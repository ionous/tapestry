package walk

import (
	"log"
	r "reflect"

	"git.sr.ht/~ionous/tapestry/support/tag"
)

// provides depth first iteration a tapestry commands.
// should either be passed a single autogenerated command, a slice of them, or a slot for them.
// ( wants the concrete value, not a pointer to one )
// other values have undefined results and may panic.
// the returned iterator is ready to use, and doesn't require an initial call to Next()
func NewWalker(root r.Value) *Walker {
	return &Walker{curr: root, focus: root}
}

// If a command, a slot for a command, and slices of commands or slots,
// can all be thought of as containers of values,
// and values might be native primitive values or other containers,
// then Walker provides a depth first traversal of those values.
//
// To indicate the start of a container, returns the container itself;
// returns an invalid (terminal) value to indicate the end of a container;
// otherwise returns a native value.
// In this context, a slice of primitives values is handled as a single value.
type Walker struct {
	// contains the next state of the parent container, if any.
	parent *Walker
	// the current container, and the current position within that container
	// focus becomes invalid at the end of a struct or slice ( to indicate that end )
	curr, focus r.Value
	tag         tag.StructTag // cached tag of the current field
	index       int           // *next* index in a slice, or field in a struct
}

// the current command struct or a slice of commands
func (w *Walker) Container() r.Value {
	return w.curr
}

// when initial is true, returns the container;
// when terminal is true, returns invalid;
// otherwise returns a current field or element within a container.
func (w *Walker) Value() r.Value {
	return w.focus
}

// at the end of the a command or slice of commands.
func (w *Walker) Initial() (okay bool) {
	switch w.focus.Kind() {
	case r.Interface, r.Slice, r.Struct:
		okay = w.index == 0
	}
	return okay
}

// at the end of the a command or slice of commands.
func (w *Walker) Terminal() bool {
	return !w.focus.IsValid()
}

// true if the container is a slice of commands.
func (w *Walker) Repeating() bool {
	return w.curr.Kind() == r.Slice
}

// only valid for command fields panics otherwise
func (w *Walker) Optional() bool {
	return w.Tag().Exists("optional")
}

// only valid for command fields panics otherwise
func (w *Walker) Label() string {
	label, _ := w.Tag().Find("label")
	return label
}

func (w *Walker) Index() int {
	return w.index - 1
}

// only valid for command fields; panics otherwise
func (w *Walker) Field() (ret r.StructField) {
	if k := w.curr.Kind(); k != r.Struct || w.index == 0 {
		panic("fields only make sense for structs")
	} else {
		ret = w.curr.Type().Field(w.index - 1)
	}
	return
}

// only valid for command fields; panics otherwise
func (w *Walker) Tag() (ret tag.StructTag) {
	if len(w.tag) == 0 {
		field := w.Field()
		w.tag = tag.ReadTag(field.Tag)
	}
	return w.tag
}

// prepare access to a (new) value
func (w *Walker) Next() bool {
	switch curr := w.curr; curr.Kind() {
	case r.Interface:
		w.step(func() int { return 0 }, func(int) (_ r.Value) { return })

	case r.Slice:
		// to be here, we must be unpacking a slice of slots or flow
		// we would have already returned value *as* the slice
		w.step(curr.Len, curr.Index)

	case r.Struct:
		// embedded flow
		// zero index, the state before the first call to Next(), indicates the flow itself
		// on first Next() we want to return the zeroth field; so "index" is used directly as the index.
		w.step(curr.NumField, curr.Field)

	default:
		// ex. Array, Uintptr, Complex64, Complex128, Chan, Func,
		// Map, Pointer, UnsafePointer, Invalid
		log.Printf("unexpected %s(%s) in generated types", curr.Kind(), curr.Type())
		panic("unexpected generated type")
	}

	return w.curr.IsValid()
}

// step to, or into, the passed value.
func (w *Walker) step(cnt func() int, get func(int) r.Value) {
	if was, at := w.focus, w.index; !was.IsValid() {
		if w.parent != nil {
			*w = *w.parent // after a terminal state, pop to the parent.
		} else {
			*w = Walker{}
		}
	} else {
		var nextField r.Value
		if num := cnt(); at < num {
			nextField = get(at)
		}
		w.focus, w.index = nextField, at+1
		w.tag = tag.StructTag("")
		// first, return the field itself
		if at > 0 {
			// then look at the last returned field to see if its a container.
			if firstInner, descend := stepInto(was); descend {
				newParent := *w // remember the nextField
				*w = Walker{curr: was, focus: firstInner, parent: &newParent, index: 1}
			}
		}
	}
}

// descend into the first value of a container
// returns true if there's a valid first field to descend into
func stepInto(v r.Value) (ret r.Value, okay bool) {
	switch k := v.Kind(); k {
	case r.Interface:
		if !v.IsNil() {
			// unpack the interface, and then: we always fill the interfaces with pointers
			ret = v.Elem().Elem()
		}
		okay = true
	case r.Struct:
		if v.NumField() != 0 { // empty structs arent really a thing.
			ret = v.Field(0)
		}
		okay = true
	case r.Slice:
		// if and only if its a slice of flows or slots
		if elKind := v.Type().Elem().Kind(); elKind == r.Interface || elKind == r.Struct {
			if v.Len() != 0 {
				ret = v.Index(0)
			}
			okay = true
		}
	}
	return
}
