package match

import (
	"errors"
	"fmt"
	"slices"
	"strings"
	"unicode"

	"github.com/ionous/tell/charm"
	"github.com/ionous/tell/charmed"
	"github.com/ionous/tell/runes"
)

// position of a token
type Pos struct{ X, Y int }

func (p Pos) String() string {
	return fmt.Sprintf("pos: %d,%d", p.Y, p.X)
}

//go:generate stringer -type=Type
type Type int

// types of tokens
const (
	Invalid       Type = iota // placeholder, not generated by the tokenizer
	Comma                     // a literal comma
	Comment                   // # something
	Parenthetical             // ( something )
	Quoted                    // quoted string
	Stop                      // full stop or other terminal
	String                    // loosely defined here
	Tell                      // tell subdoc

	// Number? but need to handle trailing decimals: "the age is 45."
)

// special runes
const (
	runeComma  = ','
	runeOpener = '('
	runeCloser = ')'
)

// callback when a new token exists
// tbd: maybe a channel instead?
type Notifier interface {
	Decoded(Pos, Type, any) error
}

// read pieces of plain text documents
type Tokenizer struct {
	Notifier
	curr, start Pos
}

func NewTokenizer(n Notifier) charm.State {
	t := Tokenizer{Notifier: n}
	return t.Decode()
}

// return a state to parse a stream of runes and notify as they are detected.
func (n Tokenizer) Decode() charm.State {
	return charm.Parallel("decode",
		n.nextToken(),
		charmed.DecodePos(&n.curr.Y, &n.curr.X),
	)
}

func (n *Tokenizer) nextToken() charm.State {
	return charm.Step(eatWhitespace(), n.tokenize())
}

// tell Notifier of the new token/value pair
// and then process the next rune (q)
// ( combining the two simplifies error handling in some cases )
func (n *Tokenizer) notifyNext(q rune, t Type, v any) (ret charm.State) {
	if e := n.Notifier.Decoded(n.start, t, v); e != nil {
		ret = charm.Error(e)
	} else {
		ret = send(n.nextToken(), q)
	}
	return
}

// tell Notifier of the new token/value pair
func (n *Tokenizer) notifyAfter(t Type, v any) (ret charm.State) {
	if e := n.Notifier.Decoded(n.start, t, v); e != nil {
		ret = charm.Error(e)
	} else {
		ret = n.nextToken()
	}
	return
}

func (n *Tokenizer) tokenize() charm.State {
	return charm.Statement("tokenize", func(q rune) (ret charm.State) {
		n.start = n.curr
		switch q {
		// fix? matchHash has/had a filter on bad punctuation
		// ex.  r != '-' && unicode.IsPunct(r)
		case runes.HTab:
			ret = charm.Error(errors.New("tabs are invalid whitespace"))

		case runes.Hash:
			ret = n.commentDecoder() // unlike .tell; eats the hash

		case runes.InterpretQuote: // doublequote
			ret = n.interpretDecoding()

		case runes.RawQuote: // backtick... maybe.
			ret = n.rawDecoding()

		case runes.Colon:
			includeComments := true
			ret = DecodeDoc(n.notifyTell, includeComments)

		case runeComma:
			ret = n.notifyAfter(Comma, q)

		case runeOpener:
			ret = n.readParens()

		default:
			switch {
			case unicode.In(q, unicode.Terminal_Punctuation):
				ret = n.notifyAfter(Stop, q)

			case unicode.IsPrint(q):
				next := n.wordDecoder()
				ret = send(next, q)
			}
		}
		return
	})
}

// a single word -- roughly, letters and numbers ending with space (or eof)
// but also, commas, fullstops, and maybe a few other things.
func (n *Tokenizer) wordDecoder() charm.State {
	// fix: hash the string as its read, and send the pair of hash and string
	var b strings.Builder
	return charm.Self("roxanne", func(self charm.State, q rune) (ret charm.State) {
		// things that end words. words roxxane, words.
		fini := slices.Contains([]rune{
			runes.Newline,
			runes.Eof,
		}, q) || unicode.In(q, unicode.Space, unicode.Terminal_Punctuation)
		if fini {
			ret = n.notifyNext(q, String, b.String())
		} else if !unicode.IsPrint(q) {
			ret = charm.Error(fmt.Errorf("unknown rune %c", q))
		} else {
			b.WriteRune(q)
			ret = self
		}
		return
	})
}

// read comments but strip leading hash
func (n *Tokenizer) commentDecoder() charm.State {
	var b strings.Builder
	var gotSpace bool
	return charm.Self("comments", func(self charm.State, q rune) (ret charm.State) {
		switch q {
		default:
			if gotSpace {
				b.WriteRune(q)
				ret = self
			} else if q == runes.Space {
				gotSpace = true
				ret = self
			} else {
				ret = charm.Error(fmt.Errorf("expected a space after comment hash, not %c", q))
			}
		case runes.Newline, runes.Eof:
			ret = n.notifyNext(q, Comment, b.String())
		}
		return
	})
}

// quoted string and heredoc decoder
// fix: remember the quoted string types ( for more/accurate reconstruction );
// flag terminal in the process ( ex. return a quoted struct with the relevant info )
func (n *Tokenizer) interpretDecoding() charm.State {
	var d charmed.QuoteDecoder
	return charm.Step(d.Interpret(), charm.Statement("interpreted",
		func(q rune) charm.State {
			return n.notifyNext(q, Quoted, d.String())
		}))
}

func (n *Tokenizer) rawDecoding() charm.State {
	var d charmed.QuoteDecoder
	return charm.Step(d.Record(), charm.Statement("recorded",
		func(q rune) charm.State {
			return n.notifyNext(q, Quoted, d.String())
		}))
}

func (n *Tokenizer) readParens() charm.State {
	var str strings.Builder
	var tailSpaces int
	return charm.Self("readParens", func(self charm.State, q rune) (ret charm.State) {
		switch q {
		case runeCloser:
			out := str.String()
			ret = n.notifyAfter(Parenthetical, out[:len(out)-tailSpaces])

		case runeOpener, runes.Newline, runes.Eof, runes.HTab:
			e := charm.InvalidRune(q)
			ret = charm.Error(e)

		default:
			// skip initial spaces
			if space := q == runes.Space; !space || str.Len() > 0 {
				str.WriteRune(q)
				// count trailing spaces
				if !space {
					tailSpaces = 0
				} else {
					tailSpaces++
				}
			}
			ret = self // loop...
		}
		return
	})
}

// received a document or an error from our async helper
func (n *Tokenizer) notifyTell(q rune, content any) (ret charm.State) {
	if e := content.(error); e != nil {
		ret = charm.Error(e)
	} else {
		ret = n.notifyNext(q, Tell, content)
	}
	return
}
