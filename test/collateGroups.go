package test

import (
	"git.sr.ht/~ionous/tapestry/affine"
	"git.sr.ht/~ionous/tapestry/dl/call"
	"git.sr.ht/~ionous/tapestry/dl/list"
	"git.sr.ht/~ionous/tapestry/dl/logic"
	"git.sr.ht/~ionous/tapestry/dl/object"
	"git.sr.ht/~ionous/tapestry/rt"
	"git.sr.ht/~ionous/tapestry/test/testpat"
)

var runCollateGroups = list.ListReduce{
	Target:      object.Variable("collation"),
	List:        &call.FromRecordList{Value: object.Variable("settings")},
	PatternName: ("collate groups")}

// pattern:
type CollateGroups struct {
	// args
	Settings  GroupSettings  // constant input
	Collation GroupCollation // accumulator; FIX: this should be []GroupedObjects -- no need for the wrapping structure.

	// locals
	Found bool
	Group GroupedObjects
}

// called multiple times: once for each "setting"
var collateGroups = testpat.Pattern{
	Name:   "collate groups",
	Labels: []string{"settings", "collation"},
	Return: "collation",
	Fields: []rt.Field{
		// arguments:
		{Name: "settings", Affinity: affine.Record, Type: "group settings"},
		{Name: "collation", Affinity: affine.Record, Type: "group collation"},
		// locals:
		{Name: "found", Affinity: affine.Bool},
		{Name: "group", Affinity: affine.Record, Type: "grouped objects"},
	},
	Rules: []rt.Rule{{
		Exe: []rt.Execute{
			// walk collation.groups, set .idx to whichever best matches.
			// fix: could this be list find? ( could list find take an optional pattern )
			&list.ListRepeat{
				List: &call.FromRecordList{Value: object.Variable("collation", "groups")},
				As:   ("el"),
				Exe: []rt.Execute{
					&logic.ChooseBranch{
						Condition: &call.CallPattern{
							PatternName: ("match groups"),
							Arguments: call.MakeArgs(
								&call.FromRecord{Value: object.Variable("settings")},
								// "el" is specified by us during ListRepeat
								// fix: use a special $element name, and require "Up" scope to reach out.
								// ( or allow locals and force them to assign )
								&call.FromRecord{Value: object.Variable("el", "settings")},
							),
						},
						Exe: []rt.Execute{
							&object.SetValue{
								Target: object.Variable("found"),
								Value:  &call.FromBool{Value: B(true)},
							},
							// found a matching group? add the object to it group.
							&list.ListPush{
								// "index" is generated by ListRepeat -- fix: make the name more special?
								Target: object.Variable(
									"collation", "groups",
									&object.AtIndex{Index: object.Variable("index")}, "objects"),
								Value: &call.FromText{Value: object.Variable("settings", "name")}},
							// todo: implement a "break"
						},
					},
				}}, // end go-each
			&logic.ChooseBranch{
				// didn't find a matching group?
				Condition: &logic.Not{Test: object.Variable("found")},
				// pack the object and its settings into the local 'group'
				// then push the group into the groups.
				// FIX: a command to MakeRecord from args, and remove the local.
				Exe: []rt.Execute{
					&object.SetValue{
						Target: object.Variable("group", "settings"),
						Value:  &call.FromRecord{Value: object.Variable("settings")}},
					&list.ListPush{
						Target: object.Variable("group", "objects"),
						Value:  &call.FromText{Value: object.Variable("settings", "name")}},
					&list.ListPush{
						Target: object.Variable("collation", "groups"),
						Value:  &call.FromRecord{Value: object.Variable("group")},
					},
				}, // end true
			},
		}},
	},
}
