package test

import (
	"git.sr.ht/~ionous/tapestry/affine"
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/list"
	"git.sr.ht/~ionous/tapestry/rt"
	"git.sr.ht/~ionous/tapestry/test/testpat"
)

var runCollateGroups = list.ListReduce{
	Target:      assign.Variable("collation"),
	List:        &assign.FromRecordList{Value: assign.Variable("settings")},
	PatternName: W("collate groups")}

// pattern:
type CollateGroups struct {
	// args
	Settings  GroupSettings  // constant input
	Collation GroupCollation // accumulator; FIX: this should be []GroupedObjects -- no need for the wrapping structure.

	// locals
	Found bool
	Group GroupedObjects
}

// called multiple times: once for each "setting"
var collateGroups = testpat.Pattern{
	Name:   "collate groups",
	Labels: []string{"settings", "collation"},
	Return: "collation",
	Fields: []rt.Field{
		// arguments:
		{Name: "settings", Affinity: affine.Record, Type: "group settings"},
		{Name: "collation", Affinity: affine.Record, Type: "group collation"},
		// locals:
		{Name: "found", Affinity: affine.Bool},
		{Name: "group", Affinity: affine.Record, Type: "grouped objects"},
	},
	Rules: []rt.Rule{{
		Exe: core.MakeActivity(
			// walk collation.groups, set .idx to whichever best matches.
			// fix: could this be list find? ( could list find take an optional pattern )
			&list.ListEach{
				List: &assign.FromRecordList{Value: assign.Variable("collation", "groups")},
				As:   W("el"),
				Exe: core.MakeActivity(
					&core.ChooseBranch{
						If: &assign.CallPattern{
							PatternName: P("match groups"),
							Arguments: core.MakeArgs(
								&assign.FromRecord{Value: assign.Variable("settings")},
								// "el" is specified by us during ListEach
								// fix: use a special $element name, and require "Up" scope to reach out.
								// ( or allow locals and force them to assign )
								&assign.FromRecord{Value: assign.Variable("el", "settings")},
							),
						},
						Exe: core.MakeActivity(
							&assign.SetValue{
								Target: assign.Variable("found"),
								Value:  &assign.FromBool{Value: B(true)},
							},
							// found a matching group? add the object to it group.
							&list.ListPush{
								// "index" is generated by ListEach -- fix: make the name more special?
								Target: assign.Variable(
									"collation", "groups",
									&assign.AtIndex{Index: assign.Variable("index")}, "objects"),
								Value: &assign.FromText{Value: assign.Variable("settings", "name")}},
							// todo: implement a "break"
						),
					},
				)}, // end go-each
			&core.ChooseBranch{
				// didn't find a matching group?
				If: &core.Not{Test: assign.Variable("found")},
				// pack the object and its settings into the local 'group'
				// then push the group into the groups.
				// FIX: a command to MakeRecord from args, and remove the local.
				Exe: core.MakeActivity(
					&assign.SetValue{
						Target: assign.Variable("group", "settings"),
						Value:  &assign.FromRecord{Value: assign.Variable("settings")}},
					&list.ListPush{
						Target: assign.Variable("group", "objects"),
						Value:  &assign.FromText{Value: assign.Variable("settings", "name")}},
					&list.ListPush{
						Target: assign.Variable("collation", "groups"),
						Value:  &assign.FromRecord{Value: assign.Variable("group")},
					},
				), // end true
			},
		)},
	},
}
