// Code generated by capnpc-go. DO NOT EDIT.

package all

import (
	core "git.sr.ht/~ionous/iffy/idl/core"
	debug "git.sr.ht/~ionous/iffy/idl/debug"
	grammar "git.sr.ht/~ionous/iffy/idl/grammar"
	list "git.sr.ht/~ionous/iffy/idl/list"
	rel "git.sr.ht/~ionous/iffy/idl/rel"
	render "git.sr.ht/~ionous/iffy/idl/render"
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type AssignmentImpl struct{ capnp.Struct }
type AssignmentImpl_Which uint16

const (
	AssignmentImpl_Which_bool           AssignmentImpl_Which = 0
	AssignmentImpl_Which_getFrom        AssignmentImpl_Which = 1
	AssignmentImpl_Which_num            AssignmentImpl_Which = 2
	AssignmentImpl_Which_nums           AssignmentImpl_Which = 3
	AssignmentImpl_Which_rec            AssignmentImpl_Which = 4
	AssignmentImpl_Which_recs           AssignmentImpl_Which = 5
	AssignmentImpl_Which_renderArgs     AssignmentImpl_Which = 6
	AssignmentImpl_Which_renderRefFlags AssignmentImpl_Which = 7
	AssignmentImpl_Which_txt            AssignmentImpl_Which = 8
	AssignmentImpl_Which_txts           AssignmentImpl_Which = 9
	AssignmentImpl_Which_var            AssignmentImpl_Which = 10
)

func (w AssignmentImpl_Which) String() string {
	const s = "boolgetFromnumnumsrecrecsrenderArgsrenderRefFlagstxttxtsvar"
	switch w {
	case AssignmentImpl_Which_bool:
		return s[0:4]
	case AssignmentImpl_Which_getFrom:
		return s[4:11]
	case AssignmentImpl_Which_num:
		return s[11:14]
	case AssignmentImpl_Which_nums:
		return s[14:18]
	case AssignmentImpl_Which_rec:
		return s[18:21]
	case AssignmentImpl_Which_recs:
		return s[21:25]
	case AssignmentImpl_Which_renderArgs:
		return s[25:35]
	case AssignmentImpl_Which_renderRefFlags:
		return s[35:49]
	case AssignmentImpl_Which_txt:
		return s[49:52]
	case AssignmentImpl_Which_txts:
		return s[52:56]
	case AssignmentImpl_Which_var:
		return s[56:59]

	}
	return "AssignmentImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// AssignmentImpl_TypeID is the unique identifier for the type AssignmentImpl.
const AssignmentImpl_TypeID = 0xbe1b1b92f4198c40

func NewAssignmentImpl(s *capnp.Segment) (AssignmentImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return AssignmentImpl{st}, err
}

func NewRootAssignmentImpl(s *capnp.Segment) (AssignmentImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return AssignmentImpl{st}, err
}

func ReadRootAssignmentImpl(msg *capnp.Message) (AssignmentImpl, error) {
	root, err := msg.RootPtr()
	return AssignmentImpl{root.Struct()}, err
}

func (s AssignmentImpl) String() string {
	str, _ := text.Marshal(0xbe1b1b92f4198c40, s.Struct)
	return str
}

func (s AssignmentImpl) Which() AssignmentImpl_Which {
	return AssignmentImpl_Which(s.Struct.Uint16(0))
}
func (s AssignmentImpl) Bool() (core.FromBool, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != bool")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromBool{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasBool() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetBool(v core.FromBool) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBool sets the bool field to a newly
// allocated core.FromBool struct, preferring placement in s's segment.
func (s AssignmentImpl) NewBool() (core.FromBool, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewFromBool(s.Struct.Segment())
	if err != nil {
		return core.FromBool{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) GetFrom() (core.GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return core.GetAtField{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetGetFrom(v core.GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated core.GetAtField struct, preferring placement in s's segment.
func (s AssignmentImpl) NewGetFrom() (core.GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewGetAtField(s.Struct.Segment())
	if err != nil {
		return core.GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Num() (core.FromNum, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != num")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromNum{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasNum() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetNum(v core.FromNum) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated core.FromNum struct, preferring placement in s's segment.
func (s AssignmentImpl) NewNum() (core.FromNum, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewFromNum(s.Struct.Segment())
	if err != nil {
		return core.FromNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Nums() (core.FromNumbers, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != nums")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromNumbers{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasNums() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetNums(v core.FromNumbers) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNums sets the nums field to a newly
// allocated core.FromNumbers struct, preferring placement in s's segment.
func (s AssignmentImpl) NewNums() (core.FromNumbers, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewFromNumbers(s.Struct.Segment())
	if err != nil {
		return core.FromNumbers{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Rec() (core.FromRecord, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != rec")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromRecord{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasRec() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetRec(v core.FromRecord) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRec sets the rec field to a newly
// allocated core.FromRecord struct, preferring placement in s's segment.
func (s AssignmentImpl) NewRec() (core.FromRecord, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := core.NewFromRecord(s.Struct.Segment())
	if err != nil {
		return core.FromRecord{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Recs() (core.FromRecords, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != recs")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromRecords{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasRecs() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetRecs(v core.FromRecords) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRecs sets the recs field to a newly
// allocated core.FromRecords struct, preferring placement in s's segment.
func (s AssignmentImpl) NewRecs() (core.FromRecords, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := core.NewFromRecords(s.Struct.Segment())
	if err != nil {
		return core.FromRecords{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s AssignmentImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) RenderRefFlags() (render.RenderRef, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderRef{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetRenderRefFlags(v render.RenderRef) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated render.RenderRef struct, preferring placement in s's segment.
func (s AssignmentImpl) NewRenderRefFlags() (render.RenderRef, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := render.NewRenderRef(s.Struct.Segment())
	if err != nil {
		return render.RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Txt() (core.FromText, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != txt")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromText{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasTxt() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetTxt(v core.FromText) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxt sets the txt field to a newly
// allocated core.FromText struct, preferring placement in s's segment.
func (s AssignmentImpl) NewTxt() (core.FromText, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := core.NewFromText(s.Struct.Segment())
	if err != nil {
		return core.FromText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Txts() (core.FromTexts, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != txts")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromTexts{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasTxts() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetTxts(v core.FromTexts) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxts sets the txts field to a newly
// allocated core.FromTexts struct, preferring placement in s's segment.
func (s AssignmentImpl) NewTxts() (core.FromTexts, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := core.NewFromTexts(s.Struct.Segment())
	if err != nil {
		return core.FromTexts{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Var() (core.Var, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.Var{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetVar(v core.Var) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.Var struct, preferring placement in s's segment.
func (s AssignmentImpl) NewVar() (core.Var, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := core.NewVar(s.Struct.Segment())
	if err != nil {
		return core.Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// AssignmentImpl_List is a list of AssignmentImpl.
type AssignmentImpl_List struct{ capnp.List }

// NewAssignmentImpl creates a new list of AssignmentImpl.
func NewAssignmentImpl_List(s *capnp.Segment, sz int32) (AssignmentImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return AssignmentImpl_List{l}, err
}

func (s AssignmentImpl_List) At(i int) AssignmentImpl { return AssignmentImpl{s.List.Struct(i)} }

func (s AssignmentImpl_List) Set(i int, v AssignmentImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s AssignmentImpl_List) String() string {
	str, _ := text.MarshalList(0xbe1b1b92f4198c40, s.List)
	return str
}

// AssignmentImpl_Promise is a wrapper for a AssignmentImpl promised by a client call.
type AssignmentImpl_Promise struct{ *capnp.Pipeline }

func (p AssignmentImpl_Promise) Struct() (AssignmentImpl, error) {
	s, err := p.Pipeline.Struct()
	return AssignmentImpl{s}, err
}

func (p AssignmentImpl_Promise) Bool() core.FromBool_Promise {
	return core.FromBool_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) GetFrom() core.GetAtField_Promise {
	return core.GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Num() core.FromNum_Promise {
	return core.FromNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Nums() core.FromNumbers_Promise {
	return core.FromNumbers_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Rec() core.FromRecord_Promise {
	return core.FromRecord_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Recs() core.FromRecords_Promise {
	return core.FromRecords_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) RenderRefFlags() render.RenderRef_Promise {
	return render.RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Txt() core.FromText_Promise {
	return core.FromText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Txts() core.FromTexts_Promise {
	return core.FromTexts_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Var() core.Var_Promise {
	return core.Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type BoolEvalImpl struct{ capnp.Struct }
type BoolEvalImpl_Which uint16

const (
	BoolEvalImpl_Which_allOf           BoolEvalImpl_Which = 0
	BoolEvalImpl_Which_always          BoolEvalImpl_Which = 1
	BoolEvalImpl_Which_anyOf           BoolEvalImpl_Which = 2
	BoolEvalImpl_Which_bool            BoolEvalImpl_Which = 3
	BoolEvalImpl_Which_cmpIsNum        BoolEvalImpl_Which = 4
	BoolEvalImpl_Which_cmpIsTxt        BoolEvalImpl_Which = 5
	BoolEvalImpl_Which_containsPart    BoolEvalImpl_Which = 6
	BoolEvalImpl_Which_countOfTrigger  BoolEvalImpl_Which = 7
	BoolEvalImpl_Which_determineArgs   BoolEvalImpl_Which = 8
	BoolEvalImpl_Which_during          BoolEvalImpl_Which = 9
	BoolEvalImpl_Which_findList        BoolEvalImpl_Which = 10
	BoolEvalImpl_Which_getObjTrait     BoolEvalImpl_Which = 11
	BoolEvalImpl_Which_getFrom         BoolEvalImpl_Which = 12
	BoolEvalImpl_Which_hasDominion     BoolEvalImpl_Which = 13
	BoolEvalImpl_Which_isEmpty         BoolEvalImpl_Which = 14
	BoolEvalImpl_Which_isValid         BoolEvalImpl_Which = 15
	BoolEvalImpl_Which_kindOfIs        BoolEvalImpl_Which = 16
	BoolEvalImpl_Which_kindOfIsExactly BoolEvalImpl_Which = 17
	BoolEvalImpl_Which_matchesTo       BoolEvalImpl_Which = 18
	BoolEvalImpl_Which_not             BoolEvalImpl_Which = 19
	BoolEvalImpl_Which_renderArgs      BoolEvalImpl_Which = 20
	BoolEvalImpl_Which_renderRefFlags  BoolEvalImpl_Which = 21
	BoolEvalImpl_Which_sendToArgs      BoolEvalImpl_Which = 22
	BoolEvalImpl_Which_var             BoolEvalImpl_Which = 23
)

func (w BoolEvalImpl_Which) String() string {
	const s = "allOfalwaysanyOfboolcmpIsNumcmpIsTxtcontainsPartcountOfTriggerdetermineArgsduringfindListgetObjTraitgetFromhasDominionisEmptyisValidkindOfIskindOfIsExactlymatchesTonotrenderArgsrenderRefFlagssendToArgsvar"
	switch w {
	case BoolEvalImpl_Which_allOf:
		return s[0:5]
	case BoolEvalImpl_Which_always:
		return s[5:11]
	case BoolEvalImpl_Which_anyOf:
		return s[11:16]
	case BoolEvalImpl_Which_bool:
		return s[16:20]
	case BoolEvalImpl_Which_cmpIsNum:
		return s[20:28]
	case BoolEvalImpl_Which_cmpIsTxt:
		return s[28:36]
	case BoolEvalImpl_Which_containsPart:
		return s[36:48]
	case BoolEvalImpl_Which_countOfTrigger:
		return s[48:62]
	case BoolEvalImpl_Which_determineArgs:
		return s[62:75]
	case BoolEvalImpl_Which_during:
		return s[75:81]
	case BoolEvalImpl_Which_findList:
		return s[81:89]
	case BoolEvalImpl_Which_getObjTrait:
		return s[89:100]
	case BoolEvalImpl_Which_getFrom:
		return s[100:107]
	case BoolEvalImpl_Which_hasDominion:
		return s[107:118]
	case BoolEvalImpl_Which_isEmpty:
		return s[118:125]
	case BoolEvalImpl_Which_isValid:
		return s[125:132]
	case BoolEvalImpl_Which_kindOfIs:
		return s[132:140]
	case BoolEvalImpl_Which_kindOfIsExactly:
		return s[140:155]
	case BoolEvalImpl_Which_matchesTo:
		return s[155:164]
	case BoolEvalImpl_Which_not:
		return s[164:167]
	case BoolEvalImpl_Which_renderArgs:
		return s[167:177]
	case BoolEvalImpl_Which_renderRefFlags:
		return s[177:191]
	case BoolEvalImpl_Which_sendToArgs:
		return s[191:201]
	case BoolEvalImpl_Which_var:
		return s[201:204]

	}
	return "BoolEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// BoolEvalImpl_TypeID is the unique identifier for the type BoolEvalImpl.
const BoolEvalImpl_TypeID = 0xa473fbecd00e31b2

func NewBoolEvalImpl(s *capnp.Segment) (BoolEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return BoolEvalImpl{st}, err
}

func NewRootBoolEvalImpl(s *capnp.Segment) (BoolEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return BoolEvalImpl{st}, err
}

func ReadRootBoolEvalImpl(msg *capnp.Message) (BoolEvalImpl, error) {
	root, err := msg.RootPtr()
	return BoolEvalImpl{root.Struct()}, err
}

func (s BoolEvalImpl) String() string {
	str, _ := text.Marshal(0xa473fbecd00e31b2, s.Struct)
	return str
}

func (s BoolEvalImpl) Which() BoolEvalImpl_Which {
	return BoolEvalImpl_Which(s.Struct.Uint16(0))
}
func (s BoolEvalImpl) AllOf() (core.AllTrue, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != allOf")
	}
	p, err := s.Struct.Ptr(0)
	return core.AllTrue{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasAllOf() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetAllOf(v core.AllTrue) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAllOf sets the allOf field to a newly
// allocated core.AllTrue struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewAllOf() (core.AllTrue, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewAllTrue(s.Struct.Segment())
	if err != nil {
		return core.AllTrue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) Always() (core.Always, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != always")
	}
	p, err := s.Struct.Ptr(0)
	return core.Always{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasAlways() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetAlways(v core.Always) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAlways sets the always field to a newly
// allocated core.Always struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewAlways() (core.Always, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewAlways(s.Struct.Segment())
	if err != nil {
		return core.Always{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) AnyOf() (core.AnyTrue, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != anyOf")
	}
	p, err := s.Struct.Ptr(0)
	return core.AnyTrue{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasAnyOf() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetAnyOf(v core.AnyTrue) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAnyOf sets the anyOf field to a newly
// allocated core.AnyTrue struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewAnyOf() (core.AnyTrue, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewAnyTrue(s.Struct.Segment())
	if err != nil {
		return core.AnyTrue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) Bool() (core.BoolValue, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != bool")
	}
	p, err := s.Struct.Ptr(0)
	return core.BoolValue{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasBool() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetBool(v core.BoolValue) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBool sets the bool field to a newly
// allocated core.BoolValue struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewBool() (core.BoolValue, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewBoolValue(s.Struct.Segment())
	if err != nil {
		return core.BoolValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) CmpIsNum() (core.CompareNum, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != cmpIsNum")
	}
	p, err := s.Struct.Ptr(0)
	return core.CompareNum{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasCmpIsNum() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetCmpIsNum(v core.CompareNum) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCmpIsNum sets the cmpIsNum field to a newly
// allocated core.CompareNum struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewCmpIsNum() (core.CompareNum, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := core.NewCompareNum(s.Struct.Segment())
	if err != nil {
		return core.CompareNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) CmpIsTxt() (core.CompareText, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != cmpIsTxt")
	}
	p, err := s.Struct.Ptr(0)
	return core.CompareText{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasCmpIsTxt() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetCmpIsTxt(v core.CompareText) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCmpIsTxt sets the cmpIsTxt field to a newly
// allocated core.CompareText struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewCmpIsTxt() (core.CompareText, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := core.NewCompareText(s.Struct.Segment())
	if err != nil {
		return core.CompareText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) ContainsPart() (core.Includes, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != containsPart")
	}
	p, err := s.Struct.Ptr(0)
	return core.Includes{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasContainsPart() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetContainsPart(v core.Includes) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewContainsPart sets the containsPart field to a newly
// allocated core.Includes struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewContainsPart() (core.Includes, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := core.NewIncludes(s.Struct.Segment())
	if err != nil {
		return core.Includes{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) CountOfTrigger() (core.CountOf, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != countOfTrigger")
	}
	p, err := s.Struct.Ptr(0)
	return core.CountOf{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasCountOfTrigger() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetCountOfTrigger(v core.CountOf) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCountOfTrigger sets the countOfTrigger field to a newly
// allocated core.CountOf struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewCountOfTrigger() (core.CountOf, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := core.NewCountOf(s.Struct.Segment())
	if err != nil {
		return core.CountOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) DetermineArgs() (core.Determine, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Determine{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetDetermineArgs(v core.Determine) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated core.Determine struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewDetermineArgs() (core.Determine, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := core.NewDetermine(s.Struct.Segment())
	if err != nil {
		return core.Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) During() (core.During, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != during")
	}
	p, err := s.Struct.Ptr(0)
	return core.During{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasDuring() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetDuring(v core.During) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDuring sets the during field to a newly
// allocated core.During struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewDuring() (core.During, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := core.NewDuring(s.Struct.Segment())
	if err != nil {
		return core.During{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) FindList() (list.Find, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != findList")
	}
	p, err := s.Struct.Ptr(0)
	return list.Find{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasFindList() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetFindList(v list.Find) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFindList sets the findList field to a newly
// allocated list.Find struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewFindList() (list.Find, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := list.NewFind(s.Struct.Segment())
	if err != nil {
		return list.Find{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) GetObjTrait() (core.HasTrait, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != getObjTrait")
	}
	p, err := s.Struct.Ptr(0)
	return core.HasTrait{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasGetObjTrait() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetGetObjTrait(v core.HasTrait) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetObjTrait sets the getObjTrait field to a newly
// allocated core.HasTrait struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewGetObjTrait() (core.HasTrait, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := core.NewHasTrait(s.Struct.Segment())
	if err != nil {
		return core.HasTrait{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) GetFrom() (core.GetAtField, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return core.GetAtField{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetGetFrom(v core.GetAtField) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated core.GetAtField struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewGetFrom() (core.GetAtField, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := core.NewGetAtField(s.Struct.Segment())
	if err != nil {
		return core.GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) HasDominion() (core.HasDominion, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != hasDominion")
	}
	p, err := s.Struct.Ptr(0)
	return core.HasDominion{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasHasDominion() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetHasDominion(v core.HasDominion) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewHasDominion sets the hasDominion field to a newly
// allocated core.HasDominion struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewHasDominion() (core.HasDominion, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := core.NewHasDominion(s.Struct.Segment())
	if err != nil {
		return core.HasDominion{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) IsEmpty() (core.IsEmpty, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != isEmpty")
	}
	p, err := s.Struct.Ptr(0)
	return core.IsEmpty{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasIsEmpty() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetIsEmpty(v core.IsEmpty) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIsEmpty sets the isEmpty field to a newly
// allocated core.IsEmpty struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewIsEmpty() (core.IsEmpty, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := core.NewIsEmpty(s.Struct.Segment())
	if err != nil {
		return core.IsEmpty{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) IsValid() (core.ObjectExists, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != isValid")
	}
	p, err := s.Struct.Ptr(0)
	return core.ObjectExists{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasIsValid() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetIsValid(v core.ObjectExists) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIsValid sets the isValid field to a newly
// allocated core.ObjectExists struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewIsValid() (core.ObjectExists, error) {
	s.Struct.SetUint16(0, 15)
	ss, err := core.NewObjectExists(s.Struct.Segment())
	if err != nil {
		return core.ObjectExists{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) KindOfIs() (core.IsKindOf, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != kindOfIs")
	}
	p, err := s.Struct.Ptr(0)
	return core.IsKindOf{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasKindOfIs() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetKindOfIs(v core.IsKindOf) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKindOfIs sets the kindOfIs field to a newly
// allocated core.IsKindOf struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewKindOfIs() (core.IsKindOf, error) {
	s.Struct.SetUint16(0, 16)
	ss, err := core.NewIsKindOf(s.Struct.Segment())
	if err != nil {
		return core.IsKindOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) KindOfIsExactly() (core.IsExactKindOf, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != kindOfIsExactly")
	}
	p, err := s.Struct.Ptr(0)
	return core.IsExactKindOf{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasKindOfIsExactly() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetKindOfIsExactly(v core.IsExactKindOf) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKindOfIsExactly sets the kindOfIsExactly field to a newly
// allocated core.IsExactKindOf struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewKindOfIsExactly() (core.IsExactKindOf, error) {
	s.Struct.SetUint16(0, 17)
	ss, err := core.NewIsExactKindOf(s.Struct.Segment())
	if err != nil {
		return core.IsExactKindOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) MatchesTo() (core.Matches, error) {
	if s.Struct.Uint16(0) != 18 {
		panic("Which() != matchesTo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Matches{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasMatchesTo() bool {
	if s.Struct.Uint16(0) != 18 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetMatchesTo(v core.Matches) error {
	s.Struct.SetUint16(0, 18)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMatchesTo sets the matchesTo field to a newly
// allocated core.Matches struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewMatchesTo() (core.Matches, error) {
	s.Struct.SetUint16(0, 18)
	ss, err := core.NewMatches(s.Struct.Segment())
	if err != nil {
		return core.Matches{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) Not() (core.IsNotTrue, error) {
	if s.Struct.Uint16(0) != 19 {
		panic("Which() != not")
	}
	p, err := s.Struct.Ptr(0)
	return core.IsNotTrue{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasNot() bool {
	if s.Struct.Uint16(0) != 19 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetNot(v core.IsNotTrue) error {
	s.Struct.SetUint16(0, 19)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNot sets the not field to a newly
// allocated core.IsNotTrue struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewNot() (core.IsNotTrue, error) {
	s.Struct.SetUint16(0, 19)
	ss, err := core.NewIsNotTrue(s.Struct.Segment())
	if err != nil {
		return core.IsNotTrue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 20 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 20 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 20)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 20)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) RenderRefFlags() (render.RenderRef, error) {
	if s.Struct.Uint16(0) != 21 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderRef{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 21 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetRenderRefFlags(v render.RenderRef) error {
	s.Struct.SetUint16(0, 21)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated render.RenderRef struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewRenderRefFlags() (render.RenderRef, error) {
	s.Struct.SetUint16(0, 21)
	ss, err := render.NewRenderRef(s.Struct.Segment())
	if err != nil {
		return render.RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) SendToArgs() (core.Send, error) {
	if s.Struct.Uint16(0) != 22 {
		panic("Which() != sendToArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Send{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasSendToArgs() bool {
	if s.Struct.Uint16(0) != 22 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetSendToArgs(v core.Send) error {
	s.Struct.SetUint16(0, 22)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSendToArgs sets the sendToArgs field to a newly
// allocated core.Send struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewSendToArgs() (core.Send, error) {
	s.Struct.SetUint16(0, 22)
	ss, err := core.NewSend(s.Struct.Segment())
	if err != nil {
		return core.Send{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) Var() (core.Var, error) {
	if s.Struct.Uint16(0) != 23 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.Var{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 23 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetVar(v core.Var) error {
	s.Struct.SetUint16(0, 23)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.Var struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewVar() (core.Var, error) {
	s.Struct.SetUint16(0, 23)
	ss, err := core.NewVar(s.Struct.Segment())
	if err != nil {
		return core.Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// BoolEvalImpl_List is a list of BoolEvalImpl.
type BoolEvalImpl_List struct{ capnp.List }

// NewBoolEvalImpl creates a new list of BoolEvalImpl.
func NewBoolEvalImpl_List(s *capnp.Segment, sz int32) (BoolEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return BoolEvalImpl_List{l}, err
}

func (s BoolEvalImpl_List) At(i int) BoolEvalImpl { return BoolEvalImpl{s.List.Struct(i)} }

func (s BoolEvalImpl_List) Set(i int, v BoolEvalImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s BoolEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xa473fbecd00e31b2, s.List)
	return str
}

// BoolEvalImpl_Promise is a wrapper for a BoolEvalImpl promised by a client call.
type BoolEvalImpl_Promise struct{ *capnp.Pipeline }

func (p BoolEvalImpl_Promise) Struct() (BoolEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return BoolEvalImpl{s}, err
}

func (p BoolEvalImpl_Promise) AllOf() core.AllTrue_Promise {
	return core.AllTrue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) Always() core.Always_Promise {
	return core.Always_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) AnyOf() core.AnyTrue_Promise {
	return core.AnyTrue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) Bool() core.BoolValue_Promise {
	return core.BoolValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) CmpIsNum() core.CompareNum_Promise {
	return core.CompareNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) CmpIsTxt() core.CompareText_Promise {
	return core.CompareText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) ContainsPart() core.Includes_Promise {
	return core.Includes_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) CountOfTrigger() core.CountOf_Promise {
	return core.CountOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) DetermineArgs() core.Determine_Promise {
	return core.Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) During() core.During_Promise {
	return core.During_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) FindList() list.Find_Promise {
	return list.Find_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) GetObjTrait() core.HasTrait_Promise {
	return core.HasTrait_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) GetFrom() core.GetAtField_Promise {
	return core.GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) HasDominion() core.HasDominion_Promise {
	return core.HasDominion_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) IsEmpty() core.IsEmpty_Promise {
	return core.IsEmpty_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) IsValid() core.ObjectExists_Promise {
	return core.ObjectExists_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) KindOfIs() core.IsKindOf_Promise {
	return core.IsKindOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) KindOfIsExactly() core.IsExactKindOf_Promise {
	return core.IsExactKindOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) MatchesTo() core.Matches_Promise {
	return core.Matches_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) Not() core.IsNotTrue_Promise {
	return core.IsNotTrue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) RenderRefFlags() render.RenderRef_Promise {
	return render.RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) SendToArgs() core.Send_Promise {
	return core.Send_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) Var() core.Var_Promise {
	return core.Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type BrancherImpl struct{ capnp.Struct }
type BrancherImpl_Which uint16

const (
	BrancherImpl_Which_elseDoDo            BrancherImpl_Which = 0
	BrancherImpl_Which_elseIfDo            BrancherImpl_Which = 1
	BrancherImpl_Which_elseIfDoElse        BrancherImpl_Which = 2
	BrancherImpl_Which_elseIfFromAndDo     BrancherImpl_Which = 3
	BrancherImpl_Which_elseIfFromAndDoElse BrancherImpl_Which = 4
	BrancherImpl_Which_ifDo                BrancherImpl_Which = 5
	BrancherImpl_Which_ifDoElse            BrancherImpl_Which = 6
	BrancherImpl_Which_ifFromAndDo         BrancherImpl_Which = 7
	BrancherImpl_Which_ifFromAndDoElse     BrancherImpl_Which = 8
)

func (w BrancherImpl_Which) String() string {
	const s = "elseDoDoelseIfDoelseIfDoElseelseIfFromAndDoelseIfFromAndDoElseifDoifDoElseifFromAndDoifFromAndDoElse"
	switch w {
	case BrancherImpl_Which_elseDoDo:
		return s[0:8]
	case BrancherImpl_Which_elseIfDo:
		return s[8:16]
	case BrancherImpl_Which_elseIfDoElse:
		return s[16:28]
	case BrancherImpl_Which_elseIfFromAndDo:
		return s[28:43]
	case BrancherImpl_Which_elseIfFromAndDoElse:
		return s[43:62]
	case BrancherImpl_Which_ifDo:
		return s[62:66]
	case BrancherImpl_Which_ifDoElse:
		return s[66:74]
	case BrancherImpl_Which_ifFromAndDo:
		return s[74:85]
	case BrancherImpl_Which_ifFromAndDoElse:
		return s[85:100]

	}
	return "BrancherImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// BrancherImpl_TypeID is the unique identifier for the type BrancherImpl.
const BrancherImpl_TypeID = 0x805187bca398c14a

func NewBrancherImpl(s *capnp.Segment) (BrancherImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return BrancherImpl{st}, err
}

func NewRootBrancherImpl(s *capnp.Segment) (BrancherImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return BrancherImpl{st}, err
}

func ReadRootBrancherImpl(msg *capnp.Message) (BrancherImpl, error) {
	root, err := msg.RootPtr()
	return BrancherImpl{root.Struct()}, err
}

func (s BrancherImpl) String() string {
	str, _ := text.Marshal(0x805187bca398c14a, s.Struct)
	return str
}

func (s BrancherImpl) Which() BrancherImpl_Which {
	return BrancherImpl_Which(s.Struct.Uint16(0))
}
func (s BrancherImpl) ElseDoDo() (core.ChooseNothingElse, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != elseDoDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseNothingElse{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseDoDo() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseDoDo(v core.ChooseNothingElse) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseDoDo sets the elseDoDo field to a newly
// allocated core.ChooseNothingElse struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseDoDo() (core.ChooseNothingElse, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewChooseNothingElse(s.Struct.Segment())
	if err != nil {
		return core.ChooseNothingElse{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) ElseIfDo() (core.ChooseMore, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != elseIfDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseMore{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseIfDo() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseIfDo(v core.ChooseMore) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseIfDo sets the elseIfDo field to a newly
// allocated core.ChooseMore struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseIfDo() (core.ChooseMore, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewChooseMore(s.Struct.Segment())
	if err != nil {
		return core.ChooseMore{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) ElseIfDoElse() (core.ChooseMore, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != elseIfDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseMore{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseIfDoElse() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseIfDoElse(v core.ChooseMore) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseIfDoElse sets the elseIfDoElse field to a newly
// allocated core.ChooseMore struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseIfDoElse() (core.ChooseMore, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewChooseMore(s.Struct.Segment())
	if err != nil {
		return core.ChooseMore{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) ElseIfFromAndDo() (core.ChooseMoreValue, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != elseIfFromAndDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseMoreValue{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseIfFromAndDo() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseIfFromAndDo(v core.ChooseMoreValue) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseIfFromAndDo sets the elseIfFromAndDo field to a newly
// allocated core.ChooseMoreValue struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseIfFromAndDo() (core.ChooseMoreValue, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewChooseMoreValue(s.Struct.Segment())
	if err != nil {
		return core.ChooseMoreValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) ElseIfFromAndDoElse() (core.ChooseMoreValue, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != elseIfFromAndDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseMoreValue{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseIfFromAndDoElse() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseIfFromAndDoElse(v core.ChooseMoreValue) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseIfFromAndDoElse sets the elseIfFromAndDoElse field to a newly
// allocated core.ChooseMoreValue struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseIfFromAndDoElse() (core.ChooseMoreValue, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := core.NewChooseMoreValue(s.Struct.Segment())
	if err != nil {
		return core.ChooseMoreValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) IfDo() (core.ChooseAction, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != ifDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseAction{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasIfDo() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetIfDo(v core.ChooseAction) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfDo sets the ifDo field to a newly
// allocated core.ChooseAction struct, preferring placement in s's segment.
func (s BrancherImpl) NewIfDo() (core.ChooseAction, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := core.NewChooseAction(s.Struct.Segment())
	if err != nil {
		return core.ChooseAction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) IfDoElse() (core.ChooseAction, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != ifDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseAction{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasIfDoElse() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetIfDoElse(v core.ChooseAction) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfDoElse sets the ifDoElse field to a newly
// allocated core.ChooseAction struct, preferring placement in s's segment.
func (s BrancherImpl) NewIfDoElse() (core.ChooseAction, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := core.NewChooseAction(s.Struct.Segment())
	if err != nil {
		return core.ChooseAction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) IfFromAndDo() (core.ChooseValue, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != ifFromAndDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseValue{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasIfFromAndDo() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetIfFromAndDo(v core.ChooseValue) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfFromAndDo sets the ifFromAndDo field to a newly
// allocated core.ChooseValue struct, preferring placement in s's segment.
func (s BrancherImpl) NewIfFromAndDo() (core.ChooseValue, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := core.NewChooseValue(s.Struct.Segment())
	if err != nil {
		return core.ChooseValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) IfFromAndDoElse() (core.ChooseValue, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != ifFromAndDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseValue{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasIfFromAndDoElse() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetIfFromAndDoElse(v core.ChooseValue) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfFromAndDoElse sets the ifFromAndDoElse field to a newly
// allocated core.ChooseValue struct, preferring placement in s's segment.
func (s BrancherImpl) NewIfFromAndDoElse() (core.ChooseValue, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := core.NewChooseValue(s.Struct.Segment())
	if err != nil {
		return core.ChooseValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// BrancherImpl_List is a list of BrancherImpl.
type BrancherImpl_List struct{ capnp.List }

// NewBrancherImpl creates a new list of BrancherImpl.
func NewBrancherImpl_List(s *capnp.Segment, sz int32) (BrancherImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return BrancherImpl_List{l}, err
}

func (s BrancherImpl_List) At(i int) BrancherImpl { return BrancherImpl{s.List.Struct(i)} }

func (s BrancherImpl_List) Set(i int, v BrancherImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s BrancherImpl_List) String() string {
	str, _ := text.MarshalList(0x805187bca398c14a, s.List)
	return str
}

// BrancherImpl_Promise is a wrapper for a BrancherImpl promised by a client call.
type BrancherImpl_Promise struct{ *capnp.Pipeline }

func (p BrancherImpl_Promise) Struct() (BrancherImpl, error) {
	s, err := p.Pipeline.Struct()
	return BrancherImpl{s}, err
}

func (p BrancherImpl_Promise) ElseDoDo() core.ChooseNothingElse_Promise {
	return core.ChooseNothingElse_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) ElseIfDo() core.ChooseMore_Promise {
	return core.ChooseMore_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) ElseIfDoElse() core.ChooseMore_Promise {
	return core.ChooseMore_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) ElseIfFromAndDo() core.ChooseMoreValue_Promise {
	return core.ChooseMoreValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) ElseIfFromAndDoElse() core.ChooseMoreValue_Promise {
	return core.ChooseMoreValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) IfDo() core.ChooseAction_Promise {
	return core.ChooseAction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) IfDoElse() core.ChooseAction_Promise {
	return core.ChooseAction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) IfFromAndDo() core.ChooseValue_Promise {
	return core.ChooseValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) IfFromAndDoElse() core.ChooseValue_Promise {
	return core.ChooseValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ComparatorImpl struct{ capnp.Struct }
type ComparatorImpl_Which uint16

const (
	ComparatorImpl_Which_atLeast     ComparatorImpl_Which = 0
	ComparatorImpl_Which_atMost      ComparatorImpl_Which = 1
	ComparatorImpl_Which_equalTo     ComparatorImpl_Which = 2
	ComparatorImpl_Which_greaterThan ComparatorImpl_Which = 3
	ComparatorImpl_Which_lessThan    ComparatorImpl_Which = 4
	ComparatorImpl_Which_otherThan   ComparatorImpl_Which = 5
)

func (w ComparatorImpl_Which) String() string {
	const s = "atLeastatMostequalTogreaterThanlessThanotherThan"
	switch w {
	case ComparatorImpl_Which_atLeast:
		return s[0:7]
	case ComparatorImpl_Which_atMost:
		return s[7:13]
	case ComparatorImpl_Which_equalTo:
		return s[13:20]
	case ComparatorImpl_Which_greaterThan:
		return s[20:31]
	case ComparatorImpl_Which_lessThan:
		return s[31:39]
	case ComparatorImpl_Which_otherThan:
		return s[39:48]

	}
	return "ComparatorImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ComparatorImpl_TypeID is the unique identifier for the type ComparatorImpl.
const ComparatorImpl_TypeID = 0xa9233d61b2dac238

func NewComparatorImpl(s *capnp.Segment) (ComparatorImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ComparatorImpl{st}, err
}

func NewRootComparatorImpl(s *capnp.Segment) (ComparatorImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ComparatorImpl{st}, err
}

func ReadRootComparatorImpl(msg *capnp.Message) (ComparatorImpl, error) {
	root, err := msg.RootPtr()
	return ComparatorImpl{root.Struct()}, err
}

func (s ComparatorImpl) String() string {
	str, _ := text.Marshal(0xa9233d61b2dac238, s.Struct)
	return str
}

func (s ComparatorImpl) Which() ComparatorImpl_Which {
	return ComparatorImpl_Which(s.Struct.Uint16(0))
}
func (s ComparatorImpl) AtLeast() (core.GreaterOrEqual, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != atLeast")
	}
	p, err := s.Struct.Ptr(0)
	return core.GreaterOrEqual{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasAtLeast() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetAtLeast(v core.GreaterOrEqual) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAtLeast sets the atLeast field to a newly
// allocated core.GreaterOrEqual struct, preferring placement in s's segment.
func (s ComparatorImpl) NewAtLeast() (core.GreaterOrEqual, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewGreaterOrEqual(s.Struct.Segment())
	if err != nil {
		return core.GreaterOrEqual{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) AtMost() (core.LessOrEqual, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != atMost")
	}
	p, err := s.Struct.Ptr(0)
	return core.LessOrEqual{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasAtMost() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetAtMost(v core.LessOrEqual) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAtMost sets the atMost field to a newly
// allocated core.LessOrEqual struct, preferring placement in s's segment.
func (s ComparatorImpl) NewAtMost() (core.LessOrEqual, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewLessOrEqual(s.Struct.Segment())
	if err != nil {
		return core.LessOrEqual{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) EqualTo() (core.EqualTo, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != equalTo")
	}
	p, err := s.Struct.Ptr(0)
	return core.EqualTo{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasEqualTo() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetEqualTo(v core.EqualTo) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEqualTo sets the equalTo field to a newly
// allocated core.EqualTo struct, preferring placement in s's segment.
func (s ComparatorImpl) NewEqualTo() (core.EqualTo, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewEqualTo(s.Struct.Segment())
	if err != nil {
		return core.EqualTo{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) GreaterThan() (core.GreaterThan, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != greaterThan")
	}
	p, err := s.Struct.Ptr(0)
	return core.GreaterThan{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasGreaterThan() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetGreaterThan(v core.GreaterThan) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGreaterThan sets the greaterThan field to a newly
// allocated core.GreaterThan struct, preferring placement in s's segment.
func (s ComparatorImpl) NewGreaterThan() (core.GreaterThan, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewGreaterThan(s.Struct.Segment())
	if err != nil {
		return core.GreaterThan{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) LessThan() (core.LessThan, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != lessThan")
	}
	p, err := s.Struct.Ptr(0)
	return core.LessThan{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasLessThan() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetLessThan(v core.LessThan) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLessThan sets the lessThan field to a newly
// allocated core.LessThan struct, preferring placement in s's segment.
func (s ComparatorImpl) NewLessThan() (core.LessThan, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := core.NewLessThan(s.Struct.Segment())
	if err != nil {
		return core.LessThan{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) OtherThan() (core.NotEqualTo, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != otherThan")
	}
	p, err := s.Struct.Ptr(0)
	return core.NotEqualTo{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasOtherThan() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetOtherThan(v core.NotEqualTo) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewOtherThan sets the otherThan field to a newly
// allocated core.NotEqualTo struct, preferring placement in s's segment.
func (s ComparatorImpl) NewOtherThan() (core.NotEqualTo, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := core.NewNotEqualTo(s.Struct.Segment())
	if err != nil {
		return core.NotEqualTo{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ComparatorImpl_List is a list of ComparatorImpl.
type ComparatorImpl_List struct{ capnp.List }

// NewComparatorImpl creates a new list of ComparatorImpl.
func NewComparatorImpl_List(s *capnp.Segment, sz int32) (ComparatorImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ComparatorImpl_List{l}, err
}

func (s ComparatorImpl_List) At(i int) ComparatorImpl { return ComparatorImpl{s.List.Struct(i)} }

func (s ComparatorImpl_List) Set(i int, v ComparatorImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s ComparatorImpl_List) String() string {
	str, _ := text.MarshalList(0xa9233d61b2dac238, s.List)
	return str
}

// ComparatorImpl_Promise is a wrapper for a ComparatorImpl promised by a client call.
type ComparatorImpl_Promise struct{ *capnp.Pipeline }

func (p ComparatorImpl_Promise) Struct() (ComparatorImpl, error) {
	s, err := p.Pipeline.Struct()
	return ComparatorImpl{s}, err
}

func (p ComparatorImpl_Promise) AtLeast() core.GreaterOrEqual_Promise {
	return core.GreaterOrEqual_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) AtMost() core.LessOrEqual_Promise {
	return core.LessOrEqual_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) EqualTo() core.EqualTo_Promise {
	return core.EqualTo_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) GreaterThan() core.GreaterThan_Promise {
	return core.GreaterThan_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) LessThan() core.LessThan_Promise {
	return core.LessThan_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) OtherThan() core.NotEqualTo_Promise {
	return core.NotEqualTo_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ExecuteImpl struct{ capnp.Struct }
type ExecuteImpl_Which uint16

const (
	ExecuteImpl_Which_actDo                       ExecuteImpl_Which = 0
	ExecuteImpl_Which_br                          ExecuteImpl_Which = 1
	ExecuteImpl_Which_break                       ExecuteImpl_Which = 2
	ExecuteImpl_Which_determineArgs               ExecuteImpl_Which = 3
	ExecuteImpl_Which_doNothing                   ExecuteImpl_Which = 4
	ExecuteImpl_Which_doNothingWhy                ExecuteImpl_Which = 5
	ExecuteImpl_Which_eraseAtEdge                 ExecuteImpl_Which = 6
	ExecuteImpl_Which_eraseFromAtIndex            ExecuteImpl_Which = 7
	ExecuteImpl_Which_erasingAtEdgeAsDo           ExecuteImpl_Which = 8
	ExecuteImpl_Which_erasingAtEdgeAsDoElse       ExecuteImpl_Which = 9
	ExecuteImpl_Which_erasingFromAtIndexAsDo      ExecuteImpl_Which = 10
	ExecuteImpl_Which_ifDo                        ExecuteImpl_Which = 11
	ExecuteImpl_Which_ifDoElse                    ExecuteImpl_Which = 12
	ExecuteImpl_Which_ifFromAndDo                 ExecuteImpl_Which = 13
	ExecuteImpl_Which_ifFromAndDoElse             ExecuteImpl_Which = 14
	ExecuteImpl_Which_letBe                       ExecuteImpl_Which = 15
	ExecuteImpl_Which_listReduceIntoFromListUsing ExecuteImpl_Which = 16
	ExecuteImpl_Which_listReverse                 ExecuteImpl_Which = 17
	ExecuteImpl_Which_listSetIndexFrom            ExecuteImpl_Which = 18
	ExecuteImpl_Which_logValue                    ExecuteImpl_Which = 19
	ExecuteImpl_Which_mapFromListUsing            ExecuteImpl_Which = 20
	ExecuteImpl_Which_next                        ExecuteImpl_Which = 21
	ExecuteImpl_Which_p                           ExecuteImpl_Which = 22
	ExecuteImpl_Which_putObjTrait                 ExecuteImpl_Which = 23
	ExecuteImpl_Which_putFromAt                   ExecuteImpl_Which = 24
	ExecuteImpl_Which_putIntoAtEdge               ExecuteImpl_Which = 25
	ExecuteImpl_Which_putIntoAtIndex              ExecuteImpl_Which = 26
	ExecuteImpl_Which_relateToRel                 ExecuteImpl_Which = 27
	ExecuteImpl_Which_renderArgs                  ExecuteImpl_Which = 28
	ExecuteImpl_Which_repeatingAcrossAsDo         ExecuteImpl_Which = 29
	ExecuteImpl_Which_repeatingAcrossAsDoElse     ExecuteImpl_Which = 30
	ExecuteImpl_Which_repeatingDo                 ExecuteImpl_Which = 31
	ExecuteImpl_Which_sayText                     ExecuteImpl_Which = 32
	ExecuteImpl_Which_sendToArgs                  ExecuteImpl_Which = 33
	ExecuteImpl_Which_sortByOrder                 ExecuteImpl_Which = 34
	ExecuteImpl_Which_sortByOrderCase             ExecuteImpl_Which = 35
	ExecuteImpl_Which_sortUsing                   ExecuteImpl_Which = 36
	ExecuteImpl_Which_spliceStartRemoveInsert     ExecuteImpl_Which = 37
	ExecuteImpl_Which_wbr                         ExecuteImpl_Which = 38
)

func (w ExecuteImpl_Which) String() string {
	const s = "actDobrbreakdetermineArgsdoNothingdoNothingWhyeraseAtEdgeeraseFromAtIndexerasingAtEdgeAsDoerasingAtEdgeAsDoElseerasingFromAtIndexAsDoifDoifDoElseifFromAndDoifFromAndDoElseletBelistReduceIntoFromListUsinglistReverselistSetIndexFromlogValuemapFromListUsingnextpputObjTraitputFromAtputIntoAtEdgeputIntoAtIndexrelateToRelrenderArgsrepeatingAcrossAsDorepeatingAcrossAsDoElserepeatingDosayTextsendToArgssortByOrdersortByOrderCasesortUsingspliceStartRemoveInsertwbr"
	switch w {
	case ExecuteImpl_Which_actDo:
		return s[0:5]
	case ExecuteImpl_Which_br:
		return s[5:7]
	case ExecuteImpl_Which_break:
		return s[7:12]
	case ExecuteImpl_Which_determineArgs:
		return s[12:25]
	case ExecuteImpl_Which_doNothing:
		return s[25:34]
	case ExecuteImpl_Which_doNothingWhy:
		return s[34:46]
	case ExecuteImpl_Which_eraseAtEdge:
		return s[46:57]
	case ExecuteImpl_Which_eraseFromAtIndex:
		return s[57:73]
	case ExecuteImpl_Which_erasingAtEdgeAsDo:
		return s[73:90]
	case ExecuteImpl_Which_erasingAtEdgeAsDoElse:
		return s[90:111]
	case ExecuteImpl_Which_erasingFromAtIndexAsDo:
		return s[111:133]
	case ExecuteImpl_Which_ifDo:
		return s[133:137]
	case ExecuteImpl_Which_ifDoElse:
		return s[137:145]
	case ExecuteImpl_Which_ifFromAndDo:
		return s[145:156]
	case ExecuteImpl_Which_ifFromAndDoElse:
		return s[156:171]
	case ExecuteImpl_Which_letBe:
		return s[171:176]
	case ExecuteImpl_Which_listReduceIntoFromListUsing:
		return s[176:203]
	case ExecuteImpl_Which_listReverse:
		return s[203:214]
	case ExecuteImpl_Which_listSetIndexFrom:
		return s[214:230]
	case ExecuteImpl_Which_logValue:
		return s[230:238]
	case ExecuteImpl_Which_mapFromListUsing:
		return s[238:254]
	case ExecuteImpl_Which_next:
		return s[254:258]
	case ExecuteImpl_Which_p:
		return s[258:259]
	case ExecuteImpl_Which_putObjTrait:
		return s[259:270]
	case ExecuteImpl_Which_putFromAt:
		return s[270:279]
	case ExecuteImpl_Which_putIntoAtEdge:
		return s[279:292]
	case ExecuteImpl_Which_putIntoAtIndex:
		return s[292:306]
	case ExecuteImpl_Which_relateToRel:
		return s[306:317]
	case ExecuteImpl_Which_renderArgs:
		return s[317:327]
	case ExecuteImpl_Which_repeatingAcrossAsDo:
		return s[327:346]
	case ExecuteImpl_Which_repeatingAcrossAsDoElse:
		return s[346:369]
	case ExecuteImpl_Which_repeatingDo:
		return s[369:380]
	case ExecuteImpl_Which_sayText:
		return s[380:387]
	case ExecuteImpl_Which_sendToArgs:
		return s[387:397]
	case ExecuteImpl_Which_sortByOrder:
		return s[397:408]
	case ExecuteImpl_Which_sortByOrderCase:
		return s[408:423]
	case ExecuteImpl_Which_sortUsing:
		return s[423:432]
	case ExecuteImpl_Which_spliceStartRemoveInsert:
		return s[432:455]
	case ExecuteImpl_Which_wbr:
		return s[455:458]

	}
	return "ExecuteImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ExecuteImpl_TypeID is the unique identifier for the type ExecuteImpl.
const ExecuteImpl_TypeID = 0xed3ddbe86f107753

func NewExecuteImpl(s *capnp.Segment) (ExecuteImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ExecuteImpl{st}, err
}

func NewRootExecuteImpl(s *capnp.Segment) (ExecuteImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ExecuteImpl{st}, err
}

func ReadRootExecuteImpl(msg *capnp.Message) (ExecuteImpl, error) {
	root, err := msg.RootPtr()
	return ExecuteImpl{root.Struct()}, err
}

func (s ExecuteImpl) String() string {
	str, _ := text.Marshal(0xed3ddbe86f107753, s.Struct)
	return str
}

func (s ExecuteImpl) Which() ExecuteImpl_Which {
	return ExecuteImpl_Which(s.Struct.Uint16(0))
}
func (s ExecuteImpl) ActDo() (core.Activity, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != actDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Activity{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasActDo() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetActDo(v core.Activity) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewActDo sets the actDo field to a newly
// allocated core.Activity struct, preferring placement in s's segment.
func (s ExecuteImpl) NewActDo() (core.Activity, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewActivity(s.Struct.Segment())
	if err != nil {
		return core.Activity{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) Br() (core.Newline, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != br")
	}
	p, err := s.Struct.Ptr(0)
	return core.Newline{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasBr() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetBr(v core.Newline) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBr sets the br field to a newly
// allocated core.Newline struct, preferring placement in s's segment.
func (s ExecuteImpl) NewBr() (core.Newline, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewNewline(s.Struct.Segment())
	if err != nil {
		return core.Newline{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) Break() (core.Break, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != break")
	}
	p, err := s.Struct.Ptr(0)
	return core.Break{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasBreak() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetBreak(v core.Break) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBreak sets the break field to a newly
// allocated core.Break struct, preferring placement in s's segment.
func (s ExecuteImpl) NewBreak() (core.Break, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewBreak(s.Struct.Segment())
	if err != nil {
		return core.Break{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) DetermineArgs() (core.Determine, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Determine{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetDetermineArgs(v core.Determine) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated core.Determine struct, preferring placement in s's segment.
func (s ExecuteImpl) NewDetermineArgs() (core.Determine, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewDetermine(s.Struct.Segment())
	if err != nil {
		return core.Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) DoNothing() (debug.DoNothing, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != doNothing")
	}
	p, err := s.Struct.Ptr(0)
	return debug.DoNothing{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasDoNothing() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetDoNothing(v debug.DoNothing) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDoNothing sets the doNothing field to a newly
// allocated debug.DoNothing struct, preferring placement in s's segment.
func (s ExecuteImpl) NewDoNothing() (debug.DoNothing, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := debug.NewDoNothing(s.Struct.Segment())
	if err != nil {
		return debug.DoNothing{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) DoNothingWhy() (debug.DoNothing, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != doNothingWhy")
	}
	p, err := s.Struct.Ptr(0)
	return debug.DoNothing{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasDoNothingWhy() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetDoNothingWhy(v debug.DoNothing) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDoNothingWhy sets the doNothingWhy field to a newly
// allocated debug.DoNothing struct, preferring placement in s's segment.
func (s ExecuteImpl) NewDoNothingWhy() (debug.DoNothing, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := debug.NewDoNothing(s.Struct.Segment())
	if err != nil {
		return debug.DoNothing{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) EraseAtEdge() (list.EraseEdge, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != eraseAtEdge")
	}
	p, err := s.Struct.Ptr(0)
	return list.EraseEdge{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasEraseAtEdge() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetEraseAtEdge(v list.EraseEdge) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEraseAtEdge sets the eraseAtEdge field to a newly
// allocated list.EraseEdge struct, preferring placement in s's segment.
func (s ExecuteImpl) NewEraseAtEdge() (list.EraseEdge, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := list.NewEraseEdge(s.Struct.Segment())
	if err != nil {
		return list.EraseEdge{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) EraseFromAtIndex() (list.EraseIndex, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != eraseFromAtIndex")
	}
	p, err := s.Struct.Ptr(0)
	return list.EraseIndex{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasEraseFromAtIndex() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetEraseFromAtIndex(v list.EraseIndex) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEraseFromAtIndex sets the eraseFromAtIndex field to a newly
// allocated list.EraseIndex struct, preferring placement in s's segment.
func (s ExecuteImpl) NewEraseFromAtIndex() (list.EraseIndex, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := list.NewEraseIndex(s.Struct.Segment())
	if err != nil {
		return list.EraseIndex{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ErasingAtEdgeAsDo() (list.ErasingEdge, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != erasingAtEdgeAsDo")
	}
	p, err := s.Struct.Ptr(0)
	return list.ErasingEdge{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasErasingAtEdgeAsDo() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetErasingAtEdgeAsDo(v list.ErasingEdge) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewErasingAtEdgeAsDo sets the erasingAtEdgeAsDo field to a newly
// allocated list.ErasingEdge struct, preferring placement in s's segment.
func (s ExecuteImpl) NewErasingAtEdgeAsDo() (list.ErasingEdge, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := list.NewErasingEdge(s.Struct.Segment())
	if err != nil {
		return list.ErasingEdge{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ErasingAtEdgeAsDoElse() (list.ErasingEdge, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != erasingAtEdgeAsDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return list.ErasingEdge{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasErasingAtEdgeAsDoElse() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetErasingAtEdgeAsDoElse(v list.ErasingEdge) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewErasingAtEdgeAsDoElse sets the erasingAtEdgeAsDoElse field to a newly
// allocated list.ErasingEdge struct, preferring placement in s's segment.
func (s ExecuteImpl) NewErasingAtEdgeAsDoElse() (list.ErasingEdge, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := list.NewErasingEdge(s.Struct.Segment())
	if err != nil {
		return list.ErasingEdge{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ErasingFromAtIndexAsDo() (list.Erasing, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != erasingFromAtIndexAsDo")
	}
	p, err := s.Struct.Ptr(0)
	return list.Erasing{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasErasingFromAtIndexAsDo() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetErasingFromAtIndexAsDo(v list.Erasing) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewErasingFromAtIndexAsDo sets the erasingFromAtIndexAsDo field to a newly
// allocated list.Erasing struct, preferring placement in s's segment.
func (s ExecuteImpl) NewErasingFromAtIndexAsDo() (list.Erasing, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := list.NewErasing(s.Struct.Segment())
	if err != nil {
		return list.Erasing{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) IfDo() (core.ChooseAction, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != ifDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseAction{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasIfDo() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetIfDo(v core.ChooseAction) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfDo sets the ifDo field to a newly
// allocated core.ChooseAction struct, preferring placement in s's segment.
func (s ExecuteImpl) NewIfDo() (core.ChooseAction, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := core.NewChooseAction(s.Struct.Segment())
	if err != nil {
		return core.ChooseAction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) IfDoElse() (core.ChooseAction, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != ifDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseAction{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasIfDoElse() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetIfDoElse(v core.ChooseAction) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfDoElse sets the ifDoElse field to a newly
// allocated core.ChooseAction struct, preferring placement in s's segment.
func (s ExecuteImpl) NewIfDoElse() (core.ChooseAction, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := core.NewChooseAction(s.Struct.Segment())
	if err != nil {
		return core.ChooseAction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) IfFromAndDo() (core.ChooseValue, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != ifFromAndDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseValue{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasIfFromAndDo() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetIfFromAndDo(v core.ChooseValue) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfFromAndDo sets the ifFromAndDo field to a newly
// allocated core.ChooseValue struct, preferring placement in s's segment.
func (s ExecuteImpl) NewIfFromAndDo() (core.ChooseValue, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := core.NewChooseValue(s.Struct.Segment())
	if err != nil {
		return core.ChooseValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) IfFromAndDoElse() (core.ChooseValue, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != ifFromAndDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseValue{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasIfFromAndDoElse() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetIfFromAndDoElse(v core.ChooseValue) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfFromAndDoElse sets the ifFromAndDoElse field to a newly
// allocated core.ChooseValue struct, preferring placement in s's segment.
func (s ExecuteImpl) NewIfFromAndDoElse() (core.ChooseValue, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := core.NewChooseValue(s.Struct.Segment())
	if err != nil {
		return core.ChooseValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) LetBe() (core.Assign, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != letBe")
	}
	p, err := s.Struct.Ptr(0)
	return core.Assign{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasLetBe() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetLetBe(v core.Assign) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLetBe sets the letBe field to a newly
// allocated core.Assign struct, preferring placement in s's segment.
func (s ExecuteImpl) NewLetBe() (core.Assign, error) {
	s.Struct.SetUint16(0, 15)
	ss, err := core.NewAssign(s.Struct.Segment())
	if err != nil {
		return core.Assign{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ListReduceIntoFromListUsing() (list.Reduce, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != listReduceIntoFromListUsing")
	}
	p, err := s.Struct.Ptr(0)
	return list.Reduce{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasListReduceIntoFromListUsing() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetListReduceIntoFromListUsing(v list.Reduce) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewListReduceIntoFromListUsing sets the listReduceIntoFromListUsing field to a newly
// allocated list.Reduce struct, preferring placement in s's segment.
func (s ExecuteImpl) NewListReduceIntoFromListUsing() (list.Reduce, error) {
	s.Struct.SetUint16(0, 16)
	ss, err := list.NewReduce(s.Struct.Segment())
	if err != nil {
		return list.Reduce{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ListReverse() (list.ReverseList, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != listReverse")
	}
	p, err := s.Struct.Ptr(0)
	return list.ReverseList{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasListReverse() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetListReverse(v list.ReverseList) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewListReverse sets the listReverse field to a newly
// allocated list.ReverseList struct, preferring placement in s's segment.
func (s ExecuteImpl) NewListReverse() (list.ReverseList, error) {
	s.Struct.SetUint16(0, 17)
	ss, err := list.NewReverseList(s.Struct.Segment())
	if err != nil {
		return list.ReverseList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ListSetIndexFrom() (list.Set, error) {
	if s.Struct.Uint16(0) != 18 {
		panic("Which() != listSetIndexFrom")
	}
	p, err := s.Struct.Ptr(0)
	return list.Set{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasListSetIndexFrom() bool {
	if s.Struct.Uint16(0) != 18 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetListSetIndexFrom(v list.Set) error {
	s.Struct.SetUint16(0, 18)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewListSetIndexFrom sets the listSetIndexFrom field to a newly
// allocated list.Set struct, preferring placement in s's segment.
func (s ExecuteImpl) NewListSetIndexFrom() (list.Set, error) {
	s.Struct.SetUint16(0, 18)
	ss, err := list.NewSet(s.Struct.Segment())
	if err != nil {
		return list.Set{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) LogValue() (debug.Log, error) {
	if s.Struct.Uint16(0) != 19 {
		panic("Which() != logValue")
	}
	p, err := s.Struct.Ptr(0)
	return debug.Log{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasLogValue() bool {
	if s.Struct.Uint16(0) != 19 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetLogValue(v debug.Log) error {
	s.Struct.SetUint16(0, 19)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLogValue sets the logValue field to a newly
// allocated debug.Log struct, preferring placement in s's segment.
func (s ExecuteImpl) NewLogValue() (debug.Log, error) {
	s.Struct.SetUint16(0, 19)
	ss, err := debug.NewLog(s.Struct.Segment())
	if err != nil {
		return debug.Log{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) MapFromListUsing() (list.Map, error) {
	if s.Struct.Uint16(0) != 20 {
		panic("Which() != mapFromListUsing")
	}
	p, err := s.Struct.Ptr(0)
	return list.Map{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasMapFromListUsing() bool {
	if s.Struct.Uint16(0) != 20 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetMapFromListUsing(v list.Map) error {
	s.Struct.SetUint16(0, 20)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMapFromListUsing sets the mapFromListUsing field to a newly
// allocated list.Map struct, preferring placement in s's segment.
func (s ExecuteImpl) NewMapFromListUsing() (list.Map, error) {
	s.Struct.SetUint16(0, 20)
	ss, err := list.NewMap(s.Struct.Segment())
	if err != nil {
		return list.Map{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) Next() (core.Next, error) {
	if s.Struct.Uint16(0) != 21 {
		panic("Which() != next")
	}
	p, err := s.Struct.Ptr(0)
	return core.Next{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasNext() bool {
	if s.Struct.Uint16(0) != 21 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetNext(v core.Next) error {
	s.Struct.SetUint16(0, 21)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNext sets the next field to a newly
// allocated core.Next struct, preferring placement in s's segment.
func (s ExecuteImpl) NewNext() (core.Next, error) {
	s.Struct.SetUint16(0, 21)
	ss, err := core.NewNext(s.Struct.Segment())
	if err != nil {
		return core.Next{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) P() (core.Paragraph, error) {
	if s.Struct.Uint16(0) != 22 {
		panic("Which() != p")
	}
	p, err := s.Struct.Ptr(0)
	return core.Paragraph{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasP() bool {
	if s.Struct.Uint16(0) != 22 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetP(v core.Paragraph) error {
	s.Struct.SetUint16(0, 22)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewP sets the p field to a newly
// allocated core.Paragraph struct, preferring placement in s's segment.
func (s ExecuteImpl) NewP() (core.Paragraph, error) {
	s.Struct.SetUint16(0, 22)
	ss, err := core.NewParagraph(s.Struct.Segment())
	if err != nil {
		return core.Paragraph{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) PutObjTrait() (core.SetTrait, error) {
	if s.Struct.Uint16(0) != 23 {
		panic("Which() != putObjTrait")
	}
	p, err := s.Struct.Ptr(0)
	return core.SetTrait{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasPutObjTrait() bool {
	if s.Struct.Uint16(0) != 23 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetPutObjTrait(v core.SetTrait) error {
	s.Struct.SetUint16(0, 23)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPutObjTrait sets the putObjTrait field to a newly
// allocated core.SetTrait struct, preferring placement in s's segment.
func (s ExecuteImpl) NewPutObjTrait() (core.SetTrait, error) {
	s.Struct.SetUint16(0, 23)
	ss, err := core.NewSetTrait(s.Struct.Segment())
	if err != nil {
		return core.SetTrait{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) PutFromAt() (core.PutAtField, error) {
	if s.Struct.Uint16(0) != 24 {
		panic("Which() != putFromAt")
	}
	p, err := s.Struct.Ptr(0)
	return core.PutAtField{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasPutFromAt() bool {
	if s.Struct.Uint16(0) != 24 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetPutFromAt(v core.PutAtField) error {
	s.Struct.SetUint16(0, 24)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPutFromAt sets the putFromAt field to a newly
// allocated core.PutAtField struct, preferring placement in s's segment.
func (s ExecuteImpl) NewPutFromAt() (core.PutAtField, error) {
	s.Struct.SetUint16(0, 24)
	ss, err := core.NewPutAtField(s.Struct.Segment())
	if err != nil {
		return core.PutAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) PutIntoAtEdge() (list.PutEdge, error) {
	if s.Struct.Uint16(0) != 25 {
		panic("Which() != putIntoAtEdge")
	}
	p, err := s.Struct.Ptr(0)
	return list.PutEdge{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasPutIntoAtEdge() bool {
	if s.Struct.Uint16(0) != 25 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetPutIntoAtEdge(v list.PutEdge) error {
	s.Struct.SetUint16(0, 25)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPutIntoAtEdge sets the putIntoAtEdge field to a newly
// allocated list.PutEdge struct, preferring placement in s's segment.
func (s ExecuteImpl) NewPutIntoAtEdge() (list.PutEdge, error) {
	s.Struct.SetUint16(0, 25)
	ss, err := list.NewPutEdge(s.Struct.Segment())
	if err != nil {
		return list.PutEdge{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) PutIntoAtIndex() (list.PutIndex, error) {
	if s.Struct.Uint16(0) != 26 {
		panic("Which() != putIntoAtIndex")
	}
	p, err := s.Struct.Ptr(0)
	return list.PutIndex{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasPutIntoAtIndex() bool {
	if s.Struct.Uint16(0) != 26 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetPutIntoAtIndex(v list.PutIndex) error {
	s.Struct.SetUint16(0, 26)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPutIntoAtIndex sets the putIntoAtIndex field to a newly
// allocated list.PutIndex struct, preferring placement in s's segment.
func (s ExecuteImpl) NewPutIntoAtIndex() (list.PutIndex, error) {
	s.Struct.SetUint16(0, 26)
	ss, err := list.NewPutIndex(s.Struct.Segment())
	if err != nil {
		return list.PutIndex{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RelateToRel() (rel.Relate, error) {
	if s.Struct.Uint16(0) != 27 {
		panic("Which() != relateToRel")
	}
	p, err := s.Struct.Ptr(0)
	return rel.Relate{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRelateToRel() bool {
	if s.Struct.Uint16(0) != 27 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRelateToRel(v rel.Relate) error {
	s.Struct.SetUint16(0, 27)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRelateToRel sets the relateToRel field to a newly
// allocated rel.Relate struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRelateToRel() (rel.Relate, error) {
	s.Struct.SetUint16(0, 27)
	ss, err := rel.NewRelate(s.Struct.Segment())
	if err != nil {
		return rel.Relate{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 28 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 28 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 28)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 28)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RepeatingAcrossAsDo() (list.Each, error) {
	if s.Struct.Uint16(0) != 29 {
		panic("Which() != repeatingAcrossAsDo")
	}
	p, err := s.Struct.Ptr(0)
	return list.Each{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRepeatingAcrossAsDo() bool {
	if s.Struct.Uint16(0) != 29 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRepeatingAcrossAsDo(v list.Each) error {
	s.Struct.SetUint16(0, 29)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRepeatingAcrossAsDo sets the repeatingAcrossAsDo field to a newly
// allocated list.Each struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRepeatingAcrossAsDo() (list.Each, error) {
	s.Struct.SetUint16(0, 29)
	ss, err := list.NewEach(s.Struct.Segment())
	if err != nil {
		return list.Each{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RepeatingAcrossAsDoElse() (list.Each, error) {
	if s.Struct.Uint16(0) != 30 {
		panic("Which() != repeatingAcrossAsDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return list.Each{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRepeatingAcrossAsDoElse() bool {
	if s.Struct.Uint16(0) != 30 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRepeatingAcrossAsDoElse(v list.Each) error {
	s.Struct.SetUint16(0, 30)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRepeatingAcrossAsDoElse sets the repeatingAcrossAsDoElse field to a newly
// allocated list.Each struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRepeatingAcrossAsDoElse() (list.Each, error) {
	s.Struct.SetUint16(0, 30)
	ss, err := list.NewEach(s.Struct.Segment())
	if err != nil {
		return list.Each{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RepeatingDo() (core.While, error) {
	if s.Struct.Uint16(0) != 31 {
		panic("Which() != repeatingDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.While{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRepeatingDo() bool {
	if s.Struct.Uint16(0) != 31 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRepeatingDo(v core.While) error {
	s.Struct.SetUint16(0, 31)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRepeatingDo sets the repeatingDo field to a newly
// allocated core.While struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRepeatingDo() (core.While, error) {
	s.Struct.SetUint16(0, 31)
	ss, err := core.NewWhile(s.Struct.Segment())
	if err != nil {
		return core.While{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SayText() (core.Say, error) {
	if s.Struct.Uint16(0) != 32 {
		panic("Which() != sayText")
	}
	p, err := s.Struct.Ptr(0)
	return core.Say{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSayText() bool {
	if s.Struct.Uint16(0) != 32 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSayText(v core.Say) error {
	s.Struct.SetUint16(0, 32)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSayText sets the sayText field to a newly
// allocated core.Say struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSayText() (core.Say, error) {
	s.Struct.SetUint16(0, 32)
	ss, err := core.NewSay(s.Struct.Segment())
	if err != nil {
		return core.Say{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SendToArgs() (core.Send, error) {
	if s.Struct.Uint16(0) != 33 {
		panic("Which() != sendToArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Send{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSendToArgs() bool {
	if s.Struct.Uint16(0) != 33 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSendToArgs(v core.Send) error {
	s.Struct.SetUint16(0, 33)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSendToArgs sets the sendToArgs field to a newly
// allocated core.Send struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSendToArgs() (core.Send, error) {
	s.Struct.SetUint16(0, 33)
	ss, err := core.NewSend(s.Struct.Segment())
	if err != nil {
		return core.Send{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SortByOrder() (list.SortNumbers, error) {
	if s.Struct.Uint16(0) != 34 {
		panic("Which() != sortByOrder")
	}
	p, err := s.Struct.Ptr(0)
	return list.SortNumbers{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSortByOrder() bool {
	if s.Struct.Uint16(0) != 34 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSortByOrder(v list.SortNumbers) error {
	s.Struct.SetUint16(0, 34)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSortByOrder sets the sortByOrder field to a newly
// allocated list.SortNumbers struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSortByOrder() (list.SortNumbers, error) {
	s.Struct.SetUint16(0, 34)
	ss, err := list.NewSortNumbers(s.Struct.Segment())
	if err != nil {
		return list.SortNumbers{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SortByOrderCase() (list.SortText, error) {
	if s.Struct.Uint16(0) != 35 {
		panic("Which() != sortByOrderCase")
	}
	p, err := s.Struct.Ptr(0)
	return list.SortText{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSortByOrderCase() bool {
	if s.Struct.Uint16(0) != 35 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSortByOrderCase(v list.SortText) error {
	s.Struct.SetUint16(0, 35)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSortByOrderCase sets the sortByOrderCase field to a newly
// allocated list.SortText struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSortByOrderCase() (list.SortText, error) {
	s.Struct.SetUint16(0, 35)
	ss, err := list.NewSortText(s.Struct.Segment())
	if err != nil {
		return list.SortText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SortUsing() (list.SortRecords, error) {
	if s.Struct.Uint16(0) != 36 {
		panic("Which() != sortUsing")
	}
	p, err := s.Struct.Ptr(0)
	return list.SortRecords{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSortUsing() bool {
	if s.Struct.Uint16(0) != 36 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSortUsing(v list.SortRecords) error {
	s.Struct.SetUint16(0, 36)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSortUsing sets the sortUsing field to a newly
// allocated list.SortRecords struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSortUsing() (list.SortRecords, error) {
	s.Struct.SetUint16(0, 36)
	ss, err := list.NewSortRecords(s.Struct.Segment())
	if err != nil {
		return list.SortRecords{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SpliceStartRemoveInsert() (list.Splice, error) {
	if s.Struct.Uint16(0) != 37 {
		panic("Which() != spliceStartRemoveInsert")
	}
	p, err := s.Struct.Ptr(0)
	return list.Splice{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSpliceStartRemoveInsert() bool {
	if s.Struct.Uint16(0) != 37 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSpliceStartRemoveInsert(v list.Splice) error {
	s.Struct.SetUint16(0, 37)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpliceStartRemoveInsert sets the spliceStartRemoveInsert field to a newly
// allocated list.Splice struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSpliceStartRemoveInsert() (list.Splice, error) {
	s.Struct.SetUint16(0, 37)
	ss, err := list.NewSplice(s.Struct.Segment())
	if err != nil {
		return list.Splice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) Wbr() (core.Softline, error) {
	if s.Struct.Uint16(0) != 38 {
		panic("Which() != wbr")
	}
	p, err := s.Struct.Ptr(0)
	return core.Softline{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasWbr() bool {
	if s.Struct.Uint16(0) != 38 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetWbr(v core.Softline) error {
	s.Struct.SetUint16(0, 38)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewWbr sets the wbr field to a newly
// allocated core.Softline struct, preferring placement in s's segment.
func (s ExecuteImpl) NewWbr() (core.Softline, error) {
	s.Struct.SetUint16(0, 38)
	ss, err := core.NewSoftline(s.Struct.Segment())
	if err != nil {
		return core.Softline{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ExecuteImpl_List is a list of ExecuteImpl.
type ExecuteImpl_List struct{ capnp.List }

// NewExecuteImpl creates a new list of ExecuteImpl.
func NewExecuteImpl_List(s *capnp.Segment, sz int32) (ExecuteImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ExecuteImpl_List{l}, err
}

func (s ExecuteImpl_List) At(i int) ExecuteImpl { return ExecuteImpl{s.List.Struct(i)} }

func (s ExecuteImpl_List) Set(i int, v ExecuteImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s ExecuteImpl_List) String() string {
	str, _ := text.MarshalList(0xed3ddbe86f107753, s.List)
	return str
}

// ExecuteImpl_Promise is a wrapper for a ExecuteImpl promised by a client call.
type ExecuteImpl_Promise struct{ *capnp.Pipeline }

func (p ExecuteImpl_Promise) Struct() (ExecuteImpl, error) {
	s, err := p.Pipeline.Struct()
	return ExecuteImpl{s}, err
}

func (p ExecuteImpl_Promise) ActDo() core.Activity_Promise {
	return core.Activity_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) Br() core.Newline_Promise {
	return core.Newline_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) Break() core.Break_Promise {
	return core.Break_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) DetermineArgs() core.Determine_Promise {
	return core.Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) DoNothing() debug.DoNothing_Promise {
	return debug.DoNothing_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) DoNothingWhy() debug.DoNothing_Promise {
	return debug.DoNothing_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) EraseAtEdge() list.EraseEdge_Promise {
	return list.EraseEdge_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) EraseFromAtIndex() list.EraseIndex_Promise {
	return list.EraseIndex_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ErasingAtEdgeAsDo() list.ErasingEdge_Promise {
	return list.ErasingEdge_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ErasingAtEdgeAsDoElse() list.ErasingEdge_Promise {
	return list.ErasingEdge_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ErasingFromAtIndexAsDo() list.Erasing_Promise {
	return list.Erasing_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) IfDo() core.ChooseAction_Promise {
	return core.ChooseAction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) IfDoElse() core.ChooseAction_Promise {
	return core.ChooseAction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) IfFromAndDo() core.ChooseValue_Promise {
	return core.ChooseValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) IfFromAndDoElse() core.ChooseValue_Promise {
	return core.ChooseValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) LetBe() core.Assign_Promise {
	return core.Assign_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ListReduceIntoFromListUsing() list.Reduce_Promise {
	return list.Reduce_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ListReverse() list.ReverseList_Promise {
	return list.ReverseList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ListSetIndexFrom() list.Set_Promise {
	return list.Set_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) LogValue() debug.Log_Promise {
	return debug.Log_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) MapFromListUsing() list.Map_Promise {
	return list.Map_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) Next() core.Next_Promise {
	return core.Next_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) P() core.Paragraph_Promise {
	return core.Paragraph_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) PutObjTrait() core.SetTrait_Promise {
	return core.SetTrait_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) PutFromAt() core.PutAtField_Promise {
	return core.PutAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) PutIntoAtEdge() list.PutEdge_Promise {
	return list.PutEdge_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) PutIntoAtIndex() list.PutIndex_Promise {
	return list.PutIndex_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RelateToRel() rel.Relate_Promise {
	return rel.Relate_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RepeatingAcrossAsDo() list.Each_Promise {
	return list.Each_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RepeatingAcrossAsDoElse() list.Each_Promise {
	return list.Each_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RepeatingDo() core.While_Promise {
	return core.While_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SayText() core.Say_Promise {
	return core.Say_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SendToArgs() core.Send_Promise {
	return core.Send_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SortByOrder() list.SortNumbers_Promise {
	return list.SortNumbers_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SortByOrderCase() list.SortText_Promise {
	return list.SortText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SortUsing() list.SortRecords_Promise {
	return list.SortRecords_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SpliceStartRemoveInsert() list.Splice_Promise {
	return list.Splice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) Wbr() core.Softline_Promise {
	return core.Softline_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromSourceFieldsImpl struct{ capnp.Struct }
type FromSourceFieldsImpl_Which uint16

const (
	FromSourceFieldsImpl_Which_obj         FromSourceFieldsImpl_Which = 0
	FromSourceFieldsImpl_Which_rec         FromSourceFieldsImpl_Which = 1
	FromSourceFieldsImpl_Which_renderField FromSourceFieldsImpl_Which = 2
	FromSourceFieldsImpl_Which_var         FromSourceFieldsImpl_Which = 3
)

func (w FromSourceFieldsImpl_Which) String() string {
	const s = "objrecrenderFieldvar"
	switch w {
	case FromSourceFieldsImpl_Which_obj:
		return s[0:3]
	case FromSourceFieldsImpl_Which_rec:
		return s[3:6]
	case FromSourceFieldsImpl_Which_renderField:
		return s[6:17]
	case FromSourceFieldsImpl_Which_var:
		return s[17:20]

	}
	return "FromSourceFieldsImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// FromSourceFieldsImpl_TypeID is the unique identifier for the type FromSourceFieldsImpl.
const FromSourceFieldsImpl_TypeID = 0xa8c4bc295da91dba

func NewFromSourceFieldsImpl(s *capnp.Segment) (FromSourceFieldsImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return FromSourceFieldsImpl{st}, err
}

func NewRootFromSourceFieldsImpl(s *capnp.Segment) (FromSourceFieldsImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return FromSourceFieldsImpl{st}, err
}

func ReadRootFromSourceFieldsImpl(msg *capnp.Message) (FromSourceFieldsImpl, error) {
	root, err := msg.RootPtr()
	return FromSourceFieldsImpl{root.Struct()}, err
}

func (s FromSourceFieldsImpl) String() string {
	str, _ := text.Marshal(0xa8c4bc295da91dba, s.Struct)
	return str
}

func (s FromSourceFieldsImpl) Which() FromSourceFieldsImpl_Which {
	return FromSourceFieldsImpl_Which(s.Struct.Uint16(0))
}
func (s FromSourceFieldsImpl) Obj() (core.FromObj, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != obj")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromObj{Struct: p.Struct()}, err
}

func (s FromSourceFieldsImpl) HasObj() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFieldsImpl) SetObj(v core.FromObj) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObj sets the obj field to a newly
// allocated core.FromObj struct, preferring placement in s's segment.
func (s FromSourceFieldsImpl) NewObj() (core.FromObj, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewFromObj(s.Struct.Segment())
	if err != nil {
		return core.FromObj{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s FromSourceFieldsImpl) Rec() (core.FromRec, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != rec")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromRec{Struct: p.Struct()}, err
}

func (s FromSourceFieldsImpl) HasRec() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFieldsImpl) SetRec(v core.FromRec) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRec sets the rec field to a newly
// allocated core.FromRec struct, preferring placement in s's segment.
func (s FromSourceFieldsImpl) NewRec() (core.FromRec, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewFromRec(s.Struct.Segment())
	if err != nil {
		return core.FromRec{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s FromSourceFieldsImpl) RenderField() (render.RenderField, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != renderField")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderField{Struct: p.Struct()}, err
}

func (s FromSourceFieldsImpl) HasRenderField() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFieldsImpl) SetRenderField(v render.RenderField) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderField sets the renderField field to a newly
// allocated render.RenderField struct, preferring placement in s's segment.
func (s FromSourceFieldsImpl) NewRenderField() (render.RenderField, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := render.NewRenderField(s.Struct.Segment())
	if err != nil {
		return render.RenderField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s FromSourceFieldsImpl) Var() (core.FromVar, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.FromVar{Struct: p.Struct()}, err
}

func (s FromSourceFieldsImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFieldsImpl) SetVar(v core.FromVar) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.FromVar struct, preferring placement in s's segment.
func (s FromSourceFieldsImpl) NewVar() (core.FromVar, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewFromVar(s.Struct.Segment())
	if err != nil {
		return core.FromVar{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromSourceFieldsImpl_List is a list of FromSourceFieldsImpl.
type FromSourceFieldsImpl_List struct{ capnp.List }

// NewFromSourceFieldsImpl creates a new list of FromSourceFieldsImpl.
func NewFromSourceFieldsImpl_List(s *capnp.Segment, sz int32) (FromSourceFieldsImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return FromSourceFieldsImpl_List{l}, err
}

func (s FromSourceFieldsImpl_List) At(i int) FromSourceFieldsImpl {
	return FromSourceFieldsImpl{s.List.Struct(i)}
}

func (s FromSourceFieldsImpl_List) Set(i int, v FromSourceFieldsImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s FromSourceFieldsImpl_List) String() string {
	str, _ := text.MarshalList(0xa8c4bc295da91dba, s.List)
	return str
}

// FromSourceFieldsImpl_Promise is a wrapper for a FromSourceFieldsImpl promised by a client call.
type FromSourceFieldsImpl_Promise struct{ *capnp.Pipeline }

func (p FromSourceFieldsImpl_Promise) Struct() (FromSourceFieldsImpl, error) {
	s, err := p.Pipeline.Struct()
	return FromSourceFieldsImpl{s}, err
}

func (p FromSourceFieldsImpl_Promise) Obj() core.FromObj_Promise {
	return core.FromObj_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p FromSourceFieldsImpl_Promise) Rec() core.FromRec_Promise {
	return core.FromRec_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p FromSourceFieldsImpl_Promise) RenderField() render.RenderField_Promise {
	return render.RenderField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p FromSourceFieldsImpl_Promise) Var() core.FromVar_Promise {
	return core.FromVar_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type GrammarMakerImpl struct{ capnp.Struct }
type GrammarMakerImpl_Which uint16

const (
	GrammarMakerImpl_Which_aliasAsNoun    GrammarMakerImpl_Which = 0
	GrammarMakerImpl_Which_directiveScans GrammarMakerImpl_Which = 1
)

func (w GrammarMakerImpl_Which) String() string {
	const s = "aliasAsNoundirectiveScans"
	switch w {
	case GrammarMakerImpl_Which_aliasAsNoun:
		return s[0:11]
	case GrammarMakerImpl_Which_directiveScans:
		return s[11:25]

	}
	return "GrammarMakerImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// GrammarMakerImpl_TypeID is the unique identifier for the type GrammarMakerImpl.
const GrammarMakerImpl_TypeID = 0xcef0b445a44bf3c9

func NewGrammarMakerImpl(s *capnp.Segment) (GrammarMakerImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return GrammarMakerImpl{st}, err
}

func NewRootGrammarMakerImpl(s *capnp.Segment) (GrammarMakerImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return GrammarMakerImpl{st}, err
}

func ReadRootGrammarMakerImpl(msg *capnp.Message) (GrammarMakerImpl, error) {
	root, err := msg.RootPtr()
	return GrammarMakerImpl{root.Struct()}, err
}

func (s GrammarMakerImpl) String() string {
	str, _ := text.Marshal(0xcef0b445a44bf3c9, s.Struct)
	return str
}

func (s GrammarMakerImpl) Which() GrammarMakerImpl_Which {
	return GrammarMakerImpl_Which(s.Struct.Uint16(0))
}
func (s GrammarMakerImpl) AliasAsNoun() (grammar.Alias, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != aliasAsNoun")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.Alias{Struct: p.Struct()}, err
}

func (s GrammarMakerImpl) HasAliasAsNoun() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s GrammarMakerImpl) SetAliasAsNoun(v grammar.Alias) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAliasAsNoun sets the aliasAsNoun field to a newly
// allocated grammar.Alias struct, preferring placement in s's segment.
func (s GrammarMakerImpl) NewAliasAsNoun() (grammar.Alias, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := grammar.NewAlias(s.Struct.Segment())
	if err != nil {
		return grammar.Alias{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s GrammarMakerImpl) DirectiveScans() (grammar.Directive, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != directiveScans")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.Directive{Struct: p.Struct()}, err
}

func (s GrammarMakerImpl) HasDirectiveScans() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s GrammarMakerImpl) SetDirectiveScans(v grammar.Directive) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDirectiveScans sets the directiveScans field to a newly
// allocated grammar.Directive struct, preferring placement in s's segment.
func (s GrammarMakerImpl) NewDirectiveScans() (grammar.Directive, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := grammar.NewDirective(s.Struct.Segment())
	if err != nil {
		return grammar.Directive{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// GrammarMakerImpl_List is a list of GrammarMakerImpl.
type GrammarMakerImpl_List struct{ capnp.List }

// NewGrammarMakerImpl creates a new list of GrammarMakerImpl.
func NewGrammarMakerImpl_List(s *capnp.Segment, sz int32) (GrammarMakerImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return GrammarMakerImpl_List{l}, err
}

func (s GrammarMakerImpl_List) At(i int) GrammarMakerImpl { return GrammarMakerImpl{s.List.Struct(i)} }

func (s GrammarMakerImpl_List) Set(i int, v GrammarMakerImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s GrammarMakerImpl_List) String() string {
	str, _ := text.MarshalList(0xcef0b445a44bf3c9, s.List)
	return str
}

// GrammarMakerImpl_Promise is a wrapper for a GrammarMakerImpl promised by a client call.
type GrammarMakerImpl_Promise struct{ *capnp.Pipeline }

func (p GrammarMakerImpl_Promise) Struct() (GrammarMakerImpl, error) {
	s, err := p.Pipeline.Struct()
	return GrammarMakerImpl{s}, err
}

func (p GrammarMakerImpl_Promise) AliasAsNoun() grammar.Alias_Promise {
	return grammar.Alias_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p GrammarMakerImpl_Promise) DirectiveScans() grammar.Directive_Promise {
	return grammar.Directive_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type IntoTargetFieldsImpl struct{ capnp.Struct }
type IntoTargetFieldsImpl_Which uint16

const (
	IntoTargetFieldsImpl_Which_obj IntoTargetFieldsImpl_Which = 0
	IntoTargetFieldsImpl_Which_var IntoTargetFieldsImpl_Which = 1
)

func (w IntoTargetFieldsImpl_Which) String() string {
	const s = "objvar"
	switch w {
	case IntoTargetFieldsImpl_Which_obj:
		return s[0:3]
	case IntoTargetFieldsImpl_Which_var:
		return s[3:6]

	}
	return "IntoTargetFieldsImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// IntoTargetFieldsImpl_TypeID is the unique identifier for the type IntoTargetFieldsImpl.
const IntoTargetFieldsImpl_TypeID = 0x8ce88691d4f85976

func NewIntoTargetFieldsImpl(s *capnp.Segment) (IntoTargetFieldsImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return IntoTargetFieldsImpl{st}, err
}

func NewRootIntoTargetFieldsImpl(s *capnp.Segment) (IntoTargetFieldsImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return IntoTargetFieldsImpl{st}, err
}

func ReadRootIntoTargetFieldsImpl(msg *capnp.Message) (IntoTargetFieldsImpl, error) {
	root, err := msg.RootPtr()
	return IntoTargetFieldsImpl{root.Struct()}, err
}

func (s IntoTargetFieldsImpl) String() string {
	str, _ := text.Marshal(0x8ce88691d4f85976, s.Struct)
	return str
}

func (s IntoTargetFieldsImpl) Which() IntoTargetFieldsImpl_Which {
	return IntoTargetFieldsImpl_Which(s.Struct.Uint16(0))
}
func (s IntoTargetFieldsImpl) Obj() (core.IntoObj, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != obj")
	}
	p, err := s.Struct.Ptr(0)
	return core.IntoObj{Struct: p.Struct()}, err
}

func (s IntoTargetFieldsImpl) HasObj() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoTargetFieldsImpl) SetObj(v core.IntoObj) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObj sets the obj field to a newly
// allocated core.IntoObj struct, preferring placement in s's segment.
func (s IntoTargetFieldsImpl) NewObj() (core.IntoObj, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewIntoObj(s.Struct.Segment())
	if err != nil {
		return core.IntoObj{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s IntoTargetFieldsImpl) Var() (core.IntoVar, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.IntoVar{Struct: p.Struct()}, err
}

func (s IntoTargetFieldsImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoTargetFieldsImpl) SetVar(v core.IntoVar) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.IntoVar struct, preferring placement in s's segment.
func (s IntoTargetFieldsImpl) NewVar() (core.IntoVar, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewIntoVar(s.Struct.Segment())
	if err != nil {
		return core.IntoVar{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IntoTargetFieldsImpl_List is a list of IntoTargetFieldsImpl.
type IntoTargetFieldsImpl_List struct{ capnp.List }

// NewIntoTargetFieldsImpl creates a new list of IntoTargetFieldsImpl.
func NewIntoTargetFieldsImpl_List(s *capnp.Segment, sz int32) (IntoTargetFieldsImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return IntoTargetFieldsImpl_List{l}, err
}

func (s IntoTargetFieldsImpl_List) At(i int) IntoTargetFieldsImpl {
	return IntoTargetFieldsImpl{s.List.Struct(i)}
}

func (s IntoTargetFieldsImpl_List) Set(i int, v IntoTargetFieldsImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s IntoTargetFieldsImpl_List) String() string {
	str, _ := text.MarshalList(0x8ce88691d4f85976, s.List)
	return str
}

// IntoTargetFieldsImpl_Promise is a wrapper for a IntoTargetFieldsImpl promised by a client call.
type IntoTargetFieldsImpl_Promise struct{ *capnp.Pipeline }

func (p IntoTargetFieldsImpl_Promise) Struct() (IntoTargetFieldsImpl, error) {
	s, err := p.Pipeline.Struct()
	return IntoTargetFieldsImpl{s}, err
}

func (p IntoTargetFieldsImpl_Promise) Obj() core.IntoObj_Promise {
	return core.IntoObj_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p IntoTargetFieldsImpl_Promise) Var() core.IntoVar_Promise {
	return core.IntoVar_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ListIteratorImpl struct{ capnp.Struct }
type ListIteratorImpl_Which uint16

const (
	ListIteratorImpl_Which_num ListIteratorImpl_Which = 0
	ListIteratorImpl_Which_rec ListIteratorImpl_Which = 1
	ListIteratorImpl_Which_txt ListIteratorImpl_Which = 2
)

func (w ListIteratorImpl_Which) String() string {
	const s = "numrectxt"
	switch w {
	case ListIteratorImpl_Which_num:
		return s[0:3]
	case ListIteratorImpl_Which_rec:
		return s[3:6]
	case ListIteratorImpl_Which_txt:
		return s[6:9]

	}
	return "ListIteratorImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ListIteratorImpl_TypeID is the unique identifier for the type ListIteratorImpl.
const ListIteratorImpl_TypeID = 0xf451095bdcd8860d

func NewListIteratorImpl(s *capnp.Segment) (ListIteratorImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListIteratorImpl{st}, err
}

func NewRootListIteratorImpl(s *capnp.Segment) (ListIteratorImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListIteratorImpl{st}, err
}

func ReadRootListIteratorImpl(msg *capnp.Message) (ListIteratorImpl, error) {
	root, err := msg.RootPtr()
	return ListIteratorImpl{root.Struct()}, err
}

func (s ListIteratorImpl) String() string {
	str, _ := text.Marshal(0xf451095bdcd8860d, s.Struct)
	return str
}

func (s ListIteratorImpl) Which() ListIteratorImpl_Which {
	return ListIteratorImpl_Which(s.Struct.Uint16(0))
}
func (s ListIteratorImpl) Num() (list.AsNum, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != num")
	}
	p, err := s.Struct.Ptr(0)
	return list.AsNum{Struct: p.Struct()}, err
}

func (s ListIteratorImpl) HasNum() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListIteratorImpl) SetNum(v list.AsNum) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated list.AsNum struct, preferring placement in s's segment.
func (s ListIteratorImpl) NewNum() (list.AsNum, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := list.NewAsNum(s.Struct.Segment())
	if err != nil {
		return list.AsNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListIteratorImpl) Rec() (list.AsRec, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != rec")
	}
	p, err := s.Struct.Ptr(0)
	return list.AsRec{Struct: p.Struct()}, err
}

func (s ListIteratorImpl) HasRec() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListIteratorImpl) SetRec(v list.AsRec) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRec sets the rec field to a newly
// allocated list.AsRec struct, preferring placement in s's segment.
func (s ListIteratorImpl) NewRec() (list.AsRec, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := list.NewAsRec(s.Struct.Segment())
	if err != nil {
		return list.AsRec{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListIteratorImpl) Txt() (list.AsTxt, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != txt")
	}
	p, err := s.Struct.Ptr(0)
	return list.AsTxt{Struct: p.Struct()}, err
}

func (s ListIteratorImpl) HasTxt() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListIteratorImpl) SetTxt(v list.AsTxt) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxt sets the txt field to a newly
// allocated list.AsTxt struct, preferring placement in s's segment.
func (s ListIteratorImpl) NewTxt() (list.AsTxt, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := list.NewAsTxt(s.Struct.Segment())
	if err != nil {
		return list.AsTxt{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ListIteratorImpl_List is a list of ListIteratorImpl.
type ListIteratorImpl_List struct{ capnp.List }

// NewListIteratorImpl creates a new list of ListIteratorImpl.
func NewListIteratorImpl_List(s *capnp.Segment, sz int32) (ListIteratorImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ListIteratorImpl_List{l}, err
}

func (s ListIteratorImpl_List) At(i int) ListIteratorImpl { return ListIteratorImpl{s.List.Struct(i)} }

func (s ListIteratorImpl_List) Set(i int, v ListIteratorImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s ListIteratorImpl_List) String() string {
	str, _ := text.MarshalList(0xf451095bdcd8860d, s.List)
	return str
}

// ListIteratorImpl_Promise is a wrapper for a ListIteratorImpl promised by a client call.
type ListIteratorImpl_Promise struct{ *capnp.Pipeline }

func (p ListIteratorImpl_Promise) Struct() (ListIteratorImpl, error) {
	s, err := p.Pipeline.Struct()
	return ListIteratorImpl{s}, err
}

func (p ListIteratorImpl_Promise) Num() list.AsNum_Promise {
	return list.AsNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListIteratorImpl_Promise) Rec() list.AsRec_Promise {
	return list.AsRec_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListIteratorImpl_Promise) Txt() list.AsTxt_Promise {
	return list.AsTxt_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ListSourceImpl struct{ capnp.Struct }
type ListSourceImpl_Which uint16

const (
	ListSourceImpl_Which_nums ListSourceImpl_Which = 0
	ListSourceImpl_Which_recs ListSourceImpl_Which = 1
	ListSourceImpl_Which_txts ListSourceImpl_Which = 2
)

func (w ListSourceImpl_Which) String() string {
	const s = "numsrecstxts"
	switch w {
	case ListSourceImpl_Which_nums:
		return s[0:4]
	case ListSourceImpl_Which_recs:
		return s[4:8]
	case ListSourceImpl_Which_txts:
		return s[8:12]

	}
	return "ListSourceImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ListSourceImpl_TypeID is the unique identifier for the type ListSourceImpl.
const ListSourceImpl_TypeID = 0x9d013df2e25b0523

func NewListSourceImpl(s *capnp.Segment) (ListSourceImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListSourceImpl{st}, err
}

func NewRootListSourceImpl(s *capnp.Segment) (ListSourceImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListSourceImpl{st}, err
}

func ReadRootListSourceImpl(msg *capnp.Message) (ListSourceImpl, error) {
	root, err := msg.RootPtr()
	return ListSourceImpl{root.Struct()}, err
}

func (s ListSourceImpl) String() string {
	str, _ := text.Marshal(0x9d013df2e25b0523, s.Struct)
	return str
}

func (s ListSourceImpl) Which() ListSourceImpl_Which {
	return ListSourceImpl_Which(s.Struct.Uint16(0))
}
func (s ListSourceImpl) Nums() (list.FromNumList, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != nums")
	}
	p, err := s.Struct.Ptr(0)
	return list.FromNumList{Struct: p.Struct()}, err
}

func (s ListSourceImpl) HasNums() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListSourceImpl) SetNums(v list.FromNumList) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNums sets the nums field to a newly
// allocated list.FromNumList struct, preferring placement in s's segment.
func (s ListSourceImpl) NewNums() (list.FromNumList, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := list.NewFromNumList(s.Struct.Segment())
	if err != nil {
		return list.FromNumList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListSourceImpl) Recs() (list.FromRecList, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != recs")
	}
	p, err := s.Struct.Ptr(0)
	return list.FromRecList{Struct: p.Struct()}, err
}

func (s ListSourceImpl) HasRecs() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListSourceImpl) SetRecs(v list.FromRecList) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRecs sets the recs field to a newly
// allocated list.FromRecList struct, preferring placement in s's segment.
func (s ListSourceImpl) NewRecs() (list.FromRecList, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := list.NewFromRecList(s.Struct.Segment())
	if err != nil {
		return list.FromRecList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListSourceImpl) Txts() (list.FromTxtList, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != txts")
	}
	p, err := s.Struct.Ptr(0)
	return list.FromTxtList{Struct: p.Struct()}, err
}

func (s ListSourceImpl) HasTxts() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListSourceImpl) SetTxts(v list.FromTxtList) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxts sets the txts field to a newly
// allocated list.FromTxtList struct, preferring placement in s's segment.
func (s ListSourceImpl) NewTxts() (list.FromTxtList, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := list.NewFromTxtList(s.Struct.Segment())
	if err != nil {
		return list.FromTxtList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ListSourceImpl_List is a list of ListSourceImpl.
type ListSourceImpl_List struct{ capnp.List }

// NewListSourceImpl creates a new list of ListSourceImpl.
func NewListSourceImpl_List(s *capnp.Segment, sz int32) (ListSourceImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ListSourceImpl_List{l}, err
}

func (s ListSourceImpl_List) At(i int) ListSourceImpl { return ListSourceImpl{s.List.Struct(i)} }

func (s ListSourceImpl_List) Set(i int, v ListSourceImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s ListSourceImpl_List) String() string {
	str, _ := text.MarshalList(0x9d013df2e25b0523, s.List)
	return str
}

// ListSourceImpl_Promise is a wrapper for a ListSourceImpl promised by a client call.
type ListSourceImpl_Promise struct{ *capnp.Pipeline }

func (p ListSourceImpl_Promise) Struct() (ListSourceImpl, error) {
	s, err := p.Pipeline.Struct()
	return ListSourceImpl{s}, err
}

func (p ListSourceImpl_Promise) Nums() list.FromNumList_Promise {
	return list.FromNumList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListSourceImpl_Promise) Recs() list.FromRecList_Promise {
	return list.FromRecList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListSourceImpl_Promise) Txts() list.FromTxtList_Promise {
	return list.FromTxtList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ListTargetImpl struct{ capnp.Struct }
type ListTargetImpl_Which uint16

const (
	ListTargetImpl_Which_nums ListTargetImpl_Which = 0
	ListTargetImpl_Which_recs ListTargetImpl_Which = 1
	ListTargetImpl_Which_txts ListTargetImpl_Which = 2
)

func (w ListTargetImpl_Which) String() string {
	const s = "numsrecstxts"
	switch w {
	case ListTargetImpl_Which_nums:
		return s[0:4]
	case ListTargetImpl_Which_recs:
		return s[4:8]
	case ListTargetImpl_Which_txts:
		return s[8:12]

	}
	return "ListTargetImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ListTargetImpl_TypeID is the unique identifier for the type ListTargetImpl.
const ListTargetImpl_TypeID = 0xedeec74f770bd677

func NewListTargetImpl(s *capnp.Segment) (ListTargetImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListTargetImpl{st}, err
}

func NewRootListTargetImpl(s *capnp.Segment) (ListTargetImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListTargetImpl{st}, err
}

func ReadRootListTargetImpl(msg *capnp.Message) (ListTargetImpl, error) {
	root, err := msg.RootPtr()
	return ListTargetImpl{root.Struct()}, err
}

func (s ListTargetImpl) String() string {
	str, _ := text.Marshal(0xedeec74f770bd677, s.Struct)
	return str
}

func (s ListTargetImpl) Which() ListTargetImpl_Which {
	return ListTargetImpl_Which(s.Struct.Uint16(0))
}
func (s ListTargetImpl) Nums() (list.IntoNumList, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != nums")
	}
	p, err := s.Struct.Ptr(0)
	return list.IntoNumList{Struct: p.Struct()}, err
}

func (s ListTargetImpl) HasNums() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListTargetImpl) SetNums(v list.IntoNumList) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNums sets the nums field to a newly
// allocated list.IntoNumList struct, preferring placement in s's segment.
func (s ListTargetImpl) NewNums() (list.IntoNumList, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := list.NewIntoNumList(s.Struct.Segment())
	if err != nil {
		return list.IntoNumList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListTargetImpl) Recs() (list.IntoRecList, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != recs")
	}
	p, err := s.Struct.Ptr(0)
	return list.IntoRecList{Struct: p.Struct()}, err
}

func (s ListTargetImpl) HasRecs() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListTargetImpl) SetRecs(v list.IntoRecList) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRecs sets the recs field to a newly
// allocated list.IntoRecList struct, preferring placement in s's segment.
func (s ListTargetImpl) NewRecs() (list.IntoRecList, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := list.NewIntoRecList(s.Struct.Segment())
	if err != nil {
		return list.IntoRecList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListTargetImpl) Txts() (list.IntoTxtList, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != txts")
	}
	p, err := s.Struct.Ptr(0)
	return list.IntoTxtList{Struct: p.Struct()}, err
}

func (s ListTargetImpl) HasTxts() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListTargetImpl) SetTxts(v list.IntoTxtList) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxts sets the txts field to a newly
// allocated list.IntoTxtList struct, preferring placement in s's segment.
func (s ListTargetImpl) NewTxts() (list.IntoTxtList, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := list.NewIntoTxtList(s.Struct.Segment())
	if err != nil {
		return list.IntoTxtList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ListTargetImpl_List is a list of ListTargetImpl.
type ListTargetImpl_List struct{ capnp.List }

// NewListTargetImpl creates a new list of ListTargetImpl.
func NewListTargetImpl_List(s *capnp.Segment, sz int32) (ListTargetImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ListTargetImpl_List{l}, err
}

func (s ListTargetImpl_List) At(i int) ListTargetImpl { return ListTargetImpl{s.List.Struct(i)} }

func (s ListTargetImpl_List) Set(i int, v ListTargetImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s ListTargetImpl_List) String() string {
	str, _ := text.MarshalList(0xedeec74f770bd677, s.List)
	return str
}

// ListTargetImpl_Promise is a wrapper for a ListTargetImpl promised by a client call.
type ListTargetImpl_Promise struct{ *capnp.Pipeline }

func (p ListTargetImpl_Promise) Struct() (ListTargetImpl, error) {
	s, err := p.Pipeline.Struct()
	return ListTargetImpl{s}, err
}

func (p ListTargetImpl_Promise) Nums() list.IntoNumList_Promise {
	return list.IntoNumList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListTargetImpl_Promise) Recs() list.IntoRecList_Promise {
	return list.IntoRecList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListTargetImpl_Promise) Txts() list.IntoTxtList_Promise {
	return list.IntoTxtList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type NumListEvalImpl struct{ capnp.Struct }
type NumListEvalImpl_Which uint16

const (
	NumListEvalImpl_Which_determineArgs           NumListEvalImpl_Which = 0
	NumListEvalImpl_Which_getFrom                 NumListEvalImpl_Which = 1
	NumListEvalImpl_Which_nums                    NumListEvalImpl_Which = 2
	NumListEvalImpl_Which_range                   NumListEvalImpl_Which = 3
	NumListEvalImpl_Which_rangeByStep             NumListEvalImpl_Which = 4
	NumListEvalImpl_Which_rangeFrom               NumListEvalImpl_Which = 5
	NumListEvalImpl_Which_rangeFromByStep         NumListEvalImpl_Which = 6
	NumListEvalImpl_Which_renderArgs              NumListEvalImpl_Which = 7
	NumListEvalImpl_Which_renderRefFlags          NumListEvalImpl_Which = 8
	NumListEvalImpl_Which_slice                   NumListEvalImpl_Which = 9
	NumListEvalImpl_Which_sliceEnd                NumListEvalImpl_Which = 10
	NumListEvalImpl_Which_sliceStart              NumListEvalImpl_Which = 11
	NumListEvalImpl_Which_sliceStartEnd           NumListEvalImpl_Which = 12
	NumListEvalImpl_Which_spliceStartRemoveInsert NumListEvalImpl_Which = 13
	NumListEvalImpl_Which_var                     NumListEvalImpl_Which = 14
)

func (w NumListEvalImpl_Which) String() string {
	const s = "determineArgsgetFromnumsrangerangeBySteprangeFromrangeFromBySteprenderArgsrenderRefFlagsslicesliceEndsliceStartsliceStartEndspliceStartRemoveInsertvar"
	switch w {
	case NumListEvalImpl_Which_determineArgs:
		return s[0:13]
	case NumListEvalImpl_Which_getFrom:
		return s[13:20]
	case NumListEvalImpl_Which_nums:
		return s[20:24]
	case NumListEvalImpl_Which_range:
		return s[24:29]
	case NumListEvalImpl_Which_rangeByStep:
		return s[29:40]
	case NumListEvalImpl_Which_rangeFrom:
		return s[40:49]
	case NumListEvalImpl_Which_rangeFromByStep:
		return s[49:64]
	case NumListEvalImpl_Which_renderArgs:
		return s[64:74]
	case NumListEvalImpl_Which_renderRefFlags:
		return s[74:88]
	case NumListEvalImpl_Which_slice:
		return s[88:93]
	case NumListEvalImpl_Which_sliceEnd:
		return s[93:101]
	case NumListEvalImpl_Which_sliceStart:
		return s[101:111]
	case NumListEvalImpl_Which_sliceStartEnd:
		return s[111:124]
	case NumListEvalImpl_Which_spliceStartRemoveInsert:
		return s[124:147]
	case NumListEvalImpl_Which_var:
		return s[147:150]

	}
	return "NumListEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// NumListEvalImpl_TypeID is the unique identifier for the type NumListEvalImpl.
const NumListEvalImpl_TypeID = 0xa20bd14fac188777

func NewNumListEvalImpl(s *capnp.Segment) (NumListEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return NumListEvalImpl{st}, err
}

func NewRootNumListEvalImpl(s *capnp.Segment) (NumListEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return NumListEvalImpl{st}, err
}

func ReadRootNumListEvalImpl(msg *capnp.Message) (NumListEvalImpl, error) {
	root, err := msg.RootPtr()
	return NumListEvalImpl{root.Struct()}, err
}

func (s NumListEvalImpl) String() string {
	str, _ := text.Marshal(0xa20bd14fac188777, s.Struct)
	return str
}

func (s NumListEvalImpl) Which() NumListEvalImpl_Which {
	return NumListEvalImpl_Which(s.Struct.Uint16(0))
}
func (s NumListEvalImpl) DetermineArgs() (core.Determine, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Determine{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetDetermineArgs(v core.Determine) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated core.Determine struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewDetermineArgs() (core.Determine, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewDetermine(s.Struct.Segment())
	if err != nil {
		return core.Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) GetFrom() (core.GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return core.GetAtField{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetGetFrom(v core.GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated core.GetAtField struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewGetFrom() (core.GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewGetAtField(s.Struct.Segment())
	if err != nil {
		return core.GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) Nums() (core.NumList, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != nums")
	}
	p, err := s.Struct.Ptr(0)
	return core.NumList{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasNums() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetNums(v core.NumList) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNums sets the nums field to a newly
// allocated core.NumList struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewNums() (core.NumList, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewNumList(s.Struct.Segment())
	if err != nil {
		return core.NumList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) Range() (list.Range, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != range")
	}
	p, err := s.Struct.Ptr(0)
	return list.Range{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRange() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRange(v list.Range) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRange sets the range field to a newly
// allocated list.Range struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRange() (list.Range, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := list.NewRange(s.Struct.Segment())
	if err != nil {
		return list.Range{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RangeByStep() (list.Range, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != rangeByStep")
	}
	p, err := s.Struct.Ptr(0)
	return list.Range{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRangeByStep() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRangeByStep(v list.Range) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRangeByStep sets the rangeByStep field to a newly
// allocated list.Range struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRangeByStep() (list.Range, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := list.NewRange(s.Struct.Segment())
	if err != nil {
		return list.Range{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RangeFrom() (list.Range, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != rangeFrom")
	}
	p, err := s.Struct.Ptr(0)
	return list.Range{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRangeFrom() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRangeFrom(v list.Range) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRangeFrom sets the rangeFrom field to a newly
// allocated list.Range struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRangeFrom() (list.Range, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := list.NewRange(s.Struct.Segment())
	if err != nil {
		return list.Range{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RangeFromByStep() (list.Range, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != rangeFromByStep")
	}
	p, err := s.Struct.Ptr(0)
	return list.Range{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRangeFromByStep() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRangeFromByStep(v list.Range) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRangeFromByStep sets the rangeFromByStep field to a newly
// allocated list.Range struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRangeFromByStep() (list.Range, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := list.NewRange(s.Struct.Segment())
	if err != nil {
		return list.Range{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RenderRefFlags() (render.RenderRef, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderRef{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRenderRefFlags(v render.RenderRef) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated render.RenderRef struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRenderRefFlags() (render.RenderRef, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := render.NewRenderRef(s.Struct.Segment())
	if err != nil {
		return render.RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) Slice() (list.Slice, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != slice")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSlice() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSlice(v list.Slice) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSlice sets the slice field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSlice() (list.Slice, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) SliceEnd() (list.Slice, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != sliceEnd")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSliceEnd() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSliceEnd(v list.Slice) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceEnd sets the sliceEnd field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSliceEnd() (list.Slice, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) SliceStart() (list.Slice, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != sliceStart")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSliceStart() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSliceStart(v list.Slice) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStart sets the sliceStart field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSliceStart() (list.Slice, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) SliceStartEnd() (list.Slice, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != sliceStartEnd")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSliceStartEnd() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSliceStartEnd(v list.Slice) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStartEnd sets the sliceStartEnd field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSliceStartEnd() (list.Slice, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) SpliceStartRemoveInsert() (list.Splice, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != spliceStartRemoveInsert")
	}
	p, err := s.Struct.Ptr(0)
	return list.Splice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSpliceStartRemoveInsert() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSpliceStartRemoveInsert(v list.Splice) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpliceStartRemoveInsert sets the spliceStartRemoveInsert field to a newly
// allocated list.Splice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSpliceStartRemoveInsert() (list.Splice, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := list.NewSplice(s.Struct.Segment())
	if err != nil {
		return list.Splice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) Var() (core.Var, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.Var{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetVar(v core.Var) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.Var struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewVar() (core.Var, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := core.NewVar(s.Struct.Segment())
	if err != nil {
		return core.Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// NumListEvalImpl_List is a list of NumListEvalImpl.
type NumListEvalImpl_List struct{ capnp.List }

// NewNumListEvalImpl creates a new list of NumListEvalImpl.
func NewNumListEvalImpl_List(s *capnp.Segment, sz int32) (NumListEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return NumListEvalImpl_List{l}, err
}

func (s NumListEvalImpl_List) At(i int) NumListEvalImpl { return NumListEvalImpl{s.List.Struct(i)} }

func (s NumListEvalImpl_List) Set(i int, v NumListEvalImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s NumListEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xa20bd14fac188777, s.List)
	return str
}

// NumListEvalImpl_Promise is a wrapper for a NumListEvalImpl promised by a client call.
type NumListEvalImpl_Promise struct{ *capnp.Pipeline }

func (p NumListEvalImpl_Promise) Struct() (NumListEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return NumListEvalImpl{s}, err
}

func (p NumListEvalImpl_Promise) DetermineArgs() core.Determine_Promise {
	return core.Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) GetFrom() core.GetAtField_Promise {
	return core.GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) Nums() core.NumList_Promise {
	return core.NumList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) Range() list.Range_Promise {
	return list.Range_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RangeByStep() list.Range_Promise {
	return list.Range_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RangeFrom() list.Range_Promise {
	return list.Range_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RangeFromByStep() list.Range_Promise {
	return list.Range_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RenderRefFlags() render.RenderRef_Promise {
	return render.RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) Slice() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) SliceEnd() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) SliceStart() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) SliceStartEnd() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) SpliceStartRemoveInsert() list.Splice_Promise {
	return list.Splice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) Var() core.Var_Promise {
	return core.Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type NumberEvalImpl struct{ capnp.Struct }
type NumberEvalImpl_Which uint16

const (
	NumberEvalImpl_Which_dec            NumberEvalImpl_Which = 0
	NumberEvalImpl_Which_decBy          NumberEvalImpl_Which = 1
	NumberEvalImpl_Which_determineArgs  NumberEvalImpl_Which = 2
	NumberEvalImpl_Which_divBy          NumberEvalImpl_Which = 3
	NumberEvalImpl_Which_during         NumberEvalImpl_Which = 4
	NumberEvalImpl_Which_findList       NumberEvalImpl_Which = 5
	NumberEvalImpl_Which_getFrom        NumberEvalImpl_Which = 6
	NumberEvalImpl_Which_getIndex       NumberEvalImpl_Which = 7
	NumberEvalImpl_Which_inc            NumberEvalImpl_Which = 8
	NumberEvalImpl_Which_incBy          NumberEvalImpl_Which = 9
	NumberEvalImpl_Which_len            NumberEvalImpl_Which = 10
	NumberEvalImpl_Which_modBy          NumberEvalImpl_Which = 11
	NumberEvalImpl_Which_mulBy          NumberEvalImpl_Which = 12
	NumberEvalImpl_Which_num            NumberEvalImpl_Which = 13
	NumberEvalImpl_Which_numIfElse      NumberEvalImpl_Which = 14
	NumberEvalImpl_Which_renderArgs     NumberEvalImpl_Which = 15
	NumberEvalImpl_Which_renderRefFlags NumberEvalImpl_Which = 16
	NumberEvalImpl_Which_var            NumberEvalImpl_Which = 17
)

func (w NumberEvalImpl_Which) String() string {
	const s = "decdecBydetermineArgsdivByduringfindListgetFromgetIndexincincBylenmodBymulBynumnumIfElserenderArgsrenderRefFlagsvar"
	switch w {
	case NumberEvalImpl_Which_dec:
		return s[0:3]
	case NumberEvalImpl_Which_decBy:
		return s[3:8]
	case NumberEvalImpl_Which_determineArgs:
		return s[8:21]
	case NumberEvalImpl_Which_divBy:
		return s[21:26]
	case NumberEvalImpl_Which_during:
		return s[26:32]
	case NumberEvalImpl_Which_findList:
		return s[32:40]
	case NumberEvalImpl_Which_getFrom:
		return s[40:47]
	case NumberEvalImpl_Which_getIndex:
		return s[47:55]
	case NumberEvalImpl_Which_inc:
		return s[55:58]
	case NumberEvalImpl_Which_incBy:
		return s[58:63]
	case NumberEvalImpl_Which_len:
		return s[63:66]
	case NumberEvalImpl_Which_modBy:
		return s[66:71]
	case NumberEvalImpl_Which_mulBy:
		return s[71:76]
	case NumberEvalImpl_Which_num:
		return s[76:79]
	case NumberEvalImpl_Which_numIfElse:
		return s[79:88]
	case NumberEvalImpl_Which_renderArgs:
		return s[88:98]
	case NumberEvalImpl_Which_renderRefFlags:
		return s[98:112]
	case NumberEvalImpl_Which_var:
		return s[112:115]

	}
	return "NumberEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// NumberEvalImpl_TypeID is the unique identifier for the type NumberEvalImpl.
const NumberEvalImpl_TypeID = 0xe3dbbb161150c44e

func NewNumberEvalImpl(s *capnp.Segment) (NumberEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return NumberEvalImpl{st}, err
}

func NewRootNumberEvalImpl(s *capnp.Segment) (NumberEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return NumberEvalImpl{st}, err
}

func ReadRootNumberEvalImpl(msg *capnp.Message) (NumberEvalImpl, error) {
	root, err := msg.RootPtr()
	return NumberEvalImpl{root.Struct()}, err
}

func (s NumberEvalImpl) String() string {
	str, _ := text.Marshal(0xe3dbbb161150c44e, s.Struct)
	return str
}

func (s NumberEvalImpl) Which() NumberEvalImpl_Which {
	return NumberEvalImpl_Which(s.Struct.Uint16(0))
}
func (s NumberEvalImpl) Dec() (core.DiffOf, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != dec")
	}
	p, err := s.Struct.Ptr(0)
	return core.DiffOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDec() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDec(v core.DiffOf) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDec sets the dec field to a newly
// allocated core.DiffOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDec() (core.DiffOf, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewDiffOf(s.Struct.Segment())
	if err != nil {
		return core.DiffOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) DecBy() (core.DiffOf, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != decBy")
	}
	p, err := s.Struct.Ptr(0)
	return core.DiffOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDecBy() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDecBy(v core.DiffOf) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDecBy sets the decBy field to a newly
// allocated core.DiffOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDecBy() (core.DiffOf, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewDiffOf(s.Struct.Segment())
	if err != nil {
		return core.DiffOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) DetermineArgs() (core.Determine, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Determine{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDetermineArgs(v core.Determine) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated core.Determine struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDetermineArgs() (core.Determine, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewDetermine(s.Struct.Segment())
	if err != nil {
		return core.Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) DivBy() (core.QuotientOf, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != divBy")
	}
	p, err := s.Struct.Ptr(0)
	return core.QuotientOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDivBy() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDivBy(v core.QuotientOf) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDivBy sets the divBy field to a newly
// allocated core.QuotientOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDivBy() (core.QuotientOf, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewQuotientOf(s.Struct.Segment())
	if err != nil {
		return core.QuotientOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) During() (core.During, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != during")
	}
	p, err := s.Struct.Ptr(0)
	return core.During{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDuring() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDuring(v core.During) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDuring sets the during field to a newly
// allocated core.During struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDuring() (core.During, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := core.NewDuring(s.Struct.Segment())
	if err != nil {
		return core.During{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) FindList() (list.Find, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != findList")
	}
	p, err := s.Struct.Ptr(0)
	return list.Find{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasFindList() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetFindList(v list.Find) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFindList sets the findList field to a newly
// allocated list.Find struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewFindList() (list.Find, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := list.NewFind(s.Struct.Segment())
	if err != nil {
		return list.Find{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) GetFrom() (core.GetAtField, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return core.GetAtField{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetGetFrom(v core.GetAtField) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated core.GetAtField struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewGetFrom() (core.GetAtField, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := core.NewGetAtField(s.Struct.Segment())
	if err != nil {
		return core.GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) GetIndex() (list.At, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != getIndex")
	}
	p, err := s.Struct.Ptr(0)
	return list.At{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasGetIndex() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetGetIndex(v list.At) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetIndex sets the getIndex field to a newly
// allocated list.At struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewGetIndex() (list.At, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := list.NewAt(s.Struct.Segment())
	if err != nil {
		return list.At{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) Inc() (core.SumOf, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != inc")
	}
	p, err := s.Struct.Ptr(0)
	return core.SumOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasInc() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetInc(v core.SumOf) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewInc sets the inc field to a newly
// allocated core.SumOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewInc() (core.SumOf, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := core.NewSumOf(s.Struct.Segment())
	if err != nil {
		return core.SumOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) IncBy() (core.SumOf, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != incBy")
	}
	p, err := s.Struct.Ptr(0)
	return core.SumOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasIncBy() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetIncBy(v core.SumOf) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIncBy sets the incBy field to a newly
// allocated core.SumOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewIncBy() (core.SumOf, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := core.NewSumOf(s.Struct.Segment())
	if err != nil {
		return core.SumOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) Len() (list.Len, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != len")
	}
	p, err := s.Struct.Ptr(0)
	return list.Len{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasLen() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetLen(v list.Len) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLen sets the len field to a newly
// allocated list.Len struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewLen() (list.Len, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := list.NewLen(s.Struct.Segment())
	if err != nil {
		return list.Len{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) ModBy() (core.RemainderOf, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != modBy")
	}
	p, err := s.Struct.Ptr(0)
	return core.RemainderOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasModBy() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetModBy(v core.RemainderOf) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewModBy sets the modBy field to a newly
// allocated core.RemainderOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewModBy() (core.RemainderOf, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := core.NewRemainderOf(s.Struct.Segment())
	if err != nil {
		return core.RemainderOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) MulBy() (core.ProductOf, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != mulBy")
	}
	p, err := s.Struct.Ptr(0)
	return core.ProductOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasMulBy() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetMulBy(v core.ProductOf) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMulBy sets the mulBy field to a newly
// allocated core.ProductOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewMulBy() (core.ProductOf, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := core.NewProductOf(s.Struct.Segment())
	if err != nil {
		return core.ProductOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) Num() (core.NumValue, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != num")
	}
	p, err := s.Struct.Ptr(0)
	return core.NumValue{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasNum() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetNum(v core.NumValue) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated core.NumValue struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewNum() (core.NumValue, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := core.NewNumValue(s.Struct.Segment())
	if err != nil {
		return core.NumValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) NumIfElse() (core.ChooseNum, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != numIfElse")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseNum{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasNumIfElse() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetNumIfElse(v core.ChooseNum) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNumIfElse sets the numIfElse field to a newly
// allocated core.ChooseNum struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewNumIfElse() (core.ChooseNum, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := core.NewChooseNum(s.Struct.Segment())
	if err != nil {
		return core.ChooseNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 15)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) RenderRefFlags() (render.RenderRef, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderRef{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetRenderRefFlags(v render.RenderRef) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated render.RenderRef struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewRenderRefFlags() (render.RenderRef, error) {
	s.Struct.SetUint16(0, 16)
	ss, err := render.NewRenderRef(s.Struct.Segment())
	if err != nil {
		return render.RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) Var() (core.Var, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.Var{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetVar(v core.Var) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.Var struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewVar() (core.Var, error) {
	s.Struct.SetUint16(0, 17)
	ss, err := core.NewVar(s.Struct.Segment())
	if err != nil {
		return core.Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// NumberEvalImpl_List is a list of NumberEvalImpl.
type NumberEvalImpl_List struct{ capnp.List }

// NewNumberEvalImpl creates a new list of NumberEvalImpl.
func NewNumberEvalImpl_List(s *capnp.Segment, sz int32) (NumberEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return NumberEvalImpl_List{l}, err
}

func (s NumberEvalImpl_List) At(i int) NumberEvalImpl { return NumberEvalImpl{s.List.Struct(i)} }

func (s NumberEvalImpl_List) Set(i int, v NumberEvalImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s NumberEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xe3dbbb161150c44e, s.List)
	return str
}

// NumberEvalImpl_Promise is a wrapper for a NumberEvalImpl promised by a client call.
type NumberEvalImpl_Promise struct{ *capnp.Pipeline }

func (p NumberEvalImpl_Promise) Struct() (NumberEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return NumberEvalImpl{s}, err
}

func (p NumberEvalImpl_Promise) Dec() core.DiffOf_Promise {
	return core.DiffOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) DecBy() core.DiffOf_Promise {
	return core.DiffOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) DetermineArgs() core.Determine_Promise {
	return core.Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) DivBy() core.QuotientOf_Promise {
	return core.QuotientOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) During() core.During_Promise {
	return core.During_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) FindList() list.Find_Promise {
	return list.Find_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) GetFrom() core.GetAtField_Promise {
	return core.GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) GetIndex() list.At_Promise {
	return list.At_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) Inc() core.SumOf_Promise {
	return core.SumOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) IncBy() core.SumOf_Promise {
	return core.SumOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) Len() list.Len_Promise {
	return list.Len_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) ModBy() core.RemainderOf_Promise {
	return core.RemainderOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) MulBy() core.ProductOf_Promise {
	return core.ProductOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) Num() core.NumValue_Promise {
	return core.NumValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) NumIfElse() core.ChooseNum_Promise {
	return core.ChooseNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) RenderRefFlags() render.RenderRef_Promise {
	return render.RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) Var() core.Var_Promise {
	return core.Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type RecordEvalImpl struct{ capnp.Struct }
type RecordEvalImpl_Which uint16

const (
	RecordEvalImpl_Which_determineArgs  RecordEvalImpl_Which = 0
	RecordEvalImpl_Which_getFrom        RecordEvalImpl_Which = 1
	RecordEvalImpl_Which_getIndex       RecordEvalImpl_Which = 2
	RecordEvalImpl_Which_makeArgs       RecordEvalImpl_Which = 3
	RecordEvalImpl_Which_renderArgs     RecordEvalImpl_Which = 4
	RecordEvalImpl_Which_renderRefFlags RecordEvalImpl_Which = 5
	RecordEvalImpl_Which_var            RecordEvalImpl_Which = 6
)

func (w RecordEvalImpl_Which) String() string {
	const s = "determineArgsgetFromgetIndexmakeArgsrenderArgsrenderRefFlagsvar"
	switch w {
	case RecordEvalImpl_Which_determineArgs:
		return s[0:13]
	case RecordEvalImpl_Which_getFrom:
		return s[13:20]
	case RecordEvalImpl_Which_getIndex:
		return s[20:28]
	case RecordEvalImpl_Which_makeArgs:
		return s[28:36]
	case RecordEvalImpl_Which_renderArgs:
		return s[36:46]
	case RecordEvalImpl_Which_renderRefFlags:
		return s[46:60]
	case RecordEvalImpl_Which_var:
		return s[60:63]

	}
	return "RecordEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// RecordEvalImpl_TypeID is the unique identifier for the type RecordEvalImpl.
const RecordEvalImpl_TypeID = 0xc19058b353c75763

func NewRecordEvalImpl(s *capnp.Segment) (RecordEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RecordEvalImpl{st}, err
}

func NewRootRecordEvalImpl(s *capnp.Segment) (RecordEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RecordEvalImpl{st}, err
}

func ReadRootRecordEvalImpl(msg *capnp.Message) (RecordEvalImpl, error) {
	root, err := msg.RootPtr()
	return RecordEvalImpl{root.Struct()}, err
}

func (s RecordEvalImpl) String() string {
	str, _ := text.Marshal(0xc19058b353c75763, s.Struct)
	return str
}

func (s RecordEvalImpl) Which() RecordEvalImpl_Which {
	return RecordEvalImpl_Which(s.Struct.Uint16(0))
}
func (s RecordEvalImpl) DetermineArgs() (core.Determine, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Determine{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetDetermineArgs(v core.Determine) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated core.Determine struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewDetermineArgs() (core.Determine, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewDetermine(s.Struct.Segment())
	if err != nil {
		return core.Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) GetFrom() (core.GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return core.GetAtField{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetGetFrom(v core.GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated core.GetAtField struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewGetFrom() (core.GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewGetAtField(s.Struct.Segment())
	if err != nil {
		return core.GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) GetIndex() (list.At, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != getIndex")
	}
	p, err := s.Struct.Ptr(0)
	return list.At{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasGetIndex() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetGetIndex(v list.At) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetIndex sets the getIndex field to a newly
// allocated list.At struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewGetIndex() (list.At, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := list.NewAt(s.Struct.Segment())
	if err != nil {
		return list.At{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) MakeArgs() (core.Make, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != makeArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Make{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasMakeArgs() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetMakeArgs(v core.Make) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMakeArgs sets the makeArgs field to a newly
// allocated core.Make struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewMakeArgs() (core.Make, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewMake(s.Struct.Segment())
	if err != nil {
		return core.Make{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) RenderRefFlags() (render.RenderRef, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderRef{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetRenderRefFlags(v render.RenderRef) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated render.RenderRef struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewRenderRefFlags() (render.RenderRef, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := render.NewRenderRef(s.Struct.Segment())
	if err != nil {
		return render.RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) Var() (core.Var, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.Var{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetVar(v core.Var) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.Var struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewVar() (core.Var, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := core.NewVar(s.Struct.Segment())
	if err != nil {
		return core.Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// RecordEvalImpl_List is a list of RecordEvalImpl.
type RecordEvalImpl_List struct{ capnp.List }

// NewRecordEvalImpl creates a new list of RecordEvalImpl.
func NewRecordEvalImpl_List(s *capnp.Segment, sz int32) (RecordEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return RecordEvalImpl_List{l}, err
}

func (s RecordEvalImpl_List) At(i int) RecordEvalImpl { return RecordEvalImpl{s.List.Struct(i)} }

func (s RecordEvalImpl_List) Set(i int, v RecordEvalImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s RecordEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xc19058b353c75763, s.List)
	return str
}

// RecordEvalImpl_Promise is a wrapper for a RecordEvalImpl promised by a client call.
type RecordEvalImpl_Promise struct{ *capnp.Pipeline }

func (p RecordEvalImpl_Promise) Struct() (RecordEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return RecordEvalImpl{s}, err
}

func (p RecordEvalImpl_Promise) DetermineArgs() core.Determine_Promise {
	return core.Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) GetFrom() core.GetAtField_Promise {
	return core.GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) GetIndex() list.At_Promise {
	return list.At_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) MakeArgs() core.Make_Promise {
	return core.Make_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) RenderRefFlags() render.RenderRef_Promise {
	return render.RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) Var() core.Var_Promise {
	return core.Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type RecordListEvalImpl struct{ capnp.Struct }
type RecordListEvalImpl_Which uint16

const (
	RecordListEvalImpl_Which_determineArgs           RecordListEvalImpl_Which = 0
	RecordListEvalImpl_Which_getFrom                 RecordListEvalImpl_Which = 1
	RecordListEvalImpl_Which_renderArgs              RecordListEvalImpl_Which = 2
	RecordListEvalImpl_Which_renderRefFlags          RecordListEvalImpl_Which = 3
	RecordListEvalImpl_Which_slice                   RecordListEvalImpl_Which = 4
	RecordListEvalImpl_Which_sliceEnd                RecordListEvalImpl_Which = 5
	RecordListEvalImpl_Which_sliceStart              RecordListEvalImpl_Which = 6
	RecordListEvalImpl_Which_sliceStartEnd           RecordListEvalImpl_Which = 7
	RecordListEvalImpl_Which_spliceStartRemoveInsert RecordListEvalImpl_Which = 8
	RecordListEvalImpl_Which_var                     RecordListEvalImpl_Which = 9
)

func (w RecordListEvalImpl_Which) String() string {
	const s = "determineArgsgetFromrenderArgsrenderRefFlagsslicesliceEndsliceStartsliceStartEndspliceStartRemoveInsertvar"
	switch w {
	case RecordListEvalImpl_Which_determineArgs:
		return s[0:13]
	case RecordListEvalImpl_Which_getFrom:
		return s[13:20]
	case RecordListEvalImpl_Which_renderArgs:
		return s[20:30]
	case RecordListEvalImpl_Which_renderRefFlags:
		return s[30:44]
	case RecordListEvalImpl_Which_slice:
		return s[44:49]
	case RecordListEvalImpl_Which_sliceEnd:
		return s[49:57]
	case RecordListEvalImpl_Which_sliceStart:
		return s[57:67]
	case RecordListEvalImpl_Which_sliceStartEnd:
		return s[67:80]
	case RecordListEvalImpl_Which_spliceStartRemoveInsert:
		return s[80:103]
	case RecordListEvalImpl_Which_var:
		return s[103:106]

	}
	return "RecordListEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// RecordListEvalImpl_TypeID is the unique identifier for the type RecordListEvalImpl.
const RecordListEvalImpl_TypeID = 0xd196ce6d3039f074

func NewRecordListEvalImpl(s *capnp.Segment) (RecordListEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RecordListEvalImpl{st}, err
}

func NewRootRecordListEvalImpl(s *capnp.Segment) (RecordListEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RecordListEvalImpl{st}, err
}

func ReadRootRecordListEvalImpl(msg *capnp.Message) (RecordListEvalImpl, error) {
	root, err := msg.RootPtr()
	return RecordListEvalImpl{root.Struct()}, err
}

func (s RecordListEvalImpl) String() string {
	str, _ := text.Marshal(0xd196ce6d3039f074, s.Struct)
	return str
}

func (s RecordListEvalImpl) Which() RecordListEvalImpl_Which {
	return RecordListEvalImpl_Which(s.Struct.Uint16(0))
}
func (s RecordListEvalImpl) DetermineArgs() (core.Determine, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Determine{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetDetermineArgs(v core.Determine) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated core.Determine struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewDetermineArgs() (core.Determine, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewDetermine(s.Struct.Segment())
	if err != nil {
		return core.Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) GetFrom() (core.GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return core.GetAtField{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetGetFrom(v core.GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated core.GetAtField struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewGetFrom() (core.GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewGetAtField(s.Struct.Segment())
	if err != nil {
		return core.GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) RenderRefFlags() (render.RenderRef, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderRef{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetRenderRefFlags(v render.RenderRef) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated render.RenderRef struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewRenderRefFlags() (render.RenderRef, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := render.NewRenderRef(s.Struct.Segment())
	if err != nil {
		return render.RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) Slice() (list.Slice, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != slice")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSlice() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSlice(v list.Slice) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSlice sets the slice field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSlice() (list.Slice, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) SliceEnd() (list.Slice, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != sliceEnd")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSliceEnd() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSliceEnd(v list.Slice) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceEnd sets the sliceEnd field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSliceEnd() (list.Slice, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) SliceStart() (list.Slice, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != sliceStart")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSliceStart() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSliceStart(v list.Slice) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStart sets the sliceStart field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSliceStart() (list.Slice, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) SliceStartEnd() (list.Slice, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != sliceStartEnd")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSliceStartEnd() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSliceStartEnd(v list.Slice) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStartEnd sets the sliceStartEnd field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSliceStartEnd() (list.Slice, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) SpliceStartRemoveInsert() (list.Splice, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != spliceStartRemoveInsert")
	}
	p, err := s.Struct.Ptr(0)
	return list.Splice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSpliceStartRemoveInsert() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSpliceStartRemoveInsert(v list.Splice) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpliceStartRemoveInsert sets the spliceStartRemoveInsert field to a newly
// allocated list.Splice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSpliceStartRemoveInsert() (list.Splice, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := list.NewSplice(s.Struct.Segment())
	if err != nil {
		return list.Splice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) Var() (core.Var, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.Var{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetVar(v core.Var) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.Var struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewVar() (core.Var, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := core.NewVar(s.Struct.Segment())
	if err != nil {
		return core.Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// RecordListEvalImpl_List is a list of RecordListEvalImpl.
type RecordListEvalImpl_List struct{ capnp.List }

// NewRecordListEvalImpl creates a new list of RecordListEvalImpl.
func NewRecordListEvalImpl_List(s *capnp.Segment, sz int32) (RecordListEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return RecordListEvalImpl_List{l}, err
}

func (s RecordListEvalImpl_List) At(i int) RecordListEvalImpl {
	return RecordListEvalImpl{s.List.Struct(i)}
}

func (s RecordListEvalImpl_List) Set(i int, v RecordListEvalImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s RecordListEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xd196ce6d3039f074, s.List)
	return str
}

// RecordListEvalImpl_Promise is a wrapper for a RecordListEvalImpl promised by a client call.
type RecordListEvalImpl_Promise struct{ *capnp.Pipeline }

func (p RecordListEvalImpl_Promise) Struct() (RecordListEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return RecordListEvalImpl{s}, err
}

func (p RecordListEvalImpl_Promise) DetermineArgs() core.Determine_Promise {
	return core.Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) GetFrom() core.GetAtField_Promise {
	return core.GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) RenderRefFlags() render.RenderRef_Promise {
	return render.RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) Slice() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) SliceEnd() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) SliceStart() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) SliceStartEnd() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) SpliceStartRemoveInsert() list.Splice_Promise {
	return list.Splice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) Var() core.Var_Promise {
	return core.Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ScannerMakerImpl struct{ capnp.Struct }
type ScannerMakerImpl_Which uint16

const (
	ScannerMakerImpl_Which_allOf    ScannerMakerImpl_Which = 0
	ScannerMakerImpl_Which_anyOf    ScannerMakerImpl_Which = 1
	ScannerMakerImpl_Which_as       ScannerMakerImpl_Which = 2
	ScannerMakerImpl_Which_noun     ScannerMakerImpl_Which = 3
	ScannerMakerImpl_Which_retarget ScannerMakerImpl_Which = 4
	ScannerMakerImpl_Which_reverse  ScannerMakerImpl_Which = 5
	ScannerMakerImpl_Which_self     ScannerMakerImpl_Which = 6
	ScannerMakerImpl_Which_words    ScannerMakerImpl_Which = 7
)

func (w ScannerMakerImpl_Which) String() string {
	const s = "allOfanyOfasnounretargetreverseselfwords"
	switch w {
	case ScannerMakerImpl_Which_allOf:
		return s[0:5]
	case ScannerMakerImpl_Which_anyOf:
		return s[5:10]
	case ScannerMakerImpl_Which_as:
		return s[10:12]
	case ScannerMakerImpl_Which_noun:
		return s[12:16]
	case ScannerMakerImpl_Which_retarget:
		return s[16:24]
	case ScannerMakerImpl_Which_reverse:
		return s[24:31]
	case ScannerMakerImpl_Which_self:
		return s[31:35]
	case ScannerMakerImpl_Which_words:
		return s[35:40]

	}
	return "ScannerMakerImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ScannerMakerImpl_TypeID is the unique identifier for the type ScannerMakerImpl.
const ScannerMakerImpl_TypeID = 0xe1637c70bbf5c834

func NewScannerMakerImpl(s *capnp.Segment) (ScannerMakerImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ScannerMakerImpl{st}, err
}

func NewRootScannerMakerImpl(s *capnp.Segment) (ScannerMakerImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ScannerMakerImpl{st}, err
}

func ReadRootScannerMakerImpl(msg *capnp.Message) (ScannerMakerImpl, error) {
	root, err := msg.RootPtr()
	return ScannerMakerImpl{root.Struct()}, err
}

func (s ScannerMakerImpl) String() string {
	str, _ := text.Marshal(0xe1637c70bbf5c834, s.Struct)
	return str
}

func (s ScannerMakerImpl) Which() ScannerMakerImpl_Which {
	return ScannerMakerImpl_Which(s.Struct.Uint16(0))
}
func (s ScannerMakerImpl) AllOf() (grammar.AllOf, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != allOf")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.AllOf{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasAllOf() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetAllOf(v grammar.AllOf) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAllOf sets the allOf field to a newly
// allocated grammar.AllOf struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewAllOf() (grammar.AllOf, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := grammar.NewAllOf(s.Struct.Segment())
	if err != nil {
		return grammar.AllOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) AnyOf() (grammar.AnyOf, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != anyOf")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.AnyOf{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasAnyOf() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetAnyOf(v grammar.AnyOf) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAnyOf sets the anyOf field to a newly
// allocated grammar.AnyOf struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewAnyOf() (grammar.AnyOf, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := grammar.NewAnyOf(s.Struct.Segment())
	if err != nil {
		return grammar.AnyOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) As() (grammar.Action, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != as")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.Action{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasAs() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetAs(v grammar.Action) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAs sets the as field to a newly
// allocated grammar.Action struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewAs() (grammar.Action, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := grammar.NewAction(s.Struct.Segment())
	if err != nil {
		return grammar.Action{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Noun() (grammar.Noun, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != noun")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.Noun{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasNoun() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetNoun(v grammar.Noun) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNoun sets the noun field to a newly
// allocated grammar.Noun struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewNoun() (grammar.Noun, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := grammar.NewNoun(s.Struct.Segment())
	if err != nil {
		return grammar.Noun{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Retarget() (grammar.Retarget, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != retarget")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.Retarget{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasRetarget() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetRetarget(v grammar.Retarget) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRetarget sets the retarget field to a newly
// allocated grammar.Retarget struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewRetarget() (grammar.Retarget, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := grammar.NewRetarget(s.Struct.Segment())
	if err != nil {
		return grammar.Retarget{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Reverse() (grammar.Reverse, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != reverse")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.Reverse{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasReverse() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetReverse(v grammar.Reverse) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReverse sets the reverse field to a newly
// allocated grammar.Reverse struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewReverse() (grammar.Reverse, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := grammar.NewReverse(s.Struct.Segment())
	if err != nil {
		return grammar.Reverse{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Self() (grammar.Self, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != self")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.Self{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasSelf() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetSelf(v grammar.Self) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSelf sets the self field to a newly
// allocated grammar.Self struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewSelf() (grammar.Self, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := grammar.NewSelf(s.Struct.Segment())
	if err != nil {
		return grammar.Self{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Words() (grammar.Words, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != words")
	}
	p, err := s.Struct.Ptr(0)
	return grammar.Words{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasWords() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetWords(v grammar.Words) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewWords sets the words field to a newly
// allocated grammar.Words struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewWords() (grammar.Words, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := grammar.NewWords(s.Struct.Segment())
	if err != nil {
		return grammar.Words{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ScannerMakerImpl_List is a list of ScannerMakerImpl.
type ScannerMakerImpl_List struct{ capnp.List }

// NewScannerMakerImpl creates a new list of ScannerMakerImpl.
func NewScannerMakerImpl_List(s *capnp.Segment, sz int32) (ScannerMakerImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ScannerMakerImpl_List{l}, err
}

func (s ScannerMakerImpl_List) At(i int) ScannerMakerImpl { return ScannerMakerImpl{s.List.Struct(i)} }

func (s ScannerMakerImpl_List) Set(i int, v ScannerMakerImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s ScannerMakerImpl_List) String() string {
	str, _ := text.MarshalList(0xe1637c70bbf5c834, s.List)
	return str
}

// ScannerMakerImpl_Promise is a wrapper for a ScannerMakerImpl promised by a client call.
type ScannerMakerImpl_Promise struct{ *capnp.Pipeline }

func (p ScannerMakerImpl_Promise) Struct() (ScannerMakerImpl, error) {
	s, err := p.Pipeline.Struct()
	return ScannerMakerImpl{s}, err
}

func (p ScannerMakerImpl_Promise) AllOf() grammar.AllOf_Promise {
	return grammar.AllOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) AnyOf() grammar.AnyOf_Promise {
	return grammar.AnyOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) As() grammar.Action_Promise {
	return grammar.Action_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Noun() grammar.Noun_Promise {
	return grammar.Noun_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Retarget() grammar.Retarget_Promise {
	return grammar.Retarget_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Reverse() grammar.Reverse_Promise {
	return grammar.Reverse_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Self() grammar.Self_Promise {
	return grammar.Self_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Words() grammar.Words_Promise {
	return grammar.Words_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type TextEvalImpl struct{ capnp.Struct }
type TextEvalImpl_Which uint16

const (
	TextEvalImpl_Which_bracketTextDo       TextEvalImpl_Which = 0
	TextEvalImpl_Which_bufferTextDo        TextEvalImpl_Which = 1
	TextEvalImpl_Which_capitalize          TextEvalImpl_Which = 2
	TextEvalImpl_Which_commaTextDo         TextEvalImpl_Which = 3
	TextEvalImpl_Which_cycle               TextEvalImpl_Which = 4
	TextEvalImpl_Which_determineArgs       TextEvalImpl_Which = 5
	TextEvalImpl_Which_getFrom             TextEvalImpl_Which = 6
	TextEvalImpl_Which_getIndex            TextEvalImpl_Which = 7
	TextEvalImpl_Which_idOf                TextEvalImpl_Which = 8
	TextEvalImpl_Which_joinParts           TextEvalImpl_Which = 9
	TextEvalImpl_Which_kindOf              TextEvalImpl_Which = 10
	TextEvalImpl_Which_lower               TextEvalImpl_Which = 11
	TextEvalImpl_Which_nameOf              TextEvalImpl_Which = 12
	TextEvalImpl_Which_numeralWords        TextEvalImpl_Which = 13
	TextEvalImpl_Which_numeral             TextEvalImpl_Which = 14
	TextEvalImpl_Which_pluralize           TextEvalImpl_Which = 15
	TextEvalImpl_Which_reciprocalRelObject TextEvalImpl_Which = 16
	TextEvalImpl_Which_relativeRelObject   TextEvalImpl_Which = 17
	TextEvalImpl_Which_renderArgs          TextEvalImpl_Which = 18
	TextEvalImpl_Which_renderName          TextEvalImpl_Which = 19
	TextEvalImpl_Which_renderRefFlags      TextEvalImpl_Which = 20
	TextEvalImpl_Which_renderTemplate      TextEvalImpl_Which = 21
	TextEvalImpl_Which_response            TextEvalImpl_Which = 22
	TextEvalImpl_Which_responseText        TextEvalImpl_Which = 23
	TextEvalImpl_Which_reverse             TextEvalImpl_Which = 24
	TextEvalImpl_Which_rowDo               TextEvalImpl_Which = 25
	TextEvalImpl_Which_rowsDo              TextEvalImpl_Which = 26
	TextEvalImpl_Which_sentence            TextEvalImpl_Which = 27
	TextEvalImpl_Which_shuffle             TextEvalImpl_Which = 28
	TextEvalImpl_Which_singularize         TextEvalImpl_Which = 29
	TextEvalImpl_Which_slashTextDo         TextEvalImpl_Which = 30
	TextEvalImpl_Which_spanTextDo          TextEvalImpl_Which = 31
	TextEvalImpl_Which_stopping            TextEvalImpl_Which = 32
	TextEvalImpl_Which_title               TextEvalImpl_Which = 33
	TextEvalImpl_Which_txt                 TextEvalImpl_Which = 34
	TextEvalImpl_Which_txtIfElse           TextEvalImpl_Which = 35
	TextEvalImpl_Which_upper               TextEvalImpl_Which = 36
	TextEvalImpl_Which_var                 TextEvalImpl_Which = 37
)

func (w TextEvalImpl_Which) String() string {
	const s = "bracketTextDobufferTextDocapitalizecommaTextDocycledetermineArgsgetFromgetIndexidOfjoinPartskindOflowernameOfnumeralWordsnumeralpluralizereciprocalRelObjectrelativeRelObjectrenderArgsrenderNamerenderRefFlagsrenderTemplateresponseresponseTextreverserowDorowsDosentenceshufflesingularizeslashTextDospanTextDostoppingtitletxttxtIfElseuppervar"
	switch w {
	case TextEvalImpl_Which_bracketTextDo:
		return s[0:13]
	case TextEvalImpl_Which_bufferTextDo:
		return s[13:25]
	case TextEvalImpl_Which_capitalize:
		return s[25:35]
	case TextEvalImpl_Which_commaTextDo:
		return s[35:46]
	case TextEvalImpl_Which_cycle:
		return s[46:51]
	case TextEvalImpl_Which_determineArgs:
		return s[51:64]
	case TextEvalImpl_Which_getFrom:
		return s[64:71]
	case TextEvalImpl_Which_getIndex:
		return s[71:79]
	case TextEvalImpl_Which_idOf:
		return s[79:83]
	case TextEvalImpl_Which_joinParts:
		return s[83:92]
	case TextEvalImpl_Which_kindOf:
		return s[92:98]
	case TextEvalImpl_Which_lower:
		return s[98:103]
	case TextEvalImpl_Which_nameOf:
		return s[103:109]
	case TextEvalImpl_Which_numeralWords:
		return s[109:121]
	case TextEvalImpl_Which_numeral:
		return s[121:128]
	case TextEvalImpl_Which_pluralize:
		return s[128:137]
	case TextEvalImpl_Which_reciprocalRelObject:
		return s[137:156]
	case TextEvalImpl_Which_relativeRelObject:
		return s[156:173]
	case TextEvalImpl_Which_renderArgs:
		return s[173:183]
	case TextEvalImpl_Which_renderName:
		return s[183:193]
	case TextEvalImpl_Which_renderRefFlags:
		return s[193:207]
	case TextEvalImpl_Which_renderTemplate:
		return s[207:221]
	case TextEvalImpl_Which_response:
		return s[221:229]
	case TextEvalImpl_Which_responseText:
		return s[229:241]
	case TextEvalImpl_Which_reverse:
		return s[241:248]
	case TextEvalImpl_Which_rowDo:
		return s[248:253]
	case TextEvalImpl_Which_rowsDo:
		return s[253:259]
	case TextEvalImpl_Which_sentence:
		return s[259:267]
	case TextEvalImpl_Which_shuffle:
		return s[267:274]
	case TextEvalImpl_Which_singularize:
		return s[274:285]
	case TextEvalImpl_Which_slashTextDo:
		return s[285:296]
	case TextEvalImpl_Which_spanTextDo:
		return s[296:306]
	case TextEvalImpl_Which_stopping:
		return s[306:314]
	case TextEvalImpl_Which_title:
		return s[314:319]
	case TextEvalImpl_Which_txt:
		return s[319:322]
	case TextEvalImpl_Which_txtIfElse:
		return s[322:331]
	case TextEvalImpl_Which_upper:
		return s[331:336]
	case TextEvalImpl_Which_var:
		return s[336:339]

	}
	return "TextEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TextEvalImpl_TypeID is the unique identifier for the type TextEvalImpl.
const TextEvalImpl_TypeID = 0x8795012f7ae80514

func NewTextEvalImpl(s *capnp.Segment) (TextEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TextEvalImpl{st}, err
}

func NewRootTextEvalImpl(s *capnp.Segment) (TextEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TextEvalImpl{st}, err
}

func ReadRootTextEvalImpl(msg *capnp.Message) (TextEvalImpl, error) {
	root, err := msg.RootPtr()
	return TextEvalImpl{root.Struct()}, err
}

func (s TextEvalImpl) String() string {
	str, _ := text.Marshal(0x8795012f7ae80514, s.Struct)
	return str
}

func (s TextEvalImpl) Which() TextEvalImpl_Which {
	return TextEvalImpl_Which(s.Struct.Uint16(0))
}
func (s TextEvalImpl) BracketTextDo() (core.Bracket, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != bracketTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Bracket{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasBracketTextDo() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetBracketTextDo(v core.Bracket) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBracketTextDo sets the bracketTextDo field to a newly
// allocated core.Bracket struct, preferring placement in s's segment.
func (s TextEvalImpl) NewBracketTextDo() (core.Bracket, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewBracket(s.Struct.Segment())
	if err != nil {
		return core.Bracket{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) BufferTextDo() (core.Buffer, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != bufferTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Buffer{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasBufferTextDo() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetBufferTextDo(v core.Buffer) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBufferTextDo sets the bufferTextDo field to a newly
// allocated core.Buffer struct, preferring placement in s's segment.
func (s TextEvalImpl) NewBufferTextDo() (core.Buffer, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewBuffer(s.Struct.Segment())
	if err != nil {
		return core.Buffer{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Capitalize() (core.Capitalize, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != capitalize")
	}
	p, err := s.Struct.Ptr(0)
	return core.Capitalize{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasCapitalize() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetCapitalize(v core.Capitalize) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCapitalize sets the capitalize field to a newly
// allocated core.Capitalize struct, preferring placement in s's segment.
func (s TextEvalImpl) NewCapitalize() (core.Capitalize, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewCapitalize(s.Struct.Segment())
	if err != nil {
		return core.Capitalize{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) CommaTextDo() (core.Commas, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != commaTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Commas{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasCommaTextDo() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetCommaTextDo(v core.Commas) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCommaTextDo sets the commaTextDo field to a newly
// allocated core.Commas struct, preferring placement in s's segment.
func (s TextEvalImpl) NewCommaTextDo() (core.Commas, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := core.NewCommas(s.Struct.Segment())
	if err != nil {
		return core.Commas{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Cycle() (core.CycleText, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != cycle")
	}
	p, err := s.Struct.Ptr(0)
	return core.CycleText{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasCycle() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetCycle(v core.CycleText) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCycle sets the cycle field to a newly
// allocated core.CycleText struct, preferring placement in s's segment.
func (s TextEvalImpl) NewCycle() (core.CycleText, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := core.NewCycleText(s.Struct.Segment())
	if err != nil {
		return core.CycleText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) DetermineArgs() (core.Determine, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Determine{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetDetermineArgs(v core.Determine) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated core.Determine struct, preferring placement in s's segment.
func (s TextEvalImpl) NewDetermineArgs() (core.Determine, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := core.NewDetermine(s.Struct.Segment())
	if err != nil {
		return core.Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) GetFrom() (core.GetAtField, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return core.GetAtField{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetGetFrom(v core.GetAtField) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated core.GetAtField struct, preferring placement in s's segment.
func (s TextEvalImpl) NewGetFrom() (core.GetAtField, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := core.NewGetAtField(s.Struct.Segment())
	if err != nil {
		return core.GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) GetIndex() (list.At, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != getIndex")
	}
	p, err := s.Struct.Ptr(0)
	return list.At{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasGetIndex() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetGetIndex(v list.At) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetIndex sets the getIndex field to a newly
// allocated list.At struct, preferring placement in s's segment.
func (s TextEvalImpl) NewGetIndex() (list.At, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := list.NewAt(s.Struct.Segment())
	if err != nil {
		return list.At{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) IdOf() (core.IdOf, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != idOf")
	}
	p, err := s.Struct.Ptr(0)
	return core.IdOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasIdOf() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetIdOf(v core.IdOf) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIdOf sets the idOf field to a newly
// allocated core.IdOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewIdOf() (core.IdOf, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := core.NewIdOf(s.Struct.Segment())
	if err != nil {
		return core.IdOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) JoinParts() (core.Join, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != joinParts")
	}
	p, err := s.Struct.Ptr(0)
	return core.Join{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasJoinParts() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetJoinParts(v core.Join) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewJoinParts sets the joinParts field to a newly
// allocated core.Join struct, preferring placement in s's segment.
func (s TextEvalImpl) NewJoinParts() (core.Join, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := core.NewJoin(s.Struct.Segment())
	if err != nil {
		return core.Join{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) KindOf() (core.KindOf, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != kindOf")
	}
	p, err := s.Struct.Ptr(0)
	return core.KindOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasKindOf() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetKindOf(v core.KindOf) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKindOf sets the kindOf field to a newly
// allocated core.KindOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewKindOf() (core.KindOf, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := core.NewKindOf(s.Struct.Segment())
	if err != nil {
		return core.KindOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Lower() (core.MakeLowercase, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != lower")
	}
	p, err := s.Struct.Ptr(0)
	return core.MakeLowercase{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasLower() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetLower(v core.MakeLowercase) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLower sets the lower field to a newly
// allocated core.MakeLowercase struct, preferring placement in s's segment.
func (s TextEvalImpl) NewLower() (core.MakeLowercase, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := core.NewMakeLowercase(s.Struct.Segment())
	if err != nil {
		return core.MakeLowercase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) NameOf() (core.NameOf, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != nameOf")
	}
	p, err := s.Struct.Ptr(0)
	return core.NameOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasNameOf() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetNameOf(v core.NameOf) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNameOf sets the nameOf field to a newly
// allocated core.NameOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewNameOf() (core.NameOf, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := core.NewNameOf(s.Struct.Segment())
	if err != nil {
		return core.NameOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) NumeralWords() (core.PrintNumWord, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != numeralWords")
	}
	p, err := s.Struct.Ptr(0)
	return core.PrintNumWord{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasNumeralWords() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetNumeralWords(v core.PrintNumWord) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNumeralWords sets the numeralWords field to a newly
// allocated core.PrintNumWord struct, preferring placement in s's segment.
func (s TextEvalImpl) NewNumeralWords() (core.PrintNumWord, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := core.NewPrintNumWord(s.Struct.Segment())
	if err != nil {
		return core.PrintNumWord{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Numeral() (core.PrintNum, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != numeral")
	}
	p, err := s.Struct.Ptr(0)
	return core.PrintNum{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasNumeral() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetNumeral(v core.PrintNum) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNumeral sets the numeral field to a newly
// allocated core.PrintNum struct, preferring placement in s's segment.
func (s TextEvalImpl) NewNumeral() (core.PrintNum, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := core.NewPrintNum(s.Struct.Segment())
	if err != nil {
		return core.PrintNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Pluralize() (core.MakePlural, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != pluralize")
	}
	p, err := s.Struct.Ptr(0)
	return core.MakePlural{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasPluralize() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetPluralize(v core.MakePlural) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPluralize sets the pluralize field to a newly
// allocated core.MakePlural struct, preferring placement in s's segment.
func (s TextEvalImpl) NewPluralize() (core.MakePlural, error) {
	s.Struct.SetUint16(0, 15)
	ss, err := core.NewMakePlural(s.Struct.Segment())
	if err != nil {
		return core.MakePlural{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) ReciprocalRelObject() (rel.ReciprocalOf, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != reciprocalRelObject")
	}
	p, err := s.Struct.Ptr(0)
	return rel.ReciprocalOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasReciprocalRelObject() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetReciprocalRelObject(v rel.ReciprocalOf) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReciprocalRelObject sets the reciprocalRelObject field to a newly
// allocated rel.ReciprocalOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewReciprocalRelObject() (rel.ReciprocalOf, error) {
	s.Struct.SetUint16(0, 16)
	ss, err := rel.NewReciprocalOf(s.Struct.Segment())
	if err != nil {
		return rel.ReciprocalOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RelativeRelObject() (rel.RelativeOf, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != relativeRelObject")
	}
	p, err := s.Struct.Ptr(0)
	return rel.RelativeOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRelativeRelObject() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRelativeRelObject(v rel.RelativeOf) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRelativeRelObject sets the relativeRelObject field to a newly
// allocated rel.RelativeOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRelativeRelObject() (rel.RelativeOf, error) {
	s.Struct.SetUint16(0, 17)
	ss, err := rel.NewRelativeOf(s.Struct.Segment())
	if err != nil {
		return rel.RelativeOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 18 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 18 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 18)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 18)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RenderName() (render.RenderName, error) {
	if s.Struct.Uint16(0) != 19 {
		panic("Which() != renderName")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderName{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRenderName() bool {
	if s.Struct.Uint16(0) != 19 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRenderName(v render.RenderName) error {
	s.Struct.SetUint16(0, 19)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderName sets the renderName field to a newly
// allocated render.RenderName struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRenderName() (render.RenderName, error) {
	s.Struct.SetUint16(0, 19)
	ss, err := render.NewRenderName(s.Struct.Segment())
	if err != nil {
		return render.RenderName{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RenderRefFlags() (render.RenderRef, error) {
	if s.Struct.Uint16(0) != 20 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderRef{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 20 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRenderRefFlags(v render.RenderRef) error {
	s.Struct.SetUint16(0, 20)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated render.RenderRef struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRenderRefFlags() (render.RenderRef, error) {
	s.Struct.SetUint16(0, 20)
	ss, err := render.NewRenderRef(s.Struct.Segment())
	if err != nil {
		return render.RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RenderTemplate() (render.RenderTemplate, error) {
	if s.Struct.Uint16(0) != 21 {
		panic("Which() != renderTemplate")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderTemplate{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRenderTemplate() bool {
	if s.Struct.Uint16(0) != 21 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRenderTemplate(v render.RenderTemplate) error {
	s.Struct.SetUint16(0, 21)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderTemplate sets the renderTemplate field to a newly
// allocated render.RenderTemplate struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRenderTemplate() (render.RenderTemplate, error) {
	s.Struct.SetUint16(0, 21)
	ss, err := render.NewRenderTemplate(s.Struct.Segment())
	if err != nil {
		return render.RenderTemplate{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Response() (core.Response, error) {
	if s.Struct.Uint16(0) != 22 {
		panic("Which() != response")
	}
	p, err := s.Struct.Ptr(0)
	return core.Response{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasResponse() bool {
	if s.Struct.Uint16(0) != 22 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetResponse(v core.Response) error {
	s.Struct.SetUint16(0, 22)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewResponse sets the response field to a newly
// allocated core.Response struct, preferring placement in s's segment.
func (s TextEvalImpl) NewResponse() (core.Response, error) {
	s.Struct.SetUint16(0, 22)
	ss, err := core.NewResponse(s.Struct.Segment())
	if err != nil {
		return core.Response{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) ResponseText() (core.Response, error) {
	if s.Struct.Uint16(0) != 23 {
		panic("Which() != responseText")
	}
	p, err := s.Struct.Ptr(0)
	return core.Response{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasResponseText() bool {
	if s.Struct.Uint16(0) != 23 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetResponseText(v core.Response) error {
	s.Struct.SetUint16(0, 23)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewResponseText sets the responseText field to a newly
// allocated core.Response struct, preferring placement in s's segment.
func (s TextEvalImpl) NewResponseText() (core.Response, error) {
	s.Struct.SetUint16(0, 23)
	ss, err := core.NewResponse(s.Struct.Segment())
	if err != nil {
		return core.Response{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Reverse() (core.MakeReversed, error) {
	if s.Struct.Uint16(0) != 24 {
		panic("Which() != reverse")
	}
	p, err := s.Struct.Ptr(0)
	return core.MakeReversed{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasReverse() bool {
	if s.Struct.Uint16(0) != 24 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetReverse(v core.MakeReversed) error {
	s.Struct.SetUint16(0, 24)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReverse sets the reverse field to a newly
// allocated core.MakeReversed struct, preferring placement in s's segment.
func (s TextEvalImpl) NewReverse() (core.MakeReversed, error) {
	s.Struct.SetUint16(0, 24)
	ss, err := core.NewMakeReversed(s.Struct.Segment())
	if err != nil {
		return core.MakeReversed{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RowDo() (core.Row, error) {
	if s.Struct.Uint16(0) != 25 {
		panic("Which() != rowDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Row{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRowDo() bool {
	if s.Struct.Uint16(0) != 25 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRowDo(v core.Row) error {
	s.Struct.SetUint16(0, 25)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRowDo sets the rowDo field to a newly
// allocated core.Row struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRowDo() (core.Row, error) {
	s.Struct.SetUint16(0, 25)
	ss, err := core.NewRow(s.Struct.Segment())
	if err != nil {
		return core.Row{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RowsDo() (core.Rows, error) {
	if s.Struct.Uint16(0) != 26 {
		panic("Which() != rowsDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Rows{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRowsDo() bool {
	if s.Struct.Uint16(0) != 26 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRowsDo(v core.Rows) error {
	s.Struct.SetUint16(0, 26)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRowsDo sets the rowsDo field to a newly
// allocated core.Rows struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRowsDo() (core.Rows, error) {
	s.Struct.SetUint16(0, 26)
	ss, err := core.NewRows(s.Struct.Segment())
	if err != nil {
		return core.Rows{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Sentence() (core.MakeSentenceCase, error) {
	if s.Struct.Uint16(0) != 27 {
		panic("Which() != sentence")
	}
	p, err := s.Struct.Ptr(0)
	return core.MakeSentenceCase{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasSentence() bool {
	if s.Struct.Uint16(0) != 27 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetSentence(v core.MakeSentenceCase) error {
	s.Struct.SetUint16(0, 27)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSentence sets the sentence field to a newly
// allocated core.MakeSentenceCase struct, preferring placement in s's segment.
func (s TextEvalImpl) NewSentence() (core.MakeSentenceCase, error) {
	s.Struct.SetUint16(0, 27)
	ss, err := core.NewMakeSentenceCase(s.Struct.Segment())
	if err != nil {
		return core.MakeSentenceCase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Shuffle() (core.ShuffleText, error) {
	if s.Struct.Uint16(0) != 28 {
		panic("Which() != shuffle")
	}
	p, err := s.Struct.Ptr(0)
	return core.ShuffleText{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasShuffle() bool {
	if s.Struct.Uint16(0) != 28 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetShuffle(v core.ShuffleText) error {
	s.Struct.SetUint16(0, 28)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewShuffle sets the shuffle field to a newly
// allocated core.ShuffleText struct, preferring placement in s's segment.
func (s TextEvalImpl) NewShuffle() (core.ShuffleText, error) {
	s.Struct.SetUint16(0, 28)
	ss, err := core.NewShuffleText(s.Struct.Segment())
	if err != nil {
		return core.ShuffleText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Singularize() (core.MakeSingular, error) {
	if s.Struct.Uint16(0) != 29 {
		panic("Which() != singularize")
	}
	p, err := s.Struct.Ptr(0)
	return core.MakeSingular{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasSingularize() bool {
	if s.Struct.Uint16(0) != 29 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetSingularize(v core.MakeSingular) error {
	s.Struct.SetUint16(0, 29)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSingularize sets the singularize field to a newly
// allocated core.MakeSingular struct, preferring placement in s's segment.
func (s TextEvalImpl) NewSingularize() (core.MakeSingular, error) {
	s.Struct.SetUint16(0, 29)
	ss, err := core.NewMakeSingular(s.Struct.Segment())
	if err != nil {
		return core.MakeSingular{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) SlashTextDo() (core.Slash, error) {
	if s.Struct.Uint16(0) != 30 {
		panic("Which() != slashTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Slash{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasSlashTextDo() bool {
	if s.Struct.Uint16(0) != 30 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetSlashTextDo(v core.Slash) error {
	s.Struct.SetUint16(0, 30)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSlashTextDo sets the slashTextDo field to a newly
// allocated core.Slash struct, preferring placement in s's segment.
func (s TextEvalImpl) NewSlashTextDo() (core.Slash, error) {
	s.Struct.SetUint16(0, 30)
	ss, err := core.NewSlash(s.Struct.Segment())
	if err != nil {
		return core.Slash{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) SpanTextDo() (core.Span, error) {
	if s.Struct.Uint16(0) != 31 {
		panic("Which() != spanTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return core.Span{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasSpanTextDo() bool {
	if s.Struct.Uint16(0) != 31 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetSpanTextDo(v core.Span) error {
	s.Struct.SetUint16(0, 31)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpanTextDo sets the spanTextDo field to a newly
// allocated core.Span struct, preferring placement in s's segment.
func (s TextEvalImpl) NewSpanTextDo() (core.Span, error) {
	s.Struct.SetUint16(0, 31)
	ss, err := core.NewSpan(s.Struct.Segment())
	if err != nil {
		return core.Span{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Stopping() (core.StoppingText, error) {
	if s.Struct.Uint16(0) != 32 {
		panic("Which() != stopping")
	}
	p, err := s.Struct.Ptr(0)
	return core.StoppingText{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasStopping() bool {
	if s.Struct.Uint16(0) != 32 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetStopping(v core.StoppingText) error {
	s.Struct.SetUint16(0, 32)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStopping sets the stopping field to a newly
// allocated core.StoppingText struct, preferring placement in s's segment.
func (s TextEvalImpl) NewStopping() (core.StoppingText, error) {
	s.Struct.SetUint16(0, 32)
	ss, err := core.NewStoppingText(s.Struct.Segment())
	if err != nil {
		return core.StoppingText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Title() (core.MakeTitleCase, error) {
	if s.Struct.Uint16(0) != 33 {
		panic("Which() != title")
	}
	p, err := s.Struct.Ptr(0)
	return core.MakeTitleCase{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasTitle() bool {
	if s.Struct.Uint16(0) != 33 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetTitle(v core.MakeTitleCase) error {
	s.Struct.SetUint16(0, 33)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTitle sets the title field to a newly
// allocated core.MakeTitleCase struct, preferring placement in s's segment.
func (s TextEvalImpl) NewTitle() (core.MakeTitleCase, error) {
	s.Struct.SetUint16(0, 33)
	ss, err := core.NewMakeTitleCase(s.Struct.Segment())
	if err != nil {
		return core.MakeTitleCase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Txt() (core.TextValue, error) {
	if s.Struct.Uint16(0) != 34 {
		panic("Which() != txt")
	}
	p, err := s.Struct.Ptr(0)
	return core.TextValue{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasTxt() bool {
	if s.Struct.Uint16(0) != 34 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetTxt(v core.TextValue) error {
	s.Struct.SetUint16(0, 34)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxt sets the txt field to a newly
// allocated core.TextValue struct, preferring placement in s's segment.
func (s TextEvalImpl) NewTxt() (core.TextValue, error) {
	s.Struct.SetUint16(0, 34)
	ss, err := core.NewTextValue(s.Struct.Segment())
	if err != nil {
		return core.TextValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) TxtIfElse() (core.ChooseText, error) {
	if s.Struct.Uint16(0) != 35 {
		panic("Which() != txtIfElse")
	}
	p, err := s.Struct.Ptr(0)
	return core.ChooseText{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasTxtIfElse() bool {
	if s.Struct.Uint16(0) != 35 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetTxtIfElse(v core.ChooseText) error {
	s.Struct.SetUint16(0, 35)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxtIfElse sets the txtIfElse field to a newly
// allocated core.ChooseText struct, preferring placement in s's segment.
func (s TextEvalImpl) NewTxtIfElse() (core.ChooseText, error) {
	s.Struct.SetUint16(0, 35)
	ss, err := core.NewChooseText(s.Struct.Segment())
	if err != nil {
		return core.ChooseText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Upper() (core.MakeUppercase, error) {
	if s.Struct.Uint16(0) != 36 {
		panic("Which() != upper")
	}
	p, err := s.Struct.Ptr(0)
	return core.MakeUppercase{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasUpper() bool {
	if s.Struct.Uint16(0) != 36 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetUpper(v core.MakeUppercase) error {
	s.Struct.SetUint16(0, 36)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewUpper sets the upper field to a newly
// allocated core.MakeUppercase struct, preferring placement in s's segment.
func (s TextEvalImpl) NewUpper() (core.MakeUppercase, error) {
	s.Struct.SetUint16(0, 36)
	ss, err := core.NewMakeUppercase(s.Struct.Segment())
	if err != nil {
		return core.MakeUppercase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Var() (core.Var, error) {
	if s.Struct.Uint16(0) != 37 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.Var{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 37 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetVar(v core.Var) error {
	s.Struct.SetUint16(0, 37)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.Var struct, preferring placement in s's segment.
func (s TextEvalImpl) NewVar() (core.Var, error) {
	s.Struct.SetUint16(0, 37)
	ss, err := core.NewVar(s.Struct.Segment())
	if err != nil {
		return core.Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// TextEvalImpl_List is a list of TextEvalImpl.
type TextEvalImpl_List struct{ capnp.List }

// NewTextEvalImpl creates a new list of TextEvalImpl.
func NewTextEvalImpl_List(s *capnp.Segment, sz int32) (TextEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return TextEvalImpl_List{l}, err
}

func (s TextEvalImpl_List) At(i int) TextEvalImpl { return TextEvalImpl{s.List.Struct(i)} }

func (s TextEvalImpl_List) Set(i int, v TextEvalImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s TextEvalImpl_List) String() string {
	str, _ := text.MarshalList(0x8795012f7ae80514, s.List)
	return str
}

// TextEvalImpl_Promise is a wrapper for a TextEvalImpl promised by a client call.
type TextEvalImpl_Promise struct{ *capnp.Pipeline }

func (p TextEvalImpl_Promise) Struct() (TextEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return TextEvalImpl{s}, err
}

func (p TextEvalImpl_Promise) BracketTextDo() core.Bracket_Promise {
	return core.Bracket_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) BufferTextDo() core.Buffer_Promise {
	return core.Buffer_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Capitalize() core.Capitalize_Promise {
	return core.Capitalize_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) CommaTextDo() core.Commas_Promise {
	return core.Commas_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Cycle() core.CycleText_Promise {
	return core.CycleText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) DetermineArgs() core.Determine_Promise {
	return core.Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) GetFrom() core.GetAtField_Promise {
	return core.GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) GetIndex() list.At_Promise {
	return list.At_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) IdOf() core.IdOf_Promise {
	return core.IdOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) JoinParts() core.Join_Promise {
	return core.Join_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) KindOf() core.KindOf_Promise {
	return core.KindOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Lower() core.MakeLowercase_Promise {
	return core.MakeLowercase_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) NameOf() core.NameOf_Promise {
	return core.NameOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) NumeralWords() core.PrintNumWord_Promise {
	return core.PrintNumWord_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Numeral() core.PrintNum_Promise {
	return core.PrintNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Pluralize() core.MakePlural_Promise {
	return core.MakePlural_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) ReciprocalRelObject() rel.ReciprocalOf_Promise {
	return rel.ReciprocalOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RelativeRelObject() rel.RelativeOf_Promise {
	return rel.RelativeOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RenderName() render.RenderName_Promise {
	return render.RenderName_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RenderRefFlags() render.RenderRef_Promise {
	return render.RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RenderTemplate() render.RenderTemplate_Promise {
	return render.RenderTemplate_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Response() core.Response_Promise {
	return core.Response_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) ResponseText() core.Response_Promise {
	return core.Response_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Reverse() core.MakeReversed_Promise {
	return core.MakeReversed_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RowDo() core.Row_Promise {
	return core.Row_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RowsDo() core.Rows_Promise {
	return core.Rows_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Sentence() core.MakeSentenceCase_Promise {
	return core.MakeSentenceCase_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Shuffle() core.ShuffleText_Promise {
	return core.ShuffleText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Singularize() core.MakeSingular_Promise {
	return core.MakeSingular_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) SlashTextDo() core.Slash_Promise {
	return core.Slash_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) SpanTextDo() core.Span_Promise {
	return core.Span_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Stopping() core.StoppingText_Promise {
	return core.StoppingText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Title() core.MakeTitleCase_Promise {
	return core.MakeTitleCase_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Txt() core.TextValue_Promise {
	return core.TextValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) TxtIfElse() core.ChooseText_Promise {
	return core.ChooseText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Upper() core.MakeUppercase_Promise {
	return core.MakeUppercase_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Var() core.Var_Promise {
	return core.Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type TextListEvalImpl struct{ capnp.Struct }
type TextListEvalImpl_Which uint16

const (
	TextListEvalImpl_Which_determineArgs           TextListEvalImpl_Which = 0
	TextListEvalImpl_Which_getFrom                 TextListEvalImpl_Which = 1
	TextListEvalImpl_Which_kindsOf                 TextListEvalImpl_Which = 2
	TextListEvalImpl_Which_reciprocalsRelObject    TextListEvalImpl_Which = 3
	TextListEvalImpl_Which_relativesRelObject      TextListEvalImpl_Which = 4
	TextListEvalImpl_Which_renderArgs              TextListEvalImpl_Which = 5
	TextListEvalImpl_Which_renderRefFlags          TextListEvalImpl_Which = 6
	TextListEvalImpl_Which_slice                   TextListEvalImpl_Which = 7
	TextListEvalImpl_Which_sliceEnd                TextListEvalImpl_Which = 8
	TextListEvalImpl_Which_sliceStart              TextListEvalImpl_Which = 9
	TextListEvalImpl_Which_sliceStartEnd           TextListEvalImpl_Which = 10
	TextListEvalImpl_Which_spliceStartRemoveInsert TextListEvalImpl_Which = 11
	TextListEvalImpl_Which_txts                    TextListEvalImpl_Which = 12
	TextListEvalImpl_Which_var                     TextListEvalImpl_Which = 13
)

func (w TextListEvalImpl_Which) String() string {
	const s = "determineArgsgetFromkindsOfreciprocalsRelObjectrelativesRelObjectrenderArgsrenderRefFlagsslicesliceEndsliceStartsliceStartEndspliceStartRemoveInserttxtsvar"
	switch w {
	case TextListEvalImpl_Which_determineArgs:
		return s[0:13]
	case TextListEvalImpl_Which_getFrom:
		return s[13:20]
	case TextListEvalImpl_Which_kindsOf:
		return s[20:27]
	case TextListEvalImpl_Which_reciprocalsRelObject:
		return s[27:47]
	case TextListEvalImpl_Which_relativesRelObject:
		return s[47:65]
	case TextListEvalImpl_Which_renderArgs:
		return s[65:75]
	case TextListEvalImpl_Which_renderRefFlags:
		return s[75:89]
	case TextListEvalImpl_Which_slice:
		return s[89:94]
	case TextListEvalImpl_Which_sliceEnd:
		return s[94:102]
	case TextListEvalImpl_Which_sliceStart:
		return s[102:112]
	case TextListEvalImpl_Which_sliceStartEnd:
		return s[112:125]
	case TextListEvalImpl_Which_spliceStartRemoveInsert:
		return s[125:148]
	case TextListEvalImpl_Which_txts:
		return s[148:152]
	case TextListEvalImpl_Which_var:
		return s[152:155]

	}
	return "TextListEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TextListEvalImpl_TypeID is the unique identifier for the type TextListEvalImpl.
const TextListEvalImpl_TypeID = 0xa3264fdbc475990d

func NewTextListEvalImpl(s *capnp.Segment) (TextListEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TextListEvalImpl{st}, err
}

func NewRootTextListEvalImpl(s *capnp.Segment) (TextListEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TextListEvalImpl{st}, err
}

func ReadRootTextListEvalImpl(msg *capnp.Message) (TextListEvalImpl, error) {
	root, err := msg.RootPtr()
	return TextListEvalImpl{root.Struct()}, err
}

func (s TextListEvalImpl) String() string {
	str, _ := text.Marshal(0xa3264fdbc475990d, s.Struct)
	return str
}

func (s TextListEvalImpl) Which() TextListEvalImpl_Which {
	return TextListEvalImpl_Which(s.Struct.Uint16(0))
}
func (s TextListEvalImpl) DetermineArgs() (core.Determine, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return core.Determine{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetDetermineArgs(v core.Determine) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated core.Determine struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewDetermineArgs() (core.Determine, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewDetermine(s.Struct.Segment())
	if err != nil {
		return core.Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) GetFrom() (core.GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return core.GetAtField{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetGetFrom(v core.GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated core.GetAtField struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewGetFrom() (core.GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewGetAtField(s.Struct.Segment())
	if err != nil {
		return core.GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) KindsOf() (core.KindsOf, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != kindsOf")
	}
	p, err := s.Struct.Ptr(0)
	return core.KindsOf{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasKindsOf() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetKindsOf(v core.KindsOf) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKindsOf sets the kindsOf field to a newly
// allocated core.KindsOf struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewKindsOf() (core.KindsOf, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewKindsOf(s.Struct.Segment())
	if err != nil {
		return core.KindsOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) ReciprocalsRelObject() (rel.ReciprocalsOf, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != reciprocalsRelObject")
	}
	p, err := s.Struct.Ptr(0)
	return rel.ReciprocalsOf{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasReciprocalsRelObject() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetReciprocalsRelObject(v rel.ReciprocalsOf) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReciprocalsRelObject sets the reciprocalsRelObject field to a newly
// allocated rel.ReciprocalsOf struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewReciprocalsRelObject() (rel.ReciprocalsOf, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := rel.NewReciprocalsOf(s.Struct.Segment())
	if err != nil {
		return rel.ReciprocalsOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) RelativesRelObject() (rel.RelativesOf, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != relativesRelObject")
	}
	p, err := s.Struct.Ptr(0)
	return rel.RelativesOf{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasRelativesRelObject() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetRelativesRelObject(v rel.RelativesOf) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRelativesRelObject sets the relativesRelObject field to a newly
// allocated rel.RelativesOf struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewRelativesRelObject() (rel.RelativesOf, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := rel.NewRelativesOf(s.Struct.Segment())
	if err != nil {
		return rel.RelativesOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) RenderArgs() (render.RenderPattern, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderPattern{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetRenderArgs(v render.RenderPattern) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated render.RenderPattern struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewRenderArgs() (render.RenderPattern, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := render.NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return render.RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) RenderRefFlags() (render.RenderRef, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return render.RenderRef{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetRenderRefFlags(v render.RenderRef) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated render.RenderRef struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewRenderRefFlags() (render.RenderRef, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := render.NewRenderRef(s.Struct.Segment())
	if err != nil {
		return render.RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) Slice() (list.Slice, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != slice")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSlice() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSlice(v list.Slice) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSlice sets the slice field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSlice() (list.Slice, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) SliceEnd() (list.Slice, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != sliceEnd")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSliceEnd() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSliceEnd(v list.Slice) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceEnd sets the sliceEnd field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSliceEnd() (list.Slice, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) SliceStart() (list.Slice, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != sliceStart")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSliceStart() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSliceStart(v list.Slice) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStart sets the sliceStart field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSliceStart() (list.Slice, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) SliceStartEnd() (list.Slice, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != sliceStartEnd")
	}
	p, err := s.Struct.Ptr(0)
	return list.Slice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSliceStartEnd() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSliceStartEnd(v list.Slice) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStartEnd sets the sliceStartEnd field to a newly
// allocated list.Slice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSliceStartEnd() (list.Slice, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := list.NewSlice(s.Struct.Segment())
	if err != nil {
		return list.Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) SpliceStartRemoveInsert() (list.Splice, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != spliceStartRemoveInsert")
	}
	p, err := s.Struct.Ptr(0)
	return list.Splice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSpliceStartRemoveInsert() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSpliceStartRemoveInsert(v list.Splice) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpliceStartRemoveInsert sets the spliceStartRemoveInsert field to a newly
// allocated list.Splice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSpliceStartRemoveInsert() (list.Splice, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := list.NewSplice(s.Struct.Segment())
	if err != nil {
		return list.Splice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) Txts() (core.TextList, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != txts")
	}
	p, err := s.Struct.Ptr(0)
	return core.TextList{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasTxts() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetTxts(v core.TextList) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxts sets the txts field to a newly
// allocated core.TextList struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewTxts() (core.TextList, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := core.NewTextList(s.Struct.Segment())
	if err != nil {
		return core.TextList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) Var() (core.Var, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return core.Var{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetVar(v core.Var) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated core.Var struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewVar() (core.Var, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := core.NewVar(s.Struct.Segment())
	if err != nil {
		return core.Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// TextListEvalImpl_List is a list of TextListEvalImpl.
type TextListEvalImpl_List struct{ capnp.List }

// NewTextListEvalImpl creates a new list of TextListEvalImpl.
func NewTextListEvalImpl_List(s *capnp.Segment, sz int32) (TextListEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return TextListEvalImpl_List{l}, err
}

func (s TextListEvalImpl_List) At(i int) TextListEvalImpl { return TextListEvalImpl{s.List.Struct(i)} }

func (s TextListEvalImpl_List) Set(i int, v TextListEvalImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s TextListEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xa3264fdbc475990d, s.List)
	return str
}

// TextListEvalImpl_Promise is a wrapper for a TextListEvalImpl promised by a client call.
type TextListEvalImpl_Promise struct{ *capnp.Pipeline }

func (p TextListEvalImpl_Promise) Struct() (TextListEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return TextListEvalImpl{s}, err
}

func (p TextListEvalImpl_Promise) DetermineArgs() core.Determine_Promise {
	return core.Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) GetFrom() core.GetAtField_Promise {
	return core.GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) KindsOf() core.KindsOf_Promise {
	return core.KindsOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) ReciprocalsRelObject() rel.ReciprocalsOf_Promise {
	return rel.ReciprocalsOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) RelativesRelObject() rel.RelativesOf_Promise {
	return rel.RelativesOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) RenderArgs() render.RenderPattern_Promise {
	return render.RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) RenderRefFlags() render.RenderRef_Promise {
	return render.RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) Slice() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) SliceEnd() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) SliceStart() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) SliceStartEnd() list.Slice_Promise {
	return list.Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) SpliceStartRemoveInsert() list.Splice_Promise {
	return list.Splice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) Txts() core.TextList_Promise {
	return core.TextList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) Var() core.Var_Promise {
	return core.Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type TriggerImpl struct{ capnp.Struct }
type TriggerImpl_Which uint16

const (
	TriggerImpl_Which_after TriggerImpl_Which = 0
	TriggerImpl_Which_at    TriggerImpl_Which = 1
	TriggerImpl_Which_every TriggerImpl_Which = 2
)

func (w TriggerImpl_Which) String() string {
	const s = "afteratevery"
	switch w {
	case TriggerImpl_Which_after:
		return s[0:5]
	case TriggerImpl_Which_at:
		return s[5:7]
	case TriggerImpl_Which_every:
		return s[7:12]

	}
	return "TriggerImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TriggerImpl_TypeID is the unique identifier for the type TriggerImpl.
const TriggerImpl_TypeID = 0x9f7d8c878e1b63cf

func NewTriggerImpl(s *capnp.Segment) (TriggerImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TriggerImpl{st}, err
}

func NewRootTriggerImpl(s *capnp.Segment) (TriggerImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TriggerImpl{st}, err
}

func ReadRootTriggerImpl(msg *capnp.Message) (TriggerImpl, error) {
	root, err := msg.RootPtr()
	return TriggerImpl{root.Struct()}, err
}

func (s TriggerImpl) String() string {
	str, _ := text.Marshal(0x9f7d8c878e1b63cf, s.Struct)
	return str
}

func (s TriggerImpl) Which() TriggerImpl_Which {
	return TriggerImpl_Which(s.Struct.Uint16(0))
}
func (s TriggerImpl) After() (core.TriggerSwitch, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != after")
	}
	p, err := s.Struct.Ptr(0)
	return core.TriggerSwitch{Struct: p.Struct()}, err
}

func (s TriggerImpl) HasAfter() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TriggerImpl) SetAfter(v core.TriggerSwitch) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAfter sets the after field to a newly
// allocated core.TriggerSwitch struct, preferring placement in s's segment.
func (s TriggerImpl) NewAfter() (core.TriggerSwitch, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := core.NewTriggerSwitch(s.Struct.Segment())
	if err != nil {
		return core.TriggerSwitch{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TriggerImpl) At() (core.TriggerOnce, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != at")
	}
	p, err := s.Struct.Ptr(0)
	return core.TriggerOnce{Struct: p.Struct()}, err
}

func (s TriggerImpl) HasAt() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TriggerImpl) SetAt(v core.TriggerOnce) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAt sets the at field to a newly
// allocated core.TriggerOnce struct, preferring placement in s's segment.
func (s TriggerImpl) NewAt() (core.TriggerOnce, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := core.NewTriggerOnce(s.Struct.Segment())
	if err != nil {
		return core.TriggerOnce{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TriggerImpl) Every() (core.TriggerCycle, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != every")
	}
	p, err := s.Struct.Ptr(0)
	return core.TriggerCycle{Struct: p.Struct()}, err
}

func (s TriggerImpl) HasEvery() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TriggerImpl) SetEvery(v core.TriggerCycle) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEvery sets the every field to a newly
// allocated core.TriggerCycle struct, preferring placement in s's segment.
func (s TriggerImpl) NewEvery() (core.TriggerCycle, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := core.NewTriggerCycle(s.Struct.Segment())
	if err != nil {
		return core.TriggerCycle{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// TriggerImpl_List is a list of TriggerImpl.
type TriggerImpl_List struct{ capnp.List }

// NewTriggerImpl creates a new list of TriggerImpl.
func NewTriggerImpl_List(s *capnp.Segment, sz int32) (TriggerImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return TriggerImpl_List{l}, err
}

func (s TriggerImpl_List) At(i int) TriggerImpl { return TriggerImpl{s.List.Struct(i)} }

func (s TriggerImpl_List) Set(i int, v TriggerImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s TriggerImpl_List) String() string {
	str, _ := text.MarshalList(0x9f7d8c878e1b63cf, s.List)
	return str
}

// TriggerImpl_Promise is a wrapper for a TriggerImpl promised by a client call.
type TriggerImpl_Promise struct{ *capnp.Pipeline }

func (p TriggerImpl_Promise) Struct() (TriggerImpl, error) {
	s, err := p.Pipeline.Struct()
	return TriggerImpl{s}, err
}

func (p TriggerImpl_Promise) After() core.TriggerSwitch_Promise {
	return core.TriggerSwitch_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TriggerImpl_Promise) At() core.TriggerOnce_Promise {
	return core.TriggerOnce_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TriggerImpl_Promise) Every() core.TriggerCycle_Promise {
	return core.TriggerCycle_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

const schema_838375eaedd19910 = "x\xda\xec|}|\x13U\xd6\xff\xdc\x99$\x93\x14\xb1" +
	"\x8d7@A\xf0\x96.U\xac\xa8\xd0\xca\x0a\x11\x9e\xd2" +
	"\xd2\"\xedRhr\x8b`\x05\x97I2mS\x92L" +
	"\x9cL\x0a\xed#\x0f/\xbe\x80\x08\x0a\x0a\x0a.((" +
	"((,\xe8\xfa\x02\x08\x0a\x88/(\xac\xa0\xb8\xf2&" +
	"\x82\x82\x02\x02\x02\xc2\x0a\"\xcc\xefs3\x99d\x86\xb6" +
	"S\xd8\x0f\xfb|\xdc\xdf\xe3\xbf\xf9\x9e\xf3\xcd\xbdw\xee" +
	"\x9cs\xee9wNW6\xbd\x0f\xdd\xcd\xfc\xb8\x85\xa2" +
	"\\\x03\xcc\x16\xb9d\xdd\xac\x17VOt\x8d\xa3\\W" +
	"\x03 \xa7\xcd\xdez\xf4p\xf4\x81\x07\xa8\"\xc0\xda(" +
	"\x0a\xde\xcc\xec\x84=\x19\x16\xf6dP.\xcf\xc8\x80\x02" +
	"\xb2\xc3|\xb0\xfeV0sbC\x85\xeb)\x0a\x9e\xb7" +
	"\xec\x846\x96\x856\x16\xe5vg\x87X) \xd7\xde" +
	"}f\xdb\xf4\x87\x0fNi\xa8@STn\xcf\xd6\xed" +
	"\x00,n\xcd\xc2\xe2\xd6\x08F[\x8f\xa2\x80\xfc\x07\xf3" +
	"=\xdf\x9c\xec\x0d\xe66T`(\x0a\xb6ms\x18f" +
	"\xb5aaV\x1b\x04]m\x96Q@\xfe\xd4{\xedc" +
	"\x13\xa7\x8cy\xaeq\xf9\xc1\xe9\x9fA.\x9d\x85\\:" +
	"\x82S\xd3\x89\xfc\xa8\x89\xe9K\x06mm\xf1|C\xf9" +
	"T\x8a\x82\xd3\xdb\x9e\x84s\xdb\xb2pn[\x94\xbb\xb5" +
	"\xed \x86\x02r\xcb\xd9\xd1\x0d\xbb\x06]\xffBC\x85" +
	"\xab)\x0a\xaeC\xbf\xc0\xcd\x88\x85\x9b\x11\xca=\x8f\xda" +
	"\x10\x85\xd7\xba]\xbd\xe5\xc8\xb9\xc8\x82\x86\x0a\xe9\x14\x05" +
	"gf\xed\x84\xf3\xb3X8?\x0b\xe5~\x91u\xa7\x99" +
	"\x02\xf2\xaa\x0e\x8b\x87\xdf\xb8z\xc3\xa2\x86\x0a&\x8a\xca" +
	"\xcd\xbf\xb5\x1d\x80\xae[Y\xe8\xba\x15\xc11\xb7~O" +
	"\x01\xb9\xc7\xfa\x9d\xafq\xbd\xff\xb0\xb8\xa1\x82\x85\xa2\xe0" +
	"\xa1\xae\x87\xe1\xe9\xae,<\xdd\x15\xe5v\xec6\x84<" +
	"\xb6>S\xda\x9ez\xe2\xdak\xdfi\xa8\xd0\x82\xa2\xe0" +
	"\xf0\xdc\xc3\xd0\x9f\xcbB\x7f.\xca\x9d\x99+\xd0\x14\x90" +
	"\xbdC>\xc4\x7f\x1b:m]C\x05\x96\xa2\xe0\xab\xb7" +
	"\x1f\x86kng\xe1\x9a\xdbQ\xee\xd1\xdb\x1f'\xff\xb0" +
	"\xf1\xa7?-(z\xfd\xf8\xdf\x1b}\xcep\xbe\xf3\x17" +
	"\xb8\xd4\xc9\xc2\xa5N\x04\xbfr\x92\xc7,\x1d\xef\xd95" +
	"\xf8\xf7\xa7\xb66\x94O\xa1\xa8\xdc\x99w\xa4\x00\xb8\xf0" +
	"\x0e\x16.\xbc\x03\xe5\xee\xb8\xe3v2\xa4\xdb>:\xfd" +
	"v\xf8~\xef\xbe\x86\x1aV\x8a\x82\x9b\xf3~\x81;\xf2" +
	"X\xb8#\x0f\xe5\xda\xfa|H\x864pC\x99\xbd\xf5" +
	"\xdb\xbb\xbem\xa8p\x0dE\xc1\xb3\x05\x87\xa1\xb9/\x0b" +
	"\xcd}Qn\xf7\xbe?\x93\x07\x87G\xa5\x09\x07w\xf5" +
	">\xdaP\xe1\x06\x8a\x82\xf6\x92\xcf`\x87\x12\x16v(" +
	"A\xb9\xc5%\x8f\x93\xcd=\xea\x1f-F\x0d\xfa\xf0\xd8" +
	"\xd1\xc6\xf7^\xcf\x8a\xc3\xb0\xa8\x82\x85E\x15\x08\xdeW" +
	"A\xf6^\xcb\x87\xb7\xef\xbe\xc7\xe6:\xd5\xb8|\xf4\x9e" +
	"_\xe0\xf8{X8\xfe\x1e\x04\x97\xdeC\xe4\xb9@\xa0" +
	"o\xd0\x17\xb9\x85\xf6r\xe1P\xd8Y r!o5" +
	"/\x16\x07\x99p\xa0\x0c\x00\x97\x09\xd0\xf2\x0f[n\x0c" +
	">\xfaR\xe6\x93\x94\xcbD\x83\xfc\xf6\x00\\EQv" +
	"\xf0\x99\xdc\x9f\x0f\x84y1\xa3\x92\x16\xc4\x0co\xb5 " +
	"D\xf8\x0c\xce+\xf9\x85\x10\xb8\x85\xa2\\\x9d\x18\xd3U" +
	"\xb2l\x02\x14e?Zb?\x81\xb0\x030\x00g\x00" +
	"\x1a\xb4\x04\x17d\x07\x00\x14\x05;\x80\x12\xd8\x11 \\" +
	"H\xa02\x02\xd1\xe7e\x07 \xcf\xb3\x14\xd4@\x17@" +
	"X\"\xd08\x021\xbf\xca\x0e@f1\x06L\x80\xe3" +
	"\x01\xc2\x8b\x08\xf4:\x81L\xe7d\x070\x91m\x03\x9e" +
	"\x87+\x01\xc2\xfb\x09t\x9c@\xe6_d\x070S\x14" +
	"<\x0a\xb2\xe1Q\x80\xf0U4\x03p:M\x83\x96\x96" +
	"\xb3\xb2\x03\x90\xed\xdc\x8a.\x81mi\x84{\x11\xa8?" +
	"\x81\xd83\xb2\x03\x90}XD{`1\x8dp\x80@" +
	"\xa3\x09d\xfdYv\x00\xb2\x1f\xa2\xf4\x04XG#<" +
	"\x8f@Kh\x1a\xc8| \xc2\x17\x0a\x85\x02EQ\xb1" +
	"\x85\xfb\xb0t\xdb\xd2%\x82c\xaa\xb2p\x8e\xf8\xc2U" +
	"\xc8E1\xb9\x0c\x1f\xc5\x08N\x8a\x02ir\xe1\xa6y" +
	"\xa7?\xf9\xa0v\x19E\x01\x90F)D\xc5\x95\x97F" +
	"T\\\xe9L\x12\x1d\xb4\x0d\x94\xd7>\xb0yk\x03\xa2" +
	"T\"j\xc05!\xc1\x05\x04'\xd1rR\x06\x84\xfd" +
	"D \x04\xf3C\xbeB\xa1\xb1\xf1\xa5\xc79\x9fW9" +
	"+\x81(\x04\x9d\\\xc8\xe7d}\xf1\x81^\xcf\xbfs" +
	"o\xd8Z\xfdxS\xbcEl\xe3\xe3Uw\xdf\xc7\x09" +
	"nZ\xe5\xf6\xa9\x03\x07\x0d\xf9S\xfd\x95\x85B#t" +
	"iq:g\x1e\x99z|l]\xae\x1f1\xadh\xa6" +
	"y\x9e:6\xa2K\xfe\xcd\xf8ixd\x85\x82\x0fP" +
	"ll\xf9\x1ae\xea'\x92\x09R\xac\xaf\xd1\xe1$\x9f" +
	"\x06\x99\x19\x99\x18\x88\xcfLy\x1a5\xed\xef\xe8\xb3y" +
	"q\xbb\xc5\x17\xf3\x01_|\x84\x06O\xe3\xe5\x06\x9c|" +
	"j@\x1d\xe8\xc5\xc4\x17\x99\x85r~\xb4TT\xcb\x05" +
	".\xc1,\x9c\x94\xb1\xc4I|\x90\x0f\xd1R$cT" +
	"\xb5\xdf[\x9d!\xf2RT\x0ce \x89\x1f-\x11\xd3" +
	"0+a\x1a`[\x93\x08;\x98\x10\xeecb\x00\x1e" +
	"`\xd2\x1a\x87bS\x0d,5!\x1c&\xd0\xfd&\xad" +
	"q\xa83U\xc01&\x84\xe7\x11h\x89Ik\x1c\x16" +
	"\x9b<p\xa9\x09\xe1-\x04\xdam\xd2\x1a\x87\x1d\xa6\x1c" +
	"\xb8\xc3\x84\xf0\x19\x02\x99\xccZ\xe3\x00\xcc\"4\x9b\x11" +
	"\xeelf\x00\xbe\xcd\xac5\x0e\xdd\xcc\x05\xb0\x9b\x19\xe1" +
	"r\x02\x8d0k\x8d\xc3ps\x09\xe4\xcc\x08?H\xa0" +
	"if\xadq\x98j\xce\x86S\xcd\x08/!\xd0\x0a\x02" +
	"\xd9\xfe);\x00\x89y\xde0\xbb\xe1J3\xc2\xbb\x09" +
	"t\x90@)\xa7e\x07H\xa1(x\xc0\xec\x84\x07\xcc" +
	"\x08\x9b,\x0c\xc0i\x16\x1a\xb4lqJv\x00\xe2A" +
	"[Zr`K\x0b\xc2]\x08\xd4\x83@W\xfd$;" +
	"\xc8\x9a\xc3\xee\x16'\xecnA\xb8\x9c@#\x08\xd4\xf2" +
	"\xa4\xec\x00-\xc9\x08-5\x90\xb3 \xfc \x81\xa6\x11" +
	"\xe8\xea\x13\xb2\x03\x90\xb0b\xaa\xa5\x00N\xb5 \xbc\x9c" +
	"@\xab\x09\x94z\\v\x00\x12\xa2\xac\xb4\xb8\xe1\x1a\x0b" +
	"\xc2{\x09t\x84@i?\xca\x0e\x90F<\xbf\xe5y" +
	"x\xc2\x82p:\xcb\x00\xdc\x89\xa5AK\xfb1\xd9\x01" +
	"\xec\x14\x05;\xb2O\xc0\x1bY\x84\xcb\x084\x8c@\xd7" +
	"\x1c\x95\x1d\x80x\xc2\xbb\xd9\x0a8\x9cEx\x1c\x81\xa6" +
	"\x10\x08\x1e\x91\x1d\x00R\x14|\x84\xad\x80SY\x84\x97" +
	"\x13h5\x81\x1c?\xc8\x0e\xe0 \xc3`\xeb\xe1\x1a\x16" +
	"\xe1\xfd\x04:N\xa0V\x87e\x07hE\x8c9[\x0f" +
	"O\xb0\x08;\xac\xc4\xa7Xi\xd0\xb2\xf5!\xd9\x01Z" +
	"\x13\x9fb-\x81\x1d\xad\x08\x17\x12\xa8\x8c@m\x0e\xca" +
	"\x0e\xd0\x86\xf8\x14k\x0dtY\x11\x96\x084\x8e@\xe9" +
	"\xdf\xcb\x0e@b\xa61\xd6\x028\xc6\x8a\xf0<\x02-" +
	"!P\xdb\xefd\x07hKv\x945\x07.\xb6\"\xfc" +
	"\x11\x81\xb6\x11\xa8\xdd\x01\xd9\x01\xdaQ\x14\xdcju\xc2" +
	"\xadV\x84OY\x19\xe0\xb6\xd1\xa0\xe5\xb5\xfbe\x07\xb8" +
	"\x96\xc4\xa9\xd6\x12\x08l\x08w\xb21\x00w%P\xfb" +
	"oe\x07hOb^[\x01\xbc\xd9\x86p\x19\x81\x86" +
	"\x11\xa8\xc37\xb2\x03t \xebd\xf3\xc0\xe16\x84\xc7" +
	"\x11h\x0a\x81\xae\xdb';\xc0ud\x9dl\x1e8\xd5" +
	"\x86\xf0r\x02\xad&\x10\xda+;\x00\"\xebd\xab\x80" +
	"kl\x08\xef%\xd0\x11\x02e|-;@\x06y\\" +
	"\xb6\x12x\xd4\x86pZ\x0a\x03p\xfb\x14\x1a\xb4\xec\xb8" +
	"Gv\x80\x8e\xe4\xcdK\xc9\x81mS\x10\xeeA\xa0B" +
	"\x02e~%;@&E\xc1\xfc\x94L\x98\x9f\x82\xf0" +
	"\x08\x02\x05\x08\xf4\x87\xdd\xb2\x03\xfc\x81\xa2\xa0?\xc5\x0d" +
	"\x83)\x08O#\xd0\x1c\x02u\xda%;@'\x8a\x82" +
	"\xb3Sr\xe0\xec\x14\x84W\x10h\x03\x81\xb2v\xca\x0e" +
	"\x90EB\xd8\x94L\xb8.\x05\xe1\xbd\x04:\x92B\x03" +
	"\xd9#r\xde\x91\xbcTN!~\xb4\xd4\x8c-,\x88" +
	"\xcb\x02~\xb4\x94\x91\xb0\x85O\xbd1e\xca-\x13\xd0" +
	"\x0b\xaa\xc9\xf2D++y\xb1\x9c\xa7R\x9b!\xac\x97" +
	"\x0bT\xd1<\x95\x90\xf8\xe0\xd7\xfe6\xe2\x1f\xc7\xea\x9f" +
	"Q\xf9\xbc\\\xd8/q\x01?\xc5\xd4\xf3\x86f\xbf\xaf" +
	"*\xc8\xd6+\xd6\xf4\xc2\xab[\xee\xef:\xc9\xfa\xacJ" +
	"$\x04\x83\\9?\x9ab\x8d\xc7%\xca}UI\x94" +
	"\x1c\xd6s\xcf\x1c\xc5m\xf2>>\x1c\x1f\x16\xf2\xd6y" +
	"\x03\xbc\xa1'\xebK$\x14\xe5\xeb\xee\xef`\xfb\xf3\x81" +
	"\xe1\x09\xff\xe3\xe3%^\x0c\xfaC\x14\xe2\xf3\xc5\xaa\x88" +
	"\xe1\xaa\x17\xc6e\x01\xef\xe4\xc4\xaaH|\xd5\x07\xdf\xe9" +
	"\x9d\xf7\xf27i\x07\xe3\x8cc\xabx\x89\xb8 \x03&" +
	"\xb7|'/\xc5\x1c\x0f\x05\x94Q\xf5\xb9\xa3t\xc3\xfa" +
	"\xbb;\xaaS\x92\xabx\xa98\xe4\xe3G7\x17\xed\x10" +
	"\x1e\x7f\xc8\xc7S\xcch\x85h\xdb\xed\xfd\xfb\xd6\xa6\xbf" +
	"\xb5=\xe1\xe4}\x83*\x0d\x96&\x07\x15\xfb\x06U*" +
	"\xaa\xb3\x96\xbdl.]`\x9f\xaf\x8e\xa1F\xf0\x87\xca" +
	"8Q\xa2@\xc4\xf0a\x97\x08\xfe\x903\xcc\x89\x14+" +
	"E\x14\xa6\xbb\x97\xb7x`\xb5\xf7\xac:\x9b\xbc\x91\xfe" +
	"\x90\xf10\x0a\xc6\xfe)&\xa2\xa8O\xfe\xb8\xff\x9e\xbb" +
	"\x07M{O}\xbe\x01a\x14/\x1a>\xdf\x01DB" +
	"Q>\xfav\xef\xf4\x1f\xcep\xd3\xd4\xff\x0eqA\xbe" +
	"\x99\xff\x1e\x18\x13Q\xd4\xa3\xdf\xf4u?\xd8\xe6\xe5m" +
	"\xea\"\x84\xa2A^\xe4\x02C\xa8TA\xf4E\x0c_" +
	"\xa1\x81\x8ah\x06\x957\x8a\xc8*|3\xee\xe8qo" +
	"\xde\xe7\xb5\xeav\x1b\x1b\xe73 *Q\x89\x9c1\x1d" +
	"\xf9\xab\xec\xb9\xbb\xbe\x9b\xb2\xf7\x82:\xa2p *r" +
	"\x01\x7f=\x05x\xc3\xadQ\xa6\xca1\xf1\x9d\xbf'\xa7" +
	"\xef\x7f\x8f\xfdt\xc3\xf7*\x91\xc8{\xfdaQ\xf0\x02" +
	".\xe0\xe6\x03\x83<5,\xef\x95\x0c\xa2\xa5U\xb2;" +
	"\xa9\x91!\xf2\x01\xa7\x90\xe7\xa9\xe1\xbd\x92B\xdf~\xc7" +
	"\x97\xdb>\xeb\xf2\xc8\x93I\xfa\x00'\xf9ky\xa0\x90" +
	"\xf3^ \x19\x86bnU^\xa1\xf6\xd4\xa4&\xa8\x87" +
	"=\xbbm\xf9\xd5S\xda\xcdOR\x87|\xbc\x98/R" +
	"\x8c\xe1\x0b[#\xbbc\x82N\x8eJU^W\x90&" +
	"\xafx\xb4o\xe7\x8a\xe9\xfe7\xf4\\\x039\x8a\x09\x1a" +
	"\xdb4\xb7*\xc8\x06\xe3\x0bZ\x8f\xf7/\xde`\xb9\xe9" +
	"\x9c\x9e\xca\xcdSy\x95\xfd\x02\\\xa3CS\xa7;9" +
	"N\xe7\xe6A\xa5\xb3\x92\x08+1\xfaw\x0fO{\xe4" +
	"\xc0\xce\xe7\xd6\xe9)\x89Y\x0e\x86\x03\x9c\xc4\x1bn@" +
	"\xf7E\xc2\xb1A\x9e\xb9i\xe8\xc0\xc7\x8e\x01\xcd|#" +
	"a!\xd4\\\xe4\xee\x96\xdd\xaa\\\xdcB\x8d\xac\x19\xd9" +
	"\xb9\x7f\xea{\xbb\x1a\xf0\xa4\x92H\xb8\x99q\xc5E\xf3" +
	"\x9c$\xdcm\x94o\xac\xc8\xd7\xf2\xa2\xe1y\xacDv" +
	"+2\xf1\x17c\xed++S{\xafs.P\xcd\x84" +
	"(\x8c2<\xd0\x14\x8cu\x0b\xa3\x12ND\xde\xf8\xe5" +
	"\x97m_HY\xa8\xda\x09Q\x18\x151\xf4E%\xb2" +
	"[\x18\x15\x89\xeb\x834y\xf8\xf0%\x05\xe5\x8b>\xdf" +
	"\xa2.H\x84\x0fI|\xc8\xdb\xec\xc2bU.\xbe\xb0" +
	"\x11O\xa7\xc1\xe7\x16\xb5~L]\x88Hu\xb4\xb22" +
	"`\xbc\x10X\x91\x89\x8f\xe4.\xfb\x8f\xc5g\x0ew\x99" +
	"\x95\x18\x89?T\x15\x0d\x10\x83\xec7\xf4\xd352V" +
	"%S\xfdqG-\xbf\xd0\xed\x11\xc1\x9dN\xbf\x99 " +
	"\x0bp\x91\xeaKr\xd5X\x95\xd4\xb8\xeaU]\xd7Z" +
	"\xd3\x868&&\xd8\xc2\\\x88\xec\x17\x8a1$\xab\x91" +
	"\xb1*\x98\x9a\xe0\xfa\xe9\xd1\xdb\xcb\x82w\x0cOD7" +
	"\x11I\x08\x87\xfd\xa1\xaaf\x17\\\x95\x8b/\xf8\x13\x08" +
	"=i\xe5~8\xa9\xee\x1b\xc9/5\x13>\x94\x13\x09" +
	"E\xf9\x86w{\xf7\xf9\xcb\x85w\x97\xc7\x95Y\xa9\xd1" +
	"\xbd\xaf\xaaf\xa7\x96\xab\xfb}\xf7='\xf3n\xeau" +
	"\xd7\x83\xea\xe8\xa5\xd1RqeQ bl\xc6kd" +
	"B\xe0\xaft\xf2T\xf2d\xfa\xdc\xecOJ_\x98\xb1" +
	"\xe0\x9f\xea\x04\xa2\xe1p3\xfeq0\x91P\x94\xb3\xbb" +
	"OZ?\xadl\xe4\xf3\xea\x04j9\xd1p\x02wq" +
	"q\xc5\xbek\xaey\xdc}\xa2t\xe3\xc5\xe7aF9" +
	"\x0f\x17\x87$\xa1\x9c\x13I\xf0\xe3\xe7\x03\xbe\xc8%\x9c" +
	"\x8bw\xea\xd2e\x11^\x92\xfc\xa1\xaa\x8cJ\xa2\xceD" +
	"\xc8\xa1\xd8\x9a\xcc\x97\xdd\x98i\xbf\x11\xb9\xfa3\xc0U" +
	"\xae9\x10\xdb]\x99v\x17r\x85\x19\xe0\xba\x9f\x06\xac" +
	"\xe0\xa91\x9c\xcb OM|\x05\xd7\xbcb\x9e\x9b\xb6" +
	"\xe9\xe9\xcb^\x84\x03Kn\x99t>e\xe8\x99&\x92" +
	"\x02\x03\xfc\x11\x09\x0bQ\xd1\xcb\xa7\x16\x07\x9b\x9b\xfe7" +
	"\xba\xe9s^/\x1f!onF\xc0\x1fa\xa5\xd8\xfc" +
	"\xafJ\xce\xbf(\xdb^\x84\\>\x06\xb8\xc2\xda\xf9\x07" +
	"\xb3\xedA\xe4\x9a\xc2\x00\xd7,M2\xc0>3\xdb>" +
	"\x13\xb9^g\x80k-\x0dRC\xd1`\xc40\x06\x1c" +
	"\x18\x0d\xc6\xbd\xe3\x90\x07\x84\x1b\xffy\xab]\xcdm\xa5" +
	"\x8a\xbc\xd7X\xd5\xcd{\xe3\xaa\xf7\x8e\x88\x0e\xf3To" +
	"\x96UUi\xb4d\xacZ>Z\x8d\x17\xff\xf8\xc0\xb3" +
	"\xfb7\x1d\x8b>\xd5T\xaaE\xf4WU\xf1bq0" +
	"\x0c.kI\xbdB4\x14\xdbR\xb5\\ \xca\xf2\x0d" +
	"\x964\xa7\xf1%m\xd7\xf8\x92\xe6h\x96\x14q\x95\x92" +
	"\xe1+\x97\x83\xf2\x89\x84\x12\xdb\x9f\xfe\xe3}7ux" +
	"hn|v\x0cgd1\xda1\xf9RLkb\xfd" +
	"\xd0V\x0f\xce\xf1\xbc\xa5\xbe\xe4\xc4\xf5\xd5\x19\xfec\x11" +
	"\x91\x88\xe9\xbe7\xf6\xd8|[\x1f\xf1\xab&\xd6s`" +
	"4H6jQ-\x87\x02Mo\xd3N1\xe2n\xa0" +
	"\x02$\xd2W\xa6\x8b\xd3W\x1c\xd9\xacR\x86P\x99\x11" +
	"\x8a\x06=\xbc\xa8\xbc\xb6\xbd\x92\xb9\xac\x99@\x84\xb3\x01" +
	"\xc2\xab\x01\x03\xf0G\xbaD\xf7\xfb\xa0\x00\xbe\x0f\x10>" +
	"H\xa0S\xbaD\xf7\x09\x90\x0dO\x00\x84\xd3hrD" +
	"\xa7\xb5\xb9\xac\xb6tN,/\xdd\x83@\x85\xb46\x97" +
	"\x95O{`\x11\x8dp5\x81$Z\x9b\xcb\xba\x8fv" +
	"\xc3(\x8d\xf0,\x02-\xd0%\xba\xe7\xd3\x13\xe0B\x1a" +
	"\xe1M\x04\xda\xaeKt\x7fAW\xc0\x1d4\xc2\xbf\x12" +
	"\xc8\xcahsYf\xa6\x1e\xda\x18\x84\xbb2\x0c\xc0\xbd" +
	"\x18m.\xab'\x93\x03{2\x08\x0f%\x90\x8f\xd1\xe6" +
	"\xb28\xa6\x04\xf2\x0c\xc2\x93\x084\x83\xd1\xe6\xb2\xa63" +
	"\x15p&\x83\xf0\x0a\x02m`\xb4\xb9\xacu\x8c\x08\xdf" +
	"g\x10>B\xa03\x8c6\x97u\x9aY\x0f\xcf3\x08" +
	"w61\x00\xdff\xd2\xe6\xb2\xba\x992a7\x13\xc2" +
	"e\x04\x1af\xa2\x7f\xa3'\xdd\xcb0N_wl\xbb" +
	"\xf8\xeb.m\xc6\xab\xe1\x1e\x17\xaa2v\xdbn\"\xa1" +
	"\xfck\xab\xb7\xff\xf4\xf1\xaa\xe0\xa4DT\x13S.\xa8" +
	"\xc3\x14+\xf1a\xc3\xa8F!\xf1\xd4Q\x08K|\xd8" +
	"\x80\xad\x9f(P h|\x84\x88qU\x8a\x14+\x04" +
	"\x8d\x99@\xb0\xa0\x8e\xfc\x9fQ\xf6\xfa\x99\x04\x1f\x10\x82" +
	"N\x0f\x91g\x9a\x1a\xe0\x15?0]\xc9S\x0e\x8a\x04" +
	"\xfc^\xe3G\x89\x89\x842\x9e\xf5_.]X\xb9\xf0" +
	"\xfa\x97\x92\x01\xaa\xdf\xcb\x17\x85|\xcd\xa5J\x14\x0a>" +
	"D1>\x03\",q\x14#J\xc6\xb1i\x8c)\"" +
	"Q\xa9\x9c(5\xc3\x85D\xa9(\xe43\\#\x95\x0e" +
	"\x106>\xe4S\xd6\xa8\x01cX\xa1\xa49Qr\xf3" +
	"A\xa1\x96/\x0eExQ\xa2\x0c*B\xdf\xc88\xac" +
	"\x90\xd3\x12!\x17czN\x7f(\xc2\xb3\xea\xc8\x85\xfe" +
	"[\xdb\xd8M\xe7\x96^\xb1xPS\x1fQ\xbcL\x1e" +
	"g\xe0e2\xe2^\xa6\xe0\x92\xbcL\xbcZB\xb9z" +
	"$]L\x1d\x10\xe1\x18\x80\xf0<\xe2G\x96\xe8\\\xcc" +
	"bP\x00\x17\x03\x847\x11h\xbb\xce\xc5|\x01\x0a\xe0" +
	"\x17\x00\xe13\x042\xe9\\\x0c\xa0_\x866\x1a\xe1\xae" +
	"\xc4\xec\xf7\xd2\xb9\x98\x9e\xf430\xbf)\x17S\xd1\xb4" +
	"\x8b\xa9o\xda\xc5\xe4\xc0/h\x84O\xd1\x0cp\xeb<" +
	"\xccy\xba\x04\x02\x06\xe1N\xc4\xeaw\xd5y\x98\x9b\x99" +
	"\x0a\xd8\x8dA\xb8\x9c@#t\x1ef8#B\xae)" +
	"\x0f\xb3\x1e\xcef\x10\xde@\xa0-:\x0f\xb3\x99\xc9\x86" +
	"\x9b\x9b\xf20\x99\xf04\x83\xb0\x83\xb8\x91\x8c\xdf\xac\x1b" +
	"\x19;\xd2\x1f\xf2E\x1a\xcd\xf3%O\xcd\x7fRd\xe2" +
	"\xa7\xe633\xe7g~\xb6\xaa\xfd\x93\x8d\xa4\xc3\"\xb1" +
	"\x94Uj\x8dq>l}\"\x1fFs\x81\x88\x9a\xb5" +
	"R\x92Vd\x88;\xfe\xe7\xf9;\xd7\xed\xfe\xf3\xee\x06" +
	"\x09\xb1H<#\xc6\x18\xd2\xbf\x96\xcc\x88\xa9\xe4(\x99" +
	"m{s\xf7\xac\x82\xf6\xdd\xfb\xbf\xfc\xbb\x85\xff\xdd\xc2" +
	"_\x9e\x85\xbf\x9c\x83\xd9\xae\xb1U\xa9\xef\xbd\xb4\xeb\xc9" +
	"+\xed\x1c\x0a\x04!\xd0L\xf1\xfcR\x8e\x1f\x92\x18\xe5" +
	"o\xad\xe4\x02\x11>v\xc4\xe3\x95\xe3\xc7\x88\xa4o\x98" +
	"N\xe7\xc0\xe94\xc2\xcb\x89\xe5]Mk}\xc3J\xda" +
	"\x09W\xd2\x08o'\xd0~Z\xeb\x1b\xf6\xd19p\x1f" +
	"\x8d\xdc\xc4\x1a^\xc5h]\x83\x8d\xc9\x8e\x85\xfd\x9d\x09" +
	"t\x1b\xa3u\x0d\xdd\x98\x12\xd8]\x17\xf6'\\C\xc3" +
	"\xb0?\xe1\x1a\xa635\x17\x85\xfd\x09\xd7\xb0\x8e\xa9\xbf" +
	"(\xecO\xf8\x86\xd3\x8c\x08\xcf2\x08\xb7'F\xb9\xb3" +
	"I\xeb\x1b\xb2LN\x98eB\xb8\x90@e&\xado" +
	"(5\x95@\x97\x09a\x89@\xe3LZ\xdf0\xc6\xe4" +
	"\x81\xe3M\x08/ \xd0r\x93\xd67,5\x15\\t" +
	"y \xe1\x1bv\x98<\xf0+\x13r\x9b\xc9:\x99\xb5" +
	"\x87\x0f\x9b\xb9\x00\xda\xcc\x08w!P\x0f\xb3\xb6\x90\xde" +
	"\xdd\\\x00\xbb\x9b\x11\x1eJ \x9fY[H\xe7\xcc%" +
	"\x907#<\x89@3\xcc\xdaB\xfat\xf3\x048\xd3" +
	"\x8c\xf0j\x02}d\xd6\x16\xd2\xdf7\xbb\xe1F3\xc2" +
	"G\x08t\xc6\xac-\xa4\x9f6g\xc2\xd3f\x84\x1d\x16" +
	"\xe2\xbc,\xdaBz\x07K\x05\xechA\xb8\x90@e" +
	"\x16m!\xbd\xd4R\x0f]\x16\x84G\x13\xe8A\x8b\xb6" +
	"\x90>\xdeR\x01\x1f\xb2 \xbc\x88@\xaf[\xb4\x85\xf4" +
	"W-\x99\xf0U\x0b\xc2[\x08\xb4\xdbB\x03\xc4\x05\x02" +
	"\x86\x85'g^>\x91P^\x98\x87\x7f\xfe\xeb\xd4e" +
	"\xdfGT{\x9e\xc7\x05Fqu\x91f\xb4\x89HL" +
	"\xbb\xe4\x81\xcf\xfd\xe3?\x19\xfc\xa5jn\xb9P]s" +
	"\x7fM$\x94\xbf\xf6\xcd\xfe\xa1\xe0\x89\xf1\x87?P\xed" +
	"\x83G\x10\x02\x86\xf6\x81\xbc\xbd\x8aju\xb0\xf5\xbd\xbd" +
	"\x17.\xfbk\xa2@\x1c\x0c\x17G\x06F\x83\xcd]\x0b" +
	"\xea\x1b\x0c;\xfd\x11g\x88b\xa3\xf1\x83\xd0'\x93\x07" +
	"\xbft\xd8+\xbf\xafc*\x1f-]\"\x93D\xb1j" +
	"\xa2ur\xbb\xdbN\x1d\xdas\xdf\x8e\x04\x93\x10\x928" +
	"\x7f(B\xa5\x96q\xa2q\xa1\xa2\xaf*\x9a\xe7\x0c'" +
	"\x0c\xff\xb9#\xc3#\xedk\x9cO$\xf9\xa2!iP" +
	"e9\x95\xa7\xa4\xa5\x0c-\x7f_E\xd8\x09$EX" +
	"\xb1\xfc\xfd\xae\xcd\xf0\xefh\xbf\xf0\xe3\x7f[\x0d:\xcf" +
	"\x17\x15\xfd\xa1*\xc3bHaLD\x99\xa3i\xeb\xe4" +
	"\xad\xefL\xe8\xa0n\x01\xb9\xd2\x1f\xf2\x91\xe0\xbd9\x8f" +
	"\xdb\xcf\x1f\xf29\x03\xfe\x08\xc5\xc4\x17\xcb\xb9a\xe2S" +
	"\xdfz>\xda\xa0\xa9c\x0f\xf2\xd4\x94\x8b\x14\xcb\xf9\x8d" +
	"\xd7\xfeN^\xca\x10<5N*O\x129\x7f\x9c\xee" +
	"\xc2\xc9\x0e\x9b\xce\xed\xda<\xe7J\x96\xd6\xab\xb9H\xa1" +
	"@\x16\x9b\xf5\x0b!\xc3(\xa0\xbf*\x99\xea\x17B\x0a" +
	"\xd9\xb4\x89\xb6\x8f\x8f\xde\xfe\x8b:\xbf\xb1\xfeHQ0" +
	",\xd5\x19\x0e\xa88\x92\xc1\x13!u@\xc7\xff\xf8R" +
	"\x87\x13\xe5\x9f\xbc\x9e\xe4\xb8\x8b\x0b\xf8}\xcdq\xd4\x12" +
	"!\x95\xe3\xd0\xa9?v+^\xc9\xff\xa0NJ\xa9\xb0" +
	"\x17G\x9a{`\xf12\xbb\x9fb\xe2\x1e\x9e.\xd9\xf1" +
	"\xf9\xb1'\xce/\xbc\x98\x08\x14\x8d\xe6\xbcR\xa0\xce(" +
	"\x01\xf1D\x82\x0eD\xe2\xe2\xf1\xe1\x9du\xff\xbc\xbf\xec" +
	"\xc4\xc3\xc7T\xd6 'y\xab\xf9H9\x05\x04\xc3\xb7" +
	"\xb9T\x91sR\xac\x14/\xfa\xbc3A|\xfd\x919" +
	"\xc3\xd4\xb7\x8f\x0d\x09\xc6\xf5\x96\x81B|\xeb<v\x0b" +
	"8\x94\xfd\xb8\xf0\xf9\x7fF\x80,G\xf8\x90\xaf\\h" +
	"vx\xa2\x8cI\xfcHV\x07q\x89\xf1\xb5}r\xc5" +
	"wC\x9fz\xe2\xf4\x95\xae\xe9\x90wM)g\xfc\x8b" +
	"5\x9d\xaa\x865\x9d\xb4d\x02\x9e\xcb\xb4s\xc85\x8e" +
	"\x01\xae)\xda\x04\xfc#\x99\xf6G\x90k\x11\x03\\\xaf" +
	"k\x13\xf0\xafz\xeco \xd7v\x06\xb8\xf6kB2" +
	"\xfb\xbeL\xfb>\xe4&\xa7\xf8\xab\xc0\xe5\x94\x80\x1e\xb2" +
	"\x07\xe7\x8c_\xb6U}\x00\xac\xc8{\x0d\x15\xdd\xbcW" +
	"Q\xfc\xf6\xfb\xcc\xed\x93\xffk\xc6+\xfa\xcd\xd0\xcfO" +
	"\xb1|\xc0w\x09;\xab\x9f\x9fJ\xe5\x03\xf1\x13J\xf9" +
	"\x8a\xdei\xcbr>\x7f\xe6\xb2\x9f\xdci\xd7\xae\x8c\xdb" +
	"^=y\xbe\x89\x00\xbb\xaf\x10\x0cs\"'\x09\xe2%" +
	"\x14\xa2\x0e_T5!\xaa\xf1\xb2IjT)\x9b\xa4" +
	"'\x9f\xda\xec\x02\xfbl\xe4Z\xc1\x00\xd7\x06\xedS[" +
	"\xe7\xb4\xafC\xae\xbd\x0cp\x1d\xd1>\xb5C\x05\xf6C" +
	"\x08[\xc9\xf3q\xe8n\xac\xdb\x81\x07\xb6\x02\x08\xf7 " +
	"P\xa1\xee\xc6z>(\x81E\x00\xe1j\x02I\xba\x1b" +
	"\xeb\xf7\x017\x8c\x02\x84g\x11h\x01\xa0\xc1XN\x1a" +
	"\xc0s\x11\xc9\xd0\xd5\xe5+2\xb1\x85\xbbu\xc8\x80\xbf" +
	"\xbe64\xeb\x85D\xa0%\x95\x0a\x86\xea\xce\xbc\xfc\x98" +
	"HL\xfb\x1f7\xac*{\xfe!\xac>\xaf\xb1\xfc}" +
	"Q.Pn|\xeb\xa0H\x91\x89\xe9o\xb8\xfb\xf0\x93" +
	"\xb9\xdb\xd7&\x12\xb3U\"\xcfI\xbcXN\xb1\xd5\\" +
	"\xc8\xd04\xde\xa9\x95\x8cq\x15m\xe9\xbc\xe7\x93\x03\xa3" +
	"\x12\x8e-\xc0G\"\xe51\x902L\x83\x0cH\xc8\x11" +
	"C\x94\x952\xfa\xbd\xd7N\x8eO\\x\x12\xa4j^" +
	",\xaf\xe6(\x102\xf4H\x83\x92rJB\xe2\xb1o" +
	"\xbcC1s\xa1\x89\x0d\x99\x1f\x89\xf8\xabBA>$" +
	"]\xc2\x86<\xd9ha\xb8\x96\x13\xfd\x1c\xf2\x04\x94\x1d" +
	"\xd9%y\xca\xcb\x02\xd90K\xf7\xc9D\xe2\x94W\x0a" +
	"\x0a`)@8L\xa0\xfbu\x19\xc0:\x90\x09\xeb\xb4" +
	"[)\xb97\xe7\x83l8\x1f \xbc\x96@\x9bt{" +
	"s#\xc8\x84\x1buU\xab\xc4\xdelX\xb5J\x1c\xf3" +
	"\xda\xd2\x15\xb0\x03\x8dp\x1f\x02\x0d\xd0e\x00\x8b\xe9z" +
	"XJ#,\x11h\x9c\xeek\x8a1t&\x1cC#" +
	"<\x87@\x8bh\xed1o!\x9d\x1dK)n \xd0" +
	"\x16Z{\xcc\xdbLg\xc2\xcd4\xc2G\x08t\x86\xa6" +
	"/+\xa0\xe7^^\xd6\xfd\x9d\xefO=}\x05\x03." +
	"6\x14\x0d\x1a\xbbl\xf5\x0c \xbf\xd9z\xcd\x9c\x17\xcc" +
	"\xcf\\~iH\x9e\xf6v\xab\x9d\xf3Z?5\xfdr" +
	"\xad\xf9\x85\x83\x8f\xe6J\x8f\x7f\xf9\xd9\xe5\x97\xbb;\x96" +
	"\x8e:\xf8\xdd\xae\x9d\x93\xff3\xe2\x8bK\xbe\xa7\xf2u" +
	"\xef{*\xae\x9f|\xf0\xa3\xcb\xcf\x15\xd9?y\xe9\xbf" +
	"\xdf\xc3/\x8e\xbb\xd2\xb9\"7\xef\x15D_\x11qF" +
	"\xcd\x97\x11\xaeIf\x8b\x98\x86e\x041F\x15\xfb\x14" +
	"\xab}\xd2\xa1\xbd!\xdaW\"\xd7n\x06\xb8\x0ej\x1d" +
	"\xda\x81\x02\xfb\x01\xad\xe7J\x18\x0e;(\xb9\xc8s%" +
	"\x0cGC\xcf\x950\x1c\xf7\x81\x0a\xbd\xe7J\x1a\x8e\xf9" +
	"\xa0\x1e.\xd4\x95)\x12\x86\xe3\x0b\x90\x19+S\x9c\x02" +
	"\x0cp\xd3\xf4\xff\xef\xd7\x95\xe5 726\xaf\xe6\x88" +
	"J\xb9\x91\xb1I%\xce1c\x7fu\x9c\xfb\xfa\xfb\xf0" +
	"\xb7\xff!\xaf\xe3\x95z9\xee\x14\xb9`\x90\x13K\xb9" +
	"\x91y\xb1\x0b2\xcd\xbc\x1e\xd9 \xe1Y\x19A\xcc\xf0" +
	"\xf1\x95\xfe\x10q\xadaN\x8c\xf0bF\x15aK\xe5" +
	"\xc4\x06\x97\xaf<\xf6\x9b\x91\xab\x8c\x01\xaea\xda7\xe4" +
	"\xeez\xfbp\xe4z\x90\x01\xaei4\x19\x99\x9f\x8b\xe4" +
	"G\x06R\xac\x10\x0d\x19\x1ea\xf2\x89\xa4\x93\x8bPh" +
	"\xa0\x10\x8d\x1f\xacO\x9c/\xdb\xbbk\xd6\x98\xe3\x89\x94" +
	"\x88_\xe4\xbd\x92\xbf\x96\xca\xe3\xb1\x97\x0b\x19\xafya" +
	"\\\x18\xf0\xce\x08\x11V\xd6\xfc\xe6p\xc8\xfb\xa3'\xfa" +
	"x\x13\x87\x1b\xc5\xae\xc4/\xc2\xc4*\x94\x14u%n" +
	"\xc2(FF9\xectN\x06)6 \xc2\x96\x00\xe1" +
	"\xae\xe4%\xef\xa5\x0bRz\x82\x02\xd8\x13 <\x8c@" +
	"\xd5:[\xc3\x83\x0a\xe8\x07\x08O!\xd0,\x9d\xad\x99" +
	"\x09\xeacWk\x1a\x0dRr\x9a\x0eRJ\xe0i\x80" +
	"p:\x89\x0e:\xe9\x82\x94\x8et\x05\xcc\xa2\x11\xeeO" +
	"\xa0r]\x90\xe2\xa2E8\x98F\xf8~\x02M\xd2\x05" +
	")\x0f\xd1\xeb\xe1T\x1a\xe1\x15\x04\xda\xa0\x0bR\xd6\xd1" +
	"\x99p\x1d\x8d\xf0^\x02\x1d\xf9\xedZ\xaf\xdfkg\xbf" +
	"\xd7\xce\xfe\x97oG\x10\x9b\x16\xe2/\xd9ng6a" +
	"\xb7\xfd\xa1pT\xca\x88\xc4\xc8X\xc5lg$\xcd\xf6" +
	"\xd6\x1c\xfbV\xe4:\xce\x00\xd7\xafZ\xb3}6\xc7~" +
	"\x16\xe1tb\x1b:\xe9\x8cMG\xd0.\xf6\xe9y\x1f" +
	"\x02\x0d\xd0\x19\x9bb\x90\x0d\x8b\x9b\x0alJ\x9a\x0el" +
	"\x0ab\xe7\xa8\x0d\x04\xda\xa2\x0bl6\x83l\xb8\x19 " +
	"|\x84@g\x80\xd6\xd8\x9c\x0691\x13\xe5 f#" +
	"\x83\xbe\xdcJ\xcam\xdbW}r\xed\xdf\x82?\xfeK" +
	"\xb5\x90\x9cwg\xd4\xdd\xdb\xeb\xba\xb7\x12w5\x8d\xa2" +
	"\xdfL6?n\x05\xe4\xe8\x99\x9eY-\x1e\x9b\x988" +
	"\xb94\xee\x025'\x97\x84\xe3\xfb\xfc\xb5>\xabNW" +
	"{\xcf$\x0d\x88\x14\xbbE\xdd\xfc\xf7\x19q\xb9\xb8Q" +
	"\xeb\xd9{Ez\xf1\x7fu\xfd\xf8_\xff\x9eb\x97\xd5" +
	"\xb9\x08<\xfb\xe6ju\x12\x11>`\xfc\xe9\x18\xe6\x03" +
	"\xf1e\xa3W\xbey\xe3\x88\x03\xd3\xd4I\xa0QM|" +
	",\x95\\\xf3!\xc9O\xa4Z<B\x7f\xfd\xa9\x942" +
	"\xae\xe9\xdb\xaa\x1e^\xbc\"\xf1\xbfrI5\x16\xff\xf7" +
	"Oz\xe6C \x13\x1e\x02\x08[\xc9~s\xe8\x8a\xc4" +
	"v:\x07\xdauW\x81\x12/KOZ\x84\xbdi\x84" +
	"G\x10(\xa0\xbb@\xe4\xa7s\xa0\x9fFx\x12\x81f" +
	"\xe8.\x10M\xa7\x9d\x17\x15\xa4\x13/\xcbJ\xba\x04\xae" +
	"\xd1z\xcb\xe4\xcbr\x88.\x80\x87h\x84\xafb\x18\x80" +
	"\xd3uU\xe2VL\x09l\xcb \xdc\x8b@\xfduU" +
	"\xe2\"&\x13\x161\x08\xfb\x08\x14\xd6\xdd \x0a29" +
	"0\xc8 <\x85@\xb3t7\x88f2\x99\xb1\x8a\xf4" +
	"\xeb\x04Z\xab\xbbA\xb4\x86\xc9\x81k\x18\x84w\x13\xe8" +
	"\xa0\xee\x06\xd1\x01&\x07\x1e`\x106\x99\x18\x80\xd3t" +
	"U\xe2\x96\xa6L\xd8\xd2\x84p\x17\x02\xf5\xd0\xddQ\xed" +
	"nr\xc3\x9e&\x84\x87\x11\xa8\xda\xa4-\x13\xf3\xa6\x0a" +
	"\xe87!<\x85@\xb3L\xda2\xf1LS=\x9cm" +
	"Bx-\x816\x99\xb4e\xe2\x8d\xa6L\xb8\xd1\x84\xf0" +
	"A\x02\x9d2\xd1\x80\xf55\x93\x08(T\xd3\xbal\xe9" +
	"\xb9\xbbK\x82\x9f\xefW\xb7\xb0\x8f\xf7\x16\xd4\x19\x17\xd0" +
	"x\xaf\xd3S\xd7\xa8\xf6\x95\x0ft\x90\xcf_\xdb\xdcx" +
	"\xfc\xb5\x89\xf1duo\xb5}\xee\x8f;\xd6\xfc\xc6\xea" +
	"\x81\xbf\xa9\xc3&\xeb\x0f\x19\xef\x8d\xe2P|o\xb4\xff" +
	"\xeb\xd7\x8f\\\xfd\xe2\xc6\x09\xea\xb3\xf0\x87\x9a\xdb\x1bD" +
	"U}\x16\x17i\xb3\x01>d\xf8\xb7\x03\xf8\xb8kX" +
	"\x9a\xbf\xbbK\xa7\x89]~Q\xff6(\xf8\x9a\xf9\xdb" +
	"R\xc1\x97\xf8\xdb\xa2\xf2\x1f\xc3S\\{\xa6$\xb4\xa3" +
	"\x81\xe6\xb4\xa3\x81\xa4v\xe4E[\xda\xf9\xf3\xf2e'" +
	"\xf1,\xa3\xda/\x9b\x94\xfa\xe0<\xcd\x07\xb4\x97\xf4\x9d" +
	"\x13!\xb8\xf8;\xa7m\x9f\xbe}\xf0}\x9f\xfc\x7f\xec" +
	"L_4\x9a\xf7F%\xfe\x92>wqG\x89_\x8b" +
	"\xf0\xb4\xe8\xe7#\xe4\xf4\x19\x89{\xbf\xf8\x17Ds\x92" +
	"n\xae\xbb)\x07v7!\\Nl\xe3\x08][\x91" +
	"\xe1\xa6vp\xb8\x09\xe1\xfb\x094I\xd7V\xe4!S" +
	"\x0e|Hw3(\xe1\xe6\x96\x9aD\xf8\xaa\x09\xe1m" +
	"\x04\xda\xabk+\xf2\x95\xc9\x0d\xf7\x99\x106\x99\x89;" +
	"\xd0\xb5\x15ii\xae\x81v3\xc2\xb7\x11\xa8\x8f\xae\xad" +
	"Ho\xb3\x07\xe6\x9b\x11\xf6\x11(\xack+\x124O" +
	"\x86Q3\xc2s\x08\xb4H\xd7Vd\xa1\xf9\x09\xb8\xd4" +
	"\x8c\xf06\x02\xed\xd5\xb5\x15\xf9\xca\xfcZ\xacwH\x9a" +
	"\x85\x01\xb8\xbdE\xeb\xe6\xdaZV\xc5\xee\xff\x0c \xd0" +
	"P][\x91\xc1\x96l8\xd8\x82\xb0D\xa0q\xba\xb6" +
	"\"c,%p\xbc\x05\xe1\x05\x04Z\xaek+\xb2\xd4" +
	"\xe2\x89\xdd\xff\xd9F\xa0\xbd\xba\xb6\"_Y&\xc0}" +
	"\x16\x84\xad,\x090X\xad\x9b\xb3\xb39\xd0\xce\"\xdc" +
	"\x95@\xbdX\xad\x9b\xeb\xc9~\x03\x8bX\x84\xc3\x04\xba" +
	"_\xd7V\xa4\x8e\xf5\xc01,\xc2\xf3\x08\xb4D\xd7V" +
	"d1;\x19\xbe\xca\"\xbc\x9d@\xfbumE\xf6\xb1" +
	"%\xf0\x00\x8b\xb0\xd5J\x86a\xd5\xde\x86\xb2['\xc3" +
	"\xb6V\x84\xfb\x10h\x80U{\x1b\xaa\xd8\x9a\x0d\x8b\xad" +
	"\x08W\x13H\xd2\xb5\x15\xb9\xcfz\x0d\xbc\xcf\x8a\xf04" +
	"\x02\xcd\xd1\xb5\x15\x99m\xf5\xc0\xb9V\x84\xd7\x12h\x93" +
	"\xae\xad\xc8F\xab\x1bn\xb6\"|\x9c@\xbf\xea\xda\x8a" +
	"\x9c\xb5\x8a\xf0\xbcU\xdb!$\xd1V\xe4f[=\xec" +
	"fCx(\x81|\xba\xbe\"\x9c\xcd\x03y\x1b\xc2\x93" +
	"\x084C\xd7Wd\xba\xad\x02\xce\xb4!\xbc\x82@\x1b" +
	"t}E\xd6\xd9\x9e\x87\x1bm\x08\x1f'\xd0\xaf\xba\xbe" +
	"\"gm\xeb!HA\xb8K\x0a\x89XR\xb4}E" +
	"\xba\xa7x`\xcf\x14\x84\x87\x11\xa8:E\xdbW\x84O" +
	")\x80|\x0a\xc2\x93\x084C\xd7WdzJ\x05\x9c" +
	"\xa9k\x03\x92\xe8+\xb2.\xc5\x03\xdfOA\xf8 \x81" +
	"N\xe9\xfa\x8a\x9cH\x99\x00O\xa7 \xdc\xbe\x05\x03p" +
	"\xe7\x16\xda\xbe\"Y-\xdc\xf0\xc6\x16\x08\x0f \xd0\xd0" +
	"\x16\xda\xbe\"\x83[\xac\x87\xc3[ <\x89@3\x08" +
	"t\xfd\x0e\xd9\x01\xae'\xc3h\x91\x09\xa7\xb7@x9" +
	"\x81V\xb7 \x07+\xaf\xd4\xcc'\xd3\xf9\xde\xe4\xc7\xbc" +
	"yK>X\xe6\xfd~\x85\x9a\xa3c<\xa2\xe1\x87l" +
	"\x05\xca\xe7o\xd7\xfe\xd4\xfa\xb6'\x7f}\xef]\xd5\x0f" +
	"yD\x9e\x1bi\\\x8e\"\x121\xddG\x8f\xf56O" +
	"\xbf\xa6\xfa\xdc\xbf-\xac\x92}\xc2@A\xaa\xf6\x87(" +
	"Pe\x18\x94\x14&\xe5b<#\xde\x9d\xfd\xe3\xccw" +
	"\xbb\x7f\xda\x80'\xb5jHu\x9d\xe1M\xa7\x04U^" +
	"U\xc6\xa8\xea\xb8\xbf\xbd\x98\x8f\x17\xb9\x08\x9f/\x15Q" +
	"\xac\xaf\x8a7\xcc\xa6\x16\x11I''Q\xa8\xc8\xa7~" +
	"\xee4'g\xcf\x8e7\xbf\xae\xdd\xabc\x8b}V\x94" +
	"\xaf\xc6N\xc6M\xcab\x9c\xca\x87E\x1c\xd1`\xf9x" +
	"\x0c\xb50\xa7\xcf\xf9\x9b\x9e\xe9|T\xcb\xec\x0fU\xe5" +
	"\x03\x89\xfc{~\xa4\xb0\xd1\x1b>\xc9;\xedE\x8a\xbc" +
	"\x13p1\x05'\x87\"\x89&cV\xd7|\xa9\xdb/" +
	"7|\xd0$7\x12\x8a\x8c[\xa0\xedL\xf0\xd3*\x7f" +
	"$\xde\x04M\xed\x82\xd1\xc4\x9f\xf4\x03\xa2\xa0,N\x1e" +
	"?:\xbf\xf1N\x00I\xb7\x9b\xf8\x97X\xf30NY" +
	"S\xf2_\x89fnk\x9e\xfe\xf4\xaeo\xeb\x7f\xde\xfd" +
	"{\xb3\xb5\x7f\xa5\xd9\x1a\x0a\xf0R\x01oh\x98\x06\xf0" +
	"\x92\xd3\x13\xd7^p\xa0\xfe\x87\xc0\xe1\xd1_$nB" +
	"\xf8#\x92\x9b\xf7Ei/_\x1c\x92\x042Frz" +
	"\x19\x1ca\x1b?\x04\xb5\x8fg\x0fh \x0f\x88\xab2" +
	"^>\xc3\x1f\x92\x84\xd8\x88\xc9\x8f\xcehD9\x1e\x91" +
	"?<\x12\xfd\xf9&\x98\xba\xe0\x07\xfd\x1f\xd6\xf2\x14k" +
	"\x9cr\xa9\x89\xf3\xd7\xf2T\xaa\xa8\xce\xbd\xa5\xf8v\xd9" +
	"\x17\xcf\x99\x8fi\xc90/\x15\x03\xb2\xa9\xc8\xd8\x9by" +
	"Y\x07(\xf2N\xe0\x8f\xed\xc2J1\xf1u\xe1\xf7\x83" +
	"\xf8G\x8f\x16\xbe\x92\xb8\x03\x17\x10\xaa\xee\xe2\x02Q\xbe" +
	"\xb9\x93\xd3\x00\xa1\xcaY\xcb\x05\xa2\x89\xd61O\x9f\xe8" +
	"\x11\xed\x1f\xfe\xf0|\xb2L\x17\x8e-*\x88\xadj\xac" +
	"\x07\x83\xe1\x10K\xb9pl!\x81\xba\x92\xacz\xd2\xfc" +
	"\xf3-g\xefz|\xca\xd89\x89\xcc\x19\xdfL\xa1z" +
	" ?Z\xb9\x8a\xf3f\xc7\x15\xedz\xd4nRo\x0b" +
	"\x80\xb0\x81\xda5\xa0L9J\xce\xddqa.\x03\x13" +
	"\xed(\xc2\xd1K\xbd\x9eZ\x16mx=\xf5|\xe7n" +
	"\x17N\x0c\xe88.I\x16{\x1b(`\x9c /\x8b" +
	"\xc6\xcf\xb7\xa9N.~L\xbeg\xc2\xf2\xfc\x8a\xae\xd7" +
	",\xd6\x8c\x8bl\xdc|\x0a\xc5\xac\x98\xe1\xe1\x84\xd0\x91" +
	"\x9d\x0a\x9cq\x93\x17;\x9c|\xf6\xdd\x81\x1b\xce~+" +
	"\xado\xc0\x98\xa7\x18+\xc3k\x9dZ\xca\x98t\xfc$" +
	"\xde\xcb\xd4o\xd6\x97a\xe6\x15\xdd\x17M|\xb9@\xb1" +
	"n>\xd0L\x0b\x18\"\xe9\x94\xa8<\xc1)\xf2\xf1\xcb" +
	"&\xdb\x86\xb5\xban\xee\x8b\x1f,\xfe\xf7\x9c\xef\xc2<" +
	"'\xf9C\xa0*\xdf+\x0a\x91H>\xdb\xb8M\xd7~" +
	"\xcc\xa5h\xd0U\x19\\L%\xee;\x947\xfe\xcb\xaf" +
	"~Y3\xe7\xa7E\xcb.\xe6\xa7U\xfeH\xd3\x160" +
	"y\xcf\xae\xa9\xff\xd0X\xc2\xa6\xfe\x88b\xab\x9a\xe9\xbf" +
	"\xa2\x92S\xa8*\xe1JBU\xb5\xdf\x9d\xf9\x9f\xd6o" +
	"$\x9a\xcbpu\xcd\xb4\xeb)\x91\xb1\"\x13\xcf\x0a_" +
	"\xfd\xee\xa7\xc3\xb2\xe7<\xbd\xe8\xdfqQU\x8e\x08\xa2" +
	"TP7H\xa4X_\xa3\x17\xe9\x93\x1b\x08\x0b\xa2\x14" +
	"KN\xe4\x09\xa2O\xede\xb2\xaa\xf6\xc5\xeb\x9e{k" +
	"\xfe\xd2\x8b\xe9\x80\x8f\x17\xfbr\xc6\xee\xe8\xf9\x04%P" +
	"\x18\xbd\\\xc2mv_~0\xb8\xe7\x8b\xf4\x0bZ^" +
	"b\xe6\x8c\x83D\x8f\xc2\x18\x8d\xf8\xa9\x84y\xbb=g" +
	"\x92\xbb]}\xf6\xb4\xff\xed:\xd5(\xc3\xd8<\x93\x1d" +
	"\xe2Q\x82\xf3gV\xbf\xff\xf7C-\x92ag#\xfd" +
	"L\x94\xa6.\xff\xa1\xfdL\x1e^\xbf\xfe/o\xf4\x9a" +
	"\xf6\xee\xe5\xf73\xf9q\xfb\xb3\xfb\xf6\xdc{\xf3\xfe\xcb" +
	"\xbf\x08\x95Uy\xcb?\xcf\x0e\xba~\xaa\xc1\x9a\x16K" +
	"\xbc\xc8Iy\x82x\xa5W5\xb3\xf1U\xcdl|U" +
	"35\xabz\xe9\x19\xbeC{\xde\x9a| \xbav\xf1" +
	"e\xdf\x9c.2\xbft\xe3\xd6?|\xbb\xfe\xb2{'" +
	"e\xf5-\xf8z\xc2s\xfb\xfe\x12W\xfc\x7f\x01\x00\x00" +
	"\xff\xff\xac\x9ek\x06"

func init() {
	schemas.Register(schema_838375eaedd19910,
		0x805187bca398c14a,
		0x8795012f7ae80514,
		0x8ce88691d4f85976,
		0x9d013df2e25b0523,
		0x9f7d8c878e1b63cf,
		0xa20bd14fac188777,
		0xa3264fdbc475990d,
		0xa473fbecd00e31b2,
		0xa8c4bc295da91dba,
		0xa9233d61b2dac238,
		0xbe1b1b92f4198c40,
		0xc19058b353c75763,
		0xcef0b445a44bf3c9,
		0xd196ce6d3039f074,
		0xe1637c70bbf5c834,
		0xe3dbbb161150c44e,
		0xed3ddbe86f107753,
		0xedeec74f770bd677,
		0xf451095bdcd8860d)
}
