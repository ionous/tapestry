package encode

import (
	"strings"
	"unicode"
)

// SigBuilder helps build the "lede" used the compact format
// ex. "Else if:from:and:do:else:"
type SigBuilder struct {
	out    strings.Builder
	labels int
}

func (b *SigBuilder) String() string {
	return b.out.String()
}

// lede is in break_case
func (b *SigBuilder) WriteLede(s string) {
	// changes the autogenerated break_case into PascalCase
	writeBreak(&b.out, s, true)
}

// label is in break_case
func (b *SigBuilder) WriteLabel(s string) {
	b.WriteLabelPair(s, "")
}

// x is a swap's choice
func (b *SigBuilder) WriteLabelPair(s, x string) {
	// write non-anonymous labels
	if len(s) > 0 {
		// add space between the lede and the first non-anonymous label
		if b.labels == 0 {
			b.out.WriteRune(' ')
		}
		// change autogenerated break_case into camelCase
		writeBreak(&b.out, s, false)
	}
	// write choices
	if len(x) > 0 {
		if len(s) > 0 || b.labels == 0 {
			b.out.WriteRune(' ')
		}
		writeBreak(&b.out, x, false)
	}
	// all labels ( even anonymous ones ) are terminated by colons
	b.out.WriteRune(':')
	b.labels++
}

func writeBreak(out *strings.Builder, s string, cap bool) {
	var lower bool
	for i, r := range s {
		// hrm... to reduce choices
		if i == 0 && r == '$' {
			lower = true
			continue
		}
		if r == '_' || r == ' ' {
			cap = true
		} else {
			if cap {
				r = unicode.ToUpper(r)
				cap = false
			} else if lower {
				r = unicode.ToLower(r)
			}
			out.WriteRune(r)
		}
	}
}
