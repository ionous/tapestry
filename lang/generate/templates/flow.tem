{{- range .Comments }}
// {{.}}
{{- end }}
type {{Pascal .Name}} struct {
{{- range $i, $t := .Terms }}
	{{Pascal $t.Name}} {{TermType $t}}
{{- end }}
	Markup map[string]any
}

// {{.Name}}, a type of flow.
var Zt_{{Pascal .Name}} typeinfo.Flow

// Implements [typeinfo.Instance]
func (*{{Pascal .Name}}) TypeInfo() typeinfo.T {
	return &Zt_{{Pascal .Name}}
}

// Implements [typeinfo.Markup]
func (op *{{Pascal .Name}}) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

{{ if .Slots }}
// Ensures the command implements its specified slots.
{{- range $i, $s := .Slots }}
var _ {{ScopedType $s}} = (*{{Pascal $.Name}})(nil)
{{- end }}
{{- end}}

// Holds a slice of type {{Pascal .Name}}.
type {{Pascal .Name}}_Slice []{{Pascal .Name}}

// Implements [typeinfo.Instance] for a slice of {{Pascal .Name}}.
func (*{{Pascal .Name}}_Slice) TypeInfo() typeinfo.T {
	return &Zt_{{Pascal .Name}}
}

// Implements [typeinfo.Repeats] for a slice of {{Pascal .Name}}.
func (op* {{Pascal .Name}}_Slice) Repeats() bool {
	return len(*op) > 0 
}
