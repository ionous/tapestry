
// FIX: for now we are generating side by side with the old definitions
// also should have user comment here 
type FIX_{{Pascal .Name}} struct {
{{- range $i, $t := .Terms }}
	{{Pascal $t.Name}} {{TermType $t}}
{{- end }}
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*{{Pascal .Name}}) Inspect() (typeinfo.T, bool) {
	return &Zt_{{Pascal .Name}}, false
}

// return a valid markup map, creating it if necessary.
func (op *{{Pascal .Name}}) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

{{if .Slots }}
// ensure the command implements its specified slots:
{{- range $i, $s := .Slots }}
var _ {{ScopedType $s}} = (*{{Pascal $.Name}})(nil)
{{- end }}
{{- end}}

// {{.Name}}, a type of flow.
var Zt_{{Pascal .Name}} = typeinfo.Flow{
	Name: "{{.Name}}",
	Lede: "{{.Lede}}",
	Terms: []typeinfo.Term{
{{- range $i, $t := .Terms -}}{{if $i}},{{end}}{
		Name: "{{$t.Name}}",
		Label: "{{$t.Label}}", {{if $t.Private}}
		Private: true,{{end}}{{if $t.Optional}}
		Optional: true,{{end}}{{if $t.Repeats}}
		Repeats: true,{{end}}{{if not $t.Private}}
		Type: &{{PackageDot $t.Type}}Zt_{{Pascal $t.Type}},{{end}}
	}
{{- end -}}
{{/**/}}		},
	{{- if .Slots }} 
	Slots: []*typeinfo.Slot{ 
	{{- range $i, $s := .Slots }}
		&{{PackageDot $s}}Zt_{{Pascal $s}},
	{{- end }}
	},
	{{- end }}
	{{- template "markup.tmpl" .}}
}

// holds a slice of type {{.Name}}
// FIX: duplicates the spec decl.
type FIX_{{Pascal .Name}}_Slice []{{Pascal .Name}}

// implements typeinfo.Inspector
func (*{{Pascal .Name}}_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_{{Pascal .Name}}, true
}
