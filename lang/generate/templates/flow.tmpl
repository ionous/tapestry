{{- range .Comment }}
// .
{{- end }}
type {{Pascal .Name}} struct {
{{- range $i, $t := .Terms }}
	{{Pascal $t.Name}} {{TermType $t}}
{{- end }}
	Markup map[string]any
}

// implements typeinfo.Instance
func (*{{Pascal .Name}}) TypeInfo() typeinfo.T {
	return &Zt_{{Pascal .Name}}
}

// implements typeinfo.Markup
func (op *{{Pascal .Name}}) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

{{if .Slots }}
// ensure the command implements its specified slots:
{{- range $i, $s := .Slots }}
var _ {{ScopedType $s}} = (*{{Pascal $.Name}})(nil)
{{- end }}
{{- end}}

// {{.Name}}, a type of flow.
var Zt_{{Pascal .Name}} = typeinfo.Flow{
	Name: "{{.Name}}",
	Lede: "{{.Lede}}",
	Terms: []typeinfo.Term{
{{- range $i, $t := .Terms -}}{{if $i}},{{end}}{
		Name: "{{$t.Name}}",{{if $t.SimpleLabel}}
		Label: "{{$t.SimpleLabel}}",{{end}}{{if $t.Private}}
		Private: true,{{end}}{{if $t.Optional}}
		Optional: true,{{end}}{{if $t.Repeats}}
		Repeats: true,{{end}}{{if not $t.Private}}
		Type: &{{PackageDot $t.Type}}Zt_{{Pascal $t.Type}},{{end}}
	}
{{- end -}}
{{/**/}}		},
	{{- if .Slots }} 
	Slots: []*typeinfo.Slot{ 
	{{- range $i, $s := .Slots }}
		&{{PackageDot $s}}Zt_{{Pascal $s}},
	{{- end }}
	},
	{{- end }}
	{{- template "markup.tmpl" .}}
}

// holds a slice of type {{.Name}}
type {{Pascal .Name}}_Slice []{{Pascal .Name}}

// implements typeinfo.Instance
func (*{{Pascal .Name}}_Slice) TypeInfo() typeinfo.T {
	return &Zt_{{Pascal .Name}}
}

// implements typeinfo.Repeats
func (op* {{Pascal .Name}}_Slice) Repeats() bool {
	return len(*op) > 0 
}
