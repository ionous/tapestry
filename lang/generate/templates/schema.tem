{{/* ------------------------------------------ */}}
{{/* helper templates                           */}}
{{/* ------------------------------------------ */}}

{{/* ------------------------------------------ 
  ref: expects text.
  names are prefixed with tilde so that they don't match in autocomplete.
   ------------------------------------------ */}}
{{ define "ref" }}
	"$ref": "#/$defs/~{{ . }}"
{{ end }}


{{/* ------------------------------------------ 
  titledesc: expects sigTerm,
  sublime and vscode hovers look better without title.
  we already know what we're hovering.
  golsp seems not to use the title either.
   ------------------------------------------ */}}
{{ define "titledesc" -}}
  "description": "{{ .SchemaComment }}",
  "markdownDescription": "{{ .SchemaComment }}"
{{ end }}


{{/* ------------------------------------------ 
  xxxDesc: 
  bug? giving a primitive value a description 
  overrides the description of the property when used in a map.
   ------------------------------------------ */}}
{{ define "xxxDesc" -}}
 "$comment": "{{.}}"
{{/*
  "description": "{{ . }}",
  "markdownDescription": "{{ . }}"
 */}}
{{ end }}


{{/* ------------------------------------------ 
  titledesc: expects sigTerm
   ------------------------------------------ */}}
{{ define "sigDesc" -}}
"description": "{{ .Flow.SchemaComment }}",
"markdownDescription": 
"{{ .Flow.SchemaComment }}{{ 
  template "typedesc" . }}{{
  template "typelinks" .TypeLinks }}"
{{ end }}

{{/* ------------------------------------------ 
  typedesc: expects sigTerm
   ------------------------------------------ */}}
{{ define "typedesc" -}}
 	{{- with $sigTerm := . -}}
	\n\n---\n[{{ 
	  .Signature }}]({{ .Flow.Link }})\n{{/* */ -}}
	```yaml\n{{
	  range .Terms 
	  }}- {{ if .SimpleLabel }}{{ 
	      .SimpleLabel }}{{ else 
	  }}{{ $sigTerm.Lede }}{{ end
	  }}: {{ Pascal .Type }}{{ 
	    if .Repeats 
	  }}...{{ end }}{{ 
	  	.LineComment
	  }}\n{{ 
	end -}}
	```\n{{/* */ -}}
	{{- end -}}
{{ end -}}

{{/* ------------------------------------------ 
  typelinks: expects slice of TypeLink
   ------------------------------------------ */}}
{{ define "typelinks" -}}
Types: {{ range $idx, $t := . -}}
{{- if $idx }}, {{ end -}}
[{{ Pascal .Type }}]({{ .Link }})
{{- end -}}
{{ end -}}

{{/* ------------------------------------------ 
  slotDesc
   ------------------------------------------ */}}
{{ define "slotDesc" -}}
 	"description": "{{ .SchemaComment }}",
 	"markdownDescription": "{{ 
 		.SchemaComment 
  }}\n\nType: [{{ Pascal .Type }}]({{ .Link }})"
{{ end }}

{{/* ------------------------------------------ */}}
{{/* the schema                                 */}}
{{/* ------------------------------------------ */}}
{
  {{/* redhat yaml-language-server and vscode idxelf use draft 7 */}}
  "$schema": "https://json-schema.org/draft-07/schema",
  "$id": "{{ .SchemaId }}",
  {{ template "titledesc" . }}, 
  {{- /* the top level is an array of story statements*/}}
  "oneOf": [{
  		{{ template "ref" "story.story_statement" }}
  	},{
  	"type": "array",
  	"items": {
		    {{ template "ref" "story.story_statement" }}
		  }
  	}],
   "$defs": {
   	{{/* ------------------------------------------ 
      slots.
     ------------------------------------------  */}}
    {{ range $op := .Slot }} {{/* a map containing slotCommand(s) */}}      
    "~{{ .Idl }}.{{ .Name }}": {
        {{ template "titledesc" . }},
        "anyOf": [ {{/* 
          oneOf ensures only one schema matches; anyOf that there is simply one match.
        	oneOf is overkill here -- since there are many objects types it would have to check all of them.
        	anyOf is fine.
         	*/}}
          {{/* 
          		eval shortcuts
          */}}
          {{ if ( Contains .Name "bool_eval" "number_eval" "text_eval"
            "num_list_eval" "text_list_eval" "record_eval" "record_list_eval"
            "address" ) }}
          {{/* variables ( start with @ ) */}}
          {
          	"type": "string",
          	"pattern": "^@"
          	{{/* 
          		xxxDesc
            "description": "A {{ if .ChopEval 
            	}}{{ Title .ChopEval }} {{end -}} variable.",
            "markdownDescription": "A {{ if .ChopEval 
            	}}[{{ Title .ChopEval }}]({{ .Link }}) {{end -}} variable."
            	*/}}
          },
          {{/* object field ( start with # and contain a dot ) */}}
          {
          	"type": "string",
          	"pattern": "^#\\w+\\."
          		{{/*
          			xxxDesc
            "description": "An object {{ if .ChopEval 
            	}}{{ Title .ChopEval }} {{end -}} field.",
            "markdownDescription": "An object {{ if .ChopEval 
            	}}[{{ Title .ChopEval }}]({{ .Link }}) {{end -}} field."
            	*/}}
          },
          {{ end }}
          {{/* 
          		handle literals
          */}}
          {{ if eq .Name "bool_eval" }}
	          {
	            "type": "boolean",
	            {{ template "xxxDesc" "The specified true/false value." }}
	          },
	          {
	          	{{- /* an object name without a dot */}}
	            "type": "string",
	          	"pattern": "^#[^\\.]+$", 
	            {{ template "xxxDesc" "True if the object exists." }}
	          },
          {{ else if eq .Name "number_eval" }}
	          {
	            "type": "number",
	           {{ template "xxxDesc" "The specified number." }}
	          },
          {{ else if eq .Name "text_eval" }}
	          {
	            "type": "string",
	            {{ template "xxxDesc" "The specified text." }}
	          },
	          {
	          	{{- /* an object name without a dot */}}
	            "type": "string",
	            "pattern": "^#[^\\.]+$",
	            {{ template "xxxDesc" "The object's full name." }}
	          },
          {{ else if eq .Name "num_list_eval" }}
	          {
	            "type": "array",
	            "items": { "type": "number", "description": "The specified number." },
	            "description": "A list of numbers."
	          },
	          {{ else if eq .Name "text_list_eval" }}
	          {
	            "type": "array",
	            "items": { "type": "string", "description": "The specified text." },
	            "description": "A list of text."
	          },
          {{ end }}
          {{/* 
          		all of the commands used by this slot
          */}}
          {{- range $idx, $t := .Types -}}
            {{- if $idx }},{{ end }}
            { {{ template "ref" .TypeScope -}} }
          {{ end }}
          {{/* 
          	user pattern calls ( start with # and contain a dot ) 
          */}}
          {{ if ( Contains .Name "bool_eval" "number_eval" "text_eval"
            "num_list_eval" "text_list_eval" "record_eval" "record_list_eval"
            "execute" ) }}
          ,{
	      		"type": "object",
	      		"patternProperties": {
					    "^[A-Z]": { 
					    	{{/* 
					    		allows a single assignment or multiple.
					    	*/}}	
				    		"anyOf": [{
									"description": "Unknown command. Possibly a user pattern.",
									"$ref": "#/$defs/~rtti.assignment"
								},{ 
									{{/* or multiple */}}
									"type": "array",
				    			"description": "Unknown command. Possibly a user pattern.",
									"items": { 
										"$ref": "#/$defs/~rtti.assignment" 
									}
								}]
					    }
				 		}
      		}
          {{ end }}
        ]
      },
    {{- end }}{{/* slot */}}
    {{/* ------------------------------------------ 
      strings and enums
     ------------------------------------------  */}}
    {{ range  .Str }}
    "~{{ .Idl }}.{{ .Name }}": {
      {{ template "titledesc" . }},
      {{ if eq .Name "bool" }}
	   	 	 {{/* tell shortcuts this and never expects the literal true/false strings */}}
	   	 	"type": "boolean"
        {{ else if eq .Name "lines"}}
        "type": ["string", "array"],
        "items": { 
        	"type": "string", 
          "description": "One or more lines of text."
        }
        {{ else }}
        	"type": "string"
	        {{- if .Options }},
		        "enum": [
		        {{- range $idx, $opt := .Options -}}
		          {{- if $idx }},{{ end }} "{{ . }}"
		        {{- end }} ]
		        {{ end }}
		        {{- if .OptionComments }},
		        "enumDescriptions": [
		        {{- range $idx, $opt := .OptionComments -}}
		          {{- if $idx }},{{ end }} "{{ . }}"
		        {{- end }} ]
	        {{ end }}{{/* options */}}
        {{ end }}{{/* lines */}}
      },
    {{ end }}{{/* str */}}
    {{/* ------------------------------------------ 
      numbers
     ------------------------------------------  */}}
    {{ range .Num }}
    "~{{ .Idl }}.{{ .Name }}":{
        {{ template "titledesc" . }},
        "type": "number"
      },
    {{ end }}{{/* num */}}
   {{/* ------------------------------------------ 
      individual commands
     ------------------------------------------  */}}
    {{ range $op := .Flow }}
    "~{{ .Idl }}.{{ .Name }}": {
        "type": "object",
        {{/*
	        for every signature in the flow provide a schema containing that signature.
	        for each signature, list the terms required for that signature.

					ideally, we'd be able to list the comment at the object level
					but the hover is on the property name ( the "My:Function:Name" )
					so it needs to be listed there for the lsp server to see it.
					only, it can't be there... for reasons. ( xxxDesc )
        */}}
        "anyOf": [
        {{- range $idx, $sigTerm := .Signatures -}}
          {{- if $idx }},{{ end }}
          {
            "required": [
              "{{ .TrimmedSignature }}"
            ],
            "properties": {
              "{{ .TrimmedSignature }}": {
              
              {{/* no terms */}}
              {{- if not .Terms }}
                 "type": "null",
                 {{ template "sigDesc" . }}

              {{/* one term */}}
              {{- else if (eq 1 (len .Terms)) }}
             	 	{{ with index .Terms 0 -}}
              		{{ template "ref" (print $op.Idl "." $op.Name "." .Name) }}
              	{{ end }}  
              {{/* multiple terms */}}
              {{ else }}
								"type": "array",
								"items": [
								{{- range $it, $term:= .Terms -}}
								  {{- if $it }},{{ end }}
								  { {{ template "ref" (print $op.Idl "." $op.Name "." .Name) }} }
								{{ end }}
								],
								"additionalItems": false,
								{{ template "sigDesc" $sigTerm }}
              {{- end }}{{/* if not/len terms */}}
              } {{/* signature */}}
            }{{/* properties */}}
          }
        {{ end }}{{/* range Signatures */}}
        ]
      },
      {{/*  ------------------------------------------ 
         terms ( per command )
        ------------------------------------------  */}}
      {{- range .Terms -}}
      {{ if not .Private }}
      "~{{ $op.Idl }}.{{ $op.Name }}.{{ .Name }}":
        {
        	{{- if not .Repeats }}
        		{{ template "ref" .TypeScope }}
        	{{ else }}
        	"oneOf": [{
        		{{/* also allow a single object */}}
        		{{ template "ref" .TypeScope }}
        	},{
        		"type": "array",
        		{{- /* the docs are confusing, but: in draft 7
         	   the value of "items" indicates the array type.
         	   a json object means repeating items;
         	   a json array, a tuple. */}}
        		"items": { 	{{ template "ref" .TypeScope }} },
        		{{ template "slotDesc" . }}
        	}]
      		{{- end }}{{/* if  repeats */}}
        },
      {{ end }}
      {{ end }}{{/* range terms */}}
    {{ end }}{{/* flow */}}
    "$comment": "this eats any trailing commas. chomp. chomp."
  }{{/* defs */}}
}
