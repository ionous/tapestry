// Package typeinfo describes tapestry autogenerated structures.
// It follows closely from tapestry typespecs:
// The typespecs describes the user specification ( in .ifspec, or .tells files )
// while the typeinfo describes the golang structures derived from those specs.
// unless otherwise specified, names are in "lower_case" format.
package typeinfo

// provides access to typeinfo for auto-generated commands
type Instance interface {
	// returns the typeinfo for the instance
	TypeInfo() T
}

// a marker interface implemented by slices of commands
type Repeats interface {
	// slices can return false if their list is empty.
	Repeats() bool
}

// implemented by instances with author specified markup data
// ( currently, that's only flows )
type Markup interface {
	GetMarkup(ensure bool) map[string]any
}

// package listing of type data
type TypeSet struct {
	Name       string
	Slot       []*Slot
	Flow       []*Flow
	Str        []*Str
	Num        []*Num
	Signatures map[uint64]Instance
}

// implemented by each kind of typeinfo
// ( see: Flow, Slot, Str, and Num. )
type T interface {
	// globally unique name for the type.
	TypeName() string
	// returns markup data specified in the .tell spec
	// ( for instance: comments, blockly presentation information, etc. )
	TypeMarkup() map[string]any
}

// tbd: add groups to flow? ( and other types; maybe then a wrapped spec struct for Name, Groups, and Markup )
type Flow struct {
	Name   string         // unique name for this type
	Lede   string         // the compact format leading text
	Slots  []*Slot        // interfaces that a command implements
	Terms  []Term         // terms of the command
	Markup map[string]any // metadata shared by all instances of this type
}

func (t *Flow) TypeName() string {
	return t.Name
}

func (t *Flow) TypeMarkup() map[string]any {
	return t.Markup
}

func (t *Flow) TermIndex(name string) (ret int) {
	ret = -1 // provisionally not found
	for i, n := range t.Terms {
		if name == n.Name {
			ret = i
			break
		}
	}
	return
}

// a member of a Flow.
type Term struct {
	Name     string         // go lang name; unique within its flow.
	Label    string         // the compact format signature
	Private  bool           // a member that only exists in memory; never serialized
	Optional bool           // true when the term can be omitted for instances of the flow.
	Repeats  bool           // true when the term can have multiple values ( all of the same type )
	Markup   map[string]any // per-term markup
	Type     T              // a pointer to Flow, Slot, Str, or Num; or, nil if private
}

// anonymous terms have empty labels.
// for instance, in some example command: { Say: "hello" }
// there is no label after the word say and before the first colon
// so that first term is considered anonymous.
func (t Term) IsAnonymous() bool {
	return len(t.Label) == 0
}

type Slot struct {
	Name   string         // unique name for this type
	Markup map[string]any // metadata shared by all instances of this type
}

func (t *Slot) TypeName() string {
	return t.Name
}

func (t *Slot) TypeMarkup() map[string]any {
	return t.Markup
}

type Str struct {
	Name    string         // unique name for this type
	Options []string       // for enumerations; for plain strings, this is nil.
	Markup  map[string]any // metadata shared by all instances of this type
}

func (t *Str) TypeName() string {
	return t.Name
}

func (t *Str) TypeMarkup() map[string]any {
	return t.Markup
}

func (t *Str) FindOption(str string) (ret int) {
	ret = -1 // provisionally
	for i, opt := range t.Options {
		if opt == str {
			ret = i
			break
		}
	}
	return
}

type Num struct {
	Name   string         // unique name for this type
	Markup map[string]any // metadata shared by all instances of this type
}

func (t *Num) TypeName() string {
	return t.Name
}

func (t *Num) TypeMarkup() map[string]any {
	return t.Markup
}
