package inspect

import (
	"log"
	r "reflect"

	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// Provides iteration of tapestry commands.
// The returned It starts pointing to the passed container,
// calling Next advances to each element of the container in turn.
// Containers can be a single command, a slot for a command, or slices of commands or slots;
// other values have undefined results and may panic.
func Walk(i typeinfo.Instance) It {
	v := r.ValueOf(i).Elem() // the value under the interface
	t := i.TypeInfo()
	if _, ok := t.(*typeinfo.Slot); ok {
		if _, ok := i.(typeinfo.Repeats); !ok {
			v = v.Field(0) // the Instance for a single slot is a struct
		}
	}
	return It{curr: v, currType: t}
}

// If a command, a slot for a command, and slices of commands or slots,
// can all be thought of as containers of values,
// where values are primitive values or other containers,
// then It provides a depth first traversal of those values.
// In this context, a slice of primitives values is handled treated as a single value.
type It struct {
	curr r.Value
	// track the type manually because slice and slot members dont have typeinf
	currType typeinfo.T
	index    int // *next* index in a slice, or field in a struct
}

// advance the focus within the current collection.
func (w *It) Next() (okay bool) {
	if cnt := w.Len(); w.index < cnt {
		w.index++
		okay = true
	}
	return
}

// returns a new walker for the currently focused element;
// panics if the focused element isn't a valid container.
func (w *It) Walk() (ret It) {
	if at := w.index - 1; at < 0 {
		log.Printf("container of %s %T hasn't advanced", w.curr.Type(), w.currType)
		panic("invalid index")
	} else if v, t := w.getFocus(); !v.IsValid() {
		log.Printf("container of %s %T invalid at %d", w.curr.Type(), w.currType, w.index)
		panic("can't walk an invalid value")
	} else {
		ret = It{curr: v, currType: t}
	}
	return
}

// the autogenerated description of the currently focused element.
func (w *It) TypeInfo() typeinfo.T {
	_, t := w.getFocus()
	return t
}

// metadata for the currently focused element.
// only valid flow; returns nil otherwise
func (w *It) Markup(ensure bool) (ret map[string]any) {
	v, _ := w.getFocus() // ugly.
	if m, ok := v.Addr().Interface().(typeinfo.Markup); ok {
		ret = m.GetMarkup(ensure)
	}
	return
}

// only valid for the members of a flow; panics otherwise
func (w *It) Term() (ret typeinfo.Term) {
	if p, ok := w.currType.(*typeinfo.Flow); !ok || w.index == 0 {
		log.Printf("container of %T at index: %d", w.currType, w.index)
		panic("terms only make sense for structs")
	} else {
		ret = p.Terms[w.index-1]
	}
	return
}

// returns whether the focused value is at its default value.
// falls back to the container itself if Next() has yet to be called.
func (w *It) IsZero() (okay bool) {
	v, _ := w.getFocus()
	return v.IsZero()
}

// fix: backwards compatibility. what are the use cases
// and what should be brought in here?
func (w *It) RawValue() r.Value {
	v, _ := w.getFocus()
	return v
}

// returns the value of the current focus as it would appear in file.
// enums use lower_case strings, while bool uses true/false.
// falls back to the container itself if Next() has yet to be called.
func (w *It) CompactValue() (ret any) {
	v, t := w.getFocus()
	if _, ok := t.(*typeinfo.Str); ok && v.Kind() == r.Int {
		ret = destring(v)
	} else {
		ret = v.Interface()
	}
	return
}

// read the target of a slot
func (w *It) GetSlot(ptr any) (okay bool) {
	if !w.curr.IsNil() {
		okay = setValue(r.ValueOf(ptr).Elem(), w.curr.Elem())
	}
	return
}

// write a value into the target of a slot.
func (w *It) SetSlot(val typeinfo.Instance) (okay bool) {
	if val == nil {
		w.curr.SetZero()
	} else {
		okay = setValue(w.curr, r.ValueOf(val))
	}
	return
}

// fix? feels like this should match the way Get works.
// write a value into the target of an iterator.
// returns false if the value is incompatible
// ( uses go rules of conversion when needed to complete the assignment )
func (w *It) SetValue(val any) (okay bool) {
	if out, val := w.RawValue(), r.ValueOf(val); out.Kind() == val.Kind() {
		out.Set(val)
		okay = true
	} else if t := out.Type(); val.CanConvert(t) {
		out.Set(val.Convert(t))
	}
	return
}

func setValue(out r.Value, from r.Value) (okay bool) {
	if from.CanConvert(out.Type()) {
		out.Set(from.Convert(out.Type()))
		okay = true
	}
	return
}

// tbd: merge with typeinfo similar to inspect?
func (w *It) Repeating() bool {
	return w.curr.Kind() == r.Slice
}

// change the size of the container
func (w *It) Resize(cnt int) {
	if !w.Repeating() {
		log.Panicf("can't resize a %s(%s)", w.curr.Kind(), w.curr.Type())
	}
	w.curr.Grow(cnt)
	w.curr.SetLen(cnt)
}

// Returns the number of repeated elements in the current container;
// doesn't change over the course of iteration.
// Filled slots have one element; empty slots zero elements.
func (w *It) Len() (ret int) {
	switch k := w.curr.Kind(); k {
	default:
		log.Panicf("can't measure the length of type %s", k)
	case r.Slice:
		ret = w.curr.Len()
	case r.Struct:
		p := w.currType.(*typeinfo.Flow)
		ret = len(p.Terms)
	case r.Interface, r.Pointer:
		if !w.curr.IsNil() {
			ret = 1
		}
	}
	return
}

func (w *It) getFocus() (rv r.Value, rt typeinfo.T) {
	if at := w.index - 1; at < 0 {
		rv, rt = w.curr, w.currType
	} else {
		switch k := w.curr.Kind(); k {
		case r.Slice:
			rv, rt = w.curr.Index(at), w.currType
		case r.Struct:
			p := w.currType.(*typeinfo.Flow)
			rv, rt = w.curr.Field(at), p.Terms[at].Type
		case r.Interface:
			// slots are filled with flows
			// the first Elem() gets the pointer, the second the struct.
			ptr := w.curr.Elem()
			inspect := ptr.Interface().(typeinfo.Instance)
			rv = ptr.Elem()
			rt = inspect.TypeInfo()
		}
	}
	return
}
