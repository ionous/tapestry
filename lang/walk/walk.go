package walk

import (
	"log"
	r "reflect"

	"git.sr.ht/~ionous/tapestry/support/tag"
)

// provides depth first iteration a tapestry commands.
// should either be passed a single autogenerated command, a slice of them, or a slot for them.
// ( wants the concrete value, not a pointer to one )
// other values have undefined results and may panic.
func MakeWalker(root r.Value) Walker {
	return Walker{curr: root}
}

// If a command, a slot for a command, and slices of commands or slots,
// can all be thought of as containers of values,
// and values might be native primitive values or other containers,
// then Walker provides a depth first traversal of those values.
//
// To indicate the start of a container, returns the container itself;
// returns an invalid (terminal) value to indicate the end of a container;
// otherwise returns a native value.
// In this context, a slice of primitives values is handled as a single value.
type Walker struct {
	/// the current container, and the current position within that container
	// focus becomes invalid at the end of a struct or slice ( to indicate that end )
	curr, focus r.Value
	index       int // *next* index in a slice, or field in a struct
}

func (w *Walker) Len() (ret int) {
	if !w.focus.IsValid() {
		panic("can't measure the length of members of a container")
	} else {
		switch w.curr.Kind() {
		default:
			panic("can't measure the length of simple values")
		case r.Interface:
			if !w.curr.IsNil() {
				ret = 1
			}
		case r.Struct:
			ret = w.curr.NumField()

		case r.Slice:
			if sliceType(w.curr.Type().Elem()) == Value {
				panic("can't measure the length simple array")
			} else {
				ret = w.curr.Len()
			}
		}
	}
	return
}

// note: a slice is a type that repeats.
func (w *Walker) Type() (ret Type) {
	switch curr := w.curr; curr.Kind() {
	case r.Interface:
		ret = Slot

	case r.Struct:
		if w.focus.Kind() == r.Invalid {
			ret = structType(curr.Type())
		} else {
			ret = fieldType(w.focus.Type())
		}

	case r.Slice:
		ret = sliceType(curr.Type().Elem())
	}
	return
}

// only valid for the members of a flow; panics otherwise
func (w *Walker) Field() Field {
	if k := w.curr.Kind(); k != r.Struct || w.index == 0 {
		panic("fields only make sense for structs")
	}
	containerType := w.curr.Type()
	field := containerType.Field(w.index - 1)
	tag := tag.ReadTag(field.Tag)
	return Field{field.Type, tag}
}

//
func (w *Walker) Value() (ret r.Value) {
	if !w.focus.IsValid() {
		ret = w.curr
	} else {
		switch w.Type() {
		case Str, Num:
			ret = w.focus.Field(0)
		default:
			ret = w.focus
		}
	}
	return
}

// returns a new walker; descending into the passed element
// panics when trying to enter invalid types...
// returns false if its a valid type, but a nil value.
func (w *Walker) Descend() (ret Walker, okay bool) {
	v := w.focus
	switch w.focus.Kind() {
	default:
		panic("can't descend into the simple values")
	case r.Invalid:
		panic("can't descend into the container; only members of the container")

	case r.Interface:
		if !v.IsNil() {
			// unpack the interface, and then: we always fill the interfaces with pointers
			ret = Walker{curr: v, focus: v.Elem().Elem()}
			okay = true
		}
	case r.Struct:
		if v.NumField() != 0 { // empty structs arent really a thing.
			ret = Walker{curr: v, focus: v.Field(0)}
			okay = true
		}
	case r.Slice:
		if sliceType(v.Type().Elem()) == Value {
			panic("can't descend into simple array")
		} else {
			if v.Len() != 0 {
				ret = Walker{curr: v, focus: v.Index(0)}
				okay = true
			}
		}
	}
	return
}

// prepare access to a (new) value
func (w *Walker) Next() (okay bool) {
	switch curr := w.curr; curr.Kind() {
	case r.Interface:
		okay = false

	case r.Slice:
		// to be here, we must be unpacking a slice of slots or flow
		// we would have already returned value *as* the slice
		okay = w.step(curr.Len, curr.Index)

	case r.Struct:
		// embedded flow
		// zero index, the state before the first call to Next(), indicates the flow itself
		// on first Next() we want to return the zeroth field; so "index" is used directly as the index.
		okay = w.step(curr.NumField, curr.Field)

	default:
		// ex. Array, Uintptr, Complex64, Complex128, Chan, Func,
		// Map, Pointer, UnsafePointer, Invalid
		log.Printf("unexpected %s(%s) in generated types", curr.Kind(), curr.Type())
		panic("unexpected generated type")
	}
	return
}

// step to, or into, the passed value.
func (w *Walker) step(cnt func() int, get func(int) r.Value) (okay bool) {
	if at, num := w.index, cnt(); at < num {
		nextField := get(at)
		w.focus, w.index = nextField, at+1
		okay = true
	}
	return
}
