package jsnutil

import (
	"strconv"
	"strings"

	"git.sr.ht/~ionous/iffy/jsn"
	"git.sr.ht/~ionous/iffy/jsn/chart"
)

type VisitStart interface {
	BlockStart(jsn.FlowBlock, Context) error
}
type VisitEnd interface {
	BlockEnd(jsn.FlowBlock, Context) error
}

type Context struct {
	Data interface{}
	Path string
}

// Visit - Look at every node (autogenerated block flow structure) in the passed marshalee tree.
// call its BlockStart() before any child nodes are visited,
// and call its BlockEnd() after all child nodes are visited
// passing the specified "context" unaltered.
// if a given block doesnt implement the call, the context itself is checked.
func Visit(tgt jsn.Marshalee, context interface{}) error {
	ts := chart.MakeEncoder()
	return ts.Marshal(tgt, NewVisitor(&ts, context))
}

// NewVisitor - lower level initialization; prefer Visit().
func NewVisitor(m *chart.Machine, context interface{}) *BlockVisitor {
	return &BlockVisitor{m: m, context: context}
}

// BlockVisitor - state which triggers the VisitMe callbacks during Visit().
// implements jsn.State using BLockStack to track the current block.
// self-terminating when the initial block goes out of scope.
type BlockVisitor struct {
	// fix: access to machine:
	// 1. pass it with context
	// 2. use return codes
	// 3. pass marshaler or some sort of "machine" interface
	//  as a parameter to end (and,or all calls)
	// 4. always pop on end.
	m       *chart.Machine
	Blocks  BlockStack
	path    []string
	context interface{}
}

func (n *BlockVisitor) Commit(interface{}) {
	// ick
}

func (n *BlockVisitor) MarshalBlock(next jsn.Block) (err error) {
	if top, ok := n.Blocks.Top(); ok {
		if _, ok := top.Block.(jsn.SliceBlock); ok {
			n.path[len(n.path)-1] = "[" + strconv.Itoa(top.depth) + "]"
			top.depth++
		}
	}
	n.path = append(n.path, next.GetType())
	if b, ok := next.(jsn.FlowBlock); ok {
		err = n.callStart(b, b.GetFlow())
	} else {
		// overwrite the default path for the swap
		if b, ok := next.(jsn.SwapBlock); ok {
			if str, _ := b.GetSwap(); len(str) > 0 {
				n.path[len(n.path)-1] = str
			}
		}
	}
	if err == nil {
		n.Blocks.Push(next)
	}
	return
}

func (n *BlockVisitor) MarshalKey(lede, key string) (err error) {
	return
}

func (n *BlockVisitor) MarshalValue(valType string, val interface{}) (err error) {
	// in a slice where we are seeing "marshal value" -- we aren't going to be seeing new blocks
	// so they wont be getting begin/ends, so we dont need to worry about updating path
	return
}

func (n *BlockVisitor) EndBlock() {
	if was, ok := n.Blocks.Pop(); !ok {
		n.m.FinishState("scope")
	} else {
		if b, ok := was.Block.(jsn.FlowBlock); ok {
			if e := n.callEnd(b, b.GetFlow()); e != nil && e != jsn.Missing {
				n.m.Error(e)
			}
		}
		n.path = n.path[:len(n.path)-1]
	}
}

func (n *BlockVisitor) callStart(b jsn.FlowBlock, v interface{}) (err error) {
	var call VisitStart
	if vb, ok := v.(VisitStart); ok {
		call = vb
	} else if vc, ok := n.context.(VisitStart); ok {
		call = vc
	}
	if call != nil {
		c := Context{n.context, strings.Join(n.path, "/")}
		err = call.BlockStart(b, c)
	}
	return
}

func (n *BlockVisitor) callEnd(b jsn.FlowBlock, v interface{}) (err error) {
	var call VisitEnd
	if vb, ok := v.(VisitEnd); ok {
		call = vb
	} else if vc, ok := n.context.(VisitEnd); ok {
		call = vc
	}
	if call != nil {
		c := Context{n.context, strings.Join(n.path, "/")}
		err = call.BlockEnd(b, c)
	}
	return
}
