package qna

// func (run *Runner) Call(name string, aff affine.Affinity, args ...core.Argument) (ret g.Value, err error) {
// 	// create a container to hold results of args, locals, and the pending return value
// 	if values, e := run.GetValues(name); e != nil {
// 		err = e
// 	} else if k, e := run.GetKindByName(name); e != nil {
// 		err = e
// 	} else {
// 		rec := k.NewRecord()

// 		// args run in the scope of their parent context
// 		// they write to the record that will become the new context
// 		if e := run.determineArgs(rec, args); e != nil {
// 			err = e
// 		} else {
// 			// initializers ( and the pattern itself ) run in the scope of the pattern
// 			// ( with access to all locals and args)
// 			watcher := &resultsWatcher{
// 				Scope: g.RecordOf(rec),
// 				watch: pat.Return,
// 			}
// 			oldScope := run.ReplaceScope(watcher)
// 			// locals ( by definition ) write to the record context
// 			if e := pat.initializeLocals(run, rec); e != nil {
// 				err = e
// 			} else if e := pat.executePattern(run, watcher); e != nil {
// 				err = e
// 			} else if res, e := pat.getResult(rec, aff); e != nil {
// 				err = e
// 			} else {
// 				ret = res
// 			}
// 			//
// 			run.ReplaceScope(oldScope)
// 		}
// 	}
// 	if err == nil {
// 		err = errutil.New("error calling", name, err)
// 	}
// 	return
// }

// // track the number of times a particular field gets successfully written to.
// type resultsWatcher struct {
// 	rt.Scope
// 	watch string
// 	sets  int
// }

// func (rw *resultsWatcher) SetFieldByName(field string, val g.Value) (err error) {
// 	if e := rw.Scope.SetFieldByName(field, val); e != nil {
// 		err = e
// 	} else if field == rw.watch {
// 		rw.sets++
// 		// we could also store the last value set,
// 		// and use that for our result --
// 		// but if nothing is set, it feels better to use the default record value production
// 		// generated by record.GetNamedField
// 	}
// 	return
// }

// func (pat *Pattern) determineArgs(run rt.Runtime, rec *g.Record, args []*core.Argument) (err error) {
// 	// note: set indexed field assigns without copying
// 	var labelIndex int
// 	var fieldIndex int
// 	var labels []string // FROM THE RCORD INITIALIZER
// 	//
// 	for i, a := range args {
// 		n := a.Name
// 		// search for a matching label.
// 		if len(n) == 0 {
// 			err = errutil.New("unnamed arg at", i)
// 		} else if n[0] == '$' {
// 			// validate positional arguments make sense
// 			if argIndex(labelIndex) != n {
// 				break
// 			}
// 			fieldIndex, labelIndex = labelIndex, labelIndex+1
// 		} else {
// 			// search in increasing order for the next label that matches the specified argument
// 			// this is our soft way of allowing patterns to participate in fluid like specs.
// 			if i := findLabel(labels, n, labelIndex); i < 0 {
// 				err = errutil.New("has mismatched arg.", i, n)
// 				break
// 			} else {
// 				fieldIndex, labelIndex = i, i+1
// 			}
// 		}
// 		//
// 		field := rec.Kind().Field(fieldIndex)
// 		if val, e := safe.GetAssignedValue(run, a.From); e != nil {
// 			err = errutil.New("error determining arg", i, n, e)
// 			break
// 		} else if v, e := filterText(run, field, val); e != nil {
// 			err = errutil.New("error narrowing arg", i, n, e)
// 			break
// 		} else if e := rec.SetIndexedField(fieldIndex, v); e != nil {
// 			err = errutil.New("error setting arg", i, n, e)
// 			break
// 		}
// 	}
// 	return
// }

// // returns -1 if not found
// func findLabel(labels []string, name string, startingAt int) (ret int) {
// 	ret = -1 // provisionally
// 	for i, cnt := startingAt, len(labels); i < cnt; i++ {
// 		if l := labels[i]; l == name {
// 			ret = i
// 			break
// 		}
// 	}
// 	return
// }

// // fix? allows callers to use positional arguments
// // for lists could have a special RunWithVarArgs that uses a custom determineArgs
// // or, allow blank names to match any arg --
// // note: templates currently use positional args too.
// func argIndex(i int) string {
// 	return "$" + strconv.Itoa(i+1)
// }

// func (pat *Pattern) initializeLocals(run rt.Runtime, rec *g.Record) (err error) {
// 	lin, fin, lcnt := 0, len(pat.Labels), len(pat.Locals) // locals start after labels
// 	k := rec.Kind()
// 	for lin < lcnt {
// 		if field, init := k.Field(fin), pat.Locals[lin]; init != nil {
// 			if v, e := init.GetAssignedValue(run); e != nil {
// 				err = errutil.New(pat.Name, "error determining local", lin, field.Name, e)
// 				break
// 			} else if e := rec.SetIndexedField(fin, v); e != nil {
// 				err = errutil.New(pat.Name, "error setting local", lin, field.Name, e)
// 				break
// 			}
// 		}
// 		lin++
// 		fin++
// 	}
// 	return
// }

// // RunWithScope - note: assumes whatever scope is needed to run the pattern has already been setup.
// func (pat *Pattern) executePattern(run rt.Runtime, rw *resultsWatcher) (err error) {
// 	sets := rw.sets
// 	var allFlags rt.Flags
// 	if rules, e := run.GetRules(pat.Name, &allFlags); e != nil {
// 		err = e
// 	} else {
// 		for i, cnt := 0, len(rules); i < cnt && allFlags != 0; i++ {
// 			if ranFlag, e := safe.ApplyRule(run, rules[i], allFlags); e != nil {
// 				err = e
// 			} else if ranFlag != 0 {
// 				didSomething := (rw.sets > sets)
// 				sets = rw.sets
// 				// if we ran a prefix or a post fix rule and it did something, we are done.
// 				if didSomething && ranFlag != rt.Infix {
// 					break
// 				}
// 				// otherwise, if an infix rule did something
// 				// check the other kinds of rules
// 				// ditto if we dont expect the pattern to return anything:
// 				// in that case we just want to do the first of each rule type.
// 				if didSomething || len(rw.watch) == 0 {
// 					allFlags = allFlags &^ ranFlag
// 				}
// 			}
// 		}
// 	}
// 	return
// }

// func (pat *Pattern) getResult(rec *g.Record, aff affine.Affinity) (ret g.Value, err error) {
// 	// labels=parameters, inits=locals, the rest ( no more than 1 ) is the return.
// 	if res := pat.Return; len(res) > 0 {
// 		// get the value and check its result
// 		if res, e := rec.GetNamedField(res); e != nil {
// 			err = errutil.New("error trying to get return value", e)
// 		} else if e := safe.Check(res, aff); e != nil {
// 			err = errutil.New("error trying to get return value", e)
// 		} else if len(aff) == 0 {
// 			// the caller expects nothing but we have a return value.
// 			if res.Affinity() == affine.Text {
// 				core.HackTillTemplatesCanEvaluatePatternTypes = res.String()
// 			}
// 			// other than passing data back to templates in a hack...
// 			// we dont treat this as an error -- we allow patterns to be run for side effects.
// 		} else {
// 			ret = res
// 		}
// 	} else if len(aff) != 0 {
// 		err = errutil.New("caller expected", aff, "returned nothing")
// 	}
// 	return
// }
