// Code generated by "makeops"; edit at your own risk.
package rt

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"github.com/ionous/errutil"
)

const Type_Assignment = "assignment"

func Assignment_Detailed_Marshal(n jsonexp.Context, ptr *Assignment) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Assignment,
			Value: b,
		})
	}
	return
}

func Assignment_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Assignment) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Assignment, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_Assignment, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_Assignment, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_Assignment, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_Assignment, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(Assignment); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_Assignment)
		} else {
			(*out) = store
		}
	}
	return
}

const Type_BoolEval = "bool_eval"

func BoolEval_Detailed_Marshal(n jsonexp.Context, ptr *BoolEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_BoolEval,
			Value: b,
		})
	}
	return
}

func BoolEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *BoolEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_BoolEval, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_BoolEval, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_BoolEval, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_BoolEval, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_BoolEval, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(BoolEval); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_BoolEval)
		} else {
			(*out) = store
		}
	}
	return
}

func BoolEval_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]BoolEval) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := BoolEval_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_BoolEval, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func BoolEval_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]BoolEval) (err error) {
	var vals []BoolEval
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_BoolEval, "-", e)
		} else {
			vals = make([]BoolEval, len(msgs))
			for i, msg := range msgs {
				if e := BoolEval_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_BoolEval, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

const Type_Execute = "execute"

func Execute_Detailed_Marshal(n jsonexp.Context, ptr *Execute) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Execute,
			Value: b,
		})
	}
	return
}

func Execute_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Execute) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Execute, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_Execute, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_Execute, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_Execute, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_Execute, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(Execute); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_Execute)
		} else {
			(*out) = store
		}
	}
	return
}

func Execute_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Execute) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := Execute_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_Execute, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Execute_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Execute) (err error) {
	var vals []Execute
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_Execute, "-", e)
		} else {
			vals = make([]Execute, len(msgs))
			for i, msg := range msgs {
				if e := Execute_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_Execute, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

const Type_NumListEval = "num_list_eval"

func NumListEval_Detailed_Marshal(n jsonexp.Context, ptr *NumListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_NumListEval,
			Value: b,
		})
	}
	return
}

func NumListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NumListEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_NumListEval, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_NumListEval, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_NumListEval, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_NumListEval, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_NumListEval, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(NumListEval); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_NumListEval)
		} else {
			(*out) = store
		}
	}
	return
}

const Type_NumberEval = "number_eval"

func NumberEval_Detailed_Marshal(n jsonexp.Context, ptr *NumberEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_NumberEval,
			Value: b,
		})
	}
	return
}

func NumberEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NumberEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_NumberEval, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_NumberEval, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_NumberEval, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_NumberEval, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_NumberEval, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(NumberEval); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_NumberEval)
		} else {
			(*out) = store
		}
	}
	return
}

const Type_RecordEval = "record_eval"

func RecordEval_Detailed_Marshal(n jsonexp.Context, ptr *RecordEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_RecordEval,
			Value: b,
		})
	}
	return
}

func RecordEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RecordEval, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_RecordEval, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_RecordEval, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_RecordEval, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_RecordEval, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(RecordEval); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_RecordEval)
		} else {
			(*out) = store
		}
	}
	return
}

const Type_RecordListEval = "record_list_eval"

func RecordListEval_Detailed_Marshal(n jsonexp.Context, ptr *RecordListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_RecordListEval,
			Value: b,
		})
	}
	return
}

func RecordListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordListEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RecordListEval, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_RecordListEval, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_RecordListEval, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_RecordListEval, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_RecordListEval, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(RecordListEval); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_RecordListEval)
		} else {
			(*out) = store
		}
	}
	return
}

const Type_TextEval = "text_eval"

func TextEval_Detailed_Marshal(n jsonexp.Context, ptr *TextEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_TextEval,
			Value: b,
		})
	}
	return
}

func TextEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TextEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_TextEval, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_TextEval, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_TextEval, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_TextEval, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_TextEval, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(TextEval); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_TextEval)
		} else {
			(*out) = store
		}
	}
	return
}

func TextEval_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]TextEval) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := TextEval_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_TextEval, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func TextEval_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]TextEval) (err error) {
	var vals []TextEval
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_TextEval, "-", e)
		} else {
			vals = make([]TextEval, len(msgs))
			for i, msg := range msgs {
				if e := TextEval_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_TextEval, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

const Type_TextListEval = "text_list_eval"

func TextListEval_Detailed_Marshal(n jsonexp.Context, ptr *TextListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_TextListEval,
			Value: b,
		})
	}
	return
}

func TextListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TextListEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_TextListEval, "-", e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("value of", Type_TextListEval, "-", e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New(Type_TextListEval, "-", e)
		} else if imp, ok := ptr.(jsonexp.DetailedMarshaler); !ok {
			err = errutil.New("casting slot", Type_TextListEval, "-", e)
		} else if e := imp.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("contents of", Type_TextListEval, "-", e)
		} else if fini, e := n.Finalize(ptr); e != nil {
			err = e
		} else if store, ok := fini.(TextListEval); !ok {
			err = errutil.Fmt("couldnt store %T into %s", fini, Type_TextListEval)
		} else {
			(*out) = store
		}
	}
	return
}

var Slots = []interface{}{
	(*Assignment)(nil),
	(*BoolEval)(nil),
	(*Execute)(nil),
	(*NumListEval)(nil),
	(*NumberEval)(nil),
	(*RecordEval)(nil),
	(*RecordListEval)(nil),
	(*TextEval)(nil),
	(*TextListEval)(nil),
}
