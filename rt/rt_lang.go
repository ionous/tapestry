// Code generated by "makeops"; edit at your own risk.
package rt

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"github.com/ionous/errutil"
)

const Type_Assignment = "assignment"

func Assignment_Detailed_Marshal(n jsonexp.Context, ptr *Assignment) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Assignment,
			Value: b,
		})
	}
	return
}

func Assignment_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Assignment) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(Assignment); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_Assignment)
	} else {
		(*out) = store
	}
	return
}

const Type_BoolEval = "bool_eval"

func BoolEval_Detailed_Marshal(n jsonexp.Context, ptr *BoolEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_BoolEval,
			Value: b,
		})
	}
	return
}

func BoolEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *BoolEval) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(BoolEval); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_BoolEval)
	} else {
		(*out) = store
	}
	return
}

func BoolEval_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]BoolEval) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := BoolEval_Detailed_Marshal(n, &el); e != nil {
				err = errutil.New(Type_BoolEval, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func BoolEval_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]BoolEval) (err error) {
	var vals []BoolEval
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_BoolEval, "-", e)
		} else {
			vals = make([]BoolEval, len(msgs))
			for i, msg := range msgs {
				if e := BoolEval_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_BoolEval, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

const Type_Execute = "execute"

func Execute_Detailed_Marshal(n jsonexp.Context, ptr *Execute) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Execute,
			Value: b,
		})
	}
	return
}

func Execute_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Execute) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(Execute); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_Execute)
	} else {
		(*out) = store
	}
	return
}

func Execute_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Execute) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := Execute_Detailed_Marshal(n, &el); e != nil {
				err = errutil.New(Type_Execute, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Execute_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Execute) (err error) {
	var vals []Execute
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_Execute, "-", e)
		} else {
			vals = make([]Execute, len(msgs))
			for i, msg := range msgs {
				if e := Execute_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_Execute, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

const Type_NumListEval = "num_list_eval"

func NumListEval_Detailed_Marshal(n jsonexp.Context, ptr *NumListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_NumListEval,
			Value: b,
		})
	}
	return
}

func NumListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NumListEval) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(NumListEval); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_NumListEval)
	} else {
		(*out) = store
	}
	return
}

const Type_NumberEval = "number_eval"

func NumberEval_Detailed_Marshal(n jsonexp.Context, ptr *NumberEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_NumberEval,
			Value: b,
		})
	}
	return
}

func NumberEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NumberEval) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(NumberEval); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_NumberEval)
	} else {
		(*out) = store
	}
	return
}

const Type_RecordEval = "record_eval"

func RecordEval_Detailed_Marshal(n jsonexp.Context, ptr *RecordEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_RecordEval,
			Value: b,
		})
	}
	return
}

func RecordEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordEval) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(RecordEval); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_RecordEval)
	} else {
		(*out) = store
	}
	return
}

const Type_RecordListEval = "record_list_eval"

func RecordListEval_Detailed_Marshal(n jsonexp.Context, ptr *RecordListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_RecordListEval,
			Value: b,
		})
	}
	return
}

func RecordListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordListEval) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(RecordListEval); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_RecordListEval)
	} else {
		(*out) = store
	}
	return
}

const Type_TextEval = "text_eval"

func TextEval_Detailed_Marshal(n jsonexp.Context, ptr *TextEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_TextEval,
			Value: b,
		})
	}
	return
}

func TextEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TextEval) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(TextEval); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_TextEval)
	} else {
		(*out) = store
	}
	return
}

func TextEval_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]TextEval) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := TextEval_Detailed_Marshal(n, &el); e != nil {
				err = errutil.New(Type_TextEval, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func TextEval_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]TextEval) (err error) {
	var vals []TextEval
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_TextEval, "-", e)
		} else {
			vals = make([]TextEval, len(msgs))
			for i, msg := range msgs {
				if e := TextEval_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_TextEval, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

const Type_TextListEval = "text_list_eval"

func TextListEval_Detailed_Marshal(n jsonexp.Context, ptr *TextListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_TextListEval,
			Value: b,
		})
	}
	return
}

func TextListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TextListEval) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(TextListEval); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_TextListEval)
	} else {
		(*out) = store
	}
	return
}

var Slots = []interface{}{
	(*Assignment)(nil),
	(*BoolEval)(nil),
	(*Execute)(nil),
	(*NumListEval)(nil),
	(*NumberEval)(nil),
	(*RecordEval)(nil),
	(*RecordListEval)(nil),
	(*TextEval)(nil),
	(*TextListEval)(nil),
}
