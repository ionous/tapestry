// Code generated by "makeops"; edit at your own risk.
package rt

import (
	"git.sr.ht/~ionous/iffy/jsn"
	"github.com/ionous/errutil"
)

const Assignment_Type = "assignment"

var Assignment_Optional_Marshal = Assignment_Marshal

type Assignment_Slot struct{ ptr *Assignment }

func (At Assignment_Slot) GetType() string { return Assignment_Type }
func (at Assignment_Slot) HasSlot() bool   { return at.ptr != nil }
func (at Assignment_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(Assignment)
	return
}

func Assignment_Marshal(m jsn.Marshaler, ptr *Assignment) (err error) {
	if fn, exists := m.CustomizedMarshal(Assignment_Type); exists {
		err = fn(m, ptr)
	} else {
		err = Assignment_DefaultMarshal(m, ptr)
	}
	return
}
func Assignment_DefaultMarshal(m jsn.Marshaler, ptr *Assignment) (err error) {
	if err = m.MarshalBlock(Assignment_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type Assignment_Slice []Assignment

func (op *Assignment_Slice) GetType() string { return Assignment_Type }
func (op *Assignment_Slice) GetSize() int    { return len(*op) }
func (op *Assignment_Slice) SetSize(cnt int) { (*op) = make(Assignment_Slice, cnt) }

func Assignment_Repeats_Marshal(m jsn.Marshaler, vals *[]Assignment) (err error) {
	if err = m.MarshalBlock((*Assignment_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Assignment_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

const BoolEval_Type = "bool_eval"

var BoolEval_Optional_Marshal = BoolEval_Marshal

type BoolEval_Slot struct{ ptr *BoolEval }

func (At BoolEval_Slot) GetType() string { return BoolEval_Type }
func (at BoolEval_Slot) HasSlot() bool   { return at.ptr != nil }
func (at BoolEval_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(BoolEval)
	return
}

func BoolEval_Marshal(m jsn.Marshaler, ptr *BoolEval) (err error) {
	if fn, exists := m.CustomizedMarshal(BoolEval_Type); exists {
		err = fn(m, ptr)
	} else {
		err = BoolEval_DefaultMarshal(m, ptr)
	}
	return
}
func BoolEval_DefaultMarshal(m jsn.Marshaler, ptr *BoolEval) (err error) {
	if err = m.MarshalBlock(BoolEval_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type BoolEval_Slice []BoolEval

func (op *BoolEval_Slice) GetType() string { return BoolEval_Type }
func (op *BoolEval_Slice) GetSize() int    { return len(*op) }
func (op *BoolEval_Slice) SetSize(cnt int) { (*op) = make(BoolEval_Slice, cnt) }

func BoolEval_Repeats_Marshal(m jsn.Marshaler, vals *[]BoolEval) (err error) {
	if err = m.MarshalBlock((*BoolEval_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := BoolEval_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

const Execute_Type = "execute"

var Execute_Optional_Marshal = Execute_Marshal

type Execute_Slot struct{ ptr *Execute }

func (At Execute_Slot) GetType() string { return Execute_Type }
func (at Execute_Slot) HasSlot() bool   { return at.ptr != nil }
func (at Execute_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(Execute)
	return
}

func Execute_Marshal(m jsn.Marshaler, ptr *Execute) (err error) {
	if err = m.MarshalBlock(Execute_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type Execute_Slice []Execute

func (op *Execute_Slice) GetType() string { return Execute_Type }
func (op *Execute_Slice) GetSize() int    { return len(*op) }
func (op *Execute_Slice) SetSize(cnt int) { (*op) = make(Execute_Slice, cnt) }

func Execute_Repeats_Marshal(m jsn.Marshaler, vals *[]Execute) (err error) {
	if err = m.MarshalBlock((*Execute_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Execute_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

const NumListEval_Type = "num_list_eval"

var NumListEval_Optional_Marshal = NumListEval_Marshal

type NumListEval_Slot struct{ ptr *NumListEval }

func (At NumListEval_Slot) GetType() string { return NumListEval_Type }
func (at NumListEval_Slot) HasSlot() bool   { return at.ptr != nil }
func (at NumListEval_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(NumListEval)
	return
}

func NumListEval_Marshal(m jsn.Marshaler, ptr *NumListEval) (err error) {
	if fn, exists := m.CustomizedMarshal(NumListEval_Type); exists {
		err = fn(m, ptr)
	} else {
		err = NumListEval_DefaultMarshal(m, ptr)
	}
	return
}
func NumListEval_DefaultMarshal(m jsn.Marshaler, ptr *NumListEval) (err error) {
	if err = m.MarshalBlock(NumListEval_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type NumListEval_Slice []NumListEval

func (op *NumListEval_Slice) GetType() string { return NumListEval_Type }
func (op *NumListEval_Slice) GetSize() int    { return len(*op) }
func (op *NumListEval_Slice) SetSize(cnt int) { (*op) = make(NumListEval_Slice, cnt) }

func NumListEval_Repeats_Marshal(m jsn.Marshaler, vals *[]NumListEval) (err error) {
	if err = m.MarshalBlock((*NumListEval_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := NumListEval_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

const NumberEval_Type = "number_eval"

var NumberEval_Optional_Marshal = NumberEval_Marshal

type NumberEval_Slot struct{ ptr *NumberEval }

func (At NumberEval_Slot) GetType() string { return NumberEval_Type }
func (at NumberEval_Slot) HasSlot() bool   { return at.ptr != nil }
func (at NumberEval_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(NumberEval)
	return
}

func NumberEval_Marshal(m jsn.Marshaler, ptr *NumberEval) (err error) {
	if fn, exists := m.CustomizedMarshal(NumberEval_Type); exists {
		err = fn(m, ptr)
	} else {
		err = NumberEval_DefaultMarshal(m, ptr)
	}
	return
}
func NumberEval_DefaultMarshal(m jsn.Marshaler, ptr *NumberEval) (err error) {
	if err = m.MarshalBlock(NumberEval_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type NumberEval_Slice []NumberEval

func (op *NumberEval_Slice) GetType() string { return NumberEval_Type }
func (op *NumberEval_Slice) GetSize() int    { return len(*op) }
func (op *NumberEval_Slice) SetSize(cnt int) { (*op) = make(NumberEval_Slice, cnt) }

func NumberEval_Repeats_Marshal(m jsn.Marshaler, vals *[]NumberEval) (err error) {
	if err = m.MarshalBlock((*NumberEval_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := NumberEval_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

const RecordEval_Type = "record_eval"

var RecordEval_Optional_Marshal = RecordEval_Marshal

type RecordEval_Slot struct{ ptr *RecordEval }

func (At RecordEval_Slot) GetType() string { return RecordEval_Type }
func (at RecordEval_Slot) HasSlot() bool   { return at.ptr != nil }
func (at RecordEval_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(RecordEval)
	return
}

func RecordEval_Marshal(m jsn.Marshaler, ptr *RecordEval) (err error) {
	if fn, exists := m.CustomizedMarshal(RecordEval_Type); exists {
		err = fn(m, ptr)
	} else {
		err = RecordEval_DefaultMarshal(m, ptr)
	}
	return
}
func RecordEval_DefaultMarshal(m jsn.Marshaler, ptr *RecordEval) (err error) {
	if err = m.MarshalBlock(RecordEval_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type RecordEval_Slice []RecordEval

func (op *RecordEval_Slice) GetType() string { return RecordEval_Type }
func (op *RecordEval_Slice) GetSize() int    { return len(*op) }
func (op *RecordEval_Slice) SetSize(cnt int) { (*op) = make(RecordEval_Slice, cnt) }

func RecordEval_Repeats_Marshal(m jsn.Marshaler, vals *[]RecordEval) (err error) {
	if err = m.MarshalBlock((*RecordEval_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := RecordEval_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

const RecordListEval_Type = "record_list_eval"

var RecordListEval_Optional_Marshal = RecordListEval_Marshal

type RecordListEval_Slot struct{ ptr *RecordListEval }

func (At RecordListEval_Slot) GetType() string { return RecordListEval_Type }
func (at RecordListEval_Slot) HasSlot() bool   { return at.ptr != nil }
func (at RecordListEval_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(RecordListEval)
	return
}

func RecordListEval_Marshal(m jsn.Marshaler, ptr *RecordListEval) (err error) {
	if fn, exists := m.CustomizedMarshal(RecordListEval_Type); exists {
		err = fn(m, ptr)
	} else {
		err = RecordListEval_DefaultMarshal(m, ptr)
	}
	return
}
func RecordListEval_DefaultMarshal(m jsn.Marshaler, ptr *RecordListEval) (err error) {
	if err = m.MarshalBlock(RecordListEval_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type RecordListEval_Slice []RecordListEval

func (op *RecordListEval_Slice) GetType() string { return RecordListEval_Type }
func (op *RecordListEval_Slice) GetSize() int    { return len(*op) }
func (op *RecordListEval_Slice) SetSize(cnt int) { (*op) = make(RecordListEval_Slice, cnt) }

func RecordListEval_Repeats_Marshal(m jsn.Marshaler, vals *[]RecordListEval) (err error) {
	if err = m.MarshalBlock((*RecordListEval_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := RecordListEval_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

const TextEval_Type = "text_eval"

var TextEval_Optional_Marshal = TextEval_Marshal

type TextEval_Slot struct{ ptr *TextEval }

func (At TextEval_Slot) GetType() string { return TextEval_Type }
func (at TextEval_Slot) HasSlot() bool   { return at.ptr != nil }
func (at TextEval_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(TextEval)
	return
}

func TextEval_Marshal(m jsn.Marshaler, ptr *TextEval) (err error) {
	if fn, exists := m.CustomizedMarshal(TextEval_Type); exists {
		err = fn(m, ptr)
	} else {
		err = TextEval_DefaultMarshal(m, ptr)
	}
	return
}
func TextEval_DefaultMarshal(m jsn.Marshaler, ptr *TextEval) (err error) {
	if err = m.MarshalBlock(TextEval_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type TextEval_Slice []TextEval

func (op *TextEval_Slice) GetType() string { return TextEval_Type }
func (op *TextEval_Slice) GetSize() int    { return len(*op) }
func (op *TextEval_Slice) SetSize(cnt int) { (*op) = make(TextEval_Slice, cnt) }

func TextEval_Repeats_Marshal(m jsn.Marshaler, vals *[]TextEval) (err error) {
	if err = m.MarshalBlock((*TextEval_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := TextEval_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

const TextListEval_Type = "text_list_eval"

var TextListEval_Optional_Marshal = TextListEval_Marshal

type TextListEval_Slot struct{ ptr *TextListEval }

func (At TextListEval_Slot) GetType() string { return TextListEval_Type }
func (at TextListEval_Slot) HasSlot() bool   { return at.ptr != nil }
func (at TextListEval_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(TextListEval)
	return
}

func TextListEval_Marshal(m jsn.Marshaler, ptr *TextListEval) (err error) {
	if fn, exists := m.CustomizedMarshal(TextListEval_Type); exists {
		err = fn(m, ptr)
	} else {
		err = TextListEval_DefaultMarshal(m, ptr)
	}
	return
}
func TextListEval_DefaultMarshal(m jsn.Marshaler, ptr *TextListEval) (err error) {
	if err = m.MarshalBlock(TextListEval_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type TextListEval_Slice []TextListEval

func (op *TextListEval_Slice) GetType() string { return TextListEval_Type }
func (op *TextListEval_Slice) GetSize() int    { return len(*op) }
func (op *TextListEval_Slice) SetSize(cnt int) { (*op) = make(TextListEval_Slice, cnt) }

func TextListEval_Repeats_Marshal(m jsn.Marshaler, vals *[]TextListEval) (err error) {
	if err = m.MarshalBlock((*TextListEval_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := TextListEval_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*Assignment)(nil),
	(*BoolEval)(nil),
	(*Execute)(nil),
	(*NumListEval)(nil),
	(*NumberEval)(nil),
	(*RecordEval)(nil),
	(*RecordListEval)(nil),
	(*TextEval)(nil),
	(*TextListEval)(nil),
}

var Signatures = map[uint64]interface{}{}
