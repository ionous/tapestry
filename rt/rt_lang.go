// Code generated by "makeops"; edit at your own risk.
package rt

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"github.com/ionous/errutil"
)

const Type_Assignment = "assignment"

func Assignment_Detailed_Marshal(n jsonexp.Context, ptr *Assignment) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Assignment,
			Value: b,
		})
	}
	return
}

func Assignment_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Assignment) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Assignment, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_Assignment, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_Assignment, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_Assignment, e)
		} else {
			(*out) = ptr.(Assignment)
		}
	}
	return
}

const Type_BoolEval = "bool_eval"

func BoolEval_Detailed_Marshal(n jsonexp.Context, ptr *BoolEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_BoolEval,
			Value: b,
		})
	}
	return
}

func BoolEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *BoolEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_BoolEval, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_BoolEval, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_BoolEval, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_BoolEval, e)
		} else {
			(*out) = ptr.(BoolEval)
		}
	}
	return
}

func BoolEval_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]BoolEval) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := BoolEval_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New("marshaling", Type_BoolEval, "at", i, e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func BoolEval_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]BoolEval) (err error) {
	var msgs []json.RawMessage
	if e := json.Unmarshal(b, &msgs); e != nil {
		err = errutil.New("unmarshaling", Type_BoolEval, e)
	} else {
		vals := make([]BoolEval, len(msgs))
		for i, msg := range msgs {
			if e := BoolEval_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
				err = errutil.New("unmarshaling", Type_BoolEval, "at", i, e)
				break
			}
		}
		if err == nil {
			*out = vals
		}
	}
	return
}

const Type_Execute = "execute"

func Execute_Detailed_Marshal(n jsonexp.Context, ptr *Execute) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Execute,
			Value: b,
		})
	}
	return
}

func Execute_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Execute) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Execute, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_Execute, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_Execute, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_Execute, e)
		} else {
			(*out) = ptr.(Execute)
		}
	}
	return
}

func Execute_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Execute) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := Execute_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New("marshaling", Type_Execute, "at", i, e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Execute_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Execute) (err error) {
	var msgs []json.RawMessage
	if e := json.Unmarshal(b, &msgs); e != nil {
		err = errutil.New("unmarshaling", Type_Execute, e)
	} else {
		vals := make([]Execute, len(msgs))
		for i, msg := range msgs {
			if e := Execute_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
				err = errutil.New("unmarshaling", Type_Execute, "at", i, e)
				break
			}
		}
		if err == nil {
			*out = vals
		}
	}
	return
}

const Type_NumListEval = "num_list_eval"

func NumListEval_Detailed_Marshal(n jsonexp.Context, ptr *NumListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_NumListEval,
			Value: b,
		})
	}
	return
}

func NumListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NumListEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_NumListEval, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_NumListEval, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_NumListEval, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_NumListEval, e)
		} else {
			(*out) = ptr.(NumListEval)
		}
	}
	return
}

const Type_NumberEval = "number_eval"

func NumberEval_Detailed_Marshal(n jsonexp.Context, ptr *NumberEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_NumberEval,
			Value: b,
		})
	}
	return
}

func NumberEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NumberEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_NumberEval, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_NumberEval, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_NumberEval, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_NumberEval, e)
		} else {
			(*out) = ptr.(NumberEval)
		}
	}
	return
}

const Type_RecordEval = "record_eval"

func RecordEval_Detailed_Marshal(n jsonexp.Context, ptr *RecordEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_RecordEval,
			Value: b,
		})
	}
	return
}

func RecordEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_RecordEval, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_RecordEval, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_RecordEval, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_RecordEval, e)
		} else {
			(*out) = ptr.(RecordEval)
		}
	}
	return
}

const Type_RecordListEval = "record_list_eval"

func RecordListEval_Detailed_Marshal(n jsonexp.Context, ptr *RecordListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_RecordListEval,
			Value: b,
		})
	}
	return
}

func RecordListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordListEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_RecordListEval, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_RecordListEval, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_RecordListEval, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_RecordListEval, e)
		} else {
			(*out) = ptr.(RecordListEval)
		}
	}
	return
}

const Type_TextEval = "text_eval"

func TextEval_Detailed_Marshal(n jsonexp.Context, ptr *TextEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_TextEval,
			Value: b,
		})
	}
	return
}

func TextEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TextEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_TextEval, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_TextEval, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_TextEval, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_TextEval, e)
		} else {
			(*out) = ptr.(TextEval)
		}
	}
	return
}

func TextEval_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]TextEval) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := TextEval_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New("marshaling", Type_TextEval, "at", i, e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func TextEval_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]TextEval) (err error) {
	var msgs []json.RawMessage
	if e := json.Unmarshal(b, &msgs); e != nil {
		err = errutil.New("unmarshaling", Type_TextEval, e)
	} else {
		vals := make([]TextEval, len(msgs))
		for i, msg := range msgs {
			if e := TextEval_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
				err = errutil.New("unmarshaling", Type_TextEval, "at", i, e)
				break
			}
		}
		if err == nil {
			*out = vals
		}
	}
	return
}

const Type_TextListEval = "text_list_eval"

func TextListEval_Detailed_Marshal(n jsonexp.Context, ptr *TextListEval) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_TextListEval,
			Value: b,
		})
	}
	return
}

func TextListEval_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TextListEval) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_TextListEval, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_TextListEval, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_TextListEval, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_TextListEval, e)
		} else {
			(*out) = ptr.(TextListEval)
		}
	}
	return
}

var Slots = []interface{}{
	(*Assignment)(nil),
	(*BoolEval)(nil),
	(*Execute)(nil),
	(*NumListEval)(nil),
	(*NumberEval)(nil),
	(*RecordEval)(nil),
	(*RecordListEval)(nil),
	(*TextEval)(nil),
	(*TextListEval)(nil),
}
