// Low level communication between a game console and a running game.
// None of these commands are available for use in game scripts.
package play

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// play_message, a type of slot.
var Zt_PlayMessage = typeinfo.Slot{
	Name: "play_message",
	Markup: map[string]any{
		"comment": "A client-server message for the play app.",
	},
}

// Holds a single slot.
type PlayMessage_Slot struct{ Value PlayMessage }

// Implements [typeinfo.Instance] for a single slot.
func (*PlayMessage_Slot) TypeInfo() typeinfo.T {
	return &Zt_PlayMessage
}

// Holds a slice of slots.
type PlayMessage_Slots []PlayMessage

// Implements [typeinfo.Instance] for a slice of slots.
func (*PlayMessage_Slots) TypeInfo() typeinfo.T {
	return &Zt_PlayMessage
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *PlayMessage_Slots) Repeats() bool {
	return len(*op) > 0
}

// A log message that might be displayed to the client for debugging.
type PlayLog struct {
	Log    string
	Markup map[string]any `json:",omitempty"`
}

// play_log, a type of flow.
var Zt_PlayLog typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PlayLog) TypeInfo() typeinfo.T {
	return &Zt_PlayLog
}

// Implements [typeinfo.Markup]
func (op *PlayLog) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ PlayMessage = (*PlayLog)(nil)

// Holds a slice of type PlayLog.
type PlayLog_Slice []PlayLog

// Implements [typeinfo.Instance] for a slice of PlayLog.
func (*PlayLog_Slice) TypeInfo() typeinfo.T {
	return &Zt_PlayLog
}

// Implements [typeinfo.Repeats] for a slice of PlayLog.
func (op *PlayLog_Slice) Repeats() bool {
	return len(*op) > 0
}

// An app level change in state.
type PlayMode struct {
	Mode   PlayModes
	Markup map[string]any `json:",omitempty"`
}

// play_mode, a type of flow.
var Zt_PlayMode typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PlayMode) TypeInfo() typeinfo.T {
	return &Zt_PlayMode
}

// Implements [typeinfo.Markup]
func (op *PlayMode) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ PlayMessage = (*PlayMode)(nil)

// Holds a slice of type PlayMode.
type PlayMode_Slice []PlayMode

// Implements [typeinfo.Instance] for a slice of PlayMode.
func (*PlayMode_Slice) TypeInfo() typeinfo.T {
	return &Zt_PlayMode
}

// Implements [typeinfo.Repeats] for a slice of PlayMode.
func (op *PlayMode_Slice) Repeats() bool {
	return len(*op) > 0
}

// Text that should be displayed to the player.
type PlayOut struct {
	Out    string
	Markup map[string]any `json:",omitempty"`
}

// play_out, a type of flow.
var Zt_PlayOut typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PlayOut) TypeInfo() typeinfo.T {
	return &Zt_PlayOut
}

// Implements [typeinfo.Markup]
func (op *PlayOut) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ PlayMessage = (*PlayOut)(nil)

// Holds a slice of type PlayOut.
type PlayOut_Slice []PlayOut

// Implements [typeinfo.Instance] for a slice of PlayOut.
func (*PlayOut_Slice) TypeInfo() typeinfo.T {
	return &Zt_PlayOut
}

// Implements [typeinfo.Repeats] for a slice of PlayOut.
func (op *PlayOut_Slice) Repeats() bool {
	return len(*op) > 0
}

// One of the app level states communicated by [PlayMode].
type PlayModes int

// The enumerated values of PlayModes.
const (
	C_PlayModes_Asm PlayModes = iota
	C_PlayModes_Play
	C_PlayModes_Complete
	C_PlayModes_Error
)

func MakePlayModes(str string) (ret PlayModes, okay bool) {
	if i := Zt_PlayModes.FindOption(str); i >= 0 {
		ret, okay = PlayModes(i), true
	}
	return
}

func (op PlayModes) String() (ret string) {
	if i, opts := int(op), Zt_PlayModes.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid PlayModes(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// play_modes, a type of str enum.
var Zt_PlayModes = typeinfo.Str{
	Name: "play_modes",
	Options: []string{
		"asm",
		"play",
		"complete",
		"error",
	},
	Markup: map[string]any{
		"comment": "One of the app level states communicated by [PlayMode].",
	},
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_PlayLog = typeinfo.Flow{
		Name: "play_log",
		Lede: "play",
		Terms: []typeinfo.Term{{
			Name:  "log",
			Label: "log",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_PlayMessage,
		},
		Markup: map[string]any{
			"comment": "A log message that might be displayed to the client for debugging.",
		},
	}
	Zt_PlayMode = typeinfo.Flow{
		Name: "play_mode",
		Lede: "play",
		Terms: []typeinfo.Term{{
			Name:  "mode",
			Label: "mode",
			Type:  &Zt_PlayModes,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_PlayMessage,
		},
		Markup: map[string]any{
			"comment": "An app level change in state.",
		},
	}
	Zt_PlayOut = typeinfo.Flow{
		Name: "play_out",
		Lede: "play",
		Terms: []typeinfo.Term{{
			Name:  "out",
			Label: "out",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_PlayMessage,
		},
		Markup: map[string]any{
			"comment": "Text that should be displayed to the player.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "play",
	Comment: []string{
		"Low level communication between a game console and a running game.",
		"None of these commands are available for use in game scripts.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_PlayMessage,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_PlayLog,
	&Zt_PlayMode,
	&Zt_PlayOut,
}

// A list of all strs in this this package.
var z_str_list = []*typeinfo.Str{
	&Zt_PlayModes,
}

// gob like registration
func Register(reg func(any)) {
	reg((*PlayLog)(nil))
	reg((*PlayMode)(nil))
	reg((*PlayOut)(nil))
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	17624726337788752012: (*PlayLog)(nil),  /* play_message=Play log: */
	4988029522939467359:  (*PlayMode)(nil), /* play_message=Play mode: */
	14741822345399231886: (*PlayOut)(nil),  /* play_message=Play out: */
}
