// System commands to manage a running game ( save, load, etc ).
package game

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// Immediately end the current game.
type QuitGame struct {
	Markup map[string]any
}

// quit_game, a type of flow.
var Zt_QuitGame typeinfo.Flow

// Implements [typeinfo.Instance]
func (*QuitGame) TypeInfo() typeinfo.T {
	return &Zt_QuitGame
}

// Implements [typeinfo.Markup]
func (op *QuitGame) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*QuitGame)(nil)

// Holds a slice of type QuitGame.
type QuitGame_Slice []QuitGame

// Implements [typeinfo.Instance] for a slice of QuitGame.
func (*QuitGame_Slice) TypeInfo() typeinfo.T {
	return &Zt_QuitGame
}

// Implements [typeinfo.Repeats] for a slice of QuitGame.
func (op *QuitGame_Slice) Repeats() bool {
	return len(*op) > 0
}

// Save the game.
type SaveGame struct {
	Markup map[string]any
}

// save_game, a type of flow.
var Zt_SaveGame typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SaveGame) TypeInfo() typeinfo.T {
	return &Zt_SaveGame
}

// Implements [typeinfo.Markup]
func (op *SaveGame) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*SaveGame)(nil)

// Holds a slice of type SaveGame.
type SaveGame_Slice []SaveGame

// Implements [typeinfo.Instance] for a slice of SaveGame.
func (*SaveGame_Slice) TypeInfo() typeinfo.T {
	return &Zt_SaveGame
}

// Implements [typeinfo.Repeats] for a slice of SaveGame.
func (op *SaveGame_Slice) Repeats() bool {
	return len(*op) > 0
}

// Load the most recent save.
type LoadGame struct {
	Markup map[string]any
}

// load_game, a type of flow.
var Zt_LoadGame typeinfo.Flow

// Implements [typeinfo.Instance]
func (*LoadGame) TypeInfo() typeinfo.T {
	return &Zt_LoadGame
}

// Implements [typeinfo.Markup]
func (op *LoadGame) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*LoadGame)(nil)

// Holds a slice of type LoadGame.
type LoadGame_Slice []LoadGame

// Implements [typeinfo.Instance] for a slice of LoadGame.
func (*LoadGame_Slice) TypeInfo() typeinfo.T {
	return &Zt_LoadGame
}

// Implements [typeinfo.Repeats] for a slice of LoadGame.
func (op *LoadGame_Slice) Repeats() bool {
	return len(*op) > 0
}

// Unimplemented: rewind the game to undo the player's most recent input.
type UndoTurn struct {
	Markup map[string]any
}

// undo_turn, a type of flow.
var Zt_UndoTurn typeinfo.Flow

// Implements [typeinfo.Instance]
func (*UndoTurn) TypeInfo() typeinfo.T {
	return &Zt_UndoTurn
}

// Implements [typeinfo.Markup]
func (op *UndoTurn) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*UndoTurn)(nil)

// Holds a slice of type UndoTurn.
type UndoTurn_Slice []UndoTurn

// Implements [typeinfo.Instance] for a slice of UndoTurn.
func (*UndoTurn_Slice) TypeInfo() typeinfo.T {
	return &Zt_UndoTurn
}

// Implements [typeinfo.Repeats] for a slice of UndoTurn.
func (op *UndoTurn_Slice) Repeats() bool {
	return len(*op) > 0
}

// Print the version of the tap executable.
type PrintVersion struct {
	Markup map[string]any
}

// print_version, a type of flow.
var Zt_PrintVersion typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintVersion) TypeInfo() typeinfo.T {
	return &Zt_PrintVersion
}

// Implements [typeinfo.Markup]
func (op *PrintVersion) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*PrintVersion)(nil)

// Holds a slice of type PrintVersion.
type PrintVersion_Slice []PrintVersion

// Implements [typeinfo.Instance] for a slice of PrintVersion.
func (*PrintVersion_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintVersion
}

// Implements [typeinfo.Repeats] for a slice of PrintVersion.
func (op *PrintVersion_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_QuitGame = typeinfo.Flow{
		Name:  "quit_game",
		Lede:  "quit_game",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Immediately end the current game.",
		},
	}
	Zt_SaveGame = typeinfo.Flow{
		Name:  "save_game",
		Lede:  "save_game",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Save the game.",
		},
	}
	Zt_LoadGame = typeinfo.Flow{
		Name:  "load_game",
		Lede:  "load_game",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Load the most recent save.",
		},
	}
	Zt_UndoTurn = typeinfo.Flow{
		Name:  "undo_turn",
		Lede:  "undo_turn",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Unimplemented: rewind the game to undo the player's most recent input.",
		},
	}
	Zt_PrintVersion = typeinfo.Flow{
		Name:  "print_version",
		Lede:  "print_version",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Print the version of the tap executable.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "game",
	Comment: []string{
		"System commands to manage a running game ( save, load, etc ).",
	},

	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_QuitGame,
	&Zt_SaveGame,
	&Zt_LoadGame,
	&Zt_UndoTurn,
	&Zt_PrintVersion,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	7048942477941640285:  (*LoadGame)(nil),     /* execute=LoadGame */
	16069653899165369674: (*PrintVersion)(nil), /* execute=PrintVersion */
	13962506025236193050: (*QuitGame)(nil),     /* execute=QuitGame */
	12343662000108026632: (*SaveGame)(nil),     /* execute=SaveGame */
	6128819475946940678:  (*UndoTurn)(nil),     /* execute=UndoTurn */
}
