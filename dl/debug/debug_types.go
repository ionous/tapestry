// Scripting commands to debug and test stories.
package debug

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// A runtime command that does... nothing.
// ( Can be used to fill in branches ( ex. of if statements )
//
//	or rules which aren't supposed to do anything. )
type DoNothing struct {
	Markup map[string]any `json:",omitempty"`
}

// do_nothing, a type of flow.
var Zt_DoNothing typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DoNothing) TypeInfo() typeinfo.T {
	return &Zt_DoNothing
}

// Implements [typeinfo.Markup]
func (op *DoNothing) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*DoNothing)(nil)

// Holds a slice of type DoNothing.
type DoNothing_Slice []DoNothing

// Implements [typeinfo.Instance] for a slice of DoNothing.
func (*DoNothing_Slice) TypeInfo() typeinfo.T {
	return &Zt_DoNothing
}

// Implements [typeinfo.Repeats] for a slice of DoNothing.
func (op *DoNothing_Slice) Repeats() bool {
	return len(*op) > 0
}

// Evaluate a boolean command and ensure it returns true.
type Expect struct {
	Value  rtti.BoolEval
	Markup map[string]any `json:",omitempty"`
}

// expect, a type of flow.
var Zt_Expect typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Expect) TypeInfo() typeinfo.T {
	return &Zt_Expect
}

// Implements [typeinfo.Markup]
func (op *Expect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Expect)(nil)

// Holds a slice of type Expect.
type Expect_Slice []Expect

// Implements [typeinfo.Instance] for a slice of Expect.
func (*Expect_Slice) TypeInfo() typeinfo.T {
	return &Zt_Expect
}

// Implements [typeinfo.Repeats] for a slice of Expect.
func (op *Expect_Slice) Repeats() bool {
	return len(*op) > 0
}

// Examine the most recent game output, and generate an error unless it matches the specified text.
type ExpectText struct {
	Text   rtti.TextEval
	Markup map[string]any `json:",omitempty"`
}

// expect_text, a type of flow.
var Zt_ExpectText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ExpectText) TypeInfo() typeinfo.T {
	return &Zt_ExpectText
}

// Implements [typeinfo.Markup]
func (op *ExpectText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ExpectText)(nil)

// Holds a slice of type ExpectText.
type ExpectText_Slice []ExpectText

// Implements [typeinfo.Instance] for a slice of ExpectText.
func (*ExpectText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ExpectText
}

// Implements [typeinfo.Repeats] for a slice of ExpectText.
func (op *ExpectText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Process fake input as if the player had typed it themselves.
// Fabricate only works while running tests, and does nothing during normal game play.
// Multiple actions can be specified by separating them with semi-colons. For example:
//
//	Fabricate input: "s; jump; look"
type Fabricate struct {
	Text   rtti.TextEval
	Markup map[string]any `json:",omitempty"`
}

// fabricate, a type of flow.
var Zt_Fabricate typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Fabricate) TypeInfo() typeinfo.T {
	return &Zt_Fabricate
}

// Implements [typeinfo.Markup]
func (op *Fabricate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Fabricate)(nil)

// Holds a slice of type Fabricate.
type Fabricate_Slice []Fabricate

// Implements [typeinfo.Instance] for a slice of Fabricate.
func (*Fabricate_Slice) TypeInfo() typeinfo.T {
	return &Zt_Fabricate
}

// Implements [typeinfo.Repeats] for a slice of Fabricate.
func (op *Fabricate_Slice) Repeats() bool {
	return len(*op) > 0
}

// Print a value that might be useful during development.
// It will be hidden from players in the final game.
type LogValue struct {
	LogLevel LoggingLevel
	Value    rtti.Assignment
	Markup   map[string]any `json:",omitempty"`
}

// log_value, a type of flow.
var Zt_LogValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*LogValue) TypeInfo() typeinfo.T {
	return &Zt_LogValue
}

// Implements [typeinfo.Markup]
func (op *LogValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*LogValue)(nil)

// Holds a slice of type LogValue.
type LogValue_Slice []LogValue

// Implements [typeinfo.Instance] for a slice of LogValue.
func (*LogValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_LogValue
}

// Implements [typeinfo.Repeats] for a slice of LogValue.
func (op *LogValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Print a message that might be useful during development.
// It will be hidden from players in the final game.
type Note struct {
	Text     rtti.TextEval
	LogLevel LoggingLevel
	Markup   map[string]any `json:",omitempty"`
}

// note, a type of flow.
var Zt_Note typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Note) TypeInfo() typeinfo.T {
	return &Zt_Note
}

// Implements [typeinfo.Markup]
func (op *Note) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Note)(nil)

// Holds a slice of type Note.
type Note_Slice []Note

// Implements [typeinfo.Instance] for a slice of Note.
func (*Note_Slice) TypeInfo() typeinfo.T {
	return &Zt_Note
}

// Implements [typeinfo.Repeats] for a slice of Note.
func (op *Note_Slice) Repeats() bool {
	return len(*op) > 0
}

// LoggingLevel, a type of str enum.
type LoggingLevel int

// The enumerated values of LoggingLevel.
const (
	C_LoggingLevel_Debug LoggingLevel = iota
	C_LoggingLevel_Info
	C_LoggingLevel_Warn
	C_LoggingLevel_Error
)

func MakeLoggingLevel(str string) (ret LoggingLevel, okay bool) {
	if i := Zt_LoggingLevel.FindOption(str); i >= 0 {
		ret, okay = LoggingLevel(i), true
	}
	return
}

func (op LoggingLevel) String() (ret string) {
	if i, opts := int(op), Zt_LoggingLevel.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid LoggingLevel(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// logging_level, a type of str enum.
var Zt_LoggingLevel = typeinfo.Str{
	Name: "logging_level",
	Options: []string{
		"debug",
		"info",
		"warn",
		"error",
	},
	Markup: map[string]any{
		"--": "Used with [DebugLog].",
	},
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_DoNothing = typeinfo.Flow{
		Name:  "do_nothing",
		Lede:  "do_nothing",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"A runtime command that does... nothing.", "( Can be used to fill in branches ( ex. of if statements )", " or rules which aren't supposed to do anything. )"},
		},
	}
	Zt_Expect = typeinfo.Flow{
		Name: "expect",
		Lede: "expect",
		Terms: []typeinfo.Term{{
			Name: "value",
			Markup: map[string]any{
				"--": "The boolean command. If the command returns false, the expectation will fail and the game will generate an error.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": "Evaluate a boolean command and ensure it returns true.",
		},
	}
	Zt_ExpectText = typeinfo.Flow{
		Name: "expect_text",
		Lede: "expect",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Markup: map[string]any{
				"--": []string{"The expected line or lines.", "If an expected line ends with ellipses \"...\"", "then only the first part of the line has to match.", "", "For example, if the expectation was \"Hello...\",", "then the output \"Hello World!\" would match."},
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": "Examine the most recent game output, and generate an error unless it matches the specified text.",
		},
	}
	Zt_Fabricate = typeinfo.Flow{
		Name: "fabricate",
		Lede: "fabricate",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "input",
			Markup: map[string]any{
				"--": "One or more actions to handle as if typed by the player.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Process fake input as if the player had typed it themselves.", "Fabricate only works while running tests, and does nothing during normal game play.", "Multiple actions can be specified by separating them with semi-colons. For example:", "  Fabricate input: \"s; jump; look\""},
		},
	}
	Zt_LogValue = typeinfo.Flow{
		Name: "log_value",
		Lede: "log",
		Terms: []typeinfo.Term{{
			Name: "log_level",
			Markup: map[string]any{
				"--": "Importance of the message.",
			},
			Type: &Zt_LoggingLevel,
		}, {
			Name:  "value",
			Label: "value",
			Markup: map[string]any{
				"--": "Some text, or any other value, to display.",
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Print a value that might be useful during development.", "It will be hidden from players in the final game."},
		},
	}
	Zt_Note = typeinfo.Flow{
		Name: "note",
		Lede: "note",
		Terms: []typeinfo.Term{{
			Name: "text",
			Markup: map[string]any{
				"--": "One or more lines of text documentation.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "log_level",
			Label:    "level",
			Optional: true,
			Type:     &Zt_LoggingLevel,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Print a message that might be useful during development.", "It will be hidden from players in the final game."},
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "debug",
	Comment: []string{
		"Scripting commands to debug and test stories.",
	},

	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_DoNothing,
	&Zt_Expect,
	&Zt_ExpectText,
	&Zt_Fabricate,
	&Zt_LogValue,
	&Zt_Note,
}

// A list of all strs in this this package.
var z_str_list = []*typeinfo.Str{
	&Zt_LoggingLevel,
}

// gob like registration
func Register(reg func(any)) {
	reg((*DoNothing)(nil))
	reg((*Expect)(nil))
	reg((*ExpectText)(nil))
	reg((*Fabricate)(nil))
	reg((*LogValue)(nil))
	reg((*Note)(nil))
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	14645287343365598707: (*DoNothing)(nil),  /* execute=DoNothing */
	16489874106085927697: (*ExpectText)(nil), /* execute=Expect text: */
	11108202414968227788: (*Expect)(nil),     /* execute=Expect: */
	12332403919453206336: (*Fabricate)(nil),  /* execute=Fabricate input: */
	14196615958578686010: (*LogValue)(nil),   /* execute=Log:value: */
	16242102660676547183: (*Note)(nil),       /* execute=Note: */
	7518350145348849935:  (*Note)(nil),       /* execute=Note:level: */
}
