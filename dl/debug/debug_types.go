// Code generated by Tapestry; edit at your own risk.
package debug

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DoNothing struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DoNothing) Inspect() typeinfo.T {
	return &Z_DoNothing_T
}

// return a valid markup map, creating it if necessary.
func (op *DoNothing) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// do_nothing, a type of flow.
const Z_DoNothing_Name = "do_nothing"

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DoNothing)(nil)

var Z_DoNothing_T = typeinfo.Flow{
	Name:  Z_DoNothing_Name,
	Lede:  "--",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Z_Execute_T,
	},
	Markup: map[string]any{
		"comment": []interface{}{"a command with a signature of the comment marker metadata.", "a cheat to allows nodes that have only a comment marker and no actual command.", "see also: story.story_break"},
	},
}

// holds a slice of type do_nothing
// FIX: duplicates the spec decl.
type FIX_DoNothing_Slice []DoNothing

// implements typeinfo.Inspector
func (*DoNothing_Slice) Inspect() typeinfo.T {
	return &Z_DoNothing_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Expect struct {
	Value  rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Expect) Inspect() typeinfo.T {
	return &Z_Expect_T
}

// return a valid markup map, creating it if necessary.
func (op *Expect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// expect, a type of flow.
const Z_Expect_Name = "expect"

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Expect)(nil)

var Z_Expect_T = typeinfo.Flow{
	Name: Z_Expect_Name,
	Lede: "expect",
	Terms: []typeinfo.Term{{
		Name:  "value",
		Label: "_",
		Type:  &rtti.Z_BoolEval_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_Execute_T,
	},
}

// holds a slice of type expect
// FIX: duplicates the spec decl.
type FIX_Expect_Slice []Expect

// implements typeinfo.Inspector
func (*Expect_Slice) Inspect() typeinfo.T {
	return &Z_Expect_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ExpectOutput struct {
	Output string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ExpectOutput) Inspect() typeinfo.T {
	return &Z_ExpectOutput_T
}

// return a valid markup map, creating it if necessary.
func (op *ExpectOutput) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// expect_output, a type of flow.
const Z_ExpectOutput_Name = "expect_output"

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ExpectOutput)(nil)

var Z_ExpectOutput_T = typeinfo.Flow{
	Name: Z_ExpectOutput_Name,
	Lede: "expect",
	Terms: []typeinfo.Term{{
		Name:  "output",
		Label: "output",
		Type:  &prim.Z_Lines_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_Execute_T,
	},
}

// holds a slice of type expect_output
// FIX: duplicates the spec decl.
type FIX_ExpectOutput_Slice []ExpectOutput

// implements typeinfo.Inspector
func (*ExpectOutput_Slice) Inspect() typeinfo.T {
	return &Z_ExpectOutput_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ExpectText struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ExpectText) Inspect() typeinfo.T {
	return &Z_ExpectText_T
}

// return a valid markup map, creating it if necessary.
func (op *ExpectText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// expect_text, a type of flow.
const Z_ExpectText_Name = "expect_text"

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ExpectText)(nil)

var Z_ExpectText_T = typeinfo.Flow{
	Name: Z_ExpectText_Name,
	Lede: "expect",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "text",
		Type:  &rtti.Z_TextEval_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_Execute_T,
	},
}

// holds a slice of type expect_text
// FIX: duplicates the spec decl.
type FIX_ExpectText_Slice []ExpectText

// implements typeinfo.Inspector
func (*ExpectText_Slice) Inspect() typeinfo.T {
	return &Z_ExpectText_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Fabricate struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Fabricate) Inspect() typeinfo.T {
	return &Z_Fabricate_T
}

// return a valid markup map, creating it if necessary.
func (op *Fabricate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// fabricate, a type of flow.
const Z_Fabricate_Name = "fabricate"

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Fabricate)(nil)

var Z_Fabricate_T = typeinfo.Flow{
	Name: Z_Fabricate_Name,
	Lede: "fabricate",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "input",
		Type:  &rtti.Z_TextEval_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_Execute_T,
	},
	Markup: map[string]any{
		"comment": []interface{}{"fake input as if the player had typed it themselves.", "only works while running checks."},
	},
}

// holds a slice of type fabricate
// FIX: duplicates the spec decl.
type FIX_Fabricate_Slice []Fabricate

// implements typeinfo.Inspector
func (*Fabricate_Slice) Inspect() typeinfo.T {
	return &Z_Fabricate_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DebugLog struct {
	LogLevel string
	Value    rtti.Assignment
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*DebugLog) Inspect() typeinfo.T {
	return &Z_DebugLog_T
}

// return a valid markup map, creating it if necessary.
func (op *DebugLog) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// debug_log, a type of flow.
const Z_DebugLog_Name = "debug_log"

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DebugLog)(nil)

var Z_DebugLog_T = typeinfo.Flow{
	Name: Z_DebugLog_Name,
	Lede: "log",
	Terms: []typeinfo.Term{{
		Name:  "log_level",
		Label: "_",
		Type:  &Z_LoggingLevel_T,
	}, {
		Name:  "value",
		Label: "value",
		Type:  &rtti.Z_Assignment_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_Execute_T,
	},
	Markup: map[string]any{
		"comment": "Debug log.",
	},
}

// holds a slice of type debug_log
// FIX: duplicates the spec decl.
type FIX_DebugLog_Slice []DebugLog

// implements typeinfo.Inspector
func (*DebugLog_Slice) Inspect() typeinfo.T {
	return &Z_DebugLog_T
}

// logging_level, a type of str enum.
const Z_LoggingLevel_Name = "logging_level"

const (
	W_LoggingLevel_Note  = "$NOTE"
	W_LoggingLevel_Debug = "$DEBUG"
	W_LoggingLevel_Info  = "$INFO"
	W_LoggingLevel_Warn  = "$WARN"
	W_LoggingLevel_Error = "$ERROR"
)

var Z_LoggingLevel_T = typeinfo.Str{
	Name: Z_LoggingLevel_Name,
	Options: []string{
		W_LoggingLevel_Note,
		W_LoggingLevel_Debug,
		W_LoggingLevel_Info,
		W_LoggingLevel_Warn,
		W_LoggingLevel_Error,
	},
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "debug",
	Flow: z_flow_list,
	Str:  z_str_list,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Z_DoNothing_T,
	&Z_Expect_T,
	&Z_ExpectOutput_T,
	&Z_ExpectText_T,
	&Z_Fabricate_T,
	&Z_DebugLog_T,
}

// a list of all strs in this this package
var z_str_list = []*typeinfo.Str{
	&Z_LoggingLevel_T,
}
