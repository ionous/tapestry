// Code generated by Tapestry; edit at your own risk.
package debug

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DoNothing struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DoNothing) Inspect() (typeinfo.T, bool) {
	return &Zt_DoNothing, false
}

// return a valid markup map, creating it if necessary.
func (op *DoNothing) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DoNothing)(nil)

// do_nothing, a type of flow.
var Zt_DoNothing = typeinfo.Flow{
	Name:  "do_nothing",
	Lede:  "--",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"a command with a signature of the comment marker metadata.", "a cheat to allows nodes that have only a comment marker and no actual command.", "see also: story.story_break"},
	},
}

// holds a slice of type do_nothing
// FIX: duplicates the spec decl.
type FIX_DoNothing_Slice []DoNothing

// implements typeinfo.Inspector
func (*DoNothing_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_DoNothing, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Expect struct {
	Value  rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Expect) Inspect() (typeinfo.T, bool) {
	return &Zt_Expect, false
}

// return a valid markup map, creating it if necessary.
func (op *Expect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Expect)(nil)

// expect, a type of flow.
var Zt_Expect = typeinfo.Flow{
	Name: "expect",
	Lede: "expect",
	Terms: []typeinfo.Term{{
		Name: "value",
		Type: &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
}

// holds a slice of type expect
// FIX: duplicates the spec decl.
type FIX_Expect_Slice []Expect

// implements typeinfo.Inspector
func (*Expect_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Expect, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ExpectOutput struct {
	Output string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ExpectOutput) Inspect() (typeinfo.T, bool) {
	return &Zt_ExpectOutput, false
}

// return a valid markup map, creating it if necessary.
func (op *ExpectOutput) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ExpectOutput)(nil)

// expect_output, a type of flow.
var Zt_ExpectOutput = typeinfo.Flow{
	Name: "expect_output",
	Lede: "expect",
	Terms: []typeinfo.Term{{
		Name:  "output",
		Label: "output",
		Type:  &prim.Zt_Lines,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
}

// holds a slice of type expect_output
// FIX: duplicates the spec decl.
type FIX_ExpectOutput_Slice []ExpectOutput

// implements typeinfo.Inspector
func (*ExpectOutput_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ExpectOutput, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ExpectText struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ExpectText) Inspect() (typeinfo.T, bool) {
	return &Zt_ExpectText, false
}

// return a valid markup map, creating it if necessary.
func (op *ExpectText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ExpectText)(nil)

// expect_text, a type of flow.
var Zt_ExpectText = typeinfo.Flow{
	Name: "expect_text",
	Lede: "expect",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "text",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
}

// holds a slice of type expect_text
// FIX: duplicates the spec decl.
type FIX_ExpectText_Slice []ExpectText

// implements typeinfo.Inspector
func (*ExpectText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ExpectText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Fabricate struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Fabricate) Inspect() (typeinfo.T, bool) {
	return &Zt_Fabricate, false
}

// return a valid markup map, creating it if necessary.
func (op *Fabricate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Fabricate)(nil)

// fabricate, a type of flow.
var Zt_Fabricate = typeinfo.Flow{
	Name: "fabricate",
	Lede: "fabricate",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "input",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"fake input as if the player had typed it themselves.", "only works while running checks."},
	},
}

// holds a slice of type fabricate
// FIX: duplicates the spec decl.
type FIX_Fabricate_Slice []Fabricate

// implements typeinfo.Inspector
func (*Fabricate_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Fabricate, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DebugLog struct {
	LogLevel string
	Value    rtti.Assignment
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*DebugLog) Inspect() (typeinfo.T, bool) {
	return &Zt_DebugLog, false
}

// return a valid markup map, creating it if necessary.
func (op *DebugLog) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DebugLog)(nil)

// debug_log, a type of flow.
var Zt_DebugLog = typeinfo.Flow{
	Name: "debug_log",
	Lede: "log",
	Terms: []typeinfo.Term{{
		Name: "log_level",
		Type: &Zt_LoggingLevel,
	}, {
		Name:  "value",
		Label: "value",
		Type:  &rtti.Zt_Assignment,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Debug log.",
	},
}

// holds a slice of type debug_log
// FIX: duplicates the spec decl.
type FIX_DebugLog_Slice []DebugLog

// implements typeinfo.Inspector
func (*DebugLog_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_DebugLog, true
}

const (
	Zc_LoggingLevel_Note  = "note"
	Zc_LoggingLevel_Debug = "debug"
	Zc_LoggingLevel_Info  = "info"
	Zc_LoggingLevel_Warn  = "warn"
	Zc_LoggingLevel_Error = "error"
)

// logging_level, a type of str enum.
var Zt_LoggingLevel = typeinfo.Str{
	Name: "logging_level",
	Options: []string{
		Zc_LoggingLevel_Note,
		Zc_LoggingLevel_Debug,
		Zc_LoggingLevel_Info,
		Zc_LoggingLevel_Warn,
		Zc_LoggingLevel_Error,
	},
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "debug",
	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_DoNothing,
	&Zt_Expect,
	&Zt_ExpectOutput,
	&Zt_ExpectText,
	&Zt_Fabricate,
	&Zt_DebugLog,
}

// a list of all strs in this this package
var z_str_list = []*typeinfo.Str{
	&Zt_LoggingLevel,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]any{
	15882152812809098721: (*DoNothing)(nil),    /* execute=-- */
	13157581199995609923: (*ExpectOutput)(nil), /* execute=Expect output: */
	16489874106085927697: (*ExpectText)(nil),   /* execute=Expect text: */
	11108202414968227788: (*Expect)(nil),       /* execute=Expect: */
	12332403919453206336: (*Fabricate)(nil),    /* execute=Fabricate input: */
	14196615958578686010: (*DebugLog)(nil),     /* execute=Log:value: */
}
