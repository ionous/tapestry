// debug and testing statements
package debug

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// a command with a signature of the comment marker metadata.
// a cheat to allows nodes that have only a comment marker and no actual command.
// see also: story.story_break
type DoNothing struct {
	Markup map[string]any
}

// do_nothing, a type of flow.
var Zt_DoNothing typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DoNothing) TypeInfo() typeinfo.T {
	return &Zt_DoNothing
}

// Implements [typeinfo.Markup]
func (op *DoNothing) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*DoNothing)(nil)

// Holds a slice of type DoNothing.
type DoNothing_Slice []DoNothing

// Implements [typeinfo.Instance] for a slice of DoNothing.
func (*DoNothing_Slice) TypeInfo() typeinfo.T {
	return &Zt_DoNothing
}

// Implements [typeinfo.Repeats] for a slice of DoNothing.
func (op *DoNothing_Slice) Repeats() bool {
	return len(*op) > 0
}

type Expect struct {
	Value  rtti.BoolEval
	Markup map[string]any
}

// expect, a type of flow.
var Zt_Expect typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Expect) TypeInfo() typeinfo.T {
	return &Zt_Expect
}

// Implements [typeinfo.Markup]
func (op *Expect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Expect)(nil)

// Holds a slice of type Expect.
type Expect_Slice []Expect

// Implements [typeinfo.Instance] for a slice of Expect.
func (*Expect_Slice) TypeInfo() typeinfo.T {
	return &Zt_Expect
}

// Implements [typeinfo.Repeats] for a slice of Expect.
func (op *Expect_Slice) Repeats() bool {
	return len(*op) > 0
}

type ExpectOutput struct {
	Output string
	Markup map[string]any
}

// expect_output, a type of flow.
var Zt_ExpectOutput typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ExpectOutput) TypeInfo() typeinfo.T {
	return &Zt_ExpectOutput
}

// Implements [typeinfo.Markup]
func (op *ExpectOutput) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ExpectOutput)(nil)

// Holds a slice of type ExpectOutput.
type ExpectOutput_Slice []ExpectOutput

// Implements [typeinfo.Instance] for a slice of ExpectOutput.
func (*ExpectOutput_Slice) TypeInfo() typeinfo.T {
	return &Zt_ExpectOutput
}

// Implements [typeinfo.Repeats] for a slice of ExpectOutput.
func (op *ExpectOutput_Slice) Repeats() bool {
	return len(*op) > 0
}

type ExpectText struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// expect_text, a type of flow.
var Zt_ExpectText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ExpectText) TypeInfo() typeinfo.T {
	return &Zt_ExpectText
}

// Implements [typeinfo.Markup]
func (op *ExpectText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ExpectText)(nil)

// Holds a slice of type ExpectText.
type ExpectText_Slice []ExpectText

// Implements [typeinfo.Instance] for a slice of ExpectText.
func (*ExpectText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ExpectText
}

// Implements [typeinfo.Repeats] for a slice of ExpectText.
func (op *ExpectText_Slice) Repeats() bool {
	return len(*op) > 0
}

// fake input as if the player had typed it themselves.
// only works while running checks.
type Fabricate struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// fabricate, a type of flow.
var Zt_Fabricate typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Fabricate) TypeInfo() typeinfo.T {
	return &Zt_Fabricate
}

// Implements [typeinfo.Markup]
func (op *Fabricate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Fabricate)(nil)

// Holds a slice of type Fabricate.
type Fabricate_Slice []Fabricate

// Implements [typeinfo.Instance] for a slice of Fabricate.
func (*Fabricate_Slice) TypeInfo() typeinfo.T {
	return &Zt_Fabricate
}

// Implements [typeinfo.Repeats] for a slice of Fabricate.
func (op *Fabricate_Slice) Repeats() bool {
	return len(*op) > 0
}

// Debug log.
type DebugLog struct {
	LogLevel LoggingLevel
	Value    rtti.Assignment
	Markup   map[string]any
}

// debug_log, a type of flow.
var Zt_DebugLog typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DebugLog) TypeInfo() typeinfo.T {
	return &Zt_DebugLog
}

// Implements [typeinfo.Markup]
func (op *DebugLog) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*DebugLog)(nil)

// Holds a slice of type DebugLog.
type DebugLog_Slice []DebugLog

// Implements [typeinfo.Instance] for a slice of DebugLog.
func (*DebugLog_Slice) TypeInfo() typeinfo.T {
	return &Zt_DebugLog
}

// Implements [typeinfo.Repeats] for a slice of DebugLog.
func (op *DebugLog_Slice) Repeats() bool {
	return len(*op) > 0
}

// LoggingLevel, a type of str enum.
type LoggingLevel int

// The enumerated values of LoggingLevel.
const (
	C_LoggingLevel_Note LoggingLevel = iota
	C_LoggingLevel_Debug
	C_LoggingLevel_Info
	C_LoggingLevel_Warn
	C_LoggingLevel_Error
)

func MakeLoggingLevel(str string) (ret LoggingLevel, okay bool) {
	if i := Zt_LoggingLevel.FindOption(str); i >= 0 {
		ret, okay = LoggingLevel(i), true
	}
	return
}

func (op LoggingLevel) String() (ret string) {
	if i, opts := int(op), Zt_LoggingLevel.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid LoggingLevel(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// logging_level, a type of str enum.
var Zt_LoggingLevel = typeinfo.Str{
	Name: "logging_level",
	Options: []string{
		"note",
		"debug",
		"info",
		"warn",
		"error",
	},
	OptionComments: []string{
		"the lowest logging level. not displayed unless specifically requested.",
		"",
		"",
		"",
		"",
	},
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_DoNothing = typeinfo.Flow{
		Name:  "do_nothing",
		Lede:  "--",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment":  []interface{}{"a command with a signature of the comment marker metadata.", "a cheat to allows nodes that have only a comment marker and no actual command.", "see also: story.story_break"},
			"internal": true,
		},
	}
	Zt_Expect = typeinfo.Flow{
		Name: "expect",
		Lede: "expect",
		Terms: []typeinfo.Term{{
			Name: "value",
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
	}
	Zt_ExpectOutput = typeinfo.Flow{
		Name: "expect_output",
		Lede: "expect",
		Terms: []typeinfo.Term{{
			Name:  "output",
			Label: "output",
			Type:  &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
	}
	Zt_ExpectText = typeinfo.Flow{
		Name: "expect_text",
		Lede: "expect",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
	}
	Zt_Fabricate = typeinfo.Flow{
		Name: "fabricate",
		Lede: "fabricate",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "input",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"fake input as if the player had typed it themselves.", "only works while running checks."},
		},
	}
	Zt_DebugLog = typeinfo.Flow{
		Name: "debug_log",
		Lede: "log",
		Terms: []typeinfo.Term{{
			Name: "log_level",
			Type: &Zt_LoggingLevel,
		}, {
			Name:  "value",
			Label: "value",
			Type:  &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Debug log.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "debug",
	Comment: []string{
		"debug and testing statements ",
	},

	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_DoNothing,
	&Zt_Expect,
	&Zt_ExpectOutput,
	&Zt_ExpectText,
	&Zt_Fabricate,
	&Zt_DebugLog,
}

// A list of all strs in this this package.
var z_str_list = []*typeinfo.Str{
	&Zt_LoggingLevel,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	15882152812809098721: (*DoNothing)(nil),    /* execute=-- */
	13157581199995609923: (*ExpectOutput)(nil), /* execute=Expect output: */
	16489874106085927697: (*ExpectText)(nil),   /* execute=Expect text: */
	11108202414968227788: (*Expect)(nil),       /* execute=Expect: */
	12332403919453206336: (*Fabricate)(nil),    /* execute=Fabricate input: */
	14196615958578686010: (*DebugLog)(nil),     /* execute=Log:value: */
}
