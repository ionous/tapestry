// Text template rendering.
// Keeping these functions separated allows weave to exclude package express from the runtime.
package render

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/object"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// render_eval, a type of slot.
var Zt_RenderEval = typeinfo.Slot{
	Name: "render_eval",
	Markup: map[string]any{
		"comment":  "Used with render pattern for arguments of unknown type.",
		"internal": true,
	},
}

// Holds a single slot.
type RenderEval_Slot struct{ Value RenderEval }

// Implements [typeinfo.Instance] for a single slot.
func (*RenderEval_Slot) TypeInfo() typeinfo.T {
	return &Zt_RenderEval
}

// Holds a slice of slots.
type RenderEval_Slots []RenderEval

// Implements [typeinfo.Instance] for a slice of slots.
func (*RenderEval_Slots) TypeInfo() typeinfo.T {
	return &Zt_RenderEval
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *RenderEval_Slots) Repeats() bool {
	return len(*op) > 0
}

// Handles changing a template like {.boombip} into text.
// If the name is a variable containing an object name: return the printed object name ( via "print name" );
// if the name is a variable with some other text: return that text;
// if the name isn't a variable but refers to some object: return that object's printed object name;
// otherwise, its an error.
type RenderName struct {
	Name   string
	Markup map[string]any
}

// render_name, a type of flow.
var Zt_RenderName typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RenderName) TypeInfo() typeinfo.T {
	return &Zt_RenderName
}

// Implements [typeinfo.Markup]
func (op *RenderName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*RenderName)(nil)

// Holds a slice of type RenderName.
type RenderName_Slice []RenderName

// Implements [typeinfo.Instance] for a slice of RenderName.
func (*RenderName_Slice) TypeInfo() typeinfo.T {
	return &Zt_RenderName
}

// Implements [typeinfo.Repeats] for a slice of RenderName.
func (op *RenderName_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pull a value from name that might refer either to a variable, or to an object.
// If the name is an object, returns the object id.
type RenderRef struct {
	Name   rtti.TextEval
	Dot    []object.Dot
	Markup map[string]any
}

// render_ref, a type of flow.
var Zt_RenderRef typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RenderRef) TypeInfo() typeinfo.T {
	return &Zt_RenderRef
}

// Implements [typeinfo.Markup]
func (op *RenderRef) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*RenderRef)(nil)
var _ rtti.NumEval = (*RenderRef)(nil)
var _ rtti.TextEval = (*RenderRef)(nil)
var _ rtti.RecordEval = (*RenderRef)(nil)
var _ rtti.NumListEval = (*RenderRef)(nil)
var _ rtti.TextListEval = (*RenderRef)(nil)
var _ rtti.RecordListEval = (*RenderRef)(nil)
var _ RenderEval = (*RenderRef)(nil)

// Holds a slice of type RenderRef.
type RenderRef_Slice []RenderRef

// Implements [typeinfo.Instance] for a slice of RenderRef.
func (*RenderRef_Slice) TypeInfo() typeinfo.T {
	return &Zt_RenderRef
}

// Implements [typeinfo.Repeats] for a slice of RenderRef.
func (op *RenderRef_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pull a value from an assignment of unknown affinity.
type RenderValue struct {
	Value  rtti.Assignment
	Markup map[string]any
}

// render_value, a type of flow.
var Zt_RenderValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RenderValue) TypeInfo() typeinfo.T {
	return &Zt_RenderValue
}

// Implements [typeinfo.Markup]
func (op *RenderValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ RenderEval = (*RenderValue)(nil)

// Holds a slice of type RenderValue.
type RenderValue_Slice []RenderValue

// Implements [typeinfo.Instance] for a slice of RenderValue.
func (*RenderValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_RenderValue
}

// Implements [typeinfo.Repeats] for a slice of RenderValue.
func (op *RenderValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// A version of core's call pattern
// that figures out how to evaluate its arguments at runtime.
type RenderPattern struct {
	PatternName string
	Render      []RenderEval
	Markup      map[string]any
}

// render_pattern, a type of flow.
var Zt_RenderPattern typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RenderPattern) TypeInfo() typeinfo.T {
	return &Zt_RenderPattern
}

// Implements [typeinfo.Markup]
func (op *RenderPattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*RenderPattern)(nil)
var _ rtti.TextEval = (*RenderPattern)(nil)
var _ RenderEval = (*RenderPattern)(nil)

// Holds a slice of type RenderPattern.
type RenderPattern_Slice []RenderPattern

// Implements [typeinfo.Instance] for a slice of RenderPattern.
func (*RenderPattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_RenderPattern
}

// Implements [typeinfo.Repeats] for a slice of RenderPattern.
func (op *RenderPattern_Slice) Repeats() bool {
	return len(*op) > 0
}

// Generate text in a replaceable manner.
type RenderResponse struct {
	Name   string
	Text   rtti.TextEval
	Markup map[string]any
}

// render_response, a type of flow.
var Zt_RenderResponse typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RenderResponse) TypeInfo() typeinfo.T {
	return &Zt_RenderResponse
}

// Implements [typeinfo.Markup]
func (op *RenderResponse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*RenderResponse)(nil)
var _ rtti.TextEval = (*RenderResponse)(nil)

// Holds a slice of type RenderResponse.
type RenderResponse_Slice []RenderResponse

// Implements [typeinfo.Instance] for a slice of RenderResponse.
func (*RenderResponse_Slice) TypeInfo() typeinfo.T {
	return &Zt_RenderResponse
}

// Implements [typeinfo.Repeats] for a slice of RenderResponse.
func (op *RenderResponse_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_RenderName = typeinfo.Flow{
		Name: "render_name",
		Lede: "render_name",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment":  []interface{}{"Handles changing a template like {.boombip} into text.", "If the name is a variable containing an object name: return the printed object name ( via \"print name\" );", "if the name is a variable with some other text: return that text;", "if the name isn't a variable but refers to some object: return that object's printed object name;", "otherwise, its an error."},
			"internal": true,
		},
	}
	Zt_RenderRef = typeinfo.Flow{
		Name: "render_ref",
		Lede: "render_ref",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "dot",
			Label:    "dot",
			Optional: true,
			Repeats:  true,
			Type:     &object.Zt_Dot,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
			&rtti.Zt_TextEval,
			&rtti.Zt_RecordEval,
			&rtti.Zt_NumListEval,
			&rtti.Zt_TextListEval,
			&rtti.Zt_RecordListEval,
			&Zt_RenderEval,
		},
		Markup: map[string]any{
			"comment":  []interface{}{"Pull a value from name that might refer either to a variable, or to an object.", "If the name is an object, returns the object id."},
			"internal": true,
		},
	}
	Zt_RenderValue = typeinfo.Flow{
		Name: "render_value",
		Lede: "render_value",
		Terms: []typeinfo.Term{{
			Name: "value",
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_RenderEval,
		},
		Markup: map[string]any{
			"comment":  "Pull a value from an assignment of unknown affinity.",
			"internal": true,
		},
	}
	Zt_RenderPattern = typeinfo.Flow{
		Name: "render_pattern",
		Lede: "render",
		Terms: []typeinfo.Term{{
			Name: "pattern_name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "render",
			Label:   "render",
			Repeats: true,
			Type:    &Zt_RenderEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
			&rtti.Zt_TextEval,
			&Zt_RenderEval,
		},
		Markup: map[string]any{
			"comment":  []interface{}{"A version of core's call pattern", "that figures out how to evaluate its arguments at runtime."},
			"internal": true,
		},
	}
	Zt_RenderResponse = typeinfo.Flow{
		Name: "render_response",
		Lede: "render_response",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:     "text",
			Label:    "text",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment":  "Generate text in a replaceable manner.",
			"internal": true,
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "render",
	Comment: []string{
		"Text template rendering.",
		"Keeping these functions separated allows weave to exclude package express from the runtime.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_RenderEval,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_RenderName,
	&Zt_RenderRef,
	&Zt_RenderValue,
	&Zt_RenderPattern,
	&Zt_RenderResponse,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	14401057669022842575: (*RenderPattern)(nil),  /* bool_eval=Render:render: */
	2910903954323771519:  (*RenderPattern)(nil),  /* render_eval=Render:render: */
	3385363614654173788:  (*RenderPattern)(nil),  /* text_eval=Render:render: */
	4328811686385928991:  (*RenderName)(nil),     /* text_eval=RenderName: */
	12372540113328333010: (*RenderRef)(nil),      /* bool_eval=RenderRef: */
	15295137765008583080: (*RenderRef)(nil),      /* num_eval=RenderRef: */
	17707941731931999319: (*RenderRef)(nil),      /* num_list_eval=RenderRef: */
	11952381947639314199: (*RenderRef)(nil),      /* record_eval=RenderRef: */
	5794615276964665178:  (*RenderRef)(nil),      /* record_list_eval=RenderRef: */
	15289959684061875714: (*RenderRef)(nil),      /* render_eval=RenderRef: */
	10542331033523904889: (*RenderRef)(nil),      /* text_eval=RenderRef: */
	4171261980310148416:  (*RenderRef)(nil),      /* text_list_eval=RenderRef: */
	18249933776929959289: (*RenderRef)(nil),      /* bool_eval=RenderRef:dot: */
	7340889015221784767:  (*RenderRef)(nil),      /* num_eval=RenderRef:dot: */
	9735547470721472920:  (*RenderRef)(nil),      /* num_list_eval=RenderRef:dot: */
	8324158095841155032:  (*RenderRef)(nil),      /* record_eval=RenderRef:dot: */
	17618593433797581633: (*RenderRef)(nil),      /* record_list_eval=RenderRef:dot: */
	7883271647282708009:  (*RenderRef)(nil),      /* render_eval=RenderRef:dot: */
	239223853229152058:   (*RenderRef)(nil),      /* text_eval=RenderRef:dot: */
	3872622981826050135:  (*RenderRef)(nil),      /* text_list_eval=RenderRef:dot: */
	15658359855727638606: (*RenderResponse)(nil), /* execute=RenderResponse: */
	6351613444865908923:  (*RenderResponse)(nil), /* text_eval=RenderResponse: */
	167592851841791829:   (*RenderResponse)(nil), /* execute=RenderResponse:text: */
	10415880721138830946: (*RenderResponse)(nil), /* text_eval=RenderResponse:text: */
	7608693554121607902:  (*RenderValue)(nil),    /* render_eval=RenderValue: */
}
