// Code generated by "makeops"; edit at your own risk.
package render

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// RenderExp
type RenderExp struct {
	Expression rt.TextEval `if:"label=_"`
}

func (*RenderExp) Compose() composer.Spec {
	return composer.Spec{
		Name: "render_exp",
		Uses: "flow",
	}
}

func (op *RenderExp) MarshalJSON() (ret []byte, err error) {
	if jsonExpression, e := op.MarshalJSONExpression(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "render_exp",
			"value": map[string]json.RawMessage{
				"$EXPRESSION": jsonExpression,
			},
		})
	}
	return
}

func (op *RenderExp) MarshalJSONExpression() ([]byte, error) {
	m := op.Expression.(json.Marshaler)
	return m.MarshalJSON()
}

// RenderField in template phrases, picks between record variables, object variables, and named global objects.,ex. could be &quot;ringBearer&quot;, &quot;SamWise&quot;, or &quot;frodo&quot;
type RenderField struct {
	Name rt.TextEval `if:"label=_"`
}

func (*RenderField) Compose() composer.Spec {
	return composer.Spec{
		Name: "render_field",
		Uses: "flow",
	}
}

func (op *RenderField) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "render_field",
			"value": map[string]json.RawMessage{
				"$NAME": jsonName,
			},
		})
	}
	return
}

func (op *RenderField) MarshalJSONName() ([]byte, error) {
	m := op.Name.(json.Marshaler)
	return m.MarshalJSON()
}

// RenderFlags requires a user-specified string.
type RenderFlags struct {
	Str string
}

func (op *RenderFlags) String() (ret string) {
	return op.Str
}

func (op *RenderFlags) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "render_flags",
		"value": op.Str,
	})
}

const RenderFlags_RenderAsVar = "$RENDER_AS_VAR"
const RenderFlags_RenderAsObj = "$RENDER_AS_OBJ"
const RenderFlags_RenderAsAny = "$RENDER_AS_ANY"

func (*RenderFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: "render_flags",
		Uses: "str",
		Choices: []string{
			RenderFlags_RenderAsVar, RenderFlags_RenderAsObj, RenderFlags_RenderAsAny,
		},
		Strings: []string{
			"render_as_var", "render_as_obj", "render_as_any",
		},
	}
}

// RenderName handles changing a template like {.boombip} into text.,if the name is a variable containing an object name: return the printed object name ( via &quot;print name&quot; ),if the name is a variable with some other text: return that text.,if the name isn&#x27;t a variable but refers to some object: return that object&#x27;s printed object name.,otherwise, its an error.
type RenderName struct {
	Name string `if:"label=_,type=text"`
}

func (*RenderName) Compose() composer.Spec {
	return composer.Spec{
		Name: "render_name",
		Uses: "flow",
	}
}

func (op *RenderName) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "render_name",
			"value": map[string]json.RawMessage{
				"$NAME": jsonName,
			},
		})
	}
	return
}

func (op *RenderName) MarshalJSONName() ([]byte, error) {
	// type override
	m := value.Text{op.Name}
	return m.MarshalJSON()
}

// RenderPattern printing is generally an activity b/c say is an activity,and we want the ability to say several things in series.
type RenderPattern struct {
	Pattern   value.PatternName `if:"label=_"`
	Arguments core.CallArgs     `if:"label=args"`
}

func (*RenderPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: "render_pattern",
		Uses: "flow",
		Lede: "render",
	}
}

func (op *RenderPattern) MarshalJSON() (ret []byte, err error) {
	if jsonPattern, e := op.MarshalJSONPattern(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "render_pattern",
			"value": map[string]json.RawMessage{
				"$PATTERN":   jsonPattern,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *RenderPattern) MarshalJSONPattern() ([]byte, error) {
	return op.Pattern.MarshalJSON()
}

func (op *RenderPattern) MarshalJSONArguments() ([]byte, error) {
	return op.Arguments.MarshalJSON()
}

// RenderRef returns the value of a variable or the id of an object.
type RenderRef struct {
	Name  value.VariableName `if:"label=_"`
	Flags RenderFlags        `if:"label=flags"`
}

func (*RenderRef) Compose() composer.Spec {
	return composer.Spec{
		Name: "render_ref",
		Uses: "flow",
	}
}

func (op *RenderRef) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonFlags, e := op.MarshalJSONFlags(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "render_ref",
			"value": map[string]json.RawMessage{
				"$NAME":  jsonName,
				"$FLAGS": jsonFlags,
			},
		})
	}
	return
}

func (op *RenderRef) MarshalJSONName() ([]byte, error) {
	return op.Name.MarshalJSON()
}

func (op *RenderRef) MarshalJSONFlags() ([]byte, error) {
	return op.Flags.MarshalJSON()
}

var Slats = []composer.Composer{
	(*RenderExp)(nil),
	(*RenderField)(nil),
	(*RenderFlags)(nil),
	(*RenderName)(nil),
	(*RenderPattern)(nil),
	(*RenderRef)(nil),
}
