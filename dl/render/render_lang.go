// Code generated by "makeops"; edit at your own risk.
package render

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
)

// RenderExp
type RenderExp struct {
	Expression rt.TextEval `if:"label=_"`
}

func (*RenderExp) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RenderExp,
		Uses: "flow",
	}
}

var Type_RenderExp = "render_exp"

func (op *RenderExp) MarshalJSON() (ret []byte, err error) {
	if jsonExpression, e := op.MarshalJSONExpression(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RenderExp,
			Value: map[string]json.RawMessage{
				"$EXPRESSION": jsonExpression,
			},
		})
	}
	return
}

func (op *RenderExp) MarshalJSONExpression() (ret []byte, err error) {
	if v, e := op.Expression.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// RenderField in template phrases, picks between record variables, object variables, and named global objects.,ex. could be &quot;ringBearer&quot;, &quot;SamWise&quot;, or &quot;frodo&quot;
type RenderField struct {
	Name rt.TextEval `if:"label=_"`
}

func (*RenderField) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RenderField,
		Uses: "flow",
	}
}

var Type_RenderField = "render_field"

func (op *RenderField) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RenderField,
			Value: map[string]json.RawMessage{
				"$NAME": jsonName,
			},
		})
	}
	return
}

func (op *RenderField) MarshalJSONName() (ret []byte, err error) {
	if v, e := op.Name.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// RenderFlags requires a user-specified string.
type RenderFlags struct {
	Str string
}

func (op *RenderFlags) String() (ret string) {
	return op.Str
}

func (*RenderFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RenderFlags,
		Uses: "str",
		Choices: []string{
			RenderFlags_RenderAsVar, RenderFlags_RenderAsObj, RenderFlags_RenderAsAny,
		},
		Strings: []string{
			"render_as_var", "render_as_obj", "render_as_any",
		},
	}
}

var Type_RenderFlags = "render_flags"

func (op *RenderFlags) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_RenderFlags,
		Value: op.Str,
	})
}

func (op *RenderFlags) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const RenderFlags_RenderAsVar = "$RENDER_AS_VAR"
const RenderFlags_RenderAsObj = "$RENDER_AS_OBJ"
const RenderFlags_RenderAsAny = "$RENDER_AS_ANY"

// RenderName handles changing a template like {.boombip} into text.,if the name is a variable containing an object name: return the printed object name ( via &quot;print name&quot; ),if the name is a variable with some other text: return that text.,if the name isn&#x27;t a variable but refers to some object: return that object&#x27;s printed object name.,otherwise, its an error.
type RenderName struct {
	Name string `if:"label=_,type=text"`
}

func (*RenderName) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RenderName,
		Uses: "flow",
	}
}

var Type_RenderName = "render_name"

func (op *RenderName) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RenderName,
			Value: map[string]json.RawMessage{
				"$NAME": jsonName,
			},
		})
	}
	return
}

func (op *RenderName) MarshalJSONName() (ret []byte, err error) {
	// type override
	m := value.Text{op.Name}
	ret, err = m.MarshalJSON()
	return
}

// RenderPattern printing is generally an activity b/c say is an activity,and we want the ability to say several things in series.
type RenderPattern struct {
	Pattern   value.PatternName `if:"label=_"`
	Arguments core.CallArgs     `if:"label=args"`
}

func (*RenderPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RenderPattern,
		Uses: "flow",
		Lede: "render",
	}
}

var Type_RenderPattern = "render_pattern"

func (op *RenderPattern) MarshalJSON() (ret []byte, err error) {
	if jsonPattern, e := op.MarshalJSONPattern(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RenderPattern,
			Value: map[string]json.RawMessage{
				"$PATTERN":   jsonPattern,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *RenderPattern) MarshalJSONPattern() (ret []byte, err error) {
	ret, err = op.Pattern.MarshalJSON()
	return
}

func (op *RenderPattern) MarshalJSONArguments() (ret []byte, err error) {
	ret, err = op.Arguments.MarshalJSON()
	return
}

// RenderRef returns the value of a variable or the id of an object.
type RenderRef struct {
	Name  value.VariableName `if:"label=_"`
	Flags RenderFlags        `if:"label=flags"`
}

func (*RenderRef) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RenderRef,
		Uses: "flow",
	}
}

var Type_RenderRef = "render_ref"

func (op *RenderRef) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonFlags, e := op.MarshalJSONFlags(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RenderRef,
			Value: map[string]json.RawMessage{
				"$NAME":  jsonName,
				"$FLAGS": jsonFlags,
			},
		})
	}
	return
}

func (op *RenderRef) MarshalJSONName() (ret []byte, err error) {
	ret, err = op.Name.MarshalJSON()
	return
}

func (op *RenderRef) MarshalJSONFlags() (ret []byte, err error) {
	ret, err = op.Flags.MarshalJSON()
	return
}

var Slats = []composer.Composer{
	(*RenderExp)(nil),
	(*RenderField)(nil),
	(*RenderFlags)(nil),
	(*RenderName)(nil),
	(*RenderPattern)(nil),
	(*RenderRef)(nil),
}
