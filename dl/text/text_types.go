// Text manipulation and transformation.
package text

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// True if text contains text.
type Includes struct {
	Text   rtti.TextEval
	Part   rtti.TextEval
	Markup map[string]any
}

// includes, a type of flow.
var Zt_Includes typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Includes) TypeInfo() typeinfo.T {
	return &Zt_Includes
}

// Implements [typeinfo.Markup]
func (op *Includes) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Includes)(nil)

// Holds a slice of type Includes.
type Includes_Slice []Includes

// Implements [typeinfo.Instance] for a slice of Includes.
func (*Includes_Slice) TypeInfo() typeinfo.T {
	return &Zt_Includes
}

// Implements [typeinfo.Repeats] for a slice of Includes.
func (op *Includes_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if the text is empty.
type IsEmpty struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// is_empty, a type of flow.
var Zt_IsEmpty typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IsEmpty) TypeInfo() typeinfo.T {
	return &Zt_IsEmpty
}

// Implements [typeinfo.Markup]
func (op *IsEmpty) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*IsEmpty)(nil)

// Holds a slice of type IsEmpty.
type IsEmpty_Slice []IsEmpty

// Implements [typeinfo.Instance] for a slice of IsEmpty.
func (*IsEmpty_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsEmpty
}

// Implements [typeinfo.Repeats] for a slice of IsEmpty.
func (op *IsEmpty_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether the specified text is similar to the specified regular expression.
type Matches struct {
	Text   rtti.TextEval
	Match  string
	Cache  MatchCache
	Markup map[string]any
}

// matches, a type of flow.
var Zt_Matches typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Matches) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// Implements [typeinfo.Markup]
func (op *Matches) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Matches)(nil)

// Holds a slice of type Matches.
type Matches_Slice []Matches

// Implements [typeinfo.Instance] for a slice of Matches.
func (*Matches_Slice) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// Implements [typeinfo.Repeats] for a slice of Matches.
func (op *Matches_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return a copy of some text with its first letter changed to uppercase.
type Capitalize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// capitalize, a type of flow.
var Zt_Capitalize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Capitalize) TypeInfo() typeinfo.T {
	return &Zt_Capitalize
}

// Implements [typeinfo.Markup]
func (op *Capitalize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Capitalize)(nil)

// Holds a slice of type Capitalize.
type Capitalize_Slice []Capitalize

// Implements [typeinfo.Instance] for a slice of Capitalize.
func (*Capitalize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Capitalize
}

// Implements [typeinfo.Repeats] for a slice of Capitalize.
func (op *Capitalize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns multiple pieces of text as a single new piece of text.
type Join struct {
	Sep    rtti.TextEval
	Parts  []rtti.TextEval
	Markup map[string]any
}

// join, a type of flow.
var Zt_Join typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Join) TypeInfo() typeinfo.T {
	return &Zt_Join
}

// Implements [typeinfo.Markup]
func (op *Join) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Join)(nil)

// Holds a slice of type Join.
type Join_Slice []Join

// Implements [typeinfo.Instance] for a slice of Join.
func (*Join_Slice) TypeInfo() typeinfo.T {
	return &Zt_Join
}

// Implements [typeinfo.Repeats] for a slice of Join.
func (op *Join_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, with every letter turned into lowercase. For example, 'shout' from 'SHOUT'.
type MakeLowercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_lowercase, a type of flow.
var Zt_MakeLowercase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeLowercase) TypeInfo() typeinfo.T {
	return &Zt_MakeLowercase
}

// Implements [typeinfo.Markup]
func (op *MakeLowercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeLowercase)(nil)

// Holds a slice of type MakeLowercase.
type MakeLowercase_Slice []MakeLowercase

// Implements [typeinfo.Instance] for a slice of MakeLowercase.
func (*MakeLowercase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeLowercase
}

// Implements [typeinfo.Repeats] for a slice of MakeLowercase.
func (op *MakeLowercase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text flipped back to front. For example, 'elppA' from 'Apple', or 'noon' from 'noon'.
type MakeReversed struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_reversed, a type of flow.
var Zt_MakeReversed typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeReversed) TypeInfo() typeinfo.T {
	return &Zt_MakeReversed
}

// Implements [typeinfo.Markup]
func (op *MakeReversed) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeReversed)(nil)

// Holds a slice of type MakeReversed.
type MakeReversed_Slice []MakeReversed

// Implements [typeinfo.Instance] for a slice of MakeReversed.
func (*MakeReversed_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeReversed
}

// Implements [typeinfo.Repeats] for a slice of MakeReversed.
func (op *MakeReversed_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, start each sentence with a capital letter. For example, 'Empire Apple.' from 'Empire apple.'.
type MakeSentenceCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_sentence_case, a type of flow.
var Zt_MakeSentenceCase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeSentenceCase) TypeInfo() typeinfo.T {
	return &Zt_MakeSentenceCase
}

// Implements [typeinfo.Markup]
func (op *MakeSentenceCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeSentenceCase)(nil)

// Holds a slice of type MakeSentenceCase.
type MakeSentenceCase_Slice []MakeSentenceCase

// Implements [typeinfo.Instance] for a slice of MakeSentenceCase.
func (*MakeSentenceCase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeSentenceCase
}

// Implements [typeinfo.Repeats] for a slice of MakeSentenceCase.
func (op *MakeSentenceCase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, starting each word with a capital letter. For example, 'Empire Apple' from 'empire apple'.
type MakeTitleCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_title_case, a type of flow.
var Zt_MakeTitleCase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeTitleCase) TypeInfo() typeinfo.T {
	return &Zt_MakeTitleCase
}

// Implements [typeinfo.Markup]
func (op *MakeTitleCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeTitleCase)(nil)

// Holds a slice of type MakeTitleCase.
type MakeTitleCase_Slice []MakeTitleCase

// Implements [typeinfo.Instance] for a slice of MakeTitleCase.
func (*MakeTitleCase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeTitleCase
}

// Implements [typeinfo.Repeats] for a slice of MakeTitleCase.
func (op *MakeTitleCase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, with every letter turned into uppercase. For example, 'APPLE' from 'apple'.
type MakeUppercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_uppercase, a type of flow.
var Zt_MakeUppercase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeUppercase) TypeInfo() typeinfo.T {
	return &Zt_MakeUppercase
}

// Implements [typeinfo.Markup]
func (op *MakeUppercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeUppercase)(nil)

// Holds a slice of type MakeUppercase.
type MakeUppercase_Slice []MakeUppercase

// Implements [typeinfo.Instance] for a slice of MakeUppercase.
func (*MakeUppercase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeUppercase
}

// Implements [typeinfo.Repeats] for a slice of MakeUppercase.
func (op *MakeUppercase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the plural form of a singular word. (ex. apples for apple. ).
type Pluralize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// pluralize, a type of flow.
var Zt_Pluralize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Pluralize) TypeInfo() typeinfo.T {
	return &Zt_Pluralize
}

// Implements [typeinfo.Markup]
func (op *Pluralize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Pluralize)(nil)

// Holds a slice of type Pluralize.
type Pluralize_Slice []Pluralize

// Implements [typeinfo.Instance] for a slice of Pluralize.
func (*Pluralize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Pluralize
}

// Implements [typeinfo.Repeats] for a slice of Pluralize.
func (op *Pluralize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the singular form of a plural word. (ex. apple for apples ).
type Singularize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// singularize, a type of flow.
var Zt_Singularize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Singularize) TypeInfo() typeinfo.T {
	return &Zt_Singularize
}

// Implements [typeinfo.Markup]
func (op *Singularize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Singularize)(nil)

// Holds a slice of type Singularize.
type Singularize_Slice []Singularize

// Implements [typeinfo.Instance] for a slice of Singularize.
func (*Singularize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Singularize
}

// Implements [typeinfo.Repeats] for a slice of Singularize.
func (op *Singularize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes a number using numerals, eg. '1'.
type PrintNum struct {
	Num    rtti.NumEval
	Markup map[string]any
}

// print_num, a type of flow.
var Zt_PrintNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintNum) TypeInfo() typeinfo.T {
	return &Zt_PrintNum
}

// Implements [typeinfo.Markup]
func (op *PrintNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintNum)(nil)

// Holds a slice of type PrintNum.
type PrintNum_Slice []PrintNum

// Implements [typeinfo.Instance] for a slice of PrintNum.
func (*PrintNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintNum
}

// Implements [typeinfo.Repeats] for a slice of PrintNum.
func (op *PrintNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes a number in plain english: eg. 'one'.
type PrintNumWord struct {
	Num    rtti.NumEval
	Markup map[string]any
}

// print_num_word, a type of flow.
var Zt_PrintNumWord typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintNumWord) TypeInfo() typeinfo.T {
	return &Zt_PrintNumWord
}

// Implements [typeinfo.Markup]
func (op *PrintNumWord) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintNumWord)(nil)

// Holds a slice of type PrintNumWord.
type PrintNumWord_Slice []PrintNumWord

// Implements [typeinfo.Instance] for a slice of PrintNumWord.
func (*PrintNumWord_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintNumWord
}

// Implements [typeinfo.Repeats] for a slice of PrintNumWord.
func (op *PrintNumWord_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Includes = typeinfo.Flow{
		Name: "includes",
		Lede: "contains",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "part",
			Label: "part",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if text contains text.",
		},
	}
	Zt_IsEmpty = typeinfo.Flow{
		Name: "is_empty",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "empty",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if the text is empty.",
		},
	}
	Zt_Matches = typeinfo.Flow{
		Name: "matches",
		Lede: "matches",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "match",
			Label: "to",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "cache",
			Label:   "cache",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Determine whether the specified text is similar to the specified regular expression.",
		},
	}
	Zt_Capitalize = typeinfo.Flow{
		Name: "capitalize",
		Lede: "capitalize",
		Terms: []typeinfo.Term{{
			Name: "text",
			Markup: map[string]any{
				"comment": "The text to capitalize.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Return a copy of some text with its first letter changed to uppercase.",
		},
	}
	Zt_Join = typeinfo.Flow{
		Name: "join",
		Lede: "join",
		Terms: []typeinfo.Term{{
			Name:     "sep",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "parts",
			Label:   "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns multiple pieces of text as a single new piece of text.",
		},
	}
	Zt_MakeLowercase = typeinfo.Flow{
		Name: "make_lowercase",
		Lede: "lower",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, with every letter turned into lowercase. For example, 'shout' from 'SHOUT'.",
		},
	}
	Zt_MakeReversed = typeinfo.Flow{
		Name: "make_reversed",
		Lede: "reverse",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text flipped back to front. For example, 'elppA' from 'Apple', or 'noon' from 'noon'.",
		},
	}
	Zt_MakeSentenceCase = typeinfo.Flow{
		Name: "make_sentence_case",
		Lede: "sentence",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, start each sentence with a capital letter. For example, 'Empire Apple.' from 'Empire apple.'.",
		},
	}
	Zt_MakeTitleCase = typeinfo.Flow{
		Name: "make_title_case",
		Lede: "title",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, starting each word with a capital letter. For example, 'Empire Apple' from 'empire apple'.",
		},
	}
	Zt_MakeUppercase = typeinfo.Flow{
		Name: "make_uppercase",
		Lede: "upper",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, with every letter turned into uppercase. For example, 'APPLE' from 'apple'.",
		},
	}
	Zt_Pluralize = typeinfo.Flow{
		Name: "pluralize",
		Lede: "plural",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns the plural form of a singular word. (ex. apples for apple. ).",
		},
	}
	Zt_Singularize = typeinfo.Flow{
		Name: "singularize",
		Lede: "singular",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns the singular form of a plural word. (ex. apple for apples ).",
		},
	}
	Zt_PrintNum = typeinfo.Flow{
		Name: "print_num",
		Lede: "numeral",
		Terms: []typeinfo.Term{{
			Name: "num",
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes a number using numerals, eg. '1'.",
		},
	}
	Zt_PrintNumWord = typeinfo.Flow{
		Name: "print_num_word",
		Lede: "numeral",
		Terms: []typeinfo.Term{{
			Name:  "num",
			Label: "words",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes a number in plain english: eg. 'one'.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "text",
	Comment: []string{
		"Text manipulation and transformation.",
	},

	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Includes,
	&Zt_IsEmpty,
	&Zt_Matches,
	&Zt_Capitalize,
	&Zt_Join,
	&Zt_MakeLowercase,
	&Zt_MakeReversed,
	&Zt_MakeSentenceCase,
	&Zt_MakeTitleCase,
	&Zt_MakeUppercase,
	&Zt_Pluralize,
	&Zt_Singularize,
	&Zt_PrintNum,
	&Zt_PrintNumWord,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	8695677004499439692:  (*Capitalize)(nil),       /* text_eval=Capitalize: */
	3601423820955950769:  (*Includes)(nil),         /* bool_eval=Contains:part: */
	10867951538760575464: (*IsEmpty)(nil),          /* bool_eval=Is empty: */
	10106284345457008764: (*Join)(nil),             /* text_eval=Join parts: */
	16037301925772243654: (*Join)(nil),             /* text_eval=Join:parts: */
	11334467785012784241: (*MakeLowercase)(nil),    /* text_eval=Lower: */
	7007374677444567783:  (*Matches)(nil),          /* bool_eval=Matches:to: */
	18009133328614046007: (*PrintNumWord)(nil),     /* text_eval=Numeral words: */
	5709077775967698380:  (*PrintNum)(nil),         /* text_eval=Numeral: */
	11420921600352749983: (*Pluralize)(nil),        /* text_eval=Plural of: */
	12963686195606417453: (*MakeReversed)(nil),     /* text_eval=Reverse text: */
	10747671703915852065: (*MakeSentenceCase)(nil), /* text_eval=Sentence: */
	2397382738676796596:  (*Singularize)(nil),      /* text_eval=Singular of: */
	10878271994667616824: (*MakeTitleCase)(nil),    /* text_eval=Title: */
	5481656653805454214:  (*MakeUppercase)(nil),    /* text_eval=Upper: */
}
