// Text manipulation and transformation.
package text

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// Determine whether some piece of text can be found in another.
type FindText struct {
	Text    rtti.TextEval
	Subtext rtti.TextEval
	Markup  map[string]any
}

// find_text, a type of flow.
var Zt_FindText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*FindText) TypeInfo() typeinfo.T {
	return &Zt_FindText
}

// Implements [typeinfo.Markup]
func (op *FindText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*FindText)(nil)
var _ rtti.NumEval = (*FindText)(nil)

// Holds a slice of type FindText.
type FindText_Slice []FindText

// Implements [typeinfo.Instance] for a slice of FindText.
func (*FindText_Slice) TypeInfo() typeinfo.T {
	return &Zt_FindText
}

// Implements [typeinfo.Repeats] for a slice of FindText.
func (op *FindText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether some piece of text starts with another.
type TextStartsWith struct {
	Text    rtti.TextEval
	Subtext rtti.TextEval
	Markup  map[string]any
}

// text_starts_with, a type of flow.
var Zt_TextStartsWith typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TextStartsWith) TypeInfo() typeinfo.T {
	return &Zt_TextStartsWith
}

// Implements [typeinfo.Markup]
func (op *TextStartsWith) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*TextStartsWith)(nil)

// Holds a slice of type TextStartsWith.
type TextStartsWith_Slice []TextStartsWith

// Implements [typeinfo.Instance] for a slice of TextStartsWith.
func (*TextStartsWith_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextStartsWith
}

// Implements [typeinfo.Repeats] for a slice of TextStartsWith.
func (op *TextStartsWith_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether some piece of text ends with another.
type TextEndsWith struct {
	Text    rtti.TextEval
	Subtext rtti.TextEval
	Markup  map[string]any
}

// text_ends_with, a type of flow.
var Zt_TextEndsWith typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TextEndsWith) TypeInfo() typeinfo.T {
	return &Zt_TextEndsWith
}

// Implements [typeinfo.Markup]
func (op *TextEndsWith) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*TextEndsWith)(nil)

// Holds a slice of type TextEndsWith.
type TextEndsWith_Slice []TextEndsWith

// Implements [typeinfo.Instance] for a slice of TextEndsWith.
func (*TextEndsWith_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextEndsWith
}

// Implements [typeinfo.Repeats] for a slice of TextEndsWith.
func (op *TextEndsWith_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether some text is completely without content.
// Even spaces are considered content. The text "" is considered empty,
// the text " " is considered *not* empty.
type IsEmpty struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// is_empty, a type of flow.
var Zt_IsEmpty typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IsEmpty) TypeInfo() typeinfo.T {
	return &Zt_IsEmpty
}

// Implements [typeinfo.Markup]
func (op *IsEmpty) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*IsEmpty)(nil)

// Holds a slice of type IsEmpty.
type IsEmpty_Slice []IsEmpty

// Implements [typeinfo.Instance] for a slice of IsEmpty.
func (*IsEmpty_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsEmpty
}

// Implements [typeinfo.Repeats] for a slice of IsEmpty.
func (op *IsEmpty_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether the some text matches a regular expression.
type Matches struct {
	Text   rtti.TextEval
	Match  string
	Cache  MatchCache
	Markup map[string]any
}

// matches, a type of flow.
var Zt_Matches typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Matches) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// Implements [typeinfo.Markup]
func (op *Matches) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Matches)(nil)

// Holds a slice of type Matches.
type Matches_Slice []Matches

// Implements [typeinfo.Instance] for a slice of Matches.
func (*Matches_Slice) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// Implements [typeinfo.Repeats] for a slice of Matches.
func (op *Matches_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return a copy of some text with its first letter changed to uppercase.
type Capitalize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// capitalize, a type of flow.
var Zt_Capitalize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Capitalize) TypeInfo() typeinfo.T {
	return &Zt_Capitalize
}

// Implements [typeinfo.Markup]
func (op *Capitalize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Capitalize)(nil)

// Holds a slice of type Capitalize.
type Capitalize_Slice []Capitalize

// Implements [typeinfo.Instance] for a slice of Capitalize.
func (*Capitalize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Capitalize
}

// Implements [typeinfo.Repeats] for a slice of Capitalize.
func (op *Capitalize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return multiple pieces of text as a single new piece of text.
type Join struct {
	Sep    rtti.TextEval
	Parts  []rtti.TextEval
	Markup map[string]any
}

// join, a type of flow.
var Zt_Join typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Join) TypeInfo() typeinfo.T {
	return &Zt_Join
}

// Implements [typeinfo.Markup]
func (op *Join) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Join)(nil)

// Holds a slice of type Join.
type Join_Slice []Join

// Implements [typeinfo.Instance] for a slice of Join.
func (*Join_Slice) TypeInfo() typeinfo.T {
	return &Zt_Join
}

// Implements [typeinfo.Repeats] for a slice of Join.
func (op *Join_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return some new text with every letter of the specified text turned into lowercase.
// For example, turns "QUIET" into "quiet.
type MakeLowercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_lowercase, a type of flow.
var Zt_MakeLowercase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeLowercase) TypeInfo() typeinfo.T {
	return &Zt_MakeLowercase
}

// Implements [typeinfo.Markup]
func (op *MakeLowercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeLowercase)(nil)

// Holds a slice of type MakeLowercase.
type MakeLowercase_Slice []MakeLowercase

// Implements [typeinfo.Instance] for a slice of MakeLowercase.
func (*MakeLowercase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeLowercase
}

// Implements [typeinfo.Repeats] for a slice of MakeLowercase.
func (op *MakeLowercase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return some new text with the contents of the specified text flipped back to front.
// For example, turns "Tapestry" into 'yrtsepaT'.
type MakeReversed struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_reversed, a type of flow.
var Zt_MakeReversed typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeReversed) TypeInfo() typeinfo.T {
	return &Zt_MakeReversed
}

// Implements [typeinfo.Markup]
func (op *MakeReversed) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeReversed)(nil)

// Holds a slice of type MakeReversed.
type MakeReversed_Slice []MakeReversed

// Implements [typeinfo.Instance] for a slice of MakeReversed.
func (*MakeReversed_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeReversed
}

// Implements [typeinfo.Repeats] for a slice of MakeReversed.
func (op *MakeReversed_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return some new text with each sentence of the specified text transformed so that it starts with a capital letter.
// For example, "see the doctor run. run doctor. run." into "See the doctor run. Run doctor. Run."
type MakeSentenceCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_sentence_case, a type of flow.
var Zt_MakeSentenceCase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeSentenceCase) TypeInfo() typeinfo.T {
	return &Zt_MakeSentenceCase
}

// Implements [typeinfo.Markup]
func (op *MakeSentenceCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeSentenceCase)(nil)

// Holds a slice of type MakeSentenceCase.
type MakeSentenceCase_Slice []MakeSentenceCase

// Implements [typeinfo.Instance] for a slice of MakeSentenceCase.
func (*MakeSentenceCase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeSentenceCase
}

// Implements [typeinfo.Repeats] for a slice of MakeSentenceCase.
func (op *MakeSentenceCase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return some new text starting each word of the specified text with a capital letter.
// For example, turns "empire apple" into "Empire Apple".
type MakeTitleCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_title_case, a type of flow.
var Zt_MakeTitleCase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeTitleCase) TypeInfo() typeinfo.T {
	return &Zt_MakeTitleCase
}

// Implements [typeinfo.Markup]
func (op *MakeTitleCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeTitleCase)(nil)

// Holds a slice of type MakeTitleCase.
type MakeTitleCase_Slice []MakeTitleCase

// Implements [typeinfo.Instance] for a slice of MakeTitleCase.
func (*MakeTitleCase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeTitleCase
}

// Implements [typeinfo.Repeats] for a slice of MakeTitleCase.
func (op *MakeTitleCase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return some new text with every letter of the specified turned into uppercase. For example, transforms "loud" into "LOUD".
type MakeUppercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_uppercase, a type of flow.
var Zt_MakeUppercase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeUppercase) TypeInfo() typeinfo.T {
	return &Zt_MakeUppercase
}

// Implements [typeinfo.Markup]
func (op *MakeUppercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeUppercase)(nil)

// Holds a slice of type MakeUppercase.
type MakeUppercase_Slice []MakeUppercase

// Implements [typeinfo.Instance] for a slice of MakeUppercase.
func (*MakeUppercase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeUppercase
}

// Implements [typeinfo.Repeats] for a slice of MakeUppercase.
func (op *MakeUppercase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return the plural form of a singular word.
// For example, given the word "apple", return "apples".
type Pluralize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// pluralize, a type of flow.
var Zt_Pluralize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Pluralize) TypeInfo() typeinfo.T {
	return &Zt_Pluralize
}

// Implements [typeinfo.Markup]
func (op *Pluralize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Pluralize)(nil)

// Holds a slice of type Pluralize.
type Pluralize_Slice []Pluralize

// Implements [typeinfo.Instance] for a slice of Pluralize.
func (*Pluralize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Pluralize
}

// Implements [typeinfo.Repeats] for a slice of Pluralize.
func (op *Pluralize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return the singular form of a plural word.
// For example, given the word "apples", return "apple".
type Singularize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// singularize, a type of flow.
var Zt_Singularize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Singularize) TypeInfo() typeinfo.T {
	return &Zt_Singularize
}

// Implements [typeinfo.Markup]
func (op *Singularize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Singularize)(nil)

// Holds a slice of type Singularize.
type Singularize_Slice []Singularize

// Implements [typeinfo.Instance] for a slice of Singularize.
func (*Singularize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Singularize
}

// Implements [typeinfo.Repeats] for a slice of Singularize.
func (op *Singularize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes a number using numerals.
// For example, '1'.
type PrintNum struct {
	Num    rtti.NumEval
	Markup map[string]any
}

// print_num, a type of flow.
var Zt_PrintNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintNum) TypeInfo() typeinfo.T {
	return &Zt_PrintNum
}

// Implements [typeinfo.Markup]
func (op *PrintNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintNum)(nil)

// Holds a slice of type PrintNum.
type PrintNum_Slice []PrintNum

// Implements [typeinfo.Instance] for a slice of PrintNum.
func (*PrintNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintNum
}

// Implements [typeinfo.Repeats] for a slice of PrintNum.
func (op *PrintNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes a number in plain english.
// For example, 'one'.
type PrintNumWord struct {
	Num    rtti.NumEval
	Markup map[string]any
}

// print_num_word, a type of flow.
var Zt_PrintNumWord typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintNumWord) TypeInfo() typeinfo.T {
	return &Zt_PrintNumWord
}

// Implements [typeinfo.Markup]
func (op *PrintNumWord) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintNumWord)(nil)

// Holds a slice of type PrintNumWord.
type PrintNumWord_Slice []PrintNumWord

// Implements [typeinfo.Instance] for a slice of PrintNumWord.
func (*PrintNumWord_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintNumWord
}

// Implements [typeinfo.Repeats] for a slice of PrintNumWord.
func (op *PrintNumWord_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_FindText = typeinfo.Flow{
		Name: "find_text",
		Lede: "find",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "in",
			Markup: map[string]any{
				"comment": "The text to search within.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "subtext",
			Label: "text",
			Markup: map[string]any{
				"comment": "The text to find.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Determine whether some piece of text can be found in another.",
		},
	}
	Zt_TextStartsWith = typeinfo.Flow{
		Name: "text_starts_with",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Markup: map[string]any{
				"comment": "The text to search within.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "subtext",
			Label: "prefix",
			Markup: map[string]any{
				"comment": "The text to find.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Determine whether some piece of text starts with another.",
		},
	}
	Zt_TextEndsWith = typeinfo.Flow{
		Name: "text_ends_with",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Markup: map[string]any{
				"comment": "The text to search within.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "subtext",
			Label: "suffix",
			Markup: map[string]any{
				"comment": "The text to find.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Determine whether some piece of text ends with another.",
		},
	}
	Zt_IsEmpty = typeinfo.Flow{
		Name: "is_empty",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "empty",
			Markup: map[string]any{
				"comment": "The text to check for content.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Determine whether some text is completely without content.", "Even spaces are considered content. The text \"\" is considered empty,", "the text \" \" is considered *not* empty."},
		},
	}
	Zt_Matches = typeinfo.Flow{
		Name: "matches",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Markup: map[string]any{
				"comment": "The text to match the expression against.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "match",
			Label: "expression",
			Markup: map[string]any{
				"comment": "The expression to match against the text.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "cache",
			Label:   "cache",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Determine whether the some text matches a regular expression.",
		},
	}
	Zt_Capitalize = typeinfo.Flow{
		Name: "capitalize",
		Lede: "capitalize",
		Terms: []typeinfo.Term{{
			Name: "text",
			Markup: map[string]any{
				"comment": "The text to capitalize.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Return a copy of some text with its first letter changed to uppercase.",
		},
	}
	Zt_Join = typeinfo.Flow{
		Name: "join",
		Lede: "join",
		Terms: []typeinfo.Term{{
			Name:     "sep",
			Optional: true,
			Markup: map[string]any{
				"comment": "Optionally, a separator to put between each piece of text.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "parts",
			Label:   "parts",
			Repeats: true,
			Markup: map[string]any{
				"comment": "The text values to concatenate.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Return multiple pieces of text as a single new piece of text.",
		},
	}
	Zt_MakeLowercase = typeinfo.Flow{
		Name: "make_lowercase",
		Lede: "lower",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Return some new text with every letter of the specified text turned into lowercase.", "For example, turns \"QUIET\" into \"quiet."},
		},
	}
	Zt_MakeReversed = typeinfo.Flow{
		Name: "make_reversed",
		Lede: "reverse",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Return some new text with the contents of the specified text flipped back to front.", "For example, turns \"Tapestry\" into 'yrtsepaT'."},
		},
	}
	Zt_MakeSentenceCase = typeinfo.Flow{
		Name: "make_sentence_case",
		Lede: "sentence",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Return some new text with each sentence of the specified text transformed so that it starts with a capital letter.", "For example, \"see the doctor run. run doctor. run.\" into \"See the doctor run. Run doctor. Run.\""},
		},
	}
	Zt_MakeTitleCase = typeinfo.Flow{
		Name: "make_title_case",
		Lede: "title",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Return some new text starting each word of the specified text with a capital letter.", "For example, turns \"empire apple\" into \"Empire Apple\"."},
		},
	}
	Zt_MakeUppercase = typeinfo.Flow{
		Name: "make_uppercase",
		Lede: "upper",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Return some new text with every letter of the specified turned into uppercase. For example, transforms \"loud\" into \"LOUD\".",
		},
	}
	Zt_Pluralize = typeinfo.Flow{
		Name: "pluralize",
		Lede: "plural",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Return the plural form of a singular word.", "For example, given the word \"apple\", return \"apples\"."},
		},
	}
	Zt_Singularize = typeinfo.Flow{
		Name: "singularize",
		Lede: "singular",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Return the singular form of a plural word.", "For example, given the word \"apples\", return \"apple\"."},
		},
	}
	Zt_PrintNum = typeinfo.Flow{
		Name: "print_num",
		Lede: "numeral",
		Terms: []typeinfo.Term{{
			Name: "num",
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Writes a number using numerals.", "For example, '1'."},
		},
	}
	Zt_PrintNumWord = typeinfo.Flow{
		Name: "print_num_word",
		Lede: "numeral",
		Terms: []typeinfo.Term{{
			Name:  "num",
			Label: "words",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Writes a number in plain english.", "For example, 'one'."},
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "text",
	Comment: []string{
		"Text manipulation and transformation.",
	},

	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_FindText,
	&Zt_TextStartsWith,
	&Zt_TextEndsWith,
	&Zt_IsEmpty,
	&Zt_Matches,
	&Zt_Capitalize,
	&Zt_Join,
	&Zt_MakeLowercase,
	&Zt_MakeReversed,
	&Zt_MakeSentenceCase,
	&Zt_MakeTitleCase,
	&Zt_MakeUppercase,
	&Zt_Pluralize,
	&Zt_Singularize,
	&Zt_PrintNum,
	&Zt_PrintNumWord,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	8695677004499439692:  (*Capitalize)(nil),       /* text_eval=Capitalize: */
	12607894193114927890: (*FindText)(nil),         /* bool_eval=Find in:text: */
	16244114700846560048: (*FindText)(nil),         /* num_eval=Find in:text: */
	10867951538760575464: (*IsEmpty)(nil),          /* bool_eval=Is empty: */
	6139101839500298168:  (*Matches)(nil),          /* bool_eval=Is text:expression: */
	43416298232103202:    (*TextStartsWith)(nil),   /* bool_eval=Is text:prefix: */
	14194170362800670601: (*TextEndsWith)(nil),     /* bool_eval=Is text:suffix: */
	10106284345457008764: (*Join)(nil),             /* text_eval=Join parts: */
	16037301925772243654: (*Join)(nil),             /* text_eval=Join:parts: */
	11334467785012784241: (*MakeLowercase)(nil),    /* text_eval=Lower: */
	18009133328614046007: (*PrintNumWord)(nil),     /* text_eval=Numeral words: */
	5709077775967698380:  (*PrintNum)(nil),         /* text_eval=Numeral: */
	11420921600352749983: (*Pluralize)(nil),        /* text_eval=Plural of: */
	12963686195606417453: (*MakeReversed)(nil),     /* text_eval=Reverse text: */
	10747671703915852065: (*MakeSentenceCase)(nil), /* text_eval=Sentence: */
	2397382738676796596:  (*Singularize)(nil),      /* text_eval=Singular of: */
	10878271994667616824: (*MakeTitleCase)(nil),    /* text_eval=Title: */
	5481656653805454214:  (*MakeUppercase)(nil),    /* text_eval=Upper: */
}
