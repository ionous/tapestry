// Code generated by Tapestry; edit at your own risk.
package core

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// brancher, a type of slot.
const Z_Brancher_Type = "brancher"

var Z_Brancher_Info = typeinfo.Slot{
	Name: Z_Brancher_Type,
	Markup: map[string]any{
		"comment": "Helper for choose action.",
	},
}

// holds a single slot
// FIX: currently provided by the spec
type FIX_Brancher_Slot struct{ Value Brancher }

// implements typeinfo.Inspector for a single slot.
func (*Brancher_Slot) Inspect() typeinfo.T {
	return &Z_Brancher_Info
}

// holds a slice of slots
type Brancher_Slots []Brancher

// implements typeinfo.Inspector for a series of slots.
func (*Brancher_Slots) Inspect() typeinfo.T {
	return &Z_Brancher_Info
}

// trigger, a type of slot.
const Z_Trigger_Type = "trigger"

var Z_Trigger_Info = typeinfo.Slot{
	Name: Z_Trigger_Type,
	Markup: map[string]any{
		"comment": "Helper for counting values.",
	},
}

// holds a single slot
// FIX: currently provided by the spec
type FIX_Trigger_Slot struct{ Value Trigger }

// implements typeinfo.Inspector for a single slot.
func (*Trigger_Slot) Inspect() typeinfo.T {
	return &Z_Trigger_Info
}

// holds a slice of slots
type Trigger_Slots []Trigger

// implements typeinfo.Inspector for a series of slots.
func (*Trigger_Slots) Inspect() typeinfo.T {
	return &Z_Trigger_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AllTrue struct {
	Test   rti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AllTrue) Inspect() typeinfo.T {
	return &Z_AllTrue_Info
}

// return a valid markup map, creating it if necessary.
func (op *AllTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// all_true, a type of flow.
const Z_AllTrue_Type = "all_true"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*AllTrue)(nil)

var Z_AllTrue_Info = typeinfo.Flow{
	Name: Z_AllTrue_Type,
	Lede: "all_true",
	Terms: []typeinfo.Term{{
		Name:    "test",
		Label:   "_",
		Repeats: true,
		Type:    &rti.Z_BoolEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns true if all of the evaluations are true.",
	},
}

// holds a slice of type all_true
// FIX: duplicates the spec decl.
type FIX_AllTrue_Slice []AllTrue

// implements typeinfo.Inspector
func (*AllTrue_Slice) Inspect() typeinfo.T {
	return &Z_AllTrue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Always struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Always) Inspect() typeinfo.T {
	return &Z_Always_Info
}

// return a valid markup map, creating it if necessary.
func (op *Always) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// always, a type of flow.
const Z_Always_Type = "always"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*Always)(nil)

var Z_Always_Info = typeinfo.Flow{
	Name:  Z_Always_Type,
	Lede:  "always",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns true.",
	},
}

// holds a slice of type always
// FIX: duplicates the spec decl.
type FIX_Always_Slice []Always

// implements typeinfo.Inspector
func (*Always_Slice) Inspect() typeinfo.T {
	return &Z_Always_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AnyTrue struct {
	Test   rti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AnyTrue) Inspect() typeinfo.T {
	return &Z_AnyTrue_Info
}

// return a valid markup map, creating it if necessary.
func (op *AnyTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// any_true, a type of flow.
const Z_AnyTrue_Type = "any_true"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*AnyTrue)(nil)

var Z_AnyTrue_Info = typeinfo.Flow{
	Name: Z_AnyTrue_Type,
	Lede: "any_true",
	Terms: []typeinfo.Term{{
		Name:    "test",
		Label:   "_",
		Repeats: true,
		Type:    &rti.Z_BoolEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns true if any of the evaluations are true.",
	},
}

// holds a slice of type any_true
// FIX: duplicates the spec decl.
type FIX_AnyTrue_Slice []AnyTrue

// implements typeinfo.Inspector
func (*AnyTrue_Slice) Inspect() typeinfo.T {
	return &Z_AnyTrue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Blankline struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Blankline) Inspect() typeinfo.T {
	return &Z_Blankline_Info
}

// return a valid markup map, creating it if necessary.
func (op *Blankline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// blankline, a type of flow.
const Z_Blankline_Type = "blankline"

// ensure the command implements its specified slots:
var _ rti.Execute = (*Blankline)(nil)

var Z_Blankline_Info = typeinfo.Flow{
	Name:  Z_Blankline_Type,
	Lede:  "p",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": "Add a single blank line following some text.",
	},
}

// holds a slice of type blankline
// FIX: duplicates the spec decl.
type FIX_Blankline_Slice []Blankline

// implements typeinfo.Inspector
func (*Blankline_Slice) Inspect() typeinfo.T {
	return &Z_Blankline_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_BracketText struct {
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*BracketText) Inspect() typeinfo.T {
	return &Z_BracketText_Info
}

// return a valid markup map, creating it if necessary.
func (op *BracketText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// bracket_text, a type of flow.
const Z_BracketText_Type = "bracket_text"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*BracketText)(nil)

var Z_BracketText_Info = typeinfo.Flow{
	Name: Z_BracketText_Type,
	Lede: "brackets",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Sandwiches text printed during a block and puts them inside parenthesis '()'.",
	},
}

// holds a slice of type bracket_text
// FIX: duplicates the spec decl.
type FIX_BracketText_Slice []BracketText

// implements typeinfo.Inspector
func (*BracketText_Slice) Inspect() typeinfo.T {
	return &Z_BracketText_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Break struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Break) Inspect() typeinfo.T {
	return &Z_Break_Info
}

// return a valid markup map, creating it if necessary.
func (op *Break) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// break, a type of flow.
const Z_Break_Type = "break"

// ensure the command implements its specified slots:
var _ rti.Execute = (*Break)(nil)

var Z_Break_Info = typeinfo.Flow{
	Name:  Z_Break_Type,
	Lede:  "break",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": []interface{}{"In a repeating loop, exit the loop;", "or, in a rule, stop processing rules."},
	},
}

// holds a slice of type break
// FIX: duplicates the spec decl.
type FIX_Break_Slice []Break

// implements typeinfo.Inspector
func (*Break_Slice) Inspect() typeinfo.T {
	return &Z_Break_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_BufferText struct {
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*BufferText) Inspect() typeinfo.T {
	return &Z_BufferText_Info
}

// return a valid markup map, creating it if necessary.
func (op *BufferText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// buffer_text, a type of flow.
const Z_BufferText_Type = "buffer_text"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*BufferText)(nil)

var Z_BufferText_Info = typeinfo.Flow{
	Name: Z_BufferText_Type,
	Lede: "buffers",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
}

// holds a slice of type buffer_text
// FIX: duplicates the spec decl.
type FIX_BufferText_Slice []BufferText

// implements typeinfo.Inspector
func (*BufferText_Slice) Inspect() typeinfo.T {
	return &Z_BufferText_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallCycle struct {
	Name   string
	Parts  rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CallCycle) Inspect() typeinfo.T {
	return &Z_CallCycle_Info
}

// return a valid markup map, creating it if necessary.
func (op *CallCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// call_cycle, a type of flow.
const Z_CallCycle_Type = "call_cycle"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*CallCycle)(nil)

var Z_CallCycle_Info = typeinfo.Flow{
	Name: Z_CallCycle_Type,
	Lede: "cycle",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:    "parts",
		Label:   "over",
		Repeats: true,
		Type:    &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Runtime version of cycle_text.",
	},
}

// holds a slice of type call_cycle
// FIX: duplicates the spec decl.
type FIX_CallCycle_Slice []CallCycle

// implements typeinfo.Inspector
func (*CallCycle_Slice) Inspect() typeinfo.T {
	return &Z_CallCycle_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallShuffle struct {
	Name    string
	Parts   rti.TextEval
	Indices Shuffler
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*CallShuffle) Inspect() typeinfo.T {
	return &Z_CallShuffle_Info
}

// return a valid markup map, creating it if necessary.
func (op *CallShuffle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// call_shuffle, a type of flow.
const Z_CallShuffle_Type = "call_shuffle"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*CallShuffle)(nil)

var Z_CallShuffle_Info = typeinfo.Flow{
	Name: Z_CallShuffle_Type,
	Lede: "shuffle",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:    "parts",
		Label:   "over",
		Repeats: true,
		Type:    &rti.Z_TextEval_Info,
	}, {
		Name:    "indices",
		Label:   "indices",
		Private: true,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Runtime version of shuffle_text.",
	},
}

// holds a slice of type call_shuffle
// FIX: duplicates the spec decl.
type FIX_CallShuffle_Slice []CallShuffle

// implements typeinfo.Inspector
func (*CallShuffle_Slice) Inspect() typeinfo.T {
	return &Z_CallShuffle_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallTerminal struct {
	Name   string
	Parts  rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CallTerminal) Inspect() typeinfo.T {
	return &Z_CallTerminal_Info
}

// return a valid markup map, creating it if necessary.
func (op *CallTerminal) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// call_terminal, a type of flow.
const Z_CallTerminal_Type = "call_terminal"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*CallTerminal)(nil)

var Z_CallTerminal_Info = typeinfo.Flow{
	Name: Z_CallTerminal_Type,
	Lede: "stopping",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:    "parts",
		Label:   "over",
		Repeats: true,
		Type:    &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Runtime version of stopping_text.",
	},
}

// holds a slice of type call_terminal
// FIX: duplicates the spec decl.
type FIX_CallTerminal_Slice []CallTerminal

// implements typeinfo.Inspector
func (*CallTerminal_Slice) Inspect() typeinfo.T {
	return &Z_CallTerminal_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallTrigger struct {
	Name    string
	Trigger Trigger
	Num     rti.NumberEval
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*CallTrigger) Inspect() typeinfo.T {
	return &Z_CallTrigger_Info
}

// return a valid markup map, creating it if necessary.
func (op *CallTrigger) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// call_trigger, a type of flow.
const Z_CallTrigger_Type = "call_trigger"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*CallTrigger)(nil)

var Z_CallTrigger_Info = typeinfo.Flow{
	Name: Z_CallTrigger_Type,
	Lede: "trigger",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:  "trigger",
		Label: "on",
		Type:  &Z_Trigger_Info,
	}, {
		Name:  "num",
		Label: "num",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "Runtime version of count_of.",
	},
}

// holds a slice of type call_trigger
// FIX: duplicates the spec decl.
type FIX_CallTrigger_Slice []CallTrigger

// implements typeinfo.Inspector
func (*CallTrigger_Slice) Inspect() typeinfo.T {
	return &Z_CallTrigger_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Capitalize struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Capitalize) Inspect() typeinfo.T {
	return &Z_Capitalize_Info
}

// return a valid markup map, creating it if necessary.
func (op *Capitalize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// capitalize, a type of flow.
const Z_Capitalize_Type = "capitalize"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*Capitalize)(nil)

var Z_Capitalize_Info = typeinfo.Flow{
	Name: Z_Capitalize_Type,
	Lede: "capitalize",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns new text, with the first letter turned into uppercase.",
	},
}

// holds a slice of type capitalize
// FIX: duplicates the spec decl.
type FIX_Capitalize_Slice []Capitalize

// implements typeinfo.Inspector
func (*Capitalize_Slice) Inspect() typeinfo.T {
	return &Z_Capitalize_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ChooseBranch struct {
	If     rti.BoolEval
	Args   assign.Arg
	Exe    rti.Execute
	Else   Brancher
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ChooseBranch) Inspect() typeinfo.T {
	return &Z_ChooseBranch_Info
}

// return a valid markup map, creating it if necessary.
func (op *ChooseBranch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// choose_branch, a type of flow.
const Z_ChooseBranch_Type = "choose_branch"

// ensure the command implements its specified slots:
var _ rti.Execute = (*ChooseBranch)(nil)
var _ Brancher = (*ChooseBranch)(nil)

var Z_ChooseBranch_Info = typeinfo.Flow{
	Name: Z_ChooseBranch_Type,
	Lede: "if",
	Terms: []typeinfo.Term{{
		Name:  "if",
		Label: "_",
		Type:  &rti.Z_BoolEval_Info,
	}, {
		Name:     "args",
		Label:    "assuming",
		Optional: true,
		Repeats:  true,
		Type:     &assign.Z_Arg_Info,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}, {
		Name:     "else",
		Label:    "else",
		Optional: true,
		Type:     &Z_Brancher_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_Execute_Info,
		&Z_Brancher_Info,
	},
	Markup: map[string]any{
		"comment": []interface{}{"An if statement.", "The provided local fields are evaluated before the if test itself."},
	},
}

// holds a slice of type choose_branch
// FIX: duplicates the spec decl.
type FIX_ChooseBranch_Slice []ChooseBranch

// implements typeinfo.Inspector
func (*ChooseBranch_Slice) Inspect() typeinfo.T {
	return &Z_ChooseBranch_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ChooseNothingElse struct {
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ChooseNothingElse) Inspect() typeinfo.T {
	return &Z_ChooseNothingElse_Info
}

// return a valid markup map, creating it if necessary.
func (op *ChooseNothingElse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// choose_nothing_else, a type of flow.
const Z_ChooseNothingElse_Type = "choose_nothing_else"

// ensure the command implements its specified slots:
var _ Brancher = (*ChooseNothingElse)(nil)

var Z_ChooseNothingElse_Info = typeinfo.Flow{
	Name: Z_ChooseNothingElse_Type,
	Lede: "finally",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&Z_Brancher_Info,
	},
}

// holds a slice of type choose_nothing_else
// FIX: duplicates the spec decl.
type FIX_ChooseNothingElse_Slice []ChooseNothingElse

// implements typeinfo.Inspector
func (*ChooseNothingElse_Slice) Inspect() typeinfo.T {
	return &Z_ChooseNothingElse_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ChooseNum struct {
	If     rti.BoolEval
	True   rti.NumberEval
	False  rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ChooseNum) Inspect() typeinfo.T {
	return &Z_ChooseNum_Info
}

// return a valid markup map, creating it if necessary.
func (op *ChooseNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// choose_num, a type of flow.
const Z_ChooseNum_Type = "choose_num"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*ChooseNum)(nil)

var Z_ChooseNum_Info = typeinfo.Flow{
	Name: Z_ChooseNum_Type,
	Lede: "num",
	Terms: []typeinfo.Term{{
		Name:  "if",
		Label: "if",
		Type:  &rti.Z_BoolEval_Info,
	}, {
		Name:  "true",
		Label: "then",
		Type:  &rti.Z_NumberEval_Info,
	}, {
		Name:     "false",
		Label:    "else",
		Optional: true,
		Type:     &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
	},
	Markup: map[string]any{
		"comment": "Pick one of two numbers based on a boolean test.",
	},
}

// holds a slice of type choose_num
// FIX: duplicates the spec decl.
type FIX_ChooseNum_Slice []ChooseNum

// implements typeinfo.Inspector
func (*ChooseNum_Slice) Inspect() typeinfo.T {
	return &Z_ChooseNum_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ChooseText struct {
	If     rti.BoolEval
	True   rti.TextEval
	False  rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ChooseText) Inspect() typeinfo.T {
	return &Z_ChooseText_Info
}

// return a valid markup map, creating it if necessary.
func (op *ChooseText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// choose_text, a type of flow.
const Z_ChooseText_Type = "choose_text"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*ChooseText)(nil)

var Z_ChooseText_Info = typeinfo.Flow{
	Name: Z_ChooseText_Type,
	Lede: "txt",
	Terms: []typeinfo.Term{{
		Name:  "if",
		Label: "if",
		Type:  &rti.Z_BoolEval_Info,
	}, {
		Name:  "true",
		Label: "then",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:     "false",
		Label:    "else",
		Optional: true,
		Type:     &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Pick one of two strings based on a boolean test.",
	},
}

// holds a slice of type choose_text
// FIX: duplicates the spec decl.
type FIX_ChooseText_Slice []ChooseText

// implements typeinfo.Inspector
func (*ChooseText_Slice) Inspect() typeinfo.T {
	return &Z_ChooseText_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CommaText struct {
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CommaText) Inspect() typeinfo.T {
	return &Z_CommaText_Info
}

// return a valid markup map, creating it if necessary.
func (op *CommaText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// comma_text, a type of flow.
const Z_CommaText_Type = "comma_text"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*CommaText)(nil)

var Z_CommaText_Info = typeinfo.Flow{
	Name: Z_CommaText_Type,
	Lede: "commas",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Separates words with commas, and 'and'.",
	},
}

// holds a slice of type comma_text
// FIX: duplicates the spec decl.
type FIX_CommaText_Slice []CommaText

// implements typeinfo.Inspector
func (*CommaText_Slice) Inspect() typeinfo.T {
	return &Z_CommaText_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CompareValue struct {
	A      rti.Assignment
	Is     string
	B      rti.Assignment
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CompareValue) Inspect() typeinfo.T {
	return &Z_CompareValue_Info
}

// return a valid markup map, creating it if necessary.
func (op *CompareValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// compare_value, a type of flow.
const Z_CompareValue_Type = "compare_value"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*CompareValue)(nil)

var Z_CompareValue_Info = typeinfo.Flow{
	Name: Z_CompareValue_Type,
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rti.Z_Assignment_Info,
	}, {
		Name:  "is",
		Label: "matching",
		Type:  &Z_Comparison_Info,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rti.Z_Assignment_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "True if eq,ne,gt,lt,ge,le two numbers.",
	},
}

// holds a slice of type compare_value
// FIX: duplicates the spec decl.
type FIX_CompareValue_Slice []CompareValue

// implements typeinfo.Inspector
func (*CompareValue_Slice) Inspect() typeinfo.T {
	return &Z_CompareValue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CompareNum struct {
	A         rti.NumberEval
	Is        string
	B         rti.NumberEval
	Tolerance float64
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*CompareNum) Inspect() typeinfo.T {
	return &Z_CompareNum_Info
}

// return a valid markup map, creating it if necessary.
func (op *CompareNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// compare_num, a type of flow.
const Z_CompareNum_Type = "compare_num"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*CompareNum)(nil)

var Z_CompareNum_Info = typeinfo.Flow{
	Name: Z_CompareNum_Type,
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rti.Z_NumberEval_Info,
	}, {
		Name:  "is",
		Label: "matching",
		Type:  &Z_Comparison_Info,
	}, {
		Name:  "b",
		Label: "num",
		Type:  &rti.Z_NumberEval_Info,
	}, {
		Name:     "tolerance",
		Label:    "within",
		Optional: true,
		Type:     &prim.Z_Number_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "True if eq,ne,gt,lt,ge,le two numbers.",
	},
}

// holds a slice of type compare_num
// FIX: duplicates the spec decl.
type FIX_CompareNum_Slice []CompareNum

// implements typeinfo.Inspector
func (*CompareNum_Slice) Inspect() typeinfo.T {
	return &Z_CompareNum_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CompareText struct {
	A      rti.TextEval
	Is     string
	B      rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CompareText) Inspect() typeinfo.T {
	return &Z_CompareText_Info
}

// return a valid markup map, creating it if necessary.
func (op *CompareText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// compare_text, a type of flow.
const Z_CompareText_Type = "compare_text"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*CompareText)(nil)

var Z_CompareText_Info = typeinfo.Flow{
	Name: Z_CompareText_Type,
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:  "is",
		Label: "matching",
		Type:  &Z_Comparison_Info,
	}, {
		Name:  "b",
		Label: "text",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "True if eq,ne,gt,lt,ge,le two strings ( lexical. ).",
	},
}

// holds a slice of type compare_text
// FIX: duplicates the spec decl.
type FIX_CompareText_Slice []CompareText

// implements typeinfo.Inspector
func (*CompareText_Slice) Inspect() typeinfo.T {
	return &Z_CompareText_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SubtractValue struct {
	A      rti.NumberEval
	B      rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*SubtractValue) Inspect() typeinfo.T {
	return &Z_SubtractValue_Info
}

// return a valid markup map, creating it if necessary.
func (op *SubtractValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// subtract_value, a type of flow.
const Z_SubtractValue_Type = "subtract_value"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*SubtractValue)(nil)

var Z_SubtractValue_Info = typeinfo.Flow{
	Name: Z_SubtractValue_Type,
	Lede: "subtract",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rti.Z_NumberEval_Info,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
	},
	Markup: map[string]any{
		"comment": "Subtract two numbers.",
	},
}

// holds a slice of type subtract_value
// FIX: duplicates the spec decl.
type FIX_SubtractValue_Slice []SubtractValue

// implements typeinfo.Inspector
func (*SubtractValue_Slice) Inspect() typeinfo.T {
	return &Z_SubtractValue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_During struct {
	PatternName string
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*During) Inspect() typeinfo.T {
	return &Z_During_Info
}

// return a valid markup map, creating it if necessary.
func (op *During) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// during, a type of flow.
const Z_During_Type = "during"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*During)(nil)
var _ rti.NumberEval = (*During)(nil)

var Z_During_Info = typeinfo.Flow{
	Name: Z_During_Type,
	Lede: "during",
	Terms: []typeinfo.Term{{
		Name:  "pattern_name",
		Label: "_",
		Type:  &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
		&rti.Z_NumberEval_Info,
	},
	Markup: map[string]any{
		"comment": "Decide whether a pattern is running.",
	},
}

// holds a slice of type during
// FIX: duplicates the spec decl.
type FIX_During_Slice []During

// implements typeinfo.Inspector
func (*During_Slice) Inspect() typeinfo.T {
	return &Z_During_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_FieldsOfKind struct {
	KindName rti.TextEval
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*FieldsOfKind) Inspect() typeinfo.T {
	return &Z_FieldsOfKind_Info
}

// return a valid markup map, creating it if necessary.
func (op *FieldsOfKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// fields_of_kind, a type of flow.
const Z_FieldsOfKind_Type = "fields_of_kind"

// ensure the command implements its specified slots:
var _ rti.TextListEval = (*FieldsOfKind)(nil)

var Z_FieldsOfKind_Info = typeinfo.Flow{
	Name: Z_FieldsOfKind_Type,
	Lede: "fields",
	Terms: []typeinfo.Term{{
		Name:  "kind_name",
		Label: "of",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextListEval_Info,
	},
	Markup: map[string]any{
		"comment": "List of the field names of a kind.",
	},
}

// holds a slice of type fields_of_kind
// FIX: duplicates the spec decl.
type FIX_FieldsOfKind_Slice []FieldsOfKind

// implements typeinfo.Inspector
func (*FieldsOfKind_Slice) Inspect() typeinfo.T {
	return &Z_FieldsOfKind_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_HasDominion struct {
	Name   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*HasDominion) Inspect() typeinfo.T {
	return &Z_HasDominion_Info
}

// return a valid markup map, creating it if necessary.
func (op *HasDominion) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// has_dominion, a type of flow.
const Z_HasDominion_Type = "has_dominion"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*HasDominion)(nil)

var Z_HasDominion_Info = typeinfo.Flow{
	Name: Z_HasDominion_Type,
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "domain",
		Type:  &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
}

// holds a slice of type has_dominion
// FIX: duplicates the spec decl.
type FIX_HasDominion_Slice []HasDominion

// implements typeinfo.Inspector
func (*HasDominion_Slice) Inspect() typeinfo.T {
	return &Z_HasDominion_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IdOf struct {
	Object rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*IdOf) Inspect() typeinfo.T {
	return &Z_IdOf_Info
}

// return a valid markup map, creating it if necessary.
func (op *IdOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// id_of, a type of flow.
const Z_IdOf_Type = "id_of"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*IdOf)(nil)

var Z_IdOf_Info = typeinfo.Flow{
	Name: Z_IdOf_Type,
	Lede: "id_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "A unique object identifier.",
	},
}

// holds a slice of type id_of
// FIX: duplicates the spec decl.
type FIX_IdOf_Slice []IdOf

// implements typeinfo.Inspector
func (*IdOf_Slice) Inspect() typeinfo.T {
	return &Z_IdOf_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Includes struct {
	Text   rti.TextEval
	Part   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Includes) Inspect() typeinfo.T {
	return &Z_Includes_Info
}

// return a valid markup map, creating it if necessary.
func (op *Includes) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// includes, a type of flow.
const Z_Includes_Type = "includes"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*Includes)(nil)

var Z_Includes_Info = typeinfo.Flow{
	Name: Z_Includes_Type,
	Lede: "contains",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:  "part",
		Label: "part",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "True if text contains text.",
	},
}

// holds a slice of type includes
// FIX: duplicates the spec decl.
type FIX_Includes_Slice []Includes

// implements typeinfo.Inspector
func (*Includes_Slice) Inspect() typeinfo.T {
	return &Z_Includes_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IsEmpty struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*IsEmpty) Inspect() typeinfo.T {
	return &Z_IsEmpty_Info
}

// return a valid markup map, creating it if necessary.
func (op *IsEmpty) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// is_empty, a type of flow.
const Z_IsEmpty_Type = "is_empty"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*IsEmpty)(nil)

var Z_IsEmpty_Info = typeinfo.Flow{
	Name: Z_IsEmpty_Type,
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "empty",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "True if the text is empty.",
	},
}

// holds a slice of type is_empty
// FIX: duplicates the spec decl.
type FIX_IsEmpty_Slice []IsEmpty

// implements typeinfo.Inspector
func (*IsEmpty_Slice) Inspect() typeinfo.T {
	return &Z_IsEmpty_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IsExactKindOf struct {
	Object rti.TextEval
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*IsExactKindOf) Inspect() typeinfo.T {
	return &Z_IsExactKindOf_Info
}

// return a valid markup map, creating it if necessary.
func (op *IsExactKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// is_exact_kind_of, a type of flow.
const Z_IsExactKindOf_Type = "is_exact_kind_of"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*IsExactKindOf)(nil)

var Z_IsExactKindOf_Info = typeinfo.Flow{
	Name: Z_IsExactKindOf_Type,
	Lede: "kind_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:  "kind",
		Label: "is_exactly",
		Type:  &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "True if the object is exactly the named kind.",
	},
}

// holds a slice of type is_exact_kind_of
// FIX: duplicates the spec decl.
type FIX_IsExactKindOf_Slice []IsExactKindOf

// implements typeinfo.Inspector
func (*IsExactKindOf_Slice) Inspect() typeinfo.T {
	return &Z_IsExactKindOf_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IsKindOf struct {
	Object  rti.TextEval
	Kind    string
	Nothing bool
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*IsKindOf) Inspect() typeinfo.T {
	return &Z_IsKindOf_Info
}

// return a valid markup map, creating it if necessary.
func (op *IsKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// is_kind_of, a type of flow.
const Z_IsKindOf_Type = "is_kind_of"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*IsKindOf)(nil)

var Z_IsKindOf_Info = typeinfo.Flow{
	Name: Z_IsKindOf_Type,
	Lede: "kind_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:  "kind",
		Label: "is",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:     "nothing",
		Label:    "nothing",
		Optional: true,
		Type:     &prim.Z_Bool_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "True if the object is compatible with the named kind.",
	},
}

// holds a slice of type is_kind_of
// FIX: duplicates the spec decl.
type FIX_IsKindOf_Slice []IsKindOf

// implements typeinfo.Inspector
func (*IsKindOf_Slice) Inspect() typeinfo.T {
	return &Z_IsKindOf_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Join struct {
	Sep    rti.TextEval
	Parts  rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Join) Inspect() typeinfo.T {
	return &Z_Join_Info
}

// return a valid markup map, creating it if necessary.
func (op *Join) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// join, a type of flow.
const Z_Join_Type = "join"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*Join)(nil)

var Z_Join_Info = typeinfo.Flow{
	Name: Z_Join_Type,
	Lede: "join",
	Terms: []typeinfo.Term{{
		Name:     "sep",
		Label:    "_",
		Optional: true,
		Type:     &rti.Z_TextEval_Info,
	}, {
		Name:    "parts",
		Label:   "parts",
		Repeats: true,
		Type:    &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns multiple pieces of text as a single new piece of text.",
	},
}

// holds a slice of type join
// FIX: duplicates the spec decl.
type FIX_Join_Slice []Join

// implements typeinfo.Inspector
func (*Join_Slice) Inspect() typeinfo.T {
	return &Z_Join_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_KindOf struct {
	Object  rti.TextEval
	Nothing bool
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*KindOf) Inspect() typeinfo.T {
	return &Z_KindOf_Info
}

// return a valid markup map, creating it if necessary.
func (op *KindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// kind_of, a type of flow.
const Z_KindOf_Type = "kind_of"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*KindOf)(nil)

var Z_KindOf_Info = typeinfo.Flow{
	Name: Z_KindOf_Type,
	Lede: "kind_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:     "nothing",
		Label:    "nothing",
		Optional: true,
		Type:     &prim.Z_Bool_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Friendly name of the object's kind.",
	},
}

// holds a slice of type kind_of
// FIX: duplicates the spec decl.
type FIX_KindOf_Slice []KindOf

// implements typeinfo.Inspector
func (*KindOf_Slice) Inspect() typeinfo.T {
	return &Z_KindOf_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_KindsOf struct {
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*KindsOf) Inspect() typeinfo.T {
	return &Z_KindsOf_Info
}

// return a valid markup map, creating it if necessary.
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// kinds_of, a type of flow.
const Z_KindsOf_Type = "kinds_of"

// ensure the command implements its specified slots:
var _ rti.TextListEval = (*KindsOf)(nil)

var Z_KindsOf_Info = typeinfo.Flow{
	Name: Z_KindsOf_Type,
	Lede: "kinds_of",
	Terms: []typeinfo.Term{{
		Name:  "kind",
		Label: "_",
		Type:  &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextListEval_Info,
	},
	Markup: map[string]any{
		"comment": "A list of compatible kinds.",
	},
}

// holds a slice of type kinds_of
// FIX: duplicates the spec decl.
type FIX_KindsOf_Slice []KindsOf

// implements typeinfo.Inspector
func (*KindsOf_Slice) Inspect() typeinfo.T {
	return &Z_KindsOf_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeLowercase struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeLowercase) Inspect() typeinfo.T {
	return &Z_MakeLowercase_Info
}

// return a valid markup map, creating it if necessary.
func (op *MakeLowercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// make_lowercase, a type of flow.
const Z_MakeLowercase_Type = "make_lowercase"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*MakeLowercase)(nil)

var Z_MakeLowercase_Info = typeinfo.Flow{
	Name: Z_MakeLowercase_Type,
	Lede: "lower",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns new text, with every letter turned into lowercase. For example, 'shout' from 'SHOUT'.",
	},
}

// holds a slice of type make_lowercase
// FIX: duplicates the spec decl.
type FIX_MakeLowercase_Slice []MakeLowercase

// implements typeinfo.Inspector
func (*MakeLowercase_Slice) Inspect() typeinfo.T {
	return &Z_MakeLowercase_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeReversed struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeReversed) Inspect() typeinfo.T {
	return &Z_MakeReversed_Info
}

// return a valid markup map, creating it if necessary.
func (op *MakeReversed) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// make_reversed, a type of flow.
const Z_MakeReversed_Type = "make_reversed"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*MakeReversed)(nil)

var Z_MakeReversed_Info = typeinfo.Flow{
	Name: Z_MakeReversed_Type,
	Lede: "reverse",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "text",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns new text flipped back to front. For example, 'elppA' from 'Apple', or 'noon' from 'noon'.",
	},
}

// holds a slice of type make_reversed
// FIX: duplicates the spec decl.
type FIX_MakeReversed_Slice []MakeReversed

// implements typeinfo.Inspector
func (*MakeReversed_Slice) Inspect() typeinfo.T {
	return &Z_MakeReversed_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeSentenceCase struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeSentenceCase) Inspect() typeinfo.T {
	return &Z_MakeSentenceCase_Info
}

// return a valid markup map, creating it if necessary.
func (op *MakeSentenceCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// make_sentence_case, a type of flow.
const Z_MakeSentenceCase_Type = "make_sentence_case"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*MakeSentenceCase)(nil)

var Z_MakeSentenceCase_Info = typeinfo.Flow{
	Name: Z_MakeSentenceCase_Type,
	Lede: "sentence",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns new text, start each sentence with a capital letter. For example, 'Empire Apple.' from 'Empire apple.'.",
	},
}

// holds a slice of type make_sentence_case
// FIX: duplicates the spec decl.
type FIX_MakeSentenceCase_Slice []MakeSentenceCase

// implements typeinfo.Inspector
func (*MakeSentenceCase_Slice) Inspect() typeinfo.T {
	return &Z_MakeSentenceCase_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeTitleCase struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeTitleCase) Inspect() typeinfo.T {
	return &Z_MakeTitleCase_Info
}

// return a valid markup map, creating it if necessary.
func (op *MakeTitleCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// make_title_case, a type of flow.
const Z_MakeTitleCase_Type = "make_title_case"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*MakeTitleCase)(nil)

var Z_MakeTitleCase_Info = typeinfo.Flow{
	Name: Z_MakeTitleCase_Type,
	Lede: "title",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns new text, starting each word with a capital letter. For example, 'Empire Apple' from 'empire apple'.",
	},
}

// holds a slice of type make_title_case
// FIX: duplicates the spec decl.
type FIX_MakeTitleCase_Slice []MakeTitleCase

// implements typeinfo.Inspector
func (*MakeTitleCase_Slice) Inspect() typeinfo.T {
	return &Z_MakeTitleCase_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeUppercase struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeUppercase) Inspect() typeinfo.T {
	return &Z_MakeUppercase_Info
}

// return a valid markup map, creating it if necessary.
func (op *MakeUppercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// make_uppercase, a type of flow.
const Z_MakeUppercase_Type = "make_uppercase"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*MakeUppercase)(nil)

var Z_MakeUppercase_Info = typeinfo.Flow{
	Name: Z_MakeUppercase_Type,
	Lede: "upper",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns new text, with every letter turned into uppercase. For example, 'APPLE' from 'apple'.",
	},
}

// holds a slice of type make_uppercase
// FIX: duplicates the spec decl.
type FIX_MakeUppercase_Slice []MakeUppercase

// implements typeinfo.Inspector
func (*MakeUppercase_Slice) Inspect() typeinfo.T {
	return &Z_MakeUppercase_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Matches struct {
	Text   rti.TextEval
	Match  string
	Cache  MatchCache
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Matches) Inspect() typeinfo.T {
	return &Z_Matches_Info
}

// return a valid markup map, creating it if necessary.
func (op *Matches) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// matches, a type of flow.
const Z_Matches_Type = "matches"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*Matches)(nil)

var Z_Matches_Info = typeinfo.Flow{
	Name: Z_Matches_Type,
	Lede: "matches",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:  "match",
		Label: "to",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:    "cache",
		Label:   "cache",
		Private: true,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "Determine whether the specified text is similar to the specified regular expression.",
	},
}

// holds a slice of type matches
// FIX: duplicates the spec decl.
type FIX_Matches_Slice []Matches

// implements typeinfo.Inspector
func (*Matches_Slice) Inspect() typeinfo.T {
	return &Z_Matches_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_NameOf struct {
	Object rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*NameOf) Inspect() typeinfo.T {
	return &Z_NameOf_Info
}

// return a valid markup map, creating it if necessary.
func (op *NameOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// name_of, a type of flow.
const Z_NameOf_Type = "name_of"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*NameOf)(nil)

var Z_NameOf_Info = typeinfo.Flow{
	Name: Z_NameOf_Type,
	Lede: "name_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Full name of the object.",
	},
}

// holds a slice of type name_of
// FIX: duplicates the spec decl.
type FIX_NameOf_Slice []NameOf

// implements typeinfo.Inspector
func (*NameOf_Slice) Inspect() typeinfo.T {
	return &Z_NameOf_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Never struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Never) Inspect() typeinfo.T {
	return &Z_Never_Info
}

// return a valid markup map, creating it if necessary.
func (op *Never) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// never, a type of flow.
const Z_Never_Type = "never"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*Never)(nil)

var Z_Never_Info = typeinfo.Flow{
	Name:  Z_Never_Type,
	Lede:  "never",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns false.",
	},
}

// holds a slice of type never
// FIX: duplicates the spec decl.
type FIX_Never_Slice []Never

// implements typeinfo.Inspector
func (*Never_Slice) Inspect() typeinfo.T {
	return &Z_Never_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Newline struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Newline) Inspect() typeinfo.T {
	return &Z_Newline_Info
}

// return a valid markup map, creating it if necessary.
func (op *Newline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// newline, a type of flow.
const Z_Newline_Type = "newline"

// ensure the command implements its specified slots:
var _ rti.Execute = (*Newline)(nil)

var Z_Newline_Info = typeinfo.Flow{
	Name:  Z_Newline_Type,
	Lede:  "br",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": "Start a new line.",
	},
}

// holds a slice of type newline
// FIX: duplicates the spec decl.
type FIX_Newline_Slice []Newline

// implements typeinfo.Inspector
func (*Newline_Slice) Inspect() typeinfo.T {
	return &Z_Newline_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Continue struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Continue) Inspect() typeinfo.T {
	return &Z_Continue_Info
}

// return a valid markup map, creating it if necessary.
func (op *Continue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// continue, a type of flow.
const Z_Continue_Type = "continue"

// ensure the command implements its specified slots:
var _ rti.Execute = (*Continue)(nil)

var Z_Continue_Info = typeinfo.Flow{
	Name:  Z_Continue_Type,
	Lede:  "continue",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": []interface{}{"In a repeating loop, try the next iteration of the loop;", "or, in a rule, continue to the next rule."},
	},
}

// holds a slice of type continue
// FIX: duplicates the spec decl.
type FIX_Continue_Slice []Continue

// implements typeinfo.Inspector
func (*Continue_Slice) Inspect() typeinfo.T {
	return &Z_Continue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Not struct {
	Test   rti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Not) Inspect() typeinfo.T {
	return &Z_Not_Info
}

// return a valid markup map, creating it if necessary.
func (op *Not) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// not, a type of flow.
const Z_Not_Type = "not"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*Not)(nil)

var Z_Not_Info = typeinfo.Flow{
	Name: Z_Not_Type,
	Lede: "not",
	Terms: []typeinfo.Term{{
		Name:  "test",
		Label: "_",
		Type:  &rti.Z_BoolEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns the opposite value.",
	},
}

// holds a slice of type not
// FIX: duplicates the spec decl.
type FIX_Not_Slice []Not

// implements typeinfo.Inspector
func (*Not_Slice) Inspect() typeinfo.T {
	return &Z_Not_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ObjectExists struct {
	Object rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ObjectExists) Inspect() typeinfo.T {
	return &Z_ObjectExists_Info
}

// return a valid markup map, creating it if necessary.
func (op *ObjectExists) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// object_exists, a type of flow.
const Z_ObjectExists_Type = "object_exists"

// ensure the command implements its specified slots:
var _ rti.BoolEval = (*ObjectExists)(nil)

var Z_ObjectExists_Info = typeinfo.Flow{
	Name: Z_ObjectExists_Type,
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "valid",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_BoolEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns whether there is a object of the specified name.",
	},
}

// holds a slice of type object_exists
// FIX: duplicates the spec decl.
type FIX_ObjectExists_Slice []ObjectExists

// implements typeinfo.Inspector
func (*ObjectExists_Slice) Inspect() typeinfo.T {
	return &Z_ObjectExists_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ObjectTraits struct {
	Object rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ObjectTraits) Inspect() typeinfo.T {
	return &Z_ObjectTraits_Info
}

// return a valid markup map, creating it if necessary.
func (op *ObjectTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// object_traits, a type of flow.
const Z_ObjectTraits_Type = "object_traits"

// ensure the command implements its specified slots:
var _ rti.TextListEval = (*ObjectTraits)(nil)

var Z_ObjectTraits_Info = typeinfo.Flow{
	Name: Z_ObjectTraits_Type,
	Lede: "object",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "traits",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextListEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns all of the object's current traits as a list of text.",
	},
}

// holds a slice of type object_traits
// FIX: duplicates the spec decl.
type FIX_ObjectTraits_Slice []ObjectTraits

// implements typeinfo.Inspector
func (*ObjectTraits_Slice) Inspect() typeinfo.T {
	return &Z_ObjectTraits_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Pluralize struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Pluralize) Inspect() typeinfo.T {
	return &Z_Pluralize_Info
}

// return a valid markup map, creating it if necessary.
func (op *Pluralize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// pluralize, a type of flow.
const Z_Pluralize_Type = "pluralize"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*Pluralize)(nil)

var Z_Pluralize_Info = typeinfo.Flow{
	Name: Z_Pluralize_Type,
	Lede: "plural",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "of",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns the plural form of a singular word. (ex. apples for apple. ).",
	},
}

// holds a slice of type pluralize
// FIX: duplicates the spec decl.
type FIX_Pluralize_Slice []Pluralize

// implements typeinfo.Inspector
func (*Pluralize_Slice) Inspect() typeinfo.T {
	return &Z_Pluralize_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_PrintNum struct {
	Num    rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*PrintNum) Inspect() typeinfo.T {
	return &Z_PrintNum_Info
}

// return a valid markup map, creating it if necessary.
func (op *PrintNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// print_num, a type of flow.
const Z_PrintNum_Type = "print_num"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*PrintNum)(nil)

var Z_PrintNum_Info = typeinfo.Flow{
	Name: Z_PrintNum_Type,
	Lede: "numeral",
	Terms: []typeinfo.Term{{
		Name:  "num",
		Label: "_",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Writes a number using numerals, eg. '1'.",
	},
}

// holds a slice of type print_num
// FIX: duplicates the spec decl.
type FIX_PrintNum_Slice []PrintNum

// implements typeinfo.Inspector
func (*PrintNum_Slice) Inspect() typeinfo.T {
	return &Z_PrintNum_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_PrintNumWord struct {
	Num    rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*PrintNumWord) Inspect() typeinfo.T {
	return &Z_PrintNumWord_Info
}

// return a valid markup map, creating it if necessary.
func (op *PrintNumWord) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// print_num_word, a type of flow.
const Z_PrintNumWord_Type = "print_num_word"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*PrintNumWord)(nil)

var Z_PrintNumWord_Info = typeinfo.Flow{
	Name: Z_PrintNumWord_Type,
	Lede: "numeral",
	Terms: []typeinfo.Term{{
		Name:  "num",
		Label: "words",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Writes a number in plain english: eg. 'one'.",
	},
}

// holds a slice of type print_num_word
// FIX: duplicates the spec decl.
type FIX_PrintNumWord_Slice []PrintNumWord

// implements typeinfo.Inspector
func (*PrintNumWord_Slice) Inspect() typeinfo.T {
	return &Z_PrintNumWord_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MultiplyValue struct {
	A      rti.NumberEval
	B      rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MultiplyValue) Inspect() typeinfo.T {
	return &Z_MultiplyValue_Info
}

// return a valid markup map, creating it if necessary.
func (op *MultiplyValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// multiply_value, a type of flow.
const Z_MultiplyValue_Type = "multiply_value"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*MultiplyValue)(nil)

var Z_MultiplyValue_Info = typeinfo.Flow{
	Name: Z_MultiplyValue_Type,
	Lede: "multiply",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rti.Z_NumberEval_Info,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
	},
	Markup: map[string]any{
		"comment": "Multiply two numbers.",
	},
}

// holds a slice of type multiply_value
// FIX: duplicates the spec decl.
type FIX_MultiplyValue_Slice []MultiplyValue

// implements typeinfo.Inspector
func (*MultiplyValue_Slice) Inspect() typeinfo.T {
	return &Z_MultiplyValue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DivideValue struct {
	A      rti.NumberEval
	B      rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DivideValue) Inspect() typeinfo.T {
	return &Z_DivideValue_Info
}

// return a valid markup map, creating it if necessary.
func (op *DivideValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// divide_value, a type of flow.
const Z_DivideValue_Type = "divide_value"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*DivideValue)(nil)

var Z_DivideValue_Info = typeinfo.Flow{
	Name: Z_DivideValue_Type,
	Lede: "divide",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rti.Z_NumberEval_Info,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
	},
	Markup: map[string]any{
		"comment": "Divide one number by another.",
	},
}

// holds a slice of type divide_value
// FIX: duplicates the spec decl.
type FIX_DivideValue_Slice []DivideValue

// implements typeinfo.Inspector
func (*DivideValue_Slice) Inspect() typeinfo.T {
	return &Z_DivideValue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ModValue struct {
	A      rti.NumberEval
	B      rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ModValue) Inspect() typeinfo.T {
	return &Z_ModValue_Info
}

// return a valid markup map, creating it if necessary.
func (op *ModValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// mod_value, a type of flow.
const Z_ModValue_Type = "mod_value"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*ModValue)(nil)

var Z_ModValue_Info = typeinfo.Flow{
	Name: Z_ModValue_Type,
	Lede: "mod",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rti.Z_NumberEval_Info,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
	},
	Markup: map[string]any{
		"comment": "Divide one number by another, and return the remainder.",
	},
}

// holds a slice of type mod_value
// FIX: duplicates the spec decl.
type FIX_ModValue_Slice []ModValue

// implements typeinfo.Inspector
func (*ModValue_Slice) Inspect() typeinfo.T {
	return &Z_ModValue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AbsValue struct {
	Value  rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AbsValue) Inspect() typeinfo.T {
	return &Z_AbsValue_Info
}

// return a valid markup map, creating it if necessary.
func (op *AbsValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// abs_value, a type of flow.
const Z_AbsValue_Type = "abs_value"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*AbsValue)(nil)

var Z_AbsValue_Info = typeinfo.Flow{
	Name: Z_AbsValue_Type,
	Lede: "absolute",
	Terms: []typeinfo.Term{{
		Name:  "value",
		Label: "value",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
	},
}

// holds a slice of type abs_value
// FIX: duplicates the spec decl.
type FIX_AbsValue_Slice []AbsValue

// implements typeinfo.Inspector
func (*AbsValue_Slice) Inspect() typeinfo.T {
	return &Z_AbsValue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Increment struct {
	Target assign.Address
	Step   rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Increment) Inspect() typeinfo.T {
	return &Z_Increment_Info
}

// return a valid markup map, creating it if necessary.
func (op *Increment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// increment, a type of flow.
const Z_Increment_Type = "increment"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*Increment)(nil)
var _ rti.Execute = (*Increment)(nil)

var Z_Increment_Info = typeinfo.Flow{
	Name: Z_Increment_Type,
	Lede: "increase",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Z_Address_Info,
	}, {
		Name:     "step",
		Label:    "by",
		Optional: true,
		Type:     &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Increases the value of a number held in by a variable or object field.", "Returns the new value of the number."},
	},
}

// holds a slice of type increment
// FIX: duplicates the spec decl.
type FIX_Increment_Slice []Increment

// implements typeinfo.Inspector
func (*Increment_Slice) Inspect() typeinfo.T {
	return &Z_Increment_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Decrement struct {
	Target assign.Address
	Step   rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Decrement) Inspect() typeinfo.T {
	return &Z_Decrement_Info
}

// return a valid markup map, creating it if necessary.
func (op *Decrement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// decrement, a type of flow.
const Z_Decrement_Type = "decrement"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*Decrement)(nil)
var _ rti.Execute = (*Decrement)(nil)

var Z_Decrement_Info = typeinfo.Flow{
	Name: Z_Decrement_Type,
	Lede: "decrease",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Z_Address_Info,
	}, {
		Name:     "step",
		Label:    "by",
		Optional: true,
		Type:     &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Decrease the value of a number held in by a variable or object field.", "Returns the new value of the number."},
	},
}

// holds a slice of type decrement
// FIX: duplicates the spec decl.
type FIX_Decrement_Slice []Decrement

// implements typeinfo.Inspector
func (*Decrement_Slice) Inspect() typeinfo.T {
	return &Z_Decrement_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IncrementAspect struct {
	Target rti.TextEval
	Aspect rti.TextEval
	Step   rti.NumberEval
	Clamp  rti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*IncrementAspect) Inspect() typeinfo.T {
	return &Z_IncrementAspect_Info
}

// return a valid markup map, creating it if necessary.
func (op *IncrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// increment_aspect, a type of flow.
const Z_IncrementAspect_Type = "increment_aspect"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*IncrementAspect)(nil)
var _ rti.Execute = (*IncrementAspect)(nil)

var Z_IncrementAspect_Info = typeinfo.Flow{
	Name: Z_IncrementAspect_Type,
	Lede: "increase",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:  "aspect",
		Label: "aspect",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:     "step",
		Label:    "by",
		Optional: true,
		Type:     &rti.Z_NumberEval_Info,
	}, {
		Name:     "clamp",
		Label:    "clamp",
		Optional: true,
		Type:     &rti.Z_BoolEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Increases the value of a trait held by an object aspect.", "Returns the new value of the trait."},
	},
}

// holds a slice of type increment_aspect
// FIX: duplicates the spec decl.
type FIX_IncrementAspect_Slice []IncrementAspect

// implements typeinfo.Inspector
func (*IncrementAspect_Slice) Inspect() typeinfo.T {
	return &Z_IncrementAspect_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DecrementAspect struct {
	Target rti.TextEval
	Aspect rti.TextEval
	Step   rti.NumberEval
	Clamp  rti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DecrementAspect) Inspect() typeinfo.T {
	return &Z_DecrementAspect_Info
}

// return a valid markup map, creating it if necessary.
func (op *DecrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// decrement_aspect, a type of flow.
const Z_DecrementAspect_Type = "decrement_aspect"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*DecrementAspect)(nil)
var _ rti.Execute = (*DecrementAspect)(nil)

var Z_DecrementAspect_Info = typeinfo.Flow{
	Name: Z_DecrementAspect_Type,
	Lede: "decrease",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:  "aspect",
		Label: "aspect",
		Type:  &rti.Z_TextEval_Info,
	}, {
		Name:     "step",
		Label:    "by",
		Optional: true,
		Type:     &rti.Z_NumberEval_Info,
	}, {
		Name:     "clamp",
		Label:    "clamp",
		Optional: true,
		Type:     &rti.Z_BoolEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Increases the value of a trait held by an object aspect.", "Returns the new value of the trait."},
	},
}

// holds a slice of type decrement_aspect
// FIX: duplicates the spec decl.
type FIX_DecrementAspect_Slice []DecrementAspect

// implements typeinfo.Inspector
func (*DecrementAspect_Slice) Inspect() typeinfo.T {
	return &Z_DecrementAspect_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_PrintText struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*PrintText) Inspect() typeinfo.T {
	return &Z_PrintText_Info
}

// return a valid markup map, creating it if necessary.
func (op *PrintText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// print_text, a type of flow.
const Z_PrintText_Type = "print_text"

// ensure the command implements its specified slots:
var _ rti.Execute = (*PrintText)(nil)

var Z_PrintText_Info = typeinfo.Flow{
	Name: Z_PrintText_Type,
	Lede: "print",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": "Display some text to the player without apply any additional formatting.",
	},
}

// holds a slice of type print_text
// FIX: duplicates the spec decl.
type FIX_PrintText_Slice []PrintText

// implements typeinfo.Inspector
func (*PrintText_Slice) Inspect() typeinfo.T {
	return &Z_PrintText_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Row struct {
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Row) Inspect() typeinfo.T {
	return &Z_Row_Info
}

// return a valid markup map, creating it if necessary.
func (op *Row) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// row, a type of flow.
const Z_Row_Type = "row"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*Row)(nil)

var Z_Row_Info = typeinfo.Flow{
	Name: Z_Row_Type,
	Lede: "row",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Group text into a single line <li> as part of a list of lines.", "See also: 'rows'."},
	},
}

// holds a slice of type row
// FIX: duplicates the spec decl.
type FIX_Row_Slice []Row

// implements typeinfo.Inspector
func (*Row_Slice) Inspect() typeinfo.T {
	return &Z_Row_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Rows struct {
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Rows) Inspect() typeinfo.T {
	return &Z_Rows_Info
}

// return a valid markup map, creating it if necessary.
func (op *Rows) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// rows, a type of flow.
const Z_Rows_Type = "rows"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*Rows)(nil)

var Z_Rows_Info = typeinfo.Flow{
	Name: Z_Rows_Type,
	Lede: "rows",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Group text into an unordered list <ul>.",
	},
}

// holds a slice of type rows
// FIX: duplicates the spec decl.
type FIX_Rows_Slice []Rows

// implements typeinfo.Inspector
func (*Rows_Slice) Inspect() typeinfo.T {
	return &Z_Rows_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Singularize struct {
	Text   rti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Singularize) Inspect() typeinfo.T {
	return &Z_Singularize_Info
}

// return a valid markup map, creating it if necessary.
func (op *Singularize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// singularize, a type of flow.
const Z_Singularize_Type = "singularize"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*Singularize)(nil)

var Z_Singularize_Info = typeinfo.Flow{
	Name: Z_Singularize_Type,
	Lede: "singular",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "of",
		Type:  &rti.Z_TextEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Returns the singular form of a plural word. (ex. apple for apples ).",
	},
}

// holds a slice of type singularize
// FIX: duplicates the spec decl.
type FIX_Singularize_Slice []Singularize

// implements typeinfo.Inspector
func (*Singularize_Slice) Inspect() typeinfo.T {
	return &Z_Singularize_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SlashText struct {
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*SlashText) Inspect() typeinfo.T {
	return &Z_SlashText_Info
}

// return a valid markup map, creating it if necessary.
func (op *SlashText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// slash_text, a type of flow.
const Z_SlashText_Type = "slash_text"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*SlashText)(nil)

var Z_SlashText_Info = typeinfo.Flow{
	Name: Z_SlashText_Type,
	Lede: "slashes",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Separates words with left-leaning slashes '/'.",
	},
}

// holds a slice of type slash_text
// FIX: duplicates the spec decl.
type FIX_SlashText_Slice []SlashText

// implements typeinfo.Inspector
func (*SlashText_Slice) Inspect() typeinfo.T {
	return &Z_SlashText_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Softline struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Softline) Inspect() typeinfo.T {
	return &Z_Softline_Info
}

// return a valid markup map, creating it if necessary.
func (op *Softline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// softline, a type of flow.
const Z_Softline_Type = "softline"

// ensure the command implements its specified slots:
var _ rti.Execute = (*Softline)(nil)

var Z_Softline_Info = typeinfo.Flow{
	Name:  Z_Softline_Type,
	Lede:  "wbr",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": "Start a new line ( if not already at a new line. ).",
	},
}

// holds a slice of type softline
// FIX: duplicates the spec decl.
type FIX_Softline_Slice []Softline

// implements typeinfo.Inspector
func (*Softline_Slice) Inspect() typeinfo.T {
	return &Z_Softline_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SpanText struct {
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*SpanText) Inspect() typeinfo.T {
	return &Z_SpanText_Info
}

// return a valid markup map, creating it if necessary.
func (op *SpanText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// span_text, a type of flow.
const Z_SpanText_Type = "span_text"

// ensure the command implements its specified slots:
var _ rti.TextEval = (*SpanText)(nil)

var Z_SpanText_Info = typeinfo.Flow{
	Name: Z_SpanText_Type,
	Lede: "spaces",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_TextEval_Info,
	},
	Markup: map[string]any{
		"comment": "Writes text with spaces between words.",
	},
}

// holds a slice of type span_text
// FIX: duplicates the spec decl.
type FIX_SpanText_Slice []SpanText

// implements typeinfo.Inspector
func (*SpanText_Slice) Inspect() typeinfo.T {
	return &Z_SpanText_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AddValue struct {
	A      rti.NumberEval
	B      rti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AddValue) Inspect() typeinfo.T {
	return &Z_AddValue_Info
}

// return a valid markup map, creating it if necessary.
func (op *AddValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// add_value, a type of flow.
const Z_AddValue_Type = "add_value"

// ensure the command implements its specified slots:
var _ rti.NumberEval = (*AddValue)(nil)

var Z_AddValue_Info = typeinfo.Flow{
	Name: Z_AddValue_Type,
	Lede: "add",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rti.Z_NumberEval_Info,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rti.Z_NumberEval_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_NumberEval_Info,
	},
	Markup: map[string]any{
		"comment": "Add two numbers.",
	},
}

// holds a slice of type add_value
// FIX: duplicates the spec decl.
type FIX_AddValue_Slice []AddValue

// implements typeinfo.Inspector
func (*AddValue_Slice) Inspect() typeinfo.T {
	return &Z_AddValue_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TriggerCycle struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*TriggerCycle) Inspect() typeinfo.T {
	return &Z_TriggerCycle_Info
}

// return a valid markup map, creating it if necessary.
func (op *TriggerCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// trigger_cycle, a type of flow.
const Z_TriggerCycle_Type = "trigger_cycle"

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerCycle)(nil)

var Z_TriggerCycle_Info = typeinfo.Flow{
	Name:  Z_TriggerCycle_Type,
	Lede:  "every",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&Z_Trigger_Info,
	},
}

// holds a slice of type trigger_cycle
// FIX: duplicates the spec decl.
type FIX_TriggerCycle_Slice []TriggerCycle

// implements typeinfo.Inspector
func (*TriggerCycle_Slice) Inspect() typeinfo.T {
	return &Z_TriggerCycle_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TriggerOnce struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*TriggerOnce) Inspect() typeinfo.T {
	return &Z_TriggerOnce_Info
}

// return a valid markup map, creating it if necessary.
func (op *TriggerOnce) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// trigger_once, a type of flow.
const Z_TriggerOnce_Type = "trigger_once"

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerOnce)(nil)

var Z_TriggerOnce_Info = typeinfo.Flow{
	Name:  Z_TriggerOnce_Type,
	Lede:  "at",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&Z_Trigger_Info,
	},
}

// holds a slice of type trigger_once
// FIX: duplicates the spec decl.
type FIX_TriggerOnce_Slice []TriggerOnce

// implements typeinfo.Inspector
func (*TriggerOnce_Slice) Inspect() typeinfo.T {
	return &Z_TriggerOnce_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TriggerSwitch struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*TriggerSwitch) Inspect() typeinfo.T {
	return &Z_TriggerSwitch_Info
}

// return a valid markup map, creating it if necessary.
func (op *TriggerSwitch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// trigger_switch, a type of flow.
const Z_TriggerSwitch_Type = "trigger_switch"

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerSwitch)(nil)

var Z_TriggerSwitch_Info = typeinfo.Flow{
	Name:  Z_TriggerSwitch_Type,
	Lede:  "after",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&Z_Trigger_Info,
	},
}

// holds a slice of type trigger_switch
// FIX: duplicates the spec decl.
type FIX_TriggerSwitch_Slice []TriggerSwitch

// implements typeinfo.Inspector
func (*TriggerSwitch_Slice) Inspect() typeinfo.T {
	return &Z_TriggerSwitch_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_While struct {
	True   rti.BoolEval
	Exe    rti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*While) Inspect() typeinfo.T {
	return &Z_While_Info
}

// return a valid markup map, creating it if necessary.
func (op *While) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// while, a type of flow.
const Z_While_Type = "while"

// ensure the command implements its specified slots:
var _ rti.Execute = (*While)(nil)

var Z_While_Info = typeinfo.Flow{
	Name: Z_While_Type,
	Lede: "repeating",
	Terms: []typeinfo.Term{{
		Name:  "true",
		Label: "_",
		Type:  &rti.Z_BoolEval_Info,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rti.Z_Execute_Info,
	}},
	Slots: []*typeinfo.Slot{
		&rti.Z_Execute_Info,
	},
	Markup: map[string]any{
		"comment": "Keep running a series of actions while a condition is true.",
	},
}

// holds a slice of type while
// FIX: duplicates the spec decl.
type FIX_While_Slice []While

// implements typeinfo.Inspector
func (*While_Slice) Inspect() typeinfo.T {
	return &Z_While_Info
}

// comparison, a type of str enum.
const Z_Comparison_Type = "comparison"

const (
	W_Comparison_EqualTo     = "$EQUAL_TO"
	W_Comparison_OtherThan   = "$OTHER_THAN"
	W_Comparison_GreaterThan = "$GREATER_THAN"
	W_Comparison_LessThan    = "$LESS_THAN"
	W_Comparison_AtLeast     = "$AT_LEAST"
	W_Comparison_AtMost      = "$AT_MOST"
)

var Z_Comparison_Info = typeinfo.Str{
	Name: Z_Comparison_Type,
	Options: []string{
		W_Comparison_EqualTo,
		W_Comparison_OtherThan,
		W_Comparison_GreaterThan,
		W_Comparison_LessThan,
		W_Comparison_AtLeast,
		W_Comparison_AtMost,
	},
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var Y_slot_List = []*typeinfo.Slot{
	&Z_Brancher_Info,
	&Z_Trigger_Info,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var Y_flow_List = []*typeinfo.Flow{
	&Z_AllTrue_Info,
	&Z_Always_Info,
	&Z_AnyTrue_Info,
	&Z_Blankline_Info,
	&Z_BracketText_Info,
	&Z_Break_Info,
	&Z_BufferText_Info,
	&Z_CallCycle_Info,
	&Z_CallShuffle_Info,
	&Z_CallTerminal_Info,
	&Z_CallTrigger_Info,
	&Z_Capitalize_Info,
	&Z_ChooseBranch_Info,
	&Z_ChooseNothingElse_Info,
	&Z_ChooseNum_Info,
	&Z_ChooseText_Info,
	&Z_CommaText_Info,
	&Z_CompareValue_Info,
	&Z_CompareNum_Info,
	&Z_CompareText_Info,
	&Z_SubtractValue_Info,
	&Z_During_Info,
	&Z_FieldsOfKind_Info,
	&Z_HasDominion_Info,
	&Z_IdOf_Info,
	&Z_Includes_Info,
	&Z_IsEmpty_Info,
	&Z_IsExactKindOf_Info,
	&Z_IsKindOf_Info,
	&Z_Join_Info,
	&Z_KindOf_Info,
	&Z_KindsOf_Info,
	&Z_MakeLowercase_Info,
	&Z_MakeReversed_Info,
	&Z_MakeSentenceCase_Info,
	&Z_MakeTitleCase_Info,
	&Z_MakeUppercase_Info,
	&Z_Matches_Info,
	&Z_NameOf_Info,
	&Z_Never_Info,
	&Z_Newline_Info,
	&Z_Continue_Info,
	&Z_Not_Info,
	&Z_ObjectExists_Info,
	&Z_ObjectTraits_Info,
	&Z_Pluralize_Info,
	&Z_PrintNum_Info,
	&Z_PrintNumWord_Info,
	&Z_MultiplyValue_Info,
	&Z_DivideValue_Info,
	&Z_ModValue_Info,
	&Z_AbsValue_Info,
	&Z_Increment_Info,
	&Z_Decrement_Info,
	&Z_IncrementAspect_Info,
	&Z_DecrementAspect_Info,
	&Z_PrintText_Info,
	&Z_Row_Info,
	&Z_Rows_Info,
	&Z_Singularize_Info,
	&Z_SlashText_Info,
	&Z_Softline_Info,
	&Z_SpanText_Info,
	&Z_AddValue_Info,
	&Z_TriggerCycle_Info,
	&Z_TriggerOnce_Info,
	&Z_TriggerSwitch_Info,
	&Z_While_Info,
}

// a list of all command signatures
// ( for processing and verifying story files )
var Z_Signatures = map[uint64]interface{}{}
