// Code generated by Tapestry; edit at your own risk.
package core

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// brancher, a type of slot.
var Zt_Brancher = typeinfo.Slot{
	Name: "brancher",
	Markup: map[string]any{
		"comment": "Helper for choose action.",
	},
}

// holds a single slot
// FIX: currently provided by the spec
type FIX_Brancher_Slot struct{ Value Brancher }

// implements typeinfo.Inspector for a single slot.
func (*FIX_Brancher_Slot) Inspect() (typeinfo.T, bool) {
	return &Zt_Brancher, false
}

// holds a slice of slots
type Brancher_Slots []Brancher

// implements typeinfo.Inspector for a series of slots.
func (*Brancher_Slots) Inspect() (typeinfo.T, bool) {
	return &Zt_Brancher, true
}

// trigger, a type of slot.
var Zt_Trigger = typeinfo.Slot{
	Name: "trigger",
	Markup: map[string]any{
		"comment": "Helper for counting values.",
	},
}

// holds a single slot
// FIX: currently provided by the spec
type FIX_Trigger_Slot struct{ Value Trigger }

// implements typeinfo.Inspector for a single slot.
func (*FIX_Trigger_Slot) Inspect() (typeinfo.T, bool) {
	return &Zt_Trigger, false
}

// holds a slice of slots
type Trigger_Slots []Trigger

// implements typeinfo.Inspector for a series of slots.
func (*Trigger_Slots) Inspect() (typeinfo.T, bool) {
	return &Zt_Trigger, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AllTrue struct {
	Test   rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AllTrue) Inspect() (typeinfo.T, bool) {
	return &Zt_AllTrue, false
}

// return a valid markup map, creating it if necessary.
func (op *AllTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*AllTrue)(nil)

// all_true, a type of flow.
var Zt_AllTrue = typeinfo.Flow{
	Name: "all_true",
	Lede: "all_true",
	Terms: []typeinfo.Term{{
		Name:    "test",
		Label:   "_",
		Repeats: true,
		Type:    &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "Returns true if all of the evaluations are true.",
	},
}

// holds a slice of type all_true
// FIX: duplicates the spec decl.
type FIX_AllTrue_Slice []AllTrue

// implements typeinfo.Inspector
func (*AllTrue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_AllTrue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Always struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Always) Inspect() (typeinfo.T, bool) {
	return &Zt_Always, false
}

// return a valid markup map, creating it if necessary.
func (op *Always) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Always)(nil)

// always, a type of flow.
var Zt_Always = typeinfo.Flow{
	Name:  "always",
	Lede:  "always",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "Returns true.",
	},
}

// holds a slice of type always
// FIX: duplicates the spec decl.
type FIX_Always_Slice []Always

// implements typeinfo.Inspector
func (*Always_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Always, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AnyTrue struct {
	Test   rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AnyTrue) Inspect() (typeinfo.T, bool) {
	return &Zt_AnyTrue, false
}

// return a valid markup map, creating it if necessary.
func (op *AnyTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*AnyTrue)(nil)

// any_true, a type of flow.
var Zt_AnyTrue = typeinfo.Flow{
	Name: "any_true",
	Lede: "any_true",
	Terms: []typeinfo.Term{{
		Name:    "test",
		Label:   "_",
		Repeats: true,
		Type:    &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "Returns true if any of the evaluations are true.",
	},
}

// holds a slice of type any_true
// FIX: duplicates the spec decl.
type FIX_AnyTrue_Slice []AnyTrue

// implements typeinfo.Inspector
func (*AnyTrue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_AnyTrue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Blankline struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Blankline) Inspect() (typeinfo.T, bool) {
	return &Zt_Blankline, false
}

// return a valid markup map, creating it if necessary.
func (op *Blankline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Blankline)(nil)

// blankline, a type of flow.
var Zt_Blankline = typeinfo.Flow{
	Name:  "blankline",
	Lede:  "p",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Add a single blank line following some text.",
	},
}

// holds a slice of type blankline
// FIX: duplicates the spec decl.
type FIX_Blankline_Slice []Blankline

// implements typeinfo.Inspector
func (*Blankline_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Blankline, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_BracketText struct {
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*BracketText) Inspect() (typeinfo.T, bool) {
	return &Zt_BracketText, false
}

// return a valid markup map, creating it if necessary.
func (op *BracketText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*BracketText)(nil)

// bracket_text, a type of flow.
var Zt_BracketText = typeinfo.Flow{
	Name: "bracket_text",
	Lede: "brackets",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Sandwiches text printed during a block and puts them inside parenthesis '()'.",
	},
}

// holds a slice of type bracket_text
// FIX: duplicates the spec decl.
type FIX_BracketText_Slice []BracketText

// implements typeinfo.Inspector
func (*BracketText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_BracketText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Break struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Break) Inspect() (typeinfo.T, bool) {
	return &Zt_Break, false
}

// return a valid markup map, creating it if necessary.
func (op *Break) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Break)(nil)

// break, a type of flow.
var Zt_Break = typeinfo.Flow{
	Name:  "break",
	Lede:  "break",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"In a repeating loop, exit the loop;", "or, in a rule, stop processing rules."},
	},
}

// holds a slice of type break
// FIX: duplicates the spec decl.
type FIX_Break_Slice []Break

// implements typeinfo.Inspector
func (*Break_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Break, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_BufferText struct {
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*BufferText) Inspect() (typeinfo.T, bool) {
	return &Zt_BufferText, false
}

// return a valid markup map, creating it if necessary.
func (op *BufferText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*BufferText)(nil)

// buffer_text, a type of flow.
var Zt_BufferText = typeinfo.Flow{
	Name: "buffer_text",
	Lede: "buffers",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
}

// holds a slice of type buffer_text
// FIX: duplicates the spec decl.
type FIX_BufferText_Slice []BufferText

// implements typeinfo.Inspector
func (*BufferText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_BufferText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallCycle struct {
	Name   string
	Parts  rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CallCycle) Inspect() (typeinfo.T, bool) {
	return &Zt_CallCycle, false
}

// return a valid markup map, creating it if necessary.
func (op *CallCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CallCycle)(nil)

// call_cycle, a type of flow.
var Zt_CallCycle = typeinfo.Flow{
	Name: "call_cycle",
	Lede: "cycle",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "parts",
		Label:   "over",
		Repeats: true,
		Type:    &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Runtime version of cycle_text.",
	},
}

// holds a slice of type call_cycle
// FIX: duplicates the spec decl.
type FIX_CallCycle_Slice []CallCycle

// implements typeinfo.Inspector
func (*CallCycle_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_CallCycle, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallShuffle struct {
	Name    string
	Parts   rtti.TextEval
	Indices Shuffler
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*CallShuffle) Inspect() (typeinfo.T, bool) {
	return &Zt_CallShuffle, false
}

// return a valid markup map, creating it if necessary.
func (op *CallShuffle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CallShuffle)(nil)

// call_shuffle, a type of flow.
var Zt_CallShuffle = typeinfo.Flow{
	Name: "call_shuffle",
	Lede: "shuffle",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "parts",
		Label:   "over",
		Repeats: true,
		Type:    &rtti.Zt_TextEval,
	}, {
		Name:    "indices",
		Label:   "indices",
		Private: true,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Runtime version of shuffle_text.",
	},
}

// holds a slice of type call_shuffle
// FIX: duplicates the spec decl.
type FIX_CallShuffle_Slice []CallShuffle

// implements typeinfo.Inspector
func (*CallShuffle_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_CallShuffle, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallTerminal struct {
	Name   string
	Parts  rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CallTerminal) Inspect() (typeinfo.T, bool) {
	return &Zt_CallTerminal, false
}

// return a valid markup map, creating it if necessary.
func (op *CallTerminal) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CallTerminal)(nil)

// call_terminal, a type of flow.
var Zt_CallTerminal = typeinfo.Flow{
	Name: "call_terminal",
	Lede: "stopping",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "parts",
		Label:   "over",
		Repeats: true,
		Type:    &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Runtime version of stopping_text.",
	},
}

// holds a slice of type call_terminal
// FIX: duplicates the spec decl.
type FIX_CallTerminal_Slice []CallTerminal

// implements typeinfo.Inspector
func (*CallTerminal_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_CallTerminal, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallTrigger struct {
	Name    string
	Trigger Trigger
	Num     rtti.NumberEval
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*CallTrigger) Inspect() (typeinfo.T, bool) {
	return &Zt_CallTrigger, false
}

// return a valid markup map, creating it if necessary.
func (op *CallTrigger) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CallTrigger)(nil)

// call_trigger, a type of flow.
var Zt_CallTrigger = typeinfo.Flow{
	Name: "call_trigger",
	Lede: "trigger",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &prim.Zt_Text,
	}, {
		Name:  "trigger",
		Label: "on",
		Type:  &Zt_Trigger,
	}, {
		Name:  "num",
		Label: "num",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "Runtime version of count_of.",
	},
}

// holds a slice of type call_trigger
// FIX: duplicates the spec decl.
type FIX_CallTrigger_Slice []CallTrigger

// implements typeinfo.Inspector
func (*CallTrigger_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_CallTrigger, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Capitalize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Capitalize) Inspect() (typeinfo.T, bool) {
	return &Zt_Capitalize, false
}

// return a valid markup map, creating it if necessary.
func (op *Capitalize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Capitalize)(nil)

// capitalize, a type of flow.
var Zt_Capitalize = typeinfo.Flow{
	Name: "capitalize",
	Lede: "capitalize",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns new text, with the first letter turned into uppercase.",
	},
}

// holds a slice of type capitalize
// FIX: duplicates the spec decl.
type FIX_Capitalize_Slice []Capitalize

// implements typeinfo.Inspector
func (*Capitalize_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Capitalize, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ChooseBranch struct {
	If     rtti.BoolEval
	Args   assign.Arg
	Exe    rtti.Execute
	Else   Brancher
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ChooseBranch) Inspect() (typeinfo.T, bool) {
	return &Zt_ChooseBranch, false
}

// return a valid markup map, creating it if necessary.
func (op *ChooseBranch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ChooseBranch)(nil)
var _ Brancher = (*ChooseBranch)(nil)

// choose_branch, a type of flow.
var Zt_ChooseBranch = typeinfo.Flow{
	Name: "choose_branch",
	Lede: "if",
	Terms: []typeinfo.Term{{
		Name:  "if",
		Label: "_",
		Type:  &rtti.Zt_BoolEval,
	}, {
		Name:     "args",
		Label:    "assuming",
		Optional: true,
		Repeats:  true,
		Type:     &assign.Zt_Arg,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}, {
		Name:     "else",
		Label:    "else",
		Optional: true,
		Type:     &Zt_Brancher,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
		&Zt_Brancher,
	},
	Markup: map[string]any{
		"comment": []interface{}{"An if statement.", "The provided local fields are evaluated before the if test itself."},
	},
}

// holds a slice of type choose_branch
// FIX: duplicates the spec decl.
type FIX_ChooseBranch_Slice []ChooseBranch

// implements typeinfo.Inspector
func (*ChooseBranch_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ChooseBranch, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ChooseNothingElse struct {
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ChooseNothingElse) Inspect() (typeinfo.T, bool) {
	return &Zt_ChooseNothingElse, false
}

// return a valid markup map, creating it if necessary.
func (op *ChooseNothingElse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Brancher = (*ChooseNothingElse)(nil)

// choose_nothing_else, a type of flow.
var Zt_ChooseNothingElse = typeinfo.Flow{
	Name: "choose_nothing_else",
	Lede: "finally",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_Brancher,
	},
}

// holds a slice of type choose_nothing_else
// FIX: duplicates the spec decl.
type FIX_ChooseNothingElse_Slice []ChooseNothingElse

// implements typeinfo.Inspector
func (*ChooseNothingElse_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ChooseNothingElse, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ChooseNum struct {
	If     rtti.BoolEval
	True   rtti.NumberEval
	False  rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ChooseNum) Inspect() (typeinfo.T, bool) {
	return &Zt_ChooseNum, false
}

// return a valid markup map, creating it if necessary.
func (op *ChooseNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*ChooseNum)(nil)

// choose_num, a type of flow.
var Zt_ChooseNum = typeinfo.Flow{
	Name: "choose_num",
	Lede: "num",
	Terms: []typeinfo.Term{{
		Name:  "if",
		Label: "if",
		Type:  &rtti.Zt_BoolEval,
	}, {
		Name:  "true",
		Label: "then",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:     "false",
		Label:    "else",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Pick one of two numbers based on a boolean test.",
	},
}

// holds a slice of type choose_num
// FIX: duplicates the spec decl.
type FIX_ChooseNum_Slice []ChooseNum

// implements typeinfo.Inspector
func (*ChooseNum_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ChooseNum, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ChooseText struct {
	If     rtti.BoolEval
	True   rtti.TextEval
	False  rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ChooseText) Inspect() (typeinfo.T, bool) {
	return &Zt_ChooseText, false
}

// return a valid markup map, creating it if necessary.
func (op *ChooseText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*ChooseText)(nil)

// choose_text, a type of flow.
var Zt_ChooseText = typeinfo.Flow{
	Name: "choose_text",
	Lede: "txt",
	Terms: []typeinfo.Term{{
		Name:  "if",
		Label: "if",
		Type:  &rtti.Zt_BoolEval,
	}, {
		Name:  "true",
		Label: "then",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "false",
		Label:    "else",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Pick one of two strings based on a boolean test.",
	},
}

// holds a slice of type choose_text
// FIX: duplicates the spec decl.
type FIX_ChooseText_Slice []ChooseText

// implements typeinfo.Inspector
func (*ChooseText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ChooseText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CommaText struct {
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CommaText) Inspect() (typeinfo.T, bool) {
	return &Zt_CommaText, false
}

// return a valid markup map, creating it if necessary.
func (op *CommaText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CommaText)(nil)

// comma_text, a type of flow.
var Zt_CommaText = typeinfo.Flow{
	Name: "comma_text",
	Lede: "commas",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Separates words with commas, and 'and'.",
	},
}

// holds a slice of type comma_text
// FIX: duplicates the spec decl.
type FIX_CommaText_Slice []CommaText

// implements typeinfo.Inspector
func (*CommaText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_CommaText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CompareValue struct {
	A      rtti.Assignment
	Is     string
	B      rtti.Assignment
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CompareValue) Inspect() (typeinfo.T, bool) {
	return &Zt_CompareValue, false
}

// return a valid markup map, creating it if necessary.
func (op *CompareValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CompareValue)(nil)

// compare_value, a type of flow.
var Zt_CompareValue = typeinfo.Flow{
	Name: "compare_value",
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rtti.Zt_Assignment,
	}, {
		Name:  "is",
		Label: "matching",
		Type:  &Zt_Comparison,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rtti.Zt_Assignment,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "True if eq,ne,gt,lt,ge,le two numbers.",
	},
}

// holds a slice of type compare_value
// FIX: duplicates the spec decl.
type FIX_CompareValue_Slice []CompareValue

// implements typeinfo.Inspector
func (*CompareValue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_CompareValue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CompareNum struct {
	A         rtti.NumberEval
	Is        string
	B         rtti.NumberEval
	Tolerance float64
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*CompareNum) Inspect() (typeinfo.T, bool) {
	return &Zt_CompareNum, false
}

// return a valid markup map, creating it if necessary.
func (op *CompareNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CompareNum)(nil)

// compare_num, a type of flow.
var Zt_CompareNum = typeinfo.Flow{
	Name: "compare_num",
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "is",
		Label: "matching",
		Type:  &Zt_Comparison,
	}, {
		Name:  "b",
		Label: "num",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:     "tolerance",
		Label:    "within",
		Optional: true,
		Type:     &prim.Zt_Number,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "True if eq,ne,gt,lt,ge,le two numbers.",
	},
}

// holds a slice of type compare_num
// FIX: duplicates the spec decl.
type FIX_CompareNum_Slice []CompareNum

// implements typeinfo.Inspector
func (*CompareNum_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_CompareNum, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CompareText struct {
	A      rtti.TextEval
	Is     string
	B      rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CompareText) Inspect() (typeinfo.T, bool) {
	return &Zt_CompareText, false
}

// return a valid markup map, creating it if necessary.
func (op *CompareText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CompareText)(nil)

// compare_text, a type of flow.
var Zt_CompareText = typeinfo.Flow{
	Name: "compare_text",
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "is",
		Label: "matching",
		Type:  &Zt_Comparison,
	}, {
		Name:  "b",
		Label: "text",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "True if eq,ne,gt,lt,ge,le two strings ( lexical. ).",
	},
}

// holds a slice of type compare_text
// FIX: duplicates the spec decl.
type FIX_CompareText_Slice []CompareText

// implements typeinfo.Inspector
func (*CompareText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_CompareText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SubtractValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*SubtractValue) Inspect() (typeinfo.T, bool) {
	return &Zt_SubtractValue, false
}

// return a valid markup map, creating it if necessary.
func (op *SubtractValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*SubtractValue)(nil)

// subtract_value, a type of flow.
var Zt_SubtractValue = typeinfo.Flow{
	Name: "subtract_value",
	Lede: "subtract",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Subtract two numbers.",
	},
}

// holds a slice of type subtract_value
// FIX: duplicates the spec decl.
type FIX_SubtractValue_Slice []SubtractValue

// implements typeinfo.Inspector
func (*SubtractValue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_SubtractValue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_During struct {
	PatternName string
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*During) Inspect() (typeinfo.T, bool) {
	return &Zt_During, false
}

// return a valid markup map, creating it if necessary.
func (op *During) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*During)(nil)
var _ rtti.NumberEval = (*During)(nil)

// during, a type of flow.
var Zt_During = typeinfo.Flow{
	Name: "during",
	Lede: "during",
	Terms: []typeinfo.Term{{
		Name:  "pattern_name",
		Label: "_",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Decide whether a pattern is running.",
	},
}

// holds a slice of type during
// FIX: duplicates the spec decl.
type FIX_During_Slice []During

// implements typeinfo.Inspector
func (*During_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_During, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_FieldsOfKind struct {
	KindName rtti.TextEval
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*FieldsOfKind) Inspect() (typeinfo.T, bool) {
	return &Zt_FieldsOfKind, false
}

// return a valid markup map, creating it if necessary.
func (op *FieldsOfKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextListEval = (*FieldsOfKind)(nil)

// fields_of_kind, a type of flow.
var Zt_FieldsOfKind = typeinfo.Flow{
	Name: "fields_of_kind",
	Lede: "fields",
	Terms: []typeinfo.Term{{
		Name:  "kind_name",
		Label: "of",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextListEval,
	},
	Markup: map[string]any{
		"comment": "List of the field names of a kind.",
	},
}

// holds a slice of type fields_of_kind
// FIX: duplicates the spec decl.
type FIX_FieldsOfKind_Slice []FieldsOfKind

// implements typeinfo.Inspector
func (*FieldsOfKind_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_FieldsOfKind, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_HasDominion struct {
	Name   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*HasDominion) Inspect() (typeinfo.T, bool) {
	return &Zt_HasDominion, false
}

// return a valid markup map, creating it if necessary.
func (op *HasDominion) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*HasDominion)(nil)

// has_dominion, a type of flow.
var Zt_HasDominion = typeinfo.Flow{
	Name: "has_dominion",
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "domain",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
}

// holds a slice of type has_dominion
// FIX: duplicates the spec decl.
type FIX_HasDominion_Slice []HasDominion

// implements typeinfo.Inspector
func (*HasDominion_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_HasDominion, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IdOf struct {
	Object rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*IdOf) Inspect() (typeinfo.T, bool) {
	return &Zt_IdOf, false
}

// return a valid markup map, creating it if necessary.
func (op *IdOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*IdOf)(nil)

// id_of, a type of flow.
var Zt_IdOf = typeinfo.Flow{
	Name: "id_of",
	Lede: "id_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "A unique object identifier.",
	},
}

// holds a slice of type id_of
// FIX: duplicates the spec decl.
type FIX_IdOf_Slice []IdOf

// implements typeinfo.Inspector
func (*IdOf_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_IdOf, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Includes struct {
	Text   rtti.TextEval
	Part   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Includes) Inspect() (typeinfo.T, bool) {
	return &Zt_Includes, false
}

// return a valid markup map, creating it if necessary.
func (op *Includes) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Includes)(nil)

// includes, a type of flow.
var Zt_Includes = typeinfo.Flow{
	Name: "includes",
	Lede: "contains",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "part",
		Label: "part",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "True if text contains text.",
	},
}

// holds a slice of type includes
// FIX: duplicates the spec decl.
type FIX_Includes_Slice []Includes

// implements typeinfo.Inspector
func (*Includes_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Includes, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IsEmpty struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*IsEmpty) Inspect() (typeinfo.T, bool) {
	return &Zt_IsEmpty, false
}

// return a valid markup map, creating it if necessary.
func (op *IsEmpty) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*IsEmpty)(nil)

// is_empty, a type of flow.
var Zt_IsEmpty = typeinfo.Flow{
	Name: "is_empty",
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "empty",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "True if the text is empty.",
	},
}

// holds a slice of type is_empty
// FIX: duplicates the spec decl.
type FIX_IsEmpty_Slice []IsEmpty

// implements typeinfo.Inspector
func (*IsEmpty_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_IsEmpty, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IsExactKindOf struct {
	Object rtti.TextEval
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*IsExactKindOf) Inspect() (typeinfo.T, bool) {
	return &Zt_IsExactKindOf, false
}

// return a valid markup map, creating it if necessary.
func (op *IsExactKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*IsExactKindOf)(nil)

// is_exact_kind_of, a type of flow.
var Zt_IsExactKindOf = typeinfo.Flow{
	Name: "is_exact_kind_of",
	Lede: "kind_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "kind",
		Label: "is_exactly",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "True if the object is exactly the named kind.",
	},
}

// holds a slice of type is_exact_kind_of
// FIX: duplicates the spec decl.
type FIX_IsExactKindOf_Slice []IsExactKindOf

// implements typeinfo.Inspector
func (*IsExactKindOf_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_IsExactKindOf, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IsKindOf struct {
	Object  rtti.TextEval
	Kind    string
	Nothing bool
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*IsKindOf) Inspect() (typeinfo.T, bool) {
	return &Zt_IsKindOf, false
}

// return a valid markup map, creating it if necessary.
func (op *IsKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*IsKindOf)(nil)

// is_kind_of, a type of flow.
var Zt_IsKindOf = typeinfo.Flow{
	Name: "is_kind_of",
	Lede: "kind_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "kind",
		Label: "is",
		Type:  &prim.Zt_Text,
	}, {
		Name:     "nothing",
		Label:    "nothing",
		Optional: true,
		Type:     &prim.Zt_Bool,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "True if the object is compatible with the named kind.",
	},
}

// holds a slice of type is_kind_of
// FIX: duplicates the spec decl.
type FIX_IsKindOf_Slice []IsKindOf

// implements typeinfo.Inspector
func (*IsKindOf_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_IsKindOf, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Join struct {
	Sep    rtti.TextEval
	Parts  rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Join) Inspect() (typeinfo.T, bool) {
	return &Zt_Join, false
}

// return a valid markup map, creating it if necessary.
func (op *Join) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Join)(nil)

// join, a type of flow.
var Zt_Join = typeinfo.Flow{
	Name: "join",
	Lede: "join",
	Terms: []typeinfo.Term{{
		Name:     "sep",
		Label:    "_",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:    "parts",
		Label:   "parts",
		Repeats: true,
		Type:    &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns multiple pieces of text as a single new piece of text.",
	},
}

// holds a slice of type join
// FIX: duplicates the spec decl.
type FIX_Join_Slice []Join

// implements typeinfo.Inspector
func (*Join_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Join, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_KindOf struct {
	Object  rtti.TextEval
	Nothing bool
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*KindOf) Inspect() (typeinfo.T, bool) {
	return &Zt_KindOf, false
}

// return a valid markup map, creating it if necessary.
func (op *KindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*KindOf)(nil)

// kind_of, a type of flow.
var Zt_KindOf = typeinfo.Flow{
	Name: "kind_of",
	Lede: "kind_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "nothing",
		Label:    "nothing",
		Optional: true,
		Type:     &prim.Zt_Bool,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Friendly name of the object's kind.",
	},
}

// holds a slice of type kind_of
// FIX: duplicates the spec decl.
type FIX_KindOf_Slice []KindOf

// implements typeinfo.Inspector
func (*KindOf_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_KindOf, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_KindsOf struct {
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*KindsOf) Inspect() (typeinfo.T, bool) {
	return &Zt_KindsOf, false
}

// return a valid markup map, creating it if necessary.
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextListEval = (*KindsOf)(nil)

// kinds_of, a type of flow.
var Zt_KindsOf = typeinfo.Flow{
	Name: "kinds_of",
	Lede: "kinds_of",
	Terms: []typeinfo.Term{{
		Name:  "kind",
		Label: "_",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextListEval,
	},
	Markup: map[string]any{
		"comment": "A list of compatible kinds.",
	},
}

// holds a slice of type kinds_of
// FIX: duplicates the spec decl.
type FIX_KindsOf_Slice []KindsOf

// implements typeinfo.Inspector
func (*KindsOf_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_KindsOf, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeLowercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeLowercase) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeLowercase, false
}

// return a valid markup map, creating it if necessary.
func (op *MakeLowercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeLowercase)(nil)

// make_lowercase, a type of flow.
var Zt_MakeLowercase = typeinfo.Flow{
	Name: "make_lowercase",
	Lede: "lower",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns new text, with every letter turned into lowercase. For example, 'shout' from 'SHOUT'.",
	},
}

// holds a slice of type make_lowercase
// FIX: duplicates the spec decl.
type FIX_MakeLowercase_Slice []MakeLowercase

// implements typeinfo.Inspector
func (*MakeLowercase_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeLowercase, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeReversed struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeReversed) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeReversed, false
}

// return a valid markup map, creating it if necessary.
func (op *MakeReversed) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeReversed)(nil)

// make_reversed, a type of flow.
var Zt_MakeReversed = typeinfo.Flow{
	Name: "make_reversed",
	Lede: "reverse",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "text",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns new text flipped back to front. For example, 'elppA' from 'Apple', or 'noon' from 'noon'.",
	},
}

// holds a slice of type make_reversed
// FIX: duplicates the spec decl.
type FIX_MakeReversed_Slice []MakeReversed

// implements typeinfo.Inspector
func (*MakeReversed_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeReversed, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeSentenceCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeSentenceCase) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeSentenceCase, false
}

// return a valid markup map, creating it if necessary.
func (op *MakeSentenceCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeSentenceCase)(nil)

// make_sentence_case, a type of flow.
var Zt_MakeSentenceCase = typeinfo.Flow{
	Name: "make_sentence_case",
	Lede: "sentence",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns new text, start each sentence with a capital letter. For example, 'Empire Apple.' from 'Empire apple.'.",
	},
}

// holds a slice of type make_sentence_case
// FIX: duplicates the spec decl.
type FIX_MakeSentenceCase_Slice []MakeSentenceCase

// implements typeinfo.Inspector
func (*MakeSentenceCase_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeSentenceCase, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeTitleCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeTitleCase) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeTitleCase, false
}

// return a valid markup map, creating it if necessary.
func (op *MakeTitleCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeTitleCase)(nil)

// make_title_case, a type of flow.
var Zt_MakeTitleCase = typeinfo.Flow{
	Name: "make_title_case",
	Lede: "title",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns new text, starting each word with a capital letter. For example, 'Empire Apple' from 'empire apple'.",
	},
}

// holds a slice of type make_title_case
// FIX: duplicates the spec decl.
type FIX_MakeTitleCase_Slice []MakeTitleCase

// implements typeinfo.Inspector
func (*MakeTitleCase_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeTitleCase, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeUppercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeUppercase) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeUppercase, false
}

// return a valid markup map, creating it if necessary.
func (op *MakeUppercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeUppercase)(nil)

// make_uppercase, a type of flow.
var Zt_MakeUppercase = typeinfo.Flow{
	Name: "make_uppercase",
	Lede: "upper",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns new text, with every letter turned into uppercase. For example, 'APPLE' from 'apple'.",
	},
}

// holds a slice of type make_uppercase
// FIX: duplicates the spec decl.
type FIX_MakeUppercase_Slice []MakeUppercase

// implements typeinfo.Inspector
func (*MakeUppercase_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeUppercase, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Matches struct {
	Text   rtti.TextEval
	Match  string
	Cache  MatchCache
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Matches) Inspect() (typeinfo.T, bool) {
	return &Zt_Matches, false
}

// return a valid markup map, creating it if necessary.
func (op *Matches) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Matches)(nil)

// matches, a type of flow.
var Zt_Matches = typeinfo.Flow{
	Name: "matches",
	Lede: "matches",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "match",
		Label: "to",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "cache",
		Label:   "cache",
		Private: true,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "Determine whether the specified text is similar to the specified regular expression.",
	},
}

// holds a slice of type matches
// FIX: duplicates the spec decl.
type FIX_Matches_Slice []Matches

// implements typeinfo.Inspector
func (*Matches_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Matches, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_NameOf struct {
	Object rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*NameOf) Inspect() (typeinfo.T, bool) {
	return &Zt_NameOf, false
}

// return a valid markup map, creating it if necessary.
func (op *NameOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*NameOf)(nil)

// name_of, a type of flow.
var Zt_NameOf = typeinfo.Flow{
	Name: "name_of",
	Lede: "name_of",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Full name of the object.",
	},
}

// holds a slice of type name_of
// FIX: duplicates the spec decl.
type FIX_NameOf_Slice []NameOf

// implements typeinfo.Inspector
func (*NameOf_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_NameOf, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Never struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Never) Inspect() (typeinfo.T, bool) {
	return &Zt_Never, false
}

// return a valid markup map, creating it if necessary.
func (op *Never) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Never)(nil)

// never, a type of flow.
var Zt_Never = typeinfo.Flow{
	Name:  "never",
	Lede:  "never",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "Returns false.",
	},
}

// holds a slice of type never
// FIX: duplicates the spec decl.
type FIX_Never_Slice []Never

// implements typeinfo.Inspector
func (*Never_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Never, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Newline struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Newline) Inspect() (typeinfo.T, bool) {
	return &Zt_Newline, false
}

// return a valid markup map, creating it if necessary.
func (op *Newline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Newline)(nil)

// newline, a type of flow.
var Zt_Newline = typeinfo.Flow{
	Name:  "newline",
	Lede:  "br",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Start a new line.",
	},
}

// holds a slice of type newline
// FIX: duplicates the spec decl.
type FIX_Newline_Slice []Newline

// implements typeinfo.Inspector
func (*Newline_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Newline, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Continue struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Continue) Inspect() (typeinfo.T, bool) {
	return &Zt_Continue, false
}

// return a valid markup map, creating it if necessary.
func (op *Continue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Continue)(nil)

// continue, a type of flow.
var Zt_Continue = typeinfo.Flow{
	Name:  "continue",
	Lede:  "continue",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"In a repeating loop, try the next iteration of the loop;", "or, in a rule, continue to the next rule."},
	},
}

// holds a slice of type continue
// FIX: duplicates the spec decl.
type FIX_Continue_Slice []Continue

// implements typeinfo.Inspector
func (*Continue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Continue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Not struct {
	Test   rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Not) Inspect() (typeinfo.T, bool) {
	return &Zt_Not, false
}

// return a valid markup map, creating it if necessary.
func (op *Not) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Not)(nil)

// not, a type of flow.
var Zt_Not = typeinfo.Flow{
	Name: "not",
	Lede: "not",
	Terms: []typeinfo.Term{{
		Name:  "test",
		Label: "_",
		Type:  &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "Returns the opposite value.",
	},
}

// holds a slice of type not
// FIX: duplicates the spec decl.
type FIX_Not_Slice []Not

// implements typeinfo.Inspector
func (*Not_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Not, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ObjectExists struct {
	Object rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ObjectExists) Inspect() (typeinfo.T, bool) {
	return &Zt_ObjectExists, false
}

// return a valid markup map, creating it if necessary.
func (op *ObjectExists) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*ObjectExists)(nil)

// object_exists, a type of flow.
var Zt_ObjectExists = typeinfo.Flow{
	Name: "object_exists",
	Lede: "is",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "valid",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": "Returns whether there is a object of the specified name.",
	},
}

// holds a slice of type object_exists
// FIX: duplicates the spec decl.
type FIX_ObjectExists_Slice []ObjectExists

// implements typeinfo.Inspector
func (*ObjectExists_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ObjectExists, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ObjectTraits struct {
	Object rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ObjectTraits) Inspect() (typeinfo.T, bool) {
	return &Zt_ObjectTraits, false
}

// return a valid markup map, creating it if necessary.
func (op *ObjectTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextListEval = (*ObjectTraits)(nil)

// object_traits, a type of flow.
var Zt_ObjectTraits = typeinfo.Flow{
	Name: "object_traits",
	Lede: "object",
	Terms: []typeinfo.Term{{
		Name:  "object",
		Label: "traits",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextListEval,
	},
	Markup: map[string]any{
		"comment": "Returns all of the object's current traits as a list of text.",
	},
}

// holds a slice of type object_traits
// FIX: duplicates the spec decl.
type FIX_ObjectTraits_Slice []ObjectTraits

// implements typeinfo.Inspector
func (*ObjectTraits_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ObjectTraits, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Pluralize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Pluralize) Inspect() (typeinfo.T, bool) {
	return &Zt_Pluralize, false
}

// return a valid markup map, creating it if necessary.
func (op *Pluralize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Pluralize)(nil)

// pluralize, a type of flow.
var Zt_Pluralize = typeinfo.Flow{
	Name: "pluralize",
	Lede: "plural",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "of",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns the plural form of a singular word. (ex. apples for apple. ).",
	},
}

// holds a slice of type pluralize
// FIX: duplicates the spec decl.
type FIX_Pluralize_Slice []Pluralize

// implements typeinfo.Inspector
func (*Pluralize_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Pluralize, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_PrintNum struct {
	Num    rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*PrintNum) Inspect() (typeinfo.T, bool) {
	return &Zt_PrintNum, false
}

// return a valid markup map, creating it if necessary.
func (op *PrintNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*PrintNum)(nil)

// print_num, a type of flow.
var Zt_PrintNum = typeinfo.Flow{
	Name: "print_num",
	Lede: "numeral",
	Terms: []typeinfo.Term{{
		Name:  "num",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Writes a number using numerals, eg. '1'.",
	},
}

// holds a slice of type print_num
// FIX: duplicates the spec decl.
type FIX_PrintNum_Slice []PrintNum

// implements typeinfo.Inspector
func (*PrintNum_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_PrintNum, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_PrintNumWord struct {
	Num    rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*PrintNumWord) Inspect() (typeinfo.T, bool) {
	return &Zt_PrintNumWord, false
}

// return a valid markup map, creating it if necessary.
func (op *PrintNumWord) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*PrintNumWord)(nil)

// print_num_word, a type of flow.
var Zt_PrintNumWord = typeinfo.Flow{
	Name: "print_num_word",
	Lede: "numeral",
	Terms: []typeinfo.Term{{
		Name:  "num",
		Label: "words",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Writes a number in plain english: eg. 'one'.",
	},
}

// holds a slice of type print_num_word
// FIX: duplicates the spec decl.
type FIX_PrintNumWord_Slice []PrintNumWord

// implements typeinfo.Inspector
func (*PrintNumWord_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_PrintNumWord, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MultiplyValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MultiplyValue) Inspect() (typeinfo.T, bool) {
	return &Zt_MultiplyValue, false
}

// return a valid markup map, creating it if necessary.
func (op *MultiplyValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*MultiplyValue)(nil)

// multiply_value, a type of flow.
var Zt_MultiplyValue = typeinfo.Flow{
	Name: "multiply_value",
	Lede: "multiply",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Multiply two numbers.",
	},
}

// holds a slice of type multiply_value
// FIX: duplicates the spec decl.
type FIX_MultiplyValue_Slice []MultiplyValue

// implements typeinfo.Inspector
func (*MultiplyValue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MultiplyValue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DivideValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DivideValue) Inspect() (typeinfo.T, bool) {
	return &Zt_DivideValue, false
}

// return a valid markup map, creating it if necessary.
func (op *DivideValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*DivideValue)(nil)

// divide_value, a type of flow.
var Zt_DivideValue = typeinfo.Flow{
	Name: "divide_value",
	Lede: "divide",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Divide one number by another.",
	},
}

// holds a slice of type divide_value
// FIX: duplicates the spec decl.
type FIX_DivideValue_Slice []DivideValue

// implements typeinfo.Inspector
func (*DivideValue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_DivideValue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ModValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ModValue) Inspect() (typeinfo.T, bool) {
	return &Zt_ModValue, false
}

// return a valid markup map, creating it if necessary.
func (op *ModValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*ModValue)(nil)

// mod_value, a type of flow.
var Zt_ModValue = typeinfo.Flow{
	Name: "mod_value",
	Lede: "mod",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Divide one number by another, and return the remainder.",
	},
}

// holds a slice of type mod_value
// FIX: duplicates the spec decl.
type FIX_ModValue_Slice []ModValue

// implements typeinfo.Inspector
func (*ModValue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ModValue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AbsValue struct {
	Value  rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AbsValue) Inspect() (typeinfo.T, bool) {
	return &Zt_AbsValue, false
}

// return a valid markup map, creating it if necessary.
func (op *AbsValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*AbsValue)(nil)

// abs_value, a type of flow.
var Zt_AbsValue = typeinfo.Flow{
	Name: "abs_value",
	Lede: "absolute",
	Terms: []typeinfo.Term{{
		Name:  "value",
		Label: "value",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
	},
}

// holds a slice of type abs_value
// FIX: duplicates the spec decl.
type FIX_AbsValue_Slice []AbsValue

// implements typeinfo.Inspector
func (*AbsValue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_AbsValue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Increment struct {
	Target assign.Address
	Step   rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Increment) Inspect() (typeinfo.T, bool) {
	return &Zt_Increment, false
}

// return a valid markup map, creating it if necessary.
func (op *Increment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*Increment)(nil)
var _ rtti.Execute = (*Increment)(nil)

// increment, a type of flow.
var Zt_Increment = typeinfo.Flow{
	Name: "increment",
	Lede: "increase",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:     "step",
		Label:    "by",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Increases the value of a number held in by a variable or object field.", "Returns the new value of the number."},
	},
}

// holds a slice of type increment
// FIX: duplicates the spec decl.
type FIX_Increment_Slice []Increment

// implements typeinfo.Inspector
func (*Increment_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Increment, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Decrement struct {
	Target assign.Address
	Step   rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Decrement) Inspect() (typeinfo.T, bool) {
	return &Zt_Decrement, false
}

// return a valid markup map, creating it if necessary.
func (op *Decrement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*Decrement)(nil)
var _ rtti.Execute = (*Decrement)(nil)

// decrement, a type of flow.
var Zt_Decrement = typeinfo.Flow{
	Name: "decrement",
	Lede: "decrease",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:     "step",
		Label:    "by",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Decrease the value of a number held in by a variable or object field.", "Returns the new value of the number."},
	},
}

// holds a slice of type decrement
// FIX: duplicates the spec decl.
type FIX_Decrement_Slice []Decrement

// implements typeinfo.Inspector
func (*Decrement_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Decrement, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_IncrementAspect struct {
	Target rtti.TextEval
	Aspect rtti.TextEval
	Step   rtti.NumberEval
	Clamp  rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*IncrementAspect) Inspect() (typeinfo.T, bool) {
	return &Zt_IncrementAspect, false
}

// return a valid markup map, creating it if necessary.
func (op *IncrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*IncrementAspect)(nil)
var _ rtti.Execute = (*IncrementAspect)(nil)

// increment_aspect, a type of flow.
var Zt_IncrementAspect = typeinfo.Flow{
	Name: "increment_aspect",
	Lede: "increase",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "aspect",
		Label: "aspect",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "step",
		Label:    "by",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}, {
		Name:     "clamp",
		Label:    "clamp",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Increases the value of a trait held by an object aspect.", "Returns the new value of the trait."},
	},
}

// holds a slice of type increment_aspect
// FIX: duplicates the spec decl.
type FIX_IncrementAspect_Slice []IncrementAspect

// implements typeinfo.Inspector
func (*IncrementAspect_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_IncrementAspect, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DecrementAspect struct {
	Target rtti.TextEval
	Aspect rtti.TextEval
	Step   rtti.NumberEval
	Clamp  rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DecrementAspect) Inspect() (typeinfo.T, bool) {
	return &Zt_DecrementAspect, false
}

// return a valid markup map, creating it if necessary.
func (op *DecrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*DecrementAspect)(nil)
var _ rtti.Execute = (*DecrementAspect)(nil)

// decrement_aspect, a type of flow.
var Zt_DecrementAspect = typeinfo.Flow{
	Name: "decrement_aspect",
	Lede: "decrease",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "aspect",
		Label: "aspect",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "step",
		Label:    "by",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}, {
		Name:     "clamp",
		Label:    "clamp",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Increases the value of a trait held by an object aspect.", "Returns the new value of the trait."},
	},
}

// holds a slice of type decrement_aspect
// FIX: duplicates the spec decl.
type FIX_DecrementAspect_Slice []DecrementAspect

// implements typeinfo.Inspector
func (*DecrementAspect_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_DecrementAspect, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_PrintText struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*PrintText) Inspect() (typeinfo.T, bool) {
	return &Zt_PrintText, false
}

// return a valid markup map, creating it if necessary.
func (op *PrintText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*PrintText)(nil)

// print_text, a type of flow.
var Zt_PrintText = typeinfo.Flow{
	Name: "print_text",
	Lede: "print",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Display some text to the player without apply any additional formatting.",
	},
}

// holds a slice of type print_text
// FIX: duplicates the spec decl.
type FIX_PrintText_Slice []PrintText

// implements typeinfo.Inspector
func (*PrintText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_PrintText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Row struct {
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Row) Inspect() (typeinfo.T, bool) {
	return &Zt_Row, false
}

// return a valid markup map, creating it if necessary.
func (op *Row) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Row)(nil)

// row, a type of flow.
var Zt_Row = typeinfo.Flow{
	Name: "row",
	Lede: "row",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Group text into a single line <li> as part of a list of lines.", "See also: 'rows'."},
	},
}

// holds a slice of type row
// FIX: duplicates the spec decl.
type FIX_Row_Slice []Row

// implements typeinfo.Inspector
func (*Row_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Row, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Rows struct {
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Rows) Inspect() (typeinfo.T, bool) {
	return &Zt_Rows, false
}

// return a valid markup map, creating it if necessary.
func (op *Rows) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Rows)(nil)

// rows, a type of flow.
var Zt_Rows = typeinfo.Flow{
	Name: "rows",
	Lede: "rows",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Group text into an unordered list <ul>.",
	},
}

// holds a slice of type rows
// FIX: duplicates the spec decl.
type FIX_Rows_Slice []Rows

// implements typeinfo.Inspector
func (*Rows_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Rows, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Singularize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Singularize) Inspect() (typeinfo.T, bool) {
	return &Zt_Singularize, false
}

// return a valid markup map, creating it if necessary.
func (op *Singularize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Singularize)(nil)

// singularize, a type of flow.
var Zt_Singularize = typeinfo.Flow{
	Name: "singularize",
	Lede: "singular",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "of",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Returns the singular form of a plural word. (ex. apple for apples ).",
	},
}

// holds a slice of type singularize
// FIX: duplicates the spec decl.
type FIX_Singularize_Slice []Singularize

// implements typeinfo.Inspector
func (*Singularize_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Singularize, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SlashText struct {
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*SlashText) Inspect() (typeinfo.T, bool) {
	return &Zt_SlashText, false
}

// return a valid markup map, creating it if necessary.
func (op *SlashText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*SlashText)(nil)

// slash_text, a type of flow.
var Zt_SlashText = typeinfo.Flow{
	Name: "slash_text",
	Lede: "slashes",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Separates words with left-leaning slashes '/'.",
	},
}

// holds a slice of type slash_text
// FIX: duplicates the spec decl.
type FIX_SlashText_Slice []SlashText

// implements typeinfo.Inspector
func (*SlashText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_SlashText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Softline struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Softline) Inspect() (typeinfo.T, bool) {
	return &Zt_Softline, false
}

// return a valid markup map, creating it if necessary.
func (op *Softline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Softline)(nil)

// softline, a type of flow.
var Zt_Softline = typeinfo.Flow{
	Name:  "softline",
	Lede:  "wbr",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Start a new line ( if not already at a new line. ).",
	},
}

// holds a slice of type softline
// FIX: duplicates the spec decl.
type FIX_Softline_Slice []Softline

// implements typeinfo.Inspector
func (*Softline_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Softline, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SpanText struct {
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*SpanText) Inspect() (typeinfo.T, bool) {
	return &Zt_SpanText, false
}

// return a valid markup map, creating it if necessary.
func (op *SpanText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*SpanText)(nil)

// span_text, a type of flow.
var Zt_SpanText = typeinfo.Flow{
	Name: "span_text",
	Lede: "spaces",
	Terms: []typeinfo.Term{{
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "Writes text with spaces between words.",
	},
}

// holds a slice of type span_text
// FIX: duplicates the spec decl.
type FIX_SpanText_Slice []SpanText

// implements typeinfo.Inspector
func (*SpanText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_SpanText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AddValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AddValue) Inspect() (typeinfo.T, bool) {
	return &Zt_AddValue, false
}

// return a valid markup map, creating it if necessary.
func (op *AddValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*AddValue)(nil)

// add_value, a type of flow.
var Zt_AddValue = typeinfo.Flow{
	Name: "add_value",
	Lede: "add",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "b",
		Label: "value",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Add two numbers.",
	},
}

// holds a slice of type add_value
// FIX: duplicates the spec decl.
type FIX_AddValue_Slice []AddValue

// implements typeinfo.Inspector
func (*AddValue_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_AddValue, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TriggerCycle struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*TriggerCycle) Inspect() (typeinfo.T, bool) {
	return &Zt_TriggerCycle, false
}

// return a valid markup map, creating it if necessary.
func (op *TriggerCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerCycle)(nil)

// trigger_cycle, a type of flow.
var Zt_TriggerCycle = typeinfo.Flow{
	Name:  "trigger_cycle",
	Lede:  "every",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&Zt_Trigger,
	},
}

// holds a slice of type trigger_cycle
// FIX: duplicates the spec decl.
type FIX_TriggerCycle_Slice []TriggerCycle

// implements typeinfo.Inspector
func (*TriggerCycle_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_TriggerCycle, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TriggerOnce struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*TriggerOnce) Inspect() (typeinfo.T, bool) {
	return &Zt_TriggerOnce, false
}

// return a valid markup map, creating it if necessary.
func (op *TriggerOnce) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerOnce)(nil)

// trigger_once, a type of flow.
var Zt_TriggerOnce = typeinfo.Flow{
	Name:  "trigger_once",
	Lede:  "at",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&Zt_Trigger,
	},
}

// holds a slice of type trigger_once
// FIX: duplicates the spec decl.
type FIX_TriggerOnce_Slice []TriggerOnce

// implements typeinfo.Inspector
func (*TriggerOnce_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_TriggerOnce, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TriggerSwitch struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*TriggerSwitch) Inspect() (typeinfo.T, bool) {
	return &Zt_TriggerSwitch, false
}

// return a valid markup map, creating it if necessary.
func (op *TriggerSwitch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerSwitch)(nil)

// trigger_switch, a type of flow.
var Zt_TriggerSwitch = typeinfo.Flow{
	Name:  "trigger_switch",
	Lede:  "after",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&Zt_Trigger,
	},
}

// holds a slice of type trigger_switch
// FIX: duplicates the spec decl.
type FIX_TriggerSwitch_Slice []TriggerSwitch

// implements typeinfo.Inspector
func (*TriggerSwitch_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_TriggerSwitch, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_While struct {
	True   rtti.BoolEval
	Exe    rtti.Execute
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*While) Inspect() (typeinfo.T, bool) {
	return &Zt_While, false
}

// return a valid markup map, creating it if necessary.
func (op *While) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*While)(nil)

// while, a type of flow.
var Zt_While = typeinfo.Flow{
	Name: "while",
	Lede: "repeating",
	Terms: []typeinfo.Term{{
		Name:  "true",
		Label: "_",
		Type:  &rtti.Zt_BoolEval,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Keep running a series of actions while a condition is true.",
	},
}

// holds a slice of type while
// FIX: duplicates the spec decl.
type FIX_While_Slice []While

// implements typeinfo.Inspector
func (*While_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_While, true
}

const (
	Zc_Comparison_EqualTo     = "equal_to"
	Zc_Comparison_OtherThan   = "other_than"
	Zc_Comparison_GreaterThan = "greater_than"
	Zc_Comparison_LessThan    = "less_than"
	Zc_Comparison_AtLeast     = "at_least"
	Zc_Comparison_AtMost      = "at_most"
)

// comparison, a type of str enum.
var Zt_Comparison = typeinfo.Str{
	Name: "comparison",
	Options: []string{
		Zc_Comparison_EqualTo,
		Zc_Comparison_OtherThan,
		Zc_Comparison_GreaterThan,
		Zc_Comparison_LessThan,
		Zc_Comparison_AtLeast,
		Zc_Comparison_AtMost,
	},
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "core",
	Slot: z_slot_list,
	Flow: z_flow_list,
	Str:  z_str_list,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Brancher,
	&Zt_Trigger,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_AllTrue,
	&Zt_Always,
	&Zt_AnyTrue,
	&Zt_Blankline,
	&Zt_BracketText,
	&Zt_Break,
	&Zt_BufferText,
	&Zt_CallCycle,
	&Zt_CallShuffle,
	&Zt_CallTerminal,
	&Zt_CallTrigger,
	&Zt_Capitalize,
	&Zt_ChooseBranch,
	&Zt_ChooseNothingElse,
	&Zt_ChooseNum,
	&Zt_ChooseText,
	&Zt_CommaText,
	&Zt_CompareValue,
	&Zt_CompareNum,
	&Zt_CompareText,
	&Zt_SubtractValue,
	&Zt_During,
	&Zt_FieldsOfKind,
	&Zt_HasDominion,
	&Zt_IdOf,
	&Zt_Includes,
	&Zt_IsEmpty,
	&Zt_IsExactKindOf,
	&Zt_IsKindOf,
	&Zt_Join,
	&Zt_KindOf,
	&Zt_KindsOf,
	&Zt_MakeLowercase,
	&Zt_MakeReversed,
	&Zt_MakeSentenceCase,
	&Zt_MakeTitleCase,
	&Zt_MakeUppercase,
	&Zt_Matches,
	&Zt_NameOf,
	&Zt_Never,
	&Zt_Newline,
	&Zt_Continue,
	&Zt_Not,
	&Zt_ObjectExists,
	&Zt_ObjectTraits,
	&Zt_Pluralize,
	&Zt_PrintNum,
	&Zt_PrintNumWord,
	&Zt_MultiplyValue,
	&Zt_DivideValue,
	&Zt_ModValue,
	&Zt_AbsValue,
	&Zt_Increment,
	&Zt_Decrement,
	&Zt_IncrementAspect,
	&Zt_DecrementAspect,
	&Zt_PrintText,
	&Zt_Row,
	&Zt_Rows,
	&Zt_Singularize,
	&Zt_SlashText,
	&Zt_Softline,
	&Zt_SpanText,
	&Zt_AddValue,
	&Zt_TriggerCycle,
	&Zt_TriggerOnce,
	&Zt_TriggerSwitch,
	&Zt_While,
}

// a list of all strs in this this package
var z_str_list = []*typeinfo.Str{
	&Zt_Comparison,
}
