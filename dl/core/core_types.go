// core
package core

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// brancher, a type of slot.
var Zt_Brancher = typeinfo.Slot{
	Name: "brancher",
	Markup: map[string]any{
		"comment": "Helper for choose action.",
	},
}

// holds a single slot.
type Brancher_Slot struct{ Value Brancher }

// implements typeinfo.Instance for a single slot.
func (*Brancher_Slot) TypeInfo() typeinfo.T {
	return &Zt_Brancher
}

// holds a slice of slots.
type Brancher_Slots []Brancher

// implements typeinfo.Instance for a series of slots.
func (*Brancher_Slots) TypeInfo() typeinfo.T {
	return &Zt_Brancher
}

// implements typeinfo.Repeats
func (op *Brancher_Slots) Repeats() bool {
	return len(*op) > 0
}

// trigger, a type of slot.
var Zt_Trigger = typeinfo.Slot{
	Name: "trigger",
	Markup: map[string]any{
		"comment": "Helper for counting values.",
	},
}

// holds a single slot.
type Trigger_Slot struct{ Value Trigger }

// implements typeinfo.Instance for a single slot.
func (*Trigger_Slot) TypeInfo() typeinfo.T {
	return &Zt_Trigger
}

// holds a slice of slots.
type Trigger_Slots []Trigger

// implements typeinfo.Instance for a series of slots.
func (*Trigger_Slots) TypeInfo() typeinfo.T {
	return &Zt_Trigger
}

// implements typeinfo.Repeats
func (op *Trigger_Slots) Repeats() bool {
	return len(*op) > 0
}

// Returns true if all of the evaluations are true.
type AllTrue struct {
	Test   []rtti.BoolEval
	Markup map[string]any
}

// all_true, a type of flow.
var Zt_AllTrue typeinfo.Flow

// implements typeinfo.Instance
func (*AllTrue) TypeInfo() typeinfo.T {
	return &Zt_AllTrue
}

// implements typeinfo.Markup
func (op *AllTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*AllTrue)(nil)

// holds a slice of type all_true
type AllTrue_Slice []AllTrue

// implements typeinfo.Instance
func (*AllTrue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AllTrue
}

// implements typeinfo.Repeats
func (op *AllTrue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns true.
type Always struct {
	Markup map[string]any
}

// always, a type of flow.
var Zt_Always typeinfo.Flow

// implements typeinfo.Instance
func (*Always) TypeInfo() typeinfo.T {
	return &Zt_Always
}

// implements typeinfo.Markup
func (op *Always) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Always)(nil)

// holds a slice of type always
type Always_Slice []Always

// implements typeinfo.Instance
func (*Always_Slice) TypeInfo() typeinfo.T {
	return &Zt_Always
}

// implements typeinfo.Repeats
func (op *Always_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns true if any of the evaluations are true.
type AnyTrue struct {
	Test   []rtti.BoolEval
	Markup map[string]any
}

// any_true, a type of flow.
var Zt_AnyTrue typeinfo.Flow

// implements typeinfo.Instance
func (*AnyTrue) TypeInfo() typeinfo.T {
	return &Zt_AnyTrue
}

// implements typeinfo.Markup
func (op *AnyTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*AnyTrue)(nil)

// holds a slice of type any_true
type AnyTrue_Slice []AnyTrue

// implements typeinfo.Instance
func (*AnyTrue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AnyTrue
}

// implements typeinfo.Repeats
func (op *AnyTrue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Add a single blank line following some text.
type Blankline struct {
	Markup map[string]any
}

// blankline, a type of flow.
var Zt_Blankline typeinfo.Flow

// implements typeinfo.Instance
func (*Blankline) TypeInfo() typeinfo.T {
	return &Zt_Blankline
}

// implements typeinfo.Markup
func (op *Blankline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Blankline)(nil)

// holds a slice of type blankline
type Blankline_Slice []Blankline

// implements typeinfo.Instance
func (*Blankline_Slice) TypeInfo() typeinfo.T {
	return &Zt_Blankline
}

// implements typeinfo.Repeats
func (op *Blankline_Slice) Repeats() bool {
	return len(*op) > 0
}

// Sandwiches text printed during a block and puts them inside parenthesis '()'.
type BracketText struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// bracket_text, a type of flow.
var Zt_BracketText typeinfo.Flow

// implements typeinfo.Instance
func (*BracketText) TypeInfo() typeinfo.T {
	return &Zt_BracketText
}

// implements typeinfo.Markup
func (op *BracketText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*BracketText)(nil)

// holds a slice of type bracket_text
type BracketText_Slice []BracketText

// implements typeinfo.Instance
func (*BracketText_Slice) TypeInfo() typeinfo.T {
	return &Zt_BracketText
}

// implements typeinfo.Repeats
func (op *BracketText_Slice) Repeats() bool {
	return len(*op) > 0
}

// In a repeating loop, exit the loop;
// or, in a rule, stop processing rules.
type Break struct {
	Markup map[string]any
}

// break, a type of flow.
var Zt_Break typeinfo.Flow

// implements typeinfo.Instance
func (*Break) TypeInfo() typeinfo.T {
	return &Zt_Break
}

// implements typeinfo.Markup
func (op *Break) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Break)(nil)

// holds a slice of type break
type Break_Slice []Break

// implements typeinfo.Instance
func (*Break_Slice) TypeInfo() typeinfo.T {
	return &Zt_Break
}

// implements typeinfo.Repeats
func (op *Break_Slice) Repeats() bool {
	return len(*op) > 0
}

type BufferText struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// buffer_text, a type of flow.
var Zt_BufferText typeinfo.Flow

// implements typeinfo.Instance
func (*BufferText) TypeInfo() typeinfo.T {
	return &Zt_BufferText
}

// implements typeinfo.Markup
func (op *BufferText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*BufferText)(nil)

// holds a slice of type buffer_text
type BufferText_Slice []BufferText

// implements typeinfo.Instance
func (*BufferText_Slice) TypeInfo() typeinfo.T {
	return &Zt_BufferText
}

// implements typeinfo.Repeats
func (op *BufferText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of cycle_text.
type CallCycle struct {
	Name   string
	Parts  []rtti.TextEval
	Markup map[string]any
}

// call_cycle, a type of flow.
var Zt_CallCycle typeinfo.Flow

// implements typeinfo.Instance
func (*CallCycle) TypeInfo() typeinfo.T {
	return &Zt_CallCycle
}

// implements typeinfo.Markup
func (op *CallCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CallCycle)(nil)

// holds a slice of type call_cycle
type CallCycle_Slice []CallCycle

// implements typeinfo.Instance
func (*CallCycle_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallCycle
}

// implements typeinfo.Repeats
func (op *CallCycle_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of shuffle_text.
type CallShuffle struct {
	Name    string
	Parts   []rtti.TextEval
	Indices Shuffler
	Markup  map[string]any
}

// call_shuffle, a type of flow.
var Zt_CallShuffle typeinfo.Flow

// implements typeinfo.Instance
func (*CallShuffle) TypeInfo() typeinfo.T {
	return &Zt_CallShuffle
}

// implements typeinfo.Markup
func (op *CallShuffle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CallShuffle)(nil)

// holds a slice of type call_shuffle
type CallShuffle_Slice []CallShuffle

// implements typeinfo.Instance
func (*CallShuffle_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallShuffle
}

// implements typeinfo.Repeats
func (op *CallShuffle_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of stopping_text.
type CallTerminal struct {
	Name   string
	Parts  []rtti.TextEval
	Markup map[string]any
}

// call_terminal, a type of flow.
var Zt_CallTerminal typeinfo.Flow

// implements typeinfo.Instance
func (*CallTerminal) TypeInfo() typeinfo.T {
	return &Zt_CallTerminal
}

// implements typeinfo.Markup
func (op *CallTerminal) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CallTerminal)(nil)

// holds a slice of type call_terminal
type CallTerminal_Slice []CallTerminal

// implements typeinfo.Instance
func (*CallTerminal_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallTerminal
}

// implements typeinfo.Repeats
func (op *CallTerminal_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of count_of.
type CallTrigger struct {
	Name    string
	Trigger Trigger
	Num     rtti.NumberEval
	Markup  map[string]any
}

// call_trigger, a type of flow.
var Zt_CallTrigger typeinfo.Flow

// implements typeinfo.Instance
func (*CallTrigger) TypeInfo() typeinfo.T {
	return &Zt_CallTrigger
}

// implements typeinfo.Markup
func (op *CallTrigger) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CallTrigger)(nil)

// holds a slice of type call_trigger
type CallTrigger_Slice []CallTrigger

// implements typeinfo.Instance
func (*CallTrigger_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallTrigger
}

// implements typeinfo.Repeats
func (op *CallTrigger_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, with the first letter turned into uppercase.
type Capitalize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// capitalize, a type of flow.
var Zt_Capitalize typeinfo.Flow

// implements typeinfo.Instance
func (*Capitalize) TypeInfo() typeinfo.T {
	return &Zt_Capitalize
}

// implements typeinfo.Markup
func (op *Capitalize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Capitalize)(nil)

// holds a slice of type capitalize
type Capitalize_Slice []Capitalize

// implements typeinfo.Instance
func (*Capitalize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Capitalize
}

// implements typeinfo.Repeats
func (op *Capitalize_Slice) Repeats() bool {
	return len(*op) > 0
}

// An if statement.
// The provided local fields are evaluated before the if test itself.
type ChooseBranch struct {
	If     rtti.BoolEval
	Args   []assign.Arg
	Exe    []rtti.Execute
	Else   Brancher
	Markup map[string]any
}

// choose_branch, a type of flow.
var Zt_ChooseBranch typeinfo.Flow

// implements typeinfo.Instance
func (*ChooseBranch) TypeInfo() typeinfo.T {
	return &Zt_ChooseBranch
}

// implements typeinfo.Markup
func (op *ChooseBranch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ChooseBranch)(nil)
var _ Brancher = (*ChooseBranch)(nil)

// holds a slice of type choose_branch
type ChooseBranch_Slice []ChooseBranch

// implements typeinfo.Instance
func (*ChooseBranch_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseBranch
}

// implements typeinfo.Repeats
func (op *ChooseBranch_Slice) Repeats() bool {
	return len(*op) > 0
}

type ChooseNothingElse struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// choose_nothing_else, a type of flow.
var Zt_ChooseNothingElse typeinfo.Flow

// implements typeinfo.Instance
func (*ChooseNothingElse) TypeInfo() typeinfo.T {
	return &Zt_ChooseNothingElse
}

// implements typeinfo.Markup
func (op *ChooseNothingElse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Brancher = (*ChooseNothingElse)(nil)

// holds a slice of type choose_nothing_else
type ChooseNothingElse_Slice []ChooseNothingElse

// implements typeinfo.Instance
func (*ChooseNothingElse_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseNothingElse
}

// implements typeinfo.Repeats
func (op *ChooseNothingElse_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pick one of two numbers based on a boolean test.
type ChooseNum struct {
	If     rtti.BoolEval
	True   rtti.NumberEval
	False  rtti.NumberEval
	Markup map[string]any
}

// choose_num, a type of flow.
var Zt_ChooseNum typeinfo.Flow

// implements typeinfo.Instance
func (*ChooseNum) TypeInfo() typeinfo.T {
	return &Zt_ChooseNum
}

// implements typeinfo.Markup
func (op *ChooseNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*ChooseNum)(nil)

// holds a slice of type choose_num
type ChooseNum_Slice []ChooseNum

// implements typeinfo.Instance
func (*ChooseNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseNum
}

// implements typeinfo.Repeats
func (op *ChooseNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pick one of two strings based on a boolean test.
type ChooseText struct {
	If     rtti.BoolEval
	True   rtti.TextEval
	False  rtti.TextEval
	Markup map[string]any
}

// choose_text, a type of flow.
var Zt_ChooseText typeinfo.Flow

// implements typeinfo.Instance
func (*ChooseText) TypeInfo() typeinfo.T {
	return &Zt_ChooseText
}

// implements typeinfo.Markup
func (op *ChooseText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*ChooseText)(nil)

// holds a slice of type choose_text
type ChooseText_Slice []ChooseText

// implements typeinfo.Instance
func (*ChooseText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseText
}

// implements typeinfo.Repeats
func (op *ChooseText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Separates words with commas, and 'and'.
type CommaText struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// comma_text, a type of flow.
var Zt_CommaText typeinfo.Flow

// implements typeinfo.Instance
func (*CommaText) TypeInfo() typeinfo.T {
	return &Zt_CommaText
}

// implements typeinfo.Markup
func (op *CommaText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CommaText)(nil)

// holds a slice of type comma_text
type CommaText_Slice []CommaText

// implements typeinfo.Instance
func (*CommaText_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaText
}

// implements typeinfo.Repeats
func (op *CommaText_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if eq,ne,gt,lt,ge,le two numbers.
type CompareValue struct {
	A      rtti.Assignment
	Is     Comparison
	B      rtti.Assignment
	Markup map[string]any
}

// compare_value, a type of flow.
var Zt_CompareValue typeinfo.Flow

// implements typeinfo.Instance
func (*CompareValue) TypeInfo() typeinfo.T {
	return &Zt_CompareValue
}

// implements typeinfo.Markup
func (op *CompareValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CompareValue)(nil)

// holds a slice of type compare_value
type CompareValue_Slice []CompareValue

// implements typeinfo.Instance
func (*CompareValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareValue
}

// implements typeinfo.Repeats
func (op *CompareValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if eq,ne,gt,lt,ge,le two numbers.
type CompareNum struct {
	A         rtti.NumberEval
	Is        Comparison
	B         rtti.NumberEval
	Tolerance float64
	Markup    map[string]any
}

// compare_num, a type of flow.
var Zt_CompareNum typeinfo.Flow

// implements typeinfo.Instance
func (*CompareNum) TypeInfo() typeinfo.T {
	return &Zt_CompareNum
}

// implements typeinfo.Markup
func (op *CompareNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CompareNum)(nil)

// holds a slice of type compare_num
type CompareNum_Slice []CompareNum

// implements typeinfo.Instance
func (*CompareNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareNum
}

// implements typeinfo.Repeats
func (op *CompareNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if eq,ne,gt,lt,ge,le two strings ( lexical. ).
type CompareText struct {
	A      rtti.TextEval
	Is     Comparison
	B      rtti.TextEval
	Markup map[string]any
}

// compare_text, a type of flow.
var Zt_CompareText typeinfo.Flow

// implements typeinfo.Instance
func (*CompareText) TypeInfo() typeinfo.T {
	return &Zt_CompareText
}

// implements typeinfo.Markup
func (op *CompareText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CompareText)(nil)

// holds a slice of type compare_text
type CompareText_Slice []CompareText

// implements typeinfo.Instance
func (*CompareText_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareText
}

// implements typeinfo.Repeats
func (op *CompareText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Subtract two numbers.
type SubtractValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// subtract_value, a type of flow.
var Zt_SubtractValue typeinfo.Flow

// implements typeinfo.Instance
func (*SubtractValue) TypeInfo() typeinfo.T {
	return &Zt_SubtractValue
}

// implements typeinfo.Markup
func (op *SubtractValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*SubtractValue)(nil)

// holds a slice of type subtract_value
type SubtractValue_Slice []SubtractValue

// implements typeinfo.Instance
func (*SubtractValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_SubtractValue
}

// implements typeinfo.Repeats
func (op *SubtractValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Decide whether a pattern is running.
type During struct {
	PatternName string
	Markup      map[string]any
}

// during, a type of flow.
var Zt_During typeinfo.Flow

// implements typeinfo.Instance
func (*During) TypeInfo() typeinfo.T {
	return &Zt_During
}

// implements typeinfo.Markup
func (op *During) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*During)(nil)
var _ rtti.NumberEval = (*During)(nil)

// holds a slice of type during
type During_Slice []During

// implements typeinfo.Instance
func (*During_Slice) TypeInfo() typeinfo.T {
	return &Zt_During
}

// implements typeinfo.Repeats
func (op *During_Slice) Repeats() bool {
	return len(*op) > 0
}

// List of the field names of a kind.
type FieldsOfKind struct {
	KindName rtti.TextEval
	Markup   map[string]any
}

// fields_of_kind, a type of flow.
var Zt_FieldsOfKind typeinfo.Flow

// implements typeinfo.Instance
func (*FieldsOfKind) TypeInfo() typeinfo.T {
	return &Zt_FieldsOfKind
}

// implements typeinfo.Markup
func (op *FieldsOfKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextListEval = (*FieldsOfKind)(nil)

// holds a slice of type fields_of_kind
type FieldsOfKind_Slice []FieldsOfKind

// implements typeinfo.Instance
func (*FieldsOfKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_FieldsOfKind
}

// implements typeinfo.Repeats
func (op *FieldsOfKind_Slice) Repeats() bool {
	return len(*op) > 0
}

type HasDominion struct {
	Name   string
	Markup map[string]any
}

// has_dominion, a type of flow.
var Zt_HasDominion typeinfo.Flow

// implements typeinfo.Instance
func (*HasDominion) TypeInfo() typeinfo.T {
	return &Zt_HasDominion
}

// implements typeinfo.Markup
func (op *HasDominion) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*HasDominion)(nil)

// holds a slice of type has_dominion
type HasDominion_Slice []HasDominion

// implements typeinfo.Instance
func (*HasDominion_Slice) TypeInfo() typeinfo.T {
	return &Zt_HasDominion
}

// implements typeinfo.Repeats
func (op *HasDominion_Slice) Repeats() bool {
	return len(*op) > 0
}

// A unique object identifier.
type IdOf struct {
	Object rtti.TextEval
	Markup map[string]any
}

// id_of, a type of flow.
var Zt_IdOf typeinfo.Flow

// implements typeinfo.Instance
func (*IdOf) TypeInfo() typeinfo.T {
	return &Zt_IdOf
}

// implements typeinfo.Markup
func (op *IdOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*IdOf)(nil)

// holds a slice of type id_of
type IdOf_Slice []IdOf

// implements typeinfo.Instance
func (*IdOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_IdOf
}

// implements typeinfo.Repeats
func (op *IdOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if text contains text.
type Includes struct {
	Text   rtti.TextEval
	Part   rtti.TextEval
	Markup map[string]any
}

// includes, a type of flow.
var Zt_Includes typeinfo.Flow

// implements typeinfo.Instance
func (*Includes) TypeInfo() typeinfo.T {
	return &Zt_Includes
}

// implements typeinfo.Markup
func (op *Includes) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Includes)(nil)

// holds a slice of type includes
type Includes_Slice []Includes

// implements typeinfo.Instance
func (*Includes_Slice) TypeInfo() typeinfo.T {
	return &Zt_Includes
}

// implements typeinfo.Repeats
func (op *Includes_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if the text is empty.
type IsEmpty struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// is_empty, a type of flow.
var Zt_IsEmpty typeinfo.Flow

// implements typeinfo.Instance
func (*IsEmpty) TypeInfo() typeinfo.T {
	return &Zt_IsEmpty
}

// implements typeinfo.Markup
func (op *IsEmpty) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*IsEmpty)(nil)

// holds a slice of type is_empty
type IsEmpty_Slice []IsEmpty

// implements typeinfo.Instance
func (*IsEmpty_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsEmpty
}

// implements typeinfo.Repeats
func (op *IsEmpty_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if the object is exactly the named kind.
type IsExactKindOf struct {
	Object rtti.TextEval
	Kind   string
	Markup map[string]any
}

// is_exact_kind_of, a type of flow.
var Zt_IsExactKindOf typeinfo.Flow

// implements typeinfo.Instance
func (*IsExactKindOf) TypeInfo() typeinfo.T {
	return &Zt_IsExactKindOf
}

// implements typeinfo.Markup
func (op *IsExactKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*IsExactKindOf)(nil)

// holds a slice of type is_exact_kind_of
type IsExactKindOf_Slice []IsExactKindOf

// implements typeinfo.Instance
func (*IsExactKindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsExactKindOf
}

// implements typeinfo.Repeats
func (op *IsExactKindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if the object is compatible with the named kind.
type IsKindOf struct {
	Object  rtti.TextEval
	Kind    string
	Nothing bool
	Markup  map[string]any
}

// is_kind_of, a type of flow.
var Zt_IsKindOf typeinfo.Flow

// implements typeinfo.Instance
func (*IsKindOf) TypeInfo() typeinfo.T {
	return &Zt_IsKindOf
}

// implements typeinfo.Markup
func (op *IsKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*IsKindOf)(nil)

// holds a slice of type is_kind_of
type IsKindOf_Slice []IsKindOf

// implements typeinfo.Instance
func (*IsKindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsKindOf
}

// implements typeinfo.Repeats
func (op *IsKindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns multiple pieces of text as a single new piece of text.
type Join struct {
	Sep    rtti.TextEval
	Parts  []rtti.TextEval
	Markup map[string]any
}

// join, a type of flow.
var Zt_Join typeinfo.Flow

// implements typeinfo.Instance
func (*Join) TypeInfo() typeinfo.T {
	return &Zt_Join
}

// implements typeinfo.Markup
func (op *Join) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Join)(nil)

// holds a slice of type join
type Join_Slice []Join

// implements typeinfo.Instance
func (*Join_Slice) TypeInfo() typeinfo.T {
	return &Zt_Join
}

// implements typeinfo.Repeats
func (op *Join_Slice) Repeats() bool {
	return len(*op) > 0
}

// Friendly name of the object's kind.
type KindOf struct {
	Object  rtti.TextEval
	Nothing bool
	Markup  map[string]any
}

// kind_of, a type of flow.
var Zt_KindOf typeinfo.Flow

// implements typeinfo.Instance
func (*KindOf) TypeInfo() typeinfo.T {
	return &Zt_KindOf
}

// implements typeinfo.Markup
func (op *KindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*KindOf)(nil)

// holds a slice of type kind_of
type KindOf_Slice []KindOf

// implements typeinfo.Instance
func (*KindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindOf
}

// implements typeinfo.Repeats
func (op *KindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// A list of compatible kinds.
type KindsOf struct {
	Kind   string
	Markup map[string]any
}

// kinds_of, a type of flow.
var Zt_KindsOf typeinfo.Flow

// implements typeinfo.Instance
func (*KindsOf) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Markup
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextListEval = (*KindsOf)(nil)

// holds a slice of type kinds_of
type KindsOf_Slice []KindsOf

// implements typeinfo.Instance
func (*KindsOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Repeats
func (op *KindsOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, with every letter turned into lowercase. For example, 'shout' from 'SHOUT'.
type MakeLowercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_lowercase, a type of flow.
var Zt_MakeLowercase typeinfo.Flow

// implements typeinfo.Instance
func (*MakeLowercase) TypeInfo() typeinfo.T {
	return &Zt_MakeLowercase
}

// implements typeinfo.Markup
func (op *MakeLowercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeLowercase)(nil)

// holds a slice of type make_lowercase
type MakeLowercase_Slice []MakeLowercase

// implements typeinfo.Instance
func (*MakeLowercase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeLowercase
}

// implements typeinfo.Repeats
func (op *MakeLowercase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text flipped back to front. For example, 'elppA' from 'Apple', or 'noon' from 'noon'.
type MakeReversed struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_reversed, a type of flow.
var Zt_MakeReversed typeinfo.Flow

// implements typeinfo.Instance
func (*MakeReversed) TypeInfo() typeinfo.T {
	return &Zt_MakeReversed
}

// implements typeinfo.Markup
func (op *MakeReversed) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeReversed)(nil)

// holds a slice of type make_reversed
type MakeReversed_Slice []MakeReversed

// implements typeinfo.Instance
func (*MakeReversed_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeReversed
}

// implements typeinfo.Repeats
func (op *MakeReversed_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, start each sentence with a capital letter. For example, 'Empire Apple.' from 'Empire apple.'.
type MakeSentenceCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_sentence_case, a type of flow.
var Zt_MakeSentenceCase typeinfo.Flow

// implements typeinfo.Instance
func (*MakeSentenceCase) TypeInfo() typeinfo.T {
	return &Zt_MakeSentenceCase
}

// implements typeinfo.Markup
func (op *MakeSentenceCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeSentenceCase)(nil)

// holds a slice of type make_sentence_case
type MakeSentenceCase_Slice []MakeSentenceCase

// implements typeinfo.Instance
func (*MakeSentenceCase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeSentenceCase
}

// implements typeinfo.Repeats
func (op *MakeSentenceCase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, starting each word with a capital letter. For example, 'Empire Apple' from 'empire apple'.
type MakeTitleCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_title_case, a type of flow.
var Zt_MakeTitleCase typeinfo.Flow

// implements typeinfo.Instance
func (*MakeTitleCase) TypeInfo() typeinfo.T {
	return &Zt_MakeTitleCase
}

// implements typeinfo.Markup
func (op *MakeTitleCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeTitleCase)(nil)

// holds a slice of type make_title_case
type MakeTitleCase_Slice []MakeTitleCase

// implements typeinfo.Instance
func (*MakeTitleCase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeTitleCase
}

// implements typeinfo.Repeats
func (op *MakeTitleCase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, with every letter turned into uppercase. For example, 'APPLE' from 'apple'.
type MakeUppercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_uppercase, a type of flow.
var Zt_MakeUppercase typeinfo.Flow

// implements typeinfo.Instance
func (*MakeUppercase) TypeInfo() typeinfo.T {
	return &Zt_MakeUppercase
}

// implements typeinfo.Markup
func (op *MakeUppercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*MakeUppercase)(nil)

// holds a slice of type make_uppercase
type MakeUppercase_Slice []MakeUppercase

// implements typeinfo.Instance
func (*MakeUppercase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeUppercase
}

// implements typeinfo.Repeats
func (op *MakeUppercase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether the specified text is similar to the specified regular expression.
type Matches struct {
	Text   rtti.TextEval
	Match  string
	Cache  MatchCache
	Markup map[string]any
}

// matches, a type of flow.
var Zt_Matches typeinfo.Flow

// implements typeinfo.Instance
func (*Matches) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// implements typeinfo.Markup
func (op *Matches) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Matches)(nil)

// holds a slice of type matches
type Matches_Slice []Matches

// implements typeinfo.Instance
func (*Matches_Slice) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// implements typeinfo.Repeats
func (op *Matches_Slice) Repeats() bool {
	return len(*op) > 0
}

// Full name of the object.
type NameOf struct {
	Object rtti.TextEval
	Markup map[string]any
}

// name_of, a type of flow.
var Zt_NameOf typeinfo.Flow

// implements typeinfo.Instance
func (*NameOf) TypeInfo() typeinfo.T {
	return &Zt_NameOf
}

// implements typeinfo.Markup
func (op *NameOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*NameOf)(nil)

// holds a slice of type name_of
type NameOf_Slice []NameOf

// implements typeinfo.Instance
func (*NameOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_NameOf
}

// implements typeinfo.Repeats
func (op *NameOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns false.
type Never struct {
	Markup map[string]any
}

// never, a type of flow.
var Zt_Never typeinfo.Flow

// implements typeinfo.Instance
func (*Never) TypeInfo() typeinfo.T {
	return &Zt_Never
}

// implements typeinfo.Markup
func (op *Never) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Never)(nil)

// holds a slice of type never
type Never_Slice []Never

// implements typeinfo.Instance
func (*Never_Slice) TypeInfo() typeinfo.T {
	return &Zt_Never
}

// implements typeinfo.Repeats
func (op *Never_Slice) Repeats() bool {
	return len(*op) > 0
}

// Start a new line.
type Newline struct {
	Markup map[string]any
}

// newline, a type of flow.
var Zt_Newline typeinfo.Flow

// implements typeinfo.Instance
func (*Newline) TypeInfo() typeinfo.T {
	return &Zt_Newline
}

// implements typeinfo.Markup
func (op *Newline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Newline)(nil)

// holds a slice of type newline
type Newline_Slice []Newline

// implements typeinfo.Instance
func (*Newline_Slice) TypeInfo() typeinfo.T {
	return &Zt_Newline
}

// implements typeinfo.Repeats
func (op *Newline_Slice) Repeats() bool {
	return len(*op) > 0
}

// In a repeating loop, try the next iteration of the loop;
// or, in a rule, continue to the next rule.
type Continue struct {
	Markup map[string]any
}

// continue, a type of flow.
var Zt_Continue typeinfo.Flow

// implements typeinfo.Instance
func (*Continue) TypeInfo() typeinfo.T {
	return &Zt_Continue
}

// implements typeinfo.Markup
func (op *Continue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Continue)(nil)

// holds a slice of type continue
type Continue_Slice []Continue

// implements typeinfo.Instance
func (*Continue_Slice) TypeInfo() typeinfo.T {
	return &Zt_Continue
}

// implements typeinfo.Repeats
func (op *Continue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the opposite value.
type Not struct {
	Test   rtti.BoolEval
	Markup map[string]any
}

// not, a type of flow.
var Zt_Not typeinfo.Flow

// implements typeinfo.Instance
func (*Not) TypeInfo() typeinfo.T {
	return &Zt_Not
}

// implements typeinfo.Markup
func (op *Not) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*Not)(nil)

// holds a slice of type not
type Not_Slice []Not

// implements typeinfo.Instance
func (*Not_Slice) TypeInfo() typeinfo.T {
	return &Zt_Not
}

// implements typeinfo.Repeats
func (op *Not_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns whether there is a object of the specified name.
type ObjectExists struct {
	Object rtti.TextEval
	Markup map[string]any
}

// object_exists, a type of flow.
var Zt_ObjectExists typeinfo.Flow

// implements typeinfo.Instance
func (*ObjectExists) TypeInfo() typeinfo.T {
	return &Zt_ObjectExists
}

// implements typeinfo.Markup
func (op *ObjectExists) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*ObjectExists)(nil)

// holds a slice of type object_exists
type ObjectExists_Slice []ObjectExists

// implements typeinfo.Instance
func (*ObjectExists_Slice) TypeInfo() typeinfo.T {
	return &Zt_ObjectExists
}

// implements typeinfo.Repeats
func (op *ObjectExists_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns all of the object's current traits as a list of text.
type ObjectTraits struct {
	Object rtti.TextEval
	Markup map[string]any
}

// object_traits, a type of flow.
var Zt_ObjectTraits typeinfo.Flow

// implements typeinfo.Instance
func (*ObjectTraits) TypeInfo() typeinfo.T {
	return &Zt_ObjectTraits
}

// implements typeinfo.Markup
func (op *ObjectTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextListEval = (*ObjectTraits)(nil)

// holds a slice of type object_traits
type ObjectTraits_Slice []ObjectTraits

// implements typeinfo.Instance
func (*ObjectTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_ObjectTraits
}

// implements typeinfo.Repeats
func (op *ObjectTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the plural form of a singular word. (ex. apples for apple. ).
type Pluralize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// pluralize, a type of flow.
var Zt_Pluralize typeinfo.Flow

// implements typeinfo.Instance
func (*Pluralize) TypeInfo() typeinfo.T {
	return &Zt_Pluralize
}

// implements typeinfo.Markup
func (op *Pluralize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Pluralize)(nil)

// holds a slice of type pluralize
type Pluralize_Slice []Pluralize

// implements typeinfo.Instance
func (*Pluralize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Pluralize
}

// implements typeinfo.Repeats
func (op *Pluralize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes a number using numerals, eg. '1'.
type PrintNum struct {
	Num    rtti.NumberEval
	Markup map[string]any
}

// print_num, a type of flow.
var Zt_PrintNum typeinfo.Flow

// implements typeinfo.Instance
func (*PrintNum) TypeInfo() typeinfo.T {
	return &Zt_PrintNum
}

// implements typeinfo.Markup
func (op *PrintNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*PrintNum)(nil)

// holds a slice of type print_num
type PrintNum_Slice []PrintNum

// implements typeinfo.Instance
func (*PrintNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintNum
}

// implements typeinfo.Repeats
func (op *PrintNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes a number in plain english: eg. 'one'.
type PrintNumWord struct {
	Num    rtti.NumberEval
	Markup map[string]any
}

// print_num_word, a type of flow.
var Zt_PrintNumWord typeinfo.Flow

// implements typeinfo.Instance
func (*PrintNumWord) TypeInfo() typeinfo.T {
	return &Zt_PrintNumWord
}

// implements typeinfo.Markup
func (op *PrintNumWord) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*PrintNumWord)(nil)

// holds a slice of type print_num_word
type PrintNumWord_Slice []PrintNumWord

// implements typeinfo.Instance
func (*PrintNumWord_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintNumWord
}

// implements typeinfo.Repeats
func (op *PrintNumWord_Slice) Repeats() bool {
	return len(*op) > 0
}

// Multiply two numbers.
type MultiplyValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// multiply_value, a type of flow.
var Zt_MultiplyValue typeinfo.Flow

// implements typeinfo.Instance
func (*MultiplyValue) TypeInfo() typeinfo.T {
	return &Zt_MultiplyValue
}

// implements typeinfo.Markup
func (op *MultiplyValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*MultiplyValue)(nil)

// holds a slice of type multiply_value
type MultiplyValue_Slice []MultiplyValue

// implements typeinfo.Instance
func (*MultiplyValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_MultiplyValue
}

// implements typeinfo.Repeats
func (op *MultiplyValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Divide one number by another.
type DivideValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// divide_value, a type of flow.
var Zt_DivideValue typeinfo.Flow

// implements typeinfo.Instance
func (*DivideValue) TypeInfo() typeinfo.T {
	return &Zt_DivideValue
}

// implements typeinfo.Markup
func (op *DivideValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*DivideValue)(nil)

// holds a slice of type divide_value
type DivideValue_Slice []DivideValue

// implements typeinfo.Instance
func (*DivideValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_DivideValue
}

// implements typeinfo.Repeats
func (op *DivideValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Divide one number by another, and return the remainder.
type ModValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// mod_value, a type of flow.
var Zt_ModValue typeinfo.Flow

// implements typeinfo.Instance
func (*ModValue) TypeInfo() typeinfo.T {
	return &Zt_ModValue
}

// implements typeinfo.Markup
func (op *ModValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*ModValue)(nil)

// holds a slice of type mod_value
type ModValue_Slice []ModValue

// implements typeinfo.Instance
func (*ModValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_ModValue
}

// implements typeinfo.Repeats
func (op *ModValue_Slice) Repeats() bool {
	return len(*op) > 0
}

type AbsValue struct {
	Value  rtti.NumberEval
	Markup map[string]any
}

// abs_value, a type of flow.
var Zt_AbsValue typeinfo.Flow

// implements typeinfo.Instance
func (*AbsValue) TypeInfo() typeinfo.T {
	return &Zt_AbsValue
}

// implements typeinfo.Markup
func (op *AbsValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*AbsValue)(nil)

// holds a slice of type abs_value
type AbsValue_Slice []AbsValue

// implements typeinfo.Instance
func (*AbsValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AbsValue
}

// implements typeinfo.Repeats
func (op *AbsValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Increases the value of a number held in by a variable or object field.
// Returns the new value of the number.
type Increment struct {
	Target assign.Address
	Step   rtti.NumberEval
	Markup map[string]any
}

// increment, a type of flow.
var Zt_Increment typeinfo.Flow

// implements typeinfo.Instance
func (*Increment) TypeInfo() typeinfo.T {
	return &Zt_Increment
}

// implements typeinfo.Markup
func (op *Increment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*Increment)(nil)
var _ rtti.Execute = (*Increment)(nil)

// holds a slice of type increment
type Increment_Slice []Increment

// implements typeinfo.Instance
func (*Increment_Slice) TypeInfo() typeinfo.T {
	return &Zt_Increment
}

// implements typeinfo.Repeats
func (op *Increment_Slice) Repeats() bool {
	return len(*op) > 0
}

// Decrease the value of a number held in by a variable or object field.
// Returns the new value of the number.
type Decrement struct {
	Target assign.Address
	Step   rtti.NumberEval
	Markup map[string]any
}

// decrement, a type of flow.
var Zt_Decrement typeinfo.Flow

// implements typeinfo.Instance
func (*Decrement) TypeInfo() typeinfo.T {
	return &Zt_Decrement
}

// implements typeinfo.Markup
func (op *Decrement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*Decrement)(nil)
var _ rtti.Execute = (*Decrement)(nil)

// holds a slice of type decrement
type Decrement_Slice []Decrement

// implements typeinfo.Instance
func (*Decrement_Slice) TypeInfo() typeinfo.T {
	return &Zt_Decrement
}

// implements typeinfo.Repeats
func (op *Decrement_Slice) Repeats() bool {
	return len(*op) > 0
}

// Increases the value of a trait held by an object aspect.
// Returns the new value of the trait.
type IncrementAspect struct {
	Target rtti.TextEval
	Aspect rtti.TextEval
	Step   rtti.NumberEval
	Clamp  rtti.BoolEval
	Markup map[string]any
}

// increment_aspect, a type of flow.
var Zt_IncrementAspect typeinfo.Flow

// implements typeinfo.Instance
func (*IncrementAspect) TypeInfo() typeinfo.T {
	return &Zt_IncrementAspect
}

// implements typeinfo.Markup
func (op *IncrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*IncrementAspect)(nil)
var _ rtti.Execute = (*IncrementAspect)(nil)

// holds a slice of type increment_aspect
type IncrementAspect_Slice []IncrementAspect

// implements typeinfo.Instance
func (*IncrementAspect_Slice) TypeInfo() typeinfo.T {
	return &Zt_IncrementAspect
}

// implements typeinfo.Repeats
func (op *IncrementAspect_Slice) Repeats() bool {
	return len(*op) > 0
}

// Increases the value of a trait held by an object aspect.
// Returns the new value of the trait.
type DecrementAspect struct {
	Target rtti.TextEval
	Aspect rtti.TextEval
	Step   rtti.NumberEval
	Clamp  rtti.BoolEval
	Markup map[string]any
}

// decrement_aspect, a type of flow.
var Zt_DecrementAspect typeinfo.Flow

// implements typeinfo.Instance
func (*DecrementAspect) TypeInfo() typeinfo.T {
	return &Zt_DecrementAspect
}

// implements typeinfo.Markup
func (op *DecrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*DecrementAspect)(nil)
var _ rtti.Execute = (*DecrementAspect)(nil)

// holds a slice of type decrement_aspect
type DecrementAspect_Slice []DecrementAspect

// implements typeinfo.Instance
func (*DecrementAspect_Slice) TypeInfo() typeinfo.T {
	return &Zt_DecrementAspect
}

// implements typeinfo.Repeats
func (op *DecrementAspect_Slice) Repeats() bool {
	return len(*op) > 0
}

// Display some text to the player without apply any additional formatting.
type PrintText struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// print_text, a type of flow.
var Zt_PrintText typeinfo.Flow

// implements typeinfo.Instance
func (*PrintText) TypeInfo() typeinfo.T {
	return &Zt_PrintText
}

// implements typeinfo.Markup
func (op *PrintText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*PrintText)(nil)

// holds a slice of type print_text
type PrintText_Slice []PrintText

// implements typeinfo.Instance
func (*PrintText_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintText
}

// implements typeinfo.Repeats
func (op *PrintText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Group text into a single line <li> as part of a list of lines.
// See also: 'rows'.
type Row struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// row, a type of flow.
var Zt_Row typeinfo.Flow

// implements typeinfo.Instance
func (*Row) TypeInfo() typeinfo.T {
	return &Zt_Row
}

// implements typeinfo.Markup
func (op *Row) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Row)(nil)

// holds a slice of type row
type Row_Slice []Row

// implements typeinfo.Instance
func (*Row_Slice) TypeInfo() typeinfo.T {
	return &Zt_Row
}

// implements typeinfo.Repeats
func (op *Row_Slice) Repeats() bool {
	return len(*op) > 0
}

// Group text into an unordered list <ul>.
type Rows struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// rows, a type of flow.
var Zt_Rows typeinfo.Flow

// implements typeinfo.Instance
func (*Rows) TypeInfo() typeinfo.T {
	return &Zt_Rows
}

// implements typeinfo.Markup
func (op *Rows) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Rows)(nil)

// holds a slice of type rows
type Rows_Slice []Rows

// implements typeinfo.Instance
func (*Rows_Slice) TypeInfo() typeinfo.T {
	return &Zt_Rows
}

// implements typeinfo.Repeats
func (op *Rows_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the singular form of a plural word. (ex. apple for apples ).
type Singularize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// singularize, a type of flow.
var Zt_Singularize typeinfo.Flow

// implements typeinfo.Instance
func (*Singularize) TypeInfo() typeinfo.T {
	return &Zt_Singularize
}

// implements typeinfo.Markup
func (op *Singularize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*Singularize)(nil)

// holds a slice of type singularize
type Singularize_Slice []Singularize

// implements typeinfo.Instance
func (*Singularize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Singularize
}

// implements typeinfo.Repeats
func (op *Singularize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Separates words with left-leaning slashes '/'.
type SlashText struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// slash_text, a type of flow.
var Zt_SlashText typeinfo.Flow

// implements typeinfo.Instance
func (*SlashText) TypeInfo() typeinfo.T {
	return &Zt_SlashText
}

// implements typeinfo.Markup
func (op *SlashText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*SlashText)(nil)

// holds a slice of type slash_text
type SlashText_Slice []SlashText

// implements typeinfo.Instance
func (*SlashText_Slice) TypeInfo() typeinfo.T {
	return &Zt_SlashText
}

// implements typeinfo.Repeats
func (op *SlashText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Start a new line ( if not already at a new line. ).
type Softline struct {
	Markup map[string]any
}

// softline, a type of flow.
var Zt_Softline typeinfo.Flow

// implements typeinfo.Instance
func (*Softline) TypeInfo() typeinfo.T {
	return &Zt_Softline
}

// implements typeinfo.Markup
func (op *Softline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Softline)(nil)

// holds a slice of type softline
type Softline_Slice []Softline

// implements typeinfo.Instance
func (*Softline_Slice) TypeInfo() typeinfo.T {
	return &Zt_Softline
}

// implements typeinfo.Repeats
func (op *Softline_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes text with spaces between words.
type SpanText struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// span_text, a type of flow.
var Zt_SpanText typeinfo.Flow

// implements typeinfo.Instance
func (*SpanText) TypeInfo() typeinfo.T {
	return &Zt_SpanText
}

// implements typeinfo.Markup
func (op *SpanText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*SpanText)(nil)

// holds a slice of type span_text
type SpanText_Slice []SpanText

// implements typeinfo.Instance
func (*SpanText_Slice) TypeInfo() typeinfo.T {
	return &Zt_SpanText
}

// implements typeinfo.Repeats
func (op *SpanText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Add two numbers.
type AddValue struct {
	A      rtti.NumberEval
	B      rtti.NumberEval
	Markup map[string]any
}

// add_value, a type of flow.
var Zt_AddValue typeinfo.Flow

// implements typeinfo.Instance
func (*AddValue) TypeInfo() typeinfo.T {
	return &Zt_AddValue
}

// implements typeinfo.Markup
func (op *AddValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*AddValue)(nil)

// holds a slice of type add_value
type AddValue_Slice []AddValue

// implements typeinfo.Instance
func (*AddValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AddValue
}

// implements typeinfo.Repeats
func (op *AddValue_Slice) Repeats() bool {
	return len(*op) > 0
}

type TriggerCycle struct {
	Markup map[string]any
}

// trigger_cycle, a type of flow.
var Zt_TriggerCycle typeinfo.Flow

// implements typeinfo.Instance
func (*TriggerCycle) TypeInfo() typeinfo.T {
	return &Zt_TriggerCycle
}

// implements typeinfo.Markup
func (op *TriggerCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerCycle)(nil)

// holds a slice of type trigger_cycle
type TriggerCycle_Slice []TriggerCycle

// implements typeinfo.Instance
func (*TriggerCycle_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerCycle
}

// implements typeinfo.Repeats
func (op *TriggerCycle_Slice) Repeats() bool {
	return len(*op) > 0
}

type TriggerOnce struct {
	Markup map[string]any
}

// trigger_once, a type of flow.
var Zt_TriggerOnce typeinfo.Flow

// implements typeinfo.Instance
func (*TriggerOnce) TypeInfo() typeinfo.T {
	return &Zt_TriggerOnce
}

// implements typeinfo.Markup
func (op *TriggerOnce) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerOnce)(nil)

// holds a slice of type trigger_once
type TriggerOnce_Slice []TriggerOnce

// implements typeinfo.Instance
func (*TriggerOnce_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerOnce
}

// implements typeinfo.Repeats
func (op *TriggerOnce_Slice) Repeats() bool {
	return len(*op) > 0
}

type TriggerSwitch struct {
	Markup map[string]any
}

// trigger_switch, a type of flow.
var Zt_TriggerSwitch typeinfo.Flow

// implements typeinfo.Instance
func (*TriggerSwitch) TypeInfo() typeinfo.T {
	return &Zt_TriggerSwitch
}

// implements typeinfo.Markup
func (op *TriggerSwitch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Trigger = (*TriggerSwitch)(nil)

// holds a slice of type trigger_switch
type TriggerSwitch_Slice []TriggerSwitch

// implements typeinfo.Instance
func (*TriggerSwitch_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerSwitch
}

// implements typeinfo.Repeats
func (op *TriggerSwitch_Slice) Repeats() bool {
	return len(*op) > 0
}

// Keep running a series of actions while a condition is true.
type While struct {
	True   rtti.BoolEval
	Exe    []rtti.Execute
	Markup map[string]any
}

// while, a type of flow.
var Zt_While typeinfo.Flow

// implements typeinfo.Instance
func (*While) TypeInfo() typeinfo.T {
	return &Zt_While
}

// implements typeinfo.Markup
func (op *While) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*While)(nil)

// holds a slice of type while
type While_Slice []While

// implements typeinfo.Instance
func (*While_Slice) TypeInfo() typeinfo.T {
	return &Zt_While
}

// implements typeinfo.Repeats
func (op *While_Slice) Repeats() bool {
	return len(*op) > 0
}

// Comparison, a type of str enum.
type Comparison int

// enumerated values of Comparison
const (
	C_Comparison_EqualTo Comparison = iota
	C_Comparison_OtherThan
	C_Comparison_GreaterThan
	C_Comparison_LessThan
	C_Comparison_AtLeast
	C_Comparison_AtMost
)

func MakeComparison(str string) (ret Comparison, okay bool) {
	if i := Zt_Comparison.FindOption(str); i >= 0 {
		ret, okay = Comparison(i), true
	}
	return
}

func (op Comparison) String() (ret string) {
	if i, opts := int(op), Zt_Comparison.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid Comparison(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// comparison, a type of str enum.
var Zt_Comparison = typeinfo.Str{
	Name: "comparison",
	Options: []string{
		"equal_to",
		"other_than",
		"greater_than",
		"less_than",
		"at_least",
		"at_most",
	},
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_AllTrue = typeinfo.Flow{
		Name: "all_true",
		Lede: "all_true",
		Terms: []typeinfo.Term{{
			Name:    "test",
			Repeats: true,
			Type:    &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns true if all of the evaluations are true.",
		},
	}
	Zt_Always = typeinfo.Flow{
		Name:  "always",
		Lede:  "always",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns true.",
		},
	}
	Zt_AnyTrue = typeinfo.Flow{
		Name: "any_true",
		Lede: "any_true",
		Terms: []typeinfo.Term{{
			Name:    "test",
			Repeats: true,
			Type:    &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns true if any of the evaluations are true.",
		},
	}
	Zt_Blankline = typeinfo.Flow{
		Name:  "blankline",
		Lede:  "p",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Add a single blank line following some text.",
		},
	}
	Zt_BracketText = typeinfo.Flow{
		Name: "bracket_text",
		Lede: "brackets",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Sandwiches text printed during a block and puts them inside parenthesis '()'.",
		},
	}
	Zt_Break = typeinfo.Flow{
		Name:  "break",
		Lede:  "break",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"In a repeating loop, exit the loop;", "or, in a rule, stop processing rules."},
		},
	}
	Zt_BufferText = typeinfo.Flow{
		Name: "buffer_text",
		Lede: "buffers",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
	}
	Zt_CallCycle = typeinfo.Flow{
		Name: "call_cycle",
		Lede: "cycle",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Runtime version of cycle_text.",
		},
	}
	Zt_CallShuffle = typeinfo.Flow{
		Name: "call_shuffle",
		Lede: "shuffle",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}, {
			Name:    "indices",
			Label:   "indices",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Runtime version of shuffle_text.",
		},
	}
	Zt_CallTerminal = typeinfo.Flow{
		Name: "call_terminal",
		Lede: "stopping",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Runtime version of stopping_text.",
		},
	}
	Zt_CallTrigger = typeinfo.Flow{
		Name: "call_trigger",
		Lede: "trigger",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:  "trigger",
			Label: "on",
			Type:  &Zt_Trigger,
		}, {
			Name:  "num",
			Label: "num",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Runtime version of count_of.",
		},
	}
	Zt_Capitalize = typeinfo.Flow{
		Name: "capitalize",
		Lede: "capitalize",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, with the first letter turned into uppercase.",
		},
	}
	Zt_ChooseBranch = typeinfo.Flow{
		Name: "choose_branch",
		Lede: "if",
		Terms: []typeinfo.Term{{
			Name: "if",
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:     "args",
			Label:    "assuming",
			Optional: true,
			Repeats:  true,
			Type:     &assign.Zt_Arg,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}, {
			Name:     "else",
			Label:    "else",
			Optional: true,
			Type:     &Zt_Brancher,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&Zt_Brancher,
		},
		Markup: map[string]any{
			"comment": []interface{}{"An if statement.", "The provided local fields are evaluated before the if test itself."},
		},
	}
	Zt_ChooseNothingElse = typeinfo.Flow{
		Name: "choose_nothing_else",
		Lede: "finally",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Brancher,
		},
	}
	Zt_ChooseNum = typeinfo.Flow{
		Name: "choose_num",
		Lede: "num",
		Terms: []typeinfo.Term{{
			Name:  "if",
			Label: "if",
			Type:  &rtti.Zt_BoolEval,
		}, {
			Name:  "true",
			Label: "then",
			Type:  &rtti.Zt_NumberEval,
		}, {
			Name:     "false",
			Label:    "else",
			Optional: true,
			Type:     &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
		},
		Markup: map[string]any{
			"comment": "Pick one of two numbers based on a boolean test.",
		},
	}
	Zt_ChooseText = typeinfo.Flow{
		Name: "choose_text",
		Lede: "txt",
		Terms: []typeinfo.Term{{
			Name:  "if",
			Label: "if",
			Type:  &rtti.Zt_BoolEval,
		}, {
			Name:  "true",
			Label: "then",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "false",
			Label:    "else",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Pick one of two strings based on a boolean test.",
		},
	}
	Zt_CommaText = typeinfo.Flow{
		Name: "comma_text",
		Lede: "commas",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Separates words with commas, and 'and'.",
		},
	}
	Zt_CompareValue = typeinfo.Flow{
		Name: "compare_value",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_Assignment,
		}, {
			Name:  "is",
			Label: "matching",
			Type:  &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if eq,ne,gt,lt,ge,le two numbers.",
		},
	}
	Zt_CompareNum = typeinfo.Flow{
		Name: "compare_num",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumberEval,
		}, {
			Name:  "is",
			Label: "matching",
			Type:  &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "num",
			Type:  &rtti.Zt_NumberEval,
		}, {
			Name:     "tolerance",
			Label:    "within",
			Optional: true,
			Markup: map[string]any{
				"comment": "a positive value that indicates how close the two numbers should be",
			},
			Type: &prim.Zt_Number,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if eq,ne,gt,lt,ge,le two numbers.",
		},
	}
	Zt_CompareText = typeinfo.Flow{
		Name: "compare_text",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "is",
			Label: "matching",
			Type:  &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "text",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if eq,ne,gt,lt,ge,le two strings ( lexical. ).",
		},
	}
	Zt_SubtractValue = typeinfo.Flow{
		Name: "subtract_value",
		Lede: "subtract",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumberEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
		},
		Markup: map[string]any{
			"comment": "Subtract two numbers.",
		},
	}
	Zt_During = typeinfo.Flow{
		Name: "during",
		Lede: "during",
		Terms: []typeinfo.Term{{
			Name: "pattern_name",
			Type: &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumberEval,
		},
		Markup: map[string]any{
			"comment": "Decide whether a pattern is running.",
		},
	}
	Zt_FieldsOfKind = typeinfo.Flow{
		Name: "fields_of_kind",
		Lede: "fields",
		Terms: []typeinfo.Term{{
			Name:  "kind_name",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"comment": "List of the field names of a kind.",
		},
	}
	Zt_HasDominion = typeinfo.Flow{
		Name: "has_dominion",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "domain",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
	}
	Zt_IdOf = typeinfo.Flow{
		Name: "id_of",
		Lede: "id_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "A unique object identifier.",
		},
	}
	Zt_Includes = typeinfo.Flow{
		Name: "includes",
		Lede: "contains",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "part",
			Label: "part",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if text contains text.",
		},
	}
	Zt_IsEmpty = typeinfo.Flow{
		Name: "is_empty",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "empty",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if the text is empty.",
		},
	}
	Zt_IsExactKindOf = typeinfo.Flow{
		Name: "is_exact_kind_of",
		Lede: "kind_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "kind",
			Label: "is_exactly",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if the object is exactly the named kind.",
		},
	}
	Zt_IsKindOf = typeinfo.Flow{
		Name: "is_kind_of",
		Lede: "kind_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "kind",
			Label: "is",
			Type:  &prim.Zt_Text,
		}, {
			Name:     "nothing",
			Label:    "nothing",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"try to check the type of nothing objects?", "normally, nothing objects have no kind."},
			},
			Type: &prim.Zt_Bool,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if the object is compatible with the named kind.",
		},
	}
	Zt_Join = typeinfo.Flow{
		Name: "join",
		Lede: "join",
		Terms: []typeinfo.Term{{
			Name:     "sep",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "parts",
			Label:   "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns multiple pieces of text as a single new piece of text.",
		},
	}
	Zt_KindOf = typeinfo.Flow{
		Name: "kind_of",
		Lede: "kind_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "nothing",
			Label:    "nothing",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"try to check the type of nothing objects?", "normally, nothing objects have no kind."},
			},
			Type: &prim.Zt_Bool,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Friendly name of the object's kind.",
		},
	}
	Zt_KindsOf = typeinfo.Flow{
		Name: "kinds_of",
		Lede: "kinds_of",
		Terms: []typeinfo.Term{{
			Name: "kind",
			Type: &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"comment": "A list of compatible kinds.",
		},
	}
	Zt_MakeLowercase = typeinfo.Flow{
		Name: "make_lowercase",
		Lede: "lower",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, with every letter turned into lowercase. For example, 'shout' from 'SHOUT'.",
		},
	}
	Zt_MakeReversed = typeinfo.Flow{
		Name: "make_reversed",
		Lede: "reverse",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text flipped back to front. For example, 'elppA' from 'Apple', or 'noon' from 'noon'.",
		},
	}
	Zt_MakeSentenceCase = typeinfo.Flow{
		Name: "make_sentence_case",
		Lede: "sentence",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, start each sentence with a capital letter. For example, 'Empire Apple.' from 'Empire apple.'.",
		},
	}
	Zt_MakeTitleCase = typeinfo.Flow{
		Name: "make_title_case",
		Lede: "title",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, starting each word with a capital letter. For example, 'Empire Apple' from 'empire apple'.",
		},
	}
	Zt_MakeUppercase = typeinfo.Flow{
		Name: "make_uppercase",
		Lede: "upper",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, with every letter turned into uppercase. For example, 'APPLE' from 'apple'.",
		},
	}
	Zt_Matches = typeinfo.Flow{
		Name: "matches",
		Lede: "matches",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "match",
			Label: "to",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "cache",
			Label:   "cache",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Determine whether the specified text is similar to the specified regular expression.",
		},
	}
	Zt_NameOf = typeinfo.Flow{
		Name: "name_of",
		Lede: "name_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Full name of the object.",
		},
	}
	Zt_Never = typeinfo.Flow{
		Name:  "never",
		Lede:  "never",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns false.",
		},
	}
	Zt_Newline = typeinfo.Flow{
		Name:  "newline",
		Lede:  "br",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Start a new line.",
		},
	}
	Zt_Continue = typeinfo.Flow{
		Name:  "continue",
		Lede:  "continue",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"In a repeating loop, try the next iteration of the loop;", "or, in a rule, continue to the next rule."},
		},
	}
	Zt_Not = typeinfo.Flow{
		Name: "not",
		Lede: "not",
		Terms: []typeinfo.Term{{
			Name: "test",
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns the opposite value.",
		},
	}
	Zt_ObjectExists = typeinfo.Flow{
		Name: "object_exists",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "object",
			Label: "valid",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns whether there is a object of the specified name.",
		},
	}
	Zt_ObjectTraits = typeinfo.Flow{
		Name: "object_traits",
		Lede: "object",
		Terms: []typeinfo.Term{{
			Name:  "object",
			Label: "traits",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"comment": "Returns all of the object's current traits as a list of text.",
		},
	}
	Zt_Pluralize = typeinfo.Flow{
		Name: "pluralize",
		Lede: "plural",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns the plural form of a singular word. (ex. apples for apple. ).",
		},
	}
	Zt_PrintNum = typeinfo.Flow{
		Name: "print_num",
		Lede: "numeral",
		Terms: []typeinfo.Term{{
			Name: "num",
			Type: &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes a number using numerals, eg. '1'.",
		},
	}
	Zt_PrintNumWord = typeinfo.Flow{
		Name: "print_num_word",
		Lede: "numeral",
		Terms: []typeinfo.Term{{
			Name:  "num",
			Label: "words",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes a number in plain english: eg. 'one'.",
		},
	}
	Zt_MultiplyValue = typeinfo.Flow{
		Name: "multiply_value",
		Lede: "multiply",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumberEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
		},
		Markup: map[string]any{
			"comment": "Multiply two numbers.",
		},
	}
	Zt_DivideValue = typeinfo.Flow{
		Name: "divide_value",
		Lede: "divide",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumberEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
		},
		Markup: map[string]any{
			"comment": "Divide one number by another.",
		},
	}
	Zt_ModValue = typeinfo.Flow{
		Name: "mod_value",
		Lede: "mod",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumberEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
		},
		Markup: map[string]any{
			"comment": "Divide one number by another, and return the remainder.",
		},
	}
	Zt_AbsValue = typeinfo.Flow{
		Name: "abs_value",
		Lede: "absolute",
		Terms: []typeinfo.Term{{
			Name:  "value",
			Label: "value",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
		},
	}
	Zt_Increment = typeinfo.Flow{
		Name: "increment",
		Lede: "increase",
		Terms: []typeinfo.Term{{
			Name: "target",
			Type: &assign.Zt_Address,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, increments by 1.",
			},
			Type: &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Increases the value of a number held in by a variable or object field.", "Returns the new value of the number."},
		},
	}
	Zt_Decrement = typeinfo.Flow{
		Name: "decrement",
		Lede: "decrease",
		Terms: []typeinfo.Term{{
			Name: "target",
			Type: &assign.Zt_Address,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, decrements by 1.",
			},
			Type: &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Decrease the value of a number held in by a variable or object field.", "Returns the new value of the number."},
		},
	}
	Zt_IncrementAspect = typeinfo.Flow{
		Name: "increment_aspect",
		Lede: "increase",
		Terms: []typeinfo.Term{{
			Name: "target",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "aspect",
			Label: "aspect",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, increments by a single step.",
			},
			Type: &rtti.Zt_NumberEval,
		}, {
			Name:     "clamp",
			Label:    "clamp",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, wraps.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Increases the value of a trait held by an object aspect.", "Returns the new value of the trait."},
		},
	}
	Zt_DecrementAspect = typeinfo.Flow{
		Name: "decrement_aspect",
		Lede: "decrease",
		Terms: []typeinfo.Term{{
			Name: "target",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "aspect",
			Label: "aspect",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, increments by a single step.",
			},
			Type: &rtti.Zt_NumberEval,
		}, {
			Name:     "clamp",
			Label:    "clamp",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, wraps.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Increases the value of a trait held by an object aspect.", "Returns the new value of the trait."},
		},
	}
	Zt_PrintText = typeinfo.Flow{
		Name: "print_text",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Display some text to the player without apply any additional formatting.",
		},
	}
	Zt_Row = typeinfo.Flow{
		Name: "row",
		Lede: "row",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Group text into a single line <li> as part of a list of lines.", "See also: 'rows'."},
		},
	}
	Zt_Rows = typeinfo.Flow{
		Name: "rows",
		Lede: "rows",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Group text into an unordered list <ul>.",
		},
	}
	Zt_Singularize = typeinfo.Flow{
		Name: "singularize",
		Lede: "singular",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns the singular form of a plural word. (ex. apple for apples ).",
		},
	}
	Zt_SlashText = typeinfo.Flow{
		Name: "slash_text",
		Lede: "slashes",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Separates words with left-leaning slashes '/'.",
		},
	}
	Zt_Softline = typeinfo.Flow{
		Name:  "softline",
		Lede:  "wbr",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Start a new line ( if not already at a new line. ).",
		},
	}
	Zt_SpanText = typeinfo.Flow{
		Name: "span_text",
		Lede: "spaces",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes text with spaces between words.",
		},
	}
	Zt_AddValue = typeinfo.Flow{
		Name: "add_value",
		Lede: "add",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumberEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumberEval,
		},
		Markup: map[string]any{
			"comment": "Add two numbers.",
		},
	}
	Zt_TriggerCycle = typeinfo.Flow{
		Name:  "trigger_cycle",
		Lede:  "every",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
	}
	Zt_TriggerOnce = typeinfo.Flow{
		Name:  "trigger_once",
		Lede:  "at",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
	}
	Zt_TriggerSwitch = typeinfo.Flow{
		Name:  "trigger_switch",
		Lede:  "after",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
	}
	Zt_While = typeinfo.Flow{
		Name: "while",
		Lede: "repeating",
		Terms: []typeinfo.Term{{
			Name: "true",
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Keep running a series of actions while a condition is true.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "core",
	Comment: []string{
		"core",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Brancher,
	&Zt_Trigger,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_AllTrue,
	&Zt_Always,
	&Zt_AnyTrue,
	&Zt_Blankline,
	&Zt_BracketText,
	&Zt_Break,
	&Zt_BufferText,
	&Zt_CallCycle,
	&Zt_CallShuffle,
	&Zt_CallTerminal,
	&Zt_CallTrigger,
	&Zt_Capitalize,
	&Zt_ChooseBranch,
	&Zt_ChooseNothingElse,
	&Zt_ChooseNum,
	&Zt_ChooseText,
	&Zt_CommaText,
	&Zt_CompareValue,
	&Zt_CompareNum,
	&Zt_CompareText,
	&Zt_SubtractValue,
	&Zt_During,
	&Zt_FieldsOfKind,
	&Zt_HasDominion,
	&Zt_IdOf,
	&Zt_Includes,
	&Zt_IsEmpty,
	&Zt_IsExactKindOf,
	&Zt_IsKindOf,
	&Zt_Join,
	&Zt_KindOf,
	&Zt_KindsOf,
	&Zt_MakeLowercase,
	&Zt_MakeReversed,
	&Zt_MakeSentenceCase,
	&Zt_MakeTitleCase,
	&Zt_MakeUppercase,
	&Zt_Matches,
	&Zt_NameOf,
	&Zt_Never,
	&Zt_Newline,
	&Zt_Continue,
	&Zt_Not,
	&Zt_ObjectExists,
	&Zt_ObjectTraits,
	&Zt_Pluralize,
	&Zt_PrintNum,
	&Zt_PrintNumWord,
	&Zt_MultiplyValue,
	&Zt_DivideValue,
	&Zt_ModValue,
	&Zt_AbsValue,
	&Zt_Increment,
	&Zt_Decrement,
	&Zt_IncrementAspect,
	&Zt_DecrementAspect,
	&Zt_PrintText,
	&Zt_Row,
	&Zt_Rows,
	&Zt_Singularize,
	&Zt_SlashText,
	&Zt_Softline,
	&Zt_SpanText,
	&Zt_AddValue,
	&Zt_TriggerCycle,
	&Zt_TriggerOnce,
	&Zt_TriggerSwitch,
	&Zt_While,
}

// a list of all strs in this this package
var z_str_list = []*typeinfo.Str{
	&Zt_Comparison,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	9652861807756732392:  (*AbsValue)(nil),          /* number_eval=Absolute value: */
	6415467136316515808:  (*AddValue)(nil),          /* number_eval=Add:value: */
	9392469773844077696:  (*TriggerSwitch)(nil),     /* trigger=After */
	8082607244820951444:  (*AllTrue)(nil),           /* bool_eval=AllTrue: */
	1979437068831463006:  (*Always)(nil),            /* bool_eval=Always */
	1963945852392897915:  (*AnyTrue)(nil),           /* bool_eval=AnyTrue: */
	2233111806717201007:  (*TriggerOnce)(nil),       /* trigger=At */
	15800853823523633295: (*Newline)(nil),           /* execute=Br */
	8805770583889466012:  (*BracketText)(nil),       /* text_eval=Brackets do: */
	9570569845423374482:  (*Break)(nil),             /* execute=Break */
	11322251195672034522: (*BufferText)(nil),        /* text_eval=Buffers do: */
	8695677004499439692:  (*Capitalize)(nil),        /* text_eval=Capitalize: */
	18319016698864768677: (*CommaText)(nil),         /* text_eval=Commas do: */
	3601423820955950769:  (*Includes)(nil),          /* bool_eval=Contains:part: */
	3156233792812716886:  (*Continue)(nil),          /* execute=Continue */
	2636120577324077328:  (*CallCycle)(nil),         /* text_eval=Cycle:over: */
	1765941604351725175:  (*Decrement)(nil),         /* execute=Decrease: */
	16337634811621251476: (*Decrement)(nil),         /* number_eval=Decrease: */
	13259725831972112539: (*DecrementAspect)(nil),   /* execute=Decrease:aspect: */
	9604047801594713852:  (*DecrementAspect)(nil),   /* text_eval=Decrease:aspect: */
	11515881376122775668: (*DecrementAspect)(nil),   /* execute=Decrease:aspect:by: */
	1589765377795283065:  (*DecrementAspect)(nil),   /* text_eval=Decrease:aspect:by: */
	10691394634979399555: (*DecrementAspect)(nil),   /* execute=Decrease:aspect:by:clamp: */
	16351892255943407142: (*DecrementAspect)(nil),   /* text_eval=Decrease:aspect:by:clamp: */
	16567257087826189312: (*DecrementAspect)(nil),   /* execute=Decrease:aspect:clamp: */
	7498537354592687963:  (*DecrementAspect)(nil),   /* text_eval=Decrease:aspect:clamp: */
	906537561468635208:   (*Decrement)(nil),         /* execute=Decrease:by: */
	7249930857706662977:  (*Decrement)(nil),         /* number_eval=Decrease:by: */
	14212233424935015742: (*DivideValue)(nil),       /* number_eval=Divide:value: */
	6766679711322815220:  (*During)(nil),            /* bool_eval=During: */
	1731395596460545319:  (*During)(nil),            /* number_eval=During: */
	1457631626735043065:  (*TriggerCycle)(nil),      /* trigger=Every */
	2224842870997259213:  (*FieldsOfKind)(nil),      /* text_list_eval=Fields of: */
	13697022905922221509: (*ChooseNothingElse)(nil), /* brancher=Finally do: */
	9805093500361992370:  (*IdOf)(nil),              /* text_eval=IdOf: */
	6524366950360243674:  (*ChooseBranch)(nil),      /* brancher=If:assuming:do: */
	12195526980856142720: (*ChooseBranch)(nil),      /* execute=If:assuming:do: */
	16752471159562852415: (*ChooseBranch)(nil),      /* brancher=If:assuming:do:else: */
	2092791308408463217:  (*ChooseBranch)(nil),      /* execute=If:assuming:do:else: */
	11676187955438326921: (*ChooseBranch)(nil),      /* brancher=If:do: */
	16551038912311542599: (*ChooseBranch)(nil),      /* execute=If:do: */
	11846460753008131314: (*ChooseBranch)(nil),      /* brancher=If:do:else: */
	9882017885672780228:  (*ChooseBranch)(nil),      /* execute=If:do:else: */
	3419326304120453839:  (*Increment)(nil),         /* execute=Increase: */
	5814330157137261092:  (*Increment)(nil),         /* number_eval=Increase: */
	11043224857467493683: (*IncrementAspect)(nil),   /* execute=Increase:aspect: */
	1296309673842091672:  (*IncrementAspect)(nil),   /* text_eval=Increase:aspect: */
	4473637830475551932:  (*IncrementAspect)(nil),   /* execute=Increase:aspect:by: */
	18328024260427443133: (*IncrementAspect)(nil),   /* text_eval=Increase:aspect:by: */
	1150598923989934235:  (*IncrementAspect)(nil),   /* execute=Increase:aspect:by:clamp: */
	16465259325356451354: (*IncrementAspect)(nil),   /* text_eval=Increase:aspect:by:clamp: */
	4522630356185077352:  (*IncrementAspect)(nil),   /* execute=Increase:aspect:clamp: */
	705264554644415287:   (*IncrementAspect)(nil),   /* text_eval=Increase:aspect:clamp: */
	9916665856596995152:  (*Increment)(nil),         /* execute=Increase:by: */
	6061586167490323121:  (*Increment)(nil),         /* number_eval=Increase:by: */
	16720860407833961741: (*HasDominion)(nil),       /* bool_eval=Is domain: */
	10867951538760575464: (*IsEmpty)(nil),           /* bool_eval=Is empty: */
	17183768313478169229: (*ObjectExists)(nil),      /* bool_eval=Is valid: */
	4986574662941955696:  (*CompareNum)(nil),        /* bool_eval=Is:matching:num: */
	6471221873898876231:  (*CompareNum)(nil),        /* bool_eval=Is:matching:num:within: */
	2616749751052919401:  (*CompareText)(nil),       /* bool_eval=Is:matching:text: */
	7216474174347601443:  (*CompareValue)(nil),      /* bool_eval=Is:matching:value: */
	10106284345457008764: (*Join)(nil),              /* text_eval=Join parts: */
	16037301925772243654: (*Join)(nil),              /* text_eval=Join:parts: */
	16305715626122315047: (*KindOf)(nil),            /* text_eval=KindOf: */
	16744881049704292640: (*IsKindOf)(nil),          /* bool_eval=KindOf:is: */
	210805642732508805:   (*IsKindOf)(nil),          /* bool_eval=KindOf:is:nothing: */
	7296079450764183372:  (*IsExactKindOf)(nil),     /* bool_eval=KindOf:isExactly: */
	4254622167054960918:  (*KindOf)(nil),            /* text_eval=KindOf:nothing: */
	6869420318733086481:  (*KindsOf)(nil),           /* text_list_eval=KindsOf: */
	11334467785012784241: (*MakeLowercase)(nil),     /* text_eval=Lower: */
	7007374677444567783:  (*Matches)(nil),           /* bool_eval=Matches:to: */
	734548188050460137:   (*ModValue)(nil),          /* number_eval=Mod:value: */
	17515508702665594117: (*MultiplyValue)(nil),     /* number_eval=Multiply:value: */
	15519818243985955688: (*NameOf)(nil),            /* text_eval=NameOf: */
	1310533520550597035:  (*Never)(nil),             /* bool_eval=Never */
	3572677870333466638:  (*Not)(nil),               /* bool_eval=Not: */
	2793972640309351788:  (*ChooseNum)(nil),         /* number_eval=Num if:then: */
	1916074756917320013:  (*ChooseNum)(nil),         /* number_eval=Num if:then:else: */
	18009133328614046007: (*PrintNumWord)(nil),      /* text_eval=Numeral words: */
	5709077775967698380:  (*PrintNum)(nil),          /* text_eval=Numeral: */
	15933580486837544843: (*ObjectTraits)(nil),      /* text_list_eval=Object traits: */
	7215745238754840573:  (*Blankline)(nil),         /* execute=P */
	11420921600352749983: (*Pluralize)(nil),         /* text_eval=Plural of: */
	4512128922644282356:  (*PrintText)(nil),         /* execute=Print: */
	16853421744116592875: (*While)(nil),             /* execute=Repeating:do: */
	12963686195606417453: (*MakeReversed)(nil),      /* text_eval=Reverse text: */
	14820902432990466009: (*Row)(nil),               /* text_eval=Row do: */
	42419598592471524:    (*Rows)(nil),              /* text_eval=Rows do: */
	10747671703915852065: (*MakeSentenceCase)(nil),  /* text_eval=Sentence: */
	3632089819497852687:  (*CallShuffle)(nil),       /* text_eval=Shuffle:over: */
	2397382738676796596:  (*Singularize)(nil),       /* text_eval=Singular of: */
	13377280423859122588: (*SlashText)(nil),         /* text_eval=Slashes do: */
	14637971099620461998: (*SpanText)(nil),          /* text_eval=Spaces do: */
	10180508752412200934: (*CallTerminal)(nil),      /* text_eval=Stopping:over: */
	6622046790206362641:  (*SubtractValue)(nil),     /* number_eval=Subtract:value: */
	10878271994667616824: (*MakeTitleCase)(nil),     /* text_eval=Title: */
	2711869841453509536:  (*CallTrigger)(nil),       /* bool_eval=Trigger:on:num: */
	9953804072544503126:  (*ChooseText)(nil),        /* text_eval=Txt if:then: */
	5534583393866490763:  (*ChooseText)(nil),        /* text_eval=Txt if:then:else: */
	5481656653805454214:  (*MakeUppercase)(nil),     /* text_eval=Upper: */
	16612725309683107572: (*Softline)(nil),          /* execute=Wbr */
}
