// Commands for scripting runtime behavior.
package core

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// brancher, a type of slot.
var Zt_Brancher = typeinfo.Slot{
	Name: "brancher",
	Markup: map[string]any{
		"comment": "Helper for the else statements of [ChooseBranch].",
	},
}

// Holds a single slot.
type Brancher_Slot struct{ Value Brancher }

// Implements [typeinfo.Instance] for a single slot.
func (*Brancher_Slot) TypeInfo() typeinfo.T {
	return &Zt_Brancher
}

// Holds a slice of slots.
type Brancher_Slots []Brancher

// Implements [typeinfo.Instance] for a slice of slots.
func (*Brancher_Slots) TypeInfo() typeinfo.T {
	return &Zt_Brancher
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *Brancher_Slots) Repeats() bool {
	return len(*op) > 0
}

// trigger, a type of slot.
var Zt_Trigger = typeinfo.Slot{
	Name: "trigger",
	Markup: map[string]any{
		"comment":  "Helper for counting values.",
		"internal": true,
	},
}

// Holds a single slot.
type Trigger_Slot struct{ Value Trigger }

// Implements [typeinfo.Instance] for a single slot.
func (*Trigger_Slot) TypeInfo() typeinfo.T {
	return &Zt_Trigger
}

// Holds a slice of slots.
type Trigger_Slots []Trigger

// Implements [typeinfo.Instance] for a slice of slots.
func (*Trigger_Slots) TypeInfo() typeinfo.T {
	return &Zt_Trigger
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *Trigger_Slots) Repeats() bool {
	return len(*op) > 0
}

// Test if a set of conditions all return true.
// Stops testing after the first condition fails.
type AllTrue struct {
	Test   []rtti.BoolEval
	Markup map[string]any
}

// all_true, a type of flow.
var Zt_AllTrue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AllTrue) TypeInfo() typeinfo.T {
	return &Zt_AllTrue
}

// Implements [typeinfo.Markup]
func (op *AllTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*AllTrue)(nil)

// Holds a slice of type AllTrue.
type AllTrue_Slice []AllTrue

// Implements [typeinfo.Instance] for a slice of AllTrue.
func (*AllTrue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AllTrue
}

// Implements [typeinfo.Repeats] for a slice of AllTrue.
func (op *AllTrue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return true; always.
type Always struct {
	Markup map[string]any
}

// always, a type of flow.
var Zt_Always typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Always) TypeInfo() typeinfo.T {
	return &Zt_Always
}

// Implements [typeinfo.Markup]
func (op *Always) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Always)(nil)

// Holds a slice of type Always.
type Always_Slice []Always

// Implements [typeinfo.Instance] for a slice of Always.
func (*Always_Slice) TypeInfo() typeinfo.T {
	return &Zt_Always
}

// Implements [typeinfo.Repeats] for a slice of Always.
func (op *Always_Slice) Repeats() bool {
	return len(*op) > 0
}

// Test if any condition in a set of conditions returns true.
// Stops testing after the first condition succeeds.
type AnyTrue struct {
	Test   []rtti.BoolEval
	Markup map[string]any
}

// any_true, a type of flow.
var Zt_AnyTrue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AnyTrue) TypeInfo() typeinfo.T {
	return &Zt_AnyTrue
}

// Implements [typeinfo.Markup]
func (op *AnyTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*AnyTrue)(nil)

// Holds a slice of type AnyTrue.
type AnyTrue_Slice []AnyTrue

// Implements [typeinfo.Instance] for a slice of AnyTrue.
func (*AnyTrue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AnyTrue
}

// Implements [typeinfo.Repeats] for a slice of AnyTrue.
func (op *AnyTrue_Slice) Repeats() bool {
	return len(*op) > 0
}

type BufferText struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// buffer_text, a type of flow.
var Zt_BufferText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*BufferText) TypeInfo() typeinfo.T {
	return &Zt_BufferText
}

// Implements [typeinfo.Markup]
func (op *BufferText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*BufferText)(nil)

// Holds a slice of type BufferText.
type BufferText_Slice []BufferText

// Implements [typeinfo.Instance] for a slice of BufferText.
func (*BufferText_Slice) TypeInfo() typeinfo.T {
	return &Zt_BufferText
}

// Implements [typeinfo.Repeats] for a slice of BufferText.
func (op *BufferText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Add a single blank line, unless a blank line was just written.
// See also <p> in package markup.
type ParagraphBreak struct {
	Markup map[string]any
}

// paragraph_break, a type of flow.
var Zt_ParagraphBreak typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ParagraphBreak) TypeInfo() typeinfo.T {
	return &Zt_ParagraphBreak
}

// Implements [typeinfo.Markup]
func (op *ParagraphBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ParagraphBreak)(nil)

// Holds a slice of type ParagraphBreak.
type ParagraphBreak_Slice []ParagraphBreak

// Implements [typeinfo.Instance] for a slice of ParagraphBreak.
func (*ParagraphBreak_Slice) TypeInfo() typeinfo.T {
	return &Zt_ParagraphBreak
}

// Implements [typeinfo.Repeats] for a slice of ParagraphBreak.
func (op *ParagraphBreak_Slice) Repeats() bool {
	return len(*op) > 0
}

// Collect printed text and surrounds the output with parenthesis '()'.
// If no text is printed, no parentheses are printed.
type PrintParens struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// print_parens, a type of flow.
var Zt_PrintParens typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintParens) TypeInfo() typeinfo.T {
	return &Zt_PrintParens
}

// Implements [typeinfo.Markup]
func (op *PrintParens) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintParens)(nil)
var _ rtti.Execute = (*PrintParens)(nil)

// Holds a slice of type PrintParens.
type PrintParens_Slice []PrintParens

// Implements [typeinfo.Instance] for a slice of PrintParens.
func (*PrintParens_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintParens
}

// Implements [typeinfo.Repeats] for a slice of PrintParens.
func (op *PrintParens_Slice) Repeats() bool {
	return len(*op) > 0
}

// In a repeating loop, exit the loop;
// or, in a rule, stop processing rules.
type Break struct {
	Markup map[string]any
}

// break, a type of flow.
var Zt_Break typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Break) TypeInfo() typeinfo.T {
	return &Zt_Break
}

// Implements [typeinfo.Markup]
func (op *Break) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Break)(nil)

// Holds a slice of type Break.
type Break_Slice []Break

// Implements [typeinfo.Instance] for a slice of Break.
func (*Break_Slice) TypeInfo() typeinfo.T {
	return &Zt_Break
}

// Implements [typeinfo.Repeats] for a slice of Break.
func (op *Break_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of cycle_text.
type CallCycle struct {
	Name   string
	Parts  []rtti.TextEval
	Markup map[string]any
}

// call_cycle, a type of flow.
var Zt_CallCycle typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallCycle) TypeInfo() typeinfo.T {
	return &Zt_CallCycle
}

// Implements [typeinfo.Markup]
func (op *CallCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*CallCycle)(nil)

// Holds a slice of type CallCycle.
type CallCycle_Slice []CallCycle

// Implements [typeinfo.Instance] for a slice of CallCycle.
func (*CallCycle_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallCycle
}

// Implements [typeinfo.Repeats] for a slice of CallCycle.
func (op *CallCycle_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of shuffle_text.
type CallShuffle struct {
	Name    string
	Parts   []rtti.TextEval
	Indices Shuffler
	Markup  map[string]any
}

// call_shuffle, a type of flow.
var Zt_CallShuffle typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallShuffle) TypeInfo() typeinfo.T {
	return &Zt_CallShuffle
}

// Implements [typeinfo.Markup]
func (op *CallShuffle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*CallShuffle)(nil)

// Holds a slice of type CallShuffle.
type CallShuffle_Slice []CallShuffle

// Implements [typeinfo.Instance] for a slice of CallShuffle.
func (*CallShuffle_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallShuffle
}

// Implements [typeinfo.Repeats] for a slice of CallShuffle.
func (op *CallShuffle_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of stopping_text.
type CallTerminal struct {
	Name   string
	Parts  []rtti.TextEval
	Markup map[string]any
}

// call_terminal, a type of flow.
var Zt_CallTerminal typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallTerminal) TypeInfo() typeinfo.T {
	return &Zt_CallTerminal
}

// Implements [typeinfo.Markup]
func (op *CallTerminal) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*CallTerminal)(nil)

// Holds a slice of type CallTerminal.
type CallTerminal_Slice []CallTerminal

// Implements [typeinfo.Instance] for a slice of CallTerminal.
func (*CallTerminal_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallTerminal
}

// Implements [typeinfo.Repeats] for a slice of CallTerminal.
func (op *CallTerminal_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of count_of.
// A guard which returns true based on a counter.
type CallTrigger struct {
	Name    string
	Trigger Trigger
	Num     rtti.NumEval
	Markup  map[string]any
}

// call_trigger, a type of flow.
var Zt_CallTrigger typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallTrigger) TypeInfo() typeinfo.T {
	return &Zt_CallTrigger
}

// Implements [typeinfo.Markup]
func (op *CallTrigger) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CallTrigger)(nil)

// Holds a slice of type CallTrigger.
type CallTrigger_Slice []CallTrigger

// Implements [typeinfo.Instance] for a slice of CallTrigger.
func (*CallTrigger_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallTrigger
}

// Implements [typeinfo.Repeats] for a slice of CallTrigger.
func (op *CallTrigger_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return a copy of some text with its first letter changed to uppercase.
type Capitalize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// capitalize, a type of flow.
var Zt_Capitalize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Capitalize) TypeInfo() typeinfo.T {
	return &Zt_Capitalize
}

// Implements [typeinfo.Markup]
func (op *Capitalize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Capitalize)(nil)

// Holds a slice of type Capitalize.
type Capitalize_Slice []Capitalize

// Implements [typeinfo.Instance] for a slice of Capitalize.
func (*Capitalize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Capitalize
}

// Implements [typeinfo.Repeats] for a slice of Capitalize.
func (op *Capitalize_Slice) Repeats() bool {
	return len(*op) > 0
}

// An if statement.
type ChooseBranch struct {
	Condition rtti.BoolEval
	Args      []assign.Arg
	Exe       []rtti.Execute
	Else      Brancher
	Markup    map[string]any
}

// choose_branch, a type of flow.
var Zt_ChooseBranch typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseBranch) TypeInfo() typeinfo.T {
	return &Zt_ChooseBranch
}

// Implements [typeinfo.Markup]
func (op *ChooseBranch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ChooseBranch)(nil)
var _ Brancher = (*ChooseBranch)(nil)

// Holds a slice of type ChooseBranch.
type ChooseBranch_Slice []ChooseBranch

// Implements [typeinfo.Instance] for a slice of ChooseBranch.
func (*ChooseBranch_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseBranch
}

// Implements [typeinfo.Repeats] for a slice of ChooseBranch.
func (op *ChooseBranch_Slice) Repeats() bool {
	return len(*op) > 0
}

// Run a set of statements after a condition has failed.
type ChooseNothingElse struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// choose_nothing_else, a type of flow.
var Zt_ChooseNothingElse typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseNothingElse) TypeInfo() typeinfo.T {
	return &Zt_ChooseNothingElse
}

// Implements [typeinfo.Markup]
func (op *ChooseNothingElse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Brancher = (*ChooseNothingElse)(nil)

// Holds a slice of type ChooseNothingElse.
type ChooseNothingElse_Slice []ChooseNothingElse

// Implements [typeinfo.Instance] for a slice of ChooseNothingElse.
func (*ChooseNothingElse_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseNothingElse
}

// Implements [typeinfo.Repeats] for a slice of ChooseNothingElse.
func (op *ChooseNothingElse_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pick one of two possible text values based on a condition.
// ( This acts similar to a ternary. )
type ChooseNum struct {
	If     rtti.BoolEval
	Args   []assign.Arg
	True   rtti.NumEval
	False  rtti.NumEval
	Markup map[string]any
}

// choose_num, a type of flow.
var Zt_ChooseNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseNum) TypeInfo() typeinfo.T {
	return &Zt_ChooseNum
}

// Implements [typeinfo.Markup]
func (op *ChooseNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*ChooseNum)(nil)

// Holds a slice of type ChooseNum.
type ChooseNum_Slice []ChooseNum

// Implements [typeinfo.Instance] for a slice of ChooseNum.
func (*ChooseNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseNum
}

// Implements [typeinfo.Repeats] for a slice of ChooseNum.
func (op *ChooseNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pick one of two possible text values based on a condition.
// ( This acts similar to a ternary. )
type ChooseText struct {
	If     rtti.BoolEval
	Args   []assign.Arg
	True   rtti.TextEval
	False  rtti.TextEval
	Markup map[string]any
}

// choose_text, a type of flow.
var Zt_ChooseText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseText) TypeInfo() typeinfo.T {
	return &Zt_ChooseText
}

// Implements [typeinfo.Markup]
func (op *ChooseText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*ChooseText)(nil)

// Holds a slice of type ChooseText.
type ChooseText_Slice []ChooseText

// Implements [typeinfo.Instance] for a slice of ChooseText.
func (*ChooseText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseText
}

// Implements [typeinfo.Repeats] for a slice of ChooseText.
func (op *ChooseText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Separates words with commas, and 'and'.
type PrintCommas struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// print_commas, a type of flow.
var Zt_PrintCommas typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintCommas) TypeInfo() typeinfo.T {
	return &Zt_PrintCommas
}

// Implements [typeinfo.Markup]
func (op *PrintCommas) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintCommas)(nil)
var _ rtti.Execute = (*PrintCommas)(nil)

// Holds a slice of type PrintCommas.
type PrintCommas_Slice []PrintCommas

// Implements [typeinfo.Instance] for a slice of PrintCommas.
func (*PrintCommas_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintCommas
}

// Implements [typeinfo.Repeats] for a slice of PrintCommas.
func (op *PrintCommas_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if eq,ne,gt,lt,ge,le two numbers.
type CompareValue struct {
	A      rtti.Assignment
	Is     Comparison
	B      rtti.Assignment
	Markup map[string]any
}

// compare_value, a type of flow.
var Zt_CompareValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CompareValue) TypeInfo() typeinfo.T {
	return &Zt_CompareValue
}

// Implements [typeinfo.Markup]
func (op *CompareValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CompareValue)(nil)

// Holds a slice of type CompareValue.
type CompareValue_Slice []CompareValue

// Implements [typeinfo.Instance] for a slice of CompareValue.
func (*CompareValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareValue
}

// Implements [typeinfo.Repeats] for a slice of CompareValue.
func (op *CompareValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if eq,ne,gt,lt,ge,le two numbers.
type CompareNum struct {
	A         rtti.NumEval
	Is        Comparison
	B         rtti.NumEval
	Tolerance float64
	Markup    map[string]any
}

// compare_num, a type of flow.
var Zt_CompareNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CompareNum) TypeInfo() typeinfo.T {
	return &Zt_CompareNum
}

// Implements [typeinfo.Markup]
func (op *CompareNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CompareNum)(nil)

// Holds a slice of type CompareNum.
type CompareNum_Slice []CompareNum

// Implements [typeinfo.Instance] for a slice of CompareNum.
func (*CompareNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareNum
}

// Implements [typeinfo.Repeats] for a slice of CompareNum.
func (op *CompareNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if eq,ne,gt,lt,ge,le two strings ( lexical. ).
type CompareText struct {
	A      rtti.TextEval
	Is     Comparison
	B      rtti.TextEval
	Markup map[string]any
}

// compare_text, a type of flow.
var Zt_CompareText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CompareText) TypeInfo() typeinfo.T {
	return &Zt_CompareText
}

// Implements [typeinfo.Markup]
func (op *CompareText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CompareText)(nil)

// Holds a slice of type CompareText.
type CompareText_Slice []CompareText

// Implements [typeinfo.Instance] for a slice of CompareText.
func (*CompareText_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareText
}

// Implements [typeinfo.Repeats] for a slice of CompareText.
func (op *CompareText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Subtract two numbers.
type SubtractValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// subtract_value, a type of flow.
var Zt_SubtractValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SubtractValue) TypeInfo() typeinfo.T {
	return &Zt_SubtractValue
}

// Implements [typeinfo.Markup]
func (op *SubtractValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*SubtractValue)(nil)

// Holds a slice of type SubtractValue.
type SubtractValue_Slice []SubtractValue

// Implements [typeinfo.Instance] for a slice of SubtractValue.
func (*SubtractValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_SubtractValue
}

// Implements [typeinfo.Repeats] for a slice of SubtractValue.
func (op *SubtractValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Decide whether a pattern is running.
type During struct {
	PatternName string
	Markup      map[string]any
}

// during, a type of flow.
var Zt_During typeinfo.Flow

// Implements [typeinfo.Instance]
func (*During) TypeInfo() typeinfo.T {
	return &Zt_During
}

// Implements [typeinfo.Markup]
func (op *During) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*During)(nil)
var _ rtti.NumEval = (*During)(nil)

// Holds a slice of type During.
type During_Slice []During

// Implements [typeinfo.Instance] for a slice of During.
func (*During_Slice) TypeInfo() typeinfo.T {
	return &Zt_During
}

// Implements [typeinfo.Repeats] for a slice of During.
func (op *During_Slice) Repeats() bool {
	return len(*op) > 0
}

// List of the field names of a kind.
type FieldsOfKind struct {
	KindName rtti.TextEval
	Markup   map[string]any
}

// fields_of_kind, a type of flow.
var Zt_FieldsOfKind typeinfo.Flow

// Implements [typeinfo.Instance]
func (*FieldsOfKind) TypeInfo() typeinfo.T {
	return &Zt_FieldsOfKind
}

// Implements [typeinfo.Markup]
func (op *FieldsOfKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*FieldsOfKind)(nil)

// Holds a slice of type FieldsOfKind.
type FieldsOfKind_Slice []FieldsOfKind

// Implements [typeinfo.Instance] for a slice of FieldsOfKind.
func (*FieldsOfKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_FieldsOfKind
}

// Implements [typeinfo.Repeats] for a slice of FieldsOfKind.
func (op *FieldsOfKind_Slice) Repeats() bool {
	return len(*op) > 0
}

type HasDominion struct {
	Name   string
	Markup map[string]any
}

// has_dominion, a type of flow.
var Zt_HasDominion typeinfo.Flow

// Implements [typeinfo.Instance]
func (*HasDominion) TypeInfo() typeinfo.T {
	return &Zt_HasDominion
}

// Implements [typeinfo.Markup]
func (op *HasDominion) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*HasDominion)(nil)

// Holds a slice of type HasDominion.
type HasDominion_Slice []HasDominion

// Implements [typeinfo.Instance] for a slice of HasDominion.
func (*HasDominion_Slice) TypeInfo() typeinfo.T {
	return &Zt_HasDominion
}

// Implements [typeinfo.Repeats] for a slice of HasDominion.
func (op *HasDominion_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if text contains text.
type Includes struct {
	Text   rtti.TextEval
	Part   rtti.TextEval
	Markup map[string]any
}

// includes, a type of flow.
var Zt_Includes typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Includes) TypeInfo() typeinfo.T {
	return &Zt_Includes
}

// Implements [typeinfo.Markup]
func (op *Includes) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Includes)(nil)

// Holds a slice of type Includes.
type Includes_Slice []Includes

// Implements [typeinfo.Instance] for a slice of Includes.
func (*Includes_Slice) TypeInfo() typeinfo.T {
	return &Zt_Includes
}

// Implements [typeinfo.Repeats] for a slice of Includes.
func (op *Includes_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if the text is empty.
type IsEmpty struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// is_empty, a type of flow.
var Zt_IsEmpty typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IsEmpty) TypeInfo() typeinfo.T {
	return &Zt_IsEmpty
}

// Implements [typeinfo.Markup]
func (op *IsEmpty) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*IsEmpty)(nil)

// Holds a slice of type IsEmpty.
type IsEmpty_Slice []IsEmpty

// Implements [typeinfo.Instance] for a slice of IsEmpty.
func (*IsEmpty_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsEmpty
}

// Implements [typeinfo.Repeats] for a slice of IsEmpty.
func (op *IsEmpty_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if the object is exactly the named kind.
type IsExactKindOf struct {
	Object rtti.TextEval
	Kind   string
	Markup map[string]any
}

// is_exact_kind_of, a type of flow.
var Zt_IsExactKindOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IsExactKindOf) TypeInfo() typeinfo.T {
	return &Zt_IsExactKindOf
}

// Implements [typeinfo.Markup]
func (op *IsExactKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*IsExactKindOf)(nil)

// Holds a slice of type IsExactKindOf.
type IsExactKindOf_Slice []IsExactKindOf

// Implements [typeinfo.Instance] for a slice of IsExactKindOf.
func (*IsExactKindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsExactKindOf
}

// Implements [typeinfo.Repeats] for a slice of IsExactKindOf.
func (op *IsExactKindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// True if the object is compatible with the named kind.
type IsKindOf struct {
	Object  rtti.TextEval
	Kind    string
	Nothing bool
	Markup  map[string]any
}

// is_kind_of, a type of flow.
var Zt_IsKindOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IsKindOf) TypeInfo() typeinfo.T {
	return &Zt_IsKindOf
}

// Implements [typeinfo.Markup]
func (op *IsKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*IsKindOf)(nil)

// Holds a slice of type IsKindOf.
type IsKindOf_Slice []IsKindOf

// Implements [typeinfo.Instance] for a slice of IsKindOf.
func (*IsKindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsKindOf
}

// Implements [typeinfo.Repeats] for a slice of IsKindOf.
func (op *IsKindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns multiple pieces of text as a single new piece of text.
type Join struct {
	Sep    rtti.TextEval
	Parts  []rtti.TextEval
	Markup map[string]any
}

// join, a type of flow.
var Zt_Join typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Join) TypeInfo() typeinfo.T {
	return &Zt_Join
}

// Implements [typeinfo.Markup]
func (op *Join) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Join)(nil)

// Holds a slice of type Join.
type Join_Slice []Join

// Implements [typeinfo.Instance] for a slice of Join.
func (*Join_Slice) TypeInfo() typeinfo.T {
	return &Zt_Join
}

// Implements [typeinfo.Repeats] for a slice of Join.
func (op *Join_Slice) Repeats() bool {
	return len(*op) > 0
}

// Friendly name of the object's kind.
type KindOf struct {
	Object  rtti.TextEval
	Nothing bool
	Markup  map[string]any
}

// kind_of, a type of flow.
var Zt_KindOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindOf) TypeInfo() typeinfo.T {
	return &Zt_KindOf
}

// Implements [typeinfo.Markup]
func (op *KindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*KindOf)(nil)

// Holds a slice of type KindOf.
type KindOf_Slice []KindOf

// Implements [typeinfo.Instance] for a slice of KindOf.
func (*KindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindOf
}

// Implements [typeinfo.Repeats] for a slice of KindOf.
func (op *KindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// A list of compatible kinds.
type KindsOf struct {
	Kind   string
	Markup map[string]any
}

// kinds_of, a type of flow.
var Zt_KindsOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindsOf) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// Implements [typeinfo.Markup]
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*KindsOf)(nil)

// Holds a slice of type KindsOf.
type KindsOf_Slice []KindsOf

// Implements [typeinfo.Instance] for a slice of KindsOf.
func (*KindsOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// Implements [typeinfo.Repeats] for a slice of KindsOf.
func (op *KindsOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, with every letter turned into lowercase. For example, 'shout' from 'SHOUT'.
type MakeLowercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_lowercase, a type of flow.
var Zt_MakeLowercase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeLowercase) TypeInfo() typeinfo.T {
	return &Zt_MakeLowercase
}

// Implements [typeinfo.Markup]
func (op *MakeLowercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeLowercase)(nil)

// Holds a slice of type MakeLowercase.
type MakeLowercase_Slice []MakeLowercase

// Implements [typeinfo.Instance] for a slice of MakeLowercase.
func (*MakeLowercase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeLowercase
}

// Implements [typeinfo.Repeats] for a slice of MakeLowercase.
func (op *MakeLowercase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text flipped back to front. For example, 'elppA' from 'Apple', or 'noon' from 'noon'.
type MakeReversed struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_reversed, a type of flow.
var Zt_MakeReversed typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeReversed) TypeInfo() typeinfo.T {
	return &Zt_MakeReversed
}

// Implements [typeinfo.Markup]
func (op *MakeReversed) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeReversed)(nil)

// Holds a slice of type MakeReversed.
type MakeReversed_Slice []MakeReversed

// Implements [typeinfo.Instance] for a slice of MakeReversed.
func (*MakeReversed_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeReversed
}

// Implements [typeinfo.Repeats] for a slice of MakeReversed.
func (op *MakeReversed_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, start each sentence with a capital letter. For example, 'Empire Apple.' from 'Empire apple.'.
type MakeSentenceCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_sentence_case, a type of flow.
var Zt_MakeSentenceCase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeSentenceCase) TypeInfo() typeinfo.T {
	return &Zt_MakeSentenceCase
}

// Implements [typeinfo.Markup]
func (op *MakeSentenceCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeSentenceCase)(nil)

// Holds a slice of type MakeSentenceCase.
type MakeSentenceCase_Slice []MakeSentenceCase

// Implements [typeinfo.Instance] for a slice of MakeSentenceCase.
func (*MakeSentenceCase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeSentenceCase
}

// Implements [typeinfo.Repeats] for a slice of MakeSentenceCase.
func (op *MakeSentenceCase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, starting each word with a capital letter. For example, 'Empire Apple' from 'empire apple'.
type MakeTitleCase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_title_case, a type of flow.
var Zt_MakeTitleCase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeTitleCase) TypeInfo() typeinfo.T {
	return &Zt_MakeTitleCase
}

// Implements [typeinfo.Markup]
func (op *MakeTitleCase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeTitleCase)(nil)

// Holds a slice of type MakeTitleCase.
type MakeTitleCase_Slice []MakeTitleCase

// Implements [typeinfo.Instance] for a slice of MakeTitleCase.
func (*MakeTitleCase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeTitleCase
}

// Implements [typeinfo.Repeats] for a slice of MakeTitleCase.
func (op *MakeTitleCase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns new text, with every letter turned into uppercase. For example, 'APPLE' from 'apple'.
type MakeUppercase struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// make_uppercase, a type of flow.
var Zt_MakeUppercase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeUppercase) TypeInfo() typeinfo.T {
	return &Zt_MakeUppercase
}

// Implements [typeinfo.Markup]
func (op *MakeUppercase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*MakeUppercase)(nil)

// Holds a slice of type MakeUppercase.
type MakeUppercase_Slice []MakeUppercase

// Implements [typeinfo.Instance] for a slice of MakeUppercase.
func (*MakeUppercase_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeUppercase
}

// Implements [typeinfo.Repeats] for a slice of MakeUppercase.
func (op *MakeUppercase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether the specified text is similar to the specified regular expression.
type Matches struct {
	Text   rtti.TextEval
	Match  string
	Cache  MatchCache
	Markup map[string]any
}

// matches, a type of flow.
var Zt_Matches typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Matches) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// Implements [typeinfo.Markup]
func (op *Matches) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Matches)(nil)

// Holds a slice of type Matches.
type Matches_Slice []Matches

// Implements [typeinfo.Instance] for a slice of Matches.
func (*Matches_Slice) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// Implements [typeinfo.Repeats] for a slice of Matches.
func (op *Matches_Slice) Repeats() bool {
	return len(*op) > 0
}

// Full name of the object.
type NameOf struct {
	Object rtti.TextEval
	Markup map[string]any
}

// name_of, a type of flow.
var Zt_NameOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NameOf) TypeInfo() typeinfo.T {
	return &Zt_NameOf
}

// Implements [typeinfo.Markup]
func (op *NameOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*NameOf)(nil)

// Holds a slice of type NameOf.
type NameOf_Slice []NameOf

// Implements [typeinfo.Instance] for a slice of NameOf.
func (*NameOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_NameOf
}

// Implements [typeinfo.Repeats] for a slice of NameOf.
func (op *NameOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns false.
type Never struct {
	Markup map[string]any
}

// never, a type of flow.
var Zt_Never typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Never) TypeInfo() typeinfo.T {
	return &Zt_Never
}

// Implements [typeinfo.Markup]
func (op *Never) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Never)(nil)

// Holds a slice of type Never.
type Never_Slice []Never

// Implements [typeinfo.Instance] for a slice of Never.
func (*Never_Slice) TypeInfo() typeinfo.T {
	return &Zt_Never
}

// Implements [typeinfo.Repeats] for a slice of Never.
func (op *Never_Slice) Repeats() bool {
	return len(*op) > 0
}

// Start a new line.
type LineBreak struct {
	Markup map[string]any
}

// line_break, a type of flow.
var Zt_LineBreak typeinfo.Flow

// Implements [typeinfo.Instance]
func (*LineBreak) TypeInfo() typeinfo.T {
	return &Zt_LineBreak
}

// Implements [typeinfo.Markup]
func (op *LineBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*LineBreak)(nil)

// Holds a slice of type LineBreak.
type LineBreak_Slice []LineBreak

// Implements [typeinfo.Instance] for a slice of LineBreak.
func (*LineBreak_Slice) TypeInfo() typeinfo.T {
	return &Zt_LineBreak
}

// Implements [typeinfo.Repeats] for a slice of LineBreak.
func (op *LineBreak_Slice) Repeats() bool {
	return len(*op) > 0
}

// In a repeating loop, try the next iteration of the loop;
// or, in a rule, continue to the next rule.
type Continue struct {
	Markup map[string]any
}

// continue, a type of flow.
var Zt_Continue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Continue) TypeInfo() typeinfo.T {
	return &Zt_Continue
}

// Implements [typeinfo.Markup]
func (op *Continue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Continue)(nil)

// Holds a slice of type Continue.
type Continue_Slice []Continue

// Implements [typeinfo.Instance] for a slice of Continue.
func (*Continue_Slice) TypeInfo() typeinfo.T {
	return &Zt_Continue
}

// Implements [typeinfo.Repeats] for a slice of Continue.
func (op *Continue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the opposite value.
type Not struct {
	Test   rtti.BoolEval
	Markup map[string]any
}

// not, a type of flow.
var Zt_Not typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Not) TypeInfo() typeinfo.T {
	return &Zt_Not
}

// Implements [typeinfo.Markup]
func (op *Not) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Not)(nil)

// Holds a slice of type Not.
type Not_Slice []Not

// Implements [typeinfo.Instance] for a slice of Not.
func (*Not_Slice) TypeInfo() typeinfo.T {
	return &Zt_Not
}

// Implements [typeinfo.Repeats] for a slice of Not.
func (op *Not_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns all of the object's current traits as a list of text.
type ObjectTraits struct {
	Object rtti.TextEval
	Markup map[string]any
}

// object_traits, a type of flow.
var Zt_ObjectTraits typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ObjectTraits) TypeInfo() typeinfo.T {
	return &Zt_ObjectTraits
}

// Implements [typeinfo.Markup]
func (op *ObjectTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*ObjectTraits)(nil)

// Holds a slice of type ObjectTraits.
type ObjectTraits_Slice []ObjectTraits

// Implements [typeinfo.Instance] for a slice of ObjectTraits.
func (*ObjectTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_ObjectTraits
}

// Implements [typeinfo.Repeats] for a slice of ObjectTraits.
func (op *ObjectTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the plural form of a singular word. (ex. apples for apple. ).
type Pluralize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// pluralize, a type of flow.
var Zt_Pluralize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Pluralize) TypeInfo() typeinfo.T {
	return &Zt_Pluralize
}

// Implements [typeinfo.Markup]
func (op *Pluralize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Pluralize)(nil)

// Holds a slice of type Pluralize.
type Pluralize_Slice []Pluralize

// Implements [typeinfo.Instance] for a slice of Pluralize.
func (*Pluralize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Pluralize
}

// Implements [typeinfo.Repeats] for a slice of Pluralize.
func (op *Pluralize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes a number using numerals, eg. '1'.
type PrintNum struct {
	Num    rtti.NumEval
	Markup map[string]any
}

// print_num, a type of flow.
var Zt_PrintNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintNum) TypeInfo() typeinfo.T {
	return &Zt_PrintNum
}

// Implements [typeinfo.Markup]
func (op *PrintNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintNum)(nil)

// Holds a slice of type PrintNum.
type PrintNum_Slice []PrintNum

// Implements [typeinfo.Instance] for a slice of PrintNum.
func (*PrintNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintNum
}

// Implements [typeinfo.Repeats] for a slice of PrintNum.
func (op *PrintNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes a number in plain english: eg. 'one'.
type PrintNumWord struct {
	Num    rtti.NumEval
	Markup map[string]any
}

// print_num_word, a type of flow.
var Zt_PrintNumWord typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintNumWord) TypeInfo() typeinfo.T {
	return &Zt_PrintNumWord
}

// Implements [typeinfo.Markup]
func (op *PrintNumWord) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintNumWord)(nil)

// Holds a slice of type PrintNumWord.
type PrintNumWord_Slice []PrintNumWord

// Implements [typeinfo.Instance] for a slice of PrintNumWord.
func (*PrintNumWord_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintNumWord
}

// Implements [typeinfo.Repeats] for a slice of PrintNumWord.
func (op *PrintNumWord_Slice) Repeats() bool {
	return len(*op) > 0
}

// Multiply two numbers.
type MultiplyValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// multiply_value, a type of flow.
var Zt_MultiplyValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MultiplyValue) TypeInfo() typeinfo.T {
	return &Zt_MultiplyValue
}

// Implements [typeinfo.Markup]
func (op *MultiplyValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*MultiplyValue)(nil)

// Holds a slice of type MultiplyValue.
type MultiplyValue_Slice []MultiplyValue

// Implements [typeinfo.Instance] for a slice of MultiplyValue.
func (*MultiplyValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_MultiplyValue
}

// Implements [typeinfo.Repeats] for a slice of MultiplyValue.
func (op *MultiplyValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Divide one number by another.
type DivideValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// divide_value, a type of flow.
var Zt_DivideValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DivideValue) TypeInfo() typeinfo.T {
	return &Zt_DivideValue
}

// Implements [typeinfo.Markup]
func (op *DivideValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*DivideValue)(nil)

// Holds a slice of type DivideValue.
type DivideValue_Slice []DivideValue

// Implements [typeinfo.Instance] for a slice of DivideValue.
func (*DivideValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_DivideValue
}

// Implements [typeinfo.Repeats] for a slice of DivideValue.
func (op *DivideValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Divide one number by another, and return the remainder.
type ModValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// mod_value, a type of flow.
var Zt_ModValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ModValue) TypeInfo() typeinfo.T {
	return &Zt_ModValue
}

// Implements [typeinfo.Markup]
func (op *ModValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*ModValue)(nil)

// Holds a slice of type ModValue.
type ModValue_Slice []ModValue

// Implements [typeinfo.Instance] for a slice of ModValue.
func (*ModValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_ModValue
}

// Implements [typeinfo.Repeats] for a slice of ModValue.
func (op *ModValue_Slice) Repeats() bool {
	return len(*op) > 0
}

type AbsValue struct {
	Value  rtti.NumEval
	Markup map[string]any
}

// abs_value, a type of flow.
var Zt_AbsValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AbsValue) TypeInfo() typeinfo.T {
	return &Zt_AbsValue
}

// Implements [typeinfo.Markup]
func (op *AbsValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*AbsValue)(nil)

// Holds a slice of type AbsValue.
type AbsValue_Slice []AbsValue

// Implements [typeinfo.Instance] for a slice of AbsValue.
func (*AbsValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AbsValue
}

// Implements [typeinfo.Repeats] for a slice of AbsValue.
func (op *AbsValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Increases the value of a number held in by a variable or object field.
// Returns the new value of the number.
type Increment struct {
	Target assign.Address
	Step   rtti.NumEval
	Markup map[string]any
}

// increment, a type of flow.
var Zt_Increment typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Increment) TypeInfo() typeinfo.T {
	return &Zt_Increment
}

// Implements [typeinfo.Markup]
func (op *Increment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*Increment)(nil)
var _ rtti.Execute = (*Increment)(nil)

// Holds a slice of type Increment.
type Increment_Slice []Increment

// Implements [typeinfo.Instance] for a slice of Increment.
func (*Increment_Slice) TypeInfo() typeinfo.T {
	return &Zt_Increment
}

// Implements [typeinfo.Repeats] for a slice of Increment.
func (op *Increment_Slice) Repeats() bool {
	return len(*op) > 0
}

// Decrease the value of a number held in by a variable or object field.
// Returns the new value of the number.
type Decrement struct {
	Target assign.Address
	Step   rtti.NumEval
	Markup map[string]any
}

// decrement, a type of flow.
var Zt_Decrement typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Decrement) TypeInfo() typeinfo.T {
	return &Zt_Decrement
}

// Implements [typeinfo.Markup]
func (op *Decrement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*Decrement)(nil)
var _ rtti.Execute = (*Decrement)(nil)

// Holds a slice of type Decrement.
type Decrement_Slice []Decrement

// Implements [typeinfo.Instance] for a slice of Decrement.
func (*Decrement_Slice) TypeInfo() typeinfo.T {
	return &Zt_Decrement
}

// Implements [typeinfo.Repeats] for a slice of Decrement.
func (op *Decrement_Slice) Repeats() bool {
	return len(*op) > 0
}

// Increases the value of a trait held by an object aspect.
// Returns the new value of the trait.
type IncrementAspect struct {
	Target rtti.TextEval
	Aspect rtti.TextEval
	Step   rtti.NumEval
	Clamp  rtti.BoolEval
	Markup map[string]any
}

// increment_aspect, a type of flow.
var Zt_IncrementAspect typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IncrementAspect) TypeInfo() typeinfo.T {
	return &Zt_IncrementAspect
}

// Implements [typeinfo.Markup]
func (op *IncrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*IncrementAspect)(nil)
var _ rtti.Execute = (*IncrementAspect)(nil)

// Holds a slice of type IncrementAspect.
type IncrementAspect_Slice []IncrementAspect

// Implements [typeinfo.Instance] for a slice of IncrementAspect.
func (*IncrementAspect_Slice) TypeInfo() typeinfo.T {
	return &Zt_IncrementAspect
}

// Implements [typeinfo.Repeats] for a slice of IncrementAspect.
func (op *IncrementAspect_Slice) Repeats() bool {
	return len(*op) > 0
}

// Increases the value of a trait held by an object aspect.
// Returns the new value of the trait.
type DecrementAspect struct {
	Target rtti.TextEval
	Aspect rtti.TextEval
	Step   rtti.NumEval
	Clamp  rtti.BoolEval
	Markup map[string]any
}

// decrement_aspect, a type of flow.
var Zt_DecrementAspect typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DecrementAspect) TypeInfo() typeinfo.T {
	return &Zt_DecrementAspect
}

// Implements [typeinfo.Markup]
func (op *DecrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*DecrementAspect)(nil)
var _ rtti.Execute = (*DecrementAspect)(nil)

// Holds a slice of type DecrementAspect.
type DecrementAspect_Slice []DecrementAspect

// Implements [typeinfo.Instance] for a slice of DecrementAspect.
func (*DecrementAspect_Slice) TypeInfo() typeinfo.T {
	return &Zt_DecrementAspect
}

// Implements [typeinfo.Repeats] for a slice of DecrementAspect.
func (op *DecrementAspect_Slice) Repeats() bool {
	return len(*op) > 0
}

// Display some text to the player without apply any additional formatting.
type PrintText struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// print_text, a type of flow.
var Zt_PrintText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintText) TypeInfo() typeinfo.T {
	return &Zt_PrintText
}

// Implements [typeinfo.Markup]
func (op *PrintText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*PrintText)(nil)

// Holds a slice of type PrintText.
type PrintText_Slice []PrintText

// Implements [typeinfo.Instance] for a slice of PrintText.
func (*PrintText_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintText
}

// Implements [typeinfo.Repeats] for a slice of PrintText.
func (op *PrintText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Group text into a single line <li> as part of a list of lines.
// See also: 'rows'.
type Row struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// row, a type of flow.
var Zt_Row typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Row) TypeInfo() typeinfo.T {
	return &Zt_Row
}

// Implements [typeinfo.Markup]
func (op *Row) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Row)(nil)

// Holds a slice of type Row.
type Row_Slice []Row

// Implements [typeinfo.Instance] for a slice of Row.
func (*Row_Slice) TypeInfo() typeinfo.T {
	return &Zt_Row
}

// Implements [typeinfo.Repeats] for a slice of Row.
func (op *Row_Slice) Repeats() bool {
	return len(*op) > 0
}

// Group text into an unordered list <ul>.
type Rows struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// rows, a type of flow.
var Zt_Rows typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Rows) TypeInfo() typeinfo.T {
	return &Zt_Rows
}

// Implements [typeinfo.Markup]
func (op *Rows) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Rows)(nil)

// Holds a slice of type Rows.
type Rows_Slice []Rows

// Implements [typeinfo.Instance] for a slice of Rows.
func (*Rows_Slice) TypeInfo() typeinfo.T {
	return &Zt_Rows
}

// Implements [typeinfo.Repeats] for a slice of Rows.
func (op *Rows_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the singular form of a plural word. (ex. apple for apples ).
type Singularize struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// singularize, a type of flow.
var Zt_Singularize typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Singularize) TypeInfo() typeinfo.T {
	return &Zt_Singularize
}

// Implements [typeinfo.Markup]
func (op *Singularize) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Singularize)(nil)

// Holds a slice of type Singularize.
type Singularize_Slice []Singularize

// Implements [typeinfo.Instance] for a slice of Singularize.
func (*Singularize_Slice) TypeInfo() typeinfo.T {
	return &Zt_Singularize
}

// Implements [typeinfo.Repeats] for a slice of Singularize.
func (op *Singularize_Slice) Repeats() bool {
	return len(*op) > 0
}

// Start a new line ( if not already at a new line ).
type Softline struct {
	Markup map[string]any
}

// softline, a type of flow.
var Zt_Softline typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Softline) TypeInfo() typeinfo.T {
	return &Zt_Softline
}

// Implements [typeinfo.Markup]
func (op *Softline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Softline)(nil)

// Holds a slice of type Softline.
type Softline_Slice []Softline

// Implements [typeinfo.Instance] for a slice of Softline.
func (*Softline_Slice) TypeInfo() typeinfo.T {
	return &Zt_Softline
}

// Implements [typeinfo.Repeats] for a slice of Softline.
func (op *Softline_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes text, by default putting spaces between words.
type PrintWords struct {
	Separator rtti.TextEval
	Exe       []rtti.Execute
	Markup    map[string]any
}

// print_words, a type of flow.
var Zt_PrintWords typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintWords) TypeInfo() typeinfo.T {
	return &Zt_PrintWords
}

// Implements [typeinfo.Markup]
func (op *PrintWords) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*PrintWords)(nil)
var _ rtti.TextEval = (*PrintWords)(nil)

// Holds a slice of type PrintWords.
type PrintWords_Slice []PrintWords

// Implements [typeinfo.Instance] for a slice of PrintWords.
func (*PrintWords_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintWords
}

// Implements [typeinfo.Repeats] for a slice of PrintWords.
func (op *PrintWords_Slice) Repeats() bool {
	return len(*op) > 0
}

// Add two numbers.
type AddValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// add_value, a type of flow.
var Zt_AddValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AddValue) TypeInfo() typeinfo.T {
	return &Zt_AddValue
}

// Implements [typeinfo.Markup]
func (op *AddValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*AddValue)(nil)

// Holds a slice of type AddValue.
type AddValue_Slice []AddValue

// Implements [typeinfo.Instance] for a slice of AddValue.
func (*AddValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AddValue
}

// Implements [typeinfo.Repeats] for a slice of AddValue.
func (op *AddValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// call_trigger
type TriggerCycle struct {
	Markup map[string]any
}

// trigger_cycle, a type of flow.
var Zt_TriggerCycle typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TriggerCycle) TypeInfo() typeinfo.T {
	return &Zt_TriggerCycle
}

// Implements [typeinfo.Markup]
func (op *TriggerCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Trigger = (*TriggerCycle)(nil)

// Holds a slice of type TriggerCycle.
type TriggerCycle_Slice []TriggerCycle

// Implements [typeinfo.Instance] for a slice of TriggerCycle.
func (*TriggerCycle_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerCycle
}

// Implements [typeinfo.Repeats] for a slice of TriggerCycle.
func (op *TriggerCycle_Slice) Repeats() bool {
	return len(*op) > 0
}

// call_trigger
type TriggerOnce struct {
	Markup map[string]any
}

// trigger_once, a type of flow.
var Zt_TriggerOnce typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TriggerOnce) TypeInfo() typeinfo.T {
	return &Zt_TriggerOnce
}

// Implements [typeinfo.Markup]
func (op *TriggerOnce) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Trigger = (*TriggerOnce)(nil)

// Holds a slice of type TriggerOnce.
type TriggerOnce_Slice []TriggerOnce

// Implements [typeinfo.Instance] for a slice of TriggerOnce.
func (*TriggerOnce_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerOnce
}

// Implements [typeinfo.Repeats] for a slice of TriggerOnce.
func (op *TriggerOnce_Slice) Repeats() bool {
	return len(*op) > 0
}

// call_trigger
type TriggerSwitch struct {
	Markup map[string]any
}

// trigger_switch, a type of flow.
var Zt_TriggerSwitch typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TriggerSwitch) TypeInfo() typeinfo.T {
	return &Zt_TriggerSwitch
}

// Implements [typeinfo.Markup]
func (op *TriggerSwitch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Trigger = (*TriggerSwitch)(nil)

// Holds a slice of type TriggerSwitch.
type TriggerSwitch_Slice []TriggerSwitch

// Implements [typeinfo.Instance] for a slice of TriggerSwitch.
func (*TriggerSwitch_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerSwitch
}

// Implements [typeinfo.Repeats] for a slice of TriggerSwitch.
func (op *TriggerSwitch_Slice) Repeats() bool {
	return len(*op) > 0
}

// Keep running a series of actions while a condition is true.
type While struct {
	True   rtti.BoolEval
	Exe    []rtti.Execute
	Markup map[string]any
}

// while, a type of flow.
var Zt_While typeinfo.Flow

// Implements [typeinfo.Instance]
func (*While) TypeInfo() typeinfo.T {
	return &Zt_While
}

// Implements [typeinfo.Markup]
func (op *While) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*While)(nil)

// Holds a slice of type While.
type While_Slice []While

// Implements [typeinfo.Instance] for a slice of While.
func (*While_Slice) TypeInfo() typeinfo.T {
	return &Zt_While
}

// Implements [typeinfo.Repeats] for a slice of While.
func (op *While_Slice) Repeats() bool {
	return len(*op) > 0
}

// Comparison, a type of str enum.
type Comparison int

// The enumerated values of Comparison.
const (
	C_Comparison_EqualTo Comparison = iota
	C_Comparison_OtherThan
	C_Comparison_GreaterThan
	C_Comparison_LessThan
	C_Comparison_AtLeast
	C_Comparison_AtMost
)

func MakeComparison(str string) (ret Comparison, okay bool) {
	if i := Zt_Comparison.FindOption(str); i >= 0 {
		ret, okay = Comparison(i), true
	}
	return
}

func (op Comparison) String() (ret string) {
	if i, opts := int(op), Zt_Comparison.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid Comparison(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// comparison, a type of str enum.
var Zt_Comparison = typeinfo.Str{
	Name: "comparison",
	Options: []string{
		"equal_to",
		"other_than",
		"greater_than",
		"less_than",
		"at_least",
		"at_most",
	},
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_AllTrue = typeinfo.Flow{
		Name: "all_true",
		Lede: "all_true",
		Terms: []typeinfo.Term{{
			Name:    "test",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more conditions to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Test if a set of conditions all return true.", "Stops testing after the first condition fails."},
		},
	}
	Zt_Always = typeinfo.Flow{
		Name:  "always",
		Lede:  "always",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Return true; always.",
		},
	}
	Zt_AnyTrue = typeinfo.Flow{
		Name: "any_true",
		Lede: "any_true",
		Terms: []typeinfo.Term{{
			Name:    "test",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more conditions to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Test if any condition in a set of conditions returns true.", "Stops testing after the first condition succeeds."},
		},
	}
	Zt_BufferText = typeinfo.Flow{
		Name: "buffer_text",
		Lede: "buffers",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
	}
	Zt_ParagraphBreak = typeinfo.Flow{
		Name:  "paragraph_break",
		Lede:  "paragraph_break",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Add a single blank line, unless a blank line was just written.", "See also <p> in package markup."},
		},
	}
	Zt_PrintParens = typeinfo.Flow{
		Name: "print_parens",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "parentheses",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Runs one or more statements, and collects any text printed by them.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Collect printed text and surrounds the output with parenthesis '()'.", "If no text is printed, no parentheses are printed."},
		},
	}
	Zt_Break = typeinfo.Flow{
		Name:  "break",
		Lede:  "break",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"In a repeating loop, exit the loop;", "or, in a rule, stop processing rules."},
		},
	}
	Zt_CallCycle = typeinfo.Flow{
		Name: "call_cycle",
		Lede: "cycle",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment":  "Runtime version of cycle_text.",
			"internal": true,
		},
	}
	Zt_CallShuffle = typeinfo.Flow{
		Name: "call_shuffle",
		Lede: "shuffle",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}, {
			Name:    "indices",
			Label:   "indices",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment":  "Runtime version of shuffle_text.",
			"internal": true,
		},
	}
	Zt_CallTerminal = typeinfo.Flow{
		Name: "call_terminal",
		Lede: "stopping",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment":  "Runtime version of stopping_text.",
			"internal": true,
		},
	}
	Zt_CallTrigger = typeinfo.Flow{
		Name: "call_trigger",
		Lede: "trigger",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:  "trigger",
			Label: "on",
			Type:  &Zt_Trigger,
		}, {
			Name:  "num",
			Label: "num",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment":  []interface{}{"Runtime version of count_of.", "A guard which returns true based on a counter."},
			"internal": true,
		},
	}
	Zt_Capitalize = typeinfo.Flow{
		Name: "capitalize",
		Lede: "capitalize",
		Terms: []typeinfo.Term{{
			Name: "text",
			Markup: map[string]any{
				"comment": "The text to capitalize.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Return a copy of some text with its first letter changed to uppercase.",
		},
	}
	Zt_ChooseBranch = typeinfo.Flow{
		Name: "choose_branch",
		Lede: "if",
		Terms: []typeinfo.Term{{
			Name: "condition",
			Markup: map[string]any{
				"comment": "The condition to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:     "args",
			Label:    "assuming",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "A set of local variables available while testing the condition and while running the do/else statements. These are initialized before testing the condition.",
			},
			Type: &assign.Zt_Arg,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Statements which run when the condition succeeded.",
			},
			Type: &rtti.Zt_Execute,
		}, {
			Name:     "else",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"comment": "An optional set of statements to evaluate when the condition failed.",
			},
			Type: &Zt_Brancher,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&Zt_Brancher,
		},
		Markup: map[string]any{
			"comment": "An if statement.",
		},
	}
	Zt_ChooseNothingElse = typeinfo.Flow{
		Name: "choose_nothing_else",
		Lede: "finally",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more statements to run.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Brancher,
		},
		Markup: map[string]any{
			"comment": "Run a set of statements after a condition has failed.",
		},
	}
	Zt_ChooseNum = typeinfo.Flow{
		Name: "choose_num",
		Lede: "num",
		Terms: []typeinfo.Term{{
			Name:  "if",
			Label: "if",
			Markup: map[string]any{
				"comment": "The condition to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:     "args",
			Label:    "assuming",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "A set of local variables available while testing the condition and while running the do/else statements. These are initialized before testing the condition.",
			},
			Type: &assign.Zt_Arg,
		}, {
			Name:  "true",
			Label: "then",
			Markup: map[string]any{
				"comment": "The number to use if the condition succeeds.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "false",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"comment": "The number to use if the condition fails.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Pick one of two possible text values based on a condition.", "( This acts similar to a ternary. )"},
		},
	}
	Zt_ChooseText = typeinfo.Flow{
		Name: "choose_text",
		Lede: "text",
		Terms: []typeinfo.Term{{
			Name:  "if",
			Label: "if",
			Markup: map[string]any{
				"comment": "The condition to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:     "args",
			Label:    "assuming",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "A set of local variables available while testing the condition and while running the do/else statements. These are initialized before testing the condition.",
			},
			Type: &assign.Zt_Arg,
		}, {
			Name:  "true",
			Label: "then",
			Markup: map[string]any{
				"comment": "The text value to use if the condition succeeds.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "false",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"comment": "The text value to use if the condition fails.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Pick one of two possible text values based on a condition.", "( This acts similar to a ternary. )"},
		},
	}
	Zt_PrintCommas = typeinfo.Flow{
		Name: "print_commas",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "commas",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Separates words with commas, and 'and'.",
		},
	}
	Zt_CompareValue = typeinfo.Flow{
		Name: "compare_value",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_Assignment,
		}, {
			Name:  "is",
			Label: "matching",
			Type:  &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if eq,ne,gt,lt,ge,le two numbers.",
		},
	}
	Zt_CompareNum = typeinfo.Flow{
		Name: "compare_num",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "is",
			Label: "matching",
			Type:  &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "num",
			Type:  &rtti.Zt_NumEval,
		}, {
			Name:     "tolerance",
			Label:    "within",
			Optional: true,
			Markup: map[string]any{
				"comment": "a positive value that indicates how close the two numbers should be",
			},
			Type: &prim.Zt_Num,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if eq,ne,gt,lt,ge,le two numbers.",
		},
	}
	Zt_CompareText = typeinfo.Flow{
		Name: "compare_text",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "is",
			Label: "matching",
			Type:  &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "text",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if eq,ne,gt,lt,ge,le two strings ( lexical. ).",
		},
	}
	Zt_SubtractValue = typeinfo.Flow{
		Name: "subtract_value",
		Lede: "subtract",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Subtract two numbers.",
		},
	}
	Zt_During = typeinfo.Flow{
		Name: "during",
		Lede: "during",
		Terms: []typeinfo.Term{{
			Name: "pattern_name",
			Type: &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Decide whether a pattern is running.",
		},
	}
	Zt_FieldsOfKind = typeinfo.Flow{
		Name: "fields_of_kind",
		Lede: "fields",
		Terms: []typeinfo.Term{{
			Name:  "kind_name",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"comment": "List of the field names of a kind.",
		},
	}
	Zt_HasDominion = typeinfo.Flow{
		Name: "has_dominion",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "domain",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
	}
	Zt_Includes = typeinfo.Flow{
		Name: "includes",
		Lede: "contains",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "part",
			Label: "part",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if text contains text.",
		},
	}
	Zt_IsEmpty = typeinfo.Flow{
		Name: "is_empty",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "empty",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if the text is empty.",
		},
	}
	Zt_IsExactKindOf = typeinfo.Flow{
		Name: "is_exact_kind_of",
		Lede: "kind_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "kind",
			Label: "is_exactly",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if the object is exactly the named kind.",
		},
	}
	Zt_IsKindOf = typeinfo.Flow{
		Name: "is_kind_of",
		Lede: "kind_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "kind",
			Label: "is",
			Type:  &prim.Zt_Text,
		}, {
			Name:     "nothing",
			Label:    "nothing",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"try to check the type of nothing objects?", "normally, nothing objects have no kind."},
			},
			Type: &prim.Zt_Bool,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "True if the object is compatible with the named kind.",
		},
	}
	Zt_Join = typeinfo.Flow{
		Name: "join",
		Lede: "join",
		Terms: []typeinfo.Term{{
			Name:     "sep",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "parts",
			Label:   "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns multiple pieces of text as a single new piece of text.",
		},
	}
	Zt_KindOf = typeinfo.Flow{
		Name: "kind_of",
		Lede: "kind_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "nothing",
			Label:    "nothing",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"try to check the type of nothing objects?", "normally, nothing objects have no kind."},
			},
			Type: &prim.Zt_Bool,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Friendly name of the object's kind.",
		},
	}
	Zt_KindsOf = typeinfo.Flow{
		Name: "kinds_of",
		Lede: "kinds_of",
		Terms: []typeinfo.Term{{
			Name: "kind",
			Type: &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"comment": "A list of compatible kinds.",
		},
	}
	Zt_MakeLowercase = typeinfo.Flow{
		Name: "make_lowercase",
		Lede: "lower",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, with every letter turned into lowercase. For example, 'shout' from 'SHOUT'.",
		},
	}
	Zt_MakeReversed = typeinfo.Flow{
		Name: "make_reversed",
		Lede: "reverse",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text flipped back to front. For example, 'elppA' from 'Apple', or 'noon' from 'noon'.",
		},
	}
	Zt_MakeSentenceCase = typeinfo.Flow{
		Name: "make_sentence_case",
		Lede: "sentence",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, start each sentence with a capital letter. For example, 'Empire Apple.' from 'Empire apple.'.",
		},
	}
	Zt_MakeTitleCase = typeinfo.Flow{
		Name: "make_title_case",
		Lede: "title",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, starting each word with a capital letter. For example, 'Empire Apple' from 'empire apple'.",
		},
	}
	Zt_MakeUppercase = typeinfo.Flow{
		Name: "make_uppercase",
		Lede: "upper",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns new text, with every letter turned into uppercase. For example, 'APPLE' from 'apple'.",
		},
	}
	Zt_Matches = typeinfo.Flow{
		Name: "matches",
		Lede: "matches",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "match",
			Label: "to",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "cache",
			Label:   "cache",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Determine whether the specified text is similar to the specified regular expression.",
		},
	}
	Zt_NameOf = typeinfo.Flow{
		Name: "name_of",
		Lede: "name_of",
		Terms: []typeinfo.Term{{
			Name: "object",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Full name of the object.",
		},
	}
	Zt_Never = typeinfo.Flow{
		Name:  "never",
		Lede:  "never",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns false.",
		},
	}
	Zt_LineBreak = typeinfo.Flow{
		Name:  "line_break",
		Lede:  "line_break",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Start a new line.",
		},
	}
	Zt_Continue = typeinfo.Flow{
		Name:  "continue",
		Lede:  "continue",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"In a repeating loop, try the next iteration of the loop;", "or, in a rule, continue to the next rule."},
		},
	}
	Zt_Not = typeinfo.Flow{
		Name: "not",
		Lede: "not",
		Terms: []typeinfo.Term{{
			Name: "test",
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns the opposite value.",
		},
	}
	Zt_ObjectTraits = typeinfo.Flow{
		Name: "object_traits",
		Lede: "object",
		Terms: []typeinfo.Term{{
			Name:  "object",
			Label: "traits",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"comment": "Returns all of the object's current traits as a list of text.",
		},
	}
	Zt_Pluralize = typeinfo.Flow{
		Name: "pluralize",
		Lede: "plural",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns the plural form of a singular word. (ex. apples for apple. ).",
		},
	}
	Zt_PrintNum = typeinfo.Flow{
		Name: "print_num",
		Lede: "numeral",
		Terms: []typeinfo.Term{{
			Name: "num",
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes a number using numerals, eg. '1'.",
		},
	}
	Zt_PrintNumWord = typeinfo.Flow{
		Name: "print_num_word",
		Lede: "numeral",
		Terms: []typeinfo.Term{{
			Name:  "num",
			Label: "words",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes a number in plain english: eg. 'one'.",
		},
	}
	Zt_MultiplyValue = typeinfo.Flow{
		Name: "multiply_value",
		Lede: "multiply",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Multiply two numbers.",
		},
	}
	Zt_DivideValue = typeinfo.Flow{
		Name: "divide_value",
		Lede: "divide",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Divide one number by another.",
		},
	}
	Zt_ModValue = typeinfo.Flow{
		Name: "mod_value",
		Lede: "mod",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Divide one number by another, and return the remainder.",
		},
	}
	Zt_AbsValue = typeinfo.Flow{
		Name: "abs_value",
		Lede: "absolute",
		Terms: []typeinfo.Term{{
			Name:  "value",
			Label: "value",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
	}
	Zt_Increment = typeinfo.Flow{
		Name: "increment",
		Lede: "increase",
		Terms: []typeinfo.Term{{
			Name: "target",
			Type: &assign.Zt_Address,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, increments by 1.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Increases the value of a number held in by a variable or object field.", "Returns the new value of the number."},
		},
	}
	Zt_Decrement = typeinfo.Flow{
		Name: "decrement",
		Lede: "decrease",
		Terms: []typeinfo.Term{{
			Name: "target",
			Type: &assign.Zt_Address,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, decrements by 1.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Decrease the value of a number held in by a variable or object field.", "Returns the new value of the number."},
		},
	}
	Zt_IncrementAspect = typeinfo.Flow{
		Name: "increment_aspect",
		Lede: "increase",
		Terms: []typeinfo.Term{{
			Name: "target",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "aspect",
			Label: "aspect",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, increments by a single step.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "clamp",
			Label:    "clamp",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, wraps.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Increases the value of a trait held by an object aspect.", "Returns the new value of the trait."},
		},
	}
	Zt_DecrementAspect = typeinfo.Flow{
		Name: "decrement_aspect",
		Lede: "decrease",
		Terms: []typeinfo.Term{{
			Name: "target",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "aspect",
			Label: "aspect",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, increments by a single step.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "clamp",
			Label:    "clamp",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, wraps.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Increases the value of a trait held by an object aspect.", "Returns the new value of the trait."},
		},
	}
	Zt_PrintText = typeinfo.Flow{
		Name: "print_text",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Display some text to the player without apply any additional formatting.",
		},
	}
	Zt_Row = typeinfo.Flow{
		Name: "row",
		Lede: "row",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Runs one or more statements, and collects any text printed by them.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Group text into a single line <li> as part of a list of lines.", "See also: 'rows'."},
		},
	}
	Zt_Rows = typeinfo.Flow{
		Name: "rows",
		Lede: "rows",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Runs one or more statements, and collects any text printed by them.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Group text into an unordered list <ul>.",
		},
	}
	Zt_Singularize = typeinfo.Flow{
		Name: "singularize",
		Lede: "singular",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "of",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns the singular form of a plural word. (ex. apple for apples ).",
		},
	}
	Zt_Softline = typeinfo.Flow{
		Name:  "softline",
		Lede:  "wbr",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Start a new line ( if not already at a new line ).",
		},
	}
	Zt_PrintWords = typeinfo.Flow{
		Name: "print_words",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name:     "separator",
			Label:    "separator",
			Optional: true,
			Markup: map[string]any{
				"comment": "Optional text to place between adjoining words.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "words",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Runs one or more statements, and collects any text printed by them.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes text, by default putting spaces between words.",
		},
	}
	Zt_AddValue = typeinfo.Flow{
		Name: "add_value",
		Lede: "add",
		Terms: []typeinfo.Term{{
			Name: "a",
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Add two numbers.",
		},
	}
	Zt_TriggerCycle = typeinfo.Flow{
		Name:  "trigger_cycle",
		Lede:  "every",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
		Markup: map[string]any{
			"comment":  "call_trigger",
			"internal": true,
		},
	}
	Zt_TriggerOnce = typeinfo.Flow{
		Name:  "trigger_once",
		Lede:  "at",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
		Markup: map[string]any{
			"comment":  "call_trigger",
			"internal": true,
		},
	}
	Zt_TriggerSwitch = typeinfo.Flow{
		Name:  "trigger_switch",
		Lede:  "after",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
		Markup: map[string]any{
			"comment":  "call_trigger",
			"internal": true,
		},
	}
	Zt_While = typeinfo.Flow{
		Name: "while",
		Lede: "repeating",
		Terms: []typeinfo.Term{{
			Name: "true",
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Keep running a series of actions while a condition is true.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "core",
	Comment: []string{
		"Commands for scripting runtime behavior.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Brancher,
	&Zt_Trigger,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_AllTrue,
	&Zt_Always,
	&Zt_AnyTrue,
	&Zt_BufferText,
	&Zt_ParagraphBreak,
	&Zt_PrintParens,
	&Zt_Break,
	&Zt_CallCycle,
	&Zt_CallShuffle,
	&Zt_CallTerminal,
	&Zt_CallTrigger,
	&Zt_Capitalize,
	&Zt_ChooseBranch,
	&Zt_ChooseNothingElse,
	&Zt_ChooseNum,
	&Zt_ChooseText,
	&Zt_PrintCommas,
	&Zt_CompareValue,
	&Zt_CompareNum,
	&Zt_CompareText,
	&Zt_SubtractValue,
	&Zt_During,
	&Zt_FieldsOfKind,
	&Zt_HasDominion,
	&Zt_Includes,
	&Zt_IsEmpty,
	&Zt_IsExactKindOf,
	&Zt_IsKindOf,
	&Zt_Join,
	&Zt_KindOf,
	&Zt_KindsOf,
	&Zt_MakeLowercase,
	&Zt_MakeReversed,
	&Zt_MakeSentenceCase,
	&Zt_MakeTitleCase,
	&Zt_MakeUppercase,
	&Zt_Matches,
	&Zt_NameOf,
	&Zt_Never,
	&Zt_LineBreak,
	&Zt_Continue,
	&Zt_Not,
	&Zt_ObjectTraits,
	&Zt_Pluralize,
	&Zt_PrintNum,
	&Zt_PrintNumWord,
	&Zt_MultiplyValue,
	&Zt_DivideValue,
	&Zt_ModValue,
	&Zt_AbsValue,
	&Zt_Increment,
	&Zt_Decrement,
	&Zt_IncrementAspect,
	&Zt_DecrementAspect,
	&Zt_PrintText,
	&Zt_Row,
	&Zt_Rows,
	&Zt_Singularize,
	&Zt_Softline,
	&Zt_PrintWords,
	&Zt_AddValue,
	&Zt_TriggerCycle,
	&Zt_TriggerOnce,
	&Zt_TriggerSwitch,
	&Zt_While,
}

// A list of all strs in this this package.
var z_str_list = []*typeinfo.Str{
	&Zt_Comparison,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	1399610288338666093:  (*AbsValue)(nil),          /* num_eval=Absolute value: */
	5038997598380008995:  (*AddValue)(nil),          /* num_eval=Add:value: */
	9392469773844077696:  (*TriggerSwitch)(nil),     /* trigger=After */
	8082607244820951444:  (*AllTrue)(nil),           /* bool_eval=AllTrue: */
	1979437068831463006:  (*Always)(nil),            /* bool_eval=Always */
	1963945852392897915:  (*AnyTrue)(nil),           /* bool_eval=AnyTrue: */
	2233111806717201007:  (*TriggerOnce)(nil),       /* trigger=At */
	9570569845423374482:  (*Break)(nil),             /* execute=Break */
	11322251195672034522: (*BufferText)(nil),        /* text_eval=Buffers do: */
	8695677004499439692:  (*Capitalize)(nil),        /* text_eval=Capitalize: */
	3601423820955950769:  (*Includes)(nil),          /* bool_eval=Contains:part: */
	3156233792812716886:  (*Continue)(nil),          /* execute=Continue */
	2636120577324077328:  (*CallCycle)(nil),         /* text_eval=Cycle:over: */
	1765941604351725175:  (*Decrement)(nil),         /* execute=Decrease: */
	2127914973580247945:  (*Decrement)(nil),         /* num_eval=Decrease: */
	13259725831972112539: (*DecrementAspect)(nil),   /* execute=Decrease:aspect: */
	9604047801594713852:  (*DecrementAspect)(nil),   /* text_eval=Decrease:aspect: */
	11515881376122775668: (*DecrementAspect)(nil),   /* execute=Decrease:aspect:by: */
	1589765377795283065:  (*DecrementAspect)(nil),   /* text_eval=Decrease:aspect:by: */
	10691394634979399555: (*DecrementAspect)(nil),   /* execute=Decrease:aspect:by:clamp: */
	16351892255943407142: (*DecrementAspect)(nil),   /* text_eval=Decrease:aspect:by:clamp: */
	16567257087826189312: (*DecrementAspect)(nil),   /* execute=Decrease:aspect:clamp: */
	7498537354592687963:  (*DecrementAspect)(nil),   /* text_eval=Decrease:aspect:clamp: */
	906537561468635208:   (*Decrement)(nil),         /* execute=Decrease:by: */
	10626433780618545830: (*Decrement)(nil),         /* num_eval=Decrease:by: */
	878353350484094823:   (*DivideValue)(nil),       /* num_eval=Divide:value: */
	6766679711322815220:  (*During)(nil),            /* bool_eval=During: */
	5502083194357667326:  (*During)(nil),            /* num_eval=During: */
	1457631626735043065:  (*TriggerCycle)(nil),      /* trigger=Every */
	2224842870997259213:  (*FieldsOfKind)(nil),      /* text_list_eval=Fields of: */
	13697022905922221509: (*ChooseNothingElse)(nil), /* brancher=Finally do: */
	6524366950360243674:  (*ChooseBranch)(nil),      /* brancher=If:assuming:do: */
	12195526980856142720: (*ChooseBranch)(nil),      /* execute=If:assuming:do: */
	16752471159562852415: (*ChooseBranch)(nil),      /* brancher=If:assuming:do:else: */
	2092791308408463217:  (*ChooseBranch)(nil),      /* execute=If:assuming:do:else: */
	11676187955438326921: (*ChooseBranch)(nil),      /* brancher=If:do: */
	16551038912311542599: (*ChooseBranch)(nil),      /* execute=If:do: */
	11846460753008131314: (*ChooseBranch)(nil),      /* brancher=If:do:else: */
	9882017885672780228:  (*ChooseBranch)(nil),      /* execute=If:do:else: */
	3419326304120453839:  (*Increment)(nil),         /* execute=Increase: */
	4329501782528502333:  (*Increment)(nil),         /* num_eval=Increase: */
	11043224857467493683: (*IncrementAspect)(nil),   /* execute=Increase:aspect: */
	1296309673842091672:  (*IncrementAspect)(nil),   /* text_eval=Increase:aspect: */
	4473637830475551932:  (*IncrementAspect)(nil),   /* execute=Increase:aspect:by: */
	18328024260427443133: (*IncrementAspect)(nil),   /* text_eval=Increase:aspect:by: */
	1150598923989934235:  (*IncrementAspect)(nil),   /* execute=Increase:aspect:by:clamp: */
	16465259325356451354: (*IncrementAspect)(nil),   /* text_eval=Increase:aspect:by:clamp: */
	4522630356185077352:  (*IncrementAspect)(nil),   /* execute=Increase:aspect:clamp: */
	705264554644415287:   (*IncrementAspect)(nil),   /* text_eval=Increase:aspect:clamp: */
	9916665856596995152:  (*Increment)(nil),         /* execute=Increase:by: */
	17764432315137014386: (*Increment)(nil),         /* num_eval=Increase:by: */
	16720860407833961741: (*HasDominion)(nil),       /* bool_eval=Is domain: */
	10867951538760575464: (*IsEmpty)(nil),           /* bool_eval=Is empty: */
	4986574662941955696:  (*CompareNum)(nil),        /* bool_eval=Is:matching:num: */
	6471221873898876231:  (*CompareNum)(nil),        /* bool_eval=Is:matching:num:within: */
	2616749751052919401:  (*CompareText)(nil),       /* bool_eval=Is:matching:text: */
	7216474174347601443:  (*CompareValue)(nil),      /* bool_eval=Is:matching:value: */
	10106284345457008764: (*Join)(nil),              /* text_eval=Join parts: */
	16037301925772243654: (*Join)(nil),              /* text_eval=Join:parts: */
	16305715626122315047: (*KindOf)(nil),            /* text_eval=KindOf: */
	16744881049704292640: (*IsKindOf)(nil),          /* bool_eval=KindOf:is: */
	210805642732508805:   (*IsKindOf)(nil),          /* bool_eval=KindOf:is:nothing: */
	7296079450764183372:  (*IsExactKindOf)(nil),     /* bool_eval=KindOf:isExactly: */
	4254622167054960918:  (*KindOf)(nil),            /* text_eval=KindOf:nothing: */
	6869420318733086481:  (*KindsOf)(nil),           /* text_list_eval=KindsOf: */
	10898429598193857104: (*LineBreak)(nil),         /* execute=LineBreak */
	11334467785012784241: (*MakeLowercase)(nil),     /* text_eval=Lower: */
	7007374677444567783:  (*Matches)(nil),           /* bool_eval=Matches:to: */
	6501544922110637214:  (*ModValue)(nil),          /* num_eval=Mod:value: */
	1256349697579623184:  (*MultiplyValue)(nil),     /* num_eval=Multiply:value: */
	15519818243985955688: (*NameOf)(nil),            /* text_eval=NameOf: */
	1310533520550597035:  (*Never)(nil),             /* bool_eval=Never */
	3572677870333466638:  (*Not)(nil),               /* bool_eval=Not: */
	12220459187031741460: (*ChooseNum)(nil),         /* num_eval=Num if:assuming:then: */
	2863639051637372837:  (*ChooseNum)(nil),         /* num_eval=Num if:assuming:then:else: */
	9841785069654362751:  (*ChooseNum)(nil),         /* num_eval=Num if:then: */
	2293377426593441548:  (*ChooseNum)(nil),         /* num_eval=Num if:then:else: */
	18009133328614046007: (*PrintNumWord)(nil),      /* text_eval=Numeral words: */
	5709077775967698380:  (*PrintNum)(nil),          /* text_eval=Numeral: */
	15933580486837544843: (*ObjectTraits)(nil),      /* text_list_eval=Object traits: */
	1194153657675604478:  (*ParagraphBreak)(nil),    /* execute=ParagraphBreak */
	11420921600352749983: (*Pluralize)(nil),         /* text_eval=Plural of: */
	16169738297367022876: (*PrintCommas)(nil),       /* execute=Print commas: */
	6231219704730380469:  (*PrintCommas)(nil),       /* text_eval=Print commas: */
	4206645811149297220:  (*PrintParens)(nil),       /* execute=Print parentheses: */
	8219093008786386363:  (*PrintParens)(nil),       /* text_eval=Print parentheses: */
	4149419216708670664:  (*PrintWords)(nil),        /* execute=Print separator:words: */
	4219359027975954467:  (*PrintWords)(nil),        /* text_eval=Print separator:words: */
	1331651249232124175:  (*PrintWords)(nil),        /* execute=Print words: */
	17978150574109115948: (*PrintWords)(nil),        /* text_eval=Print words: */
	4512128922644282356:  (*PrintText)(nil),         /* execute=Print: */
	16853421744116592875: (*While)(nil),             /* execute=Repeating:do: */
	12963686195606417453: (*MakeReversed)(nil),      /* text_eval=Reverse text: */
	14820902432990466009: (*Row)(nil),               /* text_eval=Row do: */
	42419598592471524:    (*Rows)(nil),              /* text_eval=Rows do: */
	10747671703915852065: (*MakeSentenceCase)(nil),  /* text_eval=Sentence: */
	3632089819497852687:  (*CallShuffle)(nil),       /* text_eval=Shuffle:over: */
	2397382738676796596:  (*Singularize)(nil),       /* text_eval=Singular of: */
	10180508752412200934: (*CallTerminal)(nil),      /* text_eval=Stopping:over: */
	17065007156382311204: (*SubtractValue)(nil),     /* num_eval=Subtract:value: */
	4784360512497235820:  (*ChooseText)(nil),        /* text_eval=Text if:assuming:then: */
	13980719859951632205: (*ChooseText)(nil),        /* text_eval=Text if:assuming:then:else: */
	4706788097495762503:  (*ChooseText)(nil),        /* text_eval=Text if:then: */
	12221021609112050372: (*ChooseText)(nil),        /* text_eval=Text if:then:else: */
	10878271994667616824: (*MakeTitleCase)(nil),     /* text_eval=Title: */
	2711869841453509536:  (*CallTrigger)(nil),       /* bool_eval=Trigger:on:num: */
	5481656653805454214:  (*MakeUppercase)(nil),     /* text_eval=Upper: */
	16612725309683107572: (*Softline)(nil),          /* execute=Wbr */
}
