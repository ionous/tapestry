// Code generated by "makeops"; edit at your own risk.
package core

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// Activity
type Activity struct {
	Exe []rt.Execute `if:"label=_"`
}

var _ rt.Execute = (*Activity)(nil)

func (*Activity) Compose() composer.Spec {
	return composer.Spec{
		Name: "activity",
		Uses: "flow",
		Lede: "act",
	}
}

// AllTrue Returns true if all of the evaluations are true.
type AllTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

var _ rt.BoolEval = (*AllTrue)(nil)

func (*AllTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: "all_true",
		Uses: "flow",
		Lede: "all_of",
	}
}

// Always Returns true.
type Always struct{}

var _ rt.BoolEval = (*Always)(nil)

func (*Always) Compose() composer.Spec {
	return composer.Spec{
		Name: "always",
		Uses: "flow",
	}
}

// AnyTrue Returns true if any of the evaluations are true.
type AnyTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

var _ rt.BoolEval = (*AnyTrue)(nil)

func (*AnyTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: "any_true",
		Uses: "flow",
		Lede: "any_of",
	}
}

// Assign Assigns a variable to a value.
type Assign struct {
	Var  value.VariableName `if:"label=_"`
	From rt.Assignment      `if:"label=be"`
}

var _ rt.Execute = (*Assign)(nil)

func (*Assign) Compose() composer.Spec {
	return composer.Spec{
		Name: "assign",
		Uses: "flow",
		Lede: "let",
	}
}

// AtLeast The first value is greater than or equal to the second value.
type AtLeast struct{}

var _ Comparator = (*AtLeast)(nil)

func (*AtLeast) Compose() composer.Spec {
	return composer.Spec{
		Name: "at_least",
		Uses: "flow",
	}
}

// AtMost The first value is less than or equal to the second value.
type AtMost struct{}

var _ Comparator = (*AtMost)(nil)

func (*AtMost) Compose() composer.Spec {
	return composer.Spec{
		Name: "at_most",
		Uses: "flow",
	}
}

// Blankline Add a single blank line following some text.
type Blankline struct{}

var _ rt.Execute = (*Blankline)(nil)

func (*Blankline) Compose() composer.Spec {
	return composer.Spec{
		Name: "blankline",
		Uses: "flow",
		Lede: "p",
	}
}

// BoolValue Specify an explicit true or false value.
type BoolValue struct {
	Bool bool `if:"label=_,type=bool"`
}

var _ rt.BoolEval = (*BoolValue)(nil)

func (*BoolValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "bool_value",
		Uses: "flow",
		Lede: "bool",
	}
}

// BracketText Sandwiches text printed during a block and puts them inside parenthesis &#x27;()&#x27;.
type BracketText struct {
	Do Activity `if:"label=_"`
}

var _ rt.TextEval = (*BracketText)(nil)

func (*BracketText) Compose() composer.Spec {
	return composer.Spec{
		Name: "bracket_text",
		Uses: "flow",
		Lede: "brackets",
	}
}

// Break In a repeating loop, exit the loop.
type Break struct{}

var _ rt.Execute = (*Break)(nil)

func (*Break) Compose() composer.Spec {
	return composer.Spec{
		Name: "break",
		Uses: "flow",
	}
}

// BufferText
type BufferText struct {
	Do Activity `if:"label=_"`
}

var _ rt.TextEval = (*BufferText)(nil)

func (*BufferText) Compose() composer.Spec {
	return composer.Spec{
		Name: "buffer_text",
		Uses: "flow",
		Lede: "buffers",
	}
}

// CallArg Runtime version of argument
type CallArg struct {
	Name string        `if:"label=_,type=text"`
	From rt.Assignment `if:"label=from"`
}

func (*CallArg) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_arg",
		Uses: "flow",
		Lede: "inarg",
	}
}

// CallArgs Runtime version of arguments
type CallArgs struct {
	Args []CallArg `if:"label=_"`
}

func (*CallArgs) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_args",
		Uses: "flow",
		Lede: "inargs",
	}
}

// CallCycle Runtime version of cycle_text
type CallCycle struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

var _ rt.TextEval = (*CallCycle)(nil)

func (*CallCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_cycle",
		Uses: "flow",
		Lede: "cycle",
	}
}

// CallMake Runtime version of make
type CallMake struct {
	Kind      string   `if:"label=_,type=text"`
	Arguments CallArgs `if:"label=args"`
}

var _ rt.RecordEval = (*CallMake)(nil)

func (*CallMake) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_make",
		Uses: "flow",
	}
}

// CallPattern Runtime version of determine
type CallPattern struct {
	Pattern   value.PatternName `if:"label=_"`
	Arguments CallArgs          `if:"label=args"`
}

var _ rt.Execute = (*CallPattern)(nil)
var _ rt.BoolEval = (*CallPattern)(nil)
var _ rt.NumberEval = (*CallPattern)(nil)
var _ rt.TextEval = (*CallPattern)(nil)
var _ rt.RecordEval = (*CallPattern)(nil)
var _ rt.NumListEval = (*CallPattern)(nil)
var _ rt.TextListEval = (*CallPattern)(nil)
var _ rt.RecordListEval = (*CallPattern)(nil)

func (*CallPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_pattern",
		Uses: "flow",
	}
}

// CallSend Runtime version of send
type CallSend struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=to"`
	Arguments CallArgs        `if:"label=args"`
}

var _ rt.Execute = (*CallSend)(nil)
var _ rt.BoolEval = (*CallSend)(nil)

func (*CallSend) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_send",
		Uses: "flow",
	}
}

// CallShuffle Runtime version of shuffle_text
type CallShuffle struct {
	At      reader.Position `if:"internal"`
	Parts   []rt.TextEval   `if:"label=_"`
	Indices Shuffler        `if:"internal"`
}

var _ rt.TextEval = (*CallShuffle)(nil)

func (*CallShuffle) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_shuffle",
		Uses: "flow",
		Lede: "shuffle",
	}
}

// CallTerminal Runtime version of stopping_text
type CallTerminal struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

var _ rt.TextEval = (*CallTerminal)(nil)

func (*CallTerminal) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_terminal",
		Uses: "flow",
		Lede: "stopping",
	}
}

// CallTrigger Runtime version of count_of
type CallTrigger struct {
	At      reader.Position `if:"internal"`
	Trigger Trigger         `if:"label=_"`
	Num     rt.NumberEval   `if:"label=num"`
}

var _ rt.BoolEval = (*CallTrigger)(nil)

func (*CallTrigger) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_trigger",
		Uses: "flow",
		Lede: "trigger",
	}
}

// Capitalize Returns new text, with the first letter turned into uppercase.
type Capitalize struct {
	Text rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*Capitalize)(nil)

func (*Capitalize) Compose() composer.Spec {
	return composer.Spec{
		Name: "capitalize",
		Uses: "flow",
	}
}

// ChooseAction An if statement.
type ChooseAction struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

var _ rt.Execute = (*ChooseAction)(nil)
var _ Brancher = (*ChooseAction)(nil)

func (*ChooseAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_action",
		Uses: "flow",
		Lede: "if",
	}
}

// ChooseMore
type ChooseMore struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

var _ Brancher = (*ChooseMore)(nil)

func (*ChooseMore) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_more",
		Uses: "flow",
		Lede: "else_if",
	}
}

// ChooseMoreValue
type ChooseMoreValue struct {
	Assign string        `if:"label=_,type=text"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

var _ Brancher = (*ChooseMoreValue)(nil)

func (*ChooseMoreValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_more_value",
		Uses: "flow",
		Lede: "else_if",
	}
}

// ChooseNothingElse
type ChooseNothingElse struct {
	Do Activity `if:"label=_"`
}

var _ Brancher = (*ChooseNothingElse)(nil)

func (*ChooseNothingElse) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_nothing_else",
		Uses: "flow",
		Lede: "else_do",
	}
}

// ChooseNum Pick one of two numbers based on a boolean test.
type ChooseNum struct {
	If    rt.BoolEval   `if:"label=if"`
	True  rt.NumberEval `if:"label=then"`
	False rt.NumberEval `if:"label=else"`
}

var _ rt.NumberEval = (*ChooseNum)(nil)

func (*ChooseNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_num",
		Uses: "flow",
		Lede: "num",
	}
}

// ChooseText Pick one of two strings based on a boolean test.
type ChooseText struct {
	If    rt.BoolEval `if:"label=if"`
	True  rt.TextEval `if:"label=then"`
	False rt.TextEval `if:"label=else"`
}

var _ rt.TextEval = (*ChooseText)(nil)

func (*ChooseText) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_text",
		Uses: "flow",
		Lede: "txt",
	}
}

// ChooseValue An if statement with local assignment.
type ChooseValue struct {
	Assign string        `if:"label=_,type=text"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

var _ rt.Execute = (*ChooseValue)(nil)
var _ Brancher = (*ChooseValue)(nil)

func (*ChooseValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_value",
		Uses: "flow",
		Lede: "if",
	}
}

// CommaText Separates words with commas, and &#x27;and&#x27;.
type CommaText struct {
	Do Activity `if:"label=_"`
}

var _ rt.TextEval = (*CommaText)(nil)

func (*CommaText) Compose() composer.Spec {
	return composer.Spec{
		Name: "comma_text",
		Uses: "flow",
		Lede: "commas",
	}
}

// CompareNum True if eq,ne,gt,lt,ge,le two numbers.
type CompareNum struct {
	A  rt.NumberEval `if:"label=_"`
	Is Comparator    `if:"label=is"`
	B  rt.NumberEval `if:"label=num"`
}

var _ rt.BoolEval = (*CompareNum)(nil)

func (*CompareNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "compare_num",
		Uses: "flow",
		Lede: "cmp",
	}
}

// CompareText True if eq,ne,gt,lt,ge,le two strings ( lexical. )
type CompareText struct {
	A  rt.TextEval `if:"label=_"`
	Is Comparator  `if:"label=is"`
	B  rt.TextEval `if:"label=txt"`
}

var _ rt.BoolEval = (*CompareText)(nil)

func (*CompareText) Compose() composer.Spec {
	return composer.Spec{
		Name: "compare_text",
		Uses: "flow",
		Lede: "cmp",
	}
}

// DiffOf Subtract two numbers.
type DiffOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

var _ rt.NumberEval = (*DiffOf)(nil)

func (*DiffOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "diff_of",
		Uses: "flow",
		Lede: "dec",
	}
}

// During Decide whether a pattern is running.
type During struct {
	Pattern value.PatternName `if:"label=_"`
}

var _ rt.BoolEval = (*During)(nil)
var _ rt.NumberEval = (*During)(nil)

func (*During) Compose() composer.Spec {
	return composer.Spec{
		Name: "during",
		Uses: "flow",
	}
}

// Equal Two values exactly match.
type Equal struct{}

var _ Comparator = (*Equal)(nil)

func (*Equal) Compose() composer.Spec {
	return composer.Spec{
		Name: "equal",
		Uses: "flow",
		Lede: "equals",
	}
}

// FromBool Assigns the calculated boolean value.
type FromBool struct {
	Val rt.BoolEval `if:"label=_"`
}

var _ rt.Assignment = (*FromBool)(nil)

func (*FromBool) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_bool",
		Uses: "flow",
	}
}

// FromNum Assigns the calculated number.
type FromNum struct {
	Val rt.NumberEval `if:"label=_"`
}

var _ rt.Assignment = (*FromNum)(nil)

func (*FromNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_num",
		Uses: "flow",
	}
}

// FromNumbers Assigns the calculated numbers.
type FromNumbers struct {
	Vals rt.NumListEval `if:"label=_"`
}

var _ rt.Assignment = (*FromNumbers)(nil)

func (*FromNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_numbers",
		Uses: "flow",
		Lede: "from_nums",
	}
}

// FromObj Targets an object with a computed name.
type FromObj struct {
	Object rt.TextEval `if:"label=_"`
}

var _ FromSourceFields = (*FromObj)(nil)

func (*FromObj) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_obj",
		Uses: "flow",
	}
}

// FromRec Targets a record stored in a record.
type FromRec struct {
	Rec rt.RecordEval `if:"label=_"`
}

var _ FromSourceFields = (*FromRec)(nil)

func (*FromRec) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_rec",
		Uses: "flow",
	}
}

// FromRecord Assigns the calculated record.
type FromRecord struct {
	Val rt.RecordEval `if:"label=_"`
}

var _ rt.Assignment = (*FromRecord)(nil)

func (*FromRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_record",
		Uses: "flow",
		Lede: "from_rec",
	}
}

// FromRecords Assigns the calculated records.
type FromRecords struct {
	Vals rt.RecordListEval `if:"label=_"`
}

var _ rt.Assignment = (*FromRecords)(nil)

func (*FromRecords) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_records",
		Uses: "flow",
		Lede: "from_recs",
	}
}

// FromText Assigns the calculated piece of text.
type FromText struct {
	Val rt.TextEval `if:"label=_"`
}

var _ rt.Assignment = (*FromText)(nil)

func (*FromText) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_text",
		Uses: "flow",
		Lede: "from_txt",
	}
}

// FromTexts Assigns the calculated texts.
type FromTexts struct {
	Vals rt.TextListEval `if:"label=_"`
}

var _ rt.Assignment = (*FromTexts)(nil)

func (*FromTexts) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_texts",
		Uses: "flow",
		Lede: "from_txts",
	}
}

// FromVar Targets a record stored in a variable.
type FromVar struct {
	Var value.VariableName `if:"label=_"`
}

var _ FromSourceFields = (*FromVar)(nil)

func (*FromVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_var",
		Uses: "flow",
	}
}

// GetAtField Get a value from a record.
type GetAtField struct {
	Field string           `if:"label=_,type=text"`
	From  FromSourceFields `if:"label=from"`
}

var _ rt.Assignment = (*GetAtField)(nil)
var _ rt.BoolEval = (*GetAtField)(nil)
var _ rt.NumberEval = (*GetAtField)(nil)
var _ rt.TextEval = (*GetAtField)(nil)
var _ rt.RecordEval = (*GetAtField)(nil)
var _ rt.NumListEval = (*GetAtField)(nil)
var _ rt.TextListEval = (*GetAtField)(nil)
var _ rt.RecordListEval = (*GetAtField)(nil)

func (*GetAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: "get_at_field",
		Uses: "flow",
		Lede: "get",
	}
}

// GetVar Get Variable: Return the value of the named variable.
type GetVar struct {
	Name value.VariableName `if:"label=_"`
}

var _ rt.Assignment = (*GetVar)(nil)
var _ rt.BoolEval = (*GetVar)(nil)
var _ rt.NumberEval = (*GetVar)(nil)
var _ rt.TextEval = (*GetVar)(nil)
var _ rt.RecordEval = (*GetVar)(nil)
var _ rt.NumListEval = (*GetVar)(nil)
var _ rt.TextListEval = (*GetVar)(nil)
var _ rt.RecordListEval = (*GetVar)(nil)

func (*GetVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "get_var",
		Uses: "flow",
		Lede: "var",
	}
}

// GreaterThan The first value is larger than the second value.
type GreaterThan struct{}

var _ Comparator = (*GreaterThan)(nil)

func (*GreaterThan) Compose() composer.Spec {
	return composer.Spec{
		Name: "greater_than",
		Uses: "flow",
	}
}

// HasDominion
type HasDominion struct {
	Name string `if:"label=_,type=text"`
}

var _ rt.BoolEval = (*HasDominion)(nil)

func (*HasDominion) Compose() composer.Spec {
	return composer.Spec{
		Name: "has_dominion",
		Uses: "flow",
	}
}

// HasTrait Return true if the object is currently in the requested state.
type HasTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

var _ rt.BoolEval = (*HasTrait)(nil)

func (*HasTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: "has_trait",
		Uses: "flow",
		Lede: "get",
	}
}

// IdOf A unique object identifier.
type IdOf struct {
	Object rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*IdOf)(nil)

func (*IdOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "id_of",
		Uses: "flow",
	}
}

// Includes True if text contains text.
type Includes struct {
	Text rt.TextEval `if:"label=_"`
	Part rt.TextEval `if:"label=part"`
}

var _ rt.BoolEval = (*Includes)(nil)

func (*Includes) Compose() composer.Spec {
	return composer.Spec{
		Name: "includes",
		Uses: "flow",
		Lede: "contains",
	}
}

// IntoObj Targets an object with a computed name.
type IntoObj struct {
	Object rt.TextEval `if:"label=_"`
}

var _ IntoTargetFields = (*IntoObj)(nil)

func (*IntoObj) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_obj",
		Uses: "flow",
		Lede: "obj",
	}
}

// IntoVar Targets an object or record stored in a variable
type IntoVar struct {
	Var value.VariableName `if:"label=_"`
}

var _ IntoTargetFields = (*IntoVar)(nil)

func (*IntoVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_var",
		Uses: "flow",
		Lede: "var",
	}
}

// IsEmpty True if the text is empty.
type IsEmpty struct {
	Text rt.TextEval `if:"label=empty"`
}

var _ rt.BoolEval = (*IsEmpty)(nil)

func (*IsEmpty) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_empty",
		Uses: "flow",
		Lede: "is",
	}
}

// IsExactKindOf True if the object is exactly the named kind.
type IsExactKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   string      `if:"label=is_exactly,type=text"`
}

var _ rt.BoolEval = (*IsExactKindOf)(nil)

func (*IsExactKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_exact_kind_of",
		Uses: "flow",
		Lede: "kind_of",
	}
}

// IsKindOf True if the object is compatible with the named kind.
type IsKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   string      `if:"label=is,type=text"`
}

var _ rt.BoolEval = (*IsKindOf)(nil)

func (*IsKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_kind_of",
		Uses: "flow",
		Lede: "kind_of",
	}
}

// Join Returns multiple pieces of text as a single new piece of text.
type Join struct {
	Sep   rt.TextEval   `if:"label=_"`
	Parts []rt.TextEval `if:"label=parts"`
}

var _ rt.TextEval = (*Join)(nil)

func (*Join) Compose() composer.Spec {
	return composer.Spec{
		Name: "join",
		Uses: "flow",
	}
}

// KindOf Friendly name of the object&#x27;s kind.
type KindOf struct {
	Object rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*KindOf)(nil)

func (*KindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of",
		Uses: "flow",
	}
}

// KindsOf A list of compatible kinds.
type KindsOf struct {
	Kind string `if:"label=_,type=text"`
}

var _ rt.TextListEval = (*KindsOf)(nil)

func (*KindsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of",
		Uses: "flow",
	}
}

// LessThan The first value is less than the second value.
type LessThan struct{}

var _ Comparator = (*LessThan)(nil)

func (*LessThan) Compose() composer.Spec {
	return composer.Spec{
		Name: "less_than",
		Uses: "flow",
	}
}

// MakeLowercase Returns new text, with every letter turned into lowercase. For example, &#x27;shout&#x27; from &#x27;SHOUT&#x27;.
type MakeLowercase struct {
	Text rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*MakeLowercase)(nil)

func (*MakeLowercase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_lowercase",
		Uses: "flow",
		Lede: "lower",
	}
}

// MakeReversed Returns new text flipped back to front. For example, &#x27;elppA&#x27; from &#x27;Apple&#x27;, or &#x27;noon&#x27; from &#x27;noon&#x27;.
type MakeReversed struct {
	Text rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*MakeReversed)(nil)

func (*MakeReversed) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_reversed",
		Uses: "flow",
		Lede: "reverse",
	}
}

// MakeSentenceCase Returns new text, start each sentence with a capital letter. For example, &#x27;Empire Apple.&#x27; from &#x27;Empire apple.&#x27;.
type MakeSentenceCase struct {
	Text rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*MakeSentenceCase)(nil)

func (*MakeSentenceCase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_sentence_case",
		Uses: "flow",
		Lede: "sentence",
	}
}

// MakeTitleCase Returns new text, starting each word with a capital letter. For example, &#x27;Empire Apple&#x27; from &#x27;empire apple&#x27;.
type MakeTitleCase struct {
	Text rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*MakeTitleCase)(nil)

func (*MakeTitleCase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_title_case",
		Uses: "flow",
		Lede: "title",
	}
}

// MakeUppercase Returns new text, with every letter turned into uppercase. For example, &#x27;APPLE&#x27; from &#x27;apple&#x27;.
type MakeUppercase struct {
	Text rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*MakeUppercase)(nil)

func (*MakeUppercase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_uppercase",
		Uses: "flow",
		Lede: "upper",
	}
}

// Matches Determine whether the specified text is similar to the specified regular expression.
type Matches struct {
	Text    rt.TextEval `if:"label=_"`
	Pattern string      `if:"label=to,type=text"`
	Cache   MatchCache  `if:"internal"`
}

var _ rt.BoolEval = (*Matches)(nil)

func (*Matches) Compose() composer.Spec {
	return composer.Spec{
		Name: "matches",
		Uses: "flow",
	}
}

// NameOf Full name of the object.
type NameOf struct {
	Object rt.TextEval `if:"label=_"`
}

var _ rt.TextEval = (*NameOf)(nil)

func (*NameOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "name_of",
		Uses: "flow",
	}
}

// Never Returns false.
type Never struct{}

var _ rt.BoolEval = (*Never)(nil)

func (*Never) Compose() composer.Spec {
	return composer.Spec{
		Name: "never",
		Uses: "flow",
		Lede: "always",
	}
}

// Newline Start a new line.
type Newline struct{}

var _ rt.Execute = (*Newline)(nil)

func (*Newline) Compose() composer.Spec {
	return composer.Spec{
		Name: "newline",
		Uses: "flow",
		Lede: "br",
	}
}

// Next In a repeating loop, try the next iteration of the loop.
type Next struct{}

var _ rt.Execute = (*Next)(nil)

func (*Next) Compose() composer.Spec {
	return composer.Spec{
		Name: "next",
		Uses: "flow",
	}
}

// Not Returns the opposite value.
type Not struct {
	Test rt.BoolEval `if:"label=_"`
}

var _ rt.BoolEval = (*Not)(nil)

func (*Not) Compose() composer.Spec {
	return composer.Spec{
		Name: "not",
		Uses: "flow",
	}
}

// NumValue Specify a particular number.
type NumValue struct {
	Num float64 `if:"label=_,type=number"`
}

var _ rt.NumberEval = (*NumValue)(nil)

func (*NumValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "num_value",
		Uses: "flow",
		Lede: "num",
	}
}

// Numbers Number List: Specify a list of numbers.
type Numbers struct {
	Values []float64 `if:"label=_,type=number"`
}

var _ rt.NumListEval = (*Numbers)(nil)

func (*Numbers) Compose() composer.Spec {
	return composer.Spec{
		Name: "numbers",
		Uses: "flow",
		Lede: "nums",
	}
}

// ObjectExists Returns whether there is a object of the specified name.
type ObjectExists struct {
	Object rt.TextEval `if:"label=valid"`
}

var _ rt.BoolEval = (*ObjectExists)(nil)

func (*ObjectExists) Compose() composer.Spec {
	return composer.Spec{
		Name: "object_exists",
		Uses: "flow",
		Lede: "is",
	}
}

// Pluralize Returns the plural form of a singular word. (ex. apples for apple. )
type Pluralize struct {
	Text rt.TextEval `if:"label=of"`
}

var _ rt.TextEval = (*Pluralize)(nil)

func (*Pluralize) Compose() composer.Spec {
	return composer.Spec{
		Name: "pluralize",
		Uses: "flow",
		Lede: "plural",
	}
}

// PrintNum Writes a number using numerals, eg. &#x27;1&#x27;.
type PrintNum struct {
	Num rt.NumberEval `if:"label=_"`
}

var _ rt.TextEval = (*PrintNum)(nil)

func (*PrintNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "print_num",
		Uses: "flow",
		Lede: "numeral",
	}
}

// PrintNumWord Writes a number in plain english: eg. &#x27;one&#x27;
type PrintNumWord struct {
	Num rt.NumberEval `if:"label=words"`
}

var _ rt.TextEval = (*PrintNumWord)(nil)

func (*PrintNumWord) Compose() composer.Spec {
	return composer.Spec{
		Name: "print_num_word",
		Uses: "flow",
		Lede: "numeral",
	}
}

// ProductOf Multiply two numbers.
type ProductOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

var _ rt.NumberEval = (*ProductOf)(nil)

func (*ProductOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "product_of",
		Uses: "flow",
		Lede: "mul",
	}
}

// PutAtField Put a value into the field of an record or object
type PutAtField struct {
	Into    IntoTargetFields `if:"label=_"`
	From    rt.Assignment    `if:"label=from"`
	AtField string           `if:"label=at,type=text"`
}

var _ rt.Execute = (*PutAtField)(nil)

func (*PutAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: "put_at_field",
		Uses: "flow",
		Lede: "put",
	}
}

// QuotientOf Divide one number by another.
type QuotientOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

var _ rt.NumberEval = (*QuotientOf)(nil)

func (*QuotientOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "quotient_of",
		Uses: "flow",
		Lede: "div",
	}
}

// RemainderOf Divide one number by another, and return the remainder.
type RemainderOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

var _ rt.NumberEval = (*RemainderOf)(nil)

func (*RemainderOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "remainder_of",
		Uses: "flow",
		Lede: "mod",
	}
}

// Response Generate text in a replaceable manner.
type Response struct {
	Name string      `if:"label=_,type=text"`
	Text rt.TextEval `if:"label=text,optional"`
}

var _ rt.TextEval = (*Response)(nil)

func (*Response) Compose() composer.Spec {
	return composer.Spec{
		Name: "response",
		Uses: "flow",
	}
}

// Row A single line as part of a group of lines.
type Row struct {
	Do Activity `if:"label=_"`
}

var _ rt.TextEval = (*Row)(nil)

func (*Row) Compose() composer.Spec {
	return composer.Spec{
		Name: "row",
		Uses: "flow",
	}
}

// Rows Group text into successive lines.
type Rows struct {
	Do Activity `if:"label=_"`
}

var _ rt.TextEval = (*Rows)(nil)

func (*Rows) Compose() composer.Spec {
	return composer.Spec{
		Name: "rows",
		Uses: "flow",
	}
}

// SayText Print some bit of text to the player.
type SayText struct {
	Text rt.TextEval `if:"label=_"`
}

var _ rt.Execute = (*SayText)(nil)

func (*SayText) Compose() composer.Spec {
	return composer.Spec{
		Name: "say_text",
		Uses: "flow",
		Lede: "say",
	}
}

// SetTrait Put an object into a particular state.
type SetTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

var _ rt.Execute = (*SetTrait)(nil)

func (*SetTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: "set_trait",
		Uses: "flow",
		Lede: "put",
	}
}

// Singularize Returns the singular form of a plural word. (ex. apple for apples )
type Singularize struct {
	Text rt.TextEval `if:"label=of"`
}

var _ rt.TextEval = (*Singularize)(nil)

func (*Singularize) Compose() composer.Spec {
	return composer.Spec{
		Name: "singularize",
		Uses: "flow",
		Lede: "singular",
	}
}

// SlashText Separates words with left-leaning slashes &#x27;/&#x27;.
type SlashText struct {
	Do Activity `if:"label=_"`
}

var _ rt.TextEval = (*SlashText)(nil)

func (*SlashText) Compose() composer.Spec {
	return composer.Spec{
		Name: "slash_text",
		Uses: "flow",
		Lede: "slashes",
	}
}

// Softline Start a new line ( if not already at a new line. )
type Softline struct{}

var _ rt.Execute = (*Softline)(nil)

func (*Softline) Compose() composer.Spec {
	return composer.Spec{
		Name: "softline",
		Uses: "flow",
		Lede: "wbr",
	}
}

// SpanText Writes text with spaces between words.
type SpanText struct {
	Do Activity `if:"label=_"`
}

var _ rt.TextEval = (*SpanText)(nil)

func (*SpanText) Compose() composer.Spec {
	return composer.Spec{
		Name: "span_text",
		Uses: "flow",
		Lede: "spaces",
	}
}

// SumOf Add two numbers.
type SumOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

var _ rt.NumberEval = (*SumOf)(nil)

func (*SumOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "sum_of",
		Uses: "flow",
		Lede: "inc",
	}
}

// TextValue Specify a small bit of text.
type TextValue struct {
	Text string `if:"label=_,type=text"`
}

var _ rt.TextEval = (*TextValue)(nil)

func (*TextValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "text_value",
		Uses: "flow",
		Lede: "txt",
	}
}

// Texts Text List: Specifies a set of string values.
type Texts struct {
	Values []string `if:"label=_,type=text"`
}

var _ rt.TextListEval = (*Texts)(nil)

func (*Texts) Compose() composer.Spec {
	return composer.Spec{
		Name: "texts",
		Uses: "flow",
		Lede: "txts",
	}
}

// TriggerCycle
type TriggerCycle struct{}

var _ Trigger = (*TriggerCycle)(nil)

func (*TriggerCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_cycle",
		Uses: "flow",
		Lede: "every",
	}
}

// TriggerOnce
type TriggerOnce struct{}

var _ Trigger = (*TriggerOnce)(nil)

func (*TriggerOnce) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_once",
		Uses: "flow",
		Lede: "at",
	}
}

// TriggerSwitch
type TriggerSwitch struct{}

var _ Trigger = (*TriggerSwitch)(nil)

func (*TriggerSwitch) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_switch",
		Uses: "flow",
		Lede: "after",
	}
}

// Unequal The first value doesn&#x27;t equal the second value.
type Unequal struct{}

var _ Comparator = (*Unequal)(nil)

func (*Unequal) Compose() composer.Spec {
	return composer.Spec{
		Name: "unequal",
		Uses: "flow",
		Lede: "other_than",
	}
}

// While Keep running a series of actions while a condition is true.
type While struct {
	True rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
}

var _ rt.Execute = (*While)(nil)

func (*While) Compose() composer.Spec {
	return composer.Spec{
		Name: "while",
		Uses: "flow",
		Lede: "repeating",
	}
}

var Slots = []interface{}{
	(*Brancher)(nil),
	(*Comparator)(nil),
	(*FromSourceFields)(nil),
	(*IntoTargetFields)(nil),
	(*Trigger)(nil),
}
var Slats = []composer.Composer{
	(*Activity)(nil),
	(*AllTrue)(nil),
	(*Always)(nil),
	(*AnyTrue)(nil),
	(*Assign)(nil),
	(*AtLeast)(nil),
	(*AtMost)(nil),
	(*Blankline)(nil),
	(*BoolValue)(nil),
	(*BracketText)(nil),
	(*Break)(nil),
	(*BufferText)(nil),
	(*CallArg)(nil),
	(*CallArgs)(nil),
	(*CallCycle)(nil),
	(*CallMake)(nil),
	(*CallPattern)(nil),
	(*CallSend)(nil),
	(*CallShuffle)(nil),
	(*CallTerminal)(nil),
	(*CallTrigger)(nil),
	(*Capitalize)(nil),
	(*ChooseAction)(nil),
	(*ChooseMore)(nil),
	(*ChooseMoreValue)(nil),
	(*ChooseNothingElse)(nil),
	(*ChooseNum)(nil),
	(*ChooseText)(nil),
	(*ChooseValue)(nil),
	(*CommaText)(nil),
	(*CompareNum)(nil),
	(*CompareText)(nil),
	(*DiffOf)(nil),
	(*During)(nil),
	(*Equal)(nil),
	(*FromBool)(nil),
	(*FromNum)(nil),
	(*FromNumbers)(nil),
	(*FromObj)(nil),
	(*FromRec)(nil),
	(*FromRecord)(nil),
	(*FromRecords)(nil),
	(*FromText)(nil),
	(*FromTexts)(nil),
	(*FromVar)(nil),
	(*GetAtField)(nil),
	(*GetVar)(nil),
	(*GreaterThan)(nil),
	(*HasDominion)(nil),
	(*HasTrait)(nil),
	(*IdOf)(nil),
	(*Includes)(nil),
	(*IntoObj)(nil),
	(*IntoVar)(nil),
	(*IsEmpty)(nil),
	(*IsExactKindOf)(nil),
	(*IsKindOf)(nil),
	(*Join)(nil),
	(*KindOf)(nil),
	(*KindsOf)(nil),
	(*LessThan)(nil),
	(*MakeLowercase)(nil),
	(*MakeReversed)(nil),
	(*MakeSentenceCase)(nil),
	(*MakeTitleCase)(nil),
	(*MakeUppercase)(nil),
	(*Matches)(nil),
	(*NameOf)(nil),
	(*Never)(nil),
	(*Newline)(nil),
	(*Next)(nil),
	(*Not)(nil),
	(*NumValue)(nil),
	(*Numbers)(nil),
	(*ObjectExists)(nil),
	(*Pluralize)(nil),
	(*PrintNum)(nil),
	(*PrintNumWord)(nil),
	(*ProductOf)(nil),
	(*PutAtField)(nil),
	(*QuotientOf)(nil),
	(*RemainderOf)(nil),
	(*Response)(nil),
	(*Row)(nil),
	(*Rows)(nil),
	(*SayText)(nil),
	(*SetTrait)(nil),
	(*Singularize)(nil),
	(*SlashText)(nil),
	(*Softline)(nil),
	(*SpanText)(nil),
	(*SumOf)(nil),
	(*TextValue)(nil),
	(*Texts)(nil),
	(*TriggerCycle)(nil),
	(*TriggerOnce)(nil),
	(*TriggerSwitch)(nil),
	(*Unequal)(nil),
	(*While)(nil),
}
