// Code generated by "makeops"; edit at your own risk.
package core

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// Activity
type Activity struct {
	Exe []rt.Execute `if:"label=do"`
}

func (*Activity) Compose() composer.Spec {
	return composer.Spec{
		Name: "activity",
		Lede: "act",
	}
}

// AllTrue Returns true if all of the evaluations are true.
type AllTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

func (*AllTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: "all_true",
		Lede: "all_of",
	}
}

// Always Returns true.
type Always struct{}

func (*Always) Compose() composer.Spec {
	return composer.Spec{
		Name: "always",
	}
}

// AnyTrue Returns true if any of the evaluations are true.
type AnyTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

func (*AnyTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: "any_true",
		Lede: "any_of",
	}
}

// Assign Assigns a variable to a value.
type Assign struct {
	Var  value.VariableName `if:"label=_"`
	From rt.Assignment      `if:"label=be"`
}

func (*Assign) Compose() composer.Spec {
	return composer.Spec{
		Name: "assign",
		Lede: "let",
	}
}

// AtLeast The first value is greater than or equal to the second value.
type AtLeast struct{}

func (*AtLeast) Compose() composer.Spec {
	return composer.Spec{
		Name: "at_least",
	}
}

// AtMost The first value is less than or equal to the second value.
type AtMost struct{}

func (*AtMost) Compose() composer.Spec {
	return composer.Spec{
		Name: "at_most",
	}
}

// Blankline Add a single blank line following some text.
type Blankline struct{}

func (*Blankline) Compose() composer.Spec {
	return composer.Spec{
		Name: "blankline",
		Lede: "p",
	}
}

// BoolValue Specify an explicit true or false value.
type BoolValue struct {
	Bool bool `if:"label=_"`
}

func (*BoolValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "bool_value",
		Lede: "bool",
	}
}

// BracketText Sandwiches text printed during a block and puts them inside parenthesis &#x27;()&#x27;.
type BracketText struct {
	Do Activity `if:"label=_"`
}

func (*BracketText) Compose() composer.Spec {
	return composer.Spec{
		Name: "bracket_text",
		Lede: "brackets",
	}
}

// Break In a repeating loop, exit the loop.
type Break struct{}

func (*Break) Compose() composer.Spec {
	return composer.Spec{
		Name: "break",
	}
}

// BufferText
type BufferText struct {
	Do Activity `if:"label=_"`
}

func (*BufferText) Compose() composer.Spec {
	return composer.Spec{
		Name: "buffer_text",
		Lede: "buffers",
	}
}

// CallArg Runtime version of argument
type CallArg struct {
	Name value.Text    `if:"label=_"`
	From rt.Assignment `if:"label=from"`
}

func (*CallArg) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_arg",
		Lede: "inarg",
	}
}

// CallArgs Runtime version of arguments
type CallArgs struct {
	Args []CallArg `if:"label=_"`
}

func (*CallArgs) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_args",
		Lede: "inargs",
	}
}

// CallCycle Runtime version of cycle_text
type CallCycle struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CallCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_cycle",
		Lede: "cycle",
	}
}

// CallMake Runtime version of make
type CallMake struct {
	Kind      value.Text `if:"label=_"`
	Arguments CallArgs   `if:"label=args"`
}

func (*CallMake) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_make",
		Lede: "make",
	}
}

// CallPattern Runtime version of determine
type CallPattern struct {
	Pattern   value.PatternName `if:"label=_"`
	Arguments CallArgs          `if:"label=args"`
}

func (*CallPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_pattern",
	}
}

// CallSend Runtime version of send
type CallSend struct {
	Event     value.Text      `if:"label=_"`
	Path      rt.TextListEval `if:"label=to"`
	Arguments CallArgs        `if:"label=args"`
}

func (*CallSend) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_send",
	}
}

// CallShuffle Runtime version of shuffle_text
type CallShuffle struct {
	At      reader.Position `if:"internal"`
	Parts   []rt.TextEval   `if:"label=_"`
	Indices Shuffler        `if:"internal"`
}

func (*CallShuffle) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_shuffle",
		Lede: "shuffle",
	}
}

// CallTerminal Runtime version of stopping_text
type CallTerminal struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CallTerminal) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_terminal",
		Lede: "stopping",
	}
}

// CallTrigger Runtime version of count_of
type CallTrigger struct {
	At      reader.Position `if:"internal"`
	Trigger Trigger         `if:"label=_"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CallTrigger) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_trigger",
		Lede: "trigger",
	}
}

// Capitalize Returns new text, with the first letter turned into uppercase.
type Capitalize struct {
	Text rt.TextEval `if:"label=_"`
}

func (*Capitalize) Compose() composer.Spec {
	return composer.Spec{
		Name: "capitalize",
	}
}

// ChooseAction An if statement.
type ChooseAction struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

func (*ChooseAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_action",
		Lede: "if",
	}
}

// ChooseMore
type ChooseMore struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

func (*ChooseMore) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_more",
		Lede: "else_if",
	}
}

// ChooseMoreValue
type ChooseMoreValue struct {
	Assign value.Text    `if:"label=_"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

func (*ChooseMoreValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_more_value",
		Lede: "else_if",
	}
}

// ChooseNothingElse
type ChooseNothingElse struct {
	Do Activity `if:"label=_"`
}

func (*ChooseNothingElse) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_nothing_else",
		Lede: "else_do",
	}
}

// ChooseNum Pick one of two numbers based on a boolean test.
type ChooseNum struct {
	If    rt.BoolEval   `if:"label=if"`
	True  rt.NumberEval `if:"label=then"`
	False rt.NumberEval `if:"label=else"`
}

func (*ChooseNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_num",
		Lede: "num",
	}
}

// ChooseText Pick one of two strings based on a boolean test.
type ChooseText struct {
	If    rt.BoolEval `if:"label=if"`
	True  rt.TextEval `if:"label=then"`
	False rt.TextEval `if:"label=else"`
}

func (*ChooseText) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_text",
		Lede: "txt",
	}
}

// ChooseValue An if statement with local assignment.
type ChooseValue struct {
	Assign value.Text    `if:"label=_"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

func (*ChooseValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_value",
		Lede: "if",
	}
}

// CommaText Separates words with commas, and &#x27;and&#x27;.
type CommaText struct {
	Do Activity `if:"label=_"`
}

func (*CommaText) Compose() composer.Spec {
	return composer.Spec{
		Name: "comma_text",
		Lede: "commas",
	}
}

// CompareNum True if eq,ne,gt,lt,ge,le two numbers.
type CompareNum struct {
	A  rt.NumberEval `if:"label=_"`
	Is Comparator    `if:"label=is"`
	B  rt.NumberEval `if:"label=num"`
}

func (*CompareNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "compare_num",
		Lede: "cmp",
	}
}

// CompareText True if eq,ne,gt,lt,ge,le two strings ( lexical. )
type CompareText struct {
	A  rt.TextEval `if:"label=_"`
	Is Comparator  `if:"label=is"`
	B  rt.TextEval `if:"label=txt"`
}

func (*CompareText) Compose() composer.Spec {
	return composer.Spec{
		Name: "compare_text",
		Lede: "cmp",
	}
}

// DiffOf Subtract two numbers.
type DiffOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

func (*DiffOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "diff_of",
		Lede: "dec",
	}
}

// During Decide whether a pattern is running.
type During struct {
	Pattern value.PatternName `if:"label=_"`
}

func (*During) Compose() composer.Spec {
	return composer.Spec{
		Name: "during",
	}
}

// Equal Two values exactly match.
type Equal struct{}

func (*Equal) Compose() composer.Spec {
	return composer.Spec{
		Name: "equal",
		Lede: "equals",
	}
}

// FromBool Assigns the calculated boolean value.
type FromBool struct {
	Val rt.BoolEval `if:"label=_"`
}

func (*FromBool) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_bool",
		Lede: "bool",
	}
}

// FromNum Assigns the calculated number.
type FromNum struct {
	Val rt.NumberEval `if:"label=_"`
}

func (*FromNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_num",
		Lede: "num",
	}
}

// FromNumbers Assigns the calculated numbers.
type FromNumbers struct {
	Vals rt.NumListEval `if:"label=_"`
}

func (*FromNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_numbers",
		Lede: "nums",
	}
}

// FromObj Targets an object with a computed name.
type FromObj struct {
	Object rt.TextEval `if:"label=_"`
}

func (*FromObj) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_obj",
		Lede: "obj",
	}
}

// FromRec Targets a record stored in a record.
type FromRec struct {
	Rec rt.RecordEval `if:"label=_"`
}

func (*FromRec) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_rec",
		Lede: "rec",
	}
}

// FromRecord Assigns the calculated record.
type FromRecord struct {
	Val rt.RecordEval `if:"label=_"`
}

func (*FromRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_record",
		Lede: "rec",
	}
}

// FromRecords Assigns the calculated records.
type FromRecords struct {
	Vals rt.RecordListEval `if:"label=_"`
}

func (*FromRecords) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_records",
		Lede: "recs",
	}
}

// FromText Assigns the calculated piece of text.
type FromText struct {
	Val rt.TextEval `if:"label=_"`
}

func (*FromText) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_text",
		Lede: "txt",
	}
}

// FromTexts Assigns the calculated texts.
type FromTexts struct {
	Vals rt.TextListEval `if:"label=_"`
}

func (*FromTexts) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_texts",
		Lede: "txts",
	}
}

// FromVar Targets a record stored in a variable.
type FromVar struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_var",
		Lede: "var",
	}
}

// GetAtField Get a value from a record.
type GetAtField struct {
	Field value.Text       `if:"label=_"`
	From  FromSourceFields `if:"label=from"`
}

func (*GetAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: "get_at_field",
		Lede: "get",
	}
}

// GetVar Get Variable: Return the value of the named variable.
type GetVar struct {
	Name value.VariableName `if:"label=_"`
}

func (*GetVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "get_var",
		Lede: "var",
	}
}

// GreaterThan The first value is larger than the second value.
type GreaterThan struct{}

func (*GreaterThan) Compose() composer.Spec {
	return composer.Spec{
		Name: "greater_than",
	}
}

// HasDominion
type HasDominion struct {
	Name value.Text `if:"label=_"`
}

func (*HasDominion) Compose() composer.Spec {
	return composer.Spec{
		Name: "has_dominion",
	}
}

// HasTrait Return true if the object is currently in the requested state.
type HasTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

func (*HasTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: "has_trait",
		Lede: "get",
	}
}

// IdOf A unique object identifier.
type IdOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*IdOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "id_of",
	}
}

// Includes True if text contains text.
type Includes struct {
	Text rt.TextEval `if:"label=_"`
	Part rt.TextEval `if:"label=part"`
}

func (*Includes) Compose() composer.Spec {
	return composer.Spec{
		Name: "includes",
		Lede: "contains",
	}
}

// IntoObj Targets an object with a computed name.
type IntoObj struct {
	Object rt.TextEval `if:"label=_"`
}

func (*IntoObj) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_obj",
		Lede: "obj",
	}
}

// IntoVar Targets an object or record stored in a variable
type IntoVar struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_var",
		Lede: "var",
	}
}

// IsEmpty True if the text is empty.
type IsEmpty struct {
	Text rt.TextEval `if:"label=empty"`
}

func (*IsEmpty) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_empty",
		Lede: "is",
	}
}

// IsExactKindOf True if the object is exactly the named kind.
type IsExactKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   value.Text  `if:"label=is_exactly"`
}

func (*IsExactKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_exact_kind_of",
		Lede: "kind_of",
	}
}

// IsKindOf True if the object is compatible with the named kind.
type IsKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   value.Text  `if:"label=is"`
}

func (*IsKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_kind_of",
		Lede: "kind_of",
	}
}

// Join Returns multiple pieces of text as a single new piece of text.
type Join struct {
	Sep   rt.TextEval   `if:"label=_"`
	Parts []rt.TextEval `if:"label=parts"`
}

func (*Join) Compose() composer.Spec {
	return composer.Spec{
		Name: "join",
	}
}

// KindOf Friendly name of the object&#x27;s kind.
type KindOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*KindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of",
	}
}

// KindsOf A list of compatible kinds.
type KindsOf struct {
	Kind value.Text `if:"label=_"`
}

func (*KindsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of",
	}
}

// LessThan The first value is less than the second value.
type LessThan struct{}

func (*LessThan) Compose() composer.Spec {
	return composer.Spec{
		Name: "less_than",
	}
}

// MakeLowercase Returns new text, with every letter turned into lowercase. For example, &#x27;shout&#x27; from &#x27;SHOUT&#x27;.
type MakeLowercase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeLowercase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_lowercase",
		Lede: "lower",
	}
}

// MakeReversed Returns new text flipped back to front. For example, &#x27;elppA&#x27; from &#x27;Apple&#x27;, or &#x27;noon&#x27; from &#x27;noon&#x27;.
type MakeReversed struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeReversed) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_reversed",
		Lede: "reverse",
	}
}

// MakeSentenceCase Returns new text, start each sentence with a capital letter. For example, &#x27;Empire Apple.&#x27; from &#x27;Empire apple.&#x27;.
type MakeSentenceCase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeSentenceCase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_sentence_case",
		Lede: "sentence",
	}
}

// MakeTitleCase Returns new text, starting each word with a capital letter. For example, &#x27;Empire Apple&#x27; from &#x27;empire apple&#x27;.
type MakeTitleCase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeTitleCase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_title_case",
		Lede: "title",
	}
}

// MakeUppercase Returns new text, with every letter turned into uppercase. For example, &#x27;APPLE&#x27; from &#x27;apple&#x27;.
type MakeUppercase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeUppercase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_uppercase",
		Lede: "upper",
	}
}

// Matches Determine whether the specified text is similar to the specified regular expression.
type Matches struct {
	Text    rt.TextEval `if:"label=_"`
	Pattern string      `if:"label=to"`
	Cache   MatchCache  `if:"internal"`
}

func (*Matches) Compose() composer.Spec {
	return composer.Spec{
		Name: "matches",
	}
}

// NameOf Full name of the object.
type NameOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*NameOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "name_of",
	}
}

// Never Returns false.
type Never struct{}

func (*Never) Compose() composer.Spec {
	return composer.Spec{
		Name: "never",
		Lede: "always",
	}
}

// Newline Start a new line.
type Newline struct{}

func (*Newline) Compose() composer.Spec {
	return composer.Spec{
		Name: "newline",
		Lede: "br",
	}
}

// Next In a repeating loop, try the next iteration of the loop.
type Next struct{}

func (*Next) Compose() composer.Spec {
	return composer.Spec{
		Name: "next",
	}
}

// Not Returns the opposite value.
type Not struct {
	Test rt.BoolEval `if:"label=_"`
}

func (*Not) Compose() composer.Spec {
	return composer.Spec{
		Name: "not",
	}
}

// NumValue Specify a particular number.
type NumValue struct {
	Num float64 `if:"label=_"`
}

func (*NumValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "num_value",
		Lede: "num",
	}
}

// Numbers Number List: Specify a list of numbers.
type Numbers struct {
	Values []float64 `if:"label=_"`
}

func (*Numbers) Compose() composer.Spec {
	return composer.Spec{
		Name: "numbers",
		Lede: "nums",
	}
}

// ObjectExists Returns whether there is a object of the specified name.
type ObjectExists struct {
	Object rt.TextEval `if:"label=valid"`
}

func (*ObjectExists) Compose() composer.Spec {
	return composer.Spec{
		Name: "object_exists",
		Lede: "is",
	}
}

// Pluralize Returns the plural form of a singular word. (ex. apples for apple. )
type Pluralize struct {
	Text rt.TextEval `if:"label=of"`
}

func (*Pluralize) Compose() composer.Spec {
	return composer.Spec{
		Name: "pluralize",
		Lede: "plural",
	}
}

// PrintNum Writes a number using numerals, eg. &#x27;1&#x27;.
type PrintNum struct {
	Num rt.NumberEval `if:"label=_"`
}

func (*PrintNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "print_num",
		Lede: "numeral",
	}
}

// PrintNumWord Writes a number in plain english: eg. &#x27;one&#x27;
type PrintNumWord struct {
	Num rt.NumberEval `if:"label=words"`
}

func (*PrintNumWord) Compose() composer.Spec {
	return composer.Spec{
		Name: "print_num_word",
		Lede: "numeral",
	}
}

// ProductOf Multiply two numbers.
type ProductOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*ProductOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "product_of",
		Lede: "mul",
	}
}

// PutAtField Put a value into the field of an record or object
type PutAtField struct {
	Into    IntoTargetFields `if:"label=_"`
	From    rt.Assignment    `if:"label=from"`
	AtField value.Text       `if:"label=at"`
}

func (*PutAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: "put_at_field",
		Lede: "put",
	}
}

// QuotientOf Divide one number by another.
type QuotientOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*QuotientOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "quotient_of",
		Lede: "div",
	}
}

// RemainderOf Divide one number by another, and return the remainder.
type RemainderOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*RemainderOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "remainder_of",
		Lede: "mod",
	}
}

// Response Generate text in a replaceable manner.
type Response struct {
	Name value.Text  `if:"label=_"`
	Text rt.TextEval `if:"label=text,optional"`
}

func (*Response) Compose() composer.Spec {
	return composer.Spec{
		Name: "response",
	}
}

// Row A single line as part of a group of lines.
type Row struct {
	Do Activity `if:"label=_"`
}

func (*Row) Compose() composer.Spec {
	return composer.Spec{
		Name: "row",
	}
}

// Rows Group text into successive lines.
type Rows struct {
	Do Activity `if:"label=_"`
}

func (*Rows) Compose() composer.Spec {
	return composer.Spec{
		Name: "rows",
	}
}

// SayText Print some bit of text to the player.
type SayText struct {
	Text rt.TextEval `if:"label=_"`
}

func (*SayText) Compose() composer.Spec {
	return composer.Spec{
		Name: "say_text",
		Lede: "say",
	}
}

// SetTrait Put an object into a particular state.
type SetTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

func (*SetTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: "set_trait",
		Lede: "put",
	}
}

// Singularize Returns the singular form of a plural word. (ex. apple for apples )
type Singularize struct {
	Text rt.TextEval `if:"label=of"`
}

func (*Singularize) Compose() composer.Spec {
	return composer.Spec{
		Name: "singularize",
		Lede: "singular",
	}
}

// SlashText Separates words with left-leaning slashes &#x27;/&#x27;.
type SlashText struct {
	Do Activity `if:"label=_"`
}

func (*SlashText) Compose() composer.Spec {
	return composer.Spec{
		Name: "slash_text",
		Lede: "slashes",
	}
}

// Softline Start a new line ( if not already at a new line. )
type Softline struct{}

func (*Softline) Compose() composer.Spec {
	return composer.Spec{
		Name: "softline",
		Lede: "wbr",
	}
}

// SpanText Writes text with spaces between words.
type SpanText struct {
	Do Activity `if:"label=_"`
}

func (*SpanText) Compose() composer.Spec {
	return composer.Spec{
		Name: "span_text",
		Lede: "spaces",
	}
}

// SumOf Add two numbers.
type SumOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

func (*SumOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "sum_of",
		Lede: "inc",
	}
}

// TextValue Specify a small bit of text.
type TextValue struct {
	Text value.Text `if:"label=_"`
}

func (*TextValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "text_value",
		Lede: "txt",
	}
}

// Texts Text List: Specifies a set of string values.
type Texts struct {
	Values []value.Text `if:"label=_"`
}

func (*Texts) Compose() composer.Spec {
	return composer.Spec{
		Name: "texts",
		Lede: "txts",
	}
}

// TriggerCycle
type TriggerCycle struct{}

func (*TriggerCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_cycle",
		Lede: "every",
	}
}

// TriggerOnce
type TriggerOnce struct{}

func (*TriggerOnce) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_once",
		Lede: "at",
	}
}

// TriggerSwitch
type TriggerSwitch struct{}

func (*TriggerSwitch) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_switch",
		Lede: "after",
	}
}

// Unequal The first value doesn&#x27;t equal the second value.
type Unequal struct{}

func (*Unequal) Compose() composer.Spec {
	return composer.Spec{
		Name: "unequal",
		Lede: "other_than",
	}
}

// While Keep running a series of actions while a condition is true.
type While struct {
	True rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
}

func (*While) Compose() composer.Spec {
	return composer.Spec{
		Name: "while",
		Lede: "repeating",
	}
}

var Slots = []interface{}{
	(*Brancher)(nil),
	(*Comparator)(nil),
	(*FromSourceFields)(nil),
	(*IntoTargetFields)(nil),
	(*Trigger)(nil),
}
var Slats = []composer.Composer{
	(*Activity)(nil),
	(*AllTrue)(nil),
	(*Always)(nil),
	(*AnyTrue)(nil),
	(*Assign)(nil),
	(*AtLeast)(nil),
	(*AtMost)(nil),
	(*Blankline)(nil),
	(*BoolValue)(nil),
	(*BracketText)(nil),
	(*Break)(nil),
	(*BufferText)(nil),
	(*CallArg)(nil),
	(*CallArgs)(nil),
	(*CallCycle)(nil),
	(*CallMake)(nil),
	(*CallPattern)(nil),
	(*CallSend)(nil),
	(*CallShuffle)(nil),
	(*CallTerminal)(nil),
	(*CallTrigger)(nil),
	(*Capitalize)(nil),
	(*ChooseAction)(nil),
	(*ChooseMore)(nil),
	(*ChooseMoreValue)(nil),
	(*ChooseNothingElse)(nil),
	(*ChooseNum)(nil),
	(*ChooseText)(nil),
	(*ChooseValue)(nil),
	(*CommaText)(nil),
	(*CompareNum)(nil),
	(*CompareText)(nil),
	(*DiffOf)(nil),
	(*During)(nil),
	(*Equal)(nil),
	(*FromBool)(nil),
	(*FromNum)(nil),
	(*FromNumbers)(nil),
	(*FromObj)(nil),
	(*FromRec)(nil),
	(*FromRecord)(nil),
	(*FromRecords)(nil),
	(*FromText)(nil),
	(*FromTexts)(nil),
	(*FromVar)(nil),
	(*GetAtField)(nil),
	(*GetVar)(nil),
	(*GreaterThan)(nil),
	(*HasDominion)(nil),
	(*HasTrait)(nil),
	(*IdOf)(nil),
	(*Includes)(nil),
	(*IntoObj)(nil),
	(*IntoVar)(nil),
	(*IsEmpty)(nil),
	(*IsExactKindOf)(nil),
	(*IsKindOf)(nil),
	(*Join)(nil),
	(*KindOf)(nil),
	(*KindsOf)(nil),
	(*LessThan)(nil),
	(*MakeLowercase)(nil),
	(*MakeReversed)(nil),
	(*MakeSentenceCase)(nil),
	(*MakeTitleCase)(nil),
	(*MakeUppercase)(nil),
	(*Matches)(nil),
	(*NameOf)(nil),
	(*Never)(nil),
	(*Newline)(nil),
	(*Next)(nil),
	(*Not)(nil),
	(*NumValue)(nil),
	(*Numbers)(nil),
	(*ObjectExists)(nil),
	(*Pluralize)(nil),
	(*PrintNum)(nil),
	(*PrintNumWord)(nil),
	(*ProductOf)(nil),
	(*PutAtField)(nil),
	(*QuotientOf)(nil),
	(*RemainderOf)(nil),
	(*Response)(nil),
	(*Row)(nil),
	(*Rows)(nil),
	(*SayText)(nil),
	(*SetTrait)(nil),
	(*Singularize)(nil),
	(*SlashText)(nil),
	(*Softline)(nil),
	(*SpanText)(nil),
	(*SumOf)(nil),
	(*TextValue)(nil),
	(*Texts)(nil),
	(*TriggerCycle)(nil),
	(*TriggerOnce)(nil),
	(*TriggerSwitch)(nil),
	(*Unequal)(nil),
	(*While)(nil),
}
