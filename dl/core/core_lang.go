// Code generated by "makeops"; edit at your own risk.
package core

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
)

// Activity
type Activity struct {
	Exe []rt.Execute `if:"label=_"`
}

func (*Activity) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Activity,
		Uses: "flow",
		Lede: "act",
	}
}

var Type_Activity = "activity"

func (op *Activity) MarshalJSON() (ret []byte, err error) {
	if jsonExe, e := op.MarshalJSONExe(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Activity,
			Value: map[string]json.RawMessage{
				"$EXE": jsonExe,
			},
		})
	}
	return
}

func (op *Activity) MarshalJSONExe() (ret []byte, err error) {
	ret, err = json.Marshal(op.Exe)
	return
}

// AllTrue Returns true if all of the evaluations are true.
type AllTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

func (*AllTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AllTrue,
		Uses: "flow",
		Lede: "all_of",
	}
}

var Type_AllTrue = "all_true"

func (op *AllTrue) MarshalJSON() (ret []byte, err error) {
	if jsonTest, e := op.MarshalJSONTest(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_AllTrue,
			Value: map[string]json.RawMessage{
				"$TEST": jsonTest,
			},
		})
	}
	return
}

func (op *AllTrue) MarshalJSONTest() (ret []byte, err error) {
	ret, err = json.Marshal(op.Test)
	return
}

// Always Returns true.
type Always struct {
}

func (*Always) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Always,
		Uses: "flow",
	}
}

var Type_Always = "always"

func (op *Always) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Always,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// AnyTrue Returns true if any of the evaluations are true.
type AnyTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

func (*AnyTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AnyTrue,
		Uses: "flow",
		Lede: "any_of",
	}
}

var Type_AnyTrue = "any_true"

func (op *AnyTrue) MarshalJSON() (ret []byte, err error) {
	if jsonTest, e := op.MarshalJSONTest(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_AnyTrue,
			Value: map[string]json.RawMessage{
				"$TEST": jsonTest,
			},
		})
	}
	return
}

func (op *AnyTrue) MarshalJSONTest() (ret []byte, err error) {
	ret, err = json.Marshal(op.Test)
	return
}

// Assign Assigns a variable to a value.
type Assign struct {
	Var  value.VariableName `if:"label=_"`
	From rt.Assignment      `if:"label=be"`
}

func (*Assign) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Assign,
		Uses: "flow",
		Lede: "let",
	}
}

var Type_Assign = "assign"

func (op *Assign) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Assign,
			Value: map[string]json.RawMessage{
				"$VAR":  jsonVar,
				"$FROM": jsonFrom,
			},
		})
	}
	return
}

func (op *Assign) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

func (op *Assign) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

// AtLeast The first value is greater than or equal to the second value.
type AtLeast struct {
}

func (*AtLeast) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AtLeast,
		Uses: "flow",
	}
}

var Type_AtLeast = "at_least"

func (op *AtLeast) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_AtLeast,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// AtMost The first value is less than or equal to the second value.
type AtMost struct {
}

func (*AtMost) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AtMost,
		Uses: "flow",
	}
}

var Type_AtMost = "at_most"

func (op *AtMost) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_AtMost,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// Blankline Add a single blank line following some text.
type Blankline struct {
}

func (*Blankline) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Blankline,
		Uses: "flow",
		Lede: "p",
	}
}

var Type_Blankline = "blankline"

func (op *Blankline) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Blankline,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// BoolValue Specify an explicit true or false value.
type BoolValue struct {
	Bool bool `if:"label=_,type=bool"`
}

func (*BoolValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BoolValue,
		Uses: "flow",
		Lede: "bool",
	}
}

var Type_BoolValue = "bool_value"

func (op *BoolValue) MarshalJSON() (ret []byte, err error) {
	if jsonBool, e := op.MarshalJSONBool(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_BoolValue,
			Value: map[string]json.RawMessage{
				"$BOOL": jsonBool,
			},
		})
	}
	return
}

func (op *BoolValue) MarshalJSONBool() (ret []byte, err error) {
	// bool override
	var str string
	if op.Bool {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	ret, err = m.MarshalJSON()
	return
}

// BracketText Sandwiches text printed during a block and puts them inside parenthesis &#x27;()&#x27;.
type BracketText struct {
	Do Activity `if:"label=_"`
}

func (*BracketText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BracketText,
		Uses: "flow",
		Lede: "brackets",
	}
}

var Type_BracketText = "bracket_text"

func (op *BracketText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_BracketText,
			Value: map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *BracketText) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

const Type_Brancher = "brancher"

// Break In a repeating loop, exit the loop.
type Break struct {
}

func (*Break) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Break,
		Uses: "flow",
	}
}

var Type_Break = "break"

func (op *Break) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Break,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// BufferText
type BufferText struct {
	Do Activity `if:"label=_"`
}

func (*BufferText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BufferText,
		Uses: "flow",
		Lede: "buffers",
	}
}

var Type_BufferText = "buffer_text"

func (op *BufferText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_BufferText,
			Value: map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *BufferText) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

// CallArg Runtime version of argument
type CallArg struct {
	Name string        `if:"label=_,type=text"`
	From rt.Assignment `if:"label=from"`
}

func (*CallArg) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallArg,
		Uses: "flow",
		Lede: "inarg",
	}
}

var Type_CallArg = "call_arg"

func (op *CallArg) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_CallArg,
			Value: map[string]json.RawMessage{
				"$NAME": jsonName,
				"$FROM": jsonFrom,
			},
		})
	}
	return
}

func (op *CallArg) MarshalJSONName() (ret []byte, err error) {
	// type override
	m := value.Text{op.Name}
	ret, err = m.MarshalJSON()
	return
}

func (op *CallArg) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

// CallArgs Runtime version of arguments
type CallArgs struct {
	Args []CallArg `if:"label=_"`
}

func (*CallArgs) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallArgs,
		Uses: "flow",
		Lede: "inargs",
	}
}

var Type_CallArgs = "call_args"

func (op *CallArgs) MarshalJSON() (ret []byte, err error) {
	if jsonArgs, e := op.MarshalJSONArgs(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_CallArgs,
			Value: map[string]json.RawMessage{
				"$ARGS": jsonArgs,
			},
		})
	}
	return
}

func (op *CallArgs) MarshalJSONArgs() (ret []byte, err error) {
	ret, err = json.Marshal(op.Args)
	return
}

// CallCycle Runtime version of cycle_text
type CallCycle struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CallCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallCycle,
		Uses: "flow",
		Lede: "cycle",
	}
}

var Type_CallCycle = "call_cycle"

func (op *CallCycle) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_CallCycle,
			Value: map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *CallCycle) MarshalJSONParts() (ret []byte, err error) {
	ret, err = json.Marshal(op.Parts)
	return
}

// CallMake Runtime version of make
type CallMake struct {
	Kind      string   `if:"label=_,type=text"`
	Arguments CallArgs `if:"label=args"`
}

func (*CallMake) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallMake,
		Uses: "flow",
	}
}

var Type_CallMake = "call_make"

func (op *CallMake) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_CallMake,
			Value: map[string]json.RawMessage{
				"$KIND":      jsonKind,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *CallMake) MarshalJSONKind() (ret []byte, err error) {
	// type override
	m := value.Text{op.Kind}
	ret, err = m.MarshalJSON()
	return
}

func (op *CallMake) MarshalJSONArguments() (ret []byte, err error) {
	ret, err = op.Arguments.MarshalJSON()
	return
}

// CallPattern Runtime version of determine
type CallPattern struct {
	Pattern   value.PatternName `if:"label=_"`
	Arguments CallArgs          `if:"label=args"`
}

func (*CallPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallPattern,
		Uses: "flow",
	}
}

var Type_CallPattern = "call_pattern"

func (op *CallPattern) MarshalJSON() (ret []byte, err error) {
	if jsonPattern, e := op.MarshalJSONPattern(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_CallPattern,
			Value: map[string]json.RawMessage{
				"$PATTERN":   jsonPattern,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *CallPattern) MarshalJSONPattern() (ret []byte, err error) {
	ret, err = op.Pattern.MarshalJSON()
	return
}

func (op *CallPattern) MarshalJSONArguments() (ret []byte, err error) {
	ret, err = op.Arguments.MarshalJSON()
	return
}

// CallSend Runtime version of send
type CallSend struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=to"`
	Arguments CallArgs        `if:"label=args"`
}

func (*CallSend) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallSend,
		Uses: "flow",
	}
}

var Type_CallSend = "call_send"

func (op *CallSend) MarshalJSON() (ret []byte, err error) {
	if jsonEvent, e := op.MarshalJSONEvent(); e != nil {
		err = e
	} else if jsonPath, e := op.MarshalJSONPath(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_CallSend,
			Value: map[string]json.RawMessage{
				"$EVENT":     jsonEvent,
				"$PATH":      jsonPath,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *CallSend) MarshalJSONEvent() (ret []byte, err error) {
	// type override
	m := value.Text{op.Event}
	ret, err = m.MarshalJSON()
	return
}

func (op *CallSend) MarshalJSONPath() (ret []byte, err error) {
	if v, e := op.Path.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextListEval,
			Value: v,
		})
	}
	return
}

func (op *CallSend) MarshalJSONArguments() (ret []byte, err error) {
	ret, err = op.Arguments.MarshalJSON()
	return
}

// CallShuffle Runtime version of shuffle_text
type CallShuffle struct {
	At      reader.Position `if:"internal"`
	Parts   []rt.TextEval   `if:"label=_"`
	Indices Shuffler        `if:"internal"`
}

func (*CallShuffle) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallShuffle,
		Uses: "flow",
		Lede: "shuffle",
	}
}

var Type_CallShuffle = "call_shuffle"

func (op *CallShuffle) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_CallShuffle,
			Value: map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *CallShuffle) MarshalJSONParts() (ret []byte, err error) {
	ret, err = json.Marshal(op.Parts)
	return
}

// CallTerminal Runtime version of stopping_text
type CallTerminal struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CallTerminal) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallTerminal,
		Uses: "flow",
		Lede: "stopping",
	}
}

var Type_CallTerminal = "call_terminal"

func (op *CallTerminal) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_CallTerminal,
			Value: map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *CallTerminal) MarshalJSONParts() (ret []byte, err error) {
	ret, err = json.Marshal(op.Parts)
	return
}

// CallTrigger Runtime version of count_of
type CallTrigger struct {
	At      reader.Position `if:"internal"`
	Trigger Trigger         `if:"label=_"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CallTrigger) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallTrigger,
		Uses: "flow",
		Lede: "trigger",
	}
}

var Type_CallTrigger = "call_trigger"

func (op *CallTrigger) MarshalJSON() (ret []byte, err error) {
	if jsonTrigger, e := op.MarshalJSONTrigger(); e != nil {
		err = e
	} else if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_CallTrigger,
			Value: map[string]json.RawMessage{
				"$TRIGGER": jsonTrigger,
				"$NUM":     jsonNum,
			},
		})
	}
	return
}

func (op *CallTrigger) MarshalJSONTrigger() (ret []byte, err error) {
	if v, e := op.Trigger.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_Trigger,
			Value: v,
		})
	}
	return
}

func (op *CallTrigger) MarshalJSONNum() (ret []byte, err error) {
	if v, e := op.Num.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// Capitalize Returns new text, with the first letter turned into uppercase.
type Capitalize struct {
	Text rt.TextEval `if:"label=_"`
}

func (*Capitalize) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Capitalize,
		Uses: "flow",
	}
}

var Type_Capitalize = "capitalize"

func (op *Capitalize) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Capitalize,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *Capitalize) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// ChooseAction An if statement.
type ChooseAction struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

func (*ChooseAction) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseAction,
		Uses: "flow",
		Lede: "if",
	}
}

var Type_ChooseAction = "choose_action"

func (op *ChooseAction) MarshalJSON() (ret []byte, err error) {
	if jsonIf, e := op.MarshalJSONIf(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ChooseAction,
			Value: map[string]json.RawMessage{
				"$IF":   jsonIf,
				"$DO":   jsonDo,
				"$ELSE": jsonElse,
			},
		})
	}
	return
}

func (op *ChooseAction) MarshalJSONIf() (ret []byte, err error) {
	if v, e := op.If.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *ChooseAction) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

func (op *ChooseAction) MarshalJSONElse() (ret []byte, err error) {
	if v, e := op.Else.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_Brancher,
			Value: v,
		})
	}
	return
}

// ChooseMore
type ChooseMore struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

func (*ChooseMore) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseMore,
		Uses: "flow",
		Lede: "else_if",
	}
}

var Type_ChooseMore = "choose_more"

func (op *ChooseMore) MarshalJSON() (ret []byte, err error) {
	if jsonIf, e := op.MarshalJSONIf(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ChooseMore,
			Value: map[string]json.RawMessage{
				"$IF":   jsonIf,
				"$DO":   jsonDo,
				"$ELSE": jsonElse,
			},
		})
	}
	return
}

func (op *ChooseMore) MarshalJSONIf() (ret []byte, err error) {
	if v, e := op.If.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *ChooseMore) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

func (op *ChooseMore) MarshalJSONElse() (ret []byte, err error) {
	if v, e := op.Else.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_Brancher,
			Value: v,
		})
	}
	return
}

// ChooseMoreValue
type ChooseMoreValue struct {
	Assign string        `if:"label=_,type=text"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

func (*ChooseMoreValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseMoreValue,
		Uses: "flow",
		Lede: "else_if",
	}
}

var Type_ChooseMoreValue = "choose_more_value"

func (op *ChooseMoreValue) MarshalJSON() (ret []byte, err error) {
	if jsonAssign, e := op.MarshalJSONAssign(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonFilter, e := op.MarshalJSONFilter(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ChooseMoreValue,
			Value: map[string]json.RawMessage{
				"$ASSIGN": jsonAssign,
				"$FROM":   jsonFrom,
				"$FILTER": jsonFilter,
				"$DO":     jsonDo,
				"$ELSE":   jsonElse,
			},
		})
	}
	return
}

func (op *ChooseMoreValue) MarshalJSONAssign() (ret []byte, err error) {
	// type override
	m := value.Text{op.Assign}
	ret, err = m.MarshalJSON()
	return
}

func (op *ChooseMoreValue) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *ChooseMoreValue) MarshalJSONFilter() (ret []byte, err error) {
	if v, e := op.Filter.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *ChooseMoreValue) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

func (op *ChooseMoreValue) MarshalJSONElse() (ret []byte, err error) {
	if v, e := op.Else.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_Brancher,
			Value: v,
		})
	}
	return
}

// ChooseNothingElse
type ChooseNothingElse struct {
	Do Activity `if:"label=_"`
}

func (*ChooseNothingElse) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseNothingElse,
		Uses: "flow",
		Lede: "else_do",
	}
}

var Type_ChooseNothingElse = "choose_nothing_else"

func (op *ChooseNothingElse) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ChooseNothingElse,
			Value: map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *ChooseNothingElse) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

// ChooseNum Pick one of two numbers based on a boolean test.
type ChooseNum struct {
	If    rt.BoolEval   `if:"label=if"`
	True  rt.NumberEval `if:"label=then"`
	False rt.NumberEval `if:"label=else"`
}

func (*ChooseNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseNum,
		Uses: "flow",
		Lede: "num",
	}
}

var Type_ChooseNum = "choose_num"

func (op *ChooseNum) MarshalJSON() (ret []byte, err error) {
	if jsonIf, e := op.MarshalJSONIf(); e != nil {
		err = e
	} else if jsonTrue, e := op.MarshalJSONTrue(); e != nil {
		err = e
	} else if jsonFalse, e := op.MarshalJSONFalse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ChooseNum,
			Value: map[string]json.RawMessage{
				"$IF":    jsonIf,
				"$TRUE":  jsonTrue,
				"$FALSE": jsonFalse,
			},
		})
	}
	return
}

func (op *ChooseNum) MarshalJSONIf() (ret []byte, err error) {
	if v, e := op.If.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *ChooseNum) MarshalJSONTrue() (ret []byte, err error) {
	if v, e := op.True.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *ChooseNum) MarshalJSONFalse() (ret []byte, err error) {
	if v, e := op.False.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// ChooseText Pick one of two strings based on a boolean test.
type ChooseText struct {
	If    rt.BoolEval `if:"label=if"`
	True  rt.TextEval `if:"label=then"`
	False rt.TextEval `if:"label=else"`
}

func (*ChooseText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseText,
		Uses: "flow",
		Lede: "txt",
	}
}

var Type_ChooseText = "choose_text"

func (op *ChooseText) MarshalJSON() (ret []byte, err error) {
	if jsonIf, e := op.MarshalJSONIf(); e != nil {
		err = e
	} else if jsonTrue, e := op.MarshalJSONTrue(); e != nil {
		err = e
	} else if jsonFalse, e := op.MarshalJSONFalse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ChooseText,
			Value: map[string]json.RawMessage{
				"$IF":    jsonIf,
				"$TRUE":  jsonTrue,
				"$FALSE": jsonFalse,
			},
		})
	}
	return
}

func (op *ChooseText) MarshalJSONIf() (ret []byte, err error) {
	if v, e := op.If.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *ChooseText) MarshalJSONTrue() (ret []byte, err error) {
	if v, e := op.True.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *ChooseText) MarshalJSONFalse() (ret []byte, err error) {
	if v, e := op.False.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// ChooseValue An if statement with local assignment.
type ChooseValue struct {
	Assign string        `if:"label=_,type=text"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

func (*ChooseValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseValue,
		Uses: "flow",
		Lede: "if",
	}
}

var Type_ChooseValue = "choose_value"

func (op *ChooseValue) MarshalJSON() (ret []byte, err error) {
	if jsonAssign, e := op.MarshalJSONAssign(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonFilter, e := op.MarshalJSONFilter(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ChooseValue,
			Value: map[string]json.RawMessage{
				"$ASSIGN": jsonAssign,
				"$FROM":   jsonFrom,
				"$FILTER": jsonFilter,
				"$DO":     jsonDo,
				"$ELSE":   jsonElse,
			},
		})
	}
	return
}

func (op *ChooseValue) MarshalJSONAssign() (ret []byte, err error) {
	// type override
	m := value.Text{op.Assign}
	ret, err = m.MarshalJSON()
	return
}

func (op *ChooseValue) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *ChooseValue) MarshalJSONFilter() (ret []byte, err error) {
	if v, e := op.Filter.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *ChooseValue) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

func (op *ChooseValue) MarshalJSONElse() (ret []byte, err error) {
	if v, e := op.Else.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_Brancher,
			Value: v,
		})
	}
	return
}

// CommaText Separates words with commas, and &#x27;and&#x27;.
type CommaText struct {
	Do Activity `if:"label=_"`
}

func (*CommaText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CommaText,
		Uses: "flow",
		Lede: "commas",
	}
}

var Type_CommaText = "comma_text"

func (op *CommaText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_CommaText,
			Value: map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *CommaText) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

const Type_Comparator = "comparator"

// CompareNum True if eq,ne,gt,lt,ge,le two numbers.
type CompareNum struct {
	A  rt.NumberEval `if:"label=_"`
	Is Comparator    `if:"label=is"`
	B  rt.NumberEval `if:"label=num"`
}

func (*CompareNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CompareNum,
		Uses: "flow",
		Lede: "cmp",
	}
}

var Type_CompareNum = "compare_num"

func (op *CompareNum) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonIs, e := op.MarshalJSONIs(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_CompareNum,
			Value: map[string]json.RawMessage{
				"$A":  jsonA,
				"$IS": jsonIs,
				"$B":  jsonB,
			},
		})
	}
	return
}

func (op *CompareNum) MarshalJSONA() (ret []byte, err error) {
	if v, e := op.A.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *CompareNum) MarshalJSONIs() (ret []byte, err error) {
	if v, e := op.Is.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_Comparator,
			Value: v,
		})
	}
	return
}

func (op *CompareNum) MarshalJSONB() (ret []byte, err error) {
	if v, e := op.B.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// CompareText True if eq,ne,gt,lt,ge,le two strings ( lexical. )
type CompareText struct {
	A  rt.TextEval `if:"label=_"`
	Is Comparator  `if:"label=is"`
	B  rt.TextEval `if:"label=txt"`
}

func (*CompareText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CompareText,
		Uses: "flow",
		Lede: "cmp",
	}
}

var Type_CompareText = "compare_text"

func (op *CompareText) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonIs, e := op.MarshalJSONIs(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_CompareText,
			Value: map[string]json.RawMessage{
				"$A":  jsonA,
				"$IS": jsonIs,
				"$B":  jsonB,
			},
		})
	}
	return
}

func (op *CompareText) MarshalJSONA() (ret []byte, err error) {
	if v, e := op.A.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *CompareText) MarshalJSONIs() (ret []byte, err error) {
	if v, e := op.Is.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_Comparator,
			Value: v,
		})
	}
	return
}

func (op *CompareText) MarshalJSONB() (ret []byte, err error) {
	if v, e := op.B.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// DiffOf Subtract two numbers.
type DiffOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

func (*DiffOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_DiffOf,
		Uses: "flow",
		Lede: "dec",
	}
}

var Type_DiffOf = "diff_of"

func (op *DiffOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_DiffOf,
			Value: map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *DiffOf) MarshalJSONA() (ret []byte, err error) {
	if v, e := op.A.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *DiffOf) MarshalJSONB() (ret []byte, err error) {
	if v, e := op.B.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// During Decide whether a pattern is running.
type During struct {
	Pattern value.PatternName `if:"label=_"`
}

func (*During) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_During,
		Uses: "flow",
	}
}

var Type_During = "during"

func (op *During) MarshalJSON() (ret []byte, err error) {
	if jsonPattern, e := op.MarshalJSONPattern(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_During,
			Value: map[string]json.RawMessage{
				"$PATTERN": jsonPattern,
			},
		})
	}
	return
}

func (op *During) MarshalJSONPattern() (ret []byte, err error) {
	ret, err = op.Pattern.MarshalJSON()
	return
}

// Equal Two values exactly match.
type Equal struct {
}

func (*Equal) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Equal,
		Uses: "flow",
		Lede: "equals",
	}
}

var Type_Equal = "equal"

func (op *Equal) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Equal,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// FromBool Assigns the calculated boolean value.
type FromBool struct {
	Val rt.BoolEval `if:"label=_"`
}

func (*FromBool) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromBool,
		Uses: "flow",
	}
}

var Type_FromBool = "from_bool"

func (op *FromBool) MarshalJSON() (ret []byte, err error) {
	if jsonVal, e := op.MarshalJSONVal(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromBool,
			Value: map[string]json.RawMessage{
				"$VAL": jsonVal,
			},
		})
	}
	return
}

func (op *FromBool) MarshalJSONVal() (ret []byte, err error) {
	if v, e := op.Val.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

// FromNum Assigns the calculated number.
type FromNum struct {
	Val rt.NumberEval `if:"label=_"`
}

func (*FromNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromNum,
		Uses: "flow",
	}
}

var Type_FromNum = "from_num"

func (op *FromNum) MarshalJSON() (ret []byte, err error) {
	if jsonVal, e := op.MarshalJSONVal(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromNum,
			Value: map[string]json.RawMessage{
				"$VAL": jsonVal,
			},
		})
	}
	return
}

func (op *FromNum) MarshalJSONVal() (ret []byte, err error) {
	if v, e := op.Val.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// FromNumbers Assigns the calculated numbers.
type FromNumbers struct {
	Vals rt.NumListEval `if:"label=_"`
}

func (*FromNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromNumbers,
		Uses: "flow",
		Lede: "from_nums",
	}
}

var Type_FromNumbers = "from_numbers"

func (op *FromNumbers) MarshalJSON() (ret []byte, err error) {
	if jsonVals, e := op.MarshalJSONVals(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromNumbers,
			Value: map[string]json.RawMessage{
				"$VALS": jsonVals,
			},
		})
	}
	return
}

func (op *FromNumbers) MarshalJSONVals() (ret []byte, err error) {
	if v, e := op.Vals.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumListEval,
			Value: v,
		})
	}
	return
}

// FromObj Targets an object with a computed name.
type FromObj struct {
	Object rt.TextEval `if:"label=_"`
}

func (*FromObj) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromObj,
		Uses: "flow",
	}
}

var Type_FromObj = "from_obj"

func (op *FromObj) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromObj,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *FromObj) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// FromRec Targets a record stored in a record.
type FromRec struct {
	Rec rt.RecordEval `if:"label=_"`
}

func (*FromRec) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromRec,
		Uses: "flow",
	}
}

var Type_FromRec = "from_rec"

func (op *FromRec) MarshalJSON() (ret []byte, err error) {
	if jsonRec, e := op.MarshalJSONRec(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromRec,
			Value: map[string]json.RawMessage{
				"$REC": jsonRec,
			},
		})
	}
	return
}

func (op *FromRec) MarshalJSONRec() (ret []byte, err error) {
	if v, e := op.Rec.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_RecordEval,
			Value: v,
		})
	}
	return
}

// FromRecord Assigns the calculated record.
type FromRecord struct {
	Val rt.RecordEval `if:"label=_"`
}

func (*FromRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromRecord,
		Uses: "flow",
		Lede: "from_rec",
	}
}

var Type_FromRecord = "from_record"

func (op *FromRecord) MarshalJSON() (ret []byte, err error) {
	if jsonVal, e := op.MarshalJSONVal(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromRecord,
			Value: map[string]json.RawMessage{
				"$VAL": jsonVal,
			},
		})
	}
	return
}

func (op *FromRecord) MarshalJSONVal() (ret []byte, err error) {
	if v, e := op.Val.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_RecordEval,
			Value: v,
		})
	}
	return
}

// FromRecords Assigns the calculated records.
type FromRecords struct {
	Vals rt.RecordListEval `if:"label=_"`
}

func (*FromRecords) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromRecords,
		Uses: "flow",
		Lede: "from_recs",
	}
}

var Type_FromRecords = "from_records"

func (op *FromRecords) MarshalJSON() (ret []byte, err error) {
	if jsonVals, e := op.MarshalJSONVals(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromRecords,
			Value: map[string]json.RawMessage{
				"$VALS": jsonVals,
			},
		})
	}
	return
}

func (op *FromRecords) MarshalJSONVals() (ret []byte, err error) {
	if v, e := op.Vals.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_RecordListEval,
			Value: v,
		})
	}
	return
}

const Type_FromSourceFields = "from_source_fields"

// FromText Assigns the calculated piece of text.
type FromText struct {
	Val rt.TextEval `if:"label=_"`
}

func (*FromText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromText,
		Uses: "flow",
		Lede: "from_txt",
	}
}

var Type_FromText = "from_text"

func (op *FromText) MarshalJSON() (ret []byte, err error) {
	if jsonVal, e := op.MarshalJSONVal(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromText,
			Value: map[string]json.RawMessage{
				"$VAL": jsonVal,
			},
		})
	}
	return
}

func (op *FromText) MarshalJSONVal() (ret []byte, err error) {
	if v, e := op.Val.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// FromTexts Assigns the calculated texts.
type FromTexts struct {
	Vals rt.TextListEval `if:"label=_"`
}

func (*FromTexts) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromTexts,
		Uses: "flow",
		Lede: "from_txts",
	}
}

var Type_FromTexts = "from_texts"

func (op *FromTexts) MarshalJSON() (ret []byte, err error) {
	if jsonVals, e := op.MarshalJSONVals(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromTexts,
			Value: map[string]json.RawMessage{
				"$VALS": jsonVals,
			},
		})
	}
	return
}

func (op *FromTexts) MarshalJSONVals() (ret []byte, err error) {
	if v, e := op.Vals.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextListEval,
			Value: v,
		})
	}
	return
}

// FromVar Targets a record stored in a variable.
type FromVar struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromVar) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromVar,
		Uses: "flow",
	}
}

var Type_FromVar = "from_var"

func (op *FromVar) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromVar,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *FromVar) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// GetAtField Get a value from a record.
type GetAtField struct {
	Field string           `if:"label=_,type=text"`
	From  FromSourceFields `if:"label=from"`
}

func (*GetAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_GetAtField,
		Uses: "flow",
		Lede: "get",
	}
}

var Type_GetAtField = "get_at_field"

func (op *GetAtField) MarshalJSON() (ret []byte, err error) {
	if jsonField, e := op.MarshalJSONField(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_GetAtField,
			Value: map[string]json.RawMessage{
				"$FIELD": jsonField,
				"$FROM":  jsonFrom,
			},
		})
	}
	return
}

func (op *GetAtField) MarshalJSONField() (ret []byte, err error) {
	// type override
	m := value.Text{op.Field}
	ret, err = m.MarshalJSON()
	return
}

func (op *GetAtField) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_FromSourceFields,
			Value: v,
		})
	}
	return
}

// GetVar Get Variable: Return the value of the named variable.
type GetVar struct {
	Name value.VariableName `if:"label=_"`
}

func (*GetVar) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_GetVar,
		Uses: "flow",
		Lede: "var",
	}
}

var Type_GetVar = "get_var"

func (op *GetVar) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_GetVar,
			Value: map[string]json.RawMessage{
				"$NAME": jsonName,
			},
		})
	}
	return
}

func (op *GetVar) MarshalJSONName() (ret []byte, err error) {
	ret, err = op.Name.MarshalJSON()
	return
}

// GreaterThan The first value is larger than the second value.
type GreaterThan struct {
}

func (*GreaterThan) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_GreaterThan,
		Uses: "flow",
	}
}

var Type_GreaterThan = "greater_than"

func (op *GreaterThan) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_GreaterThan,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// HasDominion
type HasDominion struct {
	Name string `if:"label=_,type=text"`
}

func (*HasDominion) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_HasDominion,
		Uses: "flow",
	}
}

var Type_HasDominion = "has_dominion"

func (op *HasDominion) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_HasDominion,
			Value: map[string]json.RawMessage{
				"$NAME": jsonName,
			},
		})
	}
	return
}

func (op *HasDominion) MarshalJSONName() (ret []byte, err error) {
	// type override
	m := value.Text{op.Name}
	ret, err = m.MarshalJSON()
	return
}

// HasTrait Return true if the object is currently in the requested state.
type HasTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

func (*HasTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_HasTrait,
		Uses: "flow",
		Lede: "get",
	}
}

var Type_HasTrait = "has_trait"

func (op *HasTrait) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_HasTrait,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
				"$TRAIT":  jsonTrait,
			},
		})
	}
	return
}

func (op *HasTrait) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *HasTrait) MarshalJSONTrait() (ret []byte, err error) {
	if v, e := op.Trait.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// IdOf A unique object identifier.
type IdOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*IdOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IdOf,
		Uses: "flow",
	}
}

var Type_IdOf = "id_of"

func (op *IdOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IdOf,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *IdOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// Includes True if text contains text.
type Includes struct {
	Text rt.TextEval `if:"label=_"`
	Part rt.TextEval `if:"label=part"`
}

func (*Includes) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Includes,
		Uses: "flow",
		Lede: "contains",
	}
}

var Type_Includes = "includes"

func (op *Includes) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else if jsonPart, e := op.MarshalJSONPart(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Includes,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
				"$PART": jsonPart,
			},
		})
	}
	return
}

func (op *Includes) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *Includes) MarshalJSONPart() (ret []byte, err error) {
	if v, e := op.Part.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// IntoObj Targets an object with a computed name.
type IntoObj struct {
	Object rt.TextEval `if:"label=_"`
}

func (*IntoObj) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoObj,
		Uses: "flow",
		Lede: "obj",
	}
}

var Type_IntoObj = "into_obj"

func (op *IntoObj) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IntoObj,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *IntoObj) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

const Type_IntoTargetFields = "into_target_fields"

// IntoVar Targets an object or record stored in a variable
type IntoVar struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoVar) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoVar,
		Uses: "flow",
		Lede: "var",
	}
}

var Type_IntoVar = "into_var"

func (op *IntoVar) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IntoVar,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *IntoVar) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// IsEmpty True if the text is empty.
type IsEmpty struct {
	Text rt.TextEval `if:"label=empty"`
}

func (*IsEmpty) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IsEmpty,
		Uses: "flow",
		Lede: "is",
	}
}

var Type_IsEmpty = "is_empty"

func (op *IsEmpty) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IsEmpty,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *IsEmpty) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// IsExactKindOf True if the object is exactly the named kind.
type IsExactKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   string      `if:"label=is_exactly,type=text"`
}

func (*IsExactKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IsExactKindOf,
		Uses: "flow",
		Lede: "kind_of",
	}
}

var Type_IsExactKindOf = "is_exact_kind_of"

func (op *IsExactKindOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IsExactKindOf,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
				"$KIND":   jsonKind,
			},
		})
	}
	return
}

func (op *IsExactKindOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *IsExactKindOf) MarshalJSONKind() (ret []byte, err error) {
	// type override
	m := value.Text{op.Kind}
	ret, err = m.MarshalJSON()
	return
}

// IsKindOf True if the object is compatible with the named kind.
type IsKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   string      `if:"label=is,type=text"`
}

func (*IsKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IsKindOf,
		Uses: "flow",
		Lede: "kind_of",
	}
}

var Type_IsKindOf = "is_kind_of"

func (op *IsKindOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IsKindOf,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
				"$KIND":   jsonKind,
			},
		})
	}
	return
}

func (op *IsKindOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *IsKindOf) MarshalJSONKind() (ret []byte, err error) {
	// type override
	m := value.Text{op.Kind}
	ret, err = m.MarshalJSON()
	return
}

// Join Returns multiple pieces of text as a single new piece of text.
type Join struct {
	Sep   rt.TextEval   `if:"label=_"`
	Parts []rt.TextEval `if:"label=parts"`
}

func (*Join) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Join,
		Uses: "flow",
	}
}

var Type_Join = "join"

func (op *Join) MarshalJSON() (ret []byte, err error) {
	if jsonSep, e := op.MarshalJSONSep(); e != nil {
		err = e
	} else if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Join,
			Value: map[string]json.RawMessage{
				"$SEP":   jsonSep,
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *Join) MarshalJSONSep() (ret []byte, err error) {
	if v, e := op.Sep.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *Join) MarshalJSONParts() (ret []byte, err error) {
	ret, err = json.Marshal(op.Parts)
	return
}

// KindOf Friendly name of the object&#x27;s kind.
type KindOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*KindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindOf,
		Uses: "flow",
	}
}

var Type_KindOf = "kind_of"

func (op *KindOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_KindOf,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *KindOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// KindsOf A list of compatible kinds.
type KindsOf struct {
	Kind string `if:"label=_,type=text"`
}

func (*KindsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsOf,
		Uses: "flow",
	}
}

var Type_KindsOf = "kinds_of"

func (op *KindsOf) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_KindsOf,
			Value: map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *KindsOf) MarshalJSONKind() (ret []byte, err error) {
	// type override
	m := value.Text{op.Kind}
	ret, err = m.MarshalJSON()
	return
}

// LessThan The first value is less than the second value.
type LessThan struct {
}

func (*LessThan) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_LessThan,
		Uses: "flow",
	}
}

var Type_LessThan = "less_than"

func (op *LessThan) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_LessThan,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// MakeLowercase Returns new text, with every letter turned into lowercase. For example, &#x27;shout&#x27; from &#x27;SHOUT&#x27;.
type MakeLowercase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeLowercase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeLowercase,
		Uses: "flow",
		Lede: "lower",
	}
}

var Type_MakeLowercase = "make_lowercase"

func (op *MakeLowercase) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_MakeLowercase,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeLowercase) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// MakeReversed Returns new text flipped back to front. For example, &#x27;elppA&#x27; from &#x27;Apple&#x27;, or &#x27;noon&#x27; from &#x27;noon&#x27;.
type MakeReversed struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeReversed) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeReversed,
		Uses: "flow",
		Lede: "reverse",
	}
}

var Type_MakeReversed = "make_reversed"

func (op *MakeReversed) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_MakeReversed,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeReversed) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// MakeSentenceCase Returns new text, start each sentence with a capital letter. For example, &#x27;Empire Apple.&#x27; from &#x27;Empire apple.&#x27;.
type MakeSentenceCase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeSentenceCase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeSentenceCase,
		Uses: "flow",
		Lede: "sentence",
	}
}

var Type_MakeSentenceCase = "make_sentence_case"

func (op *MakeSentenceCase) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_MakeSentenceCase,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeSentenceCase) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// MakeTitleCase Returns new text, starting each word with a capital letter. For example, &#x27;Empire Apple&#x27; from &#x27;empire apple&#x27;.
type MakeTitleCase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeTitleCase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeTitleCase,
		Uses: "flow",
		Lede: "title",
	}
}

var Type_MakeTitleCase = "make_title_case"

func (op *MakeTitleCase) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_MakeTitleCase,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeTitleCase) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// MakeUppercase Returns new text, with every letter turned into uppercase. For example, &#x27;APPLE&#x27; from &#x27;apple&#x27;.
type MakeUppercase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeUppercase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeUppercase,
		Uses: "flow",
		Lede: "upper",
	}
}

var Type_MakeUppercase = "make_uppercase"

func (op *MakeUppercase) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_MakeUppercase,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeUppercase) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// Matches Determine whether the specified text is similar to the specified regular expression.
type Matches struct {
	Text    rt.TextEval `if:"label=_"`
	Pattern string      `if:"label=to,type=text"`
	Cache   MatchCache  `if:"internal"`
}

func (*Matches) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Matches,
		Uses: "flow",
	}
}

var Type_Matches = "matches"

func (op *Matches) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else if jsonPattern, e := op.MarshalJSONPattern(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Matches,
			Value: map[string]json.RawMessage{
				"$TEXT":    jsonText,
				"$PATTERN": jsonPattern,
			},
		})
	}
	return
}

func (op *Matches) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *Matches) MarshalJSONPattern() (ret []byte, err error) {
	// type override
	m := value.Text{op.Pattern}
	ret, err = m.MarshalJSON()
	return
}

// NameOf Full name of the object.
type NameOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*NameOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NameOf,
		Uses: "flow",
	}
}

var Type_NameOf = "name_of"

func (op *NameOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_NameOf,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *NameOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// Never Returns false.
type Never struct {
}

func (*Never) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Never,
		Uses: "flow",
		Lede: "always",
	}
}

var Type_Never = "never"

func (op *Never) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Never,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// Newline Start a new line.
type Newline struct {
}

func (*Newline) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Newline,
		Uses: "flow",
		Lede: "br",
	}
}

var Type_Newline = "newline"

func (op *Newline) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Newline,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// Next In a repeating loop, try the next iteration of the loop.
type Next struct {
}

func (*Next) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Next,
		Uses: "flow",
	}
}

var Type_Next = "next"

func (op *Next) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Next,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// Not Returns the opposite value.
type Not struct {
	Test rt.BoolEval `if:"label=_"`
}

func (*Not) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Not,
		Uses: "flow",
	}
}

var Type_Not = "not"

func (op *Not) MarshalJSON() (ret []byte, err error) {
	if jsonTest, e := op.MarshalJSONTest(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Not,
			Value: map[string]json.RawMessage{
				"$TEST": jsonTest,
			},
		})
	}
	return
}

func (op *Not) MarshalJSONTest() (ret []byte, err error) {
	if v, e := op.Test.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

// NumValue Specify a particular number.
type NumValue struct {
	Num float64 `if:"label=_,type=number"`
}

func (*NumValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NumValue,
		Uses: "flow",
		Lede: "num",
	}
}

var Type_NumValue = "num_value"

func (op *NumValue) MarshalJSON() (ret []byte, err error) {
	if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_NumValue,
			Value: map[string]json.RawMessage{
				"$NUM": jsonNum,
			},
		})
	}
	return
}

func (op *NumValue) MarshalJSONNum() (ret []byte, err error) {
	// type override
	m := value.Number{op.Num}
	ret, err = m.MarshalJSON()
	return
}

// Numbers Number List: Specify a list of numbers.
type Numbers struct {
	Values []float64 `if:"label=_,type=number"`
}

func (*Numbers) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Numbers,
		Uses: "flow",
		Lede: "nums",
	}
}

var Type_Numbers = "numbers"

func (op *Numbers) MarshalJSON() (ret []byte, err error) {
	if jsonValues, e := op.MarshalJSONValues(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Numbers,
			Value: map[string]json.RawMessage{
				"$VALUES": jsonValues,
			},
		})
	}
	return
}

func (op *Numbers) MarshalJSONValues() (ret []byte, err error) {
	ret, err = json.Marshal(op.Values)
	return
}

// ObjectExists Returns whether there is a object of the specified name.
type ObjectExists struct {
	Object rt.TextEval `if:"label=valid"`
}

func (*ObjectExists) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ObjectExists,
		Uses: "flow",
		Lede: "is",
	}
}

var Type_ObjectExists = "object_exists"

func (op *ObjectExists) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ObjectExists,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *ObjectExists) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// Pluralize Returns the plural form of a singular word. (ex. apples for apple. )
type Pluralize struct {
	Text rt.TextEval `if:"label=of"`
}

func (*Pluralize) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Pluralize,
		Uses: "flow",
		Lede: "plural",
	}
}

var Type_Pluralize = "pluralize"

func (op *Pluralize) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Pluralize,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *Pluralize) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// PrintNum Writes a number using numerals, eg. &#x27;1&#x27;.
type PrintNum struct {
	Num rt.NumberEval `if:"label=_"`
}

func (*PrintNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PrintNum,
		Uses: "flow",
		Lede: "numeral",
	}
}

var Type_PrintNum = "print_num"

func (op *PrintNum) MarshalJSON() (ret []byte, err error) {
	if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PrintNum,
			Value: map[string]json.RawMessage{
				"$NUM": jsonNum,
			},
		})
	}
	return
}

func (op *PrintNum) MarshalJSONNum() (ret []byte, err error) {
	if v, e := op.Num.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// PrintNumWord Writes a number in plain english: eg. &#x27;one&#x27;
type PrintNumWord struct {
	Num rt.NumberEval `if:"label=words"`
}

func (*PrintNumWord) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PrintNumWord,
		Uses: "flow",
		Lede: "numeral",
	}
}

var Type_PrintNumWord = "print_num_word"

func (op *PrintNumWord) MarshalJSON() (ret []byte, err error) {
	if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PrintNumWord,
			Value: map[string]json.RawMessage{
				"$NUM": jsonNum,
			},
		})
	}
	return
}

func (op *PrintNumWord) MarshalJSONNum() (ret []byte, err error) {
	if v, e := op.Num.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// ProductOf Multiply two numbers.
type ProductOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*ProductOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ProductOf,
		Uses: "flow",
		Lede: "mul",
	}
}

var Type_ProductOf = "product_of"

func (op *ProductOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ProductOf,
			Value: map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *ProductOf) MarshalJSONA() (ret []byte, err error) {
	if v, e := op.A.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *ProductOf) MarshalJSONB() (ret []byte, err error) {
	if v, e := op.B.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// PutAtField Put a value into the field of an record or object
type PutAtField struct {
	Into    IntoTargetFields `if:"label=_"`
	From    rt.Assignment    `if:"label=from"`
	AtField string           `if:"label=at,type=text"`
}

func (*PutAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PutAtField,
		Uses: "flow",
		Lede: "put",
	}
}

var Type_PutAtField = "put_at_field"

func (op *PutAtField) MarshalJSON() (ret []byte, err error) {
	if jsonInto, e := op.MarshalJSONInto(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonAtField, e := op.MarshalJSONAtField(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PutAtField,
			Value: map[string]json.RawMessage{
				"$INTO":     jsonInto,
				"$FROM":     jsonFrom,
				"$AT_FIELD": jsonAtField,
			},
		})
	}
	return
}

func (op *PutAtField) MarshalJSONInto() (ret []byte, err error) {
	if v, e := op.Into.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_IntoTargetFields,
			Value: v,
		})
	}
	return
}

func (op *PutAtField) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *PutAtField) MarshalJSONAtField() (ret []byte, err error) {
	// type override
	m := value.Text{op.AtField}
	ret, err = m.MarshalJSON()
	return
}

// QuotientOf Divide one number by another.
type QuotientOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*QuotientOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_QuotientOf,
		Uses: "flow",
		Lede: "div",
	}
}

var Type_QuotientOf = "quotient_of"

func (op *QuotientOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_QuotientOf,
			Value: map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *QuotientOf) MarshalJSONA() (ret []byte, err error) {
	if v, e := op.A.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *QuotientOf) MarshalJSONB() (ret []byte, err error) {
	if v, e := op.B.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// RemainderOf Divide one number by another, and return the remainder.
type RemainderOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*RemainderOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RemainderOf,
		Uses: "flow",
		Lede: "mod",
	}
}

var Type_RemainderOf = "remainder_of"

func (op *RemainderOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RemainderOf,
			Value: map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *RemainderOf) MarshalJSONA() (ret []byte, err error) {
	if v, e := op.A.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *RemainderOf) MarshalJSONB() (ret []byte, err error) {
	if v, e := op.B.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// Response Generate text in a replaceable manner.
type Response struct {
	Name string      `if:"label=_,type=text"`
	Text rt.TextEval `if:"label=text,optional"`
}

func (*Response) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Response,
		Uses: "flow",
	}
}

var Type_Response = "response"

func (op *Response) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Response,
			Value: map[string]json.RawMessage{
				"$NAME": jsonName,
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *Response) MarshalJSONName() (ret []byte, err error) {
	// type override
	m := value.Text{op.Name}
	ret, err = m.MarshalJSON()
	return
}

func (op *Response) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// Row A single line as part of a group of lines.
type Row struct {
	Do Activity `if:"label=_"`
}

func (*Row) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Row,
		Uses: "flow",
	}
}

var Type_Row = "row"

func (op *Row) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Row,
			Value: map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *Row) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

// Rows Group text into successive lines.
type Rows struct {
	Do Activity `if:"label=_"`
}

func (*Rows) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Rows,
		Uses: "flow",
	}
}

var Type_Rows = "rows"

func (op *Rows) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Rows,
			Value: map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *Rows) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

// SayText Print some bit of text to the player.
type SayText struct {
	Text rt.TextEval `if:"label=_"`
}

func (*SayText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SayText,
		Uses: "flow",
		Lede: "say",
	}
}

var Type_SayText = "say_text"

func (op *SayText) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_SayText,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *SayText) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// SetTrait Put an object into a particular state.
type SetTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

func (*SetTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SetTrait,
		Uses: "flow",
		Lede: "put",
	}
}

var Type_SetTrait = "set_trait"

func (op *SetTrait) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_SetTrait,
			Value: map[string]json.RawMessage{
				"$OBJECT": jsonObject,
				"$TRAIT":  jsonTrait,
			},
		})
	}
	return
}

func (op *SetTrait) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *SetTrait) MarshalJSONTrait() (ret []byte, err error) {
	if v, e := op.Trait.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// Singularize Returns the singular form of a plural word. (ex. apple for apples )
type Singularize struct {
	Text rt.TextEval `if:"label=of"`
}

func (*Singularize) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Singularize,
		Uses: "flow",
		Lede: "singular",
	}
}

var Type_Singularize = "singularize"

func (op *Singularize) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Singularize,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *Singularize) MarshalJSONText() (ret []byte, err error) {
	if v, e := op.Text.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// SlashText Separates words with left-leaning slashes &#x27;/&#x27;.
type SlashText struct {
	Do Activity `if:"label=_"`
}

func (*SlashText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SlashText,
		Uses: "flow",
		Lede: "slashes",
	}
}

var Type_SlashText = "slash_text"

func (op *SlashText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_SlashText,
			Value: map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *SlashText) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

// Softline Start a new line ( if not already at a new line. )
type Softline struct {
}

func (*Softline) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Softline,
		Uses: "flow",
		Lede: "wbr",
	}
}

var Type_Softline = "softline"

func (op *Softline) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Softline,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// SpanText Writes text with spaces between words.
type SpanText struct {
	Do Activity `if:"label=_"`
}

func (*SpanText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SpanText,
		Uses: "flow",
		Lede: "spaces",
	}
}

var Type_SpanText = "span_text"

func (op *SpanText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_SpanText,
			Value: map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *SpanText) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

// SumOf Add two numbers.
type SumOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

func (*SumOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SumOf,
		Uses: "flow",
		Lede: "inc",
	}
}

var Type_SumOf = "sum_of"

func (op *SumOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_SumOf,
			Value: map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *SumOf) MarshalJSONA() (ret []byte, err error) {
	if v, e := op.A.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *SumOf) MarshalJSONB() (ret []byte, err error) {
	if v, e := op.B.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// TextValue Specify a small bit of text.
type TextValue struct {
	Text string `if:"label=_,type=text"`
}

func (*TextValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TextValue,
		Uses: "flow",
		Lede: "txt",
	}
}

var Type_TextValue = "text_value"

func (op *TextValue) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_TextValue,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *TextValue) MarshalJSONText() (ret []byte, err error) {
	// type override
	m := value.Text{op.Text}
	ret, err = m.MarshalJSON()
	return
}

// Texts Text List: Specifies a set of string values.
type Texts struct {
	Values []string `if:"label=_,type=text"`
}

func (*Texts) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Texts,
		Uses: "flow",
		Lede: "txts",
	}
}

var Type_Texts = "texts"

func (op *Texts) MarshalJSON() (ret []byte, err error) {
	if jsonValues, e := op.MarshalJSONValues(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Texts,
			Value: map[string]json.RawMessage{
				"$VALUES": jsonValues,
			},
		})
	}
	return
}

func (op *Texts) MarshalJSONValues() (ret []byte, err error) {
	ret, err = json.Marshal(op.Values)
	return
}

const Type_Trigger = "trigger"

// TriggerCycle
type TriggerCycle struct {
}

func (*TriggerCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TriggerCycle,
		Uses: "flow",
		Lede: "every",
	}
}

var Type_TriggerCycle = "trigger_cycle"

func (op *TriggerCycle) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_TriggerCycle,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// TriggerOnce
type TriggerOnce struct {
}

func (*TriggerOnce) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TriggerOnce,
		Uses: "flow",
		Lede: "at",
	}
}

var Type_TriggerOnce = "trigger_once"

func (op *TriggerOnce) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_TriggerOnce,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// TriggerSwitch
type TriggerSwitch struct {
}

func (*TriggerSwitch) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TriggerSwitch,
		Uses: "flow",
		Lede: "after",
	}
}

var Type_TriggerSwitch = "trigger_switch"

func (op *TriggerSwitch) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_TriggerSwitch,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// Unequal The first value doesn&#x27;t equal the second value.
type Unequal struct {
}

func (*Unequal) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Unequal,
		Uses: "flow",
		Lede: "other_than",
	}
}

var Type_Unequal = "unequal"

func (op *Unequal) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(jsonexp.Flow{
			Type:  Type_Unequal,
			Value: map[string]json.RawMessage{},
		})
	}
	return
}

// While Keep running a series of actions while a condition is true.
type While struct {
	True rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
}

func (*While) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_While,
		Uses: "flow",
		Lede: "repeating",
	}
}

var Type_While = "while"

func (op *While) MarshalJSON() (ret []byte, err error) {
	if jsonTrue, e := op.MarshalJSONTrue(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_While,
			Value: map[string]json.RawMessage{
				"$TRUE": jsonTrue,
				"$DO":   jsonDo,
			},
		})
	}
	return
}

func (op *While) MarshalJSONTrue() (ret []byte, err error) {
	if v, e := op.True.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *While) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

var Slots = []interface{}{
	(*Brancher)(nil),
	(*Comparator)(nil),
	(*FromSourceFields)(nil),
	(*IntoTargetFields)(nil),
	(*Trigger)(nil),
}

var Slats = []composer.Composer{
	(*Activity)(nil),
	(*AllTrue)(nil),
	(*Always)(nil),
	(*AnyTrue)(nil),
	(*Assign)(nil),
	(*AtLeast)(nil),
	(*AtMost)(nil),
	(*Blankline)(nil),
	(*BoolValue)(nil),
	(*BracketText)(nil),
	(*Break)(nil),
	(*BufferText)(nil),
	(*CallArg)(nil),
	(*CallArgs)(nil),
	(*CallCycle)(nil),
	(*CallMake)(nil),
	(*CallPattern)(nil),
	(*CallSend)(nil),
	(*CallShuffle)(nil),
	(*CallTerminal)(nil),
	(*CallTrigger)(nil),
	(*Capitalize)(nil),
	(*ChooseAction)(nil),
	(*ChooseMore)(nil),
	(*ChooseMoreValue)(nil),
	(*ChooseNothingElse)(nil),
	(*ChooseNum)(nil),
	(*ChooseText)(nil),
	(*ChooseValue)(nil),
	(*CommaText)(nil),
	(*CompareNum)(nil),
	(*CompareText)(nil),
	(*DiffOf)(nil),
	(*During)(nil),
	(*Equal)(nil),
	(*FromBool)(nil),
	(*FromNum)(nil),
	(*FromNumbers)(nil),
	(*FromObj)(nil),
	(*FromRec)(nil),
	(*FromRecord)(nil),
	(*FromRecords)(nil),
	(*FromText)(nil),
	(*FromTexts)(nil),
	(*FromVar)(nil),
	(*GetAtField)(nil),
	(*GetVar)(nil),
	(*GreaterThan)(nil),
	(*HasDominion)(nil),
	(*HasTrait)(nil),
	(*IdOf)(nil),
	(*Includes)(nil),
	(*IntoObj)(nil),
	(*IntoVar)(nil),
	(*IsEmpty)(nil),
	(*IsExactKindOf)(nil),
	(*IsKindOf)(nil),
	(*Join)(nil),
	(*KindOf)(nil),
	(*KindsOf)(nil),
	(*LessThan)(nil),
	(*MakeLowercase)(nil),
	(*MakeReversed)(nil),
	(*MakeSentenceCase)(nil),
	(*MakeTitleCase)(nil),
	(*MakeUppercase)(nil),
	(*Matches)(nil),
	(*NameOf)(nil),
	(*Never)(nil),
	(*Newline)(nil),
	(*Next)(nil),
	(*Not)(nil),
	(*NumValue)(nil),
	(*Numbers)(nil),
	(*ObjectExists)(nil),
	(*Pluralize)(nil),
	(*PrintNum)(nil),
	(*PrintNumWord)(nil),
	(*ProductOf)(nil),
	(*PutAtField)(nil),
	(*QuotientOf)(nil),
	(*RemainderOf)(nil),
	(*Response)(nil),
	(*Row)(nil),
	(*Rows)(nil),
	(*SayText)(nil),
	(*SetTrait)(nil),
	(*Singularize)(nil),
	(*SlashText)(nil),
	(*Softline)(nil),
	(*SpanText)(nil),
	(*SumOf)(nil),
	(*TextValue)(nil),
	(*Texts)(nil),
	(*TriggerCycle)(nil),
	(*TriggerOnce)(nil),
	(*TriggerSwitch)(nil),
	(*Unequal)(nil),
	(*While)(nil),
}
