// Code generated by "makeops"; edit at your own risk.
package core

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// Activity
type Activity struct {
	Exe []rt.Execute `if:"label=_"`
}

func (*Activity) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Activity,
		Uses: composer.Type_Flow,
		Lede: "act",
	}
}

const Type_Activity = "activity"
const Activity_Exe = "$EXE"

func (op *Activity) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Activity_Detailed_Marshal(n, op)
}
func (op *Activity) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Activity_Detailed_Unmarshal(n, b, op)
}

func Activity_Detailed_Marshal(n jsonexp.Context, val *Activity) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.Execute_Detailed_Repeats_Marshal(n, &val.Exe); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Activity_Exe] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Activity,
			Fields: fields,
		})
	}
	return
}

func Activity_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Activity) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Activity, e)
	} else if e := rt.Execute_Detailed_Repeats_Unmarshal(n, msg.Fields[Activity_Exe], &out.Exe); e != nil {
		err = errutil.New("unmarshaling", Type_Activity, rt.Type_Execute, e)
	}
	return
}

func Activity_Detailed_Optional_Marshal(n jsonexp.Context, val **Activity) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Activity_Detailed_Marshal(n, ptr)
	}
	return
}
func Activity_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Activity) (err error) {
	if len(b) > 0 {
		var el Activity
		if e := Activity_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Activity, e)
		} else {
			*out = &el
		}
	}
	return
}

// AllTrue Returns true if all of the evaluations are true.
type AllTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

func (*AllTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AllTrue,
		Uses: composer.Type_Flow,
		Lede: "all_of",
	}
}

const Type_AllTrue = "all_true"
const AllTrue_Test = "$TEST"

func (op *AllTrue) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AllTrue_Detailed_Marshal(n, op)
}
func (op *AllTrue) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AllTrue_Detailed_Unmarshal(n, b, op)
}

func AllTrue_Detailed_Marshal(n jsonexp.Context, val *AllTrue) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Repeats_Marshal(n, &val.Test); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AllTrue_Test] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AllTrue,
			Fields: fields,
		})
	}
	return
}

func AllTrue_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AllTrue) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_AllTrue, e)
	} else if e := rt.BoolEval_Detailed_Repeats_Unmarshal(n, msg.Fields[AllTrue_Test], &out.Test); e != nil {
		err = errutil.New("unmarshaling", Type_AllTrue, rt.Type_BoolEval, e)
	}
	return
}

func AllTrue_Detailed_Optional_Marshal(n jsonexp.Context, val **AllTrue) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = AllTrue_Detailed_Marshal(n, ptr)
	}
	return
}
func AllTrue_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AllTrue) (err error) {
	if len(b) > 0 {
		var el AllTrue
		if e := AllTrue_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_AllTrue, e)
		} else {
			*out = &el
		}
	}
	return
}

// Always Returns true.
type Always struct {
}

func (*Always) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Always,
		Uses: composer.Type_Flow,
	}
}

const Type_Always = "always"

func (op *Always) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Always_Detailed_Marshal(n, op)
}
func (op *Always) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Always_Detailed_Unmarshal(n, b, op)
}

func Always_Detailed_Marshal(n jsonexp.Context, val *Always) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Always,
			Fields: fields,
		})
	}
	return
}

func Always_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Always) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Always, e)
	}
	return
}

func Always_Detailed_Optional_Marshal(n jsonexp.Context, val **Always) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Always_Detailed_Marshal(n, ptr)
	}
	return
}
func Always_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Always) (err error) {
	if len(b) > 0 {
		var el Always
		if e := Always_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Always, e)
		} else {
			*out = &el
		}
	}
	return
}

// AnyTrue Returns true if any of the evaluations are true.
type AnyTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

func (*AnyTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AnyTrue,
		Uses: composer.Type_Flow,
		Lede: "any_of",
	}
}

const Type_AnyTrue = "any_true"
const AnyTrue_Test = "$TEST"

func (op *AnyTrue) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AnyTrue_Detailed_Marshal(n, op)
}
func (op *AnyTrue) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AnyTrue_Detailed_Unmarshal(n, b, op)
}

func AnyTrue_Detailed_Marshal(n jsonexp.Context, val *AnyTrue) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Repeats_Marshal(n, &val.Test); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AnyTrue_Test] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AnyTrue,
			Fields: fields,
		})
	}
	return
}

func AnyTrue_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AnyTrue) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_AnyTrue, e)
	} else if e := rt.BoolEval_Detailed_Repeats_Unmarshal(n, msg.Fields[AnyTrue_Test], &out.Test); e != nil {
		err = errutil.New("unmarshaling", Type_AnyTrue, rt.Type_BoolEval, e)
	}
	return
}

func AnyTrue_Detailed_Optional_Marshal(n jsonexp.Context, val **AnyTrue) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = AnyTrue_Detailed_Marshal(n, ptr)
	}
	return
}
func AnyTrue_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AnyTrue) (err error) {
	if len(b) > 0 {
		var el AnyTrue
		if e := AnyTrue_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_AnyTrue, e)
		} else {
			*out = &el
		}
	}
	return
}

// Assign Assigns a variable to a value.
type Assign struct {
	Var  value.VariableName `if:"label=_"`
	From rt.Assignment      `if:"label=be"`
}

func (*Assign) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Assign,
		Uses: composer.Type_Flow,
		Lede: "let",
	}
}

const Type_Assign = "assign"
const Assign_Var = "$VAR"
const Assign_From = "$FROM"

func (op *Assign) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Assign_Detailed_Marshal(n, op)
}
func (op *Assign) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Assign_Detailed_Unmarshal(n, b, op)
}

func Assign_Detailed_Marshal(n jsonexp.Context, val *Assign) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Assign_Var] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Assign_From] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Assign,
			Fields: fields,
		})
	}
	return
}

func Assign_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Assign) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Assign, e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[Assign_Var], &out.Var); e != nil {
		err = errutil.New("unmarshaling", Type_Assign, value.Type_VariableName, e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[Assign_From], &out.From); e != nil {
		err = errutil.New("unmarshaling", Type_Assign, rt.Type_Assignment, e)
	}
	return
}

func Assign_Detailed_Optional_Marshal(n jsonexp.Context, val **Assign) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Assign_Detailed_Marshal(n, ptr)
	}
	return
}
func Assign_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Assign) (err error) {
	if len(b) > 0 {
		var el Assign
		if e := Assign_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Assign, e)
		} else {
			*out = &el
		}
	}
	return
}

// AtLeast The first value is greater than or equal to the second value.
type AtLeast struct {
}

func (*AtLeast) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AtLeast,
		Uses: composer.Type_Flow,
	}
}

const Type_AtLeast = "at_least"

func (op *AtLeast) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AtLeast_Detailed_Marshal(n, op)
}
func (op *AtLeast) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AtLeast_Detailed_Unmarshal(n, b, op)
}

func AtLeast_Detailed_Marshal(n jsonexp.Context, val *AtLeast) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AtLeast,
			Fields: fields,
		})
	}
	return
}

func AtLeast_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AtLeast) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_AtLeast, e)
	}
	return
}

func AtLeast_Detailed_Optional_Marshal(n jsonexp.Context, val **AtLeast) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = AtLeast_Detailed_Marshal(n, ptr)
	}
	return
}
func AtLeast_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AtLeast) (err error) {
	if len(b) > 0 {
		var el AtLeast
		if e := AtLeast_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_AtLeast, e)
		} else {
			*out = &el
		}
	}
	return
}

// AtMost The first value is less than or equal to the second value.
type AtMost struct {
}

func (*AtMost) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AtMost,
		Uses: composer.Type_Flow,
	}
}

const Type_AtMost = "at_most"

func (op *AtMost) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AtMost_Detailed_Marshal(n, op)
}
func (op *AtMost) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AtMost_Detailed_Unmarshal(n, b, op)
}

func AtMost_Detailed_Marshal(n jsonexp.Context, val *AtMost) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AtMost,
			Fields: fields,
		})
	}
	return
}

func AtMost_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AtMost) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_AtMost, e)
	}
	return
}

func AtMost_Detailed_Optional_Marshal(n jsonexp.Context, val **AtMost) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = AtMost_Detailed_Marshal(n, ptr)
	}
	return
}
func AtMost_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AtMost) (err error) {
	if len(b) > 0 {
		var el AtMost
		if e := AtMost_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_AtMost, e)
		} else {
			*out = &el
		}
	}
	return
}

// Blankline Add a single blank line following some text.
type Blankline struct {
}

func (*Blankline) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Blankline,
		Uses: composer.Type_Flow,
		Lede: "p",
	}
}

const Type_Blankline = "blankline"

func (op *Blankline) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Blankline_Detailed_Marshal(n, op)
}
func (op *Blankline) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Blankline_Detailed_Unmarshal(n, b, op)
}

func Blankline_Detailed_Marshal(n jsonexp.Context, val *Blankline) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Blankline,
			Fields: fields,
		})
	}
	return
}

func Blankline_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Blankline) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Blankline, e)
	}
	return
}

func Blankline_Detailed_Optional_Marshal(n jsonexp.Context, val **Blankline) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Blankline_Detailed_Marshal(n, ptr)
	}
	return
}
func Blankline_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Blankline) (err error) {
	if len(b) > 0 {
		var el Blankline
		if e := Blankline_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Blankline, e)
		} else {
			*out = &el
		}
	}
	return
}

// BoolValue Specify an explicit true or false value.
type BoolValue struct {
	Bool bool `if:"label=_,type=bool"`
}

func (*BoolValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BoolValue,
		Uses: composer.Type_Flow,
		Lede: "bool",
	}
}

const Type_BoolValue = "bool_value"
const BoolValue_Bool = "$BOOL"

func (op *BoolValue) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return BoolValue_Detailed_Marshal(n, op)
}
func (op *BoolValue) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return BoolValue_Detailed_Unmarshal(n, b, op)
}

func BoolValue_Detailed_Marshal(n jsonexp.Context, val *BoolValue) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Bool_Detailed_Override_Marshal(n, &val.Bool); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[BoolValue_Bool] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_BoolValue,
			Fields: fields,
		})
	}
	return
}

func BoolValue_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *BoolValue) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_BoolValue, e)
	} else if e := value.Bool_Detailed_Override_Unmarshal(n, msg.Fields[BoolValue_Bool], &out.Bool); e != nil {
		err = errutil.New("unmarshaling", Type_BoolValue, value.Type_Bool, e)
	}
	return
}

func BoolValue_Detailed_Optional_Marshal(n jsonexp.Context, val **BoolValue) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = BoolValue_Detailed_Marshal(n, ptr)
	}
	return
}
func BoolValue_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **BoolValue) (err error) {
	if len(b) > 0 {
		var el BoolValue
		if e := BoolValue_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_BoolValue, e)
		} else {
			*out = &el
		}
	}
	return
}

// BracketText Sandwiches text printed during a block and puts them inside parenthesis &#x27;()&#x27;.
type BracketText struct {
	Do Activity `if:"label=_"`
}

func (*BracketText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BracketText,
		Uses: composer.Type_Flow,
		Lede: "brackets",
	}
}

const Type_BracketText = "bracket_text"
const BracketText_Do = "$DO"

func (op *BracketText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return BracketText_Detailed_Marshal(n, op)
}
func (op *BracketText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return BracketText_Detailed_Unmarshal(n, b, op)
}

func BracketText_Detailed_Marshal(n jsonexp.Context, val *BracketText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[BracketText_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_BracketText,
			Fields: fields,
		})
	}
	return
}

func BracketText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *BracketText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_BracketText, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[BracketText_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_BracketText, Type_Activity, e)
	}
	return
}

func BracketText_Detailed_Optional_Marshal(n jsonexp.Context, val **BracketText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = BracketText_Detailed_Marshal(n, ptr)
	}
	return
}
func BracketText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **BracketText) (err error) {
	if len(b) > 0 {
		var el BracketText
		if e := BracketText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_BracketText, e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_Brancher = "brancher"

func Brancher_Detailed_Marshal(n jsonexp.Context, ptr *Brancher) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Brancher,
			Value: b,
		})
	}
	return
}

func Brancher_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Brancher) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Brancher, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_Brancher, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_Brancher, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_Brancher, e)
		} else {
			(*out) = ptr.(Brancher)
		}
	}
	return
}

// Break In a repeating loop, exit the loop.
type Break struct {
}

func (*Break) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Break,
		Uses: composer.Type_Flow,
	}
}

const Type_Break = "break"

func (op *Break) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Break_Detailed_Marshal(n, op)
}
func (op *Break) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Break_Detailed_Unmarshal(n, b, op)
}

func Break_Detailed_Marshal(n jsonexp.Context, val *Break) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Break,
			Fields: fields,
		})
	}
	return
}

func Break_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Break) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Break, e)
	}
	return
}

func Break_Detailed_Optional_Marshal(n jsonexp.Context, val **Break) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Break_Detailed_Marshal(n, ptr)
	}
	return
}
func Break_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Break) (err error) {
	if len(b) > 0 {
		var el Break
		if e := Break_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Break, e)
		} else {
			*out = &el
		}
	}
	return
}

// BufferText
type BufferText struct {
	Do Activity `if:"label=_"`
}

func (*BufferText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BufferText,
		Uses: composer.Type_Flow,
		Lede: "buffers",
	}
}

const Type_BufferText = "buffer_text"
const BufferText_Do = "$DO"

func (op *BufferText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return BufferText_Detailed_Marshal(n, op)
}
func (op *BufferText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return BufferText_Detailed_Unmarshal(n, b, op)
}

func BufferText_Detailed_Marshal(n jsonexp.Context, val *BufferText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[BufferText_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_BufferText,
			Fields: fields,
		})
	}
	return
}

func BufferText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *BufferText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_BufferText, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[BufferText_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_BufferText, Type_Activity, e)
	}
	return
}

func BufferText_Detailed_Optional_Marshal(n jsonexp.Context, val **BufferText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = BufferText_Detailed_Marshal(n, ptr)
	}
	return
}
func BufferText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **BufferText) (err error) {
	if len(b) > 0 {
		var el BufferText
		if e := BufferText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_BufferText, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallArg Runtime version of argument
type CallArg struct {
	Name string        `if:"label=_,type=text"`
	From rt.Assignment `if:"label=from"`
}

func (*CallArg) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallArg,
		Uses: composer.Type_Flow,
		Lede: "inarg",
	}
}

const Type_CallArg = "call_arg"
const CallArg_Name = "$NAME"
const CallArg_From = "$FROM"

func (op *CallArg) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallArg_Detailed_Marshal(n, op)
}
func (op *CallArg) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallArg_Detailed_Unmarshal(n, b, op)
}

func CallArg_Detailed_Marshal(n jsonexp.Context, val *CallArg) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallArg_Name] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallArg_From] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_CallArg,
			Fields: fields,
		})
	}
	return
}

func CallArg_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallArg) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallArg, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[CallArg_Name], &out.Name); e != nil {
		err = errutil.New("unmarshaling", Type_CallArg, value.Type_Text, e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[CallArg_From], &out.From); e != nil {
		err = errutil.New("unmarshaling", Type_CallArg, rt.Type_Assignment, e)
	}
	return
}

func CallArg_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]CallArg) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := CallArg_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New("marshaling", Type_CallArg, "at", i, e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func CallArg_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]CallArg) (err error) {
	var msgs []json.RawMessage
	if e := json.Unmarshal(b, &msgs); e != nil {
		err = errutil.New("unmarshaling", Type_CallArg, e)
	} else {
		vals := make([]CallArg, len(msgs))
		for i, msg := range msgs {
			if e := CallArg_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
				err = errutil.New("unmarshaling", Type_CallArg, "at", i, e)
				break
			}
		}
		if err == nil {
			*out = vals
		}
	}
	return
}

func CallArg_Detailed_Optional_Marshal(n jsonexp.Context, val **CallArg) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallArg_Detailed_Marshal(n, ptr)
	}
	return
}
func CallArg_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallArg) (err error) {
	if len(b) > 0 {
		var el CallArg
		if e := CallArg_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallArg, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallArgs Runtime version of arguments
type CallArgs struct {
	Args []CallArg `if:"label=_"`
}

func (*CallArgs) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallArgs,
		Uses: composer.Type_Flow,
		Lede: "inargs",
	}
}

const Type_CallArgs = "call_args"
const CallArgs_Args = "$ARGS"

func (op *CallArgs) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallArgs_Detailed_Marshal(n, op)
}
func (op *CallArgs) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallArgs_Detailed_Unmarshal(n, b, op)
}

func CallArgs_Detailed_Marshal(n jsonexp.Context, val *CallArgs) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := CallArg_Detailed_Repeats_Marshal(n, &val.Args); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallArgs_Args] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_CallArgs,
			Fields: fields,
		})
	}
	return
}

func CallArgs_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallArgs) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallArgs, e)
	} else if e := CallArg_Detailed_Repeats_Unmarshal(n, msg.Fields[CallArgs_Args], &out.Args); e != nil {
		err = errutil.New("unmarshaling", Type_CallArgs, Type_CallArg, e)
	}
	return
}

func CallArgs_Detailed_Optional_Marshal(n jsonexp.Context, val **CallArgs) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallArgs_Detailed_Marshal(n, ptr)
	}
	return
}
func CallArgs_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallArgs) (err error) {
	if len(b) > 0 {
		var el CallArgs
		if e := CallArgs_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallArgs, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallCycle Runtime version of cycle_text
type CallCycle struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CallCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallCycle,
		Uses: composer.Type_Flow,
		Lede: "cycle",
	}
}

const Type_CallCycle = "call_cycle"
const CallCycle_Parts = "$PARTS"

func (op *CallCycle) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallCycle_Detailed_Marshal(n, op)
}
func (op *CallCycle) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallCycle_Detailed_Unmarshal(n, b, op)
}

func CallCycle_Detailed_Marshal(n jsonexp.Context, val *CallCycle) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Repeats_Marshal(n, &val.Parts); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallCycle_Parts] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_CallCycle,
			Fields: fields,
		})
	}
	return
}

func CallCycle_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallCycle) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallCycle, e)
	} else if e := rt.TextEval_Detailed_Repeats_Unmarshal(n, msg.Fields[CallCycle_Parts], &out.Parts); e != nil {
		err = errutil.New("unmarshaling", Type_CallCycle, rt.Type_TextEval, e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func CallCycle_Detailed_Optional_Marshal(n jsonexp.Context, val **CallCycle) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallCycle_Detailed_Marshal(n, ptr)
	}
	return
}
func CallCycle_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallCycle) (err error) {
	if len(b) > 0 {
		var el CallCycle
		if e := CallCycle_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallCycle, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallMake Runtime version of make
type CallMake struct {
	Kind      string   `if:"label=_,type=text"`
	Arguments CallArgs `if:"label=args"`
}

func (*CallMake) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallMake,
		Uses: composer.Type_Flow,
	}
}

const Type_CallMake = "call_make"
const CallMake_Kind = "$KIND"
const CallMake_Arguments = "$ARGUMENTS"

func (op *CallMake) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallMake_Detailed_Marshal(n, op)
}
func (op *CallMake) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallMake_Detailed_Unmarshal(n, b, op)
}

func CallMake_Detailed_Marshal(n jsonexp.Context, val *CallMake) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallMake_Kind] = b
	}
	if b, e := CallArgs_Detailed_Marshal(n, &val.Arguments); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallMake_Arguments] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_CallMake,
			Fields: fields,
		})
	}
	return
}

func CallMake_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallMake) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallMake, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[CallMake_Kind], &out.Kind); e != nil {
		err = errutil.New("unmarshaling", Type_CallMake, value.Type_Text, e)
	} else if e := CallArgs_Detailed_Unmarshal(n, msg.Fields[CallMake_Arguments], &out.Arguments); e != nil {
		err = errutil.New("unmarshaling", Type_CallMake, Type_CallArgs, e)
	}
	return
}

func CallMake_Detailed_Optional_Marshal(n jsonexp.Context, val **CallMake) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallMake_Detailed_Marshal(n, ptr)
	}
	return
}
func CallMake_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallMake) (err error) {
	if len(b) > 0 {
		var el CallMake
		if e := CallMake_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallMake, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallPattern Runtime version of determine
type CallPattern struct {
	Pattern   value.PatternName `if:"label=_"`
	Arguments CallArgs          `if:"label=args"`
}

func (*CallPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallPattern,
		Uses: composer.Type_Flow,
	}
}

const Type_CallPattern = "call_pattern"
const CallPattern_Pattern = "$PATTERN"
const CallPattern_Arguments = "$ARGUMENTS"

func (op *CallPattern) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallPattern_Detailed_Marshal(n, op)
}
func (op *CallPattern) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallPattern_Detailed_Unmarshal(n, b, op)
}

func CallPattern_Detailed_Marshal(n jsonexp.Context, val *CallPattern) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.PatternName_Detailed_Marshal(n, &val.Pattern); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallPattern_Pattern] = b
	}
	if b, e := CallArgs_Detailed_Marshal(n, &val.Arguments); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallPattern_Arguments] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_CallPattern,
			Fields: fields,
		})
	}
	return
}

func CallPattern_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallPattern) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallPattern, e)
	} else if e := value.PatternName_Detailed_Unmarshal(n, msg.Fields[CallPattern_Pattern], &out.Pattern); e != nil {
		err = errutil.New("unmarshaling", Type_CallPattern, value.Type_PatternName, e)
	} else if e := CallArgs_Detailed_Unmarshal(n, msg.Fields[CallPattern_Arguments], &out.Arguments); e != nil {
		err = errutil.New("unmarshaling", Type_CallPattern, Type_CallArgs, e)
	}
	return
}

func CallPattern_Detailed_Optional_Marshal(n jsonexp.Context, val **CallPattern) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallPattern_Detailed_Marshal(n, ptr)
	}
	return
}
func CallPattern_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallPattern) (err error) {
	if len(b) > 0 {
		var el CallPattern
		if e := CallPattern_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallPattern, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallSend Runtime version of send
type CallSend struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=to"`
	Arguments CallArgs        `if:"label=args"`
}

func (*CallSend) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallSend,
		Uses: composer.Type_Flow,
	}
}

const Type_CallSend = "call_send"
const CallSend_Event = "$EVENT"
const CallSend_Path = "$PATH"
const CallSend_Arguments = "$ARGUMENTS"

func (op *CallSend) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallSend_Detailed_Marshal(n, op)
}
func (op *CallSend) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallSend_Detailed_Unmarshal(n, b, op)
}

func CallSend_Detailed_Marshal(n jsonexp.Context, val *CallSend) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Event); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallSend_Event] = b
	}
	if b, e := rt.TextListEval_Detailed_Marshal(n, &val.Path); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallSend_Path] = b
	}
	if b, e := CallArgs_Detailed_Marshal(n, &val.Arguments); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallSend_Arguments] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_CallSend,
			Fields: fields,
		})
	}
	return
}

func CallSend_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallSend) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallSend, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[CallSend_Event], &out.Event); e != nil {
		err = errutil.New("unmarshaling", Type_CallSend, value.Type_Text, e)
	} else if e := rt.TextListEval_Detailed_Unmarshal(n, msg.Fields[CallSend_Path], &out.Path); e != nil {
		err = errutil.New("unmarshaling", Type_CallSend, rt.Type_TextListEval, e)
	} else if e := CallArgs_Detailed_Unmarshal(n, msg.Fields[CallSend_Arguments], &out.Arguments); e != nil {
		err = errutil.New("unmarshaling", Type_CallSend, Type_CallArgs, e)
	}
	return
}

func CallSend_Detailed_Optional_Marshal(n jsonexp.Context, val **CallSend) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallSend_Detailed_Marshal(n, ptr)
	}
	return
}
func CallSend_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallSend) (err error) {
	if len(b) > 0 {
		var el CallSend
		if e := CallSend_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallSend, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallShuffle Runtime version of shuffle_text
type CallShuffle struct {
	At      reader.Position `if:"internal"`
	Parts   []rt.TextEval   `if:"label=_"`
	Indices Shuffler        `if:"internal"`
}

func (*CallShuffle) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallShuffle,
		Uses: composer.Type_Flow,
		Lede: "shuffle",
	}
}

const Type_CallShuffle = "call_shuffle"
const CallShuffle_Parts = "$PARTS"

func (op *CallShuffle) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallShuffle_Detailed_Marshal(n, op)
}
func (op *CallShuffle) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallShuffle_Detailed_Unmarshal(n, b, op)
}

func CallShuffle_Detailed_Marshal(n jsonexp.Context, val *CallShuffle) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Repeats_Marshal(n, &val.Parts); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallShuffle_Parts] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_CallShuffle,
			Fields: fields,
		})
	}
	return
}

func CallShuffle_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallShuffle) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallShuffle, e)
	} else if e := rt.TextEval_Detailed_Repeats_Unmarshal(n, msg.Fields[CallShuffle_Parts], &out.Parts); e != nil {
		err = errutil.New("unmarshaling", Type_CallShuffle, rt.Type_TextEval, e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func CallShuffle_Detailed_Optional_Marshal(n jsonexp.Context, val **CallShuffle) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallShuffle_Detailed_Marshal(n, ptr)
	}
	return
}
func CallShuffle_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallShuffle) (err error) {
	if len(b) > 0 {
		var el CallShuffle
		if e := CallShuffle_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallShuffle, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallTerminal Runtime version of stopping_text
type CallTerminal struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CallTerminal) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallTerminal,
		Uses: composer.Type_Flow,
		Lede: "stopping",
	}
}

const Type_CallTerminal = "call_terminal"
const CallTerminal_Parts = "$PARTS"

func (op *CallTerminal) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallTerminal_Detailed_Marshal(n, op)
}
func (op *CallTerminal) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallTerminal_Detailed_Unmarshal(n, b, op)
}

func CallTerminal_Detailed_Marshal(n jsonexp.Context, val *CallTerminal) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Repeats_Marshal(n, &val.Parts); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallTerminal_Parts] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_CallTerminal,
			Fields: fields,
		})
	}
	return
}

func CallTerminal_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallTerminal) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallTerminal, e)
	} else if e := rt.TextEval_Detailed_Repeats_Unmarshal(n, msg.Fields[CallTerminal_Parts], &out.Parts); e != nil {
		err = errutil.New("unmarshaling", Type_CallTerminal, rt.Type_TextEval, e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func CallTerminal_Detailed_Optional_Marshal(n jsonexp.Context, val **CallTerminal) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallTerminal_Detailed_Marshal(n, ptr)
	}
	return
}
func CallTerminal_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallTerminal) (err error) {
	if len(b) > 0 {
		var el CallTerminal
		if e := CallTerminal_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallTerminal, e)
		} else {
			*out = &el
		}
	}
	return
}

// CallTrigger Runtime version of count_of
type CallTrigger struct {
	At      reader.Position `if:"internal"`
	Trigger Trigger         `if:"label=_"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CallTrigger) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CallTrigger,
		Uses: composer.Type_Flow,
		Lede: "trigger",
	}
}

const Type_CallTrigger = "call_trigger"
const CallTrigger_Trigger = "$TRIGGER"
const CallTrigger_Num = "$NUM"

func (op *CallTrigger) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CallTrigger_Detailed_Marshal(n, op)
}
func (op *CallTrigger) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CallTrigger_Detailed_Unmarshal(n, b, op)
}

func CallTrigger_Detailed_Marshal(n jsonexp.Context, val *CallTrigger) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Trigger_Detailed_Marshal(n, &val.Trigger); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallTrigger_Trigger] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Num); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CallTrigger_Num] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_CallTrigger,
			Fields: fields,
		})
	}
	return
}

func CallTrigger_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CallTrigger) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CallTrigger, e)
	} else if e := Trigger_Detailed_Unmarshal(n, msg.Fields[CallTrigger_Trigger], &out.Trigger); e != nil {
		err = errutil.New("unmarshaling", Type_CallTrigger, Type_Trigger, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[CallTrigger_Num], &out.Num); e != nil {
		err = errutil.New("unmarshaling", Type_CallTrigger, rt.Type_NumberEval, e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func CallTrigger_Detailed_Optional_Marshal(n jsonexp.Context, val **CallTrigger) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CallTrigger_Detailed_Marshal(n, ptr)
	}
	return
}
func CallTrigger_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CallTrigger) (err error) {
	if len(b) > 0 {
		var el CallTrigger
		if e := CallTrigger_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CallTrigger, e)
		} else {
			*out = &el
		}
	}
	return
}

// Capitalize Returns new text, with the first letter turned into uppercase.
type Capitalize struct {
	Text rt.TextEval `if:"label=_"`
}

func (*Capitalize) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Capitalize,
		Uses: composer.Type_Flow,
	}
}

const Type_Capitalize = "capitalize"
const Capitalize_Text = "$TEXT"

func (op *Capitalize) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Capitalize_Detailed_Marshal(n, op)
}
func (op *Capitalize) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Capitalize_Detailed_Unmarshal(n, b, op)
}

func Capitalize_Detailed_Marshal(n jsonexp.Context, val *Capitalize) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Capitalize_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Capitalize,
			Fields: fields,
		})
	}
	return
}

func Capitalize_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Capitalize) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Capitalize, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Capitalize_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_Capitalize, rt.Type_TextEval, e)
	}
	return
}

func Capitalize_Detailed_Optional_Marshal(n jsonexp.Context, val **Capitalize) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Capitalize_Detailed_Marshal(n, ptr)
	}
	return
}
func Capitalize_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Capitalize) (err error) {
	if len(b) > 0 {
		var el Capitalize
		if e := Capitalize_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Capitalize, e)
		} else {
			*out = &el
		}
	}
	return
}

// ChooseAction An if statement.
type ChooseAction struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

func (*ChooseAction) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseAction,
		Uses: composer.Type_Flow,
		Lede: "if",
	}
}

const Type_ChooseAction = "choose_action"
const ChooseAction_If = "$IF"
const ChooseAction_Do = "$DO"
const ChooseAction_Else = "$ELSE"

func (op *ChooseAction) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ChooseAction_Detailed_Marshal(n, op)
}
func (op *ChooseAction) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ChooseAction_Detailed_Unmarshal(n, b, op)
}

func ChooseAction_Detailed_Marshal(n jsonexp.Context, val *ChooseAction) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.If); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseAction_If] = b
	}
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseAction_Do] = b
	}
	if b, e := Brancher_Detailed_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseAction_Else] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ChooseAction,
			Fields: fields,
		})
	}
	return
}

func ChooseAction_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ChooseAction) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseAction, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ChooseAction_If], &out.If); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseAction, rt.Type_BoolEval, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[ChooseAction_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseAction, Type_Activity, e)
	} else if e := Brancher_Detailed_Unmarshal(n, msg.Fields[ChooseAction_Else], &out.Else); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseAction, Type_Brancher, e)
	}
	return
}

func ChooseAction_Detailed_Optional_Marshal(n jsonexp.Context, val **ChooseAction) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ChooseAction_Detailed_Marshal(n, ptr)
	}
	return
}
func ChooseAction_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ChooseAction) (err error) {
	if len(b) > 0 {
		var el ChooseAction
		if e := ChooseAction_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ChooseAction, e)
		} else {
			*out = &el
		}
	}
	return
}

// ChooseMore
type ChooseMore struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

func (*ChooseMore) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseMore,
		Uses: composer.Type_Flow,
		Lede: "else_if",
	}
}

const Type_ChooseMore = "choose_more"
const ChooseMore_If = "$IF"
const ChooseMore_Do = "$DO"
const ChooseMore_Else = "$ELSE"

func (op *ChooseMore) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ChooseMore_Detailed_Marshal(n, op)
}
func (op *ChooseMore) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ChooseMore_Detailed_Unmarshal(n, b, op)
}

func ChooseMore_Detailed_Marshal(n jsonexp.Context, val *ChooseMore) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.If); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseMore_If] = b
	}
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseMore_Do] = b
	}
	if b, e := Brancher_Detailed_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseMore_Else] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ChooseMore,
			Fields: fields,
		})
	}
	return
}

func ChooseMore_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ChooseMore) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMore, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ChooseMore_If], &out.If); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMore, rt.Type_BoolEval, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[ChooseMore_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMore, Type_Activity, e)
	} else if e := Brancher_Detailed_Unmarshal(n, msg.Fields[ChooseMore_Else], &out.Else); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMore, Type_Brancher, e)
	}
	return
}

func ChooseMore_Detailed_Optional_Marshal(n jsonexp.Context, val **ChooseMore) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ChooseMore_Detailed_Marshal(n, ptr)
	}
	return
}
func ChooseMore_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ChooseMore) (err error) {
	if len(b) > 0 {
		var el ChooseMore
		if e := ChooseMore_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ChooseMore, e)
		} else {
			*out = &el
		}
	}
	return
}

// ChooseMoreValue
type ChooseMoreValue struct {
	Assign string        `if:"label=_,type=text"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

func (*ChooseMoreValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseMoreValue,
		Uses: composer.Type_Flow,
		Lede: "else_if",
	}
}

const Type_ChooseMoreValue = "choose_more_value"
const ChooseMoreValue_Assign = "$ASSIGN"
const ChooseMoreValue_From = "$FROM"
const ChooseMoreValue_Filter = "$FILTER"
const ChooseMoreValue_Do = "$DO"
const ChooseMoreValue_Else = "$ELSE"

func (op *ChooseMoreValue) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ChooseMoreValue_Detailed_Marshal(n, op)
}
func (op *ChooseMoreValue) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ChooseMoreValue_Detailed_Unmarshal(n, b, op)
}

func ChooseMoreValue_Detailed_Marshal(n jsonexp.Context, val *ChooseMoreValue) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Assign); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseMoreValue_Assign] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseMoreValue_From] = b
	}
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.Filter); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseMoreValue_Filter] = b
	}
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseMoreValue_Do] = b
	}
	if b, e := Brancher_Detailed_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseMoreValue_Else] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ChooseMoreValue,
			Fields: fields,
		})
	}
	return
}

func ChooseMoreValue_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ChooseMoreValue) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMoreValue, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ChooseMoreValue_Assign], &out.Assign); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMoreValue, value.Type_Text, e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ChooseMoreValue_From], &out.From); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMoreValue, rt.Type_Assignment, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ChooseMoreValue_Filter], &out.Filter); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMoreValue, rt.Type_BoolEval, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[ChooseMoreValue_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMoreValue, Type_Activity, e)
	} else if e := Brancher_Detailed_Unmarshal(n, msg.Fields[ChooseMoreValue_Else], &out.Else); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseMoreValue, Type_Brancher, e)
	}
	return
}

func ChooseMoreValue_Detailed_Optional_Marshal(n jsonexp.Context, val **ChooseMoreValue) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ChooseMoreValue_Detailed_Marshal(n, ptr)
	}
	return
}
func ChooseMoreValue_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ChooseMoreValue) (err error) {
	if len(b) > 0 {
		var el ChooseMoreValue
		if e := ChooseMoreValue_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ChooseMoreValue, e)
		} else {
			*out = &el
		}
	}
	return
}

// ChooseNothingElse
type ChooseNothingElse struct {
	Do Activity `if:"label=_"`
}

func (*ChooseNothingElse) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseNothingElse,
		Uses: composer.Type_Flow,
		Lede: "else_do",
	}
}

const Type_ChooseNothingElse = "choose_nothing_else"
const ChooseNothingElse_Do = "$DO"

func (op *ChooseNothingElse) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ChooseNothingElse_Detailed_Marshal(n, op)
}
func (op *ChooseNothingElse) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ChooseNothingElse_Detailed_Unmarshal(n, b, op)
}

func ChooseNothingElse_Detailed_Marshal(n jsonexp.Context, val *ChooseNothingElse) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseNothingElse_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ChooseNothingElse,
			Fields: fields,
		})
	}
	return
}

func ChooseNothingElse_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ChooseNothingElse) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseNothingElse, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[ChooseNothingElse_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseNothingElse, Type_Activity, e)
	}
	return
}

func ChooseNothingElse_Detailed_Optional_Marshal(n jsonexp.Context, val **ChooseNothingElse) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ChooseNothingElse_Detailed_Marshal(n, ptr)
	}
	return
}
func ChooseNothingElse_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ChooseNothingElse) (err error) {
	if len(b) > 0 {
		var el ChooseNothingElse
		if e := ChooseNothingElse_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ChooseNothingElse, e)
		} else {
			*out = &el
		}
	}
	return
}

// ChooseNum Pick one of two numbers based on a boolean test.
type ChooseNum struct {
	If    rt.BoolEval   `if:"label=if"`
	True  rt.NumberEval `if:"label=then"`
	False rt.NumberEval `if:"label=else"`
}

func (*ChooseNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseNum,
		Uses: composer.Type_Flow,
		Lede: "num",
	}
}

const Type_ChooseNum = "choose_num"
const ChooseNum_If = "$IF"
const ChooseNum_True = "$TRUE"
const ChooseNum_False = "$FALSE"

func (op *ChooseNum) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ChooseNum_Detailed_Marshal(n, op)
}
func (op *ChooseNum) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ChooseNum_Detailed_Unmarshal(n, b, op)
}

func ChooseNum_Detailed_Marshal(n jsonexp.Context, val *ChooseNum) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.If); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseNum_If] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.True); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseNum_True] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.False); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseNum_False] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ChooseNum,
			Fields: fields,
		})
	}
	return
}

func ChooseNum_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ChooseNum) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseNum, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ChooseNum_If], &out.If); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseNum, rt.Type_BoolEval, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ChooseNum_True], &out.True); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseNum, rt.Type_NumberEval, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ChooseNum_False], &out.False); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseNum, rt.Type_NumberEval, e)
	}
	return
}

func ChooseNum_Detailed_Optional_Marshal(n jsonexp.Context, val **ChooseNum) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ChooseNum_Detailed_Marshal(n, ptr)
	}
	return
}
func ChooseNum_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ChooseNum) (err error) {
	if len(b) > 0 {
		var el ChooseNum
		if e := ChooseNum_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ChooseNum, e)
		} else {
			*out = &el
		}
	}
	return
}

// ChooseText Pick one of two strings based on a boolean test.
type ChooseText struct {
	If    rt.BoolEval `if:"label=if"`
	True  rt.TextEval `if:"label=then"`
	False rt.TextEval `if:"label=else"`
}

func (*ChooseText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseText,
		Uses: composer.Type_Flow,
		Lede: "txt",
	}
}

const Type_ChooseText = "choose_text"
const ChooseText_If = "$IF"
const ChooseText_True = "$TRUE"
const ChooseText_False = "$FALSE"

func (op *ChooseText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ChooseText_Detailed_Marshal(n, op)
}
func (op *ChooseText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ChooseText_Detailed_Unmarshal(n, b, op)
}

func ChooseText_Detailed_Marshal(n jsonexp.Context, val *ChooseText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.If); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseText_If] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.True); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseText_True] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.False); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseText_False] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ChooseText,
			Fields: fields,
		})
	}
	return
}

func ChooseText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ChooseText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseText, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ChooseText_If], &out.If); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseText, rt.Type_BoolEval, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[ChooseText_True], &out.True); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseText, rt.Type_TextEval, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[ChooseText_False], &out.False); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseText, rt.Type_TextEval, e)
	}
	return
}

func ChooseText_Detailed_Optional_Marshal(n jsonexp.Context, val **ChooseText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ChooseText_Detailed_Marshal(n, ptr)
	}
	return
}
func ChooseText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ChooseText) (err error) {
	if len(b) > 0 {
		var el ChooseText
		if e := ChooseText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ChooseText, e)
		} else {
			*out = &el
		}
	}
	return
}

// ChooseValue An if statement with local assignment.
type ChooseValue struct {
	Assign string        `if:"label=_,type=text"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

func (*ChooseValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ChooseValue,
		Uses: composer.Type_Flow,
		Lede: "if",
	}
}

const Type_ChooseValue = "choose_value"
const ChooseValue_Assign = "$ASSIGN"
const ChooseValue_From = "$FROM"
const ChooseValue_Filter = "$FILTER"
const ChooseValue_Do = "$DO"
const ChooseValue_Else = "$ELSE"

func (op *ChooseValue) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ChooseValue_Detailed_Marshal(n, op)
}
func (op *ChooseValue) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ChooseValue_Detailed_Unmarshal(n, b, op)
}

func ChooseValue_Detailed_Marshal(n jsonexp.Context, val *ChooseValue) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Assign); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseValue_Assign] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseValue_From] = b
	}
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.Filter); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseValue_Filter] = b
	}
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseValue_Do] = b
	}
	if b, e := Brancher_Detailed_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ChooseValue_Else] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ChooseValue,
			Fields: fields,
		})
	}
	return
}

func ChooseValue_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ChooseValue) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseValue, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ChooseValue_Assign], &out.Assign); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseValue, value.Type_Text, e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ChooseValue_From], &out.From); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseValue, rt.Type_Assignment, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ChooseValue_Filter], &out.Filter); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseValue, rt.Type_BoolEval, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[ChooseValue_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseValue, Type_Activity, e)
	} else if e := Brancher_Detailed_Unmarshal(n, msg.Fields[ChooseValue_Else], &out.Else); e != nil {
		err = errutil.New("unmarshaling", Type_ChooseValue, Type_Brancher, e)
	}
	return
}

func ChooseValue_Detailed_Optional_Marshal(n jsonexp.Context, val **ChooseValue) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ChooseValue_Detailed_Marshal(n, ptr)
	}
	return
}
func ChooseValue_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ChooseValue) (err error) {
	if len(b) > 0 {
		var el ChooseValue
		if e := ChooseValue_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ChooseValue, e)
		} else {
			*out = &el
		}
	}
	return
}

// CommaText Separates words with commas, and &#x27;and&#x27;.
type CommaText struct {
	Do Activity `if:"label=_"`
}

func (*CommaText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CommaText,
		Uses: composer.Type_Flow,
		Lede: "commas",
	}
}

const Type_CommaText = "comma_text"
const CommaText_Do = "$DO"

func (op *CommaText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CommaText_Detailed_Marshal(n, op)
}
func (op *CommaText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CommaText_Detailed_Unmarshal(n, b, op)
}

func CommaText_Detailed_Marshal(n jsonexp.Context, val *CommaText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CommaText_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_CommaText,
			Fields: fields,
		})
	}
	return
}

func CommaText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CommaText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CommaText, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[CommaText_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_CommaText, Type_Activity, e)
	}
	return
}

func CommaText_Detailed_Optional_Marshal(n jsonexp.Context, val **CommaText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CommaText_Detailed_Marshal(n, ptr)
	}
	return
}
func CommaText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CommaText) (err error) {
	if len(b) > 0 {
		var el CommaText
		if e := CommaText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CommaText, e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_Comparator = "comparator"

func Comparator_Detailed_Marshal(n jsonexp.Context, ptr *Comparator) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Comparator,
			Value: b,
		})
	}
	return
}

func Comparator_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Comparator) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Comparator, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_Comparator, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_Comparator, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_Comparator, e)
		} else {
			(*out) = ptr.(Comparator)
		}
	}
	return
}

// CompareNum True if eq,ne,gt,lt,ge,le two numbers.
type CompareNum struct {
	A  rt.NumberEval `if:"label=_"`
	Is Comparator    `if:"label=is"`
	B  rt.NumberEval `if:"label=num"`
}

func (*CompareNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CompareNum,
		Uses: composer.Type_Flow,
		Lede: "cmp",
	}
}

const Type_CompareNum = "compare_num"
const CompareNum_A = "$A"
const CompareNum_Is = "$IS"
const CompareNum_B = "$B"

func (op *CompareNum) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CompareNum_Detailed_Marshal(n, op)
}
func (op *CompareNum) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CompareNum_Detailed_Unmarshal(n, b, op)
}

func CompareNum_Detailed_Marshal(n jsonexp.Context, val *CompareNum) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.A); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CompareNum_A] = b
	}
	if b, e := Comparator_Detailed_Marshal(n, &val.Is); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CompareNum_Is] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.B); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CompareNum_B] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_CompareNum,
			Fields: fields,
		})
	}
	return
}

func CompareNum_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CompareNum) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CompareNum, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[CompareNum_A], &out.A); e != nil {
		err = errutil.New("unmarshaling", Type_CompareNum, rt.Type_NumberEval, e)
	} else if e := Comparator_Detailed_Unmarshal(n, msg.Fields[CompareNum_Is], &out.Is); e != nil {
		err = errutil.New("unmarshaling", Type_CompareNum, Type_Comparator, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[CompareNum_B], &out.B); e != nil {
		err = errutil.New("unmarshaling", Type_CompareNum, rt.Type_NumberEval, e)
	}
	return
}

func CompareNum_Detailed_Optional_Marshal(n jsonexp.Context, val **CompareNum) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CompareNum_Detailed_Marshal(n, ptr)
	}
	return
}
func CompareNum_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CompareNum) (err error) {
	if len(b) > 0 {
		var el CompareNum
		if e := CompareNum_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CompareNum, e)
		} else {
			*out = &el
		}
	}
	return
}

// CompareText True if eq,ne,gt,lt,ge,le two strings ( lexical. )
type CompareText struct {
	A  rt.TextEval `if:"label=_"`
	Is Comparator  `if:"label=is"`
	B  rt.TextEval `if:"label=txt"`
}

func (*CompareText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CompareText,
		Uses: composer.Type_Flow,
		Lede: "cmp",
	}
}

const Type_CompareText = "compare_text"
const CompareText_A = "$A"
const CompareText_Is = "$IS"
const CompareText_B = "$B"

func (op *CompareText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CompareText_Detailed_Marshal(n, op)
}
func (op *CompareText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CompareText_Detailed_Unmarshal(n, b, op)
}

func CompareText_Detailed_Marshal(n jsonexp.Context, val *CompareText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.A); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CompareText_A] = b
	}
	if b, e := Comparator_Detailed_Marshal(n, &val.Is); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CompareText_Is] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.B); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CompareText_B] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_CompareText,
			Fields: fields,
		})
	}
	return
}

func CompareText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CompareText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_CompareText, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[CompareText_A], &out.A); e != nil {
		err = errutil.New("unmarshaling", Type_CompareText, rt.Type_TextEval, e)
	} else if e := Comparator_Detailed_Unmarshal(n, msg.Fields[CompareText_Is], &out.Is); e != nil {
		err = errutil.New("unmarshaling", Type_CompareText, Type_Comparator, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[CompareText_B], &out.B); e != nil {
		err = errutil.New("unmarshaling", Type_CompareText, rt.Type_TextEval, e)
	}
	return
}

func CompareText_Detailed_Optional_Marshal(n jsonexp.Context, val **CompareText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CompareText_Detailed_Marshal(n, ptr)
	}
	return
}
func CompareText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CompareText) (err error) {
	if len(b) > 0 {
		var el CompareText
		if e := CompareText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_CompareText, e)
		} else {
			*out = &el
		}
	}
	return
}

// DiffOf Subtract two numbers.
type DiffOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

func (*DiffOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_DiffOf,
		Uses: composer.Type_Flow,
		Lede: "dec",
	}
}

const Type_DiffOf = "diff_of"
const DiffOf_A = "$A"
const DiffOf_B = "$B"

func (op *DiffOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return DiffOf_Detailed_Marshal(n, op)
}
func (op *DiffOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return DiffOf_Detailed_Unmarshal(n, b, op)
}

func DiffOf_Detailed_Marshal(n jsonexp.Context, val *DiffOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.A); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[DiffOf_A] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.B); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[DiffOf_B] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_DiffOf,
			Fields: fields,
		})
	}
	return
}

func DiffOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *DiffOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_DiffOf, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[DiffOf_A], &out.A); e != nil {
		err = errutil.New("unmarshaling", Type_DiffOf, rt.Type_NumberEval, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[DiffOf_B], &out.B); e != nil {
		err = errutil.New("unmarshaling", Type_DiffOf, rt.Type_NumberEval, e)
	}
	return
}

func DiffOf_Detailed_Optional_Marshal(n jsonexp.Context, val **DiffOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = DiffOf_Detailed_Marshal(n, ptr)
	}
	return
}
func DiffOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **DiffOf) (err error) {
	if len(b) > 0 {
		var el DiffOf
		if e := DiffOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_DiffOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// During Decide whether a pattern is running.
type During struct {
	Pattern value.PatternName `if:"label=_"`
}

func (*During) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_During,
		Uses: composer.Type_Flow,
	}
}

const Type_During = "during"
const During_Pattern = "$PATTERN"

func (op *During) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return During_Detailed_Marshal(n, op)
}
func (op *During) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return During_Detailed_Unmarshal(n, b, op)
}

func During_Detailed_Marshal(n jsonexp.Context, val *During) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.PatternName_Detailed_Marshal(n, &val.Pattern); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[During_Pattern] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_During,
			Fields: fields,
		})
	}
	return
}

func During_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *During) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_During, e)
	} else if e := value.PatternName_Detailed_Unmarshal(n, msg.Fields[During_Pattern], &out.Pattern); e != nil {
		err = errutil.New("unmarshaling", Type_During, value.Type_PatternName, e)
	}
	return
}

func During_Detailed_Optional_Marshal(n jsonexp.Context, val **During) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = During_Detailed_Marshal(n, ptr)
	}
	return
}
func During_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **During) (err error) {
	if len(b) > 0 {
		var el During
		if e := During_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_During, e)
		} else {
			*out = &el
		}
	}
	return
}

// Equal Two values exactly match.
type Equal struct {
}

func (*Equal) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Equal,
		Uses: composer.Type_Flow,
		Lede: "equals",
	}
}

const Type_Equal = "equal"

func (op *Equal) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Equal_Detailed_Marshal(n, op)
}
func (op *Equal) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Equal_Detailed_Unmarshal(n, b, op)
}

func Equal_Detailed_Marshal(n jsonexp.Context, val *Equal) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Equal,
			Fields: fields,
		})
	}
	return
}

func Equal_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Equal) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Equal, e)
	}
	return
}

func Equal_Detailed_Optional_Marshal(n jsonexp.Context, val **Equal) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Equal_Detailed_Marshal(n, ptr)
	}
	return
}
func Equal_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Equal) (err error) {
	if len(b) > 0 {
		var el Equal
		if e := Equal_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Equal, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromBool Assigns the calculated boolean value.
type FromBool struct {
	Val rt.BoolEval `if:"label=_"`
}

func (*FromBool) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromBool,
		Uses: composer.Type_Flow,
	}
}

const Type_FromBool = "from_bool"
const FromBool_Val = "$VAL"

func (op *FromBool) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromBool_Detailed_Marshal(n, op)
}
func (op *FromBool) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromBool_Detailed_Unmarshal(n, b, op)
}

func FromBool_Detailed_Marshal(n jsonexp.Context, val *FromBool) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.Val); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromBool_Val] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromBool,
			Fields: fields,
		})
	}
	return
}

func FromBool_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromBool) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromBool, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[FromBool_Val], &out.Val); e != nil {
		err = errutil.New("unmarshaling", Type_FromBool, rt.Type_BoolEval, e)
	}
	return
}

func FromBool_Detailed_Optional_Marshal(n jsonexp.Context, val **FromBool) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromBool_Detailed_Marshal(n, ptr)
	}
	return
}
func FromBool_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromBool) (err error) {
	if len(b) > 0 {
		var el FromBool
		if e := FromBool_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromBool, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromNum Assigns the calculated number.
type FromNum struct {
	Val rt.NumberEval `if:"label=_"`
}

func (*FromNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromNum,
		Uses: composer.Type_Flow,
	}
}

const Type_FromNum = "from_num"
const FromNum_Val = "$VAL"

func (op *FromNum) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromNum_Detailed_Marshal(n, op)
}
func (op *FromNum) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromNum_Detailed_Unmarshal(n, b, op)
}

func FromNum_Detailed_Marshal(n jsonexp.Context, val *FromNum) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Val); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromNum_Val] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromNum,
			Fields: fields,
		})
	}
	return
}

func FromNum_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromNum) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromNum, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[FromNum_Val], &out.Val); e != nil {
		err = errutil.New("unmarshaling", Type_FromNum, rt.Type_NumberEval, e)
	}
	return
}

func FromNum_Detailed_Optional_Marshal(n jsonexp.Context, val **FromNum) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromNum_Detailed_Marshal(n, ptr)
	}
	return
}
func FromNum_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromNum) (err error) {
	if len(b) > 0 {
		var el FromNum
		if e := FromNum_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromNum, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromNumbers Assigns the calculated numbers.
type FromNumbers struct {
	Vals rt.NumListEval `if:"label=_"`
}

func (*FromNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromNumbers,
		Uses: composer.Type_Flow,
		Lede: "from_nums",
	}
}

const Type_FromNumbers = "from_numbers"
const FromNumbers_Vals = "$VALS"

func (op *FromNumbers) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromNumbers_Detailed_Marshal(n, op)
}
func (op *FromNumbers) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromNumbers_Detailed_Unmarshal(n, b, op)
}

func FromNumbers_Detailed_Marshal(n jsonexp.Context, val *FromNumbers) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumListEval_Detailed_Marshal(n, &val.Vals); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromNumbers_Vals] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromNumbers,
			Fields: fields,
		})
	}
	return
}

func FromNumbers_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromNumbers) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromNumbers, e)
	} else if e := rt.NumListEval_Detailed_Unmarshal(n, msg.Fields[FromNumbers_Vals], &out.Vals); e != nil {
		err = errutil.New("unmarshaling", Type_FromNumbers, rt.Type_NumListEval, e)
	}
	return
}

func FromNumbers_Detailed_Optional_Marshal(n jsonexp.Context, val **FromNumbers) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromNumbers_Detailed_Marshal(n, ptr)
	}
	return
}
func FromNumbers_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromNumbers) (err error) {
	if len(b) > 0 {
		var el FromNumbers
		if e := FromNumbers_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromNumbers, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromObj Targets an object with a computed name.
type FromObj struct {
	Object rt.TextEval `if:"label=_"`
}

func (*FromObj) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromObj,
		Uses: composer.Type_Flow,
	}
}

const Type_FromObj = "from_obj"
const FromObj_Object = "$OBJECT"

func (op *FromObj) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromObj_Detailed_Marshal(n, op)
}
func (op *FromObj) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromObj_Detailed_Unmarshal(n, b, op)
}

func FromObj_Detailed_Marshal(n jsonexp.Context, val *FromObj) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromObj_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromObj,
			Fields: fields,
		})
	}
	return
}

func FromObj_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromObj) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromObj, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[FromObj_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_FromObj, rt.Type_TextEval, e)
	}
	return
}

func FromObj_Detailed_Optional_Marshal(n jsonexp.Context, val **FromObj) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromObj_Detailed_Marshal(n, ptr)
	}
	return
}
func FromObj_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromObj) (err error) {
	if len(b) > 0 {
		var el FromObj
		if e := FromObj_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromObj, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromRec Targets a record stored in a record.
type FromRec struct {
	Rec rt.RecordEval `if:"label=_"`
}

func (*FromRec) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromRec,
		Uses: composer.Type_Flow,
	}
}

const Type_FromRec = "from_rec"
const FromRec_Rec = "$REC"

func (op *FromRec) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromRec_Detailed_Marshal(n, op)
}
func (op *FromRec) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromRec_Detailed_Unmarshal(n, b, op)
}

func FromRec_Detailed_Marshal(n jsonexp.Context, val *FromRec) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.RecordEval_Detailed_Marshal(n, &val.Rec); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromRec_Rec] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromRec,
			Fields: fields,
		})
	}
	return
}

func FromRec_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromRec) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromRec, e)
	} else if e := rt.RecordEval_Detailed_Unmarshal(n, msg.Fields[FromRec_Rec], &out.Rec); e != nil {
		err = errutil.New("unmarshaling", Type_FromRec, rt.Type_RecordEval, e)
	}
	return
}

func FromRec_Detailed_Optional_Marshal(n jsonexp.Context, val **FromRec) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromRec_Detailed_Marshal(n, ptr)
	}
	return
}
func FromRec_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromRec) (err error) {
	if len(b) > 0 {
		var el FromRec
		if e := FromRec_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromRec, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromRecord Assigns the calculated record.
type FromRecord struct {
	Val rt.RecordEval `if:"label=_"`
}

func (*FromRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromRecord,
		Uses: composer.Type_Flow,
		Lede: "from_rec",
	}
}

const Type_FromRecord = "from_record"
const FromRecord_Val = "$VAL"

func (op *FromRecord) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromRecord_Detailed_Marshal(n, op)
}
func (op *FromRecord) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromRecord_Detailed_Unmarshal(n, b, op)
}

func FromRecord_Detailed_Marshal(n jsonexp.Context, val *FromRecord) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.RecordEval_Detailed_Marshal(n, &val.Val); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromRecord_Val] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromRecord,
			Fields: fields,
		})
	}
	return
}

func FromRecord_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromRecord) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromRecord, e)
	} else if e := rt.RecordEval_Detailed_Unmarshal(n, msg.Fields[FromRecord_Val], &out.Val); e != nil {
		err = errutil.New("unmarshaling", Type_FromRecord, rt.Type_RecordEval, e)
	}
	return
}

func FromRecord_Detailed_Optional_Marshal(n jsonexp.Context, val **FromRecord) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromRecord_Detailed_Marshal(n, ptr)
	}
	return
}
func FromRecord_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromRecord) (err error) {
	if len(b) > 0 {
		var el FromRecord
		if e := FromRecord_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromRecord, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromRecords Assigns the calculated records.
type FromRecords struct {
	Vals rt.RecordListEval `if:"label=_"`
}

func (*FromRecords) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromRecords,
		Uses: composer.Type_Flow,
		Lede: "from_recs",
	}
}

const Type_FromRecords = "from_records"
const FromRecords_Vals = "$VALS"

func (op *FromRecords) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromRecords_Detailed_Marshal(n, op)
}
func (op *FromRecords) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromRecords_Detailed_Unmarshal(n, b, op)
}

func FromRecords_Detailed_Marshal(n jsonexp.Context, val *FromRecords) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.RecordListEval_Detailed_Marshal(n, &val.Vals); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromRecords_Vals] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromRecords,
			Fields: fields,
		})
	}
	return
}

func FromRecords_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromRecords) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromRecords, e)
	} else if e := rt.RecordListEval_Detailed_Unmarshal(n, msg.Fields[FromRecords_Vals], &out.Vals); e != nil {
		err = errutil.New("unmarshaling", Type_FromRecords, rt.Type_RecordListEval, e)
	}
	return
}

func FromRecords_Detailed_Optional_Marshal(n jsonexp.Context, val **FromRecords) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromRecords_Detailed_Marshal(n, ptr)
	}
	return
}
func FromRecords_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromRecords) (err error) {
	if len(b) > 0 {
		var el FromRecords
		if e := FromRecords_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromRecords, e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_FromSourceFields = "from_source_fields"

func FromSourceFields_Detailed_Marshal(n jsonexp.Context, ptr *FromSourceFields) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_FromSourceFields,
			Value: b,
		})
	}
	return
}

func FromSourceFields_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromSourceFields) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromSourceFields, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_FromSourceFields, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_FromSourceFields, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_FromSourceFields, e)
		} else {
			(*out) = ptr.(FromSourceFields)
		}
	}
	return
}

// FromText Assigns the calculated piece of text.
type FromText struct {
	Val rt.TextEval `if:"label=_"`
}

func (*FromText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromText,
		Uses: composer.Type_Flow,
		Lede: "from_txt",
	}
}

const Type_FromText = "from_text"
const FromText_Val = "$VAL"

func (op *FromText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromText_Detailed_Marshal(n, op)
}
func (op *FromText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromText_Detailed_Unmarshal(n, b, op)
}

func FromText_Detailed_Marshal(n jsonexp.Context, val *FromText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Val); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromText_Val] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromText,
			Fields: fields,
		})
	}
	return
}

func FromText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromText, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[FromText_Val], &out.Val); e != nil {
		err = errutil.New("unmarshaling", Type_FromText, rt.Type_TextEval, e)
	}
	return
}

func FromText_Detailed_Optional_Marshal(n jsonexp.Context, val **FromText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromText_Detailed_Marshal(n, ptr)
	}
	return
}
func FromText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromText) (err error) {
	if len(b) > 0 {
		var el FromText
		if e := FromText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromText, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromTexts Assigns the calculated texts.
type FromTexts struct {
	Vals rt.TextListEval `if:"label=_"`
}

func (*FromTexts) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromTexts,
		Uses: composer.Type_Flow,
		Lede: "from_txts",
	}
}

const Type_FromTexts = "from_texts"
const FromTexts_Vals = "$VALS"

func (op *FromTexts) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromTexts_Detailed_Marshal(n, op)
}
func (op *FromTexts) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromTexts_Detailed_Unmarshal(n, b, op)
}

func FromTexts_Detailed_Marshal(n jsonexp.Context, val *FromTexts) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextListEval_Detailed_Marshal(n, &val.Vals); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromTexts_Vals] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromTexts,
			Fields: fields,
		})
	}
	return
}

func FromTexts_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromTexts) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromTexts, e)
	} else if e := rt.TextListEval_Detailed_Unmarshal(n, msg.Fields[FromTexts_Vals], &out.Vals); e != nil {
		err = errutil.New("unmarshaling", Type_FromTexts, rt.Type_TextListEval, e)
	}
	return
}

func FromTexts_Detailed_Optional_Marshal(n jsonexp.Context, val **FromTexts) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromTexts_Detailed_Marshal(n, ptr)
	}
	return
}
func FromTexts_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromTexts) (err error) {
	if len(b) > 0 {
		var el FromTexts
		if e := FromTexts_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromTexts, e)
		} else {
			*out = &el
		}
	}
	return
}

// FromVar Targets a record stored in a variable.
type FromVar struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromVar) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromVar,
		Uses: composer.Type_Flow,
	}
}

const Type_FromVar = "from_var"
const FromVar_Var = "$VAR"

func (op *FromVar) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromVar_Detailed_Marshal(n, op)
}
func (op *FromVar) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromVar_Detailed_Unmarshal(n, b, op)
}

func FromVar_Detailed_Marshal(n jsonexp.Context, val *FromVar) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromVar_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromVar,
			Fields: fields,
		})
	}
	return
}

func FromVar_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromVar) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_FromVar, e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[FromVar_Var], &out.Var); e != nil {
		err = errutil.New("unmarshaling", Type_FromVar, value.Type_VariableName, e)
	}
	return
}

func FromVar_Detailed_Optional_Marshal(n jsonexp.Context, val **FromVar) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = FromVar_Detailed_Marshal(n, ptr)
	}
	return
}
func FromVar_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromVar) (err error) {
	if len(b) > 0 {
		var el FromVar
		if e := FromVar_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_FromVar, e)
		} else {
			*out = &el
		}
	}
	return
}

// GetAtField Get a value from a record.
type GetAtField struct {
	Field string           `if:"label=_,type=text"`
	From  FromSourceFields `if:"label=from"`
}

func (*GetAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_GetAtField,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const Type_GetAtField = "get_at_field"
const GetAtField_Field = "$FIELD"
const GetAtField_From = "$FROM"

func (op *GetAtField) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return GetAtField_Detailed_Marshal(n, op)
}
func (op *GetAtField) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return GetAtField_Detailed_Unmarshal(n, b, op)
}

func GetAtField_Detailed_Marshal(n jsonexp.Context, val *GetAtField) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Field); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[GetAtField_Field] = b
	}
	if b, e := FromSourceFields_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[GetAtField_From] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_GetAtField,
			Fields: fields,
		})
	}
	return
}

func GetAtField_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *GetAtField) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_GetAtField, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[GetAtField_Field], &out.Field); e != nil {
		err = errutil.New("unmarshaling", Type_GetAtField, value.Type_Text, e)
	} else if e := FromSourceFields_Detailed_Unmarshal(n, msg.Fields[GetAtField_From], &out.From); e != nil {
		err = errutil.New("unmarshaling", Type_GetAtField, Type_FromSourceFields, e)
	}
	return
}

func GetAtField_Detailed_Optional_Marshal(n jsonexp.Context, val **GetAtField) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = GetAtField_Detailed_Marshal(n, ptr)
	}
	return
}
func GetAtField_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **GetAtField) (err error) {
	if len(b) > 0 {
		var el GetAtField
		if e := GetAtField_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_GetAtField, e)
		} else {
			*out = &el
		}
	}
	return
}

// GetVar Get Variable: Return the value of the named variable.
type GetVar struct {
	Name value.VariableName `if:"label=_"`
}

func (*GetVar) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_GetVar,
		Uses: composer.Type_Flow,
		Lede: "var",
	}
}

const Type_GetVar = "get_var"
const GetVar_Name = "$NAME"

func (op *GetVar) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return GetVar_Detailed_Marshal(n, op)
}
func (op *GetVar) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return GetVar_Detailed_Unmarshal(n, b, op)
}

func GetVar_Detailed_Marshal(n jsonexp.Context, val *GetVar) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[GetVar_Name] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_GetVar,
			Fields: fields,
		})
	}
	return
}

func GetVar_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *GetVar) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_GetVar, e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[GetVar_Name], &out.Name); e != nil {
		err = errutil.New("unmarshaling", Type_GetVar, value.Type_VariableName, e)
	}
	return
}

func GetVar_Detailed_Optional_Marshal(n jsonexp.Context, val **GetVar) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = GetVar_Detailed_Marshal(n, ptr)
	}
	return
}
func GetVar_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **GetVar) (err error) {
	if len(b) > 0 {
		var el GetVar
		if e := GetVar_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_GetVar, e)
		} else {
			*out = &el
		}
	}
	return
}

// GreaterThan The first value is larger than the second value.
type GreaterThan struct {
}

func (*GreaterThan) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_GreaterThan,
		Uses: composer.Type_Flow,
	}
}

const Type_GreaterThan = "greater_than"

func (op *GreaterThan) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return GreaterThan_Detailed_Marshal(n, op)
}
func (op *GreaterThan) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return GreaterThan_Detailed_Unmarshal(n, b, op)
}

func GreaterThan_Detailed_Marshal(n jsonexp.Context, val *GreaterThan) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_GreaterThan,
			Fields: fields,
		})
	}
	return
}

func GreaterThan_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *GreaterThan) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_GreaterThan, e)
	}
	return
}

func GreaterThan_Detailed_Optional_Marshal(n jsonexp.Context, val **GreaterThan) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = GreaterThan_Detailed_Marshal(n, ptr)
	}
	return
}
func GreaterThan_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **GreaterThan) (err error) {
	if len(b) > 0 {
		var el GreaterThan
		if e := GreaterThan_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_GreaterThan, e)
		} else {
			*out = &el
		}
	}
	return
}

// HasDominion
type HasDominion struct {
	Name string `if:"label=_,type=text"`
}

func (*HasDominion) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_HasDominion,
		Uses: composer.Type_Flow,
	}
}

const Type_HasDominion = "has_dominion"
const HasDominion_Name = "$NAME"

func (op *HasDominion) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return HasDominion_Detailed_Marshal(n, op)
}
func (op *HasDominion) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return HasDominion_Detailed_Unmarshal(n, b, op)
}

func HasDominion_Detailed_Marshal(n jsonexp.Context, val *HasDominion) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[HasDominion_Name] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_HasDominion,
			Fields: fields,
		})
	}
	return
}

func HasDominion_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *HasDominion) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_HasDominion, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[HasDominion_Name], &out.Name); e != nil {
		err = errutil.New("unmarshaling", Type_HasDominion, value.Type_Text, e)
	}
	return
}

func HasDominion_Detailed_Optional_Marshal(n jsonexp.Context, val **HasDominion) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = HasDominion_Detailed_Marshal(n, ptr)
	}
	return
}
func HasDominion_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **HasDominion) (err error) {
	if len(b) > 0 {
		var el HasDominion
		if e := HasDominion_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_HasDominion, e)
		} else {
			*out = &el
		}
	}
	return
}

// HasTrait Return true if the object is currently in the requested state.
type HasTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

func (*HasTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_HasTrait,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const Type_HasTrait = "has_trait"
const HasTrait_Object = "$OBJECT"
const HasTrait_Trait = "$TRAIT"

func (op *HasTrait) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return HasTrait_Detailed_Marshal(n, op)
}
func (op *HasTrait) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return HasTrait_Detailed_Unmarshal(n, b, op)
}

func HasTrait_Detailed_Marshal(n jsonexp.Context, val *HasTrait) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[HasTrait_Object] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Trait); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[HasTrait_Trait] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_HasTrait,
			Fields: fields,
		})
	}
	return
}

func HasTrait_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *HasTrait) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_HasTrait, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[HasTrait_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_HasTrait, rt.Type_TextEval, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[HasTrait_Trait], &out.Trait); e != nil {
		err = errutil.New("unmarshaling", Type_HasTrait, rt.Type_TextEval, e)
	}
	return
}

func HasTrait_Detailed_Optional_Marshal(n jsonexp.Context, val **HasTrait) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = HasTrait_Detailed_Marshal(n, ptr)
	}
	return
}
func HasTrait_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **HasTrait) (err error) {
	if len(b) > 0 {
		var el HasTrait
		if e := HasTrait_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_HasTrait, e)
		} else {
			*out = &el
		}
	}
	return
}

// IdOf A unique object identifier.
type IdOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*IdOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IdOf,
		Uses: composer.Type_Flow,
	}
}

const Type_IdOf = "id_of"
const IdOf_Object = "$OBJECT"

func (op *IdOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IdOf_Detailed_Marshal(n, op)
}
func (op *IdOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IdOf_Detailed_Unmarshal(n, b, op)
}

func IdOf_Detailed_Marshal(n jsonexp.Context, val *IdOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IdOf_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IdOf,
			Fields: fields,
		})
	}
	return
}

func IdOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IdOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_IdOf, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[IdOf_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_IdOf, rt.Type_TextEval, e)
	}
	return
}

func IdOf_Detailed_Optional_Marshal(n jsonexp.Context, val **IdOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = IdOf_Detailed_Marshal(n, ptr)
	}
	return
}
func IdOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IdOf) (err error) {
	if len(b) > 0 {
		var el IdOf
		if e := IdOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_IdOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// Includes True if text contains text.
type Includes struct {
	Text rt.TextEval `if:"label=_"`
	Part rt.TextEval `if:"label=part"`
}

func (*Includes) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Includes,
		Uses: composer.Type_Flow,
		Lede: "contains",
	}
}

const Type_Includes = "includes"
const Includes_Text = "$TEXT"
const Includes_Part = "$PART"

func (op *Includes) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Includes_Detailed_Marshal(n, op)
}
func (op *Includes) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Includes_Detailed_Unmarshal(n, b, op)
}

func Includes_Detailed_Marshal(n jsonexp.Context, val *Includes) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Includes_Text] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Part); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Includes_Part] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Includes,
			Fields: fields,
		})
	}
	return
}

func Includes_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Includes) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Includes, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Includes_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_Includes, rt.Type_TextEval, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Includes_Part], &out.Part); e != nil {
		err = errutil.New("unmarshaling", Type_Includes, rt.Type_TextEval, e)
	}
	return
}

func Includes_Detailed_Optional_Marshal(n jsonexp.Context, val **Includes) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Includes_Detailed_Marshal(n, ptr)
	}
	return
}
func Includes_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Includes) (err error) {
	if len(b) > 0 {
		var el Includes
		if e := Includes_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Includes, e)
		} else {
			*out = &el
		}
	}
	return
}

// IntoObj Targets an object with a computed name.
type IntoObj struct {
	Object rt.TextEval `if:"label=_"`
}

func (*IntoObj) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoObj,
		Uses: composer.Type_Flow,
		Lede: "obj",
	}
}

const Type_IntoObj = "into_obj"
const IntoObj_Object = "$OBJECT"

func (op *IntoObj) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IntoObj_Detailed_Marshal(n, op)
}
func (op *IntoObj) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IntoObj_Detailed_Unmarshal(n, b, op)
}

func IntoObj_Detailed_Marshal(n jsonexp.Context, val *IntoObj) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IntoObj_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IntoObj,
			Fields: fields,
		})
	}
	return
}

func IntoObj_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoObj) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_IntoObj, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[IntoObj_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_IntoObj, rt.Type_TextEval, e)
	}
	return
}

func IntoObj_Detailed_Optional_Marshal(n jsonexp.Context, val **IntoObj) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = IntoObj_Detailed_Marshal(n, ptr)
	}
	return
}
func IntoObj_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IntoObj) (err error) {
	if len(b) > 0 {
		var el IntoObj
		if e := IntoObj_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_IntoObj, e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_IntoTargetFields = "into_target_fields"

func IntoTargetFields_Detailed_Marshal(n jsonexp.Context, ptr *IntoTargetFields) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_IntoTargetFields,
			Value: b,
		})
	}
	return
}

func IntoTargetFields_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoTargetFields) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_IntoTargetFields, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_IntoTargetFields, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_IntoTargetFields, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_IntoTargetFields, e)
		} else {
			(*out) = ptr.(IntoTargetFields)
		}
	}
	return
}

// IntoVar Targets an object or record stored in a variable
type IntoVar struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoVar) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoVar,
		Uses: composer.Type_Flow,
		Lede: "var",
	}
}

const Type_IntoVar = "into_var"
const IntoVar_Var = "$VAR"

func (op *IntoVar) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IntoVar_Detailed_Marshal(n, op)
}
func (op *IntoVar) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IntoVar_Detailed_Unmarshal(n, b, op)
}

func IntoVar_Detailed_Marshal(n jsonexp.Context, val *IntoVar) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IntoVar_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IntoVar,
			Fields: fields,
		})
	}
	return
}

func IntoVar_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoVar) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_IntoVar, e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[IntoVar_Var], &out.Var); e != nil {
		err = errutil.New("unmarshaling", Type_IntoVar, value.Type_VariableName, e)
	}
	return
}

func IntoVar_Detailed_Optional_Marshal(n jsonexp.Context, val **IntoVar) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = IntoVar_Detailed_Marshal(n, ptr)
	}
	return
}
func IntoVar_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IntoVar) (err error) {
	if len(b) > 0 {
		var el IntoVar
		if e := IntoVar_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_IntoVar, e)
		} else {
			*out = &el
		}
	}
	return
}

// IsEmpty True if the text is empty.
type IsEmpty struct {
	Text rt.TextEval `if:"label=empty"`
}

func (*IsEmpty) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IsEmpty,
		Uses: composer.Type_Flow,
		Lede: "is",
	}
}

const Type_IsEmpty = "is_empty"
const IsEmpty_Text = "$TEXT"

func (op *IsEmpty) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IsEmpty_Detailed_Marshal(n, op)
}
func (op *IsEmpty) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IsEmpty_Detailed_Unmarshal(n, b, op)
}

func IsEmpty_Detailed_Marshal(n jsonexp.Context, val *IsEmpty) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IsEmpty_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IsEmpty,
			Fields: fields,
		})
	}
	return
}

func IsEmpty_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IsEmpty) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_IsEmpty, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[IsEmpty_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_IsEmpty, rt.Type_TextEval, e)
	}
	return
}

func IsEmpty_Detailed_Optional_Marshal(n jsonexp.Context, val **IsEmpty) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = IsEmpty_Detailed_Marshal(n, ptr)
	}
	return
}
func IsEmpty_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IsEmpty) (err error) {
	if len(b) > 0 {
		var el IsEmpty
		if e := IsEmpty_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_IsEmpty, e)
		} else {
			*out = &el
		}
	}
	return
}

// IsExactKindOf True if the object is exactly the named kind.
type IsExactKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   string      `if:"label=is_exactly,type=text"`
}

func (*IsExactKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IsExactKindOf,
		Uses: composer.Type_Flow,
		Lede: "kind_of",
	}
}

const Type_IsExactKindOf = "is_exact_kind_of"
const IsExactKindOf_Object = "$OBJECT"
const IsExactKindOf_Kind = "$KIND"

func (op *IsExactKindOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IsExactKindOf_Detailed_Marshal(n, op)
}
func (op *IsExactKindOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IsExactKindOf_Detailed_Unmarshal(n, b, op)
}

func IsExactKindOf_Detailed_Marshal(n jsonexp.Context, val *IsExactKindOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IsExactKindOf_Object] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IsExactKindOf_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IsExactKindOf,
			Fields: fields,
		})
	}
	return
}

func IsExactKindOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IsExactKindOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_IsExactKindOf, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[IsExactKindOf_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_IsExactKindOf, rt.Type_TextEval, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[IsExactKindOf_Kind], &out.Kind); e != nil {
		err = errutil.New("unmarshaling", Type_IsExactKindOf, value.Type_Text, e)
	}
	return
}

func IsExactKindOf_Detailed_Optional_Marshal(n jsonexp.Context, val **IsExactKindOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = IsExactKindOf_Detailed_Marshal(n, ptr)
	}
	return
}
func IsExactKindOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IsExactKindOf) (err error) {
	if len(b) > 0 {
		var el IsExactKindOf
		if e := IsExactKindOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_IsExactKindOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// IsKindOf True if the object is compatible with the named kind.
type IsKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   string      `if:"label=is,type=text"`
}

func (*IsKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IsKindOf,
		Uses: composer.Type_Flow,
		Lede: "kind_of",
	}
}

const Type_IsKindOf = "is_kind_of"
const IsKindOf_Object = "$OBJECT"
const IsKindOf_Kind = "$KIND"

func (op *IsKindOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IsKindOf_Detailed_Marshal(n, op)
}
func (op *IsKindOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IsKindOf_Detailed_Unmarshal(n, b, op)
}

func IsKindOf_Detailed_Marshal(n jsonexp.Context, val *IsKindOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IsKindOf_Object] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IsKindOf_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IsKindOf,
			Fields: fields,
		})
	}
	return
}

func IsKindOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IsKindOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_IsKindOf, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[IsKindOf_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_IsKindOf, rt.Type_TextEval, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[IsKindOf_Kind], &out.Kind); e != nil {
		err = errutil.New("unmarshaling", Type_IsKindOf, value.Type_Text, e)
	}
	return
}

func IsKindOf_Detailed_Optional_Marshal(n jsonexp.Context, val **IsKindOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = IsKindOf_Detailed_Marshal(n, ptr)
	}
	return
}
func IsKindOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IsKindOf) (err error) {
	if len(b) > 0 {
		var el IsKindOf
		if e := IsKindOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_IsKindOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// Join Returns multiple pieces of text as a single new piece of text.
type Join struct {
	Sep   rt.TextEval   `if:"label=_"`
	Parts []rt.TextEval `if:"label=parts"`
}

func (*Join) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Join,
		Uses: composer.Type_Flow,
	}
}

const Type_Join = "join"
const Join_Sep = "$SEP"
const Join_Parts = "$PARTS"

func (op *Join) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Join_Detailed_Marshal(n, op)
}
func (op *Join) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Join_Detailed_Unmarshal(n, b, op)
}

func Join_Detailed_Marshal(n jsonexp.Context, val *Join) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Sep); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Join_Sep] = b
	}
	if b, e := rt.TextEval_Detailed_Repeats_Marshal(n, &val.Parts); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Join_Parts] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Join,
			Fields: fields,
		})
	}
	return
}

func Join_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Join) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Join, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Join_Sep], &out.Sep); e != nil {
		err = errutil.New("unmarshaling", Type_Join, rt.Type_TextEval, e)
	} else if e := rt.TextEval_Detailed_Repeats_Unmarshal(n, msg.Fields[Join_Parts], &out.Parts); e != nil {
		err = errutil.New("unmarshaling", Type_Join, rt.Type_TextEval, e)
	}
	return
}

func Join_Detailed_Optional_Marshal(n jsonexp.Context, val **Join) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Join_Detailed_Marshal(n, ptr)
	}
	return
}
func Join_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Join) (err error) {
	if len(b) > 0 {
		var el Join
		if e := Join_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Join, e)
		} else {
			*out = &el
		}
	}
	return
}

// KindOf Friendly name of the object&#x27;s kind.
type KindOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*KindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindOf,
		Uses: composer.Type_Flow,
	}
}

const Type_KindOf = "kind_of"
const KindOf_Object = "$OBJECT"

func (op *KindOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return KindOf_Detailed_Marshal(n, op)
}
func (op *KindOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return KindOf_Detailed_Unmarshal(n, b, op)
}

func KindOf_Detailed_Marshal(n jsonexp.Context, val *KindOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindOf_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_KindOf,
			Fields: fields,
		})
	}
	return
}

func KindOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *KindOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_KindOf, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[KindOf_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_KindOf, rt.Type_TextEval, e)
	}
	return
}

func KindOf_Detailed_Optional_Marshal(n jsonexp.Context, val **KindOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = KindOf_Detailed_Marshal(n, ptr)
	}
	return
}
func KindOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **KindOf) (err error) {
	if len(b) > 0 {
		var el KindOf
		if e := KindOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_KindOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// KindsOf A list of compatible kinds.
type KindsOf struct {
	Kind string `if:"label=_,type=text"`
}

func (*KindsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsOf,
		Uses: composer.Type_Flow,
	}
}

const Type_KindsOf = "kinds_of"
const KindsOf_Kind = "$KIND"

func (op *KindsOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return KindsOf_Detailed_Marshal(n, op)
}
func (op *KindsOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return KindsOf_Detailed_Unmarshal(n, b, op)
}

func KindsOf_Detailed_Marshal(n jsonexp.Context, val *KindsOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindsOf_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_KindsOf,
			Fields: fields,
		})
	}
	return
}

func KindsOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *KindsOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_KindsOf, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[KindsOf_Kind], &out.Kind); e != nil {
		err = errutil.New("unmarshaling", Type_KindsOf, value.Type_Text, e)
	}
	return
}

func KindsOf_Detailed_Optional_Marshal(n jsonexp.Context, val **KindsOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = KindsOf_Detailed_Marshal(n, ptr)
	}
	return
}
func KindsOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **KindsOf) (err error) {
	if len(b) > 0 {
		var el KindsOf
		if e := KindsOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_KindsOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// LessThan The first value is less than the second value.
type LessThan struct {
}

func (*LessThan) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_LessThan,
		Uses: composer.Type_Flow,
	}
}

const Type_LessThan = "less_than"

func (op *LessThan) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return LessThan_Detailed_Marshal(n, op)
}
func (op *LessThan) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return LessThan_Detailed_Unmarshal(n, b, op)
}

func LessThan_Detailed_Marshal(n jsonexp.Context, val *LessThan) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_LessThan,
			Fields: fields,
		})
	}
	return
}

func LessThan_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *LessThan) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_LessThan, e)
	}
	return
}

func LessThan_Detailed_Optional_Marshal(n jsonexp.Context, val **LessThan) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = LessThan_Detailed_Marshal(n, ptr)
	}
	return
}
func LessThan_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **LessThan) (err error) {
	if len(b) > 0 {
		var el LessThan
		if e := LessThan_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_LessThan, e)
		} else {
			*out = &el
		}
	}
	return
}

// MakeLowercase Returns new text, with every letter turned into lowercase. For example, &#x27;shout&#x27; from &#x27;SHOUT&#x27;.
type MakeLowercase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeLowercase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeLowercase,
		Uses: composer.Type_Flow,
		Lede: "lower",
	}
}

const Type_MakeLowercase = "make_lowercase"
const MakeLowercase_Text = "$TEXT"

func (op *MakeLowercase) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return MakeLowercase_Detailed_Marshal(n, op)
}
func (op *MakeLowercase) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return MakeLowercase_Detailed_Unmarshal(n, b, op)
}

func MakeLowercase_Detailed_Marshal(n jsonexp.Context, val *MakeLowercase) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[MakeLowercase_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_MakeLowercase,
			Fields: fields,
		})
	}
	return
}

func MakeLowercase_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *MakeLowercase) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_MakeLowercase, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[MakeLowercase_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_MakeLowercase, rt.Type_TextEval, e)
	}
	return
}

func MakeLowercase_Detailed_Optional_Marshal(n jsonexp.Context, val **MakeLowercase) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = MakeLowercase_Detailed_Marshal(n, ptr)
	}
	return
}
func MakeLowercase_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **MakeLowercase) (err error) {
	if len(b) > 0 {
		var el MakeLowercase
		if e := MakeLowercase_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_MakeLowercase, e)
		} else {
			*out = &el
		}
	}
	return
}

// MakeReversed Returns new text flipped back to front. For example, &#x27;elppA&#x27; from &#x27;Apple&#x27;, or &#x27;noon&#x27; from &#x27;noon&#x27;.
type MakeReversed struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeReversed) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeReversed,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const Type_MakeReversed = "make_reversed"
const MakeReversed_Text = "$TEXT"

func (op *MakeReversed) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return MakeReversed_Detailed_Marshal(n, op)
}
func (op *MakeReversed) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return MakeReversed_Detailed_Unmarshal(n, b, op)
}

func MakeReversed_Detailed_Marshal(n jsonexp.Context, val *MakeReversed) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[MakeReversed_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_MakeReversed,
			Fields: fields,
		})
	}
	return
}

func MakeReversed_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *MakeReversed) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_MakeReversed, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[MakeReversed_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_MakeReversed, rt.Type_TextEval, e)
	}
	return
}

func MakeReversed_Detailed_Optional_Marshal(n jsonexp.Context, val **MakeReversed) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = MakeReversed_Detailed_Marshal(n, ptr)
	}
	return
}
func MakeReversed_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **MakeReversed) (err error) {
	if len(b) > 0 {
		var el MakeReversed
		if e := MakeReversed_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_MakeReversed, e)
		} else {
			*out = &el
		}
	}
	return
}

// MakeSentenceCase Returns new text, start each sentence with a capital letter. For example, &#x27;Empire Apple.&#x27; from &#x27;Empire apple.&#x27;.
type MakeSentenceCase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeSentenceCase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeSentenceCase,
		Uses: composer.Type_Flow,
		Lede: "sentence",
	}
}

const Type_MakeSentenceCase = "make_sentence_case"
const MakeSentenceCase_Text = "$TEXT"

func (op *MakeSentenceCase) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return MakeSentenceCase_Detailed_Marshal(n, op)
}
func (op *MakeSentenceCase) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return MakeSentenceCase_Detailed_Unmarshal(n, b, op)
}

func MakeSentenceCase_Detailed_Marshal(n jsonexp.Context, val *MakeSentenceCase) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[MakeSentenceCase_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_MakeSentenceCase,
			Fields: fields,
		})
	}
	return
}

func MakeSentenceCase_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *MakeSentenceCase) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_MakeSentenceCase, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[MakeSentenceCase_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_MakeSentenceCase, rt.Type_TextEval, e)
	}
	return
}

func MakeSentenceCase_Detailed_Optional_Marshal(n jsonexp.Context, val **MakeSentenceCase) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = MakeSentenceCase_Detailed_Marshal(n, ptr)
	}
	return
}
func MakeSentenceCase_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **MakeSentenceCase) (err error) {
	if len(b) > 0 {
		var el MakeSentenceCase
		if e := MakeSentenceCase_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_MakeSentenceCase, e)
		} else {
			*out = &el
		}
	}
	return
}

// MakeTitleCase Returns new text, starting each word with a capital letter. For example, &#x27;Empire Apple&#x27; from &#x27;empire apple&#x27;.
type MakeTitleCase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeTitleCase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeTitleCase,
		Uses: composer.Type_Flow,
		Lede: "title",
	}
}

const Type_MakeTitleCase = "make_title_case"
const MakeTitleCase_Text = "$TEXT"

func (op *MakeTitleCase) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return MakeTitleCase_Detailed_Marshal(n, op)
}
func (op *MakeTitleCase) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return MakeTitleCase_Detailed_Unmarshal(n, b, op)
}

func MakeTitleCase_Detailed_Marshal(n jsonexp.Context, val *MakeTitleCase) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[MakeTitleCase_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_MakeTitleCase,
			Fields: fields,
		})
	}
	return
}

func MakeTitleCase_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *MakeTitleCase) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_MakeTitleCase, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[MakeTitleCase_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_MakeTitleCase, rt.Type_TextEval, e)
	}
	return
}

func MakeTitleCase_Detailed_Optional_Marshal(n jsonexp.Context, val **MakeTitleCase) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = MakeTitleCase_Detailed_Marshal(n, ptr)
	}
	return
}
func MakeTitleCase_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **MakeTitleCase) (err error) {
	if len(b) > 0 {
		var el MakeTitleCase
		if e := MakeTitleCase_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_MakeTitleCase, e)
		} else {
			*out = &el
		}
	}
	return
}

// MakeUppercase Returns new text, with every letter turned into uppercase. For example, &#x27;APPLE&#x27; from &#x27;apple&#x27;.
type MakeUppercase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeUppercase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_MakeUppercase,
		Uses: composer.Type_Flow,
		Lede: "upper",
	}
}

const Type_MakeUppercase = "make_uppercase"
const MakeUppercase_Text = "$TEXT"

func (op *MakeUppercase) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return MakeUppercase_Detailed_Marshal(n, op)
}
func (op *MakeUppercase) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return MakeUppercase_Detailed_Unmarshal(n, b, op)
}

func MakeUppercase_Detailed_Marshal(n jsonexp.Context, val *MakeUppercase) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[MakeUppercase_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_MakeUppercase,
			Fields: fields,
		})
	}
	return
}

func MakeUppercase_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *MakeUppercase) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_MakeUppercase, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[MakeUppercase_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_MakeUppercase, rt.Type_TextEval, e)
	}
	return
}

func MakeUppercase_Detailed_Optional_Marshal(n jsonexp.Context, val **MakeUppercase) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = MakeUppercase_Detailed_Marshal(n, ptr)
	}
	return
}
func MakeUppercase_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **MakeUppercase) (err error) {
	if len(b) > 0 {
		var el MakeUppercase
		if e := MakeUppercase_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_MakeUppercase, e)
		} else {
			*out = &el
		}
	}
	return
}

// Matches Determine whether the specified text is similar to the specified regular expression.
type Matches struct {
	Text    rt.TextEval `if:"label=_"`
	Pattern string      `if:"label=to,type=text"`
	Cache   MatchCache  `if:"internal"`
}

func (*Matches) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Matches,
		Uses: composer.Type_Flow,
	}
}

const Type_Matches = "matches"
const Matches_Text = "$TEXT"
const Matches_Pattern = "$PATTERN"

func (op *Matches) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Matches_Detailed_Marshal(n, op)
}
func (op *Matches) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Matches_Detailed_Unmarshal(n, b, op)
}

func Matches_Detailed_Marshal(n jsonexp.Context, val *Matches) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Matches_Text] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Pattern); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Matches_Pattern] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Matches,
			Fields: fields,
		})
	}
	return
}

func Matches_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Matches) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Matches, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Matches_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_Matches, rt.Type_TextEval, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Matches_Pattern], &out.Pattern); e != nil {
		err = errutil.New("unmarshaling", Type_Matches, value.Type_Text, e)
	}
	return
}

func Matches_Detailed_Optional_Marshal(n jsonexp.Context, val **Matches) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Matches_Detailed_Marshal(n, ptr)
	}
	return
}
func Matches_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Matches) (err error) {
	if len(b) > 0 {
		var el Matches
		if e := Matches_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Matches, e)
		} else {
			*out = &el
		}
	}
	return
}

// NameOf Full name of the object.
type NameOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*NameOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NameOf,
		Uses: composer.Type_Flow,
	}
}

const Type_NameOf = "name_of"
const NameOf_Object = "$OBJECT"

func (op *NameOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NameOf_Detailed_Marshal(n, op)
}
func (op *NameOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NameOf_Detailed_Unmarshal(n, b, op)
}

func NameOf_Detailed_Marshal(n jsonexp.Context, val *NameOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NameOf_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_NameOf,
			Fields: fields,
		})
	}
	return
}

func NameOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NameOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_NameOf, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[NameOf_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_NameOf, rt.Type_TextEval, e)
	}
	return
}

func NameOf_Detailed_Optional_Marshal(n jsonexp.Context, val **NameOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = NameOf_Detailed_Marshal(n, ptr)
	}
	return
}
func NameOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **NameOf) (err error) {
	if len(b) > 0 {
		var el NameOf
		if e := NameOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_NameOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// Never Returns false.
type Never struct {
}

func (*Never) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Never,
		Uses: composer.Type_Flow,
		Lede: "always",
	}
}

const Type_Never = "never"

func (op *Never) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Never_Detailed_Marshal(n, op)
}
func (op *Never) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Never_Detailed_Unmarshal(n, b, op)
}

func Never_Detailed_Marshal(n jsonexp.Context, val *Never) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Never,
			Fields: fields,
		})
	}
	return
}

func Never_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Never) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Never, e)
	}
	return
}

func Never_Detailed_Optional_Marshal(n jsonexp.Context, val **Never) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Never_Detailed_Marshal(n, ptr)
	}
	return
}
func Never_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Never) (err error) {
	if len(b) > 0 {
		var el Never
		if e := Never_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Never, e)
		} else {
			*out = &el
		}
	}
	return
}

// Newline Start a new line.
type Newline struct {
}

func (*Newline) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Newline,
		Uses: composer.Type_Flow,
		Lede: "br",
	}
}

const Type_Newline = "newline"

func (op *Newline) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Newline_Detailed_Marshal(n, op)
}
func (op *Newline) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Newline_Detailed_Unmarshal(n, b, op)
}

func Newline_Detailed_Marshal(n jsonexp.Context, val *Newline) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Newline,
			Fields: fields,
		})
	}
	return
}

func Newline_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Newline) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Newline, e)
	}
	return
}

func Newline_Detailed_Optional_Marshal(n jsonexp.Context, val **Newline) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Newline_Detailed_Marshal(n, ptr)
	}
	return
}
func Newline_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Newline) (err error) {
	if len(b) > 0 {
		var el Newline
		if e := Newline_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Newline, e)
		} else {
			*out = &el
		}
	}
	return
}

// Next In a repeating loop, try the next iteration of the loop.
type Next struct {
}

func (*Next) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Next,
		Uses: composer.Type_Flow,
	}
}

const Type_Next = "next"

func (op *Next) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Next_Detailed_Marshal(n, op)
}
func (op *Next) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Next_Detailed_Unmarshal(n, b, op)
}

func Next_Detailed_Marshal(n jsonexp.Context, val *Next) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Next,
			Fields: fields,
		})
	}
	return
}

func Next_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Next) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Next, e)
	}
	return
}

func Next_Detailed_Optional_Marshal(n jsonexp.Context, val **Next) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Next_Detailed_Marshal(n, ptr)
	}
	return
}
func Next_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Next) (err error) {
	if len(b) > 0 {
		var el Next
		if e := Next_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Next, e)
		} else {
			*out = &el
		}
	}
	return
}

// Not Returns the opposite value.
type Not struct {
	Test rt.BoolEval `if:"label=_"`
}

func (*Not) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Not,
		Uses: composer.Type_Flow,
	}
}

const Type_Not = "not"
const Not_Test = "$TEST"

func (op *Not) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Not_Detailed_Marshal(n, op)
}
func (op *Not) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Not_Detailed_Unmarshal(n, b, op)
}

func Not_Detailed_Marshal(n jsonexp.Context, val *Not) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.Test); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Not_Test] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Not,
			Fields: fields,
		})
	}
	return
}

func Not_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Not) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Not, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[Not_Test], &out.Test); e != nil {
		err = errutil.New("unmarshaling", Type_Not, rt.Type_BoolEval, e)
	}
	return
}

func Not_Detailed_Optional_Marshal(n jsonexp.Context, val **Not) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Not_Detailed_Marshal(n, ptr)
	}
	return
}
func Not_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Not) (err error) {
	if len(b) > 0 {
		var el Not
		if e := Not_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Not, e)
		} else {
			*out = &el
		}
	}
	return
}

// NumValue Specify a particular number.
type NumValue struct {
	Num float64 `if:"label=_,type=number"`
}

func (*NumValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NumValue,
		Uses: composer.Type_Flow,
		Lede: "num",
	}
}

const Type_NumValue = "num_value"
const NumValue_Num = "$NUM"

func (op *NumValue) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NumValue_Detailed_Marshal(n, op)
}
func (op *NumValue) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NumValue_Detailed_Unmarshal(n, b, op)
}

func NumValue_Detailed_Marshal(n jsonexp.Context, val *NumValue) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Number_Detailed_Override_Marshal(n, &val.Num); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NumValue_Num] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_NumValue,
			Fields: fields,
		})
	}
	return
}

func NumValue_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NumValue) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_NumValue, e)
	} else if e := value.Number_Detailed_Override_Unmarshal(n, msg.Fields[NumValue_Num], &out.Num); e != nil {
		err = errutil.New("unmarshaling", Type_NumValue, value.Type_Number, e)
	}
	return
}

func NumValue_Detailed_Optional_Marshal(n jsonexp.Context, val **NumValue) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = NumValue_Detailed_Marshal(n, ptr)
	}
	return
}
func NumValue_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **NumValue) (err error) {
	if len(b) > 0 {
		var el NumValue
		if e := NumValue_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_NumValue, e)
		} else {
			*out = &el
		}
	}
	return
}

// Numbers Number List: Specify a list of numbers.
type Numbers struct {
	Values []float64 `if:"label=_,type=number"`
}

func (*Numbers) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Numbers,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const Type_Numbers = "numbers"
const Numbers_Values = "$VALUES"

func (op *Numbers) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Numbers_Detailed_Marshal(n, op)
}
func (op *Numbers) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Numbers_Detailed_Unmarshal(n, b, op)
}

func Numbers_Detailed_Marshal(n jsonexp.Context, val *Numbers) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Number_Detailed_Override_Repeats_Marshal(n, &val.Values); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Numbers_Values] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Numbers,
			Fields: fields,
		})
	}
	return
}

func Numbers_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Numbers) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Numbers, e)
	} else if e := value.Number_Detailed_Override_Repeats_Unmarshal(n, msg.Fields[Numbers_Values], &out.Values); e != nil {
		err = errutil.New("unmarshaling", Type_Numbers, value.Type_Number, e)
	}
	return
}

func Numbers_Detailed_Optional_Marshal(n jsonexp.Context, val **Numbers) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Numbers_Detailed_Marshal(n, ptr)
	}
	return
}
func Numbers_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Numbers) (err error) {
	if len(b) > 0 {
		var el Numbers
		if e := Numbers_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Numbers, e)
		} else {
			*out = &el
		}
	}
	return
}

// ObjectExists Returns whether there is a object of the specified name.
type ObjectExists struct {
	Object rt.TextEval `if:"label=valid"`
}

func (*ObjectExists) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ObjectExists,
		Uses: composer.Type_Flow,
		Lede: "is",
	}
}

const Type_ObjectExists = "object_exists"
const ObjectExists_Object = "$OBJECT"

func (op *ObjectExists) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ObjectExists_Detailed_Marshal(n, op)
}
func (op *ObjectExists) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ObjectExists_Detailed_Unmarshal(n, b, op)
}

func ObjectExists_Detailed_Marshal(n jsonexp.Context, val *ObjectExists) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ObjectExists_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ObjectExists,
			Fields: fields,
		})
	}
	return
}

func ObjectExists_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ObjectExists) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ObjectExists, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[ObjectExists_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_ObjectExists, rt.Type_TextEval, e)
	}
	return
}

func ObjectExists_Detailed_Optional_Marshal(n jsonexp.Context, val **ObjectExists) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ObjectExists_Detailed_Marshal(n, ptr)
	}
	return
}
func ObjectExists_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ObjectExists) (err error) {
	if len(b) > 0 {
		var el ObjectExists
		if e := ObjectExists_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ObjectExists, e)
		} else {
			*out = &el
		}
	}
	return
}

// Pluralize Returns the plural form of a singular word. (ex. apples for apple. )
type Pluralize struct {
	Text rt.TextEval `if:"label=of"`
}

func (*Pluralize) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Pluralize,
		Uses: composer.Type_Flow,
		Lede: "plural",
	}
}

const Type_Pluralize = "pluralize"
const Pluralize_Text = "$TEXT"

func (op *Pluralize) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Pluralize_Detailed_Marshal(n, op)
}
func (op *Pluralize) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Pluralize_Detailed_Unmarshal(n, b, op)
}

func Pluralize_Detailed_Marshal(n jsonexp.Context, val *Pluralize) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Pluralize_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Pluralize,
			Fields: fields,
		})
	}
	return
}

func Pluralize_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Pluralize) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Pluralize, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Pluralize_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_Pluralize, rt.Type_TextEval, e)
	}
	return
}

func Pluralize_Detailed_Optional_Marshal(n jsonexp.Context, val **Pluralize) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Pluralize_Detailed_Marshal(n, ptr)
	}
	return
}
func Pluralize_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Pluralize) (err error) {
	if len(b) > 0 {
		var el Pluralize
		if e := Pluralize_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Pluralize, e)
		} else {
			*out = &el
		}
	}
	return
}

// PrintNum Writes a number using numerals, eg. &#x27;1&#x27;.
type PrintNum struct {
	Num rt.NumberEval `if:"label=_"`
}

func (*PrintNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PrintNum,
		Uses: composer.Type_Flow,
		Lede: "numeral",
	}
}

const Type_PrintNum = "print_num"
const PrintNum_Num = "$NUM"

func (op *PrintNum) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PrintNum_Detailed_Marshal(n, op)
}
func (op *PrintNum) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PrintNum_Detailed_Unmarshal(n, b, op)
}

func PrintNum_Detailed_Marshal(n jsonexp.Context, val *PrintNum) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Num); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PrintNum_Num] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PrintNum,
			Fields: fields,
		})
	}
	return
}

func PrintNum_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PrintNum) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_PrintNum, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[PrintNum_Num], &out.Num); e != nil {
		err = errutil.New("unmarshaling", Type_PrintNum, rt.Type_NumberEval, e)
	}
	return
}

func PrintNum_Detailed_Optional_Marshal(n jsonexp.Context, val **PrintNum) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PrintNum_Detailed_Marshal(n, ptr)
	}
	return
}
func PrintNum_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PrintNum) (err error) {
	if len(b) > 0 {
		var el PrintNum
		if e := PrintNum_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_PrintNum, e)
		} else {
			*out = &el
		}
	}
	return
}

// PrintNumWord Writes a number in plain english: eg. &#x27;one&#x27;
type PrintNumWord struct {
	Num rt.NumberEval `if:"label=words"`
}

func (*PrintNumWord) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PrintNumWord,
		Uses: composer.Type_Flow,
		Lede: "numeral",
	}
}

const Type_PrintNumWord = "print_num_word"
const PrintNumWord_Num = "$NUM"

func (op *PrintNumWord) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PrintNumWord_Detailed_Marshal(n, op)
}
func (op *PrintNumWord) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PrintNumWord_Detailed_Unmarshal(n, b, op)
}

func PrintNumWord_Detailed_Marshal(n jsonexp.Context, val *PrintNumWord) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Num); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PrintNumWord_Num] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PrintNumWord,
			Fields: fields,
		})
	}
	return
}

func PrintNumWord_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PrintNumWord) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_PrintNumWord, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[PrintNumWord_Num], &out.Num); e != nil {
		err = errutil.New("unmarshaling", Type_PrintNumWord, rt.Type_NumberEval, e)
	}
	return
}

func PrintNumWord_Detailed_Optional_Marshal(n jsonexp.Context, val **PrintNumWord) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PrintNumWord_Detailed_Marshal(n, ptr)
	}
	return
}
func PrintNumWord_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PrintNumWord) (err error) {
	if len(b) > 0 {
		var el PrintNumWord
		if e := PrintNumWord_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_PrintNumWord, e)
		} else {
			*out = &el
		}
	}
	return
}

// ProductOf Multiply two numbers.
type ProductOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*ProductOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ProductOf,
		Uses: composer.Type_Flow,
		Lede: "mul",
	}
}

const Type_ProductOf = "product_of"
const ProductOf_A = "$A"
const ProductOf_B = "$B"

func (op *ProductOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ProductOf_Detailed_Marshal(n, op)
}
func (op *ProductOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ProductOf_Detailed_Unmarshal(n, b, op)
}

func ProductOf_Detailed_Marshal(n jsonexp.Context, val *ProductOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.A); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ProductOf_A] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.B); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ProductOf_B] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ProductOf,
			Fields: fields,
		})
	}
	return
}

func ProductOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ProductOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_ProductOf, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ProductOf_A], &out.A); e != nil {
		err = errutil.New("unmarshaling", Type_ProductOf, rt.Type_NumberEval, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ProductOf_B], &out.B); e != nil {
		err = errutil.New("unmarshaling", Type_ProductOf, rt.Type_NumberEval, e)
	}
	return
}

func ProductOf_Detailed_Optional_Marshal(n jsonexp.Context, val **ProductOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ProductOf_Detailed_Marshal(n, ptr)
	}
	return
}
func ProductOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ProductOf) (err error) {
	if len(b) > 0 {
		var el ProductOf
		if e := ProductOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_ProductOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// PutAtField Put a value into the field of an record or object
type PutAtField struct {
	Into    IntoTargetFields `if:"label=_"`
	From    rt.Assignment    `if:"label=from"`
	AtField string           `if:"label=at,type=text"`
}

func (*PutAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PutAtField,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const Type_PutAtField = "put_at_field"
const PutAtField_Into = "$INTO"
const PutAtField_From = "$FROM"
const PutAtField_AtField = "$AT_FIELD"

func (op *PutAtField) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PutAtField_Detailed_Marshal(n, op)
}
func (op *PutAtField) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PutAtField_Detailed_Unmarshal(n, b, op)
}

func PutAtField_Detailed_Marshal(n jsonexp.Context, val *PutAtField) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := IntoTargetFields_Detailed_Marshal(n, &val.Into); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutAtField_Into] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutAtField_From] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.AtField); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutAtField_AtField] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PutAtField,
			Fields: fields,
		})
	}
	return
}

func PutAtField_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PutAtField) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_PutAtField, e)
	} else if e := IntoTargetFields_Detailed_Unmarshal(n, msg.Fields[PutAtField_Into], &out.Into); e != nil {
		err = errutil.New("unmarshaling", Type_PutAtField, Type_IntoTargetFields, e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[PutAtField_From], &out.From); e != nil {
		err = errutil.New("unmarshaling", Type_PutAtField, rt.Type_Assignment, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[PutAtField_AtField], &out.AtField); e != nil {
		err = errutil.New("unmarshaling", Type_PutAtField, value.Type_Text, e)
	}
	return
}

func PutAtField_Detailed_Optional_Marshal(n jsonexp.Context, val **PutAtField) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PutAtField_Detailed_Marshal(n, ptr)
	}
	return
}
func PutAtField_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PutAtField) (err error) {
	if len(b) > 0 {
		var el PutAtField
		if e := PutAtField_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_PutAtField, e)
		} else {
			*out = &el
		}
	}
	return
}

// QuotientOf Divide one number by another.
type QuotientOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*QuotientOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_QuotientOf,
		Uses: composer.Type_Flow,
		Lede: "div",
	}
}

const Type_QuotientOf = "quotient_of"
const QuotientOf_A = "$A"
const QuotientOf_B = "$B"

func (op *QuotientOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return QuotientOf_Detailed_Marshal(n, op)
}
func (op *QuotientOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return QuotientOf_Detailed_Unmarshal(n, b, op)
}

func QuotientOf_Detailed_Marshal(n jsonexp.Context, val *QuotientOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.A); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[QuotientOf_A] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.B); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[QuotientOf_B] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_QuotientOf,
			Fields: fields,
		})
	}
	return
}

func QuotientOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *QuotientOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_QuotientOf, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[QuotientOf_A], &out.A); e != nil {
		err = errutil.New("unmarshaling", Type_QuotientOf, rt.Type_NumberEval, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[QuotientOf_B], &out.B); e != nil {
		err = errutil.New("unmarshaling", Type_QuotientOf, rt.Type_NumberEval, e)
	}
	return
}

func QuotientOf_Detailed_Optional_Marshal(n jsonexp.Context, val **QuotientOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = QuotientOf_Detailed_Marshal(n, ptr)
	}
	return
}
func QuotientOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **QuotientOf) (err error) {
	if len(b) > 0 {
		var el QuotientOf
		if e := QuotientOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_QuotientOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// RemainderOf Divide one number by another, and return the remainder.
type RemainderOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*RemainderOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RemainderOf,
		Uses: composer.Type_Flow,
		Lede: "mod",
	}
}

const Type_RemainderOf = "remainder_of"
const RemainderOf_A = "$A"
const RemainderOf_B = "$B"

func (op *RemainderOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RemainderOf_Detailed_Marshal(n, op)
}
func (op *RemainderOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RemainderOf_Detailed_Unmarshal(n, b, op)
}

func RemainderOf_Detailed_Marshal(n jsonexp.Context, val *RemainderOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.A); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RemainderOf_A] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.B); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RemainderOf_B] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_RemainderOf,
			Fields: fields,
		})
	}
	return
}

func RemainderOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RemainderOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_RemainderOf, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[RemainderOf_A], &out.A); e != nil {
		err = errutil.New("unmarshaling", Type_RemainderOf, rt.Type_NumberEval, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[RemainderOf_B], &out.B); e != nil {
		err = errutil.New("unmarshaling", Type_RemainderOf, rt.Type_NumberEval, e)
	}
	return
}

func RemainderOf_Detailed_Optional_Marshal(n jsonexp.Context, val **RemainderOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = RemainderOf_Detailed_Marshal(n, ptr)
	}
	return
}
func RemainderOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **RemainderOf) (err error) {
	if len(b) > 0 {
		var el RemainderOf
		if e := RemainderOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_RemainderOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// Response Generate text in a replaceable manner.
type Response struct {
	Name string      `if:"label=_,type=text"`
	Text rt.TextEval `if:"label=text,optional"`
}

func (*Response) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Response,
		Uses: composer.Type_Flow,
	}
}

const Type_Response = "response"
const Response_Name = "$NAME"
const Response_Text = "$TEXT"

func (op *Response) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Response_Detailed_Marshal(n, op)
}
func (op *Response) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Response_Detailed_Unmarshal(n, b, op)
}

func Response_Detailed_Marshal(n jsonexp.Context, val *Response) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Response_Name] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Response_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Response,
			Fields: fields,
		})
	}
	return
}

func Response_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Response) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Response, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Response_Name], &out.Name); e != nil {
		err = errutil.New("unmarshaling", Type_Response, value.Type_Text, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Response_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_Response, rt.Type_TextEval, e)
	}
	return
}

func Response_Detailed_Optional_Marshal(n jsonexp.Context, val **Response) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Response_Detailed_Marshal(n, ptr)
	}
	return
}
func Response_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Response) (err error) {
	if len(b) > 0 {
		var el Response
		if e := Response_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Response, e)
		} else {
			*out = &el
		}
	}
	return
}

// Row A single line as part of a group of lines.
type Row struct {
	Do Activity `if:"label=_"`
}

func (*Row) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Row,
		Uses: composer.Type_Flow,
	}
}

const Type_Row = "row"
const Row_Do = "$DO"

func (op *Row) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Row_Detailed_Marshal(n, op)
}
func (op *Row) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Row_Detailed_Unmarshal(n, b, op)
}

func Row_Detailed_Marshal(n jsonexp.Context, val *Row) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Row_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Row,
			Fields: fields,
		})
	}
	return
}

func Row_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Row) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Row, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[Row_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_Row, Type_Activity, e)
	}
	return
}

func Row_Detailed_Optional_Marshal(n jsonexp.Context, val **Row) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Row_Detailed_Marshal(n, ptr)
	}
	return
}
func Row_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Row) (err error) {
	if len(b) > 0 {
		var el Row
		if e := Row_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Row, e)
		} else {
			*out = &el
		}
	}
	return
}

// Rows Group text into successive lines.
type Rows struct {
	Do Activity `if:"label=_"`
}

func (*Rows) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Rows,
		Uses: composer.Type_Flow,
	}
}

const Type_Rows = "rows"
const Rows_Do = "$DO"

func (op *Rows) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Rows_Detailed_Marshal(n, op)
}
func (op *Rows) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Rows_Detailed_Unmarshal(n, b, op)
}

func Rows_Detailed_Marshal(n jsonexp.Context, val *Rows) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Rows_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Rows,
			Fields: fields,
		})
	}
	return
}

func Rows_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Rows) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Rows, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[Rows_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_Rows, Type_Activity, e)
	}
	return
}

func Rows_Detailed_Optional_Marshal(n jsonexp.Context, val **Rows) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Rows_Detailed_Marshal(n, ptr)
	}
	return
}
func Rows_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Rows) (err error) {
	if len(b) > 0 {
		var el Rows
		if e := Rows_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Rows, e)
		} else {
			*out = &el
		}
	}
	return
}

// SayText Print some bit of text to the player.
type SayText struct {
	Text rt.TextEval `if:"label=_"`
}

func (*SayText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SayText,
		Uses: composer.Type_Flow,
		Lede: "say",
	}
}

const Type_SayText = "say_text"
const SayText_Text = "$TEXT"

func (op *SayText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return SayText_Detailed_Marshal(n, op)
}
func (op *SayText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return SayText_Detailed_Unmarshal(n, b, op)
}

func SayText_Detailed_Marshal(n jsonexp.Context, val *SayText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[SayText_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_SayText,
			Fields: fields,
		})
	}
	return
}

func SayText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *SayText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_SayText, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[SayText_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_SayText, rt.Type_TextEval, e)
	}
	return
}

func SayText_Detailed_Optional_Marshal(n jsonexp.Context, val **SayText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = SayText_Detailed_Marshal(n, ptr)
	}
	return
}
func SayText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **SayText) (err error) {
	if len(b) > 0 {
		var el SayText
		if e := SayText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_SayText, e)
		} else {
			*out = &el
		}
	}
	return
}

// SetTrait Put an object into a particular state.
type SetTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

func (*SetTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SetTrait,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const Type_SetTrait = "set_trait"
const SetTrait_Object = "$OBJECT"
const SetTrait_Trait = "$TRAIT"

func (op *SetTrait) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return SetTrait_Detailed_Marshal(n, op)
}
func (op *SetTrait) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return SetTrait_Detailed_Unmarshal(n, b, op)
}

func SetTrait_Detailed_Marshal(n jsonexp.Context, val *SetTrait) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[SetTrait_Object] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Trait); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[SetTrait_Trait] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_SetTrait,
			Fields: fields,
		})
	}
	return
}

func SetTrait_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *SetTrait) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_SetTrait, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[SetTrait_Object], &out.Object); e != nil {
		err = errutil.New("unmarshaling", Type_SetTrait, rt.Type_TextEval, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[SetTrait_Trait], &out.Trait); e != nil {
		err = errutil.New("unmarshaling", Type_SetTrait, rt.Type_TextEval, e)
	}
	return
}

func SetTrait_Detailed_Optional_Marshal(n jsonexp.Context, val **SetTrait) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = SetTrait_Detailed_Marshal(n, ptr)
	}
	return
}
func SetTrait_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **SetTrait) (err error) {
	if len(b) > 0 {
		var el SetTrait
		if e := SetTrait_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_SetTrait, e)
		} else {
			*out = &el
		}
	}
	return
}

// Singularize Returns the singular form of a plural word. (ex. apple for apples )
type Singularize struct {
	Text rt.TextEval `if:"label=of"`
}

func (*Singularize) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Singularize,
		Uses: composer.Type_Flow,
		Lede: "singular",
	}
}

const Type_Singularize = "singularize"
const Singularize_Text = "$TEXT"

func (op *Singularize) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Singularize_Detailed_Marshal(n, op)
}
func (op *Singularize) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Singularize_Detailed_Unmarshal(n, b, op)
}

func Singularize_Detailed_Marshal(n jsonexp.Context, val *Singularize) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Singularize_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Singularize,
			Fields: fields,
		})
	}
	return
}

func Singularize_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Singularize) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Singularize, e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Singularize_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_Singularize, rt.Type_TextEval, e)
	}
	return
}

func Singularize_Detailed_Optional_Marshal(n jsonexp.Context, val **Singularize) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Singularize_Detailed_Marshal(n, ptr)
	}
	return
}
func Singularize_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Singularize) (err error) {
	if len(b) > 0 {
		var el Singularize
		if e := Singularize_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Singularize, e)
		} else {
			*out = &el
		}
	}
	return
}

// SlashText Separates words with left-leaning slashes &#x27;/&#x27;.
type SlashText struct {
	Do Activity `if:"label=_"`
}

func (*SlashText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SlashText,
		Uses: composer.Type_Flow,
		Lede: "slashes",
	}
}

const Type_SlashText = "slash_text"
const SlashText_Do = "$DO"

func (op *SlashText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return SlashText_Detailed_Marshal(n, op)
}
func (op *SlashText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return SlashText_Detailed_Unmarshal(n, b, op)
}

func SlashText_Detailed_Marshal(n jsonexp.Context, val *SlashText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[SlashText_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_SlashText,
			Fields: fields,
		})
	}
	return
}

func SlashText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *SlashText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_SlashText, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[SlashText_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_SlashText, Type_Activity, e)
	}
	return
}

func SlashText_Detailed_Optional_Marshal(n jsonexp.Context, val **SlashText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = SlashText_Detailed_Marshal(n, ptr)
	}
	return
}
func SlashText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **SlashText) (err error) {
	if len(b) > 0 {
		var el SlashText
		if e := SlashText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_SlashText, e)
		} else {
			*out = &el
		}
	}
	return
}

// Softline Start a new line ( if not already at a new line. )
type Softline struct {
}

func (*Softline) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Softline,
		Uses: composer.Type_Flow,
		Lede: "wbr",
	}
}

const Type_Softline = "softline"

func (op *Softline) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Softline_Detailed_Marshal(n, op)
}
func (op *Softline) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Softline_Detailed_Unmarshal(n, b, op)
}

func Softline_Detailed_Marshal(n jsonexp.Context, val *Softline) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Softline,
			Fields: fields,
		})
	}
	return
}

func Softline_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Softline) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Softline, e)
	}
	return
}

func Softline_Detailed_Optional_Marshal(n jsonexp.Context, val **Softline) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Softline_Detailed_Marshal(n, ptr)
	}
	return
}
func Softline_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Softline) (err error) {
	if len(b) > 0 {
		var el Softline
		if e := Softline_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Softline, e)
		} else {
			*out = &el
		}
	}
	return
}

// SpanText Writes text with spaces between words.
type SpanText struct {
	Do Activity `if:"label=_"`
}

func (*SpanText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SpanText,
		Uses: composer.Type_Flow,
		Lede: "spaces",
	}
}

const Type_SpanText = "span_text"
const SpanText_Do = "$DO"

func (op *SpanText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return SpanText_Detailed_Marshal(n, op)
}
func (op *SpanText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return SpanText_Detailed_Unmarshal(n, b, op)
}

func SpanText_Detailed_Marshal(n jsonexp.Context, val *SpanText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[SpanText_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_SpanText,
			Fields: fields,
		})
	}
	return
}

func SpanText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *SpanText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_SpanText, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[SpanText_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_SpanText, Type_Activity, e)
	}
	return
}

func SpanText_Detailed_Optional_Marshal(n jsonexp.Context, val **SpanText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = SpanText_Detailed_Marshal(n, ptr)
	}
	return
}
func SpanText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **SpanText) (err error) {
	if len(b) > 0 {
		var el SpanText
		if e := SpanText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_SpanText, e)
		} else {
			*out = &el
		}
	}
	return
}

// SumOf Add two numbers.
type SumOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

func (*SumOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_SumOf,
		Uses: composer.Type_Flow,
		Lede: "inc",
	}
}

const Type_SumOf = "sum_of"
const SumOf_A = "$A"
const SumOf_B = "$B"

func (op *SumOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return SumOf_Detailed_Marshal(n, op)
}
func (op *SumOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return SumOf_Detailed_Unmarshal(n, b, op)
}

func SumOf_Detailed_Marshal(n jsonexp.Context, val *SumOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.A); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[SumOf_A] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.B); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[SumOf_B] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_SumOf,
			Fields: fields,
		})
	}
	return
}

func SumOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *SumOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_SumOf, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[SumOf_A], &out.A); e != nil {
		err = errutil.New("unmarshaling", Type_SumOf, rt.Type_NumberEval, e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[SumOf_B], &out.B); e != nil {
		err = errutil.New("unmarshaling", Type_SumOf, rt.Type_NumberEval, e)
	}
	return
}

func SumOf_Detailed_Optional_Marshal(n jsonexp.Context, val **SumOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = SumOf_Detailed_Marshal(n, ptr)
	}
	return
}
func SumOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **SumOf) (err error) {
	if len(b) > 0 {
		var el SumOf
		if e := SumOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_SumOf, e)
		} else {
			*out = &el
		}
	}
	return
}

// TextValue Specify a small bit of text.
type TextValue struct {
	Text string `if:"label=_,type=text"`
}

func (*TextValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TextValue,
		Uses: composer.Type_Flow,
		Lede: "txt",
	}
}

const Type_TextValue = "text_value"
const TextValue_Text = "$TEXT"

func (op *TextValue) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TextValue_Detailed_Marshal(n, op)
}
func (op *TextValue) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TextValue_Detailed_Unmarshal(n, b, op)
}

func TextValue_Detailed_Marshal(n jsonexp.Context, val *TextValue) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TextValue_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_TextValue,
			Fields: fields,
		})
	}
	return
}

func TextValue_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TextValue) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_TextValue, e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[TextValue_Text], &out.Text); e != nil {
		err = errutil.New("unmarshaling", Type_TextValue, value.Type_Text, e)
	}
	return
}

func TextValue_Detailed_Optional_Marshal(n jsonexp.Context, val **TextValue) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TextValue_Detailed_Marshal(n, ptr)
	}
	return
}
func TextValue_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TextValue) (err error) {
	if len(b) > 0 {
		var el TextValue
		if e := TextValue_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_TextValue, e)
		} else {
			*out = &el
		}
	}
	return
}

// Texts Text List: Specifies a set of string values.
type Texts struct {
	Values []string `if:"label=_,type=text"`
}

func (*Texts) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Texts,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const Type_Texts = "texts"
const Texts_Values = "$VALUES"

func (op *Texts) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Texts_Detailed_Marshal(n, op)
}
func (op *Texts) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Texts_Detailed_Unmarshal(n, b, op)
}

func Texts_Detailed_Marshal(n jsonexp.Context, val *Texts) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Repeats_Marshal(n, &val.Values); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Texts_Values] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Texts,
			Fields: fields,
		})
	}
	return
}

func Texts_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Texts) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Texts, e)
	} else if e := value.Text_Detailed_Override_Repeats_Unmarshal(n, msg.Fields[Texts_Values], &out.Values); e != nil {
		err = errutil.New("unmarshaling", Type_Texts, value.Type_Text, e)
	}
	return
}

func Texts_Detailed_Optional_Marshal(n jsonexp.Context, val **Texts) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Texts_Detailed_Marshal(n, ptr)
	}
	return
}
func Texts_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Texts) (err error) {
	if len(b) > 0 {
		var el Texts
		if e := Texts_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Texts, e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_Trigger = "trigger"

func Trigger_Detailed_Marshal(n jsonexp.Context, ptr *Trigger) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Trigger,
			Value: b,
		})
	}
	return
}

func Trigger_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Trigger) (err error) {
	var msg jsonexp.Node
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Trigger, e)
	} else if contents := msg.Value; len(contents) > 0 {
		var inner jsonexp.Node // peek to create the appropriate type
		if e := json.Unmarshal(contents, &inner); e != nil {
			err = errutil.New("unmarshaling inner", Type_Trigger, e)
		} else if ptr, e := n.NewType(inner.Type); e != nil {
			err = errutil.New("unmarshaling", Type_Trigger, e)
		} else if e := ptr.UnmarshalDetailed(n, contents); e != nil {
			err = errutil.New("unmarshaling", Type_Trigger, e)
		} else {
			(*out) = ptr.(Trigger)
		}
	}
	return
}

// TriggerCycle
type TriggerCycle struct {
}

func (*TriggerCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TriggerCycle,
		Uses: composer.Type_Flow,
		Lede: "every",
	}
}

const Type_TriggerCycle = "trigger_cycle"

func (op *TriggerCycle) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TriggerCycle_Detailed_Marshal(n, op)
}
func (op *TriggerCycle) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TriggerCycle_Detailed_Unmarshal(n, b, op)
}

func TriggerCycle_Detailed_Marshal(n jsonexp.Context, val *TriggerCycle) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_TriggerCycle,
			Fields: fields,
		})
	}
	return
}

func TriggerCycle_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TriggerCycle) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_TriggerCycle, e)
	}
	return
}

func TriggerCycle_Detailed_Optional_Marshal(n jsonexp.Context, val **TriggerCycle) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TriggerCycle_Detailed_Marshal(n, ptr)
	}
	return
}
func TriggerCycle_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TriggerCycle) (err error) {
	if len(b) > 0 {
		var el TriggerCycle
		if e := TriggerCycle_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_TriggerCycle, e)
		} else {
			*out = &el
		}
	}
	return
}

// TriggerOnce
type TriggerOnce struct {
}

func (*TriggerOnce) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TriggerOnce,
		Uses: composer.Type_Flow,
		Lede: "at",
	}
}

const Type_TriggerOnce = "trigger_once"

func (op *TriggerOnce) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TriggerOnce_Detailed_Marshal(n, op)
}
func (op *TriggerOnce) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TriggerOnce_Detailed_Unmarshal(n, b, op)
}

func TriggerOnce_Detailed_Marshal(n jsonexp.Context, val *TriggerOnce) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_TriggerOnce,
			Fields: fields,
		})
	}
	return
}

func TriggerOnce_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TriggerOnce) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_TriggerOnce, e)
	}
	return
}

func TriggerOnce_Detailed_Optional_Marshal(n jsonexp.Context, val **TriggerOnce) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TriggerOnce_Detailed_Marshal(n, ptr)
	}
	return
}
func TriggerOnce_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TriggerOnce) (err error) {
	if len(b) > 0 {
		var el TriggerOnce
		if e := TriggerOnce_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_TriggerOnce, e)
		} else {
			*out = &el
		}
	}
	return
}

// TriggerSwitch
type TriggerSwitch struct {
}

func (*TriggerSwitch) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TriggerSwitch,
		Uses: composer.Type_Flow,
		Lede: "after",
	}
}

const Type_TriggerSwitch = "trigger_switch"

func (op *TriggerSwitch) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TriggerSwitch_Detailed_Marshal(n, op)
}
func (op *TriggerSwitch) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TriggerSwitch_Detailed_Unmarshal(n, b, op)
}

func TriggerSwitch_Detailed_Marshal(n jsonexp.Context, val *TriggerSwitch) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_TriggerSwitch,
			Fields: fields,
		})
	}
	return
}

func TriggerSwitch_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TriggerSwitch) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_TriggerSwitch, e)
	}
	return
}

func TriggerSwitch_Detailed_Optional_Marshal(n jsonexp.Context, val **TriggerSwitch) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TriggerSwitch_Detailed_Marshal(n, ptr)
	}
	return
}
func TriggerSwitch_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TriggerSwitch) (err error) {
	if len(b) > 0 {
		var el TriggerSwitch
		if e := TriggerSwitch_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_TriggerSwitch, e)
		} else {
			*out = &el
		}
	}
	return
}

// Unequal The first value doesn&#x27;t equal the second value.
type Unequal struct {
}

func (*Unequal) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Unequal,
		Uses: composer.Type_Flow,
		Lede: "other_than",
	}
}

const Type_Unequal = "unequal"

func (op *Unequal) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Unequal_Detailed_Marshal(n, op)
}
func (op *Unequal) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Unequal_Detailed_Unmarshal(n, b, op)
}

func Unequal_Detailed_Marshal(n jsonexp.Context, val *Unequal) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Unequal,
			Fields: fields,
		})
	}
	return
}

func Unequal_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Unequal) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_Unequal, e)
	}
	return
}

func Unequal_Detailed_Optional_Marshal(n jsonexp.Context, val **Unequal) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Unequal_Detailed_Marshal(n, ptr)
	}
	return
}
func Unequal_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Unequal) (err error) {
	if len(b) > 0 {
		var el Unequal
		if e := Unequal_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_Unequal, e)
		} else {
			*out = &el
		}
	}
	return
}

// While Keep running a series of actions while a condition is true.
type While struct {
	True rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
}

func (*While) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_While,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const Type_While = "while"
const While_True = "$TRUE"
const While_Do = "$DO"

func (op *While) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return While_Detailed_Marshal(n, op)
}
func (op *While) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return While_Detailed_Unmarshal(n, b, op)
}

func While_Detailed_Marshal(n jsonexp.Context, val *While) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.True); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[While_True] = b
	}
	if b, e := Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[While_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_While,
			Fields: fields,
		})
	}
	return
}

func While_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *While) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("unmarshaling", Type_While, e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[While_True], &out.True); e != nil {
		err = errutil.New("unmarshaling", Type_While, rt.Type_BoolEval, e)
	} else if e := Activity_Detailed_Unmarshal(n, msg.Fields[While_Do], &out.Do); e != nil {
		err = errutil.New("unmarshaling", Type_While, Type_Activity, e)
	}
	return
}

func While_Detailed_Optional_Marshal(n jsonexp.Context, val **While) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = While_Detailed_Marshal(n, ptr)
	}
	return
}
func While_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **While) (err error) {
	if len(b) > 0 {
		var el While
		if e := While_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New("unmarshaling", Type_While, e)
		} else {
			*out = &el
		}
	}
	return
}

var Slots = []interface{}{
	(*Brancher)(nil),
	(*Comparator)(nil),
	(*FromSourceFields)(nil),
	(*IntoTargetFields)(nil),
	(*Trigger)(nil),
}

var Slats = []composer.Composer{
	(*Activity)(nil),
	(*AllTrue)(nil),
	(*Always)(nil),
	(*AnyTrue)(nil),
	(*Assign)(nil),
	(*AtLeast)(nil),
	(*AtMost)(nil),
	(*Blankline)(nil),
	(*BoolValue)(nil),
	(*BracketText)(nil),
	(*Break)(nil),
	(*BufferText)(nil),
	(*CallArg)(nil),
	(*CallArgs)(nil),
	(*CallCycle)(nil),
	(*CallMake)(nil),
	(*CallPattern)(nil),
	(*CallSend)(nil),
	(*CallShuffle)(nil),
	(*CallTerminal)(nil),
	(*CallTrigger)(nil),
	(*Capitalize)(nil),
	(*ChooseAction)(nil),
	(*ChooseMore)(nil),
	(*ChooseMoreValue)(nil),
	(*ChooseNothingElse)(nil),
	(*ChooseNum)(nil),
	(*ChooseText)(nil),
	(*ChooseValue)(nil),
	(*CommaText)(nil),
	(*CompareNum)(nil),
	(*CompareText)(nil),
	(*DiffOf)(nil),
	(*During)(nil),
	(*Equal)(nil),
	(*FromBool)(nil),
	(*FromNum)(nil),
	(*FromNumbers)(nil),
	(*FromObj)(nil),
	(*FromRec)(nil),
	(*FromRecord)(nil),
	(*FromRecords)(nil),
	(*FromText)(nil),
	(*FromTexts)(nil),
	(*FromVar)(nil),
	(*GetAtField)(nil),
	(*GetVar)(nil),
	(*GreaterThan)(nil),
	(*HasDominion)(nil),
	(*HasTrait)(nil),
	(*IdOf)(nil),
	(*Includes)(nil),
	(*IntoObj)(nil),
	(*IntoVar)(nil),
	(*IsEmpty)(nil),
	(*IsExactKindOf)(nil),
	(*IsKindOf)(nil),
	(*Join)(nil),
	(*KindOf)(nil),
	(*KindsOf)(nil),
	(*LessThan)(nil),
	(*MakeLowercase)(nil),
	(*MakeReversed)(nil),
	(*MakeSentenceCase)(nil),
	(*MakeTitleCase)(nil),
	(*MakeUppercase)(nil),
	(*Matches)(nil),
	(*NameOf)(nil),
	(*Never)(nil),
	(*Newline)(nil),
	(*Next)(nil),
	(*Not)(nil),
	(*NumValue)(nil),
	(*Numbers)(nil),
	(*ObjectExists)(nil),
	(*Pluralize)(nil),
	(*PrintNum)(nil),
	(*PrintNumWord)(nil),
	(*ProductOf)(nil),
	(*PutAtField)(nil),
	(*QuotientOf)(nil),
	(*RemainderOf)(nil),
	(*Response)(nil),
	(*Row)(nil),
	(*Rows)(nil),
	(*SayText)(nil),
	(*SetTrait)(nil),
	(*Singularize)(nil),
	(*SlashText)(nil),
	(*Softline)(nil),
	(*SpanText)(nil),
	(*SumOf)(nil),
	(*TextValue)(nil),
	(*Texts)(nil),
	(*TriggerCycle)(nil),
	(*TriggerOnce)(nil),
	(*TriggerSwitch)(nil),
	(*Unequal)(nil),
	(*While)(nil),
}
