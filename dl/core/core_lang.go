// Code generated by "makeops"; edit at your own risk.
package core

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// Activity
type Activity struct {
	Exe []rt.Execute `if:"label=_"`
}

func (*Activity) Compose() composer.Spec {
	return composer.Spec{
		Name: "activity",
		Uses: "flow",
		Lede: "act",
	}
}

func (op *Activity) MarshalJSON() (ret []byte, err error) {
	if jsonExe, e := op.MarshalJSONExe(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "activity",
			"value": map[string]json.RawMessage{
				"$EXE": jsonExe,
			},
		})
	}
	return
}

func (op *Activity) MarshalJSONExe() ([]byte, error) {
	return json.Marshal(op.Exe)
}

// AllTrue Returns true if all of the evaluations are true.
type AllTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

func (*AllTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: "all_true",
		Uses: "flow",
		Lede: "all_of",
	}
}

func (op *AllTrue) MarshalJSON() (ret []byte, err error) {
	if jsonTest, e := op.MarshalJSONTest(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "all_true",
			"value": map[string]json.RawMessage{
				"$TEST": jsonTest,
			},
		})
	}
	return
}

func (op *AllTrue) MarshalJSONTest() ([]byte, error) {
	return json.Marshal(op.Test)
}

// Always Returns true.
type Always struct {
}

func (*Always) Compose() composer.Spec {
	return composer.Spec{
		Name: "always",
		Uses: "flow",
	}
}

func (op *Always) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "always",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// AnyTrue Returns true if any of the evaluations are true.
type AnyTrue struct {
	Test []rt.BoolEval `if:"label=_"`
}

func (*AnyTrue) Compose() composer.Spec {
	return composer.Spec{
		Name: "any_true",
		Uses: "flow",
		Lede: "any_of",
	}
}

func (op *AnyTrue) MarshalJSON() (ret []byte, err error) {
	if jsonTest, e := op.MarshalJSONTest(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "any_true",
			"value": map[string]json.RawMessage{
				"$TEST": jsonTest,
			},
		})
	}
	return
}

func (op *AnyTrue) MarshalJSONTest() ([]byte, error) {
	return json.Marshal(op.Test)
}

// Assign Assigns a variable to a value.
type Assign struct {
	Var  value.VariableName `if:"label=_"`
	From rt.Assignment      `if:"label=be"`
}

func (*Assign) Compose() composer.Spec {
	return composer.Spec{
		Name: "assign",
		Uses: "flow",
		Lede: "let",
	}
}

func (op *Assign) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "assign",
			"value": map[string]json.RawMessage{
				"$VAR":  jsonVar,
				"$FROM": jsonFrom,
			},
		})
	}
	return
}

func (op *Assign) MarshalJSONVar() ([]byte, error) {
	return op.Var.MarshalJSON()
}

func (op *Assign) MarshalJSONFrom() ([]byte, error) {
	m := op.From.(json.Marshaler)
	return m.MarshalJSON()
}

// AtLeast The first value is greater than or equal to the second value.
type AtLeast struct {
}

func (*AtLeast) Compose() composer.Spec {
	return composer.Spec{
		Name: "at_least",
		Uses: "flow",
	}
}

func (op *AtLeast) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "at_least",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// AtMost The first value is less than or equal to the second value.
type AtMost struct {
}

func (*AtMost) Compose() composer.Spec {
	return composer.Spec{
		Name: "at_most",
		Uses: "flow",
	}
}

func (op *AtMost) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "at_most",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// Blankline Add a single blank line following some text.
type Blankline struct {
}

func (*Blankline) Compose() composer.Spec {
	return composer.Spec{
		Name: "blankline",
		Uses: "flow",
		Lede: "p",
	}
}

func (op *Blankline) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "blankline",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// BoolValue Specify an explicit true or false value.
type BoolValue struct {
	Bool bool `if:"label=_,type=bool"`
}

func (*BoolValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "bool_value",
		Uses: "flow",
		Lede: "bool",
	}
}

func (op *BoolValue) MarshalJSON() (ret []byte, err error) {
	if jsonBool, e := op.MarshalJSONBool(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "bool_value",
			"value": map[string]json.RawMessage{
				"$BOOL": jsonBool,
			},
		})
	}
	return
}

func (op *BoolValue) MarshalJSONBool() ([]byte, error) {
	// bool override
	var str string
	if op.Bool {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	return m.MarshalJSON()
}

// BracketText Sandwiches text printed during a block and puts them inside parenthesis &#x27;()&#x27;.
type BracketText struct {
	Do Activity `if:"label=_"`
}

func (*BracketText) Compose() composer.Spec {
	return composer.Spec{
		Name: "bracket_text",
		Uses: "flow",
		Lede: "brackets",
	}
}

func (op *BracketText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "bracket_text",
			"value": map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *BracketText) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

// Break In a repeating loop, exit the loop.
type Break struct {
}

func (*Break) Compose() composer.Spec {
	return composer.Spec{
		Name: "break",
		Uses: "flow",
	}
}

func (op *Break) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "break",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// BufferText
type BufferText struct {
	Do Activity `if:"label=_"`
}

func (*BufferText) Compose() composer.Spec {
	return composer.Spec{
		Name: "buffer_text",
		Uses: "flow",
		Lede: "buffers",
	}
}

func (op *BufferText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "buffer_text",
			"value": map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *BufferText) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

// CallArg Runtime version of argument
type CallArg struct {
	Name string        `if:"label=_,type=text"`
	From rt.Assignment `if:"label=from"`
}

func (*CallArg) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_arg",
		Uses: "flow",
		Lede: "inarg",
	}
}

func (op *CallArg) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "call_arg",
			"value": map[string]json.RawMessage{
				"$NAME": jsonName,
				"$FROM": jsonFrom,
			},
		})
	}
	return
}

func (op *CallArg) MarshalJSONName() ([]byte, error) {
	// type override
	m := value.Text{op.Name}
	return m.MarshalJSON()
}

func (op *CallArg) MarshalJSONFrom() ([]byte, error) {
	m := op.From.(json.Marshaler)
	return m.MarshalJSON()
}

// CallArgs Runtime version of arguments
type CallArgs struct {
	Args []CallArg `if:"label=_"`
}

func (*CallArgs) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_args",
		Uses: "flow",
		Lede: "inargs",
	}
}

func (op *CallArgs) MarshalJSON() (ret []byte, err error) {
	if jsonArgs, e := op.MarshalJSONArgs(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "call_args",
			"value": map[string]json.RawMessage{
				"$ARGS": jsonArgs,
			},
		})
	}
	return
}

func (op *CallArgs) MarshalJSONArgs() ([]byte, error) {
	return json.Marshal(op.Args)
}

// CallCycle Runtime version of cycle_text
type CallCycle struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CallCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_cycle",
		Uses: "flow",
		Lede: "cycle",
	}
}

func (op *CallCycle) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "call_cycle",
			"value": map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *CallCycle) MarshalJSONParts() ([]byte, error) {
	return json.Marshal(op.Parts)
}

// CallMake Runtime version of make
type CallMake struct {
	Kind      string   `if:"label=_,type=text"`
	Arguments CallArgs `if:"label=args"`
}

func (*CallMake) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_make",
		Uses: "flow",
	}
}

func (op *CallMake) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "call_make",
			"value": map[string]json.RawMessage{
				"$KIND":      jsonKind,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *CallMake) MarshalJSONKind() ([]byte, error) {
	// type override
	m := value.Text{op.Kind}
	return m.MarshalJSON()
}

func (op *CallMake) MarshalJSONArguments() ([]byte, error) {
	return op.Arguments.MarshalJSON()
}

// CallPattern Runtime version of determine
type CallPattern struct {
	Pattern   value.PatternName `if:"label=_"`
	Arguments CallArgs          `if:"label=args"`
}

func (*CallPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_pattern",
		Uses: "flow",
	}
}

func (op *CallPattern) MarshalJSON() (ret []byte, err error) {
	if jsonPattern, e := op.MarshalJSONPattern(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "call_pattern",
			"value": map[string]json.RawMessage{
				"$PATTERN":   jsonPattern,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *CallPattern) MarshalJSONPattern() ([]byte, error) {
	return op.Pattern.MarshalJSON()
}

func (op *CallPattern) MarshalJSONArguments() ([]byte, error) {
	return op.Arguments.MarshalJSON()
}

// CallSend Runtime version of send
type CallSend struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=to"`
	Arguments CallArgs        `if:"label=args"`
}

func (*CallSend) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_send",
		Uses: "flow",
	}
}

func (op *CallSend) MarshalJSON() (ret []byte, err error) {
	if jsonEvent, e := op.MarshalJSONEvent(); e != nil {
		err = e
	} else if jsonPath, e := op.MarshalJSONPath(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "call_send",
			"value": map[string]json.RawMessage{
				"$EVENT":     jsonEvent,
				"$PATH":      jsonPath,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *CallSend) MarshalJSONEvent() ([]byte, error) {
	// type override
	m := value.Text{op.Event}
	return m.MarshalJSON()
}

func (op *CallSend) MarshalJSONPath() ([]byte, error) {
	m := op.Path.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *CallSend) MarshalJSONArguments() ([]byte, error) {
	return op.Arguments.MarshalJSON()
}

// CallShuffle Runtime version of shuffle_text
type CallShuffle struct {
	At      reader.Position `if:"internal"`
	Parts   []rt.TextEval   `if:"label=_"`
	Indices Shuffler        `if:"internal"`
}

func (*CallShuffle) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_shuffle",
		Uses: "flow",
		Lede: "shuffle",
	}
}

func (op *CallShuffle) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "call_shuffle",
			"value": map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *CallShuffle) MarshalJSONParts() ([]byte, error) {
	return json.Marshal(op.Parts)
}

// CallTerminal Runtime version of stopping_text
type CallTerminal struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CallTerminal) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_terminal",
		Uses: "flow",
		Lede: "stopping",
	}
}

func (op *CallTerminal) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "call_terminal",
			"value": map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *CallTerminal) MarshalJSONParts() ([]byte, error) {
	return json.Marshal(op.Parts)
}

// CallTrigger Runtime version of count_of
type CallTrigger struct {
	At      reader.Position `if:"internal"`
	Trigger Trigger         `if:"label=_"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CallTrigger) Compose() composer.Spec {
	return composer.Spec{
		Name: "call_trigger",
		Uses: "flow",
		Lede: "trigger",
	}
}

func (op *CallTrigger) MarshalJSON() (ret []byte, err error) {
	if jsonTrigger, e := op.MarshalJSONTrigger(); e != nil {
		err = e
	} else if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "call_trigger",
			"value": map[string]json.RawMessage{
				"$TRIGGER": jsonTrigger,
				"$NUM":     jsonNum,
			},
		})
	}
	return
}

func (op *CallTrigger) MarshalJSONTrigger() ([]byte, error) {
	m := op.Trigger.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *CallTrigger) MarshalJSONNum() ([]byte, error) {
	m := op.Num.(json.Marshaler)
	return m.MarshalJSON()
}

// Capitalize Returns new text, with the first letter turned into uppercase.
type Capitalize struct {
	Text rt.TextEval `if:"label=_"`
}

func (*Capitalize) Compose() composer.Spec {
	return composer.Spec{
		Name: "capitalize",
		Uses: "flow",
	}
}

func (op *Capitalize) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "capitalize",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *Capitalize) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// ChooseAction An if statement.
type ChooseAction struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

func (*ChooseAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_action",
		Uses: "flow",
		Lede: "if",
	}
}

func (op *ChooseAction) MarshalJSON() (ret []byte, err error) {
	if jsonIf, e := op.MarshalJSONIf(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "choose_action",
			"value": map[string]json.RawMessage{
				"$IF":   jsonIf,
				"$DO":   jsonDo,
				"$ELSE": jsonElse,
			},
		})
	}
	return
}

func (op *ChooseAction) MarshalJSONIf() ([]byte, error) {
	m := op.If.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseAction) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

func (op *ChooseAction) MarshalJSONElse() ([]byte, error) {
	m := op.Else.(json.Marshaler)
	return m.MarshalJSON()
}

// ChooseMore
type ChooseMore struct {
	If   rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
	Else Brancher    `if:"label=else,optional"`
}

func (*ChooseMore) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_more",
		Uses: "flow",
		Lede: "else_if",
	}
}

func (op *ChooseMore) MarshalJSON() (ret []byte, err error) {
	if jsonIf, e := op.MarshalJSONIf(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "choose_more",
			"value": map[string]json.RawMessage{
				"$IF":   jsonIf,
				"$DO":   jsonDo,
				"$ELSE": jsonElse,
			},
		})
	}
	return
}

func (op *ChooseMore) MarshalJSONIf() ([]byte, error) {
	m := op.If.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseMore) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

func (op *ChooseMore) MarshalJSONElse() ([]byte, error) {
	m := op.Else.(json.Marshaler)
	return m.MarshalJSON()
}

// ChooseMoreValue
type ChooseMoreValue struct {
	Assign string        `if:"label=_,type=text"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

func (*ChooseMoreValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_more_value",
		Uses: "flow",
		Lede: "else_if",
	}
}

func (op *ChooseMoreValue) MarshalJSON() (ret []byte, err error) {
	if jsonAssign, e := op.MarshalJSONAssign(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonFilter, e := op.MarshalJSONFilter(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "choose_more_value",
			"value": map[string]json.RawMessage{
				"$ASSIGN": jsonAssign,
				"$FROM":   jsonFrom,
				"$FILTER": jsonFilter,
				"$DO":     jsonDo,
				"$ELSE":   jsonElse,
			},
		})
	}
	return
}

func (op *ChooseMoreValue) MarshalJSONAssign() ([]byte, error) {
	// type override
	m := value.Text{op.Assign}
	return m.MarshalJSON()
}

func (op *ChooseMoreValue) MarshalJSONFrom() ([]byte, error) {
	m := op.From.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseMoreValue) MarshalJSONFilter() ([]byte, error) {
	m := op.Filter.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseMoreValue) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

func (op *ChooseMoreValue) MarshalJSONElse() ([]byte, error) {
	m := op.Else.(json.Marshaler)
	return m.MarshalJSON()
}

// ChooseNothingElse
type ChooseNothingElse struct {
	Do Activity `if:"label=_"`
}

func (*ChooseNothingElse) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_nothing_else",
		Uses: "flow",
		Lede: "else_do",
	}
}

func (op *ChooseNothingElse) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "choose_nothing_else",
			"value": map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *ChooseNothingElse) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

// ChooseNum Pick one of two numbers based on a boolean test.
type ChooseNum struct {
	If    rt.BoolEval   `if:"label=if"`
	True  rt.NumberEval `if:"label=then"`
	False rt.NumberEval `if:"label=else"`
}

func (*ChooseNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_num",
		Uses: "flow",
		Lede: "num",
	}
}

func (op *ChooseNum) MarshalJSON() (ret []byte, err error) {
	if jsonIf, e := op.MarshalJSONIf(); e != nil {
		err = e
	} else if jsonTrue, e := op.MarshalJSONTrue(); e != nil {
		err = e
	} else if jsonFalse, e := op.MarshalJSONFalse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "choose_num",
			"value": map[string]json.RawMessage{
				"$IF":    jsonIf,
				"$TRUE":  jsonTrue,
				"$FALSE": jsonFalse,
			},
		})
	}
	return
}

func (op *ChooseNum) MarshalJSONIf() ([]byte, error) {
	m := op.If.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseNum) MarshalJSONTrue() ([]byte, error) {
	m := op.True.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseNum) MarshalJSONFalse() ([]byte, error) {
	m := op.False.(json.Marshaler)
	return m.MarshalJSON()
}

// ChooseText Pick one of two strings based on a boolean test.
type ChooseText struct {
	If    rt.BoolEval `if:"label=if"`
	True  rt.TextEval `if:"label=then"`
	False rt.TextEval `if:"label=else"`
}

func (*ChooseText) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_text",
		Uses: "flow",
		Lede: "txt",
	}
}

func (op *ChooseText) MarshalJSON() (ret []byte, err error) {
	if jsonIf, e := op.MarshalJSONIf(); e != nil {
		err = e
	} else if jsonTrue, e := op.MarshalJSONTrue(); e != nil {
		err = e
	} else if jsonFalse, e := op.MarshalJSONFalse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "choose_text",
			"value": map[string]json.RawMessage{
				"$IF":    jsonIf,
				"$TRUE":  jsonTrue,
				"$FALSE": jsonFalse,
			},
		})
	}
	return
}

func (op *ChooseText) MarshalJSONIf() ([]byte, error) {
	m := op.If.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseText) MarshalJSONTrue() ([]byte, error) {
	m := op.True.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseText) MarshalJSONFalse() ([]byte, error) {
	m := op.False.(json.Marshaler)
	return m.MarshalJSON()
}

// ChooseValue An if statement with local assignment.
type ChooseValue struct {
	Assign string        `if:"label=_,type=text"`
	From   rt.Assignment `if:"label=from"`
	Filter rt.BoolEval   `if:"label=and"`
	Do     Activity      `if:"label=do"`
	Else   Brancher      `if:"label=else,optional"`
}

func (*ChooseValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "choose_value",
		Uses: "flow",
		Lede: "if",
	}
}

func (op *ChooseValue) MarshalJSON() (ret []byte, err error) {
	if jsonAssign, e := op.MarshalJSONAssign(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonFilter, e := op.MarshalJSONFilter(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "choose_value",
			"value": map[string]json.RawMessage{
				"$ASSIGN": jsonAssign,
				"$FROM":   jsonFrom,
				"$FILTER": jsonFilter,
				"$DO":     jsonDo,
				"$ELSE":   jsonElse,
			},
		})
	}
	return
}

func (op *ChooseValue) MarshalJSONAssign() ([]byte, error) {
	// type override
	m := value.Text{op.Assign}
	return m.MarshalJSON()
}

func (op *ChooseValue) MarshalJSONFrom() ([]byte, error) {
	m := op.From.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseValue) MarshalJSONFilter() ([]byte, error) {
	m := op.Filter.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ChooseValue) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

func (op *ChooseValue) MarshalJSONElse() ([]byte, error) {
	m := op.Else.(json.Marshaler)
	return m.MarshalJSON()
}

// CommaText Separates words with commas, and &#x27;and&#x27;.
type CommaText struct {
	Do Activity `if:"label=_"`
}

func (*CommaText) Compose() composer.Spec {
	return composer.Spec{
		Name: "comma_text",
		Uses: "flow",
		Lede: "commas",
	}
}

func (op *CommaText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "comma_text",
			"value": map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *CommaText) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

// CompareNum True if eq,ne,gt,lt,ge,le two numbers.
type CompareNum struct {
	A  rt.NumberEval `if:"label=_"`
	Is Comparator    `if:"label=is"`
	B  rt.NumberEval `if:"label=num"`
}

func (*CompareNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "compare_num",
		Uses: "flow",
		Lede: "cmp",
	}
}

func (op *CompareNum) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonIs, e := op.MarshalJSONIs(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "compare_num",
			"value": map[string]json.RawMessage{
				"$A":  jsonA,
				"$IS": jsonIs,
				"$B":  jsonB,
			},
		})
	}
	return
}

func (op *CompareNum) MarshalJSONA() ([]byte, error) {
	m := op.A.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *CompareNum) MarshalJSONIs() ([]byte, error) {
	m := op.Is.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *CompareNum) MarshalJSONB() ([]byte, error) {
	m := op.B.(json.Marshaler)
	return m.MarshalJSON()
}

// CompareText True if eq,ne,gt,lt,ge,le two strings ( lexical. )
type CompareText struct {
	A  rt.TextEval `if:"label=_"`
	Is Comparator  `if:"label=is"`
	B  rt.TextEval `if:"label=txt"`
}

func (*CompareText) Compose() composer.Spec {
	return composer.Spec{
		Name: "compare_text",
		Uses: "flow",
		Lede: "cmp",
	}
}

func (op *CompareText) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonIs, e := op.MarshalJSONIs(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "compare_text",
			"value": map[string]json.RawMessage{
				"$A":  jsonA,
				"$IS": jsonIs,
				"$B":  jsonB,
			},
		})
	}
	return
}

func (op *CompareText) MarshalJSONA() ([]byte, error) {
	m := op.A.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *CompareText) MarshalJSONIs() ([]byte, error) {
	m := op.Is.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *CompareText) MarshalJSONB() ([]byte, error) {
	m := op.B.(json.Marshaler)
	return m.MarshalJSON()
}

// DiffOf Subtract two numbers.
type DiffOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

func (*DiffOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "diff_of",
		Uses: "flow",
		Lede: "dec",
	}
}

func (op *DiffOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "diff_of",
			"value": map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *DiffOf) MarshalJSONA() ([]byte, error) {
	m := op.A.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *DiffOf) MarshalJSONB() ([]byte, error) {
	m := op.B.(json.Marshaler)
	return m.MarshalJSON()
}

// During Decide whether a pattern is running.
type During struct {
	Pattern value.PatternName `if:"label=_"`
}

func (*During) Compose() composer.Spec {
	return composer.Spec{
		Name: "during",
		Uses: "flow",
	}
}

func (op *During) MarshalJSON() (ret []byte, err error) {
	if jsonPattern, e := op.MarshalJSONPattern(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "during",
			"value": map[string]json.RawMessage{
				"$PATTERN": jsonPattern,
			},
		})
	}
	return
}

func (op *During) MarshalJSONPattern() ([]byte, error) {
	return op.Pattern.MarshalJSON()
}

// Equal Two values exactly match.
type Equal struct {
}

func (*Equal) Compose() composer.Spec {
	return composer.Spec{
		Name: "equal",
		Uses: "flow",
		Lede: "equals",
	}
}

func (op *Equal) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "equal",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// FromBool Assigns the calculated boolean value.
type FromBool struct {
	Val rt.BoolEval `if:"label=_"`
}

func (*FromBool) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_bool",
		Uses: "flow",
	}
}

func (op *FromBool) MarshalJSON() (ret []byte, err error) {
	if jsonVal, e := op.MarshalJSONVal(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_bool",
			"value": map[string]json.RawMessage{
				"$VAL": jsonVal,
			},
		})
	}
	return
}

func (op *FromBool) MarshalJSONVal() ([]byte, error) {
	m := op.Val.(json.Marshaler)
	return m.MarshalJSON()
}

// FromNum Assigns the calculated number.
type FromNum struct {
	Val rt.NumberEval `if:"label=_"`
}

func (*FromNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_num",
		Uses: "flow",
	}
}

func (op *FromNum) MarshalJSON() (ret []byte, err error) {
	if jsonVal, e := op.MarshalJSONVal(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_num",
			"value": map[string]json.RawMessage{
				"$VAL": jsonVal,
			},
		})
	}
	return
}

func (op *FromNum) MarshalJSONVal() ([]byte, error) {
	m := op.Val.(json.Marshaler)
	return m.MarshalJSON()
}

// FromNumbers Assigns the calculated numbers.
type FromNumbers struct {
	Vals rt.NumListEval `if:"label=_"`
}

func (*FromNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_numbers",
		Uses: "flow",
		Lede: "from_nums",
	}
}

func (op *FromNumbers) MarshalJSON() (ret []byte, err error) {
	if jsonVals, e := op.MarshalJSONVals(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_numbers",
			"value": map[string]json.RawMessage{
				"$VALS": jsonVals,
			},
		})
	}
	return
}

func (op *FromNumbers) MarshalJSONVals() ([]byte, error) {
	m := op.Vals.(json.Marshaler)
	return m.MarshalJSON()
}

// FromObj Targets an object with a computed name.
type FromObj struct {
	Object rt.TextEval `if:"label=_"`
}

func (*FromObj) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_obj",
		Uses: "flow",
	}
}

func (op *FromObj) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_obj",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *FromObj) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// FromRec Targets a record stored in a record.
type FromRec struct {
	Rec rt.RecordEval `if:"label=_"`
}

func (*FromRec) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_rec",
		Uses: "flow",
	}
}

func (op *FromRec) MarshalJSON() (ret []byte, err error) {
	if jsonRec, e := op.MarshalJSONRec(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_rec",
			"value": map[string]json.RawMessage{
				"$REC": jsonRec,
			},
		})
	}
	return
}

func (op *FromRec) MarshalJSONRec() ([]byte, error) {
	m := op.Rec.(json.Marshaler)
	return m.MarshalJSON()
}

// FromRecord Assigns the calculated record.
type FromRecord struct {
	Val rt.RecordEval `if:"label=_"`
}

func (*FromRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_record",
		Uses: "flow",
		Lede: "from_rec",
	}
}

func (op *FromRecord) MarshalJSON() (ret []byte, err error) {
	if jsonVal, e := op.MarshalJSONVal(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_record",
			"value": map[string]json.RawMessage{
				"$VAL": jsonVal,
			},
		})
	}
	return
}

func (op *FromRecord) MarshalJSONVal() ([]byte, error) {
	m := op.Val.(json.Marshaler)
	return m.MarshalJSON()
}

// FromRecords Assigns the calculated records.
type FromRecords struct {
	Vals rt.RecordListEval `if:"label=_"`
}

func (*FromRecords) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_records",
		Uses: "flow",
		Lede: "from_recs",
	}
}

func (op *FromRecords) MarshalJSON() (ret []byte, err error) {
	if jsonVals, e := op.MarshalJSONVals(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_records",
			"value": map[string]json.RawMessage{
				"$VALS": jsonVals,
			},
		})
	}
	return
}

func (op *FromRecords) MarshalJSONVals() ([]byte, error) {
	m := op.Vals.(json.Marshaler)
	return m.MarshalJSON()
}

// FromText Assigns the calculated piece of text.
type FromText struct {
	Val rt.TextEval `if:"label=_"`
}

func (*FromText) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_text",
		Uses: "flow",
		Lede: "from_txt",
	}
}

func (op *FromText) MarshalJSON() (ret []byte, err error) {
	if jsonVal, e := op.MarshalJSONVal(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_text",
			"value": map[string]json.RawMessage{
				"$VAL": jsonVal,
			},
		})
	}
	return
}

func (op *FromText) MarshalJSONVal() ([]byte, error) {
	m := op.Val.(json.Marshaler)
	return m.MarshalJSON()
}

// FromTexts Assigns the calculated texts.
type FromTexts struct {
	Vals rt.TextListEval `if:"label=_"`
}

func (*FromTexts) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_texts",
		Uses: "flow",
		Lede: "from_txts",
	}
}

func (op *FromTexts) MarshalJSON() (ret []byte, err error) {
	if jsonVals, e := op.MarshalJSONVals(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_texts",
			"value": map[string]json.RawMessage{
				"$VALS": jsonVals,
			},
		})
	}
	return
}

func (op *FromTexts) MarshalJSONVals() ([]byte, error) {
	m := op.Vals.(json.Marshaler)
	return m.MarshalJSON()
}

// FromVar Targets a record stored in a variable.
type FromVar struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_var",
		Uses: "flow",
	}
}

func (op *FromVar) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "from_var",
			"value": map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *FromVar) MarshalJSONVar() ([]byte, error) {
	return op.Var.MarshalJSON()
}

// GetAtField Get a value from a record.
type GetAtField struct {
	Field string           `if:"label=_,type=text"`
	From  FromSourceFields `if:"label=from"`
}

func (*GetAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: "get_at_field",
		Uses: "flow",
		Lede: "get",
	}
}

func (op *GetAtField) MarshalJSON() (ret []byte, err error) {
	if jsonField, e := op.MarshalJSONField(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "get_at_field",
			"value": map[string]json.RawMessage{
				"$FIELD": jsonField,
				"$FROM":  jsonFrom,
			},
		})
	}
	return
}

func (op *GetAtField) MarshalJSONField() ([]byte, error) {
	// type override
	m := value.Text{op.Field}
	return m.MarshalJSON()
}

func (op *GetAtField) MarshalJSONFrom() ([]byte, error) {
	m := op.From.(json.Marshaler)
	return m.MarshalJSON()
}

// GetVar Get Variable: Return the value of the named variable.
type GetVar struct {
	Name value.VariableName `if:"label=_"`
}

func (*GetVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "get_var",
		Uses: "flow",
		Lede: "var",
	}
}

func (op *GetVar) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "get_var",
			"value": map[string]json.RawMessage{
				"$NAME": jsonName,
			},
		})
	}
	return
}

func (op *GetVar) MarshalJSONName() ([]byte, error) {
	return op.Name.MarshalJSON()
}

// GreaterThan The first value is larger than the second value.
type GreaterThan struct {
}

func (*GreaterThan) Compose() composer.Spec {
	return composer.Spec{
		Name: "greater_than",
		Uses: "flow",
	}
}

func (op *GreaterThan) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "greater_than",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// HasDominion
type HasDominion struct {
	Name string `if:"label=_,type=text"`
}

func (*HasDominion) Compose() composer.Spec {
	return composer.Spec{
		Name: "has_dominion",
		Uses: "flow",
	}
}

func (op *HasDominion) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "has_dominion",
			"value": map[string]json.RawMessage{
				"$NAME": jsonName,
			},
		})
	}
	return
}

func (op *HasDominion) MarshalJSONName() ([]byte, error) {
	// type override
	m := value.Text{op.Name}
	return m.MarshalJSON()
}

// HasTrait Return true if the object is currently in the requested state.
type HasTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

func (*HasTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: "has_trait",
		Uses: "flow",
		Lede: "get",
	}
}

func (op *HasTrait) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "has_trait",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
				"$TRAIT":  jsonTrait,
			},
		})
	}
	return
}

func (op *HasTrait) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *HasTrait) MarshalJSONTrait() ([]byte, error) {
	m := op.Trait.(json.Marshaler)
	return m.MarshalJSON()
}

// IdOf A unique object identifier.
type IdOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*IdOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "id_of",
		Uses: "flow",
	}
}

func (op *IdOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "id_of",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *IdOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// Includes True if text contains text.
type Includes struct {
	Text rt.TextEval `if:"label=_"`
	Part rt.TextEval `if:"label=part"`
}

func (*Includes) Compose() composer.Spec {
	return composer.Spec{
		Name: "includes",
		Uses: "flow",
		Lede: "contains",
	}
}

func (op *Includes) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else if jsonPart, e := op.MarshalJSONPart(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "includes",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
				"$PART": jsonPart,
			},
		})
	}
	return
}

func (op *Includes) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *Includes) MarshalJSONPart() ([]byte, error) {
	m := op.Part.(json.Marshaler)
	return m.MarshalJSON()
}

// IntoObj Targets an object with a computed name.
type IntoObj struct {
	Object rt.TextEval `if:"label=_"`
}

func (*IntoObj) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_obj",
		Uses: "flow",
		Lede: "obj",
	}
}

func (op *IntoObj) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "into_obj",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *IntoObj) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// IntoVar Targets an object or record stored in a variable
type IntoVar struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoVar) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_var",
		Uses: "flow",
		Lede: "var",
	}
}

func (op *IntoVar) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "into_var",
			"value": map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *IntoVar) MarshalJSONVar() ([]byte, error) {
	return op.Var.MarshalJSON()
}

// IsEmpty True if the text is empty.
type IsEmpty struct {
	Text rt.TextEval `if:"label=empty"`
}

func (*IsEmpty) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_empty",
		Uses: "flow",
		Lede: "is",
	}
}

func (op *IsEmpty) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "is_empty",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *IsEmpty) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// IsExactKindOf True if the object is exactly the named kind.
type IsExactKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   string      `if:"label=is_exactly,type=text"`
}

func (*IsExactKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_exact_kind_of",
		Uses: "flow",
		Lede: "kind_of",
	}
}

func (op *IsExactKindOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "is_exact_kind_of",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
				"$KIND":   jsonKind,
			},
		})
	}
	return
}

func (op *IsExactKindOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *IsExactKindOf) MarshalJSONKind() ([]byte, error) {
	// type override
	m := value.Text{op.Kind}
	return m.MarshalJSON()
}

// IsKindOf True if the object is compatible with the named kind.
type IsKindOf struct {
	Object rt.TextEval `if:"label=_"`
	Kind   string      `if:"label=is,type=text"`
}

func (*IsKindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "is_kind_of",
		Uses: "flow",
		Lede: "kind_of",
	}
}

func (op *IsKindOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "is_kind_of",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
				"$KIND":   jsonKind,
			},
		})
	}
	return
}

func (op *IsKindOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *IsKindOf) MarshalJSONKind() ([]byte, error) {
	// type override
	m := value.Text{op.Kind}
	return m.MarshalJSON()
}

// Join Returns multiple pieces of text as a single new piece of text.
type Join struct {
	Sep   rt.TextEval   `if:"label=_"`
	Parts []rt.TextEval `if:"label=parts"`
}

func (*Join) Compose() composer.Spec {
	return composer.Spec{
		Name: "join",
		Uses: "flow",
	}
}

func (op *Join) MarshalJSON() (ret []byte, err error) {
	if jsonSep, e := op.MarshalJSONSep(); e != nil {
		err = e
	} else if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "join",
			"value": map[string]json.RawMessage{
				"$SEP":   jsonSep,
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *Join) MarshalJSONSep() ([]byte, error) {
	m := op.Sep.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *Join) MarshalJSONParts() ([]byte, error) {
	return json.Marshal(op.Parts)
}

// KindOf Friendly name of the object&#x27;s kind.
type KindOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*KindOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of",
		Uses: "flow",
	}
}

func (op *KindOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "kind_of",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *KindOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// KindsOf A list of compatible kinds.
type KindsOf struct {
	Kind string `if:"label=_,type=text"`
}

func (*KindsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of",
		Uses: "flow",
	}
}

func (op *KindsOf) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "kinds_of",
			"value": map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *KindsOf) MarshalJSONKind() ([]byte, error) {
	// type override
	m := value.Text{op.Kind}
	return m.MarshalJSON()
}

// LessThan The first value is less than the second value.
type LessThan struct {
}

func (*LessThan) Compose() composer.Spec {
	return composer.Spec{
		Name: "less_than",
		Uses: "flow",
	}
}

func (op *LessThan) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "less_than",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// MakeLowercase Returns new text, with every letter turned into lowercase. For example, &#x27;shout&#x27; from &#x27;SHOUT&#x27;.
type MakeLowercase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeLowercase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_lowercase",
		Uses: "flow",
		Lede: "lower",
	}
}

func (op *MakeLowercase) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "make_lowercase",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeLowercase) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// MakeReversed Returns new text flipped back to front. For example, &#x27;elppA&#x27; from &#x27;Apple&#x27;, or &#x27;noon&#x27; from &#x27;noon&#x27;.
type MakeReversed struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeReversed) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_reversed",
		Uses: "flow",
		Lede: "reverse",
	}
}

func (op *MakeReversed) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "make_reversed",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeReversed) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// MakeSentenceCase Returns new text, start each sentence with a capital letter. For example, &#x27;Empire Apple.&#x27; from &#x27;Empire apple.&#x27;.
type MakeSentenceCase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeSentenceCase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_sentence_case",
		Uses: "flow",
		Lede: "sentence",
	}
}

func (op *MakeSentenceCase) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "make_sentence_case",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeSentenceCase) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// MakeTitleCase Returns new text, starting each word with a capital letter. For example, &#x27;Empire Apple&#x27; from &#x27;empire apple&#x27;.
type MakeTitleCase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeTitleCase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_title_case",
		Uses: "flow",
		Lede: "title",
	}
}

func (op *MakeTitleCase) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "make_title_case",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeTitleCase) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// MakeUppercase Returns new text, with every letter turned into uppercase. For example, &#x27;APPLE&#x27; from &#x27;apple&#x27;.
type MakeUppercase struct {
	Text rt.TextEval `if:"label=_"`
}

func (*MakeUppercase) Compose() composer.Spec {
	return composer.Spec{
		Name: "make_uppercase",
		Uses: "flow",
		Lede: "upper",
	}
}

func (op *MakeUppercase) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "make_uppercase",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *MakeUppercase) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// Matches Determine whether the specified text is similar to the specified regular expression.
type Matches struct {
	Text    rt.TextEval `if:"label=_"`
	Pattern string      `if:"label=to,type=text"`
	Cache   MatchCache  `if:"internal"`
}

func (*Matches) Compose() composer.Spec {
	return composer.Spec{
		Name: "matches",
		Uses: "flow",
	}
}

func (op *Matches) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else if jsonPattern, e := op.MarshalJSONPattern(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "matches",
			"value": map[string]json.RawMessage{
				"$TEXT":    jsonText,
				"$PATTERN": jsonPattern,
			},
		})
	}
	return
}

func (op *Matches) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *Matches) MarshalJSONPattern() ([]byte, error) {
	// type override
	m := value.Text{op.Pattern}
	return m.MarshalJSON()
}

// NameOf Full name of the object.
type NameOf struct {
	Object rt.TextEval `if:"label=_"`
}

func (*NameOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "name_of",
		Uses: "flow",
	}
}

func (op *NameOf) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "name_of",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *NameOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// Never Returns false.
type Never struct {
}

func (*Never) Compose() composer.Spec {
	return composer.Spec{
		Name: "never",
		Uses: "flow",
		Lede: "always",
	}
}

func (op *Never) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "never",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// Newline Start a new line.
type Newline struct {
}

func (*Newline) Compose() composer.Spec {
	return composer.Spec{
		Name: "newline",
		Uses: "flow",
		Lede: "br",
	}
}

func (op *Newline) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "newline",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// Next In a repeating loop, try the next iteration of the loop.
type Next struct {
}

func (*Next) Compose() composer.Spec {
	return composer.Spec{
		Name: "next",
		Uses: "flow",
	}
}

func (op *Next) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "next",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// Not Returns the opposite value.
type Not struct {
	Test rt.BoolEval `if:"label=_"`
}

func (*Not) Compose() composer.Spec {
	return composer.Spec{
		Name: "not",
		Uses: "flow",
	}
}

func (op *Not) MarshalJSON() (ret []byte, err error) {
	if jsonTest, e := op.MarshalJSONTest(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "not",
			"value": map[string]json.RawMessage{
				"$TEST": jsonTest,
			},
		})
	}
	return
}

func (op *Not) MarshalJSONTest() ([]byte, error) {
	m := op.Test.(json.Marshaler)
	return m.MarshalJSON()
}

// NumValue Specify a particular number.
type NumValue struct {
	Num float64 `if:"label=_,type=number"`
}

func (*NumValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "num_value",
		Uses: "flow",
		Lede: "num",
	}
}

func (op *NumValue) MarshalJSON() (ret []byte, err error) {
	if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "num_value",
			"value": map[string]json.RawMessage{
				"$NUM": jsonNum,
			},
		})
	}
	return
}

func (op *NumValue) MarshalJSONNum() ([]byte, error) {
	// type override
	m := value.Number{op.Num}
	return m.MarshalJSON()
}

// Numbers Number List: Specify a list of numbers.
type Numbers struct {
	Values []float64 `if:"label=_,type=number"`
}

func (*Numbers) Compose() composer.Spec {
	return composer.Spec{
		Name: "numbers",
		Uses: "flow",
		Lede: "nums",
	}
}

func (op *Numbers) MarshalJSON() (ret []byte, err error) {
	if jsonValues, e := op.MarshalJSONValues(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "numbers",
			"value": map[string]json.RawMessage{
				"$VALUES": jsonValues,
			},
		})
	}
	return
}

func (op *Numbers) MarshalJSONValues() ([]byte, error) {
	return json.Marshal(op.Values)
}

// ObjectExists Returns whether there is a object of the specified name.
type ObjectExists struct {
	Object rt.TextEval `if:"label=valid"`
}

func (*ObjectExists) Compose() composer.Spec {
	return composer.Spec{
		Name: "object_exists",
		Uses: "flow",
		Lede: "is",
	}
}

func (op *ObjectExists) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "object_exists",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *ObjectExists) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// Pluralize Returns the plural form of a singular word. (ex. apples for apple. )
type Pluralize struct {
	Text rt.TextEval `if:"label=of"`
}

func (*Pluralize) Compose() composer.Spec {
	return composer.Spec{
		Name: "pluralize",
		Uses: "flow",
		Lede: "plural",
	}
}

func (op *Pluralize) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pluralize",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *Pluralize) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// PrintNum Writes a number using numerals, eg. &#x27;1&#x27;.
type PrintNum struct {
	Num rt.NumberEval `if:"label=_"`
}

func (*PrintNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "print_num",
		Uses: "flow",
		Lede: "numeral",
	}
}

func (op *PrintNum) MarshalJSON() (ret []byte, err error) {
	if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "print_num",
			"value": map[string]json.RawMessage{
				"$NUM": jsonNum,
			},
		})
	}
	return
}

func (op *PrintNum) MarshalJSONNum() ([]byte, error) {
	m := op.Num.(json.Marshaler)
	return m.MarshalJSON()
}

// PrintNumWord Writes a number in plain english: eg. &#x27;one&#x27;
type PrintNumWord struct {
	Num rt.NumberEval `if:"label=words"`
}

func (*PrintNumWord) Compose() composer.Spec {
	return composer.Spec{
		Name: "print_num_word",
		Uses: "flow",
		Lede: "numeral",
	}
}

func (op *PrintNumWord) MarshalJSON() (ret []byte, err error) {
	if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "print_num_word",
			"value": map[string]json.RawMessage{
				"$NUM": jsonNum,
			},
		})
	}
	return
}

func (op *PrintNumWord) MarshalJSONNum() ([]byte, error) {
	m := op.Num.(json.Marshaler)
	return m.MarshalJSON()
}

// ProductOf Multiply two numbers.
type ProductOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*ProductOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "product_of",
		Uses: "flow",
		Lede: "mul",
	}
}

func (op *ProductOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "product_of",
			"value": map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *ProductOf) MarshalJSONA() ([]byte, error) {
	m := op.A.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *ProductOf) MarshalJSONB() ([]byte, error) {
	m := op.B.(json.Marshaler)
	return m.MarshalJSON()
}

// PutAtField Put a value into the field of an record or object
type PutAtField struct {
	Into    IntoTargetFields `if:"label=_"`
	From    rt.Assignment    `if:"label=from"`
	AtField string           `if:"label=at,type=text"`
}

func (*PutAtField) Compose() composer.Spec {
	return composer.Spec{
		Name: "put_at_field",
		Uses: "flow",
		Lede: "put",
	}
}

func (op *PutAtField) MarshalJSON() (ret []byte, err error) {
	if jsonInto, e := op.MarshalJSONInto(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonAtField, e := op.MarshalJSONAtField(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "put_at_field",
			"value": map[string]json.RawMessage{
				"$INTO":     jsonInto,
				"$FROM":     jsonFrom,
				"$AT_FIELD": jsonAtField,
			},
		})
	}
	return
}

func (op *PutAtField) MarshalJSONInto() ([]byte, error) {
	m := op.Into.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *PutAtField) MarshalJSONFrom() ([]byte, error) {
	m := op.From.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *PutAtField) MarshalJSONAtField() ([]byte, error) {
	// type override
	m := value.Text{op.AtField}
	return m.MarshalJSON()
}

// QuotientOf Divide one number by another.
type QuotientOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*QuotientOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "quotient_of",
		Uses: "flow",
		Lede: "div",
	}
}

func (op *QuotientOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "quotient_of",
			"value": map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *QuotientOf) MarshalJSONA() ([]byte, error) {
	m := op.A.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *QuotientOf) MarshalJSONB() ([]byte, error) {
	m := op.B.(json.Marshaler)
	return m.MarshalJSON()
}

// RemainderOf Divide one number by another, and return the remainder.
type RemainderOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by"`
}

func (*RemainderOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "remainder_of",
		Uses: "flow",
		Lede: "mod",
	}
}

func (op *RemainderOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "remainder_of",
			"value": map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *RemainderOf) MarshalJSONA() ([]byte, error) {
	m := op.A.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *RemainderOf) MarshalJSONB() ([]byte, error) {
	m := op.B.(json.Marshaler)
	return m.MarshalJSON()
}

// Response Generate text in a replaceable manner.
type Response struct {
	Name string      `if:"label=_,type=text"`
	Text rt.TextEval `if:"label=text,optional"`
}

func (*Response) Compose() composer.Spec {
	return composer.Spec{
		Name: "response",
		Uses: "flow",
	}
}

func (op *Response) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "response",
			"value": map[string]json.RawMessage{
				"$NAME": jsonName,
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *Response) MarshalJSONName() ([]byte, error) {
	// type override
	m := value.Text{op.Name}
	return m.MarshalJSON()
}

func (op *Response) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// Row A single line as part of a group of lines.
type Row struct {
	Do Activity `if:"label=_"`
}

func (*Row) Compose() composer.Spec {
	return composer.Spec{
		Name: "row",
		Uses: "flow",
	}
}

func (op *Row) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "row",
			"value": map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *Row) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

// Rows Group text into successive lines.
type Rows struct {
	Do Activity `if:"label=_"`
}

func (*Rows) Compose() composer.Spec {
	return composer.Spec{
		Name: "rows",
		Uses: "flow",
	}
}

func (op *Rows) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "rows",
			"value": map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *Rows) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

// SayText Print some bit of text to the player.
type SayText struct {
	Text rt.TextEval `if:"label=_"`
}

func (*SayText) Compose() composer.Spec {
	return composer.Spec{
		Name: "say_text",
		Uses: "flow",
		Lede: "say",
	}
}

func (op *SayText) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "say_text",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *SayText) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// SetTrait Put an object into a particular state.
type SetTrait struct {
	Object rt.TextEval `if:"label=obj"`
	Trait  rt.TextEval `if:"label=trait"`
}

func (*SetTrait) Compose() composer.Spec {
	return composer.Spec{
		Name: "set_trait",
		Uses: "flow",
		Lede: "put",
	}
}

func (op *SetTrait) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "set_trait",
			"value": map[string]json.RawMessage{
				"$OBJECT": jsonObject,
				"$TRAIT":  jsonTrait,
			},
		})
	}
	return
}

func (op *SetTrait) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *SetTrait) MarshalJSONTrait() ([]byte, error) {
	m := op.Trait.(json.Marshaler)
	return m.MarshalJSON()
}

// Singularize Returns the singular form of a plural word. (ex. apple for apples )
type Singularize struct {
	Text rt.TextEval `if:"label=of"`
}

func (*Singularize) Compose() composer.Spec {
	return composer.Spec{
		Name: "singularize",
		Uses: "flow",
		Lede: "singular",
	}
}

func (op *Singularize) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "singularize",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *Singularize) MarshalJSONText() ([]byte, error) {
	m := op.Text.(json.Marshaler)
	return m.MarshalJSON()
}

// SlashText Separates words with left-leaning slashes &#x27;/&#x27;.
type SlashText struct {
	Do Activity `if:"label=_"`
}

func (*SlashText) Compose() composer.Spec {
	return composer.Spec{
		Name: "slash_text",
		Uses: "flow",
		Lede: "slashes",
	}
}

func (op *SlashText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "slash_text",
			"value": map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *SlashText) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

// Softline Start a new line ( if not already at a new line. )
type Softline struct {
}

func (*Softline) Compose() composer.Spec {
	return composer.Spec{
		Name: "softline",
		Uses: "flow",
		Lede: "wbr",
	}
}

func (op *Softline) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "softline",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// SpanText Writes text with spaces between words.
type SpanText struct {
	Do Activity `if:"label=_"`
}

func (*SpanText) Compose() composer.Spec {
	return composer.Spec{
		Name: "span_text",
		Uses: "flow",
		Lede: "spaces",
	}
}

func (op *SpanText) MarshalJSON() (ret []byte, err error) {
	if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "span_text",
			"value": map[string]json.RawMessage{
				"$DO": jsonDo,
			},
		})
	}
	return
}

func (op *SpanText) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

// SumOf Add two numbers.
type SumOf struct {
	A rt.NumberEval `if:"label=_"`
	B rt.NumberEval `if:"label=by,optional"`
}

func (*SumOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "sum_of",
		Uses: "flow",
		Lede: "inc",
	}
}

func (op *SumOf) MarshalJSON() (ret []byte, err error) {
	if jsonA, e := op.MarshalJSONA(); e != nil {
		err = e
	} else if jsonB, e := op.MarshalJSONB(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "sum_of",
			"value": map[string]json.RawMessage{
				"$A": jsonA,
				"$B": jsonB,
			},
		})
	}
	return
}

func (op *SumOf) MarshalJSONA() ([]byte, error) {
	m := op.A.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *SumOf) MarshalJSONB() ([]byte, error) {
	m := op.B.(json.Marshaler)
	return m.MarshalJSON()
}

// TextValue Specify a small bit of text.
type TextValue struct {
	Text string `if:"label=_,type=text"`
}

func (*TextValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "text_value",
		Uses: "flow",
		Lede: "txt",
	}
}

func (op *TextValue) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "text_value",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *TextValue) MarshalJSONText() ([]byte, error) {
	// type override
	m := value.Text{op.Text}
	return m.MarshalJSON()
}

// Texts Text List: Specifies a set of string values.
type Texts struct {
	Values []string `if:"label=_,type=text"`
}

func (*Texts) Compose() composer.Spec {
	return composer.Spec{
		Name: "texts",
		Uses: "flow",
		Lede: "txts",
	}
}

func (op *Texts) MarshalJSON() (ret []byte, err error) {
	if jsonValues, e := op.MarshalJSONValues(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "texts",
			"value": map[string]json.RawMessage{
				"$VALUES": jsonValues,
			},
		})
	}
	return
}

func (op *Texts) MarshalJSONValues() ([]byte, error) {
	return json.Marshal(op.Values)
}

// TriggerCycle
type TriggerCycle struct {
}

func (*TriggerCycle) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_cycle",
		Uses: "flow",
		Lede: "every",
	}
}

func (op *TriggerCycle) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "trigger_cycle",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// TriggerOnce
type TriggerOnce struct {
}

func (*TriggerOnce) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_once",
		Uses: "flow",
		Lede: "at",
	}
}

func (op *TriggerOnce) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "trigger_once",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// TriggerSwitch
type TriggerSwitch struct {
}

func (*TriggerSwitch) Compose() composer.Spec {
	return composer.Spec{
		Name: "trigger_switch",
		Uses: "flow",
		Lede: "after",
	}
}

func (op *TriggerSwitch) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "trigger_switch",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// Unequal The first value doesn&#x27;t equal the second value.
type Unequal struct {
}

func (*Unequal) Compose() composer.Spec {
	return composer.Spec{
		Name: "unequal",
		Uses: "flow",
		Lede: "other_than",
	}
}

func (op *Unequal) MarshalJSON() (ret []byte, err error) {
	{
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "unequal",
			"value": map[string]json.RawMessage{},
		})
	}
	return
}

// While Keep running a series of actions while a condition is true.
type While struct {
	True rt.BoolEval `if:"label=_"`
	Do   Activity    `if:"label=do"`
}

func (*While) Compose() composer.Spec {
	return composer.Spec{
		Name: "while",
		Uses: "flow",
		Lede: "repeating",
	}
}

func (op *While) MarshalJSON() (ret []byte, err error) {
	if jsonTrue, e := op.MarshalJSONTrue(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "while",
			"value": map[string]json.RawMessage{
				"$TRUE": jsonTrue,
				"$DO":   jsonDo,
			},
		})
	}
	return
}

func (op *While) MarshalJSONTrue() ([]byte, error) {
	m := op.True.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *While) MarshalJSONDo() ([]byte, error) {
	return op.Do.MarshalJSON()
}

var Slots = []interface{}{
	(*Brancher)(nil),
	(*Comparator)(nil),
	(*FromSourceFields)(nil),
	(*IntoTargetFields)(nil),
	(*Trigger)(nil),
}
var Slats = []composer.Composer{
	(*Activity)(nil),
	(*AllTrue)(nil),
	(*Always)(nil),
	(*AnyTrue)(nil),
	(*Assign)(nil),
	(*AtLeast)(nil),
	(*AtMost)(nil),
	(*Blankline)(nil),
	(*BoolValue)(nil),
	(*BracketText)(nil),
	(*Break)(nil),
	(*BufferText)(nil),
	(*CallArg)(nil),
	(*CallArgs)(nil),
	(*CallCycle)(nil),
	(*CallMake)(nil),
	(*CallPattern)(nil),
	(*CallSend)(nil),
	(*CallShuffle)(nil),
	(*CallTerminal)(nil),
	(*CallTrigger)(nil),
	(*Capitalize)(nil),
	(*ChooseAction)(nil),
	(*ChooseMore)(nil),
	(*ChooseMoreValue)(nil),
	(*ChooseNothingElse)(nil),
	(*ChooseNum)(nil),
	(*ChooseText)(nil),
	(*ChooseValue)(nil),
	(*CommaText)(nil),
	(*CompareNum)(nil),
	(*CompareText)(nil),
	(*DiffOf)(nil),
	(*During)(nil),
	(*Equal)(nil),
	(*FromBool)(nil),
	(*FromNum)(nil),
	(*FromNumbers)(nil),
	(*FromObj)(nil),
	(*FromRec)(nil),
	(*FromRecord)(nil),
	(*FromRecords)(nil),
	(*FromText)(nil),
	(*FromTexts)(nil),
	(*FromVar)(nil),
	(*GetAtField)(nil),
	(*GetVar)(nil),
	(*GreaterThan)(nil),
	(*HasDominion)(nil),
	(*HasTrait)(nil),
	(*IdOf)(nil),
	(*Includes)(nil),
	(*IntoObj)(nil),
	(*IntoVar)(nil),
	(*IsEmpty)(nil),
	(*IsExactKindOf)(nil),
	(*IsKindOf)(nil),
	(*Join)(nil),
	(*KindOf)(nil),
	(*KindsOf)(nil),
	(*LessThan)(nil),
	(*MakeLowercase)(nil),
	(*MakeReversed)(nil),
	(*MakeSentenceCase)(nil),
	(*MakeTitleCase)(nil),
	(*MakeUppercase)(nil),
	(*Matches)(nil),
	(*NameOf)(nil),
	(*Never)(nil),
	(*Newline)(nil),
	(*Next)(nil),
	(*Not)(nil),
	(*NumValue)(nil),
	(*Numbers)(nil),
	(*ObjectExists)(nil),
	(*Pluralize)(nil),
	(*PrintNum)(nil),
	(*PrintNumWord)(nil),
	(*ProductOf)(nil),
	(*PutAtField)(nil),
	(*QuotientOf)(nil),
	(*RemainderOf)(nil),
	(*Response)(nil),
	(*Row)(nil),
	(*Rows)(nil),
	(*SayText)(nil),
	(*SetTrait)(nil),
	(*Singularize)(nil),
	(*SlashText)(nil),
	(*Softline)(nil),
	(*SpanText)(nil),
	(*SumOf)(nil),
	(*TextValue)(nil),
	(*Texts)(nil),
	(*TriggerCycle)(nil),
	(*TriggerOnce)(nil),
	(*TriggerSwitch)(nil),
	(*Unequal)(nil),
	(*While)(nil),
}
