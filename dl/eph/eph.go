package eph

import (
	"git.sr.ht/~ionous/tapestry/dl/literal"
	"git.sr.ht/~ionous/tapestry/imp/assert"
	"git.sr.ht/~ionous/tapestry/jsn"
	"git.sr.ht/~ionous/tapestry/jsn/cout"
	"git.sr.ht/~ionous/tapestry/tables"
	"github.com/ionous/errutil"
)

// database/sql like interface
type Writer interface {
	Write(q string, args ...interface{}) error
}

// turn a function into a writer
type WrappedWriter func(q string, args ...interface{}) error

func (w WrappedWriter) Write(q string, args ...interface{}) error {
	return w(q, args...)
}

// turn a transaction, etc into a writer.
func ExecWriter(db tables.Executer) WrappedWriter {
	return func(q string, args ...interface{}) (err error) {
		if _, e := db.Exec(q, args...); e != nil {
			err = e
		}
		return
	}
}

// implemented by individual commands
type Ephemera interface {
	Phase() assert.Phase
	// the command builder generates commands;
	// this reverse the direction and generates calls to the command builder.
	Weave(assert.Assertions) error
}

//go:generate stringer -type=Phase

type PhaseActions map[assert.Phase]PhaseAction

type PhaseAction struct {
	Flags PhaseFlags
	Do    func(d *Domain) (err error)
}

// wrapper for implementing Ephemera with free functions.
// its a shortcut to defining new ephemera structs for every last processing statement;
// which works because its all the same process space.
// could separate these out into commands for inter-process communication, logging, etc. if ever needed.
type PhaseFunction struct {
	OnPhase assert.Phase
	Do      func(assert.World, assert.Assertions) error
}

func (fn PhaseFunction) Phase() assert.Phase { return fn.OnPhase }

func (fn PhaseFunction) Weave(k assert.Assertions) (err error) {
	return k.Schedule(fn.OnPhase, fn.Do)
}

func (ctx *Context) Schedule(when assert.Phase, do func(assert.World, assert.Assertions) error) (err error) {
	c, d, at := ctx.c, ctx.d, ctx.at
	var writeEph WriterFun = func(op Ephemera) {
		d.QueueEphemera(at, op)
	}
	return do(c, NewCommandBuilder(writeEph))
}

type PhaseFlags struct {
	NoDuplicates bool
}

// shared generic marshal prog to text
func marshalout(cmd interface{}) (ret string, err error) {
	if cmd != nil {
		if m, ok := cmd.(jsn.Marshalee); !ok {
			err = errutil.Fmt("can only marshal autogenerated types (%T)", cmd)
		} else {
			ret, err = cout.Marshal(m, literal.CompactEncoder)
		}
	}
	return
}
