// Code generated by "makeops"; edit at your own risk.
package eph

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/jsn"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// Affinity requires a predefined string.
type Affinity struct {
	Str string
}

func (op *Affinity) String() string {
	return op.Str
}

const Affinity_Bool = "$BOOL"
const Affinity_Number = "$NUMBER"
const Affinity_NumList = "$NUM_LIST"
const Affinity_Text = "$TEXT"
const Affinity_TextList = "$TEXT_LIST"
const Affinity_Record = "$RECORD"
const Affinity_RecordList = "$RECORD_LIST"

func (*Affinity) Compose() composer.Spec {
	return composer.Spec{
		Name: Affinity_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			Affinity_Bool, Affinity_Number, Affinity_NumList, Affinity_Text, Affinity_TextList, Affinity_Record, Affinity_RecordList,
		},
		Strings: []string{
			"bool", "number", "num_list", "text", "text_list", "record", "record_list",
		},
	}
}

const Affinity_Type = "affinity"

func (op *Affinity) Marshal(m jsn.Marshaler) error {
	return Affinity_Marshal(m, op)
}

func Affinity_Optional_Marshal(m jsn.Marshaler, val *Affinity) (err error) {
	var zero Affinity
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = Affinity_Marshal(m, val)
	}
	return
}

func Affinity_Marshal(m jsn.Marshaler, val *Affinity) (err error) {
	return m.MarshalValue(Affinity_Type, jsn.MakeEnum(val, &val.Str))
}

type Affinity_Slice []Affinity

func (op *Affinity_Slice) GetType() string { return Affinity_Type }

func (op *Affinity_Slice) Marshal(m jsn.Marshaler) error {
	return Affinity_Repeats_Marshal(m, (*[]Affinity)(op))
}

func (op *Affinity_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Affinity_Slice) SetSize(cnt int) {
	var els []Affinity
	if cnt >= 0 {
		els = make(Affinity_Slice, cnt)
	}
	(*op) = els
}

func (op *Affinity_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Affinity_Marshal(m, &(*op)[i])
}

func Affinity_Repeats_Marshal(m jsn.Marshaler, vals *[]Affinity) error {
	return jsn.RepeatBlock(m, (*Affinity_Slice)(vals))
}

func Affinity_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Affinity) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = Affinity_Repeats_Marshal(m, pv)
	}
	return
}

// EphAspects A set of related object states such that exactly one member of the set is true for a given object at a single time.
// Generates an implicit kind of 'aspect' where every field of the kind is a boolean property.
// User implements: Ephemera.
type EphAspects struct {
	Aspects string   `if:"label=aspects,type=text"`
	Traits  []string `if:"label=traits,type=text"`
}

func (*EphAspects) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAspects_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphAspects_Type = "eph_aspects"

const EphAspects_Field_Aspects = "$ASPECTS"
const EphAspects_Field_Traits = "$TRAITS"

func (op *EphAspects) Marshal(m jsn.Marshaler) error {
	return EphAspects_Marshal(m, op)
}

type EphAspects_Slice []EphAspects

func (op *EphAspects_Slice) GetType() string { return EphAspects_Type }

func (op *EphAspects_Slice) Marshal(m jsn.Marshaler) error {
	return EphAspects_Repeats_Marshal(m, (*[]EphAspects)(op))
}

func (op *EphAspects_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAspects_Slice) SetSize(cnt int) {
	var els []EphAspects
	if cnt >= 0 {
		els = make(EphAspects_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAspects_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAspects_Marshal(m, &(*op)[i])
}

func EphAspects_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAspects) error {
	return jsn.RepeatBlock(m, (*EphAspects_Slice)(vals))
}

func EphAspects_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAspects) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphAspects_Repeats_Marshal(m, pv)
	}
	return
}

type EphAspects_Flow struct{ ptr *EphAspects }

func (n EphAspects_Flow) GetType() string      { return EphAspects_Type }
func (n EphAspects_Flow) GetLede() string      { return "eph" }
func (n EphAspects_Flow) GetFlow() interface{} { return n.ptr }
func (n EphAspects_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphAspects); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphAspects_Optional_Marshal(m jsn.Marshaler, pv **EphAspects) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphAspects_Marshal(m, *pv)
	} else if !enc {
		var v EphAspects
		if err = EphAspects_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphAspects_Marshal(m jsn.Marshaler, val *EphAspects) (err error) {
	if err = m.MarshalBlock(EphAspects_Flow{val}); err == nil {
		e0 := m.MarshalKey("aspects", EphAspects_Field_Aspects)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Aspects)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphAspects_Field_Aspects))
		}
		e1 := m.MarshalKey("traits", EphAspects_Field_Traits)
		if e1 == nil {
			e1 = value.Text_Unboxed_Repeats_Marshal(m, &val.Traits)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphAspects_Field_Traits))
		}
		m.EndBlock()
	}
	return
}

// EphAt
type EphAt struct {
	At  string   `if:"label=at,type=text"`
	Eph Ephemera `if:"label=eph"`
}

func (*EphAt) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAt_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphAt_Type = "eph_at"

const EphAt_Field_At = "$AT"
const EphAt_Field_Eph = "$EPH"

func (op *EphAt) Marshal(m jsn.Marshaler) error {
	return EphAt_Marshal(m, op)
}

type EphAt_Slice []EphAt

func (op *EphAt_Slice) GetType() string { return EphAt_Type }

func (op *EphAt_Slice) Marshal(m jsn.Marshaler) error {
	return EphAt_Repeats_Marshal(m, (*[]EphAt)(op))
}

func (op *EphAt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAt_Slice) SetSize(cnt int) {
	var els []EphAt
	if cnt >= 0 {
		els = make(EphAt_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAt_Marshal(m, &(*op)[i])
}

func EphAt_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAt) error {
	return jsn.RepeatBlock(m, (*EphAt_Slice)(vals))
}

func EphAt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAt) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphAt_Repeats_Marshal(m, pv)
	}
	return
}

type EphAt_Flow struct{ ptr *EphAt }

func (n EphAt_Flow) GetType() string      { return EphAt_Type }
func (n EphAt_Flow) GetLede() string      { return "eph" }
func (n EphAt_Flow) GetFlow() interface{} { return n.ptr }
func (n EphAt_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphAt); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphAt_Optional_Marshal(m jsn.Marshaler, pv **EphAt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphAt_Marshal(m, *pv)
	} else if !enc {
		var v EphAt
		if err = EphAt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphAt_Marshal(m jsn.Marshaler, val *EphAt) (err error) {
	if err = m.MarshalBlock(EphAt_Flow{val}); err == nil {
		e0 := m.MarshalKey("at", EphAt_Field_At)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.At)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphAt_Field_At))
		}
		e1 := m.MarshalKey("eph", EphAt_Field_Eph)
		if e1 == nil {
			e1 = Ephemera_Marshal(m, &val.Eph)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphAt_Field_Eph))
		}
		m.EndBlock()
	}
	return
}

// EphBeginDomain
// User implements: Ephemera.
type EphBeginDomain struct {
	Name     string   `if:"label=domain,type=text"`
	Requires []string `if:"label=requires,type=text"`
}

func (*EphBeginDomain) Compose() composer.Spec {
	return composer.Spec{
		Name: EphBeginDomain_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphBeginDomain_Type = "eph_begin_domain"

const EphBeginDomain_Field_Name = "$NAME"
const EphBeginDomain_Field_Requires = "$REQUIRES"

func (op *EphBeginDomain) Marshal(m jsn.Marshaler) error {
	return EphBeginDomain_Marshal(m, op)
}

type EphBeginDomain_Slice []EphBeginDomain

func (op *EphBeginDomain_Slice) GetType() string { return EphBeginDomain_Type }

func (op *EphBeginDomain_Slice) Marshal(m jsn.Marshaler) error {
	return EphBeginDomain_Repeats_Marshal(m, (*[]EphBeginDomain)(op))
}

func (op *EphBeginDomain_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphBeginDomain_Slice) SetSize(cnt int) {
	var els []EphBeginDomain
	if cnt >= 0 {
		els = make(EphBeginDomain_Slice, cnt)
	}
	(*op) = els
}

func (op *EphBeginDomain_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphBeginDomain_Marshal(m, &(*op)[i])
}

func EphBeginDomain_Repeats_Marshal(m jsn.Marshaler, vals *[]EphBeginDomain) error {
	return jsn.RepeatBlock(m, (*EphBeginDomain_Slice)(vals))
}

func EphBeginDomain_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphBeginDomain) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphBeginDomain_Repeats_Marshal(m, pv)
	}
	return
}

type EphBeginDomain_Flow struct{ ptr *EphBeginDomain }

func (n EphBeginDomain_Flow) GetType() string      { return EphBeginDomain_Type }
func (n EphBeginDomain_Flow) GetLede() string      { return "eph" }
func (n EphBeginDomain_Flow) GetFlow() interface{} { return n.ptr }
func (n EphBeginDomain_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphBeginDomain); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphBeginDomain_Optional_Marshal(m jsn.Marshaler, pv **EphBeginDomain) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphBeginDomain_Marshal(m, *pv)
	} else if !enc {
		var v EphBeginDomain
		if err = EphBeginDomain_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphBeginDomain_Marshal(m jsn.Marshaler, val *EphBeginDomain) (err error) {
	if err = m.MarshalBlock(EphBeginDomain_Flow{val}); err == nil {
		e0 := m.MarshalKey("domain", EphBeginDomain_Field_Name)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphBeginDomain_Field_Name))
		}
		e1 := m.MarshalKey("requires", EphBeginDomain_Field_Requires)
		if e1 == nil {
			e1 = value.Text_Unboxed_Repeats_Marshal(m, &val.Requires)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphBeginDomain_Field_Requires))
		}
		m.EndBlock()
	}
	return
}

// EphCheckPrint
// User implements: Ephemera.
type EphCheckPrint struct {
	Name string `if:"label=check,type=text"`
	Text string `if:"label=prints,type=text"`
}

func (*EphCheckPrint) Compose() composer.Spec {
	return composer.Spec{
		Name: EphCheckPrint_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphCheckPrint_Type = "eph_check_print"

const EphCheckPrint_Field_Name = "$NAME"
const EphCheckPrint_Field_Text = "$TEXT"

func (op *EphCheckPrint) Marshal(m jsn.Marshaler) error {
	return EphCheckPrint_Marshal(m, op)
}

type EphCheckPrint_Slice []EphCheckPrint

func (op *EphCheckPrint_Slice) GetType() string { return EphCheckPrint_Type }

func (op *EphCheckPrint_Slice) Marshal(m jsn.Marshaler) error {
	return EphCheckPrint_Repeats_Marshal(m, (*[]EphCheckPrint)(op))
}

func (op *EphCheckPrint_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphCheckPrint_Slice) SetSize(cnt int) {
	var els []EphCheckPrint
	if cnt >= 0 {
		els = make(EphCheckPrint_Slice, cnt)
	}
	(*op) = els
}

func (op *EphCheckPrint_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphCheckPrint_Marshal(m, &(*op)[i])
}

func EphCheckPrint_Repeats_Marshal(m jsn.Marshaler, vals *[]EphCheckPrint) error {
	return jsn.RepeatBlock(m, (*EphCheckPrint_Slice)(vals))
}

func EphCheckPrint_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphCheckPrint) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphCheckPrint_Repeats_Marshal(m, pv)
	}
	return
}

type EphCheckPrint_Flow struct{ ptr *EphCheckPrint }

func (n EphCheckPrint_Flow) GetType() string      { return EphCheckPrint_Type }
func (n EphCheckPrint_Flow) GetLede() string      { return "eph" }
func (n EphCheckPrint_Flow) GetFlow() interface{} { return n.ptr }
func (n EphCheckPrint_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphCheckPrint); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphCheckPrint_Optional_Marshal(m jsn.Marshaler, pv **EphCheckPrint) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphCheckPrint_Marshal(m, *pv)
	} else if !enc {
		var v EphCheckPrint
		if err = EphCheckPrint_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphCheckPrint_Marshal(m jsn.Marshaler, val *EphCheckPrint) (err error) {
	if err = m.MarshalBlock(EphCheckPrint_Flow{val}); err == nil {
		e0 := m.MarshalKey("check", EphCheckPrint_Field_Name)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphCheckPrint_Field_Name))
		}
		e1 := m.MarshalKey("prints", EphCheckPrint_Field_Text)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.Text)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphCheckPrint_Field_Text))
		}
		m.EndBlock()
	}
	return
}

// EphEndDomain
// User implements: Ephemera.
type EphEndDomain struct {
	Name string `if:"label=domain,type=text"`
}

func (*EphEndDomain) Compose() composer.Spec {
	return composer.Spec{
		Name: EphEndDomain_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphEndDomain_Type = "eph_end_domain"

const EphEndDomain_Field_Name = "$NAME"

func (op *EphEndDomain) Marshal(m jsn.Marshaler) error {
	return EphEndDomain_Marshal(m, op)
}

type EphEndDomain_Slice []EphEndDomain

func (op *EphEndDomain_Slice) GetType() string { return EphEndDomain_Type }

func (op *EphEndDomain_Slice) Marshal(m jsn.Marshaler) error {
	return EphEndDomain_Repeats_Marshal(m, (*[]EphEndDomain)(op))
}

func (op *EphEndDomain_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphEndDomain_Slice) SetSize(cnt int) {
	var els []EphEndDomain
	if cnt >= 0 {
		els = make(EphEndDomain_Slice, cnt)
	}
	(*op) = els
}

func (op *EphEndDomain_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphEndDomain_Marshal(m, &(*op)[i])
}

func EphEndDomain_Repeats_Marshal(m jsn.Marshaler, vals *[]EphEndDomain) error {
	return jsn.RepeatBlock(m, (*EphEndDomain_Slice)(vals))
}

func EphEndDomain_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphEndDomain) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphEndDomain_Repeats_Marshal(m, pv)
	}
	return
}

type EphEndDomain_Flow struct{ ptr *EphEndDomain }

func (n EphEndDomain_Flow) GetType() string      { return EphEndDomain_Type }
func (n EphEndDomain_Flow) GetLede() string      { return "eph" }
func (n EphEndDomain_Flow) GetFlow() interface{} { return n.ptr }
func (n EphEndDomain_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphEndDomain); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphEndDomain_Optional_Marshal(m jsn.Marshaler, pv **EphEndDomain) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphEndDomain_Marshal(m, *pv)
	} else if !enc {
		var v EphEndDomain
		if err = EphEndDomain_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphEndDomain_Marshal(m jsn.Marshaler, val *EphEndDomain) (err error) {
	if err = m.MarshalBlock(EphEndDomain_Flow{val}); err == nil {
		e0 := m.MarshalKey("domain", EphEndDomain_Field_Name)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphEndDomain_Field_Name))
		}
		m.EndBlock()
	}
	return
}

// EphFields Contents of a kind.
// 'Affinity' designates the storage type of a given field
// while 'class' is used to indicate an interpretation of that field, for example a reference to a kind.
// User implements: Ephemera.
type EphFields struct {
	Kinds    string   `if:"label=kinds,type=text"`
	Affinity Affinity `if:"label=have"`
	Name     string   `if:"label=called,type=text"`
	Class    string   `if:"label=of,optional,type=text"`
}

func (*EphFields) Compose() composer.Spec {
	return composer.Spec{
		Name: EphFields_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphFields_Type = "eph_fields"

const EphFields_Field_Kinds = "$KINDS"
const EphFields_Field_Affinity = "$AFFINITY"
const EphFields_Field_Name = "$NAME"
const EphFields_Field_Class = "$CLASS"

func (op *EphFields) Marshal(m jsn.Marshaler) error {
	return EphFields_Marshal(m, op)
}

type EphFields_Slice []EphFields

func (op *EphFields_Slice) GetType() string { return EphFields_Type }

func (op *EphFields_Slice) Marshal(m jsn.Marshaler) error {
	return EphFields_Repeats_Marshal(m, (*[]EphFields)(op))
}

func (op *EphFields_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphFields_Slice) SetSize(cnt int) {
	var els []EphFields
	if cnt >= 0 {
		els = make(EphFields_Slice, cnt)
	}
	(*op) = els
}

func (op *EphFields_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphFields_Marshal(m, &(*op)[i])
}

func EphFields_Repeats_Marshal(m jsn.Marshaler, vals *[]EphFields) error {
	return jsn.RepeatBlock(m, (*EphFields_Slice)(vals))
}

func EphFields_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphFields) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphFields_Repeats_Marshal(m, pv)
	}
	return
}

type EphFields_Flow struct{ ptr *EphFields }

func (n EphFields_Flow) GetType() string      { return EphFields_Type }
func (n EphFields_Flow) GetLede() string      { return "eph" }
func (n EphFields_Flow) GetFlow() interface{} { return n.ptr }
func (n EphFields_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphFields); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphFields_Optional_Marshal(m jsn.Marshaler, pv **EphFields) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphFields_Marshal(m, *pv)
	} else if !enc {
		var v EphFields
		if err = EphFields_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphFields_Marshal(m jsn.Marshaler, val *EphFields) (err error) {
	if err = m.MarshalBlock(EphFields_Flow{val}); err == nil {
		e0 := m.MarshalKey("kinds", EphFields_Field_Kinds)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphFields_Field_Kinds))
		}
		e1 := m.MarshalKey("have", EphFields_Field_Affinity)
		if e1 == nil {
			e1 = Affinity_Marshal(m, &val.Affinity)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphFields_Field_Affinity))
		}
		e2 := m.MarshalKey("called", EphFields_Field_Name)
		if e2 == nil {
			e2 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphFields_Field_Name))
		}
		e3 := m.MarshalKey("of", EphFields_Field_Class)
		if e3 == nil {
			e3 = value.Text_Unboxed_Optional_Marshal(m, &val.Class)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", EphFields_Field_Class))
		}
		m.EndBlock()
	}
	return
}

// EphKinds A new type deriving from another existing type.
// The new kind has all of the properties of all of its ancestor kinds
// and it can be used wherever one of its ancestor kinds is needed.
// ( The reverse isn't true because the new kind can have its own unique properties not available to its ancestors. )
// User implements: Ephemera.
type EphKinds struct {
	Kinds string `if:"label=kinds,type=text"`
	From  string `if:"label=from,type=text"`
}

func (*EphKinds) Compose() composer.Spec {
	return composer.Spec{
		Name: EphKinds_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphKinds_Type = "eph_kinds"

const EphKinds_Field_Kinds = "$KINDS"
const EphKinds_Field_From = "$FROM"

func (op *EphKinds) Marshal(m jsn.Marshaler) error {
	return EphKinds_Marshal(m, op)
}

type EphKinds_Slice []EphKinds

func (op *EphKinds_Slice) GetType() string { return EphKinds_Type }

func (op *EphKinds_Slice) Marshal(m jsn.Marshaler) error {
	return EphKinds_Repeats_Marshal(m, (*[]EphKinds)(op))
}

func (op *EphKinds_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphKinds_Slice) SetSize(cnt int) {
	var els []EphKinds
	if cnt >= 0 {
		els = make(EphKinds_Slice, cnt)
	}
	(*op) = els
}

func (op *EphKinds_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphKinds_Marshal(m, &(*op)[i])
}

func EphKinds_Repeats_Marshal(m jsn.Marshaler, vals *[]EphKinds) error {
	return jsn.RepeatBlock(m, (*EphKinds_Slice)(vals))
}

func EphKinds_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphKinds) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphKinds_Repeats_Marshal(m, pv)
	}
	return
}

type EphKinds_Flow struct{ ptr *EphKinds }

func (n EphKinds_Flow) GetType() string      { return EphKinds_Type }
func (n EphKinds_Flow) GetLede() string      { return "eph" }
func (n EphKinds_Flow) GetFlow() interface{} { return n.ptr }
func (n EphKinds_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphKinds); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphKinds_Optional_Marshal(m jsn.Marshaler, pv **EphKinds) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphKinds_Marshal(m, *pv)
	} else if !enc {
		var v EphKinds
		if err = EphKinds_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphKinds_Marshal(m jsn.Marshaler, val *EphKinds) (err error) {
	if err = m.MarshalBlock(EphKinds_Flow{val}); err == nil {
		e0 := m.MarshalKey("kinds", EphKinds_Field_Kinds)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphKinds_Field_Kinds))
		}
		e1 := m.MarshalKey("from", EphKinds_Field_From)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphKinds_Field_From))
		}
		m.EndBlock()
	}
	return
}

// EphList
type EphList struct {
	All []EphAt `if:"label=list"`
}

func (*EphList) Compose() composer.Spec {
	return composer.Spec{
		Name: EphList_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphList_Type = "eph_list"

const EphList_Field_All = "$ALL"

func (op *EphList) Marshal(m jsn.Marshaler) error {
	return EphList_Marshal(m, op)
}

type EphList_Slice []EphList

func (op *EphList_Slice) GetType() string { return EphList_Type }

func (op *EphList_Slice) Marshal(m jsn.Marshaler) error {
	return EphList_Repeats_Marshal(m, (*[]EphList)(op))
}

func (op *EphList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphList_Slice) SetSize(cnt int) {
	var els []EphList
	if cnt >= 0 {
		els = make(EphList_Slice, cnt)
	}
	(*op) = els
}

func (op *EphList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphList_Marshal(m, &(*op)[i])
}

func EphList_Repeats_Marshal(m jsn.Marshaler, vals *[]EphList) error {
	return jsn.RepeatBlock(m, (*EphList_Slice)(vals))
}

func EphList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphList) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphList_Repeats_Marshal(m, pv)
	}
	return
}

type EphList_Flow struct{ ptr *EphList }

func (n EphList_Flow) GetType() string      { return EphList_Type }
func (n EphList_Flow) GetLede() string      { return "eph" }
func (n EphList_Flow) GetFlow() interface{} { return n.ptr }
func (n EphList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphList_Optional_Marshal(m jsn.Marshaler, pv **EphList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphList_Marshal(m, *pv)
	} else if !enc {
		var v EphList
		if err = EphList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphList_Marshal(m jsn.Marshaler, val *EphList) (err error) {
	if err = m.MarshalBlock(EphList_Flow{val}); err == nil {
		e0 := m.MarshalKey("list", EphList_Field_All)
		if e0 == nil {
			e0 = EphAt_Repeats_Marshal(m, &val.All)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphList_Field_All))
		}
		m.EndBlock()
	}
	return
}

// EphNameRef
// User implements: Ephemera.
type EphNameRef struct {
	Name string `if:"label=ref,type=text"`
	Type string `if:"label=of,type=text"`
}

func (*EphNameRef) Compose() composer.Spec {
	return composer.Spec{
		Name: EphNameRef_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphNameRef_Type = "eph_name_ref"

const EphNameRef_Field_Name = "$NAME"
const EphNameRef_Field_Type = "$TYPE"

func (op *EphNameRef) Marshal(m jsn.Marshaler) error {
	return EphNameRef_Marshal(m, op)
}

type EphNameRef_Slice []EphNameRef

func (op *EphNameRef_Slice) GetType() string { return EphNameRef_Type }

func (op *EphNameRef_Slice) Marshal(m jsn.Marshaler) error {
	return EphNameRef_Repeats_Marshal(m, (*[]EphNameRef)(op))
}

func (op *EphNameRef_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphNameRef_Slice) SetSize(cnt int) {
	var els []EphNameRef
	if cnt >= 0 {
		els = make(EphNameRef_Slice, cnt)
	}
	(*op) = els
}

func (op *EphNameRef_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphNameRef_Marshal(m, &(*op)[i])
}

func EphNameRef_Repeats_Marshal(m jsn.Marshaler, vals *[]EphNameRef) error {
	return jsn.RepeatBlock(m, (*EphNameRef_Slice)(vals))
}

func EphNameRef_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphNameRef) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphNameRef_Repeats_Marshal(m, pv)
	}
	return
}

type EphNameRef_Flow struct{ ptr *EphNameRef }

func (n EphNameRef_Flow) GetType() string      { return EphNameRef_Type }
func (n EphNameRef_Flow) GetLede() string      { return "eph" }
func (n EphNameRef_Flow) GetFlow() interface{} { return n.ptr }
func (n EphNameRef_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphNameRef); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphNameRef_Optional_Marshal(m jsn.Marshaler, pv **EphNameRef) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphNameRef_Marshal(m, *pv)
	} else if !enc {
		var v EphNameRef
		if err = EphNameRef_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphNameRef_Marshal(m jsn.Marshaler, val *EphNameRef) (err error) {
	if err = m.MarshalBlock(EphNameRef_Flow{val}); err == nil {
		e0 := m.MarshalKey("ref", EphNameRef_Field_Name)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphNameRef_Field_Name))
		}
		e1 := m.MarshalKey("of", EphNameRef_Field_Type)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphNameRef_Field_Type))
		}
		m.EndBlock()
	}
	return
}

// EphPlurals Rules for transforming plural text to singular text and back again.
// Used by the assembler to help interpret author definitions,
// and at runtime to help the parser interpret user input.
// User implements: Ephemera.
type EphPlurals struct {
	Plural   string `if:"label=plural,type=text"`
	Singular string `if:"label=singular,type=text"`
}

func (*EphPlurals) Compose() composer.Spec {
	return composer.Spec{
		Name: EphPlurals_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphPlurals_Type = "eph_plurals"

const EphPlurals_Field_Plural = "$PLURAL"
const EphPlurals_Field_Singular = "$SINGULAR"

func (op *EphPlurals) Marshal(m jsn.Marshaler) error {
	return EphPlurals_Marshal(m, op)
}

type EphPlurals_Slice []EphPlurals

func (op *EphPlurals_Slice) GetType() string { return EphPlurals_Type }

func (op *EphPlurals_Slice) Marshal(m jsn.Marshaler) error {
	return EphPlurals_Repeats_Marshal(m, (*[]EphPlurals)(op))
}

func (op *EphPlurals_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphPlurals_Slice) SetSize(cnt int) {
	var els []EphPlurals
	if cnt >= 0 {
		els = make(EphPlurals_Slice, cnt)
	}
	(*op) = els
}

func (op *EphPlurals_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphPlurals_Marshal(m, &(*op)[i])
}

func EphPlurals_Repeats_Marshal(m jsn.Marshaler, vals *[]EphPlurals) error {
	return jsn.RepeatBlock(m, (*EphPlurals_Slice)(vals))
}

func EphPlurals_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphPlurals) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphPlurals_Repeats_Marshal(m, pv)
	}
	return
}

type EphPlurals_Flow struct{ ptr *EphPlurals }

func (n EphPlurals_Flow) GetType() string      { return EphPlurals_Type }
func (n EphPlurals_Flow) GetLede() string      { return "eph" }
func (n EphPlurals_Flow) GetFlow() interface{} { return n.ptr }
func (n EphPlurals_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphPlurals); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphPlurals_Optional_Marshal(m jsn.Marshaler, pv **EphPlurals) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphPlurals_Marshal(m, *pv)
	} else if !enc {
		var v EphPlurals
		if err = EphPlurals_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphPlurals_Marshal(m jsn.Marshaler, val *EphPlurals) (err error) {
	if err = m.MarshalBlock(EphPlurals_Flow{val}); err == nil {
		e0 := m.MarshalKey("plural", EphPlurals_Field_Plural)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Plural)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphPlurals_Field_Plural))
		}
		e1 := m.MarshalKey("singular", EphPlurals_Field_Singular)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.Singular)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphPlurals_Field_Singular))
		}
		m.EndBlock()
	}
	return
}

// EphRun
// User implements: Ephemera.
type EphRun struct {
	Run []rt.Execute `if:"label=run"`
}

func (*EphRun) Compose() composer.Spec {
	return composer.Spec{
		Name: EphRun_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphRun_Type = "eph_run"

const EphRun_Field_Run = "$RUN"

func (op *EphRun) Marshal(m jsn.Marshaler) error {
	return EphRun_Marshal(m, op)
}

type EphRun_Slice []EphRun

func (op *EphRun_Slice) GetType() string { return EphRun_Type }

func (op *EphRun_Slice) Marshal(m jsn.Marshaler) error {
	return EphRun_Repeats_Marshal(m, (*[]EphRun)(op))
}

func (op *EphRun_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphRun_Slice) SetSize(cnt int) {
	var els []EphRun
	if cnt >= 0 {
		els = make(EphRun_Slice, cnt)
	}
	(*op) = els
}

func (op *EphRun_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphRun_Marshal(m, &(*op)[i])
}

func EphRun_Repeats_Marshal(m jsn.Marshaler, vals *[]EphRun) error {
	return jsn.RepeatBlock(m, (*EphRun_Slice)(vals))
}

func EphRun_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphRun) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphRun_Repeats_Marshal(m, pv)
	}
	return
}

type EphRun_Flow struct{ ptr *EphRun }

func (n EphRun_Flow) GetType() string      { return EphRun_Type }
func (n EphRun_Flow) GetLede() string      { return "eph" }
func (n EphRun_Flow) GetFlow() interface{} { return n.ptr }
func (n EphRun_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphRun); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphRun_Optional_Marshal(m jsn.Marshaler, pv **EphRun) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphRun_Marshal(m, *pv)
	} else if !enc {
		var v EphRun
		if err = EphRun_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphRun_Marshal(m jsn.Marshaler, val *EphRun) (err error) {
	if err = m.MarshalBlock(EphRun_Flow{val}); err == nil {
		e0 := m.MarshalKey("run", EphRun_Field_Run)
		if e0 == nil {
			e0 = rt.Execute_Repeats_Marshal(m, &val.Run)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphRun_Field_Run))
		}
		m.EndBlock()
	}
	return
}

const Ephemera_Type = "ephemera"

var Ephemera_Optional_Marshal = Ephemera_Marshal

type Ephemera_Slot struct{ ptr *Ephemera }

func (at Ephemera_Slot) GetType() string              { return Ephemera_Type }
func (at Ephemera_Slot) GetSlot() (interface{}, bool) { return *at.ptr, *at.ptr != nil }
func (at Ephemera_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(Ephemera)
	return
}

func Ephemera_Marshal(m jsn.Marshaler, ptr *Ephemera) (err error) {
	slot := Ephemera_Slot{ptr}
	if err = m.MarshalBlock(slot); err == nil {
		if a, ok := slot.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}

type Ephemera_Slice []Ephemera

func (op *Ephemera_Slice) GetType() string { return Ephemera_Type }

func (op *Ephemera_Slice) Marshal(m jsn.Marshaler) error {
	return Ephemera_Repeats_Marshal(m, (*[]Ephemera)(op))
}

func (op *Ephemera_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Ephemera_Slice) SetSize(cnt int) {
	var els []Ephemera
	if cnt >= 0 {
		els = make(Ephemera_Slice, cnt)
	}
	(*op) = els
}

func (op *Ephemera_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Ephemera_Marshal(m, &(*op)[i])
}

func Ephemera_Repeats_Marshal(m jsn.Marshaler, vals *[]Ephemera) error {
	return jsn.RepeatBlock(m, (*Ephemera_Slice)(vals))
}

func Ephemera_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Ephemera) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = Ephemera_Repeats_Marshal(m, pv)
	}
	return
}

var Slots = []interface{}{
	(*Ephemera)(nil),
}

var Slats = []composer.Composer{
	(*Affinity)(nil),
	(*EphAspects)(nil),
	(*EphAt)(nil),
	(*EphBeginDomain)(nil),
	(*EphCheckPrint)(nil),
	(*EphEndDomain)(nil),
	(*EphFields)(nil),
	(*EphKinds)(nil),
	(*EphList)(nil),
	(*EphNameRef)(nil),
	(*EphPlurals)(nil),
	(*EphRun)(nil),
}

var Signatures = map[uint64]interface{}{
	18295658173337269930: (*EphAspects)(nil),     /* Eph aspects:traits: */
	9182060341586636438:  (*EphAt)(nil),          /* Eph at:eph: */
	12209727080993772760: (*EphBeginDomain)(nil), /* Eph domain:requires: */
	18354563224792793196: (*EphCheckPrint)(nil),  /* Eph check:prints: */
	4379746949646135194:  (*EphEndDomain)(nil),   /* Eph domain: */
	8381163068622333334:  (*EphFields)(nil),      /* Eph kinds:have:called: */
	12374005136224423943: (*EphFields)(nil),      /* Eph kinds:have:called:of: */
	9386889860419880175:  (*EphKinds)(nil),       /* Eph kinds:from: */
	11648725103497180078: (*EphList)(nil),        /* Eph list: */
	9956475014949920846:  (*EphNameRef)(nil),     /* Eph ref:of: */
	890409142408471553:   (*EphPlurals)(nil),     /* Eph plural:singular: */
	4420716908411308437:  (*EphRun)(nil),         /* Eph run: */
}
