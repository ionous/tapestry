// Code generated by "makeops"; edit at your own risk.
package eph

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/jsn"
	"github.com/ionous/errutil"
)

// Affinity requires a predefined string.
type Affinity struct {
	Str string
}

func (op *Affinity) String() string {
	return op.Str
}

const Affinity_Bool = "$BOOL"
const Affinity_Number = "$NUMBER"
const Affinity_NumList = "$NUM_LIST"
const Affinity_Text = "$TEXT"
const Affinity_TextList = "$TEXT_LIST"
const Affinity_Record = "$RECORD"
const Affinity_RecordList = "$RECORD_LIST"

func (*Affinity) Compose() composer.Spec {
	return composer.Spec{
		Name: Affinity_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			Affinity_Bool, Affinity_Number, Affinity_NumList, Affinity_Text, Affinity_TextList, Affinity_Record, Affinity_RecordList,
		},
		Strings: []string{
			"bool", "number", "num_list", "text", "text_list", "record", "record_list",
		},
	}
}

const Affinity_Type = "affinity"

func (op *Affinity) Marshal(m jsn.Marshaler) error {
	return Affinity_Marshal(m, op)
}

func Affinity_Optional_Marshal(m jsn.Marshaler, val *Affinity) (err error) {
	var zero Affinity
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = Affinity_Marshal(m, val)
	}
	return
}

func Affinity_Marshal(m jsn.Marshaler, val *Affinity) (err error) {
	return m.MarshalValue(Affinity_Type, jsn.MakeEnum(val, &val.Str))
}

type Affinity_Slice []Affinity

func (op *Affinity_Slice) GetType() string { return Affinity_Type }

func (op *Affinity_Slice) Marshal(m jsn.Marshaler) error {
	return Affinity_Repeats_Marshal(m, (*[]Affinity)(op))
}

func (op *Affinity_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Affinity_Slice) SetSize(cnt int) {
	var els []Affinity
	if cnt >= 0 {
		els = make(Affinity_Slice, cnt)
	}
	(*op) = els
}

func (op *Affinity_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Affinity_Marshal(m, &(*op)[i])
}

func Affinity_Repeats_Marshal(m jsn.Marshaler, vals *[]Affinity) error {
	return jsn.RepeatBlock(m, (*Affinity_Slice)(vals))
}

func Affinity_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Affinity) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = Affinity_Repeats_Marshal(m, pv)
	}
	return
}

// EphAliases
// User implements: Ephemera.
type EphAliases struct {
	ShortName string   `if:"label=understand,type=text"`
	Aliases   []string `if:"label=as,type=text"`
}

func (*EphAliases) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAliases_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphAliases_Type = "eph_aliases"

const EphAliases_Field_ShortName = "$SHORT_NAME"
const EphAliases_Field_Aliases = "$ALIASES"

func (op *EphAliases) Marshal(m jsn.Marshaler) error {
	return EphAliases_Marshal(m, op)
}

type EphAliases_Slice []EphAliases

func (op *EphAliases_Slice) GetType() string { return EphAliases_Type }

func (op *EphAliases_Slice) Marshal(m jsn.Marshaler) error {
	return EphAliases_Repeats_Marshal(m, (*[]EphAliases)(op))
}

func (op *EphAliases_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAliases_Slice) SetSize(cnt int) {
	var els []EphAliases
	if cnt >= 0 {
		els = make(EphAliases_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAliases_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAliases_Marshal(m, &(*op)[i])
}

func EphAliases_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAliases) error {
	return jsn.RepeatBlock(m, (*EphAliases_Slice)(vals))
}

func EphAliases_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAliases) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphAliases_Repeats_Marshal(m, pv)
	}
	return
}

type EphAliases_Flow struct{ ptr *EphAliases }

func (n EphAliases_Flow) GetType() string      { return EphAliases_Type }
func (n EphAliases_Flow) GetLede() string      { return "eph" }
func (n EphAliases_Flow) GetFlow() interface{} { return n.ptr }
func (n EphAliases_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphAliases); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphAliases_Optional_Marshal(m jsn.Marshaler, pv **EphAliases) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphAliases_Marshal(m, *pv)
	} else if !enc {
		var v EphAliases
		if err = EphAliases_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphAliases_Marshal(m jsn.Marshaler, val *EphAliases) (err error) {
	if err = m.MarshalBlock(EphAliases_Flow{val}); err == nil {
		e0 := m.MarshalKey("understand", EphAliases_Field_ShortName)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.ShortName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphAliases_Field_ShortName))
		}
		e1 := m.MarshalKey("as", EphAliases_Field_Aliases)
		if e1 == nil {
			e1 = value.Text_Unboxed_Repeats_Marshal(m, &val.Aliases)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphAliases_Field_Aliases))
		}
		m.EndBlock()
	}
	return
}

// EphAspects A set of related object states such that exactly one member of the set is true for a given object at a single time.
// Generates an implicit kind of 'aspect' where every field of the kind is a boolean property.
// User implements: Ephemera.
type EphAspects struct {
	Aspects string   `if:"label=aspects,type=text"`
	Traits  []string `if:"label=traits,type=text"`
}

func (*EphAspects) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAspects_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphAspects_Type = "eph_aspects"

const EphAspects_Field_Aspects = "$ASPECTS"
const EphAspects_Field_Traits = "$TRAITS"

func (op *EphAspects) Marshal(m jsn.Marshaler) error {
	return EphAspects_Marshal(m, op)
}

type EphAspects_Slice []EphAspects

func (op *EphAspects_Slice) GetType() string { return EphAspects_Type }

func (op *EphAspects_Slice) Marshal(m jsn.Marshaler) error {
	return EphAspects_Repeats_Marshal(m, (*[]EphAspects)(op))
}

func (op *EphAspects_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAspects_Slice) SetSize(cnt int) {
	var els []EphAspects
	if cnt >= 0 {
		els = make(EphAspects_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAspects_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAspects_Marshal(m, &(*op)[i])
}

func EphAspects_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAspects) error {
	return jsn.RepeatBlock(m, (*EphAspects_Slice)(vals))
}

func EphAspects_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAspects) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphAspects_Repeats_Marshal(m, pv)
	}
	return
}

type EphAspects_Flow struct{ ptr *EphAspects }

func (n EphAspects_Flow) GetType() string      { return EphAspects_Type }
func (n EphAspects_Flow) GetLede() string      { return "eph" }
func (n EphAspects_Flow) GetFlow() interface{} { return n.ptr }
func (n EphAspects_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphAspects); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphAspects_Optional_Marshal(m jsn.Marshaler, pv **EphAspects) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphAspects_Marshal(m, *pv)
	} else if !enc {
		var v EphAspects
		if err = EphAspects_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphAspects_Marshal(m jsn.Marshaler, val *EphAspects) (err error) {
	if err = m.MarshalBlock(EphAspects_Flow{val}); err == nil {
		e0 := m.MarshalKey("aspects", EphAspects_Field_Aspects)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Aspects)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphAspects_Field_Aspects))
		}
		e1 := m.MarshalKey("traits", EphAspects_Field_Traits)
		if e1 == nil {
			e1 = value.Text_Unboxed_Repeats_Marshal(m, &val.Traits)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphAspects_Field_Traits))
		}
		m.EndBlock()
	}
	return
}

// EphAt
type EphAt struct {
	At  string   `if:"label=at,type=text"`
	Eph Ephemera `if:"label=eph"`
}

func (*EphAt) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAt_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphAt_Type = "eph_at"

const EphAt_Field_At = "$AT"
const EphAt_Field_Eph = "$EPH"

func (op *EphAt) Marshal(m jsn.Marshaler) error {
	return EphAt_Marshal(m, op)
}

type EphAt_Slice []EphAt

func (op *EphAt_Slice) GetType() string { return EphAt_Type }

func (op *EphAt_Slice) Marshal(m jsn.Marshaler) error {
	return EphAt_Repeats_Marshal(m, (*[]EphAt)(op))
}

func (op *EphAt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAt_Slice) SetSize(cnt int) {
	var els []EphAt
	if cnt >= 0 {
		els = make(EphAt_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAt_Marshal(m, &(*op)[i])
}

func EphAt_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAt) error {
	return jsn.RepeatBlock(m, (*EphAt_Slice)(vals))
}

func EphAt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAt) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphAt_Repeats_Marshal(m, pv)
	}
	return
}

type EphAt_Flow struct{ ptr *EphAt }

func (n EphAt_Flow) GetType() string      { return EphAt_Type }
func (n EphAt_Flow) GetLede() string      { return "eph" }
func (n EphAt_Flow) GetFlow() interface{} { return n.ptr }
func (n EphAt_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphAt); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphAt_Optional_Marshal(m jsn.Marshaler, pv **EphAt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphAt_Marshal(m, *pv)
	} else if !enc {
		var v EphAt
		if err = EphAt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphAt_Marshal(m jsn.Marshaler, val *EphAt) (err error) {
	if err = m.MarshalBlock(EphAt_Flow{val}); err == nil {
		e0 := m.MarshalKey("at", EphAt_Field_At)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.At)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphAt_Field_At))
		}
		e1 := m.MarshalKey("eph", EphAt_Field_Eph)
		if e1 == nil {
			e1 = Ephemera_Marshal(m, &val.Eph)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphAt_Field_Eph))
		}
		m.EndBlock()
	}
	return
}

// EphBeginDomain
// User implements: Ephemera.
type EphBeginDomain struct {
	Name     string   `if:"label=domain,type=text"`
	Requires []string `if:"label=requires,type=text"`
}

func (*EphBeginDomain) Compose() composer.Spec {
	return composer.Spec{
		Name: EphBeginDomain_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphBeginDomain_Type = "eph_begin_domain"

const EphBeginDomain_Field_Name = "$NAME"
const EphBeginDomain_Field_Requires = "$REQUIRES"

func (op *EphBeginDomain) Marshal(m jsn.Marshaler) error {
	return EphBeginDomain_Marshal(m, op)
}

type EphBeginDomain_Slice []EphBeginDomain

func (op *EphBeginDomain_Slice) GetType() string { return EphBeginDomain_Type }

func (op *EphBeginDomain_Slice) Marshal(m jsn.Marshaler) error {
	return EphBeginDomain_Repeats_Marshal(m, (*[]EphBeginDomain)(op))
}

func (op *EphBeginDomain_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphBeginDomain_Slice) SetSize(cnt int) {
	var els []EphBeginDomain
	if cnt >= 0 {
		els = make(EphBeginDomain_Slice, cnt)
	}
	(*op) = els
}

func (op *EphBeginDomain_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphBeginDomain_Marshal(m, &(*op)[i])
}

func EphBeginDomain_Repeats_Marshal(m jsn.Marshaler, vals *[]EphBeginDomain) error {
	return jsn.RepeatBlock(m, (*EphBeginDomain_Slice)(vals))
}

func EphBeginDomain_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphBeginDomain) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphBeginDomain_Repeats_Marshal(m, pv)
	}
	return
}

type EphBeginDomain_Flow struct{ ptr *EphBeginDomain }

func (n EphBeginDomain_Flow) GetType() string      { return EphBeginDomain_Type }
func (n EphBeginDomain_Flow) GetLede() string      { return "eph" }
func (n EphBeginDomain_Flow) GetFlow() interface{} { return n.ptr }
func (n EphBeginDomain_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphBeginDomain); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphBeginDomain_Optional_Marshal(m jsn.Marshaler, pv **EphBeginDomain) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphBeginDomain_Marshal(m, *pv)
	} else if !enc {
		var v EphBeginDomain
		if err = EphBeginDomain_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphBeginDomain_Marshal(m jsn.Marshaler, val *EphBeginDomain) (err error) {
	if err = m.MarshalBlock(EphBeginDomain_Flow{val}); err == nil {
		e0 := m.MarshalKey("domain", EphBeginDomain_Field_Name)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphBeginDomain_Field_Name))
		}
		e1 := m.MarshalKey("requires", EphBeginDomain_Field_Requires)
		if e1 == nil {
			e1 = value.Text_Unboxed_Repeats_Marshal(m, &val.Requires)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphBeginDomain_Field_Requires))
		}
		m.EndBlock()
	}
	return
}

// EphCardinality swaps between various options
type EphCardinality struct {
	Choice string
	Value  interface{}
}

var EphCardinality_Optional_Marshal = EphCardinality_Marshal

const EphCardinality_OneOne_Opt = "$ONE_ONE"
const EphCardinality_OneMany_Opt = "$ONE_MANY"
const EphCardinality_ManyOne_Opt = "$MANY_ONE"
const EphCardinality_ManyMany_Opt = "$MANY_MANY"

func (*EphCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: EphCardinality_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			EphCardinality_OneOne_Opt, EphCardinality_OneMany_Opt, EphCardinality_ManyOne_Opt, EphCardinality_ManyMany_Opt,
		},
		Swaps: []interface{}{
			(*OneOne)(nil),
			(*OneMany)(nil),
			(*ManyOne)(nil),
			(*ManyMany)(nil),
		},
	}
}

const EphCardinality_Type = "eph_cardinality"

func (op *EphCardinality) GetType() string { return EphCardinality_Type }

func (op *EphCardinality) GetSwap() (string, interface{}) {
	return op.Choice, op.Value
}

func (op *EphCardinality) SetSwap(c string) (okay bool) {
	switch c {
	case "":
		op.Choice, op.Value = c, nil
		okay = true
	case EphCardinality_OneOne_Opt:
		op.Choice, op.Value = c, new(OneOne)
		okay = true
	case EphCardinality_OneMany_Opt:
		op.Choice, op.Value = c, new(OneMany)
		okay = true
	case EphCardinality_ManyOne_Opt:
		op.Choice, op.Value = c, new(ManyOne)
		okay = true
	case EphCardinality_ManyMany_Opt:
		op.Choice, op.Value = c, new(ManyMany)
		okay = true
	}
	return
}

func (op *EphCardinality) Marshal(m jsn.Marshaler) error {
	return EphCardinality_Marshal(m, op)
}
func EphCardinality_Marshal(m jsn.Marshaler, val *EphCardinality) (err error) {
	if err = m.MarshalBlock(val); err == nil {
		if _, ptr := val.GetSwap(); ptr != nil {
			if e := ptr.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}

type EphCardinality_Slice []EphCardinality

func (op *EphCardinality_Slice) GetType() string { return EphCardinality_Type }

func (op *EphCardinality_Slice) Marshal(m jsn.Marshaler) error {
	return EphCardinality_Repeats_Marshal(m, (*[]EphCardinality)(op))
}

func (op *EphCardinality_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphCardinality_Slice) SetSize(cnt int) {
	var els []EphCardinality
	if cnt >= 0 {
		els = make(EphCardinality_Slice, cnt)
	}
	(*op) = els
}

func (op *EphCardinality_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphCardinality_Marshal(m, &(*op)[i])
}

func EphCardinality_Repeats_Marshal(m jsn.Marshaler, vals *[]EphCardinality) error {
	return jsn.RepeatBlock(m, (*EphCardinality_Slice)(vals))
}

func EphCardinality_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphCardinality) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphCardinality_Repeats_Marshal(m, pv)
	}
	return
}

// EphEndDomain
// User implements: Ephemera.
type EphEndDomain struct {
	Name string `if:"label=domain,type=text"`
}

func (*EphEndDomain) Compose() composer.Spec {
	return composer.Spec{
		Name: EphEndDomain_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphEndDomain_Type = "eph_end_domain"

const EphEndDomain_Field_Name = "$NAME"

func (op *EphEndDomain) Marshal(m jsn.Marshaler) error {
	return EphEndDomain_Marshal(m, op)
}

type EphEndDomain_Slice []EphEndDomain

func (op *EphEndDomain_Slice) GetType() string { return EphEndDomain_Type }

func (op *EphEndDomain_Slice) Marshal(m jsn.Marshaler) error {
	return EphEndDomain_Repeats_Marshal(m, (*[]EphEndDomain)(op))
}

func (op *EphEndDomain_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphEndDomain_Slice) SetSize(cnt int) {
	var els []EphEndDomain
	if cnt >= 0 {
		els = make(EphEndDomain_Slice, cnt)
	}
	(*op) = els
}

func (op *EphEndDomain_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphEndDomain_Marshal(m, &(*op)[i])
}

func EphEndDomain_Repeats_Marshal(m jsn.Marshaler, vals *[]EphEndDomain) error {
	return jsn.RepeatBlock(m, (*EphEndDomain_Slice)(vals))
}

func EphEndDomain_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphEndDomain) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphEndDomain_Repeats_Marshal(m, pv)
	}
	return
}

type EphEndDomain_Flow struct{ ptr *EphEndDomain }

func (n EphEndDomain_Flow) GetType() string      { return EphEndDomain_Type }
func (n EphEndDomain_Flow) GetLede() string      { return "eph" }
func (n EphEndDomain_Flow) GetFlow() interface{} { return n.ptr }
func (n EphEndDomain_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphEndDomain); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphEndDomain_Optional_Marshal(m jsn.Marshaler, pv **EphEndDomain) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphEndDomain_Marshal(m, *pv)
	} else if !enc {
		var v EphEndDomain
		if err = EphEndDomain_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphEndDomain_Marshal(m jsn.Marshaler, val *EphEndDomain) (err error) {
	if err = m.MarshalBlock(EphEndDomain_Flow{val}); err == nil {
		e0 := m.MarshalKey("domain", EphEndDomain_Field_Name)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphEndDomain_Field_Name))
		}
		m.EndBlock()
	}
	return
}

// EphFields Contents of a kind.
// 'Affinity' designates the storage type of a given field
// while 'class' is used to indicate an interpretation of that field, for example a reference to a kind.
// User implements: Ephemera.
type EphFields struct {
	Kinds    string   `if:"label=kinds,type=text"`
	Affinity Affinity `if:"label=have"`
	Name     string   `if:"label=called,type=text"`
	Class    string   `if:"label=of,optional,type=text"`
}

func (*EphFields) Compose() composer.Spec {
	return composer.Spec{
		Name: EphFields_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphFields_Type = "eph_fields"

const EphFields_Field_Kinds = "$KINDS"
const EphFields_Field_Affinity = "$AFFINITY"
const EphFields_Field_Name = "$NAME"
const EphFields_Field_Class = "$CLASS"

func (op *EphFields) Marshal(m jsn.Marshaler) error {
	return EphFields_Marshal(m, op)
}

type EphFields_Slice []EphFields

func (op *EphFields_Slice) GetType() string { return EphFields_Type }

func (op *EphFields_Slice) Marshal(m jsn.Marshaler) error {
	return EphFields_Repeats_Marshal(m, (*[]EphFields)(op))
}

func (op *EphFields_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphFields_Slice) SetSize(cnt int) {
	var els []EphFields
	if cnt >= 0 {
		els = make(EphFields_Slice, cnt)
	}
	(*op) = els
}

func (op *EphFields_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphFields_Marshal(m, &(*op)[i])
}

func EphFields_Repeats_Marshal(m jsn.Marshaler, vals *[]EphFields) error {
	return jsn.RepeatBlock(m, (*EphFields_Slice)(vals))
}

func EphFields_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphFields) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphFields_Repeats_Marshal(m, pv)
	}
	return
}

type EphFields_Flow struct{ ptr *EphFields }

func (n EphFields_Flow) GetType() string      { return EphFields_Type }
func (n EphFields_Flow) GetLede() string      { return "eph" }
func (n EphFields_Flow) GetFlow() interface{} { return n.ptr }
func (n EphFields_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphFields); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphFields_Optional_Marshal(m jsn.Marshaler, pv **EphFields) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphFields_Marshal(m, *pv)
	} else if !enc {
		var v EphFields
		if err = EphFields_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphFields_Marshal(m jsn.Marshaler, val *EphFields) (err error) {
	if err = m.MarshalBlock(EphFields_Flow{val}); err == nil {
		e0 := m.MarshalKey("kinds", EphFields_Field_Kinds)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphFields_Field_Kinds))
		}
		e1 := m.MarshalKey("have", EphFields_Field_Affinity)
		if e1 == nil {
			e1 = Affinity_Marshal(m, &val.Affinity)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphFields_Field_Affinity))
		}
		e2 := m.MarshalKey("called", EphFields_Field_Name)
		if e2 == nil {
			e2 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphFields_Field_Name))
		}
		e3 := m.MarshalKey("of", EphFields_Field_Class)
		if e3 == nil {
			e3 = value.Text_Unboxed_Optional_Marshal(m, &val.Class)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", EphFields_Field_Class))
		}
		m.EndBlock()
	}
	return
}

// EphKinds A new type deriving from another existing type.
// The new kind has all of the properties of all of its ancestor kinds
// and it can be used wherever one of its ancestor kinds is needed.
// ( The reverse isn't true because the new kind can have its own unique properties not available to its ancestors. )
// User implements: Ephemera.
type EphKinds struct {
	Kinds string `if:"label=kinds,type=text"`
	From  string `if:"label=from,type=text"`
}

func (*EphKinds) Compose() composer.Spec {
	return composer.Spec{
		Name: EphKinds_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphKinds_Type = "eph_kinds"

const EphKinds_Field_Kinds = "$KINDS"
const EphKinds_Field_From = "$FROM"

func (op *EphKinds) Marshal(m jsn.Marshaler) error {
	return EphKinds_Marshal(m, op)
}

type EphKinds_Slice []EphKinds

func (op *EphKinds_Slice) GetType() string { return EphKinds_Type }

func (op *EphKinds_Slice) Marshal(m jsn.Marshaler) error {
	return EphKinds_Repeats_Marshal(m, (*[]EphKinds)(op))
}

func (op *EphKinds_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphKinds_Slice) SetSize(cnt int) {
	var els []EphKinds
	if cnt >= 0 {
		els = make(EphKinds_Slice, cnt)
	}
	(*op) = els
}

func (op *EphKinds_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphKinds_Marshal(m, &(*op)[i])
}

func EphKinds_Repeats_Marshal(m jsn.Marshaler, vals *[]EphKinds) error {
	return jsn.RepeatBlock(m, (*EphKinds_Slice)(vals))
}

func EphKinds_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphKinds) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphKinds_Repeats_Marshal(m, pv)
	}
	return
}

type EphKinds_Flow struct{ ptr *EphKinds }

func (n EphKinds_Flow) GetType() string      { return EphKinds_Type }
func (n EphKinds_Flow) GetLede() string      { return "eph" }
func (n EphKinds_Flow) GetFlow() interface{} { return n.ptr }
func (n EphKinds_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphKinds); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphKinds_Optional_Marshal(m jsn.Marshaler, pv **EphKinds) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphKinds_Marshal(m, *pv)
	} else if !enc {
		var v EphKinds
		if err = EphKinds_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphKinds_Marshal(m jsn.Marshaler, val *EphKinds) (err error) {
	if err = m.MarshalBlock(EphKinds_Flow{val}); err == nil {
		e0 := m.MarshalKey("kinds", EphKinds_Field_Kinds)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphKinds_Field_Kinds))
		}
		e1 := m.MarshalKey("from", EphKinds_Field_From)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphKinds_Field_From))
		}
		m.EndBlock()
	}
	return
}

// EphList
type EphList struct {
	All []EphAt `if:"label=list"`
}

func (*EphList) Compose() composer.Spec {
	return composer.Spec{
		Name: EphList_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphList_Type = "eph_list"

const EphList_Field_All = "$ALL"

func (op *EphList) Marshal(m jsn.Marshaler) error {
	return EphList_Marshal(m, op)
}

type EphList_Slice []EphList

func (op *EphList_Slice) GetType() string { return EphList_Type }

func (op *EphList_Slice) Marshal(m jsn.Marshaler) error {
	return EphList_Repeats_Marshal(m, (*[]EphList)(op))
}

func (op *EphList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphList_Slice) SetSize(cnt int) {
	var els []EphList
	if cnt >= 0 {
		els = make(EphList_Slice, cnt)
	}
	(*op) = els
}

func (op *EphList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphList_Marshal(m, &(*op)[i])
}

func EphList_Repeats_Marshal(m jsn.Marshaler, vals *[]EphList) error {
	return jsn.RepeatBlock(m, (*EphList_Slice)(vals))
}

func EphList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphList) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphList_Repeats_Marshal(m, pv)
	}
	return
}

type EphList_Flow struct{ ptr *EphList }

func (n EphList_Flow) GetType() string      { return EphList_Type }
func (n EphList_Flow) GetLede() string      { return "eph" }
func (n EphList_Flow) GetFlow() interface{} { return n.ptr }
func (n EphList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphList_Optional_Marshal(m jsn.Marshaler, pv **EphList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphList_Marshal(m, *pv)
	} else if !enc {
		var v EphList
		if err = EphList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphList_Marshal(m jsn.Marshaler, val *EphList) (err error) {
	if err = m.MarshalBlock(EphList_Flow{val}); err == nil {
		e0 := m.MarshalKey("list", EphList_Field_All)
		if e0 == nil {
			e0 = EphAt_Repeats_Marshal(m, &val.All)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphList_Field_All))
		}
		m.EndBlock()
	}
	return
}

// EphNouns
// User implements: Ephemera.
type EphNouns struct {
	Noun string `if:"label=noun,type=text"`
	Kind string `if:"label=kind,type=text"`
}

func (*EphNouns) Compose() composer.Spec {
	return composer.Spec{
		Name: EphNouns_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphNouns_Type = "eph_nouns"

const EphNouns_Field_Noun = "$NOUN"
const EphNouns_Field_Kind = "$KIND"

func (op *EphNouns) Marshal(m jsn.Marshaler) error {
	return EphNouns_Marshal(m, op)
}

type EphNouns_Slice []EphNouns

func (op *EphNouns_Slice) GetType() string { return EphNouns_Type }

func (op *EphNouns_Slice) Marshal(m jsn.Marshaler) error {
	return EphNouns_Repeats_Marshal(m, (*[]EphNouns)(op))
}

func (op *EphNouns_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphNouns_Slice) SetSize(cnt int) {
	var els []EphNouns
	if cnt >= 0 {
		els = make(EphNouns_Slice, cnt)
	}
	(*op) = els
}

func (op *EphNouns_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphNouns_Marshal(m, &(*op)[i])
}

func EphNouns_Repeats_Marshal(m jsn.Marshaler, vals *[]EphNouns) error {
	return jsn.RepeatBlock(m, (*EphNouns_Slice)(vals))
}

func EphNouns_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphNouns) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphNouns_Repeats_Marshal(m, pv)
	}
	return
}

type EphNouns_Flow struct{ ptr *EphNouns }

func (n EphNouns_Flow) GetType() string      { return EphNouns_Type }
func (n EphNouns_Flow) GetLede() string      { return "eph" }
func (n EphNouns_Flow) GetFlow() interface{} { return n.ptr }
func (n EphNouns_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphNouns); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphNouns_Optional_Marshal(m jsn.Marshaler, pv **EphNouns) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphNouns_Marshal(m, *pv)
	} else if !enc {
		var v EphNouns
		if err = EphNouns_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphNouns_Marshal(m jsn.Marshaler, val *EphNouns) (err error) {
	if err = m.MarshalBlock(EphNouns_Flow{val}); err == nil {
		e0 := m.MarshalKey("noun", EphNouns_Field_Noun)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Noun)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphNouns_Field_Noun))
		}
		e1 := m.MarshalKey("kind", EphNouns_Field_Kind)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.Kind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphNouns_Field_Kind))
		}
		m.EndBlock()
	}
	return
}

// EphParams 'Affinity' designates the storage type of a given parameter
// while 'class' is used to indicate an interpretation of that parameter, for example a reference to a kind.
// User implements: Ephemera.
type EphParams struct {
	Affinity Affinity `if:"label=have"`
	Name     string   `if:"label=called,type=text"`
	Class    string   `if:"label=of,optional,type=text"`
}

func (*EphParams) Compose() composer.Spec {
	return composer.Spec{
		Name: EphParams_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphParams_Type = "eph_params"

const EphParams_Field_Affinity = "$AFFINITY"
const EphParams_Field_Name = "$NAME"
const EphParams_Field_Class = "$CLASS"

func (op *EphParams) Marshal(m jsn.Marshaler) error {
	return EphParams_Marshal(m, op)
}

type EphParams_Slice []EphParams

func (op *EphParams_Slice) GetType() string { return EphParams_Type }

func (op *EphParams_Slice) Marshal(m jsn.Marshaler) error {
	return EphParams_Repeats_Marshal(m, (*[]EphParams)(op))
}

func (op *EphParams_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphParams_Slice) SetSize(cnt int) {
	var els []EphParams
	if cnt >= 0 {
		els = make(EphParams_Slice, cnt)
	}
	(*op) = els
}

func (op *EphParams_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphParams_Marshal(m, &(*op)[i])
}

func EphParams_Repeats_Marshal(m jsn.Marshaler, vals *[]EphParams) error {
	return jsn.RepeatBlock(m, (*EphParams_Slice)(vals))
}

func EphParams_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphParams) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphParams_Repeats_Marshal(m, pv)
	}
	return
}

type EphParams_Flow struct{ ptr *EphParams }

func (n EphParams_Flow) GetType() string      { return EphParams_Type }
func (n EphParams_Flow) GetLede() string      { return "eph" }
func (n EphParams_Flow) GetFlow() interface{} { return n.ptr }
func (n EphParams_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphParams); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphParams_Optional_Marshal(m jsn.Marshaler, pv **EphParams) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphParams_Marshal(m, *pv)
	} else if !enc {
		var v EphParams
		if err = EphParams_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphParams_Marshal(m jsn.Marshaler, val *EphParams) (err error) {
	if err = m.MarshalBlock(EphParams_Flow{val}); err == nil {
		e0 := m.MarshalKey("have", EphParams_Field_Affinity)
		if e0 == nil {
			e0 = Affinity_Marshal(m, &val.Affinity)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphParams_Field_Affinity))
		}
		e1 := m.MarshalKey("called", EphParams_Field_Name)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphParams_Field_Name))
		}
		e2 := m.MarshalKey("of", EphParams_Field_Class)
		if e2 == nil {
			e2 = value.Text_Unboxed_Optional_Marshal(m, &val.Class)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphParams_Field_Class))
		}
		m.EndBlock()
	}
	return
}

// EphPatterns Patterns provide author reusable code.
// Arguments define values provided by the caller.
// Locals provide scratch values for use during pattern processing.
// The return allows the pattern to hand back a value to the caller of pattern.
// While multiple pattern commands can be used to define a pattern,
// the set of arguments and the return can only be specified once.
// User implements: Ephemera.
type EphPatterns struct {
	Name   string      `if:"label=pattern,type=text"`
	Args   []EphParams `if:"label=args,optional"`
	Locals []EphParams `if:"label=locals,optional"`
	Return *EphParams  `if:"label=return,optional"`
}

func (*EphPatterns) Compose() composer.Spec {
	return composer.Spec{
		Name: EphPatterns_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphPatterns_Type = "eph_patterns"

const EphPatterns_Field_Name = "$NAME"
const EphPatterns_Field_Args = "$ARGS"
const EphPatterns_Field_Locals = "$LOCALS"
const EphPatterns_Field_Return = "$RETURN"

func (op *EphPatterns) Marshal(m jsn.Marshaler) error {
	return EphPatterns_Marshal(m, op)
}

type EphPatterns_Slice []EphPatterns

func (op *EphPatterns_Slice) GetType() string { return EphPatterns_Type }

func (op *EphPatterns_Slice) Marshal(m jsn.Marshaler) error {
	return EphPatterns_Repeats_Marshal(m, (*[]EphPatterns)(op))
}

func (op *EphPatterns_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphPatterns_Slice) SetSize(cnt int) {
	var els []EphPatterns
	if cnt >= 0 {
		els = make(EphPatterns_Slice, cnt)
	}
	(*op) = els
}

func (op *EphPatterns_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphPatterns_Marshal(m, &(*op)[i])
}

func EphPatterns_Repeats_Marshal(m jsn.Marshaler, vals *[]EphPatterns) error {
	return jsn.RepeatBlock(m, (*EphPatterns_Slice)(vals))
}

func EphPatterns_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphPatterns) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphPatterns_Repeats_Marshal(m, pv)
	}
	return
}

type EphPatterns_Flow struct{ ptr *EphPatterns }

func (n EphPatterns_Flow) GetType() string      { return EphPatterns_Type }
func (n EphPatterns_Flow) GetLede() string      { return "eph" }
func (n EphPatterns_Flow) GetFlow() interface{} { return n.ptr }
func (n EphPatterns_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphPatterns); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphPatterns_Optional_Marshal(m jsn.Marshaler, pv **EphPatterns) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphPatterns_Marshal(m, *pv)
	} else if !enc {
		var v EphPatterns
		if err = EphPatterns_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphPatterns_Marshal(m jsn.Marshaler, val *EphPatterns) (err error) {
	if err = m.MarshalBlock(EphPatterns_Flow{val}); err == nil {
		e0 := m.MarshalKey("pattern", EphPatterns_Field_Name)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphPatterns_Field_Name))
		}
		e1 := m.MarshalKey("args", EphPatterns_Field_Args)
		if e1 == nil {
			e1 = EphParams_Optional_Repeats_Marshal(m, &val.Args)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphPatterns_Field_Args))
		}
		e2 := m.MarshalKey("locals", EphPatterns_Field_Locals)
		if e2 == nil {
			e2 = EphParams_Optional_Repeats_Marshal(m, &val.Locals)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphPatterns_Field_Locals))
		}
		e3 := m.MarshalKey("return", EphPatterns_Field_Return)
		if e3 == nil {
			e3 = EphParams_Optional_Marshal(m, &val.Return)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", EphPatterns_Field_Return))
		}
		m.EndBlock()
	}
	return
}

// EphPlurals Rules for transforming plural text to singular text and back again.
// Used by the assembler to help interpret author definitions,
// and at runtime to help the parser interpret user input.
// User implements: Ephemera.
type EphPlurals struct {
	Plural   string `if:"label=plural,type=text"`
	Singular string `if:"label=singular,type=text"`
}

func (*EphPlurals) Compose() composer.Spec {
	return composer.Spec{
		Name: EphPlurals_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphPlurals_Type = "eph_plurals"

const EphPlurals_Field_Plural = "$PLURAL"
const EphPlurals_Field_Singular = "$SINGULAR"

func (op *EphPlurals) Marshal(m jsn.Marshaler) error {
	return EphPlurals_Marshal(m, op)
}

type EphPlurals_Slice []EphPlurals

func (op *EphPlurals_Slice) GetType() string { return EphPlurals_Type }

func (op *EphPlurals_Slice) Marshal(m jsn.Marshaler) error {
	return EphPlurals_Repeats_Marshal(m, (*[]EphPlurals)(op))
}

func (op *EphPlurals_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphPlurals_Slice) SetSize(cnt int) {
	var els []EphPlurals
	if cnt >= 0 {
		els = make(EphPlurals_Slice, cnt)
	}
	(*op) = els
}

func (op *EphPlurals_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphPlurals_Marshal(m, &(*op)[i])
}

func EphPlurals_Repeats_Marshal(m jsn.Marshaler, vals *[]EphPlurals) error {
	return jsn.RepeatBlock(m, (*EphPlurals_Slice)(vals))
}

func EphPlurals_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphPlurals) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphPlurals_Repeats_Marshal(m, pv)
	}
	return
}

type EphPlurals_Flow struct{ ptr *EphPlurals }

func (n EphPlurals_Flow) GetType() string      { return EphPlurals_Type }
func (n EphPlurals_Flow) GetLede() string      { return "eph" }
func (n EphPlurals_Flow) GetFlow() interface{} { return n.ptr }
func (n EphPlurals_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphPlurals); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphPlurals_Optional_Marshal(m jsn.Marshaler, pv **EphPlurals) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphPlurals_Marshal(m, *pv)
	} else if !enc {
		var v EphPlurals
		if err = EphPlurals_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphPlurals_Marshal(m jsn.Marshaler, val *EphPlurals) (err error) {
	if err = m.MarshalBlock(EphPlurals_Flow{val}); err == nil {
		e0 := m.MarshalKey("plural", EphPlurals_Field_Plural)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Plural)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphPlurals_Field_Plural))
		}
		e1 := m.MarshalKey("singular", EphPlurals_Field_Singular)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.Singular)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphPlurals_Field_Singular))
		}
		m.EndBlock()
	}
	return
}

// EphPrograms
// User implements: Ephemera.
type EphPrograms struct {
	Name string `if:"label=go,type=text"`
	Type string `if:"label=run,type=text"`
	Prog string `if:"label=using,type=text"`
}

func (*EphPrograms) Compose() composer.Spec {
	return composer.Spec{
		Name: EphPrograms_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphPrograms_Type = "eph_programs"

const EphPrograms_Field_Name = "$NAME"
const EphPrograms_Field_Type = "$TYPE"
const EphPrograms_Field_Prog = "$PROG"

func (op *EphPrograms) Marshal(m jsn.Marshaler) error {
	return EphPrograms_Marshal(m, op)
}

type EphPrograms_Slice []EphPrograms

func (op *EphPrograms_Slice) GetType() string { return EphPrograms_Type }

func (op *EphPrograms_Slice) Marshal(m jsn.Marshaler) error {
	return EphPrograms_Repeats_Marshal(m, (*[]EphPrograms)(op))
}

func (op *EphPrograms_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphPrograms_Slice) SetSize(cnt int) {
	var els []EphPrograms
	if cnt >= 0 {
		els = make(EphPrograms_Slice, cnt)
	}
	(*op) = els
}

func (op *EphPrograms_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphPrograms_Marshal(m, &(*op)[i])
}

func EphPrograms_Repeats_Marshal(m jsn.Marshaler, vals *[]EphPrograms) error {
	return jsn.RepeatBlock(m, (*EphPrograms_Slice)(vals))
}

func EphPrograms_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphPrograms) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphPrograms_Repeats_Marshal(m, pv)
	}
	return
}

type EphPrograms_Flow struct{ ptr *EphPrograms }

func (n EphPrograms_Flow) GetType() string      { return EphPrograms_Type }
func (n EphPrograms_Flow) GetLede() string      { return "eph" }
func (n EphPrograms_Flow) GetFlow() interface{} { return n.ptr }
func (n EphPrograms_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphPrograms); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphPrograms_Optional_Marshal(m jsn.Marshaler, pv **EphPrograms) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphPrograms_Marshal(m, *pv)
	} else if !enc {
		var v EphPrograms
		if err = EphPrograms_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphPrograms_Marshal(m jsn.Marshaler, val *EphPrograms) (err error) {
	if err = m.MarshalBlock(EphPrograms_Flow{val}); err == nil {
		e0 := m.MarshalKey("go", EphPrograms_Field_Name)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphPrograms_Field_Name))
		}
		e1 := m.MarshalKey("run", EphPrograms_Field_Type)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphPrograms_Field_Type))
		}
		e2 := m.MarshalKey("using", EphPrograms_Field_Prog)
		if e2 == nil {
			e2 = value.Text_Unboxed_Marshal(m, &val.Prog)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphPrograms_Field_Prog))
		}
		m.EndBlock()
	}
	return
}

// EphRelations
// User implements: Ephemera.
type EphRelations struct {
	Rel         string         `if:"label=_,type=text"`
	Cardinality EphCardinality `if:"label=relate"`
}

func (*EphRelations) Compose() composer.Spec {
	return composer.Spec{
		Name: EphRelations_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphRelations_Type = "eph_relations"

const EphRelations_Field_Rel = "$REL"
const EphRelations_Field_Cardinality = "$CARDINALITY"

func (op *EphRelations) Marshal(m jsn.Marshaler) error {
	return EphRelations_Marshal(m, op)
}

type EphRelations_Slice []EphRelations

func (op *EphRelations_Slice) GetType() string { return EphRelations_Type }

func (op *EphRelations_Slice) Marshal(m jsn.Marshaler) error {
	return EphRelations_Repeats_Marshal(m, (*[]EphRelations)(op))
}

func (op *EphRelations_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphRelations_Slice) SetSize(cnt int) {
	var els []EphRelations
	if cnt >= 0 {
		els = make(EphRelations_Slice, cnt)
	}
	(*op) = els
}

func (op *EphRelations_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphRelations_Marshal(m, &(*op)[i])
}

func EphRelations_Repeats_Marshal(m jsn.Marshaler, vals *[]EphRelations) error {
	return jsn.RepeatBlock(m, (*EphRelations_Slice)(vals))
}

func EphRelations_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphRelations) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EphRelations_Repeats_Marshal(m, pv)
	}
	return
}

type EphRelations_Flow struct{ ptr *EphRelations }

func (n EphRelations_Flow) GetType() string      { return EphRelations_Type }
func (n EphRelations_Flow) GetLede() string      { return "eph" }
func (n EphRelations_Flow) GetFlow() interface{} { return n.ptr }
func (n EphRelations_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphRelations); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphRelations_Optional_Marshal(m jsn.Marshaler, pv **EphRelations) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphRelations_Marshal(m, *pv)
	} else if !enc {
		var v EphRelations
		if err = EphRelations_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphRelations_Marshal(m jsn.Marshaler, val *EphRelations) (err error) {
	if err = m.MarshalBlock(EphRelations_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EphRelations_Field_Rel)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Rel)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphRelations_Field_Rel))
		}
		e1 := m.MarshalKey("relate", EphRelations_Field_Cardinality)
		if e1 == nil {
			e1 = EphCardinality_Marshal(m, &val.Cardinality)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphRelations_Field_Cardinality))
		}
		m.EndBlock()
	}
	return
}

const Ephemera_Type = "ephemera"

var Ephemera_Optional_Marshal = Ephemera_Marshal

type Ephemera_Slot struct{ ptr *Ephemera }

func (at Ephemera_Slot) GetType() string              { return Ephemera_Type }
func (at Ephemera_Slot) GetSlot() (interface{}, bool) { return *at.ptr, *at.ptr != nil }
func (at Ephemera_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(Ephemera)
	return
}

func Ephemera_Marshal(m jsn.Marshaler, ptr *Ephemera) (err error) {
	slot := Ephemera_Slot{ptr}
	if err = m.MarshalBlock(slot); err == nil {
		if a, ok := slot.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}

type Ephemera_Slice []Ephemera

func (op *Ephemera_Slice) GetType() string { return Ephemera_Type }

func (op *Ephemera_Slice) Marshal(m jsn.Marshaler) error {
	return Ephemera_Repeats_Marshal(m, (*[]Ephemera)(op))
}

func (op *Ephemera_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Ephemera_Slice) SetSize(cnt int) {
	var els []Ephemera
	if cnt >= 0 {
		els = make(Ephemera_Slice, cnt)
	}
	(*op) = els
}

func (op *Ephemera_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Ephemera_Marshal(m, &(*op)[i])
}

func Ephemera_Repeats_Marshal(m jsn.Marshaler, vals *[]Ephemera) error {
	return jsn.RepeatBlock(m, (*Ephemera_Slice)(vals))
}

func Ephemera_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Ephemera) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = Ephemera_Repeats_Marshal(m, pv)
	}
	return
}

// ManyMany
type ManyMany struct {
	Kinds      string `if:"label=_,type=text"`
	OtherKinds string `if:"label=to_kinds,type=text"`
}

func (*ManyMany) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyMany_Type,
		Uses: composer.Type_Flow,
		Lede: "kinds",
	}
}

const ManyMany_Type = "many_many"

const ManyMany_Field_Kinds = "$KINDS"
const ManyMany_Field_OtherKinds = "$OTHER_KINDS"

func (op *ManyMany) Marshal(m jsn.Marshaler) error {
	return ManyMany_Marshal(m, op)
}

type ManyMany_Slice []ManyMany

func (op *ManyMany_Slice) GetType() string { return ManyMany_Type }

func (op *ManyMany_Slice) Marshal(m jsn.Marshaler) error {
	return ManyMany_Repeats_Marshal(m, (*[]ManyMany)(op))
}

func (op *ManyMany_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ManyMany_Slice) SetSize(cnt int) {
	var els []ManyMany
	if cnt >= 0 {
		els = make(ManyMany_Slice, cnt)
	}
	(*op) = els
}

func (op *ManyMany_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ManyMany_Marshal(m, &(*op)[i])
}

func ManyMany_Repeats_Marshal(m jsn.Marshaler, vals *[]ManyMany) error {
	return jsn.RepeatBlock(m, (*ManyMany_Slice)(vals))
}

func ManyMany_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ManyMany) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ManyMany_Repeats_Marshal(m, pv)
	}
	return
}

type ManyMany_Flow struct{ ptr *ManyMany }

func (n ManyMany_Flow) GetType() string      { return ManyMany_Type }
func (n ManyMany_Flow) GetLede() string      { return "kinds" }
func (n ManyMany_Flow) GetFlow() interface{} { return n.ptr }
func (n ManyMany_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ManyMany); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ManyMany_Optional_Marshal(m jsn.Marshaler, pv **ManyMany) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ManyMany_Marshal(m, *pv)
	} else if !enc {
		var v ManyMany
		if err = ManyMany_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ManyMany_Marshal(m jsn.Marshaler, val *ManyMany) (err error) {
	if err = m.MarshalBlock(ManyMany_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ManyMany_Field_Kinds)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ManyMany_Field_Kinds))
		}
		e1 := m.MarshalKey("to_kinds", ManyMany_Field_OtherKinds)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.OtherKinds)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ManyMany_Field_OtherKinds))
		}
		m.EndBlock()
	}
	return
}

// ManyOne
type ManyOne struct {
	Kinds     string `if:"label=_,type=text"`
	OtherKind string `if:"label=to_kind,type=text"`
}

func (*ManyOne) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyOne_Type,
		Uses: composer.Type_Flow,
		Lede: "kinds",
	}
}

const ManyOne_Type = "many_one"

const ManyOne_Field_Kinds = "$KINDS"
const ManyOne_Field_OtherKind = "$OTHER_KIND"

func (op *ManyOne) Marshal(m jsn.Marshaler) error {
	return ManyOne_Marshal(m, op)
}

type ManyOne_Slice []ManyOne

func (op *ManyOne_Slice) GetType() string { return ManyOne_Type }

func (op *ManyOne_Slice) Marshal(m jsn.Marshaler) error {
	return ManyOne_Repeats_Marshal(m, (*[]ManyOne)(op))
}

func (op *ManyOne_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ManyOne_Slice) SetSize(cnt int) {
	var els []ManyOne
	if cnt >= 0 {
		els = make(ManyOne_Slice, cnt)
	}
	(*op) = els
}

func (op *ManyOne_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ManyOne_Marshal(m, &(*op)[i])
}

func ManyOne_Repeats_Marshal(m jsn.Marshaler, vals *[]ManyOne) error {
	return jsn.RepeatBlock(m, (*ManyOne_Slice)(vals))
}

func ManyOne_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ManyOne) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ManyOne_Repeats_Marshal(m, pv)
	}
	return
}

type ManyOne_Flow struct{ ptr *ManyOne }

func (n ManyOne_Flow) GetType() string      { return ManyOne_Type }
func (n ManyOne_Flow) GetLede() string      { return "kinds" }
func (n ManyOne_Flow) GetFlow() interface{} { return n.ptr }
func (n ManyOne_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ManyOne); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ManyOne_Optional_Marshal(m jsn.Marshaler, pv **ManyOne) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ManyOne_Marshal(m, *pv)
	} else if !enc {
		var v ManyOne
		if err = ManyOne_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ManyOne_Marshal(m jsn.Marshaler, val *ManyOne) (err error) {
	if err = m.MarshalBlock(ManyOne_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ManyOne_Field_Kinds)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ManyOne_Field_Kinds))
		}
		e1 := m.MarshalKey("to_kind", ManyOne_Field_OtherKind)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.OtherKind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ManyOne_Field_OtherKind))
		}
		m.EndBlock()
	}
	return
}

// OneMany
type OneMany struct {
	Kind       string `if:"label=_,type=text"`
	OtherKinds string `if:"label=to_kinds,type=text"`
}

func (*OneMany) Compose() composer.Spec {
	return composer.Spec{
		Name: OneMany_Type,
		Uses: composer.Type_Flow,
		Lede: "kind",
	}
}

const OneMany_Type = "one_many"

const OneMany_Field_Kind = "$KIND"
const OneMany_Field_OtherKinds = "$OTHER_KINDS"

func (op *OneMany) Marshal(m jsn.Marshaler) error {
	return OneMany_Marshal(m, op)
}

type OneMany_Slice []OneMany

func (op *OneMany_Slice) GetType() string { return OneMany_Type }

func (op *OneMany_Slice) Marshal(m jsn.Marshaler) error {
	return OneMany_Repeats_Marshal(m, (*[]OneMany)(op))
}

func (op *OneMany_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *OneMany_Slice) SetSize(cnt int) {
	var els []OneMany
	if cnt >= 0 {
		els = make(OneMany_Slice, cnt)
	}
	(*op) = els
}

func (op *OneMany_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return OneMany_Marshal(m, &(*op)[i])
}

func OneMany_Repeats_Marshal(m jsn.Marshaler, vals *[]OneMany) error {
	return jsn.RepeatBlock(m, (*OneMany_Slice)(vals))
}

func OneMany_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]OneMany) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = OneMany_Repeats_Marshal(m, pv)
	}
	return
}

type OneMany_Flow struct{ ptr *OneMany }

func (n OneMany_Flow) GetType() string      { return OneMany_Type }
func (n OneMany_Flow) GetLede() string      { return "kind" }
func (n OneMany_Flow) GetFlow() interface{} { return n.ptr }
func (n OneMany_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*OneMany); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func OneMany_Optional_Marshal(m jsn.Marshaler, pv **OneMany) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = OneMany_Marshal(m, *pv)
	} else if !enc {
		var v OneMany
		if err = OneMany_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func OneMany_Marshal(m jsn.Marshaler, val *OneMany) (err error) {
	if err = m.MarshalBlock(OneMany_Flow{val}); err == nil {
		e0 := m.MarshalKey("", OneMany_Field_Kind)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kind)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", OneMany_Field_Kind))
		}
		e1 := m.MarshalKey("to_kinds", OneMany_Field_OtherKinds)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.OtherKinds)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", OneMany_Field_OtherKinds))
		}
		m.EndBlock()
	}
	return
}

// OneOne
type OneOne struct {
	Kind      string `if:"label=_,type=text"`
	OtherKind string `if:"label=to_kind,type=text"`
}

func (*OneOne) Compose() composer.Spec {
	return composer.Spec{
		Name: OneOne_Type,
		Uses: composer.Type_Flow,
		Lede: "kind",
	}
}

const OneOne_Type = "one_one"

const OneOne_Field_Kind = "$KIND"
const OneOne_Field_OtherKind = "$OTHER_KIND"

func (op *OneOne) Marshal(m jsn.Marshaler) error {
	return OneOne_Marshal(m, op)
}

type OneOne_Slice []OneOne

func (op *OneOne_Slice) GetType() string { return OneOne_Type }

func (op *OneOne_Slice) Marshal(m jsn.Marshaler) error {
	return OneOne_Repeats_Marshal(m, (*[]OneOne)(op))
}

func (op *OneOne_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *OneOne_Slice) SetSize(cnt int) {
	var els []OneOne
	if cnt >= 0 {
		els = make(OneOne_Slice, cnt)
	}
	(*op) = els
}

func (op *OneOne_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return OneOne_Marshal(m, &(*op)[i])
}

func OneOne_Repeats_Marshal(m jsn.Marshaler, vals *[]OneOne) error {
	return jsn.RepeatBlock(m, (*OneOne_Slice)(vals))
}

func OneOne_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]OneOne) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = OneOne_Repeats_Marshal(m, pv)
	}
	return
}

type OneOne_Flow struct{ ptr *OneOne }

func (n OneOne_Flow) GetType() string      { return OneOne_Type }
func (n OneOne_Flow) GetLede() string      { return "kind" }
func (n OneOne_Flow) GetFlow() interface{} { return n.ptr }
func (n OneOne_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*OneOne); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func OneOne_Optional_Marshal(m jsn.Marshaler, pv **OneOne) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = OneOne_Marshal(m, *pv)
	} else if !enc {
		var v OneOne
		if err = OneOne_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func OneOne_Marshal(m jsn.Marshaler, val *OneOne) (err error) {
	if err = m.MarshalBlock(OneOne_Flow{val}); err == nil {
		e0 := m.MarshalKey("", OneOne_Field_Kind)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kind)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", OneOne_Field_Kind))
		}
		e1 := m.MarshalKey("to_kind", OneOne_Field_OtherKind)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.OtherKind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", OneOne_Field_OtherKind))
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*Ephemera)(nil),
}

var Slats = []composer.Composer{
	(*Affinity)(nil),
	(*EphAliases)(nil),
	(*EphAspects)(nil),
	(*EphAt)(nil),
	(*EphBeginDomain)(nil),
	(*EphCardinality)(nil),
	(*EphEndDomain)(nil),
	(*EphFields)(nil),
	(*EphKinds)(nil),
	(*EphList)(nil),
	(*EphNouns)(nil),
	(*EphParams)(nil),
	(*EphPatterns)(nil),
	(*EphPlurals)(nil),
	(*EphPrograms)(nil),
	(*EphRelations)(nil),
	(*ManyMany)(nil),
	(*ManyOne)(nil),
	(*OneMany)(nil),
	(*OneOne)(nil),
}

var Signatures = map[uint64]interface{}{
	15711422147190391894: (*EphAliases)(nil),     /* Eph understand:as: */
	18295658173337269930: (*EphAspects)(nil),     /* Eph aspects:traits: */
	9182060341586636438:  (*EphAt)(nil),          /* Eph at:eph: */
	12209727080993772760: (*EphBeginDomain)(nil), /* Eph domain:requires: */
	12717235098097470366: (*EphCardinality)(nil), /* EphCardinality oneOne: */
	13014334328963404635: (*EphCardinality)(nil), /* EphCardinality oneMany: */
	874627862825420357:   (*EphCardinality)(nil), /* EphCardinality manyOne: */
	18342259850011553446: (*EphCardinality)(nil), /* EphCardinality manyMany: */
	4379746949646135194:  (*EphEndDomain)(nil),   /* Eph domain: */
	8381163068622333334:  (*EphFields)(nil),      /* Eph kinds:have:called: */
	12374005136224423943: (*EphFields)(nil),      /* Eph kinds:have:called:of: */
	9386889860419880175:  (*EphKinds)(nil),       /* Eph kinds:from: */
	11648725103497180078: (*EphList)(nil),        /* Eph list: */
	4810543164949198614:  (*EphNouns)(nil),       /* Eph noun:kind: */
	12259359132675429189: (*EphParams)(nil),      /* Eph have:called: */
	277028977564474262:   (*EphParams)(nil),      /* Eph have:called:of: */
	1611161010098549912:  (*EphPatterns)(nil),    /* Eph pattern: */
	14764503916681519581: (*EphPatterns)(nil),    /* Eph pattern:args: */
	7324201728182884878:  (*EphPatterns)(nil),    /* Eph pattern:locals: */
	11512083512716742729: (*EphPatterns)(nil),    /* Eph pattern:args:locals: */
	11252849383664709948: (*EphPatterns)(nil),    /* Eph pattern:return: */
	13754500090075776327: (*EphPatterns)(nil),    /* Eph pattern:args:return: */
	386808170159152854:   (*EphPatterns)(nil),    /* Eph pattern:locals:return: */
	10703276746650528267: (*EphPatterns)(nil),    /* Eph pattern:args:locals:return: */
	890409142408471553:   (*EphPlurals)(nil),     /* Eph plural:singular: */
	17377027355382879147: (*EphPrograms)(nil),    /* Eph go:run:using: */
	9811567312656774933:  (*EphRelations)(nil),   /* Eph:relate oneOne: */
	2078507782755484470:  (*EphRelations)(nil),   /* Eph:relate oneMany: */
	1697062231687722288:  (*EphRelations)(nil),   /* Eph:relate manyOne: */
	15063335060652852941: (*EphRelations)(nil),   /* Eph:relate manyMany: */
	13111067660678472252: (*ManyMany)(nil),       /* Kinds:toKinds: */
	15407091527463396937: (*ManyOne)(nil),        /* Kinds:toKind: */
	8349208709908405809:  (*OneMany)(nil),        /* Kind:toKinds: */
	11329972991603205158: (*OneOne)(nil),         /* Kind:toKind: */
}
