// Code generated by "makeops"; edit at your own risk.
package eph

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/dl/grammar"
	"git.sr.ht/~ionous/tapestry/dl/literal"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/jsn"
	"git.sr.ht/~ionous/tapestry/rt"
	"github.com/ionous/errutil"
)

// Affinity requires a predefined string.
type Affinity struct {
	Str string
}

func (op *Affinity) String() string {
	return op.Str
}

const Affinity_Bool = "$BOOL"
const Affinity_Number = "$NUMBER"
const Affinity_Text = "$TEXT"
const Affinity_Record = "$RECORD"
const Affinity_NumList = "$NUM_LIST"
const Affinity_TextList = "$TEXT_LIST"
const Affinity_RecordList = "$RECORD_LIST"

func (*Affinity) Compose() composer.Spec {
	return composer.Spec{
		Name: Affinity_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			Affinity_Bool, Affinity_Number, Affinity_Text, Affinity_Record, Affinity_NumList, Affinity_TextList, Affinity_RecordList,
		},
		Strings: []string{
			"bool", "number", "text", "record", "num_list", "text_list", "record_list",
		},
	}
}

const Affinity_Type = "affinity"

func (op *Affinity) Marshal(m jsn.Marshaler) error {
	return Affinity_Marshal(m, op)
}

func Affinity_Optional_Marshal(m jsn.Marshaler, val *Affinity) (err error) {
	var zero Affinity
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = Affinity_Marshal(m, val)
	}
	return
}

func Affinity_Marshal(m jsn.Marshaler, val *Affinity) (err error) {
	return m.MarshalValue(Affinity_Type, jsn.MakeEnum(val, &val.Str))
}

type Affinity_Slice []Affinity

func (op *Affinity_Slice) GetType() string { return Affinity_Type }

func (op *Affinity_Slice) Marshal(m jsn.Marshaler) error {
	return Affinity_Repeats_Marshal(m, (*[]Affinity)(op))
}

func (op *Affinity_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Affinity_Slice) SetSize(cnt int) {
	var els []Affinity
	if cnt >= 0 {
		els = make(Affinity_Slice, cnt)
	}
	(*op) = els
}

func (op *Affinity_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Affinity_Marshal(m, &(*op)[i])
}

func Affinity_Repeats_Marshal(m jsn.Marshaler, vals *[]Affinity) error {
	return jsn.RepeatBlock(m, (*Affinity_Slice)(vals))
}

func Affinity_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Affinity) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Affinity_Repeats_Marshal(m, pv)
	}
	return
}

// EphAliases
type EphAliases struct {
	ShortName string   `if:"label=understand,type=text"`
	Aliases   []string `if:"label=as,type=text"`
	Markup    map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphAliases)(nil)

func (*EphAliases) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAliases_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphAliases_Type = "eph_aliases"
const EphAliases_Field_ShortName = "$SHORT_NAME"
const EphAliases_Field_Aliases = "$ALIASES"

func (op *EphAliases) Marshal(m jsn.Marshaler) error {
	return EphAliases_Marshal(m, op)
}

type EphAliases_Slice []EphAliases

func (op *EphAliases_Slice) GetType() string { return EphAliases_Type }

func (op *EphAliases_Slice) Marshal(m jsn.Marshaler) error {
	return EphAliases_Repeats_Marshal(m, (*[]EphAliases)(op))
}

func (op *EphAliases_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAliases_Slice) SetSize(cnt int) {
	var els []EphAliases
	if cnt >= 0 {
		els = make(EphAliases_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAliases_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAliases_Marshal(m, &(*op)[i])
}

func EphAliases_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAliases) error {
	return jsn.RepeatBlock(m, (*EphAliases_Slice)(vals))
}

func EphAliases_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAliases) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphAliases_Repeats_Marshal(m, pv)
	}
	return
}

type EphAliases_Flow struct{ ptr *EphAliases }

func (n EphAliases_Flow) GetType() string      { return EphAliases_Type }
func (n EphAliases_Flow) GetLede() string      { return "eph" }
func (n EphAliases_Flow) GetFlow() interface{} { return n.ptr }
func (n EphAliases_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphAliases); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphAliases_Optional_Marshal(m jsn.Marshaler, pv **EphAliases) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphAliases_Marshal(m, *pv)
	} else if !enc {
		var v EphAliases
		if err = EphAliases_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphAliases_Marshal(m jsn.Marshaler, val *EphAliases) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphAliases_Flow{val}); err == nil {
		e0 := m.MarshalKey("understand", EphAliases_Field_ShortName)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.ShortName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphAliases_Field_ShortName))
		}
		e1 := m.MarshalKey("as", EphAliases_Field_Aliases)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Repeats_Marshal(m, &val.Aliases)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphAliases_Field_Aliases))
		}
		m.EndBlock()
	}
	return
}

// EphAlways requires a predefined string.
type EphAlways struct {
	Str string
}

func (op *EphAlways) String() string {
	return op.Str
}

const EphAlways_Always = "$ALWAYS"

func (*EphAlways) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAlways_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			EphAlways_Always,
		},
		Strings: []string{
			"always",
		},
	}
}

const EphAlways_Type = "eph_always"

func (op *EphAlways) Marshal(m jsn.Marshaler) error {
	return EphAlways_Marshal(m, op)
}

func EphAlways_Optional_Marshal(m jsn.Marshaler, val *EphAlways) (err error) {
	var zero EphAlways
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = EphAlways_Marshal(m, val)
	}
	return
}

func EphAlways_Marshal(m jsn.Marshaler, val *EphAlways) (err error) {
	return m.MarshalValue(EphAlways_Type, jsn.MakeEnum(val, &val.Str))
}

type EphAlways_Slice []EphAlways

func (op *EphAlways_Slice) GetType() string { return EphAlways_Type }

func (op *EphAlways_Slice) Marshal(m jsn.Marshaler) error {
	return EphAlways_Repeats_Marshal(m, (*[]EphAlways)(op))
}

func (op *EphAlways_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAlways_Slice) SetSize(cnt int) {
	var els []EphAlways
	if cnt >= 0 {
		els = make(EphAlways_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAlways_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAlways_Marshal(m, &(*op)[i])
}

func EphAlways_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAlways) error {
	return jsn.RepeatBlock(m, (*EphAlways_Slice)(vals))
}

func EphAlways_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAlways) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphAlways_Repeats_Marshal(m, pv)
	}
	return
}

// EphAspects A set of related object states such that exactly one member of the set is true for a given object at a single time.
// Generates an implicit kind of 'aspect' where every field of the kind is a boolean property.
type EphAspects struct {
	Aspects string   `if:"label=aspects,type=text"`
	Traits  []string `if:"label=traits,type=text"`
	Markup  map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphAspects)(nil)

func (*EphAspects) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAspects_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphAspects_Type = "eph_aspects"
const EphAspects_Field_Aspects = "$ASPECTS"
const EphAspects_Field_Traits = "$TRAITS"

func (op *EphAspects) Marshal(m jsn.Marshaler) error {
	return EphAspects_Marshal(m, op)
}

type EphAspects_Slice []EphAspects

func (op *EphAspects_Slice) GetType() string { return EphAspects_Type }

func (op *EphAspects_Slice) Marshal(m jsn.Marshaler) error {
	return EphAspects_Repeats_Marshal(m, (*[]EphAspects)(op))
}

func (op *EphAspects_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAspects_Slice) SetSize(cnt int) {
	var els []EphAspects
	if cnt >= 0 {
		els = make(EphAspects_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAspects_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAspects_Marshal(m, &(*op)[i])
}

func EphAspects_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAspects) error {
	return jsn.RepeatBlock(m, (*EphAspects_Slice)(vals))
}

func EphAspects_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAspects) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphAspects_Repeats_Marshal(m, pv)
	}
	return
}

type EphAspects_Flow struct{ ptr *EphAspects }

func (n EphAspects_Flow) GetType() string      { return EphAspects_Type }
func (n EphAspects_Flow) GetLede() string      { return "eph" }
func (n EphAspects_Flow) GetFlow() interface{} { return n.ptr }
func (n EphAspects_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphAspects); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphAspects_Optional_Marshal(m jsn.Marshaler, pv **EphAspects) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphAspects_Marshal(m, *pv)
	} else if !enc {
		var v EphAspects
		if err = EphAspects_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphAspects_Marshal(m jsn.Marshaler, val *EphAspects) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphAspects_Flow{val}); err == nil {
		e0 := m.MarshalKey("aspects", EphAspects_Field_Aspects)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Aspects)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphAspects_Field_Aspects))
		}
		e1 := m.MarshalKey("traits", EphAspects_Field_Traits)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Repeats_Marshal(m, &val.Traits)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphAspects_Field_Traits))
		}
		m.EndBlock()
	}
	return
}

// EphAt
type EphAt struct {
	At     string   `if:"label=at,type=text"`
	Eph    Ephemera `if:"label=eph"`
	Markup map[string]any
}

func (*EphAt) Compose() composer.Spec {
	return composer.Spec{
		Name: EphAt_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphAt_Type = "eph_at"
const EphAt_Field_At = "$AT"
const EphAt_Field_Eph = "$EPH"

func (op *EphAt) Marshal(m jsn.Marshaler) error {
	return EphAt_Marshal(m, op)
}

type EphAt_Slice []EphAt

func (op *EphAt_Slice) GetType() string { return EphAt_Type }

func (op *EphAt_Slice) Marshal(m jsn.Marshaler) error {
	return EphAt_Repeats_Marshal(m, (*[]EphAt)(op))
}

func (op *EphAt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphAt_Slice) SetSize(cnt int) {
	var els []EphAt
	if cnt >= 0 {
		els = make(EphAt_Slice, cnt)
	}
	(*op) = els
}

func (op *EphAt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphAt_Marshal(m, &(*op)[i])
}

func EphAt_Repeats_Marshal(m jsn.Marshaler, vals *[]EphAt) error {
	return jsn.RepeatBlock(m, (*EphAt_Slice)(vals))
}

func EphAt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphAt) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphAt_Repeats_Marshal(m, pv)
	}
	return
}

type EphAt_Flow struct{ ptr *EphAt }

func (n EphAt_Flow) GetType() string      { return EphAt_Type }
func (n EphAt_Flow) GetLede() string      { return "eph" }
func (n EphAt_Flow) GetFlow() interface{} { return n.ptr }
func (n EphAt_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphAt); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphAt_Optional_Marshal(m jsn.Marshaler, pv **EphAt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphAt_Marshal(m, *pv)
	} else if !enc {
		var v EphAt
		if err = EphAt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphAt_Marshal(m jsn.Marshaler, val *EphAt) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphAt_Flow{val}); err == nil {
		e0 := m.MarshalKey("at", EphAt_Field_At)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.At)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphAt_Field_At))
		}
		e1 := m.MarshalKey("eph", EphAt_Field_Eph)
		if e1 == nil {
			e1 = Ephemera_Marshal(m, &val.Eph)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphAt_Field_Eph))
		}
		m.EndBlock()
	}
	return
}

// EphBeginDomain
type EphBeginDomain struct {
	Name     string   `if:"label=domain,type=text"`
	Requires []string `if:"label=requires,type=text"`
	Markup   map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphBeginDomain)(nil)

func (*EphBeginDomain) Compose() composer.Spec {
	return composer.Spec{
		Name: EphBeginDomain_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphBeginDomain_Type = "eph_begin_domain"
const EphBeginDomain_Field_Name = "$NAME"
const EphBeginDomain_Field_Requires = "$REQUIRES"

func (op *EphBeginDomain) Marshal(m jsn.Marshaler) error {
	return EphBeginDomain_Marshal(m, op)
}

type EphBeginDomain_Slice []EphBeginDomain

func (op *EphBeginDomain_Slice) GetType() string { return EphBeginDomain_Type }

func (op *EphBeginDomain_Slice) Marshal(m jsn.Marshaler) error {
	return EphBeginDomain_Repeats_Marshal(m, (*[]EphBeginDomain)(op))
}

func (op *EphBeginDomain_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphBeginDomain_Slice) SetSize(cnt int) {
	var els []EphBeginDomain
	if cnt >= 0 {
		els = make(EphBeginDomain_Slice, cnt)
	}
	(*op) = els
}

func (op *EphBeginDomain_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphBeginDomain_Marshal(m, &(*op)[i])
}

func EphBeginDomain_Repeats_Marshal(m jsn.Marshaler, vals *[]EphBeginDomain) error {
	return jsn.RepeatBlock(m, (*EphBeginDomain_Slice)(vals))
}

func EphBeginDomain_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphBeginDomain) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphBeginDomain_Repeats_Marshal(m, pv)
	}
	return
}

type EphBeginDomain_Flow struct{ ptr *EphBeginDomain }

func (n EphBeginDomain_Flow) GetType() string      { return EphBeginDomain_Type }
func (n EphBeginDomain_Flow) GetLede() string      { return "eph" }
func (n EphBeginDomain_Flow) GetFlow() interface{} { return n.ptr }
func (n EphBeginDomain_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphBeginDomain); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphBeginDomain_Optional_Marshal(m jsn.Marshaler, pv **EphBeginDomain) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphBeginDomain_Marshal(m, *pv)
	} else if !enc {
		var v EphBeginDomain
		if err = EphBeginDomain_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphBeginDomain_Marshal(m jsn.Marshaler, val *EphBeginDomain) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphBeginDomain_Flow{val}); err == nil {
		e0 := m.MarshalKey("domain", EphBeginDomain_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphBeginDomain_Field_Name))
		}
		e1 := m.MarshalKey("requires", EphBeginDomain_Field_Requires)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Repeats_Marshal(m, &val.Requires)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphBeginDomain_Field_Requires))
		}
		m.EndBlock()
	}
	return
}

// EphCardinality swaps between various options
type EphCardinality struct {
	Choice string
	Value  interface{}
}

var EphCardinality_Optional_Marshal = EphCardinality_Marshal

const EphCardinality_OneOne_Opt = "$ONE_ONE"
const EphCardinality_OneMany_Opt = "$ONE_MANY"
const EphCardinality_ManyOne_Opt = "$MANY_ONE"
const EphCardinality_ManyMany_Opt = "$MANY_MANY"

func (*EphCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: EphCardinality_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			EphCardinality_OneOne_Opt, EphCardinality_OneMany_Opt, EphCardinality_ManyOne_Opt, EphCardinality_ManyMany_Opt,
		},
		Swaps: []interface{}{
			(*OneOne)(nil),
			(*OneMany)(nil),
			(*ManyOne)(nil),
			(*ManyMany)(nil),
		},
	}
}

const EphCardinality_Type = "eph_cardinality"

func (op *EphCardinality) GetType() string { return EphCardinality_Type }

func (op *EphCardinality) GetSwap() (string, interface{}) {
	return op.Choice, op.Value
}

func (op *EphCardinality) SetSwap(c string) (okay bool) {
	switch c {
	case "":
		op.Choice, op.Value = c, nil
		okay = true
	case EphCardinality_OneOne_Opt:
		op.Choice, op.Value = c, new(OneOne)
		okay = true
	case EphCardinality_OneMany_Opt:
		op.Choice, op.Value = c, new(OneMany)
		okay = true
	case EphCardinality_ManyOne_Opt:
		op.Choice, op.Value = c, new(ManyOne)
		okay = true
	case EphCardinality_ManyMany_Opt:
		op.Choice, op.Value = c, new(ManyMany)
		okay = true
	}
	return
}

func (op *EphCardinality) Marshal(m jsn.Marshaler) error {
	return EphCardinality_Marshal(m, op)
}
func EphCardinality_Marshal(m jsn.Marshaler, val *EphCardinality) (err error) {
	if err = m.MarshalBlock(val); err == nil {
		if _, ptr := val.GetSwap(); ptr != nil {
			if e := ptr.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}

type EphCardinality_Slice []EphCardinality

func (op *EphCardinality_Slice) GetType() string { return EphCardinality_Type }

func (op *EphCardinality_Slice) Marshal(m jsn.Marshaler) error {
	return EphCardinality_Repeats_Marshal(m, (*[]EphCardinality)(op))
}

func (op *EphCardinality_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphCardinality_Slice) SetSize(cnt int) {
	var els []EphCardinality
	if cnt >= 0 {
		els = make(EphCardinality_Slice, cnt)
	}
	(*op) = els
}

func (op *EphCardinality_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphCardinality_Marshal(m, &(*op)[i])
}

func EphCardinality_Repeats_Marshal(m jsn.Marshaler, vals *[]EphCardinality) error {
	return jsn.RepeatBlock(m, (*EphCardinality_Slice)(vals))
}

func EphCardinality_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphCardinality) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphCardinality_Repeats_Marshal(m, pv)
	}
	return
}

// EphChecks
type EphChecks struct {
	Name   string               `if:"label=check,type=text"`
	Expect literal.LiteralValue `if:"label=expect,optional"`
	Exe    []rt.Execute         `if:"label=does"`
	Markup map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphChecks)(nil)

func (*EphChecks) Compose() composer.Spec {
	return composer.Spec{
		Name: EphChecks_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphChecks_Type = "eph_checks"
const EphChecks_Field_Name = "$NAME"
const EphChecks_Field_Expect = "$EXPECT"
const EphChecks_Field_Exe = "$EXE"

func (op *EphChecks) Marshal(m jsn.Marshaler) error {
	return EphChecks_Marshal(m, op)
}

type EphChecks_Slice []EphChecks

func (op *EphChecks_Slice) GetType() string { return EphChecks_Type }

func (op *EphChecks_Slice) Marshal(m jsn.Marshaler) error {
	return EphChecks_Repeats_Marshal(m, (*[]EphChecks)(op))
}

func (op *EphChecks_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphChecks_Slice) SetSize(cnt int) {
	var els []EphChecks
	if cnt >= 0 {
		els = make(EphChecks_Slice, cnt)
	}
	(*op) = els
}

func (op *EphChecks_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphChecks_Marshal(m, &(*op)[i])
}

func EphChecks_Repeats_Marshal(m jsn.Marshaler, vals *[]EphChecks) error {
	return jsn.RepeatBlock(m, (*EphChecks_Slice)(vals))
}

func EphChecks_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphChecks) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphChecks_Repeats_Marshal(m, pv)
	}
	return
}

type EphChecks_Flow struct{ ptr *EphChecks }

func (n EphChecks_Flow) GetType() string      { return EphChecks_Type }
func (n EphChecks_Flow) GetLede() string      { return "eph" }
func (n EphChecks_Flow) GetFlow() interface{} { return n.ptr }
func (n EphChecks_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphChecks); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphChecks_Optional_Marshal(m jsn.Marshaler, pv **EphChecks) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphChecks_Marshal(m, *pv)
	} else if !enc {
		var v EphChecks
		if err = EphChecks_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphChecks_Marshal(m jsn.Marshaler, val *EphChecks) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphChecks_Flow{val}); err == nil {
		e0 := m.MarshalKey("check", EphChecks_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphChecks_Field_Name))
		}
		e1 := m.MarshalKey("expect", EphChecks_Field_Expect)
		if e1 == nil {
			e1 = literal.LiteralValue_Optional_Marshal(m, &val.Expect)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphChecks_Field_Expect))
		}
		e2 := m.MarshalKey("does", EphChecks_Field_Exe)
		if e2 == nil {
			e2 = rt.Execute_Repeats_Marshal(m, &val.Exe)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphChecks_Field_Exe))
		}
		m.EndBlock()
	}
	return
}

// EphDirectives
type EphDirectives struct {
	Name      string            `if:"label=go,type=text"`
	Directive grammar.Directive `if:"label=parse"`
	Markup    map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphDirectives)(nil)

func (*EphDirectives) Compose() composer.Spec {
	return composer.Spec{
		Name: EphDirectives_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphDirectives_Type = "eph_directives"
const EphDirectives_Field_Name = "$NAME"
const EphDirectives_Field_Directive = "$DIRECTIVE"

func (op *EphDirectives) Marshal(m jsn.Marshaler) error {
	return EphDirectives_Marshal(m, op)
}

type EphDirectives_Slice []EphDirectives

func (op *EphDirectives_Slice) GetType() string { return EphDirectives_Type }

func (op *EphDirectives_Slice) Marshal(m jsn.Marshaler) error {
	return EphDirectives_Repeats_Marshal(m, (*[]EphDirectives)(op))
}

func (op *EphDirectives_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphDirectives_Slice) SetSize(cnt int) {
	var els []EphDirectives
	if cnt >= 0 {
		els = make(EphDirectives_Slice, cnt)
	}
	(*op) = els
}

func (op *EphDirectives_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphDirectives_Marshal(m, &(*op)[i])
}

func EphDirectives_Repeats_Marshal(m jsn.Marshaler, vals *[]EphDirectives) error {
	return jsn.RepeatBlock(m, (*EphDirectives_Slice)(vals))
}

func EphDirectives_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphDirectives) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphDirectives_Repeats_Marshal(m, pv)
	}
	return
}

type EphDirectives_Flow struct{ ptr *EphDirectives }

func (n EphDirectives_Flow) GetType() string      { return EphDirectives_Type }
func (n EphDirectives_Flow) GetLede() string      { return "eph" }
func (n EphDirectives_Flow) GetFlow() interface{} { return n.ptr }
func (n EphDirectives_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphDirectives); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphDirectives_Optional_Marshal(m jsn.Marshaler, pv **EphDirectives) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphDirectives_Marshal(m, *pv)
	} else if !enc {
		var v EphDirectives
		if err = EphDirectives_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphDirectives_Marshal(m jsn.Marshaler, val *EphDirectives) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphDirectives_Flow{val}); err == nil {
		e0 := m.MarshalKey("go", EphDirectives_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphDirectives_Field_Name))
		}
		e1 := m.MarshalKey("parse", EphDirectives_Field_Directive)
		if e1 == nil {
			e1 = grammar.Directive_Marshal(m, &val.Directive)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphDirectives_Field_Directive))
		}
		m.EndBlock()
	}
	return
}

// EphEndDomain
type EphEndDomain struct {
	Name   string `if:"label=domain,type=text"`
	Markup map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphEndDomain)(nil)

func (*EphEndDomain) Compose() composer.Spec {
	return composer.Spec{
		Name: EphEndDomain_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphEndDomain_Type = "eph_end_domain"
const EphEndDomain_Field_Name = "$NAME"

func (op *EphEndDomain) Marshal(m jsn.Marshaler) error {
	return EphEndDomain_Marshal(m, op)
}

type EphEndDomain_Slice []EphEndDomain

func (op *EphEndDomain_Slice) GetType() string { return EphEndDomain_Type }

func (op *EphEndDomain_Slice) Marshal(m jsn.Marshaler) error {
	return EphEndDomain_Repeats_Marshal(m, (*[]EphEndDomain)(op))
}

func (op *EphEndDomain_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphEndDomain_Slice) SetSize(cnt int) {
	var els []EphEndDomain
	if cnt >= 0 {
		els = make(EphEndDomain_Slice, cnt)
	}
	(*op) = els
}

func (op *EphEndDomain_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphEndDomain_Marshal(m, &(*op)[i])
}

func EphEndDomain_Repeats_Marshal(m jsn.Marshaler, vals *[]EphEndDomain) error {
	return jsn.RepeatBlock(m, (*EphEndDomain_Slice)(vals))
}

func EphEndDomain_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphEndDomain) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphEndDomain_Repeats_Marshal(m, pv)
	}
	return
}

type EphEndDomain_Flow struct{ ptr *EphEndDomain }

func (n EphEndDomain_Flow) GetType() string      { return EphEndDomain_Type }
func (n EphEndDomain_Flow) GetLede() string      { return "eph" }
func (n EphEndDomain_Flow) GetFlow() interface{} { return n.ptr }
func (n EphEndDomain_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphEndDomain); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphEndDomain_Optional_Marshal(m jsn.Marshaler, pv **EphEndDomain) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphEndDomain_Marshal(m, *pv)
	} else if !enc {
		var v EphEndDomain
		if err = EphEndDomain_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphEndDomain_Marshal(m jsn.Marshaler, val *EphEndDomain) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphEndDomain_Flow{val}); err == nil {
		e0 := m.MarshalKey("domain", EphEndDomain_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphEndDomain_Field_Name))
		}
		m.EndBlock()
	}
	return
}

// EphKinds A new type deriving from another existing type.
// The new kind has all of the properties of all of its ancestor kinds
// and it can be used wherever one of its ancestor kinds is needed.
// ( The reverse isn't true because the new kind can have its own unique properties not available to its ancestors. )
type EphKinds struct {
	Kinds   string      `if:"label=kinds,type=text"`
	From    string      `if:"label=from,type=text"`
	Contain []EphParams `if:"label=contain"`
	Markup  map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphKinds)(nil)

func (*EphKinds) Compose() composer.Spec {
	return composer.Spec{
		Name: EphKinds_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphKinds_Type = "eph_kinds"
const EphKinds_Field_Kinds = "$KINDS"
const EphKinds_Field_From = "$FROM"
const EphKinds_Field_Contain = "$CONTAIN"

func (op *EphKinds) Marshal(m jsn.Marshaler) error {
	return EphKinds_Marshal(m, op)
}

type EphKinds_Slice []EphKinds

func (op *EphKinds_Slice) GetType() string { return EphKinds_Type }

func (op *EphKinds_Slice) Marshal(m jsn.Marshaler) error {
	return EphKinds_Repeats_Marshal(m, (*[]EphKinds)(op))
}

func (op *EphKinds_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphKinds_Slice) SetSize(cnt int) {
	var els []EphKinds
	if cnt >= 0 {
		els = make(EphKinds_Slice, cnt)
	}
	(*op) = els
}

func (op *EphKinds_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphKinds_Marshal(m, &(*op)[i])
}

func EphKinds_Repeats_Marshal(m jsn.Marshaler, vals *[]EphKinds) error {
	return jsn.RepeatBlock(m, (*EphKinds_Slice)(vals))
}

func EphKinds_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphKinds) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphKinds_Repeats_Marshal(m, pv)
	}
	return
}

type EphKinds_Flow struct{ ptr *EphKinds }

func (n EphKinds_Flow) GetType() string      { return EphKinds_Type }
func (n EphKinds_Flow) GetLede() string      { return "eph" }
func (n EphKinds_Flow) GetFlow() interface{} { return n.ptr }
func (n EphKinds_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphKinds); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphKinds_Optional_Marshal(m jsn.Marshaler, pv **EphKinds) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphKinds_Marshal(m, *pv)
	} else if !enc {
		var v EphKinds
		if err = EphKinds_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphKinds_Marshal(m jsn.Marshaler, val *EphKinds) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphKinds_Flow{val}); err == nil {
		e0 := m.MarshalKey("kinds", EphKinds_Field_Kinds)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphKinds_Field_Kinds))
		}
		e1 := m.MarshalKey("from", EphKinds_Field_From)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphKinds_Field_From))
		}
		e2 := m.MarshalKey("contain", EphKinds_Field_Contain)
		if e2 == nil {
			e2 = EphParams_Repeats_Marshal(m, &val.Contain)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphKinds_Field_Contain))
		}
		m.EndBlock()
	}
	return
}

// EphList
type EphList struct {
	All    []EphAt `if:"label=list"`
	Markup map[string]any
}

func (*EphList) Compose() composer.Spec {
	return composer.Spec{
		Name: EphList_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphList_Type = "eph_list"
const EphList_Field_All = "$ALL"

func (op *EphList) Marshal(m jsn.Marshaler) error {
	return EphList_Marshal(m, op)
}

type EphList_Slice []EphList

func (op *EphList_Slice) GetType() string { return EphList_Type }

func (op *EphList_Slice) Marshal(m jsn.Marshaler) error {
	return EphList_Repeats_Marshal(m, (*[]EphList)(op))
}

func (op *EphList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphList_Slice) SetSize(cnt int) {
	var els []EphList
	if cnt >= 0 {
		els = make(EphList_Slice, cnt)
	}
	(*op) = els
}

func (op *EphList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphList_Marshal(m, &(*op)[i])
}

func EphList_Repeats_Marshal(m jsn.Marshaler, vals *[]EphList) error {
	return jsn.RepeatBlock(m, (*EphList_Slice)(vals))
}

func EphList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphList_Repeats_Marshal(m, pv)
	}
	return
}

type EphList_Flow struct{ ptr *EphList }

func (n EphList_Flow) GetType() string      { return EphList_Type }
func (n EphList_Flow) GetLede() string      { return "eph" }
func (n EphList_Flow) GetFlow() interface{} { return n.ptr }
func (n EphList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphList_Optional_Marshal(m jsn.Marshaler, pv **EphList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphList_Marshal(m, *pv)
	} else if !enc {
		var v EphList
		if err = EphList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphList_Marshal(m jsn.Marshaler, val *EphList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphList_Flow{val}); err == nil {
		e0 := m.MarshalKey("list", EphList_Field_All)
		if e0 == nil {
			e0 = EphAt_Repeats_Marshal(m, &val.All)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphList_Field_All))
		}
		m.EndBlock()
	}
	return
}

// EphNouns
type EphNouns struct {
	Noun   string `if:"label=noun,type=text"`
	Kind   string `if:"label=kind,type=text"`
	Markup map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphNouns)(nil)

func (*EphNouns) Compose() composer.Spec {
	return composer.Spec{
		Name: EphNouns_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphNouns_Type = "eph_nouns"
const EphNouns_Field_Noun = "$NOUN"
const EphNouns_Field_Kind = "$KIND"

func (op *EphNouns) Marshal(m jsn.Marshaler) error {
	return EphNouns_Marshal(m, op)
}

type EphNouns_Slice []EphNouns

func (op *EphNouns_Slice) GetType() string { return EphNouns_Type }

func (op *EphNouns_Slice) Marshal(m jsn.Marshaler) error {
	return EphNouns_Repeats_Marshal(m, (*[]EphNouns)(op))
}

func (op *EphNouns_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphNouns_Slice) SetSize(cnt int) {
	var els []EphNouns
	if cnt >= 0 {
		els = make(EphNouns_Slice, cnt)
	}
	(*op) = els
}

func (op *EphNouns_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphNouns_Marshal(m, &(*op)[i])
}

func EphNouns_Repeats_Marshal(m jsn.Marshaler, vals *[]EphNouns) error {
	return jsn.RepeatBlock(m, (*EphNouns_Slice)(vals))
}

func EphNouns_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphNouns) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphNouns_Repeats_Marshal(m, pv)
	}
	return
}

type EphNouns_Flow struct{ ptr *EphNouns }

func (n EphNouns_Flow) GetType() string      { return EphNouns_Type }
func (n EphNouns_Flow) GetLede() string      { return "eph" }
func (n EphNouns_Flow) GetFlow() interface{} { return n.ptr }
func (n EphNouns_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphNouns); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphNouns_Optional_Marshal(m jsn.Marshaler, pv **EphNouns) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphNouns_Marshal(m, *pv)
	} else if !enc {
		var v EphNouns
		if err = EphNouns_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphNouns_Marshal(m jsn.Marshaler, val *EphNouns) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphNouns_Flow{val}); err == nil {
		e0 := m.MarshalKey("noun", EphNouns_Field_Noun)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Noun)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphNouns_Field_Noun))
		}
		e1 := m.MarshalKey("kind", EphNouns_Field_Kind)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Kind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphNouns_Field_Kind))
		}
		m.EndBlock()
	}
	return
}

// EphOpposites Rules for transforming plural text to singular text and back again.
// Used by the assembler to help interpret author definitions,
// and at runtime to help the parser interpret user input.
type EphOpposites struct {
	Opposite string `if:"label=opposite,type=text"`
	Word     string `if:"label=word,type=text"`
	Markup   map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphOpposites)(nil)

func (*EphOpposites) Compose() composer.Spec {
	return composer.Spec{
		Name: EphOpposites_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphOpposites_Type = "eph_opposites"
const EphOpposites_Field_Opposite = "$OPPOSITE"
const EphOpposites_Field_Word = "$WORD"

func (op *EphOpposites) Marshal(m jsn.Marshaler) error {
	return EphOpposites_Marshal(m, op)
}

type EphOpposites_Slice []EphOpposites

func (op *EphOpposites_Slice) GetType() string { return EphOpposites_Type }

func (op *EphOpposites_Slice) Marshal(m jsn.Marshaler) error {
	return EphOpposites_Repeats_Marshal(m, (*[]EphOpposites)(op))
}

func (op *EphOpposites_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphOpposites_Slice) SetSize(cnt int) {
	var els []EphOpposites
	if cnt >= 0 {
		els = make(EphOpposites_Slice, cnt)
	}
	(*op) = els
}

func (op *EphOpposites_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphOpposites_Marshal(m, &(*op)[i])
}

func EphOpposites_Repeats_Marshal(m jsn.Marshaler, vals *[]EphOpposites) error {
	return jsn.RepeatBlock(m, (*EphOpposites_Slice)(vals))
}

func EphOpposites_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphOpposites) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphOpposites_Repeats_Marshal(m, pv)
	}
	return
}

type EphOpposites_Flow struct{ ptr *EphOpposites }

func (n EphOpposites_Flow) GetType() string      { return EphOpposites_Type }
func (n EphOpposites_Flow) GetLede() string      { return "eph" }
func (n EphOpposites_Flow) GetFlow() interface{} { return n.ptr }
func (n EphOpposites_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphOpposites); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphOpposites_Optional_Marshal(m jsn.Marshaler, pv **EphOpposites) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphOpposites_Marshal(m, *pv)
	} else if !enc {
		var v EphOpposites
		if err = EphOpposites_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphOpposites_Marshal(m jsn.Marshaler, val *EphOpposites) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphOpposites_Flow{val}); err == nil {
		e0 := m.MarshalKey("opposite", EphOpposites_Field_Opposite)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Opposite)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphOpposites_Field_Opposite))
		}
		e1 := m.MarshalKey("word", EphOpposites_Field_Word)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Word)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphOpposites_Field_Word))
		}
		m.EndBlock()
	}
	return
}

// EphParams 'Affinity' designates the storage type of a given parameter
// while 'class' is used to indicate an interpretation of that parameter, for example a reference to a kind.
// Pattern locals can have an initial value, other uses of parameter cannot.
type EphParams struct {
	Affinity  Affinity          `if:"label=have"`
	Name      string            `if:"label=called,type=text"`
	Class     string            `if:"label=of,optional,type=text"`
	Initially assign.Assignment `if:"label=initially,optional"`
	Markup    map[string]any
}

func (*EphParams) Compose() composer.Spec {
	return composer.Spec{
		Name: EphParams_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphParams_Type = "eph_params"
const EphParams_Field_Affinity = "$AFFINITY"
const EphParams_Field_Name = "$NAME"
const EphParams_Field_Class = "$CLASS"
const EphParams_Field_Initially = "$INITIALLY"

func (op *EphParams) Marshal(m jsn.Marshaler) error {
	return EphParams_Marshal(m, op)
}

type EphParams_Slice []EphParams

func (op *EphParams_Slice) GetType() string { return EphParams_Type }

func (op *EphParams_Slice) Marshal(m jsn.Marshaler) error {
	return EphParams_Repeats_Marshal(m, (*[]EphParams)(op))
}

func (op *EphParams_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphParams_Slice) SetSize(cnt int) {
	var els []EphParams
	if cnt >= 0 {
		els = make(EphParams_Slice, cnt)
	}
	(*op) = els
}

func (op *EphParams_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphParams_Marshal(m, &(*op)[i])
}

func EphParams_Repeats_Marshal(m jsn.Marshaler, vals *[]EphParams) error {
	return jsn.RepeatBlock(m, (*EphParams_Slice)(vals))
}

func EphParams_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphParams) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphParams_Repeats_Marshal(m, pv)
	}
	return
}

type EphParams_Flow struct{ ptr *EphParams }

func (n EphParams_Flow) GetType() string      { return EphParams_Type }
func (n EphParams_Flow) GetLede() string      { return "eph" }
func (n EphParams_Flow) GetFlow() interface{} { return n.ptr }
func (n EphParams_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphParams); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphParams_Optional_Marshal(m jsn.Marshaler, pv **EphParams) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphParams_Marshal(m, *pv)
	} else if !enc {
		var v EphParams
		if err = EphParams_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphParams_Marshal(m jsn.Marshaler, val *EphParams) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphParams_Flow{val}); err == nil {
		e0 := m.MarshalKey("have", EphParams_Field_Affinity)
		if e0 == nil {
			e0 = Affinity_Marshal(m, &val.Affinity)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphParams_Field_Affinity))
		}
		e1 := m.MarshalKey("called", EphParams_Field_Name)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphParams_Field_Name))
		}
		e2 := m.MarshalKey("of", EphParams_Field_Class)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Optional_Marshal(m, &val.Class)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphParams_Field_Class))
		}
		e3 := m.MarshalKey("initially", EphParams_Field_Initially)
		if e3 == nil {
			e3 = assign.Assignment_Optional_Marshal(m, &val.Initially)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", EphParams_Field_Initially))
		}
		m.EndBlock()
	}
	return
}

// EphPatterns Patterns provide author reusable code.
// The parameters define values provided by the caller.
// Locals provide scratch values for use during pattern processing.
// The result allows the pattern to return a value to the caller of pattern.
// While multiple pattern commands can be used to define a pattern,
// the set of arguments and the return can only be specified once.
type EphPatterns struct {
	PatternName string      `if:"label=pattern,type=text"`
	Params      []EphParams `if:"label=with,optional"`
	Locals      []EphParams `if:"label=locals,optional"`
	Result      *EphParams  `if:"label=result,optional"`
	Markup      map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphPatterns)(nil)

func (*EphPatterns) Compose() composer.Spec {
	return composer.Spec{
		Name: EphPatterns_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphPatterns_Type = "eph_patterns"
const EphPatterns_Field_PatternName = "$PATTERN_NAME"
const EphPatterns_Field_Params = "$PARAMS"
const EphPatterns_Field_Locals = "$LOCALS"
const EphPatterns_Field_Result = "$RESULT"

func (op *EphPatterns) Marshal(m jsn.Marshaler) error {
	return EphPatterns_Marshal(m, op)
}

type EphPatterns_Slice []EphPatterns

func (op *EphPatterns_Slice) GetType() string { return EphPatterns_Type }

func (op *EphPatterns_Slice) Marshal(m jsn.Marshaler) error {
	return EphPatterns_Repeats_Marshal(m, (*[]EphPatterns)(op))
}

func (op *EphPatterns_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphPatterns_Slice) SetSize(cnt int) {
	var els []EphPatterns
	if cnt >= 0 {
		els = make(EphPatterns_Slice, cnt)
	}
	(*op) = els
}

func (op *EphPatterns_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphPatterns_Marshal(m, &(*op)[i])
}

func EphPatterns_Repeats_Marshal(m jsn.Marshaler, vals *[]EphPatterns) error {
	return jsn.RepeatBlock(m, (*EphPatterns_Slice)(vals))
}

func EphPatterns_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphPatterns) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphPatterns_Repeats_Marshal(m, pv)
	}
	return
}

type EphPatterns_Flow struct{ ptr *EphPatterns }

func (n EphPatterns_Flow) GetType() string      { return EphPatterns_Type }
func (n EphPatterns_Flow) GetLede() string      { return "eph" }
func (n EphPatterns_Flow) GetFlow() interface{} { return n.ptr }
func (n EphPatterns_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphPatterns); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphPatterns_Optional_Marshal(m jsn.Marshaler, pv **EphPatterns) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphPatterns_Marshal(m, *pv)
	} else if !enc {
		var v EphPatterns
		if err = EphPatterns_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphPatterns_Marshal(m jsn.Marshaler, val *EphPatterns) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphPatterns_Flow{val}); err == nil {
		e0 := m.MarshalKey("pattern", EphPatterns_Field_PatternName)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.PatternName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphPatterns_Field_PatternName))
		}
		e1 := m.MarshalKey("with", EphPatterns_Field_Params)
		if e1 == nil {
			e1 = EphParams_Optional_Repeats_Marshal(m, &val.Params)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphPatterns_Field_Params))
		}
		e2 := m.MarshalKey("locals", EphPatterns_Field_Locals)
		if e2 == nil {
			e2 = EphParams_Optional_Repeats_Marshal(m, &val.Locals)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphPatterns_Field_Locals))
		}
		e3 := m.MarshalKey("result", EphPatterns_Field_Result)
		if e3 == nil {
			e3 = EphParams_Optional_Marshal(m, &val.Result)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", EphPatterns_Field_Result))
		}
		m.EndBlock()
	}
	return
}

// EphPlurals Rules for transforming plural text to singular text and back again.
// Used by the assembler to help interpret author definitions,
// and at runtime to help the parser interpret user input.
type EphPlurals struct {
	Plural   string `if:"label=plural,type=text"`
	Singular string `if:"label=singular,type=text"`
	Markup   map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphPlurals)(nil)

func (*EphPlurals) Compose() composer.Spec {
	return composer.Spec{
		Name: EphPlurals_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphPlurals_Type = "eph_plurals"
const EphPlurals_Field_Plural = "$PLURAL"
const EphPlurals_Field_Singular = "$SINGULAR"

func (op *EphPlurals) Marshal(m jsn.Marshaler) error {
	return EphPlurals_Marshal(m, op)
}

type EphPlurals_Slice []EphPlurals

func (op *EphPlurals_Slice) GetType() string { return EphPlurals_Type }

func (op *EphPlurals_Slice) Marshal(m jsn.Marshaler) error {
	return EphPlurals_Repeats_Marshal(m, (*[]EphPlurals)(op))
}

func (op *EphPlurals_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphPlurals_Slice) SetSize(cnt int) {
	var els []EphPlurals
	if cnt >= 0 {
		els = make(EphPlurals_Slice, cnt)
	}
	(*op) = els
}

func (op *EphPlurals_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphPlurals_Marshal(m, &(*op)[i])
}

func EphPlurals_Repeats_Marshal(m jsn.Marshaler, vals *[]EphPlurals) error {
	return jsn.RepeatBlock(m, (*EphPlurals_Slice)(vals))
}

func EphPlurals_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphPlurals) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphPlurals_Repeats_Marshal(m, pv)
	}
	return
}

type EphPlurals_Flow struct{ ptr *EphPlurals }

func (n EphPlurals_Flow) GetType() string      { return EphPlurals_Type }
func (n EphPlurals_Flow) GetLede() string      { return "eph" }
func (n EphPlurals_Flow) GetFlow() interface{} { return n.ptr }
func (n EphPlurals_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphPlurals); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphPlurals_Optional_Marshal(m jsn.Marshaler, pv **EphPlurals) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphPlurals_Marshal(m, *pv)
	} else if !enc {
		var v EphPlurals
		if err = EphPlurals_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphPlurals_Marshal(m jsn.Marshaler, val *EphPlurals) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphPlurals_Flow{val}); err == nil {
		e0 := m.MarshalKey("plural", EphPlurals_Field_Plural)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Plural)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphPlurals_Field_Plural))
		}
		e1 := m.MarshalKey("singular", EphPlurals_Field_Singular)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Singular)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphPlurals_Field_Singular))
		}
		m.EndBlock()
	}
	return
}

// EphRefs Implies some fact about the world that will be defined elsewhere.
// Reuses the set of ephemera to limit redefinition. Not all are valid.
type EphRefs struct {
	Refs   []Ephemera `if:"label=refs"`
	Markup map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphRefs)(nil)

func (*EphRefs) Compose() composer.Spec {
	return composer.Spec{
		Name: EphRefs_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphRefs_Type = "eph_refs"
const EphRefs_Field_Refs = "$REFS"

func (op *EphRefs) Marshal(m jsn.Marshaler) error {
	return EphRefs_Marshal(m, op)
}

type EphRefs_Slice []EphRefs

func (op *EphRefs_Slice) GetType() string { return EphRefs_Type }

func (op *EphRefs_Slice) Marshal(m jsn.Marshaler) error {
	return EphRefs_Repeats_Marshal(m, (*[]EphRefs)(op))
}

func (op *EphRefs_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphRefs_Slice) SetSize(cnt int) {
	var els []EphRefs
	if cnt >= 0 {
		els = make(EphRefs_Slice, cnt)
	}
	(*op) = els
}

func (op *EphRefs_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphRefs_Marshal(m, &(*op)[i])
}

func EphRefs_Repeats_Marshal(m jsn.Marshaler, vals *[]EphRefs) error {
	return jsn.RepeatBlock(m, (*EphRefs_Slice)(vals))
}

func EphRefs_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphRefs) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphRefs_Repeats_Marshal(m, pv)
	}
	return
}

type EphRefs_Flow struct{ ptr *EphRefs }

func (n EphRefs_Flow) GetType() string      { return EphRefs_Type }
func (n EphRefs_Flow) GetLede() string      { return "eph" }
func (n EphRefs_Flow) GetFlow() interface{} { return n.ptr }
func (n EphRefs_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphRefs); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphRefs_Optional_Marshal(m jsn.Marshaler, pv **EphRefs) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphRefs_Marshal(m, *pv)
	} else if !enc {
		var v EphRefs
		if err = EphRefs_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphRefs_Marshal(m jsn.Marshaler, val *EphRefs) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphRefs_Flow{val}); err == nil {
		e0 := m.MarshalKey("refs", EphRefs_Field_Refs)
		if e0 == nil {
			e0 = Ephemera_Repeats_Marshal(m, &val.Refs)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphRefs_Field_Refs))
		}
		m.EndBlock()
	}
	return
}

// EphRelations
type EphRelations struct {
	Rel         string         `if:"label=_,type=text"`
	Cardinality EphCardinality `if:"label=relate"`
	Markup      map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphRelations)(nil)

func (*EphRelations) Compose() composer.Spec {
	return composer.Spec{
		Name: EphRelations_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphRelations_Type = "eph_relations"
const EphRelations_Field_Rel = "$REL"
const EphRelations_Field_Cardinality = "$CARDINALITY"

func (op *EphRelations) Marshal(m jsn.Marshaler) error {
	return EphRelations_Marshal(m, op)
}

type EphRelations_Slice []EphRelations

func (op *EphRelations_Slice) GetType() string { return EphRelations_Type }

func (op *EphRelations_Slice) Marshal(m jsn.Marshaler) error {
	return EphRelations_Repeats_Marshal(m, (*[]EphRelations)(op))
}

func (op *EphRelations_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphRelations_Slice) SetSize(cnt int) {
	var els []EphRelations
	if cnt >= 0 {
		els = make(EphRelations_Slice, cnt)
	}
	(*op) = els
}

func (op *EphRelations_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphRelations_Marshal(m, &(*op)[i])
}

func EphRelations_Repeats_Marshal(m jsn.Marshaler, vals *[]EphRelations) error {
	return jsn.RepeatBlock(m, (*EphRelations_Slice)(vals))
}

func EphRelations_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphRelations) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphRelations_Repeats_Marshal(m, pv)
	}
	return
}

type EphRelations_Flow struct{ ptr *EphRelations }

func (n EphRelations_Flow) GetType() string      { return EphRelations_Type }
func (n EphRelations_Flow) GetLede() string      { return "eph" }
func (n EphRelations_Flow) GetFlow() interface{} { return n.ptr }
func (n EphRelations_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphRelations); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphRelations_Optional_Marshal(m jsn.Marshaler, pv **EphRelations) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphRelations_Marshal(m, *pv)
	} else if !enc {
		var v EphRelations
		if err = EphRelations_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphRelations_Marshal(m jsn.Marshaler, val *EphRelations) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphRelations_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EphRelations_Field_Rel)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Rel)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphRelations_Field_Rel))
		}
		e1 := m.MarshalKey("relate", EphRelations_Field_Cardinality)
		if e1 == nil {
			e1 = EphCardinality_Marshal(m, &val.Cardinality)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphRelations_Field_Cardinality))
		}
		m.EndBlock()
	}
	return
}

// EphRelatives
type EphRelatives struct {
	Rel       string `if:"label=_,type=text"`
	Noun      string `if:"label=relates,type=text"`
	OtherNoun string `if:"label=to,type=text"`
	Markup    map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphRelatives)(nil)

func (*EphRelatives) Compose() composer.Spec {
	return composer.Spec{
		Name: EphRelatives_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphRelatives_Type = "eph_relatives"
const EphRelatives_Field_Rel = "$REL"
const EphRelatives_Field_Noun = "$NOUN"
const EphRelatives_Field_OtherNoun = "$OTHER_NOUN"

func (op *EphRelatives) Marshal(m jsn.Marshaler) error {
	return EphRelatives_Marshal(m, op)
}

type EphRelatives_Slice []EphRelatives

func (op *EphRelatives_Slice) GetType() string { return EphRelatives_Type }

func (op *EphRelatives_Slice) Marshal(m jsn.Marshaler) error {
	return EphRelatives_Repeats_Marshal(m, (*[]EphRelatives)(op))
}

func (op *EphRelatives_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphRelatives_Slice) SetSize(cnt int) {
	var els []EphRelatives
	if cnt >= 0 {
		els = make(EphRelatives_Slice, cnt)
	}
	(*op) = els
}

func (op *EphRelatives_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphRelatives_Marshal(m, &(*op)[i])
}

func EphRelatives_Repeats_Marshal(m jsn.Marshaler, vals *[]EphRelatives) error {
	return jsn.RepeatBlock(m, (*EphRelatives_Slice)(vals))
}

func EphRelatives_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphRelatives) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphRelatives_Repeats_Marshal(m, pv)
	}
	return
}

type EphRelatives_Flow struct{ ptr *EphRelatives }

func (n EphRelatives_Flow) GetType() string      { return EphRelatives_Type }
func (n EphRelatives_Flow) GetLede() string      { return "eph" }
func (n EphRelatives_Flow) GetFlow() interface{} { return n.ptr }
func (n EphRelatives_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphRelatives); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphRelatives_Optional_Marshal(m jsn.Marshaler, pv **EphRelatives) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphRelatives_Marshal(m, *pv)
	} else if !enc {
		var v EphRelatives
		if err = EphRelatives_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphRelatives_Marshal(m jsn.Marshaler, val *EphRelatives) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphRelatives_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EphRelatives_Field_Rel)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Rel)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphRelatives_Field_Rel))
		}
		e1 := m.MarshalKey("relates", EphRelatives_Field_Noun)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Noun)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphRelatives_Field_Noun))
		}
		e2 := m.MarshalKey("to", EphRelatives_Field_OtherNoun)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.OtherNoun)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphRelatives_Field_OtherNoun))
		}
		m.EndBlock()
	}
	return
}

// EphRules
type EphRules struct {
	PatternName string       `if:"label=pattern,type=text"`
	Target      string       `if:"label=target,optional,type=text"`
	Filter      rt.BoolEval  `if:"label=if"`
	When        EphTiming    `if:"label=when"`
	Exe         []rt.Execute `if:"label=does"`
	Touch       EphAlways    `if:"label=touch,optional"`
	Markup      map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphRules)(nil)

func (*EphRules) Compose() composer.Spec {
	return composer.Spec{
		Name: EphRules_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphRules_Type = "eph_rules"
const EphRules_Field_PatternName = "$PATTERN_NAME"
const EphRules_Field_Target = "$TARGET"
const EphRules_Field_Filter = "$FILTER"
const EphRules_Field_When = "$WHEN"
const EphRules_Field_Exe = "$EXE"
const EphRules_Field_Touch = "$TOUCH"

func (op *EphRules) Marshal(m jsn.Marshaler) error {
	return EphRules_Marshal(m, op)
}

type EphRules_Slice []EphRules

func (op *EphRules_Slice) GetType() string { return EphRules_Type }

func (op *EphRules_Slice) Marshal(m jsn.Marshaler) error {
	return EphRules_Repeats_Marshal(m, (*[]EphRules)(op))
}

func (op *EphRules_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphRules_Slice) SetSize(cnt int) {
	var els []EphRules
	if cnt >= 0 {
		els = make(EphRules_Slice, cnt)
	}
	(*op) = els
}

func (op *EphRules_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphRules_Marshal(m, &(*op)[i])
}

func EphRules_Repeats_Marshal(m jsn.Marshaler, vals *[]EphRules) error {
	return jsn.RepeatBlock(m, (*EphRules_Slice)(vals))
}

func EphRules_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphRules) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphRules_Repeats_Marshal(m, pv)
	}
	return
}

type EphRules_Flow struct{ ptr *EphRules }

func (n EphRules_Flow) GetType() string      { return EphRules_Type }
func (n EphRules_Flow) GetLede() string      { return "eph" }
func (n EphRules_Flow) GetFlow() interface{} { return n.ptr }
func (n EphRules_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphRules); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphRules_Optional_Marshal(m jsn.Marshaler, pv **EphRules) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphRules_Marshal(m, *pv)
	} else if !enc {
		var v EphRules
		if err = EphRules_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphRules_Marshal(m jsn.Marshaler, val *EphRules) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphRules_Flow{val}); err == nil {
		e0 := m.MarshalKey("pattern", EphRules_Field_PatternName)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.PatternName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphRules_Field_PatternName))
		}
		e1 := m.MarshalKey("target", EphRules_Field_Target)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Optional_Marshal(m, &val.Target)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphRules_Field_Target))
		}
		e2 := m.MarshalKey("if", EphRules_Field_Filter)
		if e2 == nil {
			e2 = rt.BoolEval_Marshal(m, &val.Filter)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphRules_Field_Filter))
		}
		e3 := m.MarshalKey("when", EphRules_Field_When)
		if e3 == nil {
			e3 = EphTiming_Marshal(m, &val.When)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", EphRules_Field_When))
		}
		e4 := m.MarshalKey("does", EphRules_Field_Exe)
		if e4 == nil {
			e4 = rt.Execute_Repeats_Marshal(m, &val.Exe)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", EphRules_Field_Exe))
		}
		e5 := m.MarshalKey("touch", EphRules_Field_Touch)
		if e5 == nil {
			e5 = EphAlways_Optional_Marshal(m, &val.Touch)
		}
		if e5 != nil && e5 != jsn.Missing {
			m.Error(errutil.New(e5, "in flow at", EphRules_Field_Touch))
		}
		m.EndBlock()
	}
	return
}

// EphTiming requires a predefined string.
type EphTiming struct {
	Str string
}

func (op *EphTiming) String() string {
	return op.Str
}

const EphTiming_Before = "$BEFORE"
const EphTiming_During = "$DURING"
const EphTiming_After = "$AFTER"
const EphTiming_Later = "$LATER"

func (*EphTiming) Compose() composer.Spec {
	return composer.Spec{
		Name: EphTiming_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			EphTiming_Before, EphTiming_During, EphTiming_After, EphTiming_Later,
		},
		Strings: []string{
			"before", "during", "after", "later",
		},
	}
}

const EphTiming_Type = "eph_timing"

func (op *EphTiming) Marshal(m jsn.Marshaler) error {
	return EphTiming_Marshal(m, op)
}

func EphTiming_Optional_Marshal(m jsn.Marshaler, val *EphTiming) (err error) {
	var zero EphTiming
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = EphTiming_Marshal(m, val)
	}
	return
}

func EphTiming_Marshal(m jsn.Marshaler, val *EphTiming) (err error) {
	return m.MarshalValue(EphTiming_Type, jsn.MakeEnum(val, &val.Str))
}

type EphTiming_Slice []EphTiming

func (op *EphTiming_Slice) GetType() string { return EphTiming_Type }

func (op *EphTiming_Slice) Marshal(m jsn.Marshaler) error {
	return EphTiming_Repeats_Marshal(m, (*[]EphTiming)(op))
}

func (op *EphTiming_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphTiming_Slice) SetSize(cnt int) {
	var els []EphTiming
	if cnt >= 0 {
		els = make(EphTiming_Slice, cnt)
	}
	(*op) = els
}

func (op *EphTiming_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphTiming_Marshal(m, &(*op)[i])
}

func EphTiming_Repeats_Marshal(m jsn.Marshaler, vals *[]EphTiming) error {
	return jsn.RepeatBlock(m, (*EphTiming_Slice)(vals))
}

func EphTiming_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphTiming) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphTiming_Repeats_Marshal(m, pv)
	}
	return
}

// EphValues Give a noun a specific value at startup.
// Initialization is somewhat simplistic:
// 1. Initial values are not scoped to domains, triggers must be used to change values when domains begin and end.
// 2. The values inside of records can be set using a 'path' to find them, however individual values within lists cannot be set.
// Note: when using a path, the path addresses the noun first, the named field - referring to the inner most record - last.
type EphValues struct {
	Noun   string               `if:"label=noun,type=text"`
	Field  string               `if:"label=has,type=text"`
	Path   []string             `if:"label=path,optional,type=text"`
	Value  literal.LiteralValue `if:"label=value"`
	Markup map[string]any
}

// User implemented slots:
var _ Ephemera = (*EphValues)(nil)

func (*EphValues) Compose() composer.Spec {
	return composer.Spec{
		Name: EphValues_Type,
		Uses: composer.Type_Flow,
		Lede: "eph",
	}
}

const EphValues_Type = "eph_values"
const EphValues_Field_Noun = "$NOUN"
const EphValues_Field_Field = "$FIELD"
const EphValues_Field_Path = "$PATH"
const EphValues_Field_Value = "$VALUE"

func (op *EphValues) Marshal(m jsn.Marshaler) error {
	return EphValues_Marshal(m, op)
}

type EphValues_Slice []EphValues

func (op *EphValues_Slice) GetType() string { return EphValues_Type }

func (op *EphValues_Slice) Marshal(m jsn.Marshaler) error {
	return EphValues_Repeats_Marshal(m, (*[]EphValues)(op))
}

func (op *EphValues_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EphValues_Slice) SetSize(cnt int) {
	var els []EphValues
	if cnt >= 0 {
		els = make(EphValues_Slice, cnt)
	}
	(*op) = els
}

func (op *EphValues_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EphValues_Marshal(m, &(*op)[i])
}

func EphValues_Repeats_Marshal(m jsn.Marshaler, vals *[]EphValues) error {
	return jsn.RepeatBlock(m, (*EphValues_Slice)(vals))
}

func EphValues_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EphValues) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EphValues_Repeats_Marshal(m, pv)
	}
	return
}

type EphValues_Flow struct{ ptr *EphValues }

func (n EphValues_Flow) GetType() string      { return EphValues_Type }
func (n EphValues_Flow) GetLede() string      { return "eph" }
func (n EphValues_Flow) GetFlow() interface{} { return n.ptr }
func (n EphValues_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EphValues); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EphValues_Optional_Marshal(m jsn.Marshaler, pv **EphValues) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EphValues_Marshal(m, *pv)
	} else if !enc {
		var v EphValues
		if err = EphValues_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EphValues_Marshal(m jsn.Marshaler, val *EphValues) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EphValues_Flow{val}); err == nil {
		e0 := m.MarshalKey("noun", EphValues_Field_Noun)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Noun)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EphValues_Field_Noun))
		}
		e1 := m.MarshalKey("has", EphValues_Field_Field)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Field)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EphValues_Field_Field))
		}
		e2 := m.MarshalKey("path", EphValues_Field_Path)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Optional_Repeats_Marshal(m, &val.Path)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EphValues_Field_Path))
		}
		e3 := m.MarshalKey("value", EphValues_Field_Value)
		if e3 == nil {
			e3 = literal.LiteralValue_Marshal(m, &val.Value)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", EphValues_Field_Value))
		}
		m.EndBlock()
	}
	return
}

const Ephemera_Type = "ephemera"

var Ephemera_Optional_Marshal = Ephemera_Marshal

type Ephemera_Slot struct{ Value *Ephemera }

func (at Ephemera_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at Ephemera_Slot) GetType() string              { return Ephemera_Type }
func (at Ephemera_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at Ephemera_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(Ephemera)
	return
}

func Ephemera_Marshal(m jsn.Marshaler, ptr *Ephemera) (err error) {
	slot := Ephemera_Slot{ptr}
	return slot.Marshal(m)
}

type Ephemera_Slice []Ephemera

func (op *Ephemera_Slice) GetType() string { return Ephemera_Type }

func (op *Ephemera_Slice) Marshal(m jsn.Marshaler) error {
	return Ephemera_Repeats_Marshal(m, (*[]Ephemera)(op))
}

func (op *Ephemera_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Ephemera_Slice) SetSize(cnt int) {
	var els []Ephemera
	if cnt >= 0 {
		els = make(Ephemera_Slice, cnt)
	}
	(*op) = els
}

func (op *Ephemera_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Ephemera_Marshal(m, &(*op)[i])
}

func Ephemera_Repeats_Marshal(m jsn.Marshaler, vals *[]Ephemera) error {
	return jsn.RepeatBlock(m, (*Ephemera_Slice)(vals))
}

func Ephemera_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Ephemera) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Ephemera_Repeats_Marshal(m, pv)
	}
	return
}

// ManyMany
type ManyMany struct {
	Kinds      string `if:"label=_,type=text"`
	OtherKinds string `if:"label=to_kinds,type=text"`
	Markup     map[string]any
}

func (*ManyMany) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyMany_Type,
		Uses: composer.Type_Flow,
		Lede: "kinds",
	}
}

const ManyMany_Type = "many_many"
const ManyMany_Field_Kinds = "$KINDS"
const ManyMany_Field_OtherKinds = "$OTHER_KINDS"

func (op *ManyMany) Marshal(m jsn.Marshaler) error {
	return ManyMany_Marshal(m, op)
}

type ManyMany_Slice []ManyMany

func (op *ManyMany_Slice) GetType() string { return ManyMany_Type }

func (op *ManyMany_Slice) Marshal(m jsn.Marshaler) error {
	return ManyMany_Repeats_Marshal(m, (*[]ManyMany)(op))
}

func (op *ManyMany_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ManyMany_Slice) SetSize(cnt int) {
	var els []ManyMany
	if cnt >= 0 {
		els = make(ManyMany_Slice, cnt)
	}
	(*op) = els
}

func (op *ManyMany_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ManyMany_Marshal(m, &(*op)[i])
}

func ManyMany_Repeats_Marshal(m jsn.Marshaler, vals *[]ManyMany) error {
	return jsn.RepeatBlock(m, (*ManyMany_Slice)(vals))
}

func ManyMany_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ManyMany) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ManyMany_Repeats_Marshal(m, pv)
	}
	return
}

type ManyMany_Flow struct{ ptr *ManyMany }

func (n ManyMany_Flow) GetType() string      { return ManyMany_Type }
func (n ManyMany_Flow) GetLede() string      { return "kinds" }
func (n ManyMany_Flow) GetFlow() interface{} { return n.ptr }
func (n ManyMany_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ManyMany); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ManyMany_Optional_Marshal(m jsn.Marshaler, pv **ManyMany) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ManyMany_Marshal(m, *pv)
	} else if !enc {
		var v ManyMany
		if err = ManyMany_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ManyMany_Marshal(m jsn.Marshaler, val *ManyMany) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ManyMany_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ManyMany_Field_Kinds)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ManyMany_Field_Kinds))
		}
		e1 := m.MarshalKey("to_kinds", ManyMany_Field_OtherKinds)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.OtherKinds)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ManyMany_Field_OtherKinds))
		}
		m.EndBlock()
	}
	return
}

// ManyOne
type ManyOne struct {
	Kinds     string `if:"label=_,type=text"`
	OtherKind string `if:"label=to_kind,type=text"`
	Markup    map[string]any
}

func (*ManyOne) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyOne_Type,
		Uses: composer.Type_Flow,
		Lede: "kinds",
	}
}

const ManyOne_Type = "many_one"
const ManyOne_Field_Kinds = "$KINDS"
const ManyOne_Field_OtherKind = "$OTHER_KIND"

func (op *ManyOne) Marshal(m jsn.Marshaler) error {
	return ManyOne_Marshal(m, op)
}

type ManyOne_Slice []ManyOne

func (op *ManyOne_Slice) GetType() string { return ManyOne_Type }

func (op *ManyOne_Slice) Marshal(m jsn.Marshaler) error {
	return ManyOne_Repeats_Marshal(m, (*[]ManyOne)(op))
}

func (op *ManyOne_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ManyOne_Slice) SetSize(cnt int) {
	var els []ManyOne
	if cnt >= 0 {
		els = make(ManyOne_Slice, cnt)
	}
	(*op) = els
}

func (op *ManyOne_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ManyOne_Marshal(m, &(*op)[i])
}

func ManyOne_Repeats_Marshal(m jsn.Marshaler, vals *[]ManyOne) error {
	return jsn.RepeatBlock(m, (*ManyOne_Slice)(vals))
}

func ManyOne_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ManyOne) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ManyOne_Repeats_Marshal(m, pv)
	}
	return
}

type ManyOne_Flow struct{ ptr *ManyOne }

func (n ManyOne_Flow) GetType() string      { return ManyOne_Type }
func (n ManyOne_Flow) GetLede() string      { return "kinds" }
func (n ManyOne_Flow) GetFlow() interface{} { return n.ptr }
func (n ManyOne_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ManyOne); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ManyOne_Optional_Marshal(m jsn.Marshaler, pv **ManyOne) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ManyOne_Marshal(m, *pv)
	} else if !enc {
		var v ManyOne
		if err = ManyOne_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ManyOne_Marshal(m jsn.Marshaler, val *ManyOne) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ManyOne_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ManyOne_Field_Kinds)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ManyOne_Field_Kinds))
		}
		e1 := m.MarshalKey("to_kind", ManyOne_Field_OtherKind)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.OtherKind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ManyOne_Field_OtherKind))
		}
		m.EndBlock()
	}
	return
}

// OneMany
type OneMany struct {
	Kind       string `if:"label=_,type=text"`
	OtherKinds string `if:"label=to_kinds,type=text"`
	Markup     map[string]any
}

func (*OneMany) Compose() composer.Spec {
	return composer.Spec{
		Name: OneMany_Type,
		Uses: composer.Type_Flow,
		Lede: "kind",
	}
}

const OneMany_Type = "one_many"
const OneMany_Field_Kind = "$KIND"
const OneMany_Field_OtherKinds = "$OTHER_KINDS"

func (op *OneMany) Marshal(m jsn.Marshaler) error {
	return OneMany_Marshal(m, op)
}

type OneMany_Slice []OneMany

func (op *OneMany_Slice) GetType() string { return OneMany_Type }

func (op *OneMany_Slice) Marshal(m jsn.Marshaler) error {
	return OneMany_Repeats_Marshal(m, (*[]OneMany)(op))
}

func (op *OneMany_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *OneMany_Slice) SetSize(cnt int) {
	var els []OneMany
	if cnt >= 0 {
		els = make(OneMany_Slice, cnt)
	}
	(*op) = els
}

func (op *OneMany_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return OneMany_Marshal(m, &(*op)[i])
}

func OneMany_Repeats_Marshal(m jsn.Marshaler, vals *[]OneMany) error {
	return jsn.RepeatBlock(m, (*OneMany_Slice)(vals))
}

func OneMany_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]OneMany) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = OneMany_Repeats_Marshal(m, pv)
	}
	return
}

type OneMany_Flow struct{ ptr *OneMany }

func (n OneMany_Flow) GetType() string      { return OneMany_Type }
func (n OneMany_Flow) GetLede() string      { return "kind" }
func (n OneMany_Flow) GetFlow() interface{} { return n.ptr }
func (n OneMany_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*OneMany); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func OneMany_Optional_Marshal(m jsn.Marshaler, pv **OneMany) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = OneMany_Marshal(m, *pv)
	} else if !enc {
		var v OneMany
		if err = OneMany_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func OneMany_Marshal(m jsn.Marshaler, val *OneMany) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(OneMany_Flow{val}); err == nil {
		e0 := m.MarshalKey("", OneMany_Field_Kind)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Kind)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", OneMany_Field_Kind))
		}
		e1 := m.MarshalKey("to_kinds", OneMany_Field_OtherKinds)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.OtherKinds)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", OneMany_Field_OtherKinds))
		}
		m.EndBlock()
	}
	return
}

// OneOne
type OneOne struct {
	Kind      string `if:"label=_,type=text"`
	OtherKind string `if:"label=to_kind,type=text"`
	Markup    map[string]any
}

func (*OneOne) Compose() composer.Spec {
	return composer.Spec{
		Name: OneOne_Type,
		Uses: composer.Type_Flow,
		Lede: "kind",
	}
}

const OneOne_Type = "one_one"
const OneOne_Field_Kind = "$KIND"
const OneOne_Field_OtherKind = "$OTHER_KIND"

func (op *OneOne) Marshal(m jsn.Marshaler) error {
	return OneOne_Marshal(m, op)
}

type OneOne_Slice []OneOne

func (op *OneOne_Slice) GetType() string { return OneOne_Type }

func (op *OneOne_Slice) Marshal(m jsn.Marshaler) error {
	return OneOne_Repeats_Marshal(m, (*[]OneOne)(op))
}

func (op *OneOne_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *OneOne_Slice) SetSize(cnt int) {
	var els []OneOne
	if cnt >= 0 {
		els = make(OneOne_Slice, cnt)
	}
	(*op) = els
}

func (op *OneOne_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return OneOne_Marshal(m, &(*op)[i])
}

func OneOne_Repeats_Marshal(m jsn.Marshaler, vals *[]OneOne) error {
	return jsn.RepeatBlock(m, (*OneOne_Slice)(vals))
}

func OneOne_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]OneOne) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = OneOne_Repeats_Marshal(m, pv)
	}
	return
}

type OneOne_Flow struct{ ptr *OneOne }

func (n OneOne_Flow) GetType() string      { return OneOne_Type }
func (n OneOne_Flow) GetLede() string      { return "kind" }
func (n OneOne_Flow) GetFlow() interface{} { return n.ptr }
func (n OneOne_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*OneOne); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func OneOne_Optional_Marshal(m jsn.Marshaler, pv **OneOne) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = OneOne_Marshal(m, *pv)
	} else if !enc {
		var v OneOne
		if err = OneOne_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func OneOne_Marshal(m jsn.Marshaler, val *OneOne) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(OneOne_Flow{val}); err == nil {
		e0 := m.MarshalKey("", OneOne_Field_Kind)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Kind)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", OneOne_Field_Kind))
		}
		e1 := m.MarshalKey("to_kind", OneOne_Field_OtherKind)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.OtherKind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", OneOne_Field_OtherKind))
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*Ephemera)(nil),
}

var Slats = []composer.Composer{
	(*Affinity)(nil),
	(*EphAliases)(nil),
	(*EphAlways)(nil),
	(*EphAspects)(nil),
	(*EphAt)(nil),
	(*EphBeginDomain)(nil),
	(*EphCardinality)(nil),
	(*EphChecks)(nil),
	(*EphDirectives)(nil),
	(*EphEndDomain)(nil),
	(*EphKinds)(nil),
	(*EphList)(nil),
	(*EphNouns)(nil),
	(*EphOpposites)(nil),
	(*EphParams)(nil),
	(*EphPatterns)(nil),
	(*EphPlurals)(nil),
	(*EphRefs)(nil),
	(*EphRelations)(nil),
	(*EphRelatives)(nil),
	(*EphRules)(nil),
	(*EphTiming)(nil),
	(*EphValues)(nil),
	(*ManyMany)(nil),
	(*ManyOne)(nil),
	(*OneMany)(nil),
	(*OneOne)(nil),
}

var Signatures = map[uint64]interface{}{
	5836720772794648281:  (*Affinity)(nil),       /* Affinity: */
	9182060341586636438:  (*EphAt)(nil),          /* Eph at:eph: */
	12259359132675429189: (*EphParams)(nil),      /* Eph have:called: */
	16868970960604249858: (*EphParams)(nil),      /* Eph have:called:initially: */
	277028977564474262:   (*EphParams)(nil),      /* Eph have:called:of: */
	16991751007965772137: (*EphParams)(nil),      /* Eph have:called:of:initially: */
	11648725103497180078: (*EphList)(nil),        /* Eph list: */
	2686821152326169213:  (*EphAlways)(nil),      /* EphAlways: */
	18342259850011553446: (*EphCardinality)(nil), /* EphCardinality manyMany: */
	874627862825420357:   (*EphCardinality)(nil), /* EphCardinality manyOne: */
	13014334328963404635: (*EphCardinality)(nil), /* EphCardinality oneMany: */
	12717235098097470366: (*EphCardinality)(nil), /* EphCardinality oneOne: */
	2349101510842402488:  (*EphTiming)(nil),      /* EphTiming: */
	11329972991603205158: (*OneOne)(nil),         /* Kind:toKind: */
	8349208709908405809:  (*OneMany)(nil),        /* Kind:toKinds: */
	15407091527463396937: (*ManyOne)(nil),        /* Kinds:toKind: */
	13111067660678472252: (*ManyMany)(nil),       /* Kinds:toKinds: */
	5916329907914983828:  (*EphAspects)(nil),     /* ephemera=Eph aspects:traits: */
	10555617802178579157: (*EphChecks)(nil),      /* ephemera=Eph check:does: */
	9233733686439242010:  (*EphChecks)(nil),      /* ephemera=Eph check:expect:does: */
	7564361348995556804:  (*EphEndDomain)(nil),   /* ephemera=Eph domain: */
	820545394049303942:   (*EphBeginDomain)(nil), /* ephemera=Eph domain:requires: */
	8295134481279733201:  (*EphDirectives)(nil),  /* ephemera=Eph go:parse: */
	202629818288463075:   (*EphKinds)(nil),       /* ephemera=Eph kinds:from:contain: */
	16641753326641881700: (*EphValues)(nil),      /* ephemera=Eph noun:has:path:value: */
	13546115301751905691: (*EphValues)(nil),      /* ephemera=Eph noun:has:value: */
	10773278362010151300: (*EphNouns)(nil),       /* ephemera=Eph noun:kind: */
	4696929331768532319:  (*EphOpposites)(nil),   /* ephemera=Eph opposite:word: */
	9745836144150297926:  (*EphPatterns)(nil),    /* ephemera=Eph pattern: */
	12848998644474496958: (*EphRules)(nil),       /* ephemera=Eph pattern:if:when:does: */
	11781798069617550497: (*EphRules)(nil),       /* ephemera=Eph pattern:if:when:does:touch: */
	4579736231881618112:  (*EphPatterns)(nil),    /* ephemera=Eph pattern:locals: */
	17706945660252712761: (*EphPatterns)(nil),    /* ephemera=Eph pattern:locals:result: */
	3432572155416154447:  (*EphPatterns)(nil),    /* ephemera=Eph pattern:result: */
	9493523235682582389:  (*EphRules)(nil),       /* ephemera=Eph pattern:target:if:when:does: */
	14116605515882567958: (*EphRules)(nil),       /* ephemera=Eph pattern:target:if:when:does:touch: */
	11977292589457157224: (*EphPatterns)(nil),    /* ephemera=Eph pattern:with: */
	17354166755189823294: (*EphPatterns)(nil),    /* ephemera=Eph pattern:with:locals: */
	18129437326859380983: (*EphPatterns)(nil),    /* ephemera=Eph pattern:with:locals:result: */
	588830360375424657:   (*EphPatterns)(nil),    /* ephemera=Eph pattern:with:result: */
	1142624251723957623:  (*EphPlurals)(nil),     /* ephemera=Eph plural:singular: */
	6868013341452217478:  (*EphRefs)(nil),        /* ephemera=Eph refs: */
	18988513613569668:    (*EphAliases)(nil),     /* ephemera=Eph understand:as: */
	17022620689640962955: (*EphRelations)(nil),   /* ephemera=Eph:relate manyMany: */
	9165608903722613646:  (*EphRelations)(nil),   /* ephemera=Eph:relate manyOne: */
	10631247178865579132: (*EphRelations)(nil),   /* ephemera=Eph:relate oneMany: */
	1633627839598904515:  (*EphRelations)(nil),   /* ephemera=Eph:relate oneOne: */
	8506635386610510661:  (*EphRelatives)(nil),   /* ephemera=Eph:relates:to: */
}
