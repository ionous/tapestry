package eph

import (
	"errors"

	"github.com/ionous/errutil"
)

// arbitrary key to value storage of declarations generated by the assembler.
// exists specifically to detect ambiguities in authored stories.
type Artifacts map[string]Definition

// an arbitrary string value and the location of its first declaration.
type Definition struct {
	at, value string
}

// error generated by mismatched or duplicated artifacts within the same domain
type Conflict struct {
	Key    string
	Reason ReasonForConflict
	Was    Definition
	Value  string
}

func (n *Conflict) Error() string {
	return errutil.Sprintf("%s %s was %q at %s now %q", n.Reason.String(), n.Key, n.Was.value, n.Was.at, n.Value)
}

func newConflict(key string, why ReasonForConflict, was Definition, newval string) *Conflict {
	return &Conflict{key, why, was, newval}
}

type ReasonForConflict int

//go:generate stringer -type=ReasonForConflict
const (
	Redefined ReasonForConflict = iota
	Duplicated
)

// return an error ( type Conflict ) if the passed pair would collide with any existing pair
func (defs Artifacts) CheckConflict(key, value string) (err error) {
	if def, ok := defs[key]; ok {
		var why ReasonForConflict
		if def.value == value {
			why = Duplicated // if its duplicated, the previous entry would have checked for redefined
		} else {
			why = Redefined
		}
		err = newConflict(key, why, def, value)
	}
	return
}

// add the passed artifacts looking for and rejecting conflicts
func (defs Artifacts) Merge(from Artifacts, allowDupes bool) (err error) {
	for k, def := range from {
		var conflict *Conflict
		if e := defs.CheckConflict(k, def.value); e == nil {
			defs[k] = def // store if there was no conflict
		} else if allowDupes && errors.As(e, &conflict) && conflict.Reason == Duplicated {
			LogWarning(e) // warn if it was a duplicated definition
		} else {
			err = errutil.Append(err, e)
		}
	}
	return
}
