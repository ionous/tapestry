// Operations on objects, variables, and kinds.
package object

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// dot, a type of slot.
var Zt_Dot = typeinfo.Slot{
	Name: "dot",
	Markup: map[string]any{
		"--": "Access values stored inside other values.",
	},
}

// Holds a single slot.
type Dot_Slot struct{ Value Dot }

// Implements [typeinfo.Instance] for a single slot.
func (*Dot_Slot) TypeInfo() typeinfo.T {
	return &Zt_Dot
}

// Holds a slice of slots.
type Dot_Slots []Dot

// Implements [typeinfo.Instance] for a slice of slots.
func (*Dot_Slots) TypeInfo() typeinfo.T {
	return &Zt_Dot
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *Dot_Slots) Repeats() bool {
	return len(*op) > 0
}

// Store a value into a variable or object.
// Values are specified as a generic [Assignment].
// The various "From" commands exist to cast specific value types into an assignment.
//
// WARNING: This doesn't convert values from one type to another.
// For example:
//
//	Set:value:
//	- "@some_local_variable"
//	- FromText: "a piece of text to store."
//
// will only work if the local variable can store text. If the variable was declared as a number, the command will generate an error.
type SetValue struct {
	Target rtti.Address
	Value  rtti.Assignment
	Markup map[string]any `json:",omitempty"`
}

// set_value, a type of flow.
var Zt_SetValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SetValue) TypeInfo() typeinfo.T {
	return &Zt_SetValue
}

// Implements [typeinfo.Markup]
func (op *SetValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*SetValue)(nil)

// Holds a slice of type SetValue.
type SetValue_Slice []SetValue

// Implements [typeinfo.Instance] for a slice of SetValue.
func (*SetValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_SetValue
}

// Implements [typeinfo.Repeats] for a slice of SetValue.
func (op *SetValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Set the state of an object or record.
// See also: story `Define state:names:`.
type SetState struct {
	Target    rtti.Address
	StateName rtti.TextEval
	Markup    map[string]any `json:",omitempty"`
}

// set_state, a type of flow.
var Zt_SetState typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SetState) TypeInfo() typeinfo.T {
	return &Zt_SetState
}

// Implements [typeinfo.Markup]
func (op *SetState) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*SetState)(nil)

// Holds a slice of type SetState.
type SetState_Slice []SetState

// Implements [typeinfo.Instance] for a slice of SetState.
func (*SetState_Slice) TypeInfo() typeinfo.T {
	return &Zt_SetState
}

// Implements [typeinfo.Repeats] for a slice of SetState.
func (op *SetState_Slice) Repeats() bool {
	return len(*op) > 0
}

// Read a value from an object. As a special case, if there are no dot parts, this will return the id of the object.
// In .tell files, this command is often specified with a shortcut. For example:
//
//	"#my_object.some_field"
//
// is a shorter way to say:
//
//	Object:dot:
//	- "my object"
//	- "some field"
//
// WARNING: This doesn't convert values from one type to another. For instance, if a field was declared as text, this will error if read as a boolean.
type ObjectDot struct {
	NounName rtti.TextEval
	Dot      []Dot
	Markup   map[string]any `json:",omitempty"`
}

// object_dot, a type of flow.
var Zt_ObjectDot typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ObjectDot) TypeInfo() typeinfo.T {
	return &Zt_ObjectDot
}

// Implements [typeinfo.Markup]
func (op *ObjectDot) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Address = (*ObjectDot)(nil)
var _ rtti.BoolEval = (*ObjectDot)(nil)
var _ rtti.NumEval = (*ObjectDot)(nil)
var _ rtti.TextEval = (*ObjectDot)(nil)
var _ rtti.RecordEval = (*ObjectDot)(nil)
var _ rtti.NumListEval = (*ObjectDot)(nil)
var _ rtti.TextListEval = (*ObjectDot)(nil)
var _ rtti.RecordListEval = (*ObjectDot)(nil)

// Holds a slice of type ObjectDot.
type ObjectDot_Slice []ObjectDot

// Implements [typeinfo.Instance] for a slice of ObjectDot.
func (*ObjectDot_Slice) TypeInfo() typeinfo.T {
	return &Zt_ObjectDot
}

// Implements [typeinfo.Repeats] for a slice of ObjectDot.
func (op *ObjectDot_Slice) Repeats() bool {
	return len(*op) > 0
}

// Read a value from a variable.
// In .tell files, this command is often specified with a shortcut. For example:
//
//	"@some_local_variable"
//
// is a shorter way to say:
//
//	Variable:dot: "some local variable"
//
// WARNING: This doesn't convert values from one type to another. For instance, if a field was declared as text, this will error if read as a boolean.
type VariableDot struct {
	VariableName rtti.TextEval
	Dot          []Dot
	Markup       map[string]any `json:",omitempty"`
}

// variable_dot, a type of flow.
var Zt_VariableDot typeinfo.Flow

// Implements [typeinfo.Instance]
func (*VariableDot) TypeInfo() typeinfo.T {
	return &Zt_VariableDot
}

// Implements [typeinfo.Markup]
func (op *VariableDot) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Address = (*VariableDot)(nil)
var _ rtti.BoolEval = (*VariableDot)(nil)
var _ rtti.NumEval = (*VariableDot)(nil)
var _ rtti.TextEval = (*VariableDot)(nil)
var _ rtti.RecordEval = (*VariableDot)(nil)
var _ rtti.NumListEval = (*VariableDot)(nil)
var _ rtti.TextListEval = (*VariableDot)(nil)
var _ rtti.RecordListEval = (*VariableDot)(nil)

// Holds a slice of type VariableDot.
type VariableDot_Slice []VariableDot

// Implements [typeinfo.Instance] for a slice of VariableDot.
func (*VariableDot_Slice) TypeInfo() typeinfo.T {
	return &Zt_VariableDot
}

// Implements [typeinfo.Repeats] for a slice of VariableDot.
func (op *VariableDot_Slice) Repeats() bool {
	return len(*op) > 0
}

// Read a value from a record.
// WARNING: This doesn't convert values from one type to another.
type RecordDot struct {
	Value  rtti.RecordEval
	Dot    []Dot
	Markup map[string]any `json:",omitempty"`
}

// record_dot, a type of flow.
var Zt_RecordDot typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RecordDot) TypeInfo() typeinfo.T {
	return &Zt_RecordDot
}

// Implements [typeinfo.Markup]
func (op *RecordDot) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*RecordDot)(nil)
var _ rtti.NumEval = (*RecordDot)(nil)
var _ rtti.TextEval = (*RecordDot)(nil)
var _ rtti.RecordEval = (*RecordDot)(nil)
var _ rtti.NumListEval = (*RecordDot)(nil)
var _ rtti.TextListEval = (*RecordDot)(nil)
var _ rtti.RecordListEval = (*RecordDot)(nil)

// Holds a slice of type RecordDot.
type RecordDot_Slice []RecordDot

// Implements [typeinfo.Instance] for a slice of RecordDot.
func (*RecordDot_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordDot
}

// Implements [typeinfo.Repeats] for a slice of RecordDot.
func (op *RecordDot_Slice) Repeats() bool {
	return len(*op) > 0
}

// Select a named field from a record, or a named property from an object.
type AtField struct {
	FieldName rtti.TextEval
	Markup    map[string]any `json:",omitempty"`
}

// at_field, a type of flow.
var Zt_AtField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AtField) TypeInfo() typeinfo.T {
	return &Zt_AtField
}

// Implements [typeinfo.Markup]
func (op *AtField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Dot = (*AtField)(nil)

// Holds a slice of type AtField.
type AtField_Slice []AtField

// Implements [typeinfo.Instance] for a slice of AtField.
func (*AtField_Slice) TypeInfo() typeinfo.T {
	return &Zt_AtField
}

// Implements [typeinfo.Repeats] for a slice of AtField.
func (op *AtField_Slice) Repeats() bool {
	return len(*op) > 0
}

// Select a value from a list of values.
type AtIndex struct {
	Index  rtti.NumEval
	Markup map[string]any `json:",omitempty"`
}

// at_index, a type of flow.
var Zt_AtIndex typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AtIndex) TypeInfo() typeinfo.T {
	return &Zt_AtIndex
}

// Implements [typeinfo.Markup]
func (op *AtIndex) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Dot = (*AtIndex)(nil)

// Holds a slice of type AtIndex.
type AtIndex_Slice []AtIndex

// Implements [typeinfo.Instance] for a slice of AtIndex.
func (*AtIndex_Slice) TypeInfo() typeinfo.T {
	return &Zt_AtIndex
}

// Implements [typeinfo.Repeats] for a slice of AtIndex.
func (op *AtIndex_Slice) Repeats() bool {
	return len(*op) > 0
}

// The full name of an object as originally specified by the author.
// Generates an error for unknown objects except
// it returns empty text when given empty text.
// See also [ObjectDot] which can return the object's unique id.
type ObjectName struct {
	Target rtti.Address
	Markup map[string]any `json:",omitempty"`
}

// object_name, a type of flow.
var Zt_ObjectName typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ObjectName) TypeInfo() typeinfo.T {
	return &Zt_ObjectName
}

// Implements [typeinfo.Markup]
func (op *ObjectName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*ObjectName)(nil)

// Holds a slice of type ObjectName.
type ObjectName_Slice []ObjectName

// Implements [typeinfo.Instance] for a slice of ObjectName.
func (*ObjectName_Slice) TypeInfo() typeinfo.T {
	return &Zt_ObjectName
}

// Implements [typeinfo.Repeats] for a slice of ObjectName.
func (op *ObjectName_Slice) Repeats() bool {
	return len(*op) > 0
}

// All of an object's current states as a list of text.
// ( Despite the name, can also be used on records. )
type ObjectStates struct {
	Target rtti.Address
	Markup map[string]any `json:",omitempty"`
}

// object_states, a type of flow.
var Zt_ObjectStates typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ObjectStates) TypeInfo() typeinfo.T {
	return &Zt_ObjectStates
}

// Implements [typeinfo.Markup]
func (op *ObjectStates) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*ObjectStates)(nil)

// Holds a slice of type ObjectStates.
type ObjectStates_Slice []ObjectStates

// Implements [typeinfo.Instance] for a slice of ObjectStates.
func (*ObjectStates_Slice) TypeInfo() typeinfo.T {
	return &Zt_ObjectStates
}

// Implements [typeinfo.Repeats] for a slice of ObjectStates.
func (op *ObjectStates_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether an object (or record) is of exactly the named kind.
// For example, all containers are a kind of prop.
// Asking if a container is exactly a prop would return false.
// See also [IsKindOf].
type IsExactKindOf struct {
	Target   rtti.Address
	KindName rtti.TextEval
	Markup   map[string]any `json:",omitempty"`
}

// is_exact_kind_of, a type of flow.
var Zt_IsExactKindOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IsExactKindOf) TypeInfo() typeinfo.T {
	return &Zt_IsExactKindOf
}

// Implements [typeinfo.Markup]
func (op *IsExactKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*IsExactKindOf)(nil)

// Holds a slice of type IsExactKindOf.
type IsExactKindOf_Slice []IsExactKindOf

// Implements [typeinfo.Instance] for a slice of IsExactKindOf.
func (*IsExactKindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsExactKindOf
}

// Implements [typeinfo.Repeats] for a slice of IsExactKindOf.
func (op *IsExactKindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine whether an object (or record) is compatible with the named kind.
// For example, all containers are a kind of prop.
// Asking if a container is a kind of a prop would return true.
// See also [IsExactKindOf].
type IsKindOf struct {
	Target   rtti.Address
	KindName rtti.TextEval
	Nothing  bool
	Markup   map[string]any `json:",omitempty"`
}

// is_kind_of, a type of flow.
var Zt_IsKindOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IsKindOf) TypeInfo() typeinfo.T {
	return &Zt_IsKindOf
}

// Implements [typeinfo.Markup]
func (op *IsKindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*IsKindOf)(nil)

// Holds a slice of type IsKindOf.
type IsKindOf_Slice []IsKindOf

// Implements [typeinfo.Instance] for a slice of IsKindOf.
func (*IsKindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_IsKindOf
}

// Implements [typeinfo.Repeats] for a slice of IsKindOf.
func (op *IsKindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// The kind of an object or record.
type KindOf struct {
	Target  rtti.Address
	Nothing bool
	Markup  map[string]any `json:",omitempty"`
}

// kind_of, a type of flow.
var Zt_KindOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindOf) TypeInfo() typeinfo.T {
	return &Zt_KindOf
}

// Implements [typeinfo.Markup]
func (op *KindOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*KindOf)(nil)

// Holds a slice of type KindOf.
type KindOf_Slice []KindOf

// Implements [typeinfo.Instance] for a slice of KindOf.
func (*KindOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindOf
}

// Implements [typeinfo.Repeats] for a slice of KindOf.
func (op *KindOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// A list of all objects accessible by the current scene
// and compatible with the specified kind.
type KindsOf struct {
	KindName        rtti.TextEval
	BoolPatternName string
	Markup          map[string]any `json:",omitempty"`
}

// kinds_of, a type of flow.
var Zt_KindsOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindsOf) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// Implements [typeinfo.Markup]
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*KindsOf)(nil)

// Holds a slice of type KindsOf.
type KindsOf_Slice []KindsOf

// Implements [typeinfo.Instance] for a slice of KindsOf.
func (*KindsOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// Implements [typeinfo.Repeats] for a slice of KindsOf.
func (op *KindsOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// A list of the fields of a given kind.
type FieldsOfKind struct {
	KindName rtti.TextEval
	Markup   map[string]any `json:",omitempty"`
}

// fields_of_kind, a type of flow.
var Zt_FieldsOfKind typeinfo.Flow

// Implements [typeinfo.Instance]
func (*FieldsOfKind) TypeInfo() typeinfo.T {
	return &Zt_FieldsOfKind
}

// Implements [typeinfo.Markup]
func (op *FieldsOfKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*FieldsOfKind)(nil)

// Holds a slice of type FieldsOfKind.
type FieldsOfKind_Slice []FieldsOfKind

// Implements [typeinfo.Instance] for a slice of FieldsOfKind.
func (*FieldsOfKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_FieldsOfKind
}

// Implements [typeinfo.Repeats] for a slice of FieldsOfKind.
func (op *FieldsOfKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change to the next state in some particular set of states for a given object ( or record. )
// Optionally, returns the new value of the state.
// Uses the order of the states where as they were originally defined.
// See [DefineState].
type IncrementAspect struct {
	Target     rtti.Address
	AspectName rtti.TextEval
	Step       rtti.NumEval
	Clamp      rtti.BoolEval
	Markup     map[string]any `json:",omitempty"`
}

// increment_aspect, a type of flow.
var Zt_IncrementAspect typeinfo.Flow

// Implements [typeinfo.Instance]
func (*IncrementAspect) TypeInfo() typeinfo.T {
	return &Zt_IncrementAspect
}

// Implements [typeinfo.Markup]
func (op *IncrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*IncrementAspect)(nil)
var _ rtti.Execute = (*IncrementAspect)(nil)

// Holds a slice of type IncrementAspect.
type IncrementAspect_Slice []IncrementAspect

// Implements [typeinfo.Instance] for a slice of IncrementAspect.
func (*IncrementAspect_Slice) TypeInfo() typeinfo.T {
	return &Zt_IncrementAspect
}

// Implements [typeinfo.Repeats] for a slice of IncrementAspect.
func (op *IncrementAspect_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change to the previous state in some particular set of states for a given object ( or record. )
// Optionally, returns the new value of the state.
// Uses the order of the states where as they were originally defined.
// See [DefineState].
type DecrementAspect struct {
	Target     rtti.Address
	AspectName rtti.TextEval
	Step       rtti.NumEval
	Clamp      rtti.BoolEval
	Markup     map[string]any `json:",omitempty"`
}

// decrement_aspect, a type of flow.
var Zt_DecrementAspect typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DecrementAspect) TypeInfo() typeinfo.T {
	return &Zt_DecrementAspect
}

// Implements [typeinfo.Markup]
func (op *DecrementAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*DecrementAspect)(nil)
var _ rtti.Execute = (*DecrementAspect)(nil)

// Holds a slice of type DecrementAspect.
type DecrementAspect_Slice []DecrementAspect

// Implements [typeinfo.Instance] for a slice of DecrementAspect.
func (*DecrementAspect_Slice) TypeInfo() typeinfo.T {
	return &Zt_DecrementAspect
}

// Implements [typeinfo.Repeats] for a slice of DecrementAspect.
func (op *DecrementAspect_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_SetValue = typeinfo.Flow{
		Name: "set_value",
		Lede: "set",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "Object property or variable into which to write the value.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "value",
			Label: "value",
			Markup: map[string]any{
				"--": "The value to copy into the destination.",
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Store a value into a variable or object.", "Values are specified as a generic [Assignment].", "The various \"From\" commands exist to cast specific value types into an assignment.", "", "WARNING: This doesn't convert values from one type to another.", "For example:", "  Set:value:", "  - \"@some_local_variable\"", "  - FromText: \"a piece of text to store.\"", "will only work if the local variable can store text. If the variable was declared as a number, the command will generate an error."},
		},
	}
	Zt_SetState = typeinfo.Flow{
		Name: "set_state",
		Lede: "set",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "Object or record to change.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "state_name",
			Label: "state",
			Markup: map[string]any{
				"--": []string{"Name of the state to set.", "Only one state in a state set is considered active at a time so this implicitly deactivates the other states in its set.", "Errors if the state wasn't declared as part of the object's kind."},
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Set the state of an object or record.", "See also: story `Define state:names:`."},
		},
	}
	Zt_ObjectDot = typeinfo.Flow{
		Name: "object_dot",
		Lede: "object",
		Terms: []typeinfo.Term{{
			Name: "noun_name",
			Markup: map[string]any{
				"--": "Id or friendly name of the object.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "dot",
			Label:    "dot",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"--": "A field or path within the object to read from.",
			},
			Type: &Zt_Dot,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Address,
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
			&rtti.Zt_TextEval,
			&rtti.Zt_RecordEval,
			&rtti.Zt_NumListEval,
			&rtti.Zt_TextListEval,
			&rtti.Zt_RecordListEval,
		},
		Markup: map[string]any{
			"--": []string{"Read a value from an object. As a special case, if there are no dot parts, this will return the id of the object.", "In .tell files, this command is often specified with a shortcut. For example:", "  \"#my_object.some_field\"", "is a shorter way to say:", "  Object:dot:", "  - \"my object\"", "  - \"some field\"", "WARNING: This doesn't convert values from one type to another. For instance, if a field was declared as text, this will error if read as a boolean."},
		},
	}
	Zt_VariableDot = typeinfo.Flow{
		Name: "variable_dot",
		Lede: "variable",
		Terms: []typeinfo.Term{{
			Name: "variable_name",
			Markup: map[string]any{
				"--": "Exact name of the variable in question.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "dot",
			Label:    "dot",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"--": []string{"The field or path within the variable to read from.", "Specifying a dot only makes sense when the variable contains", "a record, a list, or the id an object.", "When this isn't specified, the command returns the value of the variable itself."},
			},
			Type: &Zt_Dot,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Address,
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
			&rtti.Zt_TextEval,
			&rtti.Zt_RecordEval,
			&rtti.Zt_NumListEval,
			&rtti.Zt_TextListEval,
			&rtti.Zt_RecordListEval,
		},
		Markup: map[string]any{
			"--":            []string{"Read a value from a variable.", "In .tell files, this command is often specified with a shortcut. For example:", "  \"@some_local_variable\"", "is a shorter way to say:", "  Variable:dot: \"some local variable\"", "WARNING: This doesn't convert values from one type to another. For instance, if a field was declared as text, this will error if read as a boolean."},
			"blockly-color": "MATH_HUE",
		},
	}
	Zt_RecordDot = typeinfo.Flow{
		Name: "record_dot",
		Lede: "record",
		Terms: []typeinfo.Term{{
			Name: "value",
			Markup: map[string]any{
				"--": "Exact name of the variable in question.",
			},
			Type: &rtti.Zt_RecordEval,
		}, {
			Name:    "dot",
			Label:   "dot",
			Repeats: true,
			Markup: map[string]any{
				"--": "The field or path within the record.",
			},
			Type: &Zt_Dot,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
			&rtti.Zt_TextEval,
			&rtti.Zt_RecordEval,
			&rtti.Zt_NumListEval,
			&rtti.Zt_TextListEval,
			&rtti.Zt_RecordListEval,
		},
		Markup: map[string]any{
			"--": []string{"Read a value from a record.", "WARNING: This doesn't convert values from one type to another."},
		},
	}
	Zt_AtField = typeinfo.Flow{
		Name: "at_field",
		Lede: "at",
		Terms: []typeinfo.Term{{
			Name:  "field_name",
			Label: "field",
			Markup: map[string]any{
				"--": []string{"The name of the field to read or write.", "The field must exist in the object or record being accessed."},
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Dot,
		},
		Markup: map[string]any{
			"--": "Select a named field from a record, or a named property from an object.",
		},
	}
	Zt_AtIndex = typeinfo.Flow{
		Name: "at_index",
		Lede: "at",
		Terms: []typeinfo.Term{{
			Name:  "index",
			Label: "index",
			Markup: map[string]any{
				"--": []string{"The one-based index to read or write.", "The index must exist within the list being targeted."},
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Dot,
		},
		Markup: map[string]any{
			"--": "Select a value from a list of values.",
		},
	}
	Zt_ObjectName = typeinfo.Flow{
		Name: "object_name",
		Lede: "object",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "name",
			Markup: map[string]any{
				"--": []string{"The object in question.", "( Records don't have names. )"},
			},
			Type: &rtti.Zt_Address,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"--": []string{"The full name of an object as originally specified by the author.", "Generates an error for unknown objects except", "it returns empty text when given empty text.", "See also [ObjectDot] which can return the object's unique id."},
		},
	}
	Zt_ObjectStates = typeinfo.Flow{
		Name: "object_states",
		Lede: "object",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "states",
			Markup: map[string]any{
				"--": "The object or record in question.",
			},
			Type: &rtti.Zt_Address,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"--": []string{"All of an object's current states as a list of text.", "( Despite the name, can also be used on records. )"},
		},
	}
	Zt_IsExactKindOf = typeinfo.Flow{
		Name: "is_exact_kind_of",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "exactly",
			Markup: map[string]any{
				"--": "The object or record in question.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "kind_name",
			Label: "kind",
			Markup: map[string]any{
				"--": "The kind to check.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"--": []string{"Determine whether an object (or record) is of exactly the named kind.", "For example, all containers are a kind of prop.", "Asking if a container is exactly a prop would return false.", "See also [IsKindOf]."},
		},
	}
	Zt_IsKindOf = typeinfo.Flow{
		Name: "is_kind_of",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "compatible",
			Markup: map[string]any{
				"--": "The object or record in question.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "kind_name",
			Label: "kind",
			Markup: map[string]any{
				"--": "The kind to check.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "nothing",
			Label:    "nothing",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Check whether the requested text of the object is empty", "but the type of the requested text is still of requested kind."},
			},
			Type: &prim.Zt_Bool,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"--": []string{"Determine whether an object (or record) is compatible with the named kind.", "For example, all containers are a kind of prop.", "Asking if a container is a kind of a prop would return true.", "See also [IsExactKindOf]."},
		},
	}
	Zt_KindOf = typeinfo.Flow{
		Name: "kind_of",
		Lede: "kind",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "of",
			Markup: map[string]any{
				"--": "The object or record in question.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "nothing",
			Label:    "nothing",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Check whether the requested text of the object is empty", "but the type of the requested text is still of requested kind."},
			},
			Type: &prim.Zt_Bool,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"--": "The kind of an object or record.",
		},
	}
	Zt_KindsOf = typeinfo.Flow{
		Name: "kinds_of",
		Lede: "objects",
		Terms: []typeinfo.Term{{
			Name:  "kind_name",
			Label: "of",
			Markup: map[string]any{
				"--": "The kind in question.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "bool_pattern_name",
			Label:    "pattern",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"A pattern, called per object, to filter the results.", "The pattern should return 'true' for all desired objects."},
			},
			Type: &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"--": []string{"A list of all objects accessible by the current scene ", "and compatible with the specified kind."},
		},
	}
	Zt_FieldsOfKind = typeinfo.Flow{
		Name: "fields_of_kind",
		Lede: "fields",
		Terms: []typeinfo.Term{{
			Name:  "kind_name",
			Label: "of",
			Markup: map[string]any{
				"--": "The kind in question.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"--": "A list of the fields of a given kind.",
		},
	}
	Zt_IncrementAspect = typeinfo.Flow{
		Name: "increment_aspect",
		Lede: "increase",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The object or record in question.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "aspect_name",
			Label: "state",
			Markup: map[string]any{
				"--": []string{"The name of the set of states in question.", "See also [DefineState]."},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"--": "Customize the size of the increment. When not specified, increase by a single step.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "clamp",
			Label:    "clamp",
			Optional: true,
			Markup: map[string]any{
				"--": "Customize the behavior of increment when the last state has been reached. If clamp if false ( or not specified ), increment will wrap around to the first state. When clamp is true, increment will stick to the last state.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Change to the next state in some particular set of states for a given object ( or record. )", "Optionally, returns the new value of the state.", "Uses the order of the states where as they were originally defined.", "See [DefineState]."},
		},
	}
	Zt_DecrementAspect = typeinfo.Flow{
		Name: "decrement_aspect",
		Lede: "decrease",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The object or record in question.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "aspect_name",
			Label: "state",
			Markup: map[string]any{
				"--": []string{"The name of the set of states in question.", "See also [DefineState]."},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"--": "Customize the size of the decrement. When not specified, decrease by a single step.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "clamp",
			Label:    "clamp",
			Optional: true,
			Markup: map[string]any{
				"--": " Customize the behavior of decrement when the first state has been reached. If clamp if false ( or not specified ), decrement will wrap around to the last state. When clamp is true, decrement will stick to the first state.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Change to the previous state in some particular set of states for a given object ( or record. )", "Optionally, returns the new value of the state.", "Uses the order of the states where as they were originally defined.", "See [DefineState]."},
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "object",
	Comment: []string{
		"Operations on objects, variables, and kinds.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Dot,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_SetValue,
	&Zt_SetState,
	&Zt_ObjectDot,
	&Zt_VariableDot,
	&Zt_RecordDot,
	&Zt_AtField,
	&Zt_AtIndex,
	&Zt_ObjectName,
	&Zt_ObjectStates,
	&Zt_IsExactKindOf,
	&Zt_IsKindOf,
	&Zt_KindOf,
	&Zt_KindsOf,
	&Zt_FieldsOfKind,
	&Zt_IncrementAspect,
	&Zt_DecrementAspect,
}

// gob like registration
func Register(reg func(any)) {
	reg((*SetValue)(nil))
	reg((*SetState)(nil))
	reg((*ObjectDot)(nil))
	reg((*VariableDot)(nil))
	reg((*RecordDot)(nil))
	reg((*AtField)(nil))
	reg((*AtIndex)(nil))
	reg((*ObjectName)(nil))
	reg((*ObjectStates)(nil))
	reg((*IsExactKindOf)(nil))
	reg((*IsKindOf)(nil))
	reg((*KindOf)(nil))
	reg((*KindsOf)(nil))
	reg((*FieldsOfKind)(nil))
	reg((*IncrementAspect)(nil))
	reg((*DecrementAspect)(nil))
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	15204531541525437496: (*AtField)(nil),         /* dot=At field: */
	7476101450221130208:  (*AtIndex)(nil),         /* dot=At index: */
	14169556874784221862: (*DecrementAspect)(nil), /* execute=Decrease:state: */
	17587985027489164579: (*DecrementAspect)(nil), /* text_eval=Decrease:state: */
	7559406936622200143:  (*DecrementAspect)(nil), /* execute=Decrease:state:by: */
	419651371872152076:   (*DecrementAspect)(nil), /* text_eval=Decrease:state:by: */
	13093349901141291332: (*DecrementAspect)(nil), /* execute=Decrease:state:by:clamp: */
	12748959322317977131: (*DecrementAspect)(nil), /* text_eval=Decrease:state:by:clamp: */
	3351294293920048277:  (*DecrementAspect)(nil), /* execute=Decrease:state:clamp: */
	16963765904232890520: (*DecrementAspect)(nil), /* text_eval=Decrease:state:clamp: */
	2224842870997259213:  (*FieldsOfKind)(nil),    /* text_list_eval=Fields of: */
	1983679666160899438:  (*IncrementAspect)(nil), /* execute=Increase:state: */
	11027003704027006847: (*IncrementAspect)(nil), /* text_eval=Increase:state: */
	9009918931836719719:  (*IncrementAspect)(nil), /* execute=Increase:state:by: */
	4759094076173014048:  (*IncrementAspect)(nil), /* text_eval=Increase:state:by: */
	5055672601277968076:  (*IncrementAspect)(nil), /* execute=Increase:state:by:clamp: */
	4231756894592955311:  (*IncrementAspect)(nil), /* text_eval=Increase:state:by:clamp: */
	13691223217116632397: (*IncrementAspect)(nil), /* execute=Increase:state:clamp: */
	1440462751062399988:  (*IncrementAspect)(nil), /* text_eval=Increase:state:clamp: */
	1438230010307446237:  (*IsKindOf)(nil),        /* bool_eval=Is compatible:kind: */
	11610383747721345480: (*IsKindOf)(nil),        /* bool_eval=Is compatible:kind:nothing: */
	13266154688715980549: (*IsExactKindOf)(nil),   /* bool_eval=Is exactly:kind: */
	6032980780630230203:  (*KindOf)(nil),          /* text_eval=Kind of: */
	10655425131305457554: (*KindOf)(nil),          /* text_eval=Kind of:nothing: */
	4315817498883274344:  (*ObjectName)(nil),      /* text_eval=Object name: */
	15083953234702869198: (*ObjectStates)(nil),    /* text_list_eval=Object states: */
	8656684385605626625:  (*ObjectDot)(nil),       /* address=Object: */
	6106842879255343810:  (*ObjectDot)(nil),       /* bool_eval=Object: */
	14709650427635515944: (*ObjectDot)(nil),       /* num_eval=Object: */
	3322847371150895433:  (*ObjectDot)(nil),       /* num_list_eval=Object: */
	1988642049281593865:  (*ObjectDot)(nil),       /* record_eval=Object: */
	9599721143262547914:  (*ObjectDot)(nil),       /* record_list_eval=Object: */
	16083123907778192555: (*ObjectDot)(nil),       /* text_eval=Object: */
	15780956574897965792: (*ObjectDot)(nil),       /* text_list_eval=Object: */
	8121157847033684962:  (*ObjectDot)(nil),       /* address=Object:dot: */
	5205171710741514089:  (*ObjectDot)(nil),       /* bool_eval=Object:dot: */
	13854256590934503743: (*ObjectDot)(nil),       /* num_eval=Object:dot: */
	3914994200631113354:  (*ObjectDot)(nil),       /* num_list_eval=Object:dot: */
	1364775634664390090:  (*ObjectDot)(nil),       /* record_eval=Object:dot: */
	16877508779303594737: (*ObjectDot)(nil),       /* record_list_eval=Object:dot: */
	17663678026468030644: (*ObjectDot)(nil),       /* text_eval=Object:dot: */
	725008522959645559:   (*ObjectDot)(nil),       /* text_list_eval=Object:dot: */
	13479346777286647466: (*KindsOf)(nil),         /* text_list_eval=Objects of: */
	12232168245148948542: (*KindsOf)(nil),         /* text_list_eval=Objects of:pattern: */
	7909779041221295763:  (*RecordDot)(nil),       /* bool_eval=Record:dot: */
	6646689152519216673:  (*RecordDot)(nil),       /* num_eval=Record:dot: */
	16076168783079774776: (*RecordDot)(nil),       /* num_list_eval=Record:dot: */
	8828077584500414584:  (*RecordDot)(nil),       /* record_eval=Record:dot: */
	257500016186131851:   (*RecordDot)(nil),       /* record_list_eval=Record:dot: */
	9702839738011694802:  (*RecordDot)(nil),       /* text_eval=Record:dot: */
	4733069711040627369:  (*RecordDot)(nil),       /* text_list_eval=Record:dot: */
	9616350989753725148:  (*SetState)(nil),        /* execute=Set:state: */
	3912570011939708664:  (*SetValue)(nil),        /* execute=Set:value: */
	13692207992970428220: (*VariableDot)(nil),     /* address=Variable: */
	17908519799628660539: (*VariableDot)(nil),     /* bool_eval=Variable: */
	17658028528032582325: (*VariableDot)(nil),     /* num_eval=Variable: */
	11022385456290008164: (*VariableDot)(nil),     /* num_list_eval=Variable: */
	15906653930217516836: (*VariableDot)(nil),     /* record_eval=Variable: */
	16032903663975260899: (*VariableDot)(nil),     /* record_list_eval=Variable: */
	11181798416019134386: (*VariableDot)(nil),     /* text_eval=Variable: */
	14769776891888769773: (*VariableDot)(nil),     /* text_list_eval=Variable: */
	15966558056732701531: (*VariableDot)(nil),     /* address=Variable:dot: */
	7739360284898038596:  (*VariableDot)(nil),     /* bool_eval=Variable:dot: */
	4938834444414070846:  (*VariableDot)(nil),     /* num_eval=Variable:dot: */
	14012826006150347811: (*VariableDot)(nil),     /* num_list_eval=Variable:dot: */
	3479001804857346403:  (*VariableDot)(nil),     /* record_eval=Variable:dot: */
	11938488787528882828: (*VariableDot)(nil),     /* record_list_eval=Variable:dot: */
	4798713833623285465:  (*VariableDot)(nil),     /* text_eval=Variable:dot: */
	12039638244497140214: (*VariableDot)(nil),     /* text_list_eval=Variable:dot: */
}
