// Common text output commands.
package printer

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// Add a single blank line, unless a blank line was just written.
// See also <p> in package markup.
type ParagraphBreak struct {
	Markup map[string]any
}

// paragraph_break, a type of flow.
var Zt_ParagraphBreak typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ParagraphBreak) TypeInfo() typeinfo.T {
	return &Zt_ParagraphBreak
}

// Implements [typeinfo.Markup]
func (op *ParagraphBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ParagraphBreak)(nil)

// Holds a slice of type ParagraphBreak.
type ParagraphBreak_Slice []ParagraphBreak

// Implements [typeinfo.Instance] for a slice of ParagraphBreak.
func (*ParagraphBreak_Slice) TypeInfo() typeinfo.T {
	return &Zt_ParagraphBreak
}

// Implements [typeinfo.Repeats] for a slice of ParagraphBreak.
func (op *ParagraphBreak_Slice) Repeats() bool {
	return len(*op) > 0
}

// Start a new line ( if not already at a new line ).
type Softline struct {
	Markup map[string]any
}

// softline, a type of flow.
var Zt_Softline typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Softline) TypeInfo() typeinfo.T {
	return &Zt_Softline
}

// Implements [typeinfo.Markup]
func (op *Softline) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Softline)(nil)

// Holds a slice of type Softline.
type Softline_Slice []Softline

// Implements [typeinfo.Instance] for a slice of Softline.
func (*Softline_Slice) TypeInfo() typeinfo.T {
	return &Zt_Softline
}

// Implements [typeinfo.Repeats] for a slice of Softline.
func (op *Softline_Slice) Repeats() bool {
	return len(*op) > 0
}

// Start a new line.
type LineBreak struct {
	Markup map[string]any
}

// line_break, a type of flow.
var Zt_LineBreak typeinfo.Flow

// Implements [typeinfo.Instance]
func (*LineBreak) TypeInfo() typeinfo.T {
	return &Zt_LineBreak
}

// Implements [typeinfo.Markup]
func (op *LineBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*LineBreak)(nil)

// Holds a slice of type LineBreak.
type LineBreak_Slice []LineBreak

// Implements [typeinfo.Instance] for a slice of LineBreak.
func (*LineBreak_Slice) TypeInfo() typeinfo.T {
	return &Zt_LineBreak
}

// Implements [typeinfo.Repeats] for a slice of LineBreak.
func (op *LineBreak_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of cycle_text.
type CallCycle struct {
	Name   string
	Parts  []rtti.TextEval
	Markup map[string]any
}

// call_cycle, a type of flow.
var Zt_CallCycle typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallCycle) TypeInfo() typeinfo.T {
	return &Zt_CallCycle
}

// Implements [typeinfo.Markup]
func (op *CallCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*CallCycle)(nil)

// Holds a slice of type CallCycle.
type CallCycle_Slice []CallCycle

// Implements [typeinfo.Instance] for a slice of CallCycle.
func (*CallCycle_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallCycle
}

// Implements [typeinfo.Repeats] for a slice of CallCycle.
func (op *CallCycle_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of shuffle_text.
type CallShuffle struct {
	Name    string
	Parts   []rtti.TextEval
	Indices Shuffler
	Markup  map[string]any
}

// call_shuffle, a type of flow.
var Zt_CallShuffle typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallShuffle) TypeInfo() typeinfo.T {
	return &Zt_CallShuffle
}

// Implements [typeinfo.Markup]
func (op *CallShuffle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*CallShuffle)(nil)

// Holds a slice of type CallShuffle.
type CallShuffle_Slice []CallShuffle

// Implements [typeinfo.Instance] for a slice of CallShuffle.
func (*CallShuffle_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallShuffle
}

// Implements [typeinfo.Repeats] for a slice of CallShuffle.
func (op *CallShuffle_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of stopping_text.
type CallTerminal struct {
	Name   string
	Parts  []rtti.TextEval
	Markup map[string]any
}

// call_terminal, a type of flow.
var Zt_CallTerminal typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallTerminal) TypeInfo() typeinfo.T {
	return &Zt_CallTerminal
}

// Implements [typeinfo.Markup]
func (op *CallTerminal) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*CallTerminal)(nil)

// Holds a slice of type CallTerminal.
type CallTerminal_Slice []CallTerminal

// Implements [typeinfo.Instance] for a slice of CallTerminal.
func (*CallTerminal_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallTerminal
}

// Implements [typeinfo.Repeats] for a slice of CallTerminal.
func (op *CallTerminal_Slice) Repeats() bool {
	return len(*op) > 0
}

type BufferText struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// buffer_text, a type of flow.
var Zt_BufferText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*BufferText) TypeInfo() typeinfo.T {
	return &Zt_BufferText
}

// Implements [typeinfo.Markup]
func (op *BufferText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*BufferText)(nil)

// Holds a slice of type BufferText.
type BufferText_Slice []BufferText

// Implements [typeinfo.Instance] for a slice of BufferText.
func (*BufferText_Slice) TypeInfo() typeinfo.T {
	return &Zt_BufferText
}

// Implements [typeinfo.Repeats] for a slice of BufferText.
func (op *BufferText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Display some text to the player without apply any additional formatting.
type PrintText struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// print_text, a type of flow.
var Zt_PrintText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintText) TypeInfo() typeinfo.T {
	return &Zt_PrintText
}

// Implements [typeinfo.Markup]
func (op *PrintText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*PrintText)(nil)

// Holds a slice of type PrintText.
type PrintText_Slice []PrintText

// Implements [typeinfo.Instance] for a slice of PrintText.
func (*PrintText_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintText
}

// Implements [typeinfo.Repeats] for a slice of PrintText.
func (op *PrintText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Writes text, by default putting spaces between words.
type PrintWords struct {
	Separator rtti.TextEval
	Exe       []rtti.Execute
	Markup    map[string]any
}

// print_words, a type of flow.
var Zt_PrintWords typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintWords) TypeInfo() typeinfo.T {
	return &Zt_PrintWords
}

// Implements [typeinfo.Markup]
func (op *PrintWords) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*PrintWords)(nil)
var _ rtti.TextEval = (*PrintWords)(nil)

// Holds a slice of type PrintWords.
type PrintWords_Slice []PrintWords

// Implements [typeinfo.Instance] for a slice of PrintWords.
func (*PrintWords_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintWords
}

// Implements [typeinfo.Repeats] for a slice of PrintWords.
func (op *PrintWords_Slice) Repeats() bool {
	return len(*op) > 0
}

// Collect printed text and surrounds the output with parenthesis '()'.
// If no text is printed, no parentheses are printed.
type PrintParens struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// print_parens, a type of flow.
var Zt_PrintParens typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintParens) TypeInfo() typeinfo.T {
	return &Zt_PrintParens
}

// Implements [typeinfo.Markup]
func (op *PrintParens) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintParens)(nil)
var _ rtti.Execute = (*PrintParens)(nil)

// Holds a slice of type PrintParens.
type PrintParens_Slice []PrintParens

// Implements [typeinfo.Instance] for a slice of PrintParens.
func (*PrintParens_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintParens
}

// Implements [typeinfo.Repeats] for a slice of PrintParens.
func (op *PrintParens_Slice) Repeats() bool {
	return len(*op) > 0
}

// Separates words with commas, and 'and'.
type PrintCommas struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// print_commas, a type of flow.
var Zt_PrintCommas typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PrintCommas) TypeInfo() typeinfo.T {
	return &Zt_PrintCommas
}

// Implements [typeinfo.Markup]
func (op *PrintCommas) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*PrintCommas)(nil)
var _ rtti.Execute = (*PrintCommas)(nil)

// Holds a slice of type PrintCommas.
type PrintCommas_Slice []PrintCommas

// Implements [typeinfo.Instance] for a slice of PrintCommas.
func (*PrintCommas_Slice) TypeInfo() typeinfo.T {
	return &Zt_PrintCommas
}

// Implements [typeinfo.Repeats] for a slice of PrintCommas.
func (op *PrintCommas_Slice) Repeats() bool {
	return len(*op) > 0
}

// Group text into a single line <li> as part of a list of lines.
// See also: 'rows'.
type Row struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// row, a type of flow.
var Zt_Row typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Row) TypeInfo() typeinfo.T {
	return &Zt_Row
}

// Implements [typeinfo.Markup]
func (op *Row) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Row)(nil)

// Holds a slice of type Row.
type Row_Slice []Row

// Implements [typeinfo.Instance] for a slice of Row.
func (*Row_Slice) TypeInfo() typeinfo.T {
	return &Zt_Row
}

// Implements [typeinfo.Repeats] for a slice of Row.
func (op *Row_Slice) Repeats() bool {
	return len(*op) > 0
}

// Group text into an unordered list <ul>.
type Rows struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// rows, a type of flow.
var Zt_Rows typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Rows) TypeInfo() typeinfo.T {
	return &Zt_Rows
}

// Implements [typeinfo.Markup]
func (op *Rows) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*Rows)(nil)

// Holds a slice of type Rows.
type Rows_Slice []Rows

// Implements [typeinfo.Instance] for a slice of Rows.
func (*Rows_Slice) TypeInfo() typeinfo.T {
	return &Zt_Rows
}

// Implements [typeinfo.Repeats] for a slice of Rows.
func (op *Rows_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_ParagraphBreak = typeinfo.Flow{
		Name:  "paragraph_break",
		Lede:  "paragraph_break",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Add a single blank line, unless a blank line was just written.", "See also <p> in package markup."},
		},
	}
	Zt_Softline = typeinfo.Flow{
		Name:  "softline",
		Lede:  "wbr",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Start a new line ( if not already at a new line ).",
		},
	}
	Zt_LineBreak = typeinfo.Flow{
		Name:  "line_break",
		Lede:  "line_break",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Start a new line.",
		},
	}
	Zt_CallCycle = typeinfo.Flow{
		Name: "call_cycle",
		Lede: "cycle",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment":  "Runtime version of cycle_text.",
			"internal": true,
		},
	}
	Zt_CallShuffle = typeinfo.Flow{
		Name: "call_shuffle",
		Lede: "shuffle",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}, {
			Name:    "indices",
			Label:   "indices",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment":  "Runtime version of shuffle_text.",
			"internal": true,
		},
	}
	Zt_CallTerminal = typeinfo.Flow{
		Name: "call_terminal",
		Lede: "stopping",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:    "parts",
			Label:   "over",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment":  "Runtime version of stopping_text.",
			"internal": true,
		},
	}
	Zt_BufferText = typeinfo.Flow{
		Name: "buffer_text",
		Lede: "buffers",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
	}
	Zt_PrintText = typeinfo.Flow{
		Name: "print_text",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Display some text to the player without apply any additional formatting.",
		},
	}
	Zt_PrintWords = typeinfo.Flow{
		Name: "print_words",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name:     "separator",
			Label:    "separator",
			Optional: true,
			Markup: map[string]any{
				"comment": "Optional text to place between adjoining words.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "words",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Runs one or more statements, and collects any text printed by them.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Writes text, by default putting spaces between words.",
		},
	}
	Zt_PrintParens = typeinfo.Flow{
		Name: "print_parens",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "parentheses",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Runs one or more statements, and collects any text printed by them.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Collect printed text and surrounds the output with parenthesis '()'.", "If no text is printed, no parentheses are printed."},
		},
	}
	Zt_PrintCommas = typeinfo.Flow{
		Name: "print_commas",
		Lede: "print",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "commas",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Separates words with commas, and 'and'.",
		},
	}
	Zt_Row = typeinfo.Flow{
		Name: "row",
		Lede: "row",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Runs one or more statements, and collects any text printed by them.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Group text into a single line <li> as part of a list of lines.", "See also: 'rows'."},
		},
	}
	Zt_Rows = typeinfo.Flow{
		Name: "rows",
		Lede: "rows",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Runs one or more statements, and collects any text printed by them.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Group text into an unordered list <ul>.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "printer",
	Comment: []string{
		"Common text output commands.",
	},

	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_ParagraphBreak,
	&Zt_Softline,
	&Zt_LineBreak,
	&Zt_CallCycle,
	&Zt_CallShuffle,
	&Zt_CallTerminal,
	&Zt_BufferText,
	&Zt_PrintText,
	&Zt_PrintWords,
	&Zt_PrintParens,
	&Zt_PrintCommas,
	&Zt_Row,
	&Zt_Rows,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	11322251195672034522: (*BufferText)(nil),     /* text_eval=Buffers do: */
	2636120577324077328:  (*CallCycle)(nil),      /* text_eval=Cycle:over: */
	10898429598193857104: (*LineBreak)(nil),      /* execute=LineBreak */
	1194153657675604478:  (*ParagraphBreak)(nil), /* execute=ParagraphBreak */
	16169738297367022876: (*PrintCommas)(nil),    /* execute=Print commas: */
	6231219704730380469:  (*PrintCommas)(nil),    /* text_eval=Print commas: */
	4206645811149297220:  (*PrintParens)(nil),    /* execute=Print parentheses: */
	8219093008786386363:  (*PrintParens)(nil),    /* text_eval=Print parentheses: */
	4149419216708670664:  (*PrintWords)(nil),     /* execute=Print separator:words: */
	4219359027975954467:  (*PrintWords)(nil),     /* text_eval=Print separator:words: */
	1331651249232124175:  (*PrintWords)(nil),     /* execute=Print words: */
	17978150574109115948: (*PrintWords)(nil),     /* text_eval=Print words: */
	4512128922644282356:  (*PrintText)(nil),      /* execute=Print: */
	14820902432990466009: (*Row)(nil),            /* text_eval=Row do: */
	42419598592471524:    (*Rows)(nil),           /* text_eval=Rows do: */
	3632089819497852687:  (*CallShuffle)(nil),    /* text_eval=Shuffle:over: */
	10180508752412200934: (*CallTerminal)(nil),   /* text_eval=Stopping:over: */
	16612725309683107572: (*Softline)(nil),       /* execute=Wbr */
}
