// Common boolean logic and loop handling.
package logic

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// brancher, a type of slot.
var Zt_Brancher = typeinfo.Slot{
	Name: "brancher",
	Markup: map[string]any{
		"comment": "Helper for the else statements of [ChooseBranch].",
	},
}

// Holds a single slot.
type Brancher_Slot struct{ Value Brancher }

// Implements [typeinfo.Instance] for a single slot.
func (*Brancher_Slot) TypeInfo() typeinfo.T {
	return &Zt_Brancher
}

// Holds a slice of slots.
type Brancher_Slots []Brancher

// Implements [typeinfo.Instance] for a slice of slots.
func (*Brancher_Slots) TypeInfo() typeinfo.T {
	return &Zt_Brancher
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *Brancher_Slots) Repeats() bool {
	return len(*op) > 0
}

// Test if a set of conditions all return true.
// Stops testing after the first condition fails.
type AllTrue struct {
	Test   []rtti.BoolEval
	Markup map[string]any
}

// all_true, a type of flow.
var Zt_AllTrue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AllTrue) TypeInfo() typeinfo.T {
	return &Zt_AllTrue
}

// Implements [typeinfo.Markup]
func (op *AllTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*AllTrue)(nil)

// Holds a slice of type AllTrue.
type AllTrue_Slice []AllTrue

// Implements [typeinfo.Instance] for a slice of AllTrue.
func (*AllTrue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AllTrue
}

// Implements [typeinfo.Repeats] for a slice of AllTrue.
func (op *AllTrue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return true; always.
type Always struct {
	Markup map[string]any
}

// always, a type of flow.
var Zt_Always typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Always) TypeInfo() typeinfo.T {
	return &Zt_Always
}

// Implements [typeinfo.Markup]
func (op *Always) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Always)(nil)

// Holds a slice of type Always.
type Always_Slice []Always

// Implements [typeinfo.Instance] for a slice of Always.
func (*Always_Slice) TypeInfo() typeinfo.T {
	return &Zt_Always
}

// Implements [typeinfo.Repeats] for a slice of Always.
func (op *Always_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns false.
type Never struct {
	Markup map[string]any
}

// never, a type of flow.
var Zt_Never typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Never) TypeInfo() typeinfo.T {
	return &Zt_Never
}

// Implements [typeinfo.Markup]
func (op *Never) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Never)(nil)

// Holds a slice of type Never.
type Never_Slice []Never

// Implements [typeinfo.Instance] for a slice of Never.
func (*Never_Slice) TypeInfo() typeinfo.T {
	return &Zt_Never
}

// Implements [typeinfo.Repeats] for a slice of Never.
func (op *Never_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns the opposite value.
type Not struct {
	Test   rtti.BoolEval
	Markup map[string]any
}

// not, a type of flow.
var Zt_Not typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Not) TypeInfo() typeinfo.T {
	return &Zt_Not
}

// Implements [typeinfo.Markup]
func (op *Not) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*Not)(nil)

// Holds a slice of type Not.
type Not_Slice []Not

// Implements [typeinfo.Instance] for a slice of Not.
func (*Not_Slice) TypeInfo() typeinfo.T {
	return &Zt_Not
}

// Implements [typeinfo.Repeats] for a slice of Not.
func (op *Not_Slice) Repeats() bool {
	return len(*op) > 0
}

// Test if any condition in a set of conditions returns true.
// Stops testing after the first condition succeeds.
type AnyTrue struct {
	Test   []rtti.BoolEval
	Markup map[string]any
}

// any_true, a type of flow.
var Zt_AnyTrue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AnyTrue) TypeInfo() typeinfo.T {
	return &Zt_AnyTrue
}

// Implements [typeinfo.Markup]
func (op *AnyTrue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*AnyTrue)(nil)

// Holds a slice of type AnyTrue.
type AnyTrue_Slice []AnyTrue

// Implements [typeinfo.Instance] for a slice of AnyTrue.
func (*AnyTrue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AnyTrue
}

// Implements [typeinfo.Repeats] for a slice of AnyTrue.
func (op *AnyTrue_Slice) Repeats() bool {
	return len(*op) > 0
}

// In a repeating loop, exit the loop;
// or, in a rule, stop processing rules.
type Break struct {
	Markup map[string]any
}

// break, a type of flow.
var Zt_Break typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Break) TypeInfo() typeinfo.T {
	return &Zt_Break
}

// Implements [typeinfo.Markup]
func (op *Break) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Break)(nil)

// Holds a slice of type Break.
type Break_Slice []Break

// Implements [typeinfo.Instance] for a slice of Break.
func (*Break_Slice) TypeInfo() typeinfo.T {
	return &Zt_Break
}

// Implements [typeinfo.Repeats] for a slice of Break.
func (op *Break_Slice) Repeats() bool {
	return len(*op) > 0
}

// In a repeating loop, try the next iteration of the loop;
// or, in a rule, continue to the next rule.
type Continue struct {
	Markup map[string]any
}

// continue, a type of flow.
var Zt_Continue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Continue) TypeInfo() typeinfo.T {
	return &Zt_Continue
}

// Implements [typeinfo.Markup]
func (op *Continue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Continue)(nil)

// Holds a slice of type Continue.
type Continue_Slice []Continue

// Implements [typeinfo.Instance] for a slice of Continue.
func (*Continue_Slice) TypeInfo() typeinfo.T {
	return &Zt_Continue
}

// Implements [typeinfo.Repeats] for a slice of Continue.
func (op *Continue_Slice) Repeats() bool {
	return len(*op) > 0
}

// An if statement.
type ChooseBranch struct {
	Condition rtti.BoolEval
	Args      []assign.Arg
	Exe       []rtti.Execute
	Else      Brancher
	Markup    map[string]any
}

// choose_branch, a type of flow.
var Zt_ChooseBranch typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseBranch) TypeInfo() typeinfo.T {
	return &Zt_ChooseBranch
}

// Implements [typeinfo.Markup]
func (op *ChooseBranch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ChooseBranch)(nil)
var _ Brancher = (*ChooseBranch)(nil)

// Holds a slice of type ChooseBranch.
type ChooseBranch_Slice []ChooseBranch

// Implements [typeinfo.Instance] for a slice of ChooseBranch.
func (*ChooseBranch_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseBranch
}

// Implements [typeinfo.Repeats] for a slice of ChooseBranch.
func (op *ChooseBranch_Slice) Repeats() bool {
	return len(*op) > 0
}

// Run a set of statements after a condition has failed.
type ChooseNothingElse struct {
	Exe    []rtti.Execute
	Markup map[string]any
}

// choose_nothing_else, a type of flow.
var Zt_ChooseNothingElse typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseNothingElse) TypeInfo() typeinfo.T {
	return &Zt_ChooseNothingElse
}

// Implements [typeinfo.Markup]
func (op *ChooseNothingElse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Brancher = (*ChooseNothingElse)(nil)

// Holds a slice of type ChooseNothingElse.
type ChooseNothingElse_Slice []ChooseNothingElse

// Implements [typeinfo.Instance] for a slice of ChooseNothingElse.
func (*ChooseNothingElse_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseNothingElse
}

// Implements [typeinfo.Repeats] for a slice of ChooseNothingElse.
func (op *ChooseNothingElse_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pick one of two possible text values based on a condition.
// ( This acts similar to a ternary. )
type ChooseNum struct {
	If     rtti.BoolEval
	Args   []assign.Arg
	True   rtti.NumEval
	False  rtti.NumEval
	Markup map[string]any
}

// choose_num, a type of flow.
var Zt_ChooseNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseNum) TypeInfo() typeinfo.T {
	return &Zt_ChooseNum
}

// Implements [typeinfo.Markup]
func (op *ChooseNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*ChooseNum)(nil)

// Holds a slice of type ChooseNum.
type ChooseNum_Slice []ChooseNum

// Implements [typeinfo.Instance] for a slice of ChooseNum.
func (*ChooseNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseNum
}

// Implements [typeinfo.Repeats] for a slice of ChooseNum.
func (op *ChooseNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pick one of two possible text values based on a condition.
// ( This acts similar to a ternary. )
type ChooseText struct {
	If     rtti.BoolEval
	Args   []assign.Arg
	True   rtti.TextEval
	False  rtti.TextEval
	Markup map[string]any
}

// choose_text, a type of flow.
var Zt_ChooseText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseText) TypeInfo() typeinfo.T {
	return &Zt_ChooseText
}

// Implements [typeinfo.Markup]
func (op *ChooseText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*ChooseText)(nil)

// Holds a slice of type ChooseText.
type ChooseText_Slice []ChooseText

// Implements [typeinfo.Instance] for a slice of ChooseText.
func (*ChooseText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseText
}

// Implements [typeinfo.Repeats] for a slice of ChooseText.
func (op *ChooseText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Keep running a series of actions while a condition is true.
type While struct {
	True   rtti.BoolEval
	Exe    []rtti.Execute
	Markup map[string]any
}

// while, a type of flow.
var Zt_While typeinfo.Flow

// Implements [typeinfo.Instance]
func (*While) TypeInfo() typeinfo.T {
	return &Zt_While
}

// Implements [typeinfo.Markup]
func (op *While) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*While)(nil)

// Holds a slice of type While.
type While_Slice []While

// Implements [typeinfo.Instance] for a slice of While.
func (*While_Slice) TypeInfo() typeinfo.T {
	return &Zt_While
}

// Implements [typeinfo.Repeats] for a slice of While.
func (op *While_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_AllTrue = typeinfo.Flow{
		Name: "all_true",
		Lede: "all_true",
		Terms: []typeinfo.Term{{
			Name:    "test",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more conditions to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Test if a set of conditions all return true.", "Stops testing after the first condition fails."},
		},
	}
	Zt_Always = typeinfo.Flow{
		Name:  "always",
		Lede:  "always",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Return true; always.",
		},
	}
	Zt_Never = typeinfo.Flow{
		Name:  "never",
		Lede:  "never",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns false.",
		},
	}
	Zt_Not = typeinfo.Flow{
		Name: "not",
		Lede: "not",
		Terms: []typeinfo.Term{{
			Name: "test",
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Returns the opposite value.",
		},
	}
	Zt_AnyTrue = typeinfo.Flow{
		Name: "any_true",
		Lede: "any_true",
		Terms: []typeinfo.Term{{
			Name:    "test",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more conditions to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Test if any condition in a set of conditions returns true.", "Stops testing after the first condition succeeds."},
		},
	}
	Zt_Break = typeinfo.Flow{
		Name:  "break",
		Lede:  "break",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"In a repeating loop, exit the loop;", "or, in a rule, stop processing rules."},
		},
	}
	Zt_Continue = typeinfo.Flow{
		Name:  "continue",
		Lede:  "continue",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"In a repeating loop, try the next iteration of the loop;", "or, in a rule, continue to the next rule."},
		},
	}
	Zt_ChooseBranch = typeinfo.Flow{
		Name: "choose_branch",
		Lede: "if",
		Terms: []typeinfo.Term{{
			Name: "condition",
			Markup: map[string]any{
				"comment": "The condition to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:     "args",
			Label:    "assuming",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "A set of local variables available while testing the condition and while running the do/else statements. These are initialized before testing the condition.",
			},
			Type: &assign.Zt_Arg,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "Statements which run when the condition succeeded.",
			},
			Type: &rtti.Zt_Execute,
		}, {
			Name:     "else",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"comment": "An optional set of statements to evaluate when the condition failed.",
			},
			Type: &Zt_Brancher,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&Zt_Brancher,
		},
		Markup: map[string]any{
			"comment": "An if statement.",
		},
	}
	Zt_ChooseNothingElse = typeinfo.Flow{
		Name: "choose_nothing_else",
		Lede: "finally",
		Terms: []typeinfo.Term{{
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more statements to run.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Brancher,
		},
		Markup: map[string]any{
			"comment": "Run a set of statements after a condition has failed.",
		},
	}
	Zt_ChooseNum = typeinfo.Flow{
		Name: "choose_num",
		Lede: "num",
		Terms: []typeinfo.Term{{
			Name:  "if",
			Label: "if",
			Markup: map[string]any{
				"comment": "The condition to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:     "args",
			Label:    "assuming",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "A set of local variables available while testing the condition and while running the do/else statements. These are initialized before testing the condition.",
			},
			Type: &assign.Zt_Arg,
		}, {
			Name:  "true",
			Label: "then",
			Markup: map[string]any{
				"comment": "The number to use if the condition succeeds.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "false",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"comment": "The number to use if the condition fails.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Pick one of two possible text values based on a condition.", "( This acts similar to a ternary. )"},
		},
	}
	Zt_ChooseText = typeinfo.Flow{
		Name: "choose_text",
		Lede: "text",
		Terms: []typeinfo.Term{{
			Name:  "if",
			Label: "if",
			Markup: map[string]any{
				"comment": "The condition to test.",
			},
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:     "args",
			Label:    "assuming",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "A set of local variables available while testing the condition and while running the do/else statements. These are initialized before testing the condition.",
			},
			Type: &assign.Zt_Arg,
		}, {
			Name:  "true",
			Label: "then",
			Markup: map[string]any{
				"comment": "The text value to use if the condition succeeds.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "false",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"comment": "The text value to use if the condition fails.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Pick one of two possible text values based on a condition.", "( This acts similar to a ternary. )"},
		},
	}
	Zt_While = typeinfo.Flow{
		Name: "while",
		Lede: "repeating",
		Terms: []typeinfo.Term{{
			Name: "true",
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Keep running a series of actions while a condition is true.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "logic",
	Comment: []string{
		"Common boolean logic and loop handling.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Brancher,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_AllTrue,
	&Zt_Always,
	&Zt_Never,
	&Zt_Not,
	&Zt_AnyTrue,
	&Zt_Break,
	&Zt_Continue,
	&Zt_ChooseBranch,
	&Zt_ChooseNothingElse,
	&Zt_ChooseNum,
	&Zt_ChooseText,
	&Zt_While,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	8082607244820951444:  (*AllTrue)(nil),           /* bool_eval=AllTrue: */
	1979437068831463006:  (*Always)(nil),            /* bool_eval=Always */
	1963945852392897915:  (*AnyTrue)(nil),           /* bool_eval=AnyTrue: */
	9570569845423374482:  (*Break)(nil),             /* execute=Break */
	3156233792812716886:  (*Continue)(nil),          /* execute=Continue */
	13697022905922221509: (*ChooseNothingElse)(nil), /* brancher=Finally do: */
	6524366950360243674:  (*ChooseBranch)(nil),      /* brancher=If:assuming:do: */
	12195526980856142720: (*ChooseBranch)(nil),      /* execute=If:assuming:do: */
	16752471159562852415: (*ChooseBranch)(nil),      /* brancher=If:assuming:do:else: */
	2092791308408463217:  (*ChooseBranch)(nil),      /* execute=If:assuming:do:else: */
	11676187955438326921: (*ChooseBranch)(nil),      /* brancher=If:do: */
	16551038912311542599: (*ChooseBranch)(nil),      /* execute=If:do: */
	11846460753008131314: (*ChooseBranch)(nil),      /* brancher=If:do:else: */
	9882017885672780228:  (*ChooseBranch)(nil),      /* execute=If:do:else: */
	1310533520550597035:  (*Never)(nil),             /* bool_eval=Never */
	3572677870333466638:  (*Not)(nil),               /* bool_eval=Not: */
	12220459187031741460: (*ChooseNum)(nil),         /* num_eval=Num if:assuming:then: */
	2863639051637372837:  (*ChooseNum)(nil),         /* num_eval=Num if:assuming:then:else: */
	9841785069654362751:  (*ChooseNum)(nil),         /* num_eval=Num if:then: */
	2293377426593441548:  (*ChooseNum)(nil),         /* num_eval=Num if:then:else: */
	16853421744116592875: (*While)(nil),             /* execute=Repeating:do: */
	4784360512497235820:  (*ChooseText)(nil),        /* text_eval=Text if:assuming:then: */
	13980719859951632205: (*ChooseText)(nil),        /* text_eval=Text if:assuming:then:else: */
	4706788097495762503:  (*ChooseText)(nil),        /* text_eval=Text if:then: */
	12221021609112050372: (*ChooseText)(nil),        /* text_eval=Text if:then:else: */
}
