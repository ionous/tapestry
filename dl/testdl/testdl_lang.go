// Code generated by "makeops"; edit at your own risk.
package testdl

import (
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/jsn"
	"github.com/ionous/errutil"
)

// TestBool requires a predefined string.
type TestBool struct {
	Str string
}

func (op *TestBool) String() string {
	return op.Str
}

const TestBool_True = "$TRUE"
const TestBool_False = "$FALSE"

func (*TestBool) Compose() composer.Spec {
	return composer.Spec{
		Name: TestBool_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			TestBool_True, TestBool_False,
		},
		Strings: []string{
			"true", "false",
		},
	}
}

const TestBool_Type = "test_bool"

func (op *TestBool) Marshal(m jsn.Marshaler) error {
	return TestBool_Marshal(m, op)
}

func TestBool_Optional_Marshal(m jsn.Marshaler, val *TestBool) (err error) {
	var zero TestBool
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestBool_Marshal(m, val)
	}
	return
}

func TestBool_Marshal(m jsn.Marshaler, val *TestBool) (err error) {
	return m.MarshalValue(TestBool_Type, jsn.MakeEnum(val, &val.Str))
}

type TestBool_Slice []TestBool

func (op *TestBool_Slice) GetType() string { return TestBool_Type }

func (op *TestBool_Slice) Marshal(m jsn.Marshaler) error {
	return TestBool_Repeats_Marshal(m, (*[]TestBool)(op))
}

func (op *TestBool_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestBool_Slice) SetSize(cnt int) {
	var els []TestBool
	if cnt >= 0 {
		els = make(TestBool_Slice, cnt)
	}
	(*op) = els
}

func (op *TestBool_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestBool_Marshal(m, &(*op)[i])
}

func TestBool_Repeats_Marshal(m jsn.Marshaler, vals *[]TestBool) error {
	return jsn.RepeatBlock(m, (*TestBool_Slice)(vals))
}

func TestBool_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestBool) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestBool_Repeats_Marshal(m, pv)
	}
	return
}

// TestEmbed
type TestEmbed struct {
	TestFlow TestFlow `if:"label=test_flow"`
	Markup   map[string]any
}

// User implemented slots:
var _ TestSlot = (*TestEmbed)(nil)

func (*TestEmbed) Compose() composer.Spec {
	return composer.Spec{
		Name: TestEmbed_Type,
		Uses: composer.Type_Flow,
		Lede: "embed",
	}
}

const TestEmbed_Type = "test_embed"
const TestEmbed_Field_TestFlow = "$TEST_FLOW"

func (op *TestEmbed) Marshal(m jsn.Marshaler) error {
	return TestEmbed_Marshal(m, op)
}

type TestEmbed_Slice []TestEmbed

func (op *TestEmbed_Slice) GetType() string { return TestEmbed_Type }

func (op *TestEmbed_Slice) Marshal(m jsn.Marshaler) error {
	return TestEmbed_Repeats_Marshal(m, (*[]TestEmbed)(op))
}

func (op *TestEmbed_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestEmbed_Slice) SetSize(cnt int) {
	var els []TestEmbed
	if cnt >= 0 {
		els = make(TestEmbed_Slice, cnt)
	}
	(*op) = els
}

func (op *TestEmbed_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestEmbed_Marshal(m, &(*op)[i])
}

func TestEmbed_Repeats_Marshal(m jsn.Marshaler, vals *[]TestEmbed) error {
	return jsn.RepeatBlock(m, (*TestEmbed_Slice)(vals))
}

func TestEmbed_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestEmbed) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestEmbed_Repeats_Marshal(m, pv)
	}
	return
}

type TestEmbed_Flow struct{ ptr *TestEmbed }

func (n TestEmbed_Flow) GetType() string      { return TestEmbed_Type }
func (n TestEmbed_Flow) GetLede() string      { return "embed" }
func (n TestEmbed_Flow) GetFlow() interface{} { return n.ptr }
func (n TestEmbed_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*TestEmbed); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func TestEmbed_Optional_Marshal(m jsn.Marshaler, pv **TestEmbed) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = TestEmbed_Marshal(m, *pv)
	} else if !enc {
		var v TestEmbed
		if err = TestEmbed_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func TestEmbed_Marshal(m jsn.Marshaler, val *TestEmbed) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(TestEmbed_Flow{val}); err == nil {
		e0 := m.MarshalKey("test_flow", TestEmbed_Field_TestFlow)
		if e0 == nil {
			e0 = TestFlow_Marshal(m, &val.TestFlow)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", TestEmbed_Field_TestFlow))
		}
		m.EndBlock()
	}
	return
}

// TestFlow
type TestFlow struct {
	Slot   TestSlot   `if:"label=slot,optional"`
	Txt    TestTxt    `if:"label=txt,optional"`
	Num    float64    `if:"label=num,optional,type=test_num"`
	Bool   TestBool   `if:"label=bool,optional"`
	Slots  []TestSlot `if:"label=slots,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ TestSlot = (*TestFlow)(nil)

func (*TestFlow) Compose() composer.Spec {
	return composer.Spec{
		Name: TestFlow_Type,
		Uses: composer.Type_Flow,
		Lede: "flow",
	}
}

const TestFlow_Type = "test_flow"
const TestFlow_Field_Slot = "$SLOT"
const TestFlow_Field_Txt = "$TXT"
const TestFlow_Field_Num = "$NUM"
const TestFlow_Field_Bool = "$BOOL"
const TestFlow_Field_Slots = "$SLOTS"

func (op *TestFlow) Marshal(m jsn.Marshaler) error {
	return TestFlow_Marshal(m, op)
}

type TestFlow_Slice []TestFlow

func (op *TestFlow_Slice) GetType() string { return TestFlow_Type }

func (op *TestFlow_Slice) Marshal(m jsn.Marshaler) error {
	return TestFlow_Repeats_Marshal(m, (*[]TestFlow)(op))
}

func (op *TestFlow_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestFlow_Slice) SetSize(cnt int) {
	var els []TestFlow
	if cnt >= 0 {
		els = make(TestFlow_Slice, cnt)
	}
	(*op) = els
}

func (op *TestFlow_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestFlow_Marshal(m, &(*op)[i])
}

func TestFlow_Repeats_Marshal(m jsn.Marshaler, vals *[]TestFlow) error {
	return jsn.RepeatBlock(m, (*TestFlow_Slice)(vals))
}

func TestFlow_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestFlow) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestFlow_Repeats_Marshal(m, pv)
	}
	return
}

type TestFlow_Flow struct{ ptr *TestFlow }

func (n TestFlow_Flow) GetType() string      { return TestFlow_Type }
func (n TestFlow_Flow) GetLede() string      { return "flow" }
func (n TestFlow_Flow) GetFlow() interface{} { return n.ptr }
func (n TestFlow_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*TestFlow); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func TestFlow_Optional_Marshal(m jsn.Marshaler, pv **TestFlow) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = TestFlow_Marshal(m, *pv)
	} else if !enc {
		var v TestFlow
		if err = TestFlow_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func TestFlow_Marshal(m jsn.Marshaler, val *TestFlow) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(TestFlow_Flow{val}); err == nil {
		e0 := m.MarshalKey("slot", TestFlow_Field_Slot)
		if e0 == nil {
			e0 = TestSlot_Optional_Marshal(m, &val.Slot)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", TestFlow_Field_Slot))
		}
		e1 := m.MarshalKey("txt", TestFlow_Field_Txt)
		if e1 == nil {
			e1 = TestTxt_Optional_Marshal(m, &val.Txt)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", TestFlow_Field_Txt))
		}
		e2 := m.MarshalKey("num", TestFlow_Field_Num)
		if e2 == nil {
			e2 = TestNum_Unboxed_Optional_Marshal(m, &val.Num)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", TestFlow_Field_Num))
		}
		e3 := m.MarshalKey("bool", TestFlow_Field_Bool)
		if e3 == nil {
			e3 = TestBool_Optional_Marshal(m, &val.Bool)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", TestFlow_Field_Bool))
		}
		e4 := m.MarshalKey("slots", TestFlow_Field_Slots)
		if e4 == nil {
			e4 = TestSlot_Optional_Repeats_Marshal(m, &val.Slots)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", TestFlow_Field_Slots))
		}
		m.EndBlock()
	}
	return
}

// TestNum requires a user-specified number.
type TestNum struct {
	Num float64
}

func (*TestNum) Compose() composer.Spec {
	return composer.Spec{
		Name: TestNum_Type,
		Uses: composer.Type_Num,
	}
}

const TestNum_Type = "test_num"

func (op *TestNum) Marshal(m jsn.Marshaler) error {
	return TestNum_Marshal(m, op)
}

type TestNum_Unboxed_Slice []float64

func (op *TestNum_Unboxed_Slice) GetType() string { return TestNum_Type }

func (op *TestNum_Unboxed_Slice) Marshal(m jsn.Marshaler) error {
	return TestNum_Unboxed_Repeats_Marshal(m, (*[]float64)(op))
}

func (op *TestNum_Unboxed_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestNum_Unboxed_Slice) SetSize(cnt int) {
	var els []float64
	if cnt >= 0 {
		els = make(TestNum_Unboxed_Slice, cnt)
	}
	(*op) = els
}

func (op *TestNum_Unboxed_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestNum_Unboxed_Marshal(m, &(*op)[i])
}

func TestNum_Unboxed_Repeats_Marshal(m jsn.Marshaler, vals *[]float64) error {
	return jsn.RepeatBlock(m, (*TestNum_Unboxed_Slice)(vals))
}

func TestNum_Unboxed_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]float64) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestNum_Unboxed_Repeats_Marshal(m, pv)
	}
	return
}

func TestNum_Unboxed_Optional_Marshal(m jsn.Marshaler, val *float64) (err error) {
	var zero float64
	if enc := m.IsEncoding(); !enc || *val != zero {
		err = TestNum_Unboxed_Marshal(m, val)
	}
	return
}

func TestNum_Unboxed_Marshal(m jsn.Marshaler, val *float64) error {
	return m.MarshalValue(TestNum_Type, jsn.BoxFloat64(val))
}

func TestNum_Optional_Marshal(m jsn.Marshaler, val *TestNum) (err error) {
	var zero TestNum
	if enc := m.IsEncoding(); !enc || val.Num != zero.Num {
		err = TestNum_Marshal(m, val)
	}
	return
}

func TestNum_Marshal(m jsn.Marshaler, val *TestNum) (err error) {
	return m.MarshalValue(TestNum_Type, &val.Num)
}

type TestNum_Slice []TestNum

func (op *TestNum_Slice) GetType() string { return TestNum_Type }

func (op *TestNum_Slice) Marshal(m jsn.Marshaler) error {
	return TestNum_Repeats_Marshal(m, (*[]TestNum)(op))
}

func (op *TestNum_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestNum_Slice) SetSize(cnt int) {
	var els []TestNum
	if cnt >= 0 {
		els = make(TestNum_Slice, cnt)
	}
	(*op) = els
}

func (op *TestNum_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestNum_Marshal(m, &(*op)[i])
}

func TestNum_Repeats_Marshal(m jsn.Marshaler, vals *[]TestNum) error {
	return jsn.RepeatBlock(m, (*TestNum_Slice)(vals))
}

func TestNum_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestNum) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestNum_Repeats_Marshal(m, pv)
	}
	return
}

const TestSlot_Type = "test_slot"

var TestSlot_Optional_Marshal = TestSlot_Marshal

type TestSlot_Slot struct{ Value *TestSlot }

func (at TestSlot_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at TestSlot_Slot) GetType() string              { return TestSlot_Type }
func (at TestSlot_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at TestSlot_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(TestSlot)
	return
}

func TestSlot_Marshal(m jsn.Marshaler, ptr *TestSlot) (err error) {
	slot := TestSlot_Slot{ptr}
	return slot.Marshal(m)
}

type TestSlot_Slice []TestSlot

func (op *TestSlot_Slice) GetType() string { return TestSlot_Type }

func (op *TestSlot_Slice) Marshal(m jsn.Marshaler) error {
	return TestSlot_Repeats_Marshal(m, (*[]TestSlot)(op))
}

func (op *TestSlot_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestSlot_Slice) SetSize(cnt int) {
	var els []TestSlot
	if cnt >= 0 {
		els = make(TestSlot_Slice, cnt)
	}
	(*op) = els
}

func (op *TestSlot_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestSlot_Marshal(m, &(*op)[i])
}

func TestSlot_Repeats_Marshal(m jsn.Marshaler, vals *[]TestSlot) error {
	return jsn.RepeatBlock(m, (*TestSlot_Slice)(vals))
}

func TestSlot_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestSlot) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestSlot_Repeats_Marshal(m, pv)
	}
	return
}

// TestStr requires a predefined string.
type TestStr struct {
	Str string
}

func (op *TestStr) String() string {
	return op.Str
}

const TestStr_One = "$ONE"
const TestStr_Other = "$OTHER"
const TestStr_Option = "$OPTION"

func (*TestStr) Compose() composer.Spec {
	return composer.Spec{
		Name: TestStr_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			TestStr_One, TestStr_Other, TestStr_Option,
		},
		Strings: []string{
			"one", "other", "option",
		},
	}
}

const TestStr_Type = "test_str"

func (op *TestStr) Marshal(m jsn.Marshaler) error {
	return TestStr_Marshal(m, op)
}

func TestStr_Optional_Marshal(m jsn.Marshaler, val *TestStr) (err error) {
	var zero TestStr
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestStr_Marshal(m, val)
	}
	return
}

func TestStr_Marshal(m jsn.Marshaler, val *TestStr) (err error) {
	return m.MarshalValue(TestStr_Type, jsn.MakeEnum(val, &val.Str))
}

type TestStr_Slice []TestStr

func (op *TestStr_Slice) GetType() string { return TestStr_Type }

func (op *TestStr_Slice) Marshal(m jsn.Marshaler) error {
	return TestStr_Repeats_Marshal(m, (*[]TestStr)(op))
}

func (op *TestStr_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestStr_Slice) SetSize(cnt int) {
	var els []TestStr
	if cnt >= 0 {
		els = make(TestStr_Slice, cnt)
	}
	(*op) = els
}

func (op *TestStr_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestStr_Marshal(m, &(*op)[i])
}

func TestStr_Repeats_Marshal(m jsn.Marshaler, vals *[]TestStr) error {
	return jsn.RepeatBlock(m, (*TestStr_Slice)(vals))
}

func TestStr_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestStr) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestStr_Repeats_Marshal(m, pv)
	}
	return
}

// TestTxt requires a user-specified string.
type TestTxt struct {
	Str string
}

func (op *TestTxt) String() string {
	return op.Str
}

func (*TestTxt) Compose() composer.Spec {
	return composer.Spec{
		Name:        TestTxt_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const TestTxt_Type = "test_txt"

func (op *TestTxt) Marshal(m jsn.Marshaler) error {
	return TestTxt_Marshal(m, op)
}

func TestTxt_Optional_Marshal(m jsn.Marshaler, val *TestTxt) (err error) {
	var zero TestTxt
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestTxt_Marshal(m, val)
	}
	return
}

func TestTxt_Marshal(m jsn.Marshaler, val *TestTxt) (err error) {
	return m.MarshalValue(TestTxt_Type, &val.Str)
}

type TestTxt_Slice []TestTxt

func (op *TestTxt_Slice) GetType() string { return TestTxt_Type }

func (op *TestTxt_Slice) Marshal(m jsn.Marshaler) error {
	return TestTxt_Repeats_Marshal(m, (*[]TestTxt)(op))
}

func (op *TestTxt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestTxt_Slice) SetSize(cnt int) {
	var els []TestTxt
	if cnt >= 0 {
		els = make(TestTxt_Slice, cnt)
	}
	(*op) = els
}

func (op *TestTxt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestTxt_Marshal(m, &(*op)[i])
}

func TestTxt_Repeats_Marshal(m jsn.Marshaler, vals *[]TestTxt) error {
	return jsn.RepeatBlock(m, (*TestTxt_Slice)(vals))
}

func TestTxt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestTxt) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestTxt_Repeats_Marshal(m, pv)
	}
	return
}

var Slots = []interface{}{
	(*TestSlot)(nil),
}

var Slats = []composer.Composer{
	(*TestBool)(nil),
	(*TestEmbed)(nil),
	(*TestFlow)(nil),
	(*TestNum)(nil),
	(*TestStr)(nil),
	(*TestTxt)(nil),
}

var Signatures = map[uint64]interface{}{
	5375871781273392485:  (*TestBool)(nil),  /* TestBool: */
	2921095451308776491:  (*TestNum)(nil),   /* TestNum: */
	8940712013797765950:  (*TestStr)(nil),   /* TestStr: */
	9144781193212880495:  (*TestTxt)(nil),   /* TestTxt: */
	4674877661722404900:  (*TestEmbed)(nil), /* test_slot=Embed testFlow: */
	6035317458491358757:  (*TestFlow)(nil),  /* test_slot=Flow */
	3180197217674355987:  (*TestFlow)(nil),  /* test_slot=Flow bool: */
	7800787521023201210:  (*TestFlow)(nil),  /* test_slot=Flow bool:slots: */
	1352478831057267749:  (*TestFlow)(nil),  /* test_slot=Flow num: */
	5418383768131476581:  (*TestFlow)(nil),  /* test_slot=Flow num:bool: */
	7291931087597771892:  (*TestFlow)(nil),  /* test_slot=Flow num:bool:slots: */
	6297018247826912692:  (*TestFlow)(nil),  /* test_slot=Flow num:slots: */
	12951016320825491083: (*TestFlow)(nil),  /* test_slot=Flow slot: */
	9305516548358700591:  (*TestFlow)(nil),  /* test_slot=Flow slot:bool: */
	5145100175048896574:  (*TestFlow)(nil),  /* test_slot=Flow slot:bool:slots: */
	17015981910898011913: (*TestFlow)(nil),  /* test_slot=Flow slot:num: */
	1311123221862663321:  (*TestFlow)(nil),  /* test_slot=Flow slot:num:bool: */
	8394834950289276944:  (*TestFlow)(nil),  /* test_slot=Flow slot:num:bool:slots: */
	7555590340079896384:  (*TestFlow)(nil),  /* test_slot=Flow slot:num:slots: */
	12633006641875816738: (*TestFlow)(nil),  /* test_slot=Flow slot:slots: */
	15158636115026315841: (*TestFlow)(nil),  /* test_slot=Flow slot:txt: */
	14129076392559381825: (*TestFlow)(nil),  /* test_slot=Flow slot:txt:bool: */
	12962075234394227848: (*TestFlow)(nil),  /* test_slot=Flow slot:txt:bool:slots: */
	12920314065270770223: (*TestFlow)(nil),  /* test_slot=Flow slot:txt:num: */
	11065472324065071427: (*TestFlow)(nil),  /* test_slot=Flow slot:txt:num:bool: */
	1751948850686087210:  (*TestFlow)(nil),  /* test_slot=Flow slot:txt:num:bool:slots: */
	1821468357792341054:  (*TestFlow)(nil),  /* test_slot=Flow slot:txt:num:slots: */
	4820696260179335560:  (*TestFlow)(nil),  /* test_slot=Flow slot:txt:slots: */
	9022305410891129358:  (*TestFlow)(nil),  /* test_slot=Flow slots: */
	13864086419337359925: (*TestFlow)(nil),  /* test_slot=Flow txt: */
	6197717516868531189:  (*TestFlow)(nil),  /* test_slot=Flow txt:bool: */
	12039181645319947460: (*TestFlow)(nil),  /* test_slot=Flow txt:bool:slots: */
	3282522180982023931:  (*TestFlow)(nil),  /* test_slot=Flow txt:num: */
	14112799375577386271: (*TestFlow)(nil),  /* test_slot=Flow txt:num:bool: */
	15951227895458002862: (*TestFlow)(nil),  /* test_slot=Flow txt:num:bool:slots: */
	1596042300229332818:  (*TestFlow)(nil),  /* test_slot=Flow txt:num:slots: */
	445595344264097156:   (*TestFlow)(nil),  /* test_slot=Flow txt:slots: */
}
