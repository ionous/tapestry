// Code generated by "makeops"; edit at your own risk.
package testdl

import (
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/jsn"
	"github.com/ionous/errutil"
)

// TestBool requires a predefined string.
type TestBool struct {
	Str string
}

func (op *TestBool) String() string {
	return op.Str
}

const TestBool_True = "$TRUE"
const TestBool_False = "$FALSE"

func (*TestBool) Compose() composer.Spec {
	return composer.Spec{
		Name: TestBool_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			TestBool_True, TestBool_False,
		},
		Strings: []string{
			"true", "false",
		},
	}
}

const TestBool_Type = "test_bool"

func (op *TestBool) Marshal(m jsn.Marshaler) error {
	return TestBool_Marshal(m, op)
}

func TestBool_Optional_Marshal(m jsn.Marshaler, val *TestBool) (err error) {
	var zero TestBool
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestBool_Marshal(m, val)
	}
	return
}

func TestBool_Marshal(m jsn.Marshaler, val *TestBool) (err error) {
	return m.MarshalValue(TestBool_Type, jsn.MakeEnum(val, &val.Str))
}

type TestBool_Slice []TestBool

func (op *TestBool_Slice) GetType() string { return TestBool_Type }

func (op *TestBool_Slice) Marshal(m jsn.Marshaler) error {
	return TestBool_Repeats_Marshal(m, (*[]TestBool)(op))
}

func (op *TestBool_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestBool_Slice) SetSize(cnt int) {
	var els []TestBool
	if cnt >= 0 {
		els = make(TestBool_Slice, cnt)
	}
	(*op) = els
}

func (op *TestBool_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestBool_Marshal(m, &(*op)[i])
}

func TestBool_Repeats_Marshal(m jsn.Marshaler, vals *[]TestBool) error {
	return jsn.RepeatBlock(m, (*TestBool_Slice)(vals))
}

func TestBool_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestBool) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = TestBool_Repeats_Marshal(m, pv)
	}
	return
}

// TestFlow
type TestFlow struct {
	Slot  TestSlot   `if:"label=slot,optional"`
	Txt   TestTxt    `if:"label=txt,optional"`
	Num   float64    `if:"label=num,optional,type=test_num"`
	Bool  TestBool   `if:"label=bool,optional"`
	Swap  TestSwap   `if:"label=swap,optional"`
	Slots []TestSlot `if:"label=slots,optional"`
}

// User implemented slots:
var _ TestSlot = (*TestFlow)(nil)

func (*TestFlow) Compose() composer.Spec {
	return composer.Spec{
		Name: TestFlow_Type,
		Uses: composer.Type_Flow,
		Lede: "flow",
	}
}

const TestFlow_Type = "test_flow"
const TestFlow_Field_Slot = "$SLOT"
const TestFlow_Field_Txt = "$TXT"
const TestFlow_Field_Num = "$NUM"
const TestFlow_Field_Bool = "$BOOL"
const TestFlow_Field_Swap = "$SWAP"
const TestFlow_Field_Slots = "$SLOTS"

func (op *TestFlow) Marshal(m jsn.Marshaler) error {
	return TestFlow_Marshal(m, op)
}

type TestFlow_Slice []TestFlow

func (op *TestFlow_Slice) GetType() string { return TestFlow_Type }

func (op *TestFlow_Slice) Marshal(m jsn.Marshaler) error {
	return TestFlow_Repeats_Marshal(m, (*[]TestFlow)(op))
}

func (op *TestFlow_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestFlow_Slice) SetSize(cnt int) {
	var els []TestFlow
	if cnt >= 0 {
		els = make(TestFlow_Slice, cnt)
	}
	(*op) = els
}

func (op *TestFlow_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestFlow_Marshal(m, &(*op)[i])
}

func TestFlow_Repeats_Marshal(m jsn.Marshaler, vals *[]TestFlow) error {
	return jsn.RepeatBlock(m, (*TestFlow_Slice)(vals))
}

func TestFlow_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestFlow) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = TestFlow_Repeats_Marshal(m, pv)
	}
	return
}

type TestFlow_Flow struct{ ptr *TestFlow }

func (n TestFlow_Flow) GetType() string      { return TestFlow_Type }
func (n TestFlow_Flow) GetLede() string      { return "flow" }
func (n TestFlow_Flow) GetFlow() interface{} { return n.ptr }
func (n TestFlow_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*TestFlow); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func TestFlow_Optional_Marshal(m jsn.Marshaler, pv **TestFlow) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = TestFlow_Marshal(m, *pv)
	} else if !enc {
		var v TestFlow
		if err = TestFlow_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func TestFlow_Marshal(m jsn.Marshaler, val *TestFlow) (err error) {
	if err = m.MarshalBlock(TestFlow_Flow{val}); err == nil {
		e0 := m.MarshalKey("slot", TestFlow_Field_Slot)
		if e0 == nil {
			e0 = TestSlot_Optional_Marshal(m, &val.Slot)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", TestFlow_Field_Slot))
		}
		e1 := m.MarshalKey("txt", TestFlow_Field_Txt)
		if e1 == nil {
			e1 = TestTxt_Optional_Marshal(m, &val.Txt)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", TestFlow_Field_Txt))
		}
		e2 := m.MarshalKey("num", TestFlow_Field_Num)
		if e2 == nil {
			e2 = TestNum_Unboxed_Optional_Marshal(m, &val.Num)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", TestFlow_Field_Num))
		}
		e3 := m.MarshalKey("bool", TestFlow_Field_Bool)
		if e3 == nil {
			e3 = TestBool_Optional_Marshal(m, &val.Bool)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", TestFlow_Field_Bool))
		}
		e4 := m.MarshalKey("swap", TestFlow_Field_Swap)
		if e4 == nil {
			e4 = TestSwap_Optional_Marshal(m, &val.Swap)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", TestFlow_Field_Swap))
		}
		e5 := m.MarshalKey("slots", TestFlow_Field_Slots)
		if e5 == nil {
			e5 = TestSlot_Optional_Repeats_Marshal(m, &val.Slots)
		}
		if e5 != nil && e5 != jsn.Missing {
			m.Error(errutil.New(e5, "in flow at", TestFlow_Field_Slots))
		}
		m.EndBlock()
	}
	return
}

// TestNum requires a string.
type TestNum struct {
	Num float64
}

func (*TestNum) Compose() composer.Spec {
	return composer.Spec{
		Name: TestNum_Type,
		Uses: composer.Type_Num,
	}
}

const TestNum_Type = "test_num"

func (op *TestNum) Marshal(m jsn.Marshaler) error {
	return TestNum_Marshal(m, op)
}

type TestNum_Unboxed_Slice []float64

func (op *TestNum_Unboxed_Slice) GetType() string { return TestNum_Type }

func (op *TestNum_Unboxed_Slice) Marshal(m jsn.Marshaler) error {
	return TestNum_Unboxed_Repeats_Marshal(m, (*[]float64)(op))
}

func (op *TestNum_Unboxed_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestNum_Unboxed_Slice) SetSize(cnt int) {
	var els []float64
	if cnt >= 0 {
		els = make(TestNum_Unboxed_Slice, cnt)
	}
	(*op) = els
}

func (op *TestNum_Unboxed_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestNum_Unboxed_Marshal(m, &(*op)[i])
}

func TestNum_Unboxed_Repeats_Marshal(m jsn.Marshaler, vals *[]float64) error {
	return jsn.RepeatBlock(m, (*TestNum_Unboxed_Slice)(vals))
}

func TestNum_Unboxed_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]float64) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = TestNum_Unboxed_Repeats_Marshal(m, pv)
	}
	return
}

func TestNum_Unboxed_Optional_Marshal(m jsn.Marshaler, val *float64) (err error) {
	var zero float64
	if enc := m.IsEncoding(); !enc || *val != zero {
		err = TestNum_Unboxed_Marshal(m, val)
	}
	return
}

func TestNum_Unboxed_Marshal(m jsn.Marshaler, val *float64) error {
	return m.MarshalValue(TestNum_Type, jsn.BoxFloat64(val))
}

func TestNum_Optional_Marshal(m jsn.Marshaler, val *TestNum) (err error) {
	var zero TestNum
	if enc := m.IsEncoding(); !enc || val.Num != zero.Num {
		err = TestNum_Marshal(m, val)
	}
	return
}

func TestNum_Marshal(m jsn.Marshaler, val *TestNum) (err error) {
	return m.MarshalValue(TestNum_Type, &val.Num)
}

type TestNum_Slice []TestNum

func (op *TestNum_Slice) GetType() string { return TestNum_Type }

func (op *TestNum_Slice) Marshal(m jsn.Marshaler) error {
	return TestNum_Repeats_Marshal(m, (*[]TestNum)(op))
}

func (op *TestNum_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestNum_Slice) SetSize(cnt int) {
	var els []TestNum
	if cnt >= 0 {
		els = make(TestNum_Slice, cnt)
	}
	(*op) = els
}

func (op *TestNum_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestNum_Marshal(m, &(*op)[i])
}

func TestNum_Repeats_Marshal(m jsn.Marshaler, vals *[]TestNum) error {
	return jsn.RepeatBlock(m, (*TestNum_Slice)(vals))
}

func TestNum_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestNum) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = TestNum_Repeats_Marshal(m, pv)
	}
	return
}

const TestSlot_Type = "test_slot"

var TestSlot_Optional_Marshal = TestSlot_Marshal

type TestSlot_Slot struct{ Value *TestSlot }

func (at TestSlot_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at TestSlot_Slot) GetType() string              { return TestSlot_Type }
func (at TestSlot_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at TestSlot_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(TestSlot)
	return
}

func TestSlot_Marshal(m jsn.Marshaler, ptr *TestSlot) (err error) {
	slot := TestSlot_Slot{ptr}
	return slot.Marshal(m)
}

type TestSlot_Slice []TestSlot

func (op *TestSlot_Slice) GetType() string { return TestSlot_Type }

func (op *TestSlot_Slice) Marshal(m jsn.Marshaler) error {
	return TestSlot_Repeats_Marshal(m, (*[]TestSlot)(op))
}

func (op *TestSlot_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestSlot_Slice) SetSize(cnt int) {
	var els []TestSlot
	if cnt >= 0 {
		els = make(TestSlot_Slice, cnt)
	}
	(*op) = els
}

func (op *TestSlot_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestSlot_Marshal(m, &(*op)[i])
}

func TestSlot_Repeats_Marshal(m jsn.Marshaler, vals *[]TestSlot) error {
	return jsn.RepeatBlock(m, (*TestSlot_Slice)(vals))
}

func TestSlot_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestSlot) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = TestSlot_Repeats_Marshal(m, pv)
	}
	return
}

// TestSwap swaps between various options
type TestSwap struct {
	Choice string
	Value  interface{}
}

var TestSwap_Optional_Marshal = TestSwap_Marshal

const TestSwap_A_Opt = "$A"
const TestSwap_B_Opt = "$B"
const TestSwap_C_Opt = "$C"

func (*TestSwap) Compose() composer.Spec {
	return composer.Spec{
		Name: TestSwap_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			TestSwap_A_Opt, TestSwap_B_Opt, TestSwap_C_Opt,
		},
		Swaps: []interface{}{
			(*TestFlow)(nil),
			(*TestSlot)(nil),
			(*TestTxt)(nil),
		},
	}
}

const TestSwap_Type = "test_swap"

func (op *TestSwap) GetType() string { return TestSwap_Type }

func (op *TestSwap) GetSwap() (string, interface{}) {
	return op.Choice, op.Value
}

func (op *TestSwap) SetSwap(c string) (okay bool) {
	switch c {
	case "":
		op.Choice, op.Value = c, nil
		okay = true
	case TestSwap_A_Opt:
		op.Choice, op.Value = c, new(TestFlow)
		okay = true
	case TestSwap_B_Opt:
		op.Choice, op.Value = c, new(TestSlot)
		okay = true
	case TestSwap_C_Opt:
		op.Choice, op.Value = c, new(TestTxt)
		okay = true
	}
	return
}

func (op *TestSwap) Marshal(m jsn.Marshaler) error {
	return TestSwap_Marshal(m, op)
}
func TestSwap_Marshal(m jsn.Marshaler, val *TestSwap) (err error) {
	if err = m.MarshalBlock(val); err == nil {
		if _, ptr := val.GetSwap(); ptr != nil {
			if e := ptr.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}

type TestSwap_Slice []TestSwap

func (op *TestSwap_Slice) GetType() string { return TestSwap_Type }

func (op *TestSwap_Slice) Marshal(m jsn.Marshaler) error {
	return TestSwap_Repeats_Marshal(m, (*[]TestSwap)(op))
}

func (op *TestSwap_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestSwap_Slice) SetSize(cnt int) {
	var els []TestSwap
	if cnt >= 0 {
		els = make(TestSwap_Slice, cnt)
	}
	(*op) = els
}

func (op *TestSwap_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestSwap_Marshal(m, &(*op)[i])
}

func TestSwap_Repeats_Marshal(m jsn.Marshaler, vals *[]TestSwap) error {
	return jsn.RepeatBlock(m, (*TestSwap_Slice)(vals))
}

func TestSwap_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestSwap) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = TestSwap_Repeats_Marshal(m, pv)
	}
	return
}

// TestTxt requires a user-specified string.
type TestTxt struct {
	Str string
}

func (op *TestTxt) String() string {
	return op.Str
}

func (*TestTxt) Compose() composer.Spec {
	return composer.Spec{
		Name:        TestTxt_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const TestTxt_Type = "test_txt"

func (op *TestTxt) Marshal(m jsn.Marshaler) error {
	return TestTxt_Marshal(m, op)
}

func TestTxt_Optional_Marshal(m jsn.Marshaler, val *TestTxt) (err error) {
	var zero TestTxt
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestTxt_Marshal(m, val)
	}
	return
}

func TestTxt_Marshal(m jsn.Marshaler, val *TestTxt) (err error) {
	return m.MarshalValue(TestTxt_Type, &val.Str)
}

type TestTxt_Slice []TestTxt

func (op *TestTxt_Slice) GetType() string { return TestTxt_Type }

func (op *TestTxt_Slice) Marshal(m jsn.Marshaler) error {
	return TestTxt_Repeats_Marshal(m, (*[]TestTxt)(op))
}

func (op *TestTxt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestTxt_Slice) SetSize(cnt int) {
	var els []TestTxt
	if cnt >= 0 {
		els = make(TestTxt_Slice, cnt)
	}
	(*op) = els
}

func (op *TestTxt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestTxt_Marshal(m, &(*op)[i])
}

func TestTxt_Repeats_Marshal(m jsn.Marshaler, vals *[]TestTxt) error {
	return jsn.RepeatBlock(m, (*TestTxt_Slice)(vals))
}

func TestTxt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestTxt) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = TestTxt_Repeats_Marshal(m, pv)
	}
	return
}

var Slots = []interface{}{
	(*TestSlot)(nil),
}

var Slats = []composer.Composer{
	(*TestBool)(nil),
	(*TestFlow)(nil),
	(*TestNum)(nil),
	(*TestSwap)(nil),
	(*TestTxt)(nil),
}

var Signatures = map[uint64]interface{}{
	5337047762531013063:  (*TestFlow)(nil), /* Flow bool:swap a: */
	173907217500496038:   (*TestFlow)(nil), /* Flow bool:swap a:slots: */
	5338021929833418784:  (*TestFlow)(nil), /* Flow bool:swap b: */
	17774439874725826645: (*TestFlow)(nil), /* Flow bool:swap b:slots: */
	5339018087368388725:  (*TestFlow)(nil), /* Flow bool:swap c: */
	13993954442636639556: (*TestFlow)(nil), /* Flow bool:swap c:slots: */
	17459444998408277825: (*TestFlow)(nil), /* Flow num:bool:swap a: */
	14647405343768426120: (*TestFlow)(nil), /* Flow num:bool:swap a:slots: */
	17456487312128957910: (*TestFlow)(nil), /* Flow num:bool:swap b: */
	1903455566071210763:  (*TestFlow)(nil), /* Flow num:bool:swap b:slots: */
	17457474673570902163: (*TestFlow)(nil), /* Flow num:bool:swap c: */
	18059206813038075706: (*TestFlow)(nil), /* Flow num:bool:swap c:slots: */
	4666675808510842369:  (*TestFlow)(nil), /* Flow num:swap a: */
	16427114558833338056: (*TestFlow)(nil), /* Flow num:swap a:slots: */
	4663718122231522454:  (*TestFlow)(nil), /* Flow num:swap b: */
	3438281551349410379:  (*TestFlow)(nil), /* Flow num:swap b:slots: */
	4664705483673466707:  (*TestFlow)(nil), /* Flow num:swap c: */
	14846854600902914938: (*TestFlow)(nil), /* Flow num:swap c:slots: */
	11377739199057956195: (*TestFlow)(nil), /* Flow slot:bool:swap a: */
	4658225592716078922:  (*TestFlow)(nil), /* Flow slot:bool:swap a:slots: */
	11378730958546413292: (*TestFlow)(nil), /* Flow slot:bool:swap b: */
	4600549086376030505:  (*TestFlow)(nil), /* Flow slot:bool:swap b:slots: */
	11379709523895331857: (*TestFlow)(nil), /* Flow slot:bool:swap c: */
	8879769277624914776:  (*TestFlow)(nil), /* Flow slot:bool:swap c:slots: */
	2223088452677130245:  (*TestFlow)(nil), /* Flow slot:num:bool:swap a: */
	9083701904834269716:  (*TestFlow)(nil), /* Flow slot:num:bool:swap a:slots: */
	2220271503886221338:  (*TestFlow)(nil), /* Flow slot:num:bool:swap b: */
	14165450989025931767: (*TestFlow)(nil), /* Flow slot:num:bool:swap b:slots: */
	2221118127839754583:  (*TestFlow)(nil), /* Flow slot:num:bool:swap c: */
	2873696889990895094:  (*TestFlow)(nil), /* Flow slot:num:bool:swap c:slots: */
	15358787804422758677: (*TestFlow)(nil), /* Flow slot:num:swap a: */
	3990079510368579812:  (*TestFlow)(nil), /* Flow slot:num:swap a:slots: */
	15355970855631849770: (*TestFlow)(nil), /* Flow slot:num:swap b: */
	3227047420855120839:  (*TestFlow)(nil), /* Flow slot:num:swap b:slots: */
	15356958217073794023: (*TestFlow)(nil), /* Flow slot:num:swap c: */
	15964700649333640774: (*TestFlow)(nil), /* Flow slot:num:swap c:slots: */
	473288575672775711:   (*TestFlow)(nil), /* Flow slot:swap a: */
	5352266987280328366:  (*TestFlow)(nil), /* Flow slot:swap a:slots: */
	474262742975181432:   (*TestFlow)(nil), /* Flow slot:swap b: */
	6977705303858443549:  (*TestFlow)(nil), /* Flow slot:swap b:slots: */
	475258900510151373:   (*TestFlow)(nil), /* Flow slot:swap c: */
	17351518409012557612: (*TestFlow)(nil), /* Flow slot:swap c:slots: */
	6319745570155300781:  (*TestFlow)(nil), /* Flow slot:txt:bool:swap a: */
	15532303502597138316: (*TestFlow)(nil), /* Flow slot:txt:bool:swap a:slots: */
	6316928621364391874:  (*TestFlow)(nil), /* Flow slot:txt:bool:swap b: */
	5932864323383072431:  (*TestFlow)(nil), /* Flow slot:txt:bool:swap b:slots: */
	6317775245317925119:  (*TestFlow)(nil), /* Flow slot:txt:bool:swap c: */
	16987875464862798990: (*TestFlow)(nil), /* Flow slot:txt:bool:swap c:slots: */
	15692898581799579543: (*TestFlow)(nil), /* Flow slot:txt:num:bool:swap a: */
	4113536089123331766:  (*TestFlow)(nil), /* Flow slot:txt:num:bool:swap a:slots: */
	15693872749101985264: (*TestFlow)(nil), /* Flow slot:txt:num:bool:swap b: */
	7990918451189932581:  (*TestFlow)(nil), /* Flow slot:txt:num:bool:swap b:slots: */
	15694868906636955205: (*TestFlow)(nil), /* Flow slot:txt:num:bool:swap c: */
	17933442576771064276: (*TestFlow)(nil), /* Flow slot:txt:num:bool:swap c:slots: */
	10797567927238540899: (*TestFlow)(nil), /* Flow slot:txt:num:swap a: */
	18088294895293012042: (*TestFlow)(nil), /* Flow slot:txt:num:swap a:slots: */
	10798559686726997996: (*TestFlow)(nil), /* Flow slot:txt:num:swap b: */
	18030618388952963625: (*TestFlow)(nil), /* Flow slot:txt:num:swap b:slots: */
	10799538252075916561: (*TestFlow)(nil), /* Flow slot:txt:num:swap c: */
	3863094506492296280:  (*TestFlow)(nil), /* Flow slot:txt:num:swap c:slots: */
	12888316790172233453: (*TestFlow)(nil), /* Flow slot:txt:swap a: */
	13143049727272335436: (*TestFlow)(nil), /* Flow slot:txt:swap a:slots: */
	12885499841381324546: (*TestFlow)(nil), /* Flow slot:txt:swap b: */
	8151749273386767471:  (*TestFlow)(nil), /* Flow slot:txt:swap b:slots: */
	12886346465334857791: (*TestFlow)(nil), /* Flow slot:txt:swap c: */
	7378328281120740942:  (*TestFlow)(nil), /* Flow slot:txt:swap c:slots: */
	11197575529385158675: (*TestFlow)(nil), /* Flow swap a: */
	5941332621307640506:  (*TestFlow)(nil), /* Flow swap a:slots: */
	11198567288873615772: (*TestFlow)(nil), /* Flow swap b: */
	15070663784246521433: (*TestFlow)(nil), /* Flow swap b:slots: */
	11199545854222534337: (*TestFlow)(nil), /* Flow swap c: */
	2529531152037990920:  (*TestFlow)(nil), /* Flow swap c:slots: */
	911670878832212209:   (*TestFlow)(nil), /* Flow txt:bool:swap a: */
	10809752327504430648: (*TestFlow)(nil), /* Flow txt:bool:swap a:slots: */
	908853930041303302:   (*TestFlow)(nil), /* Flow txt:bool:swap b: */
	2406137992719069243:  (*TestFlow)(nil), /* Flow txt:bool:swap b:slots: */
	909841291483247555:   (*TestFlow)(nil), /* Flow txt:bool:swap c: */
	16912195045548080810: (*TestFlow)(nil), /* Flow txt:bool:swap c:slots: */
	17003454676585106931: (*TestFlow)(nil), /* Flow txt:num:bool:swap a: */
	7213260971153186202:  (*TestFlow)(nil), /* Flow txt:num:bool:swap a:slots: */
	17004446436073564028: (*TestFlow)(nil), /* Flow txt:num:bool:swap b: */
	10358941174051435065: (*TestFlow)(nil), /* Flow txt:num:bool:swap b:slots: */
	17005425001422482593: (*TestFlow)(nil), /* Flow txt:num:bool:swap c: */
	14638302102788730344: (*TestFlow)(nil), /* Flow txt:num:bool:swap c:slots: */
	6470611964404050607:  (*TestFlow)(nil), /* Flow txt:num:swap a: */
	3446557831411620030:  (*TestFlow)(nil), /* Flow txt:num:swap a:slots: */
	6471586131706456328:  (*TestFlow)(nil), /* Flow txt:num:swap b: */
	7009547525656593965:  (*TestFlow)(nil), /* Flow txt:num:swap b:slots: */
	6472582289241426269:  (*TestFlow)(nil), /* Flow txt:num:swap c: */
	6546518029905514300:  (*TestFlow)(nil), /* Flow txt:num:swap c:slots: */
	1999357900407268657:  (*TestFlow)(nil), /* Flow txt:swap a: */
	10029138454270883832: (*TestFlow)(nil), /* Flow txt:swap a:slots: */
	1996540951616359750:  (*TestFlow)(nil), /* Flow txt:swap b: */
	9480308822076592635:  (*TestFlow)(nil), /* Flow txt:swap b:slots: */
	1997528313058304003:  (*TestFlow)(nil), /* Flow txt:swap c: */
	10392813442060614250: (*TestFlow)(nil), /* Flow txt:swap c:slots: */
	7140800509473528945:  (*TestSwap)(nil), /* TestSwap a: */
	7137983560682620038:  (*TestSwap)(nil), /* TestSwap b: */
	7138970922124564291:  (*TestSwap)(nil), /* TestSwap c: */
}
