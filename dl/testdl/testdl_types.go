// testdl
package testdl

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// test_slot, a type of slot.
var Zt_TestSlot = typeinfo.Slot{
	Name: "test_slot",
}

// Holds a single slot.
type TestSlot_Slot struct{ Value TestSlot }

// Implements [typeinfo.Instance] for a single slot.
func (*TestSlot_Slot) TypeInfo() typeinfo.T {
	return &Zt_TestSlot
}

// Holds a slice of slots.
type TestSlot_Slots []TestSlot

// Implements [typeinfo.Instance] for a slice of slots.
func (*TestSlot_Slots) TypeInfo() typeinfo.T {
	return &Zt_TestSlot
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *TestSlot_Slots) Repeats() bool {
	return len(*op) > 0
}

type TestEmbed struct {
	TestFlow TestFlow
	Markup   map[string]any
}

// test_embed, a type of flow.
var Zt_TestEmbed typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TestEmbed) TypeInfo() typeinfo.T {
	return &Zt_TestEmbed
}

// Implements [typeinfo.Markup]
func (op *TestEmbed) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ TestSlot = (*TestEmbed)(nil)

// Holds a slice of type TestEmbed.
type TestEmbed_Slice []TestEmbed

// Implements [typeinfo.Instance] for a slice of TestEmbed.
func (*TestEmbed_Slice) TypeInfo() typeinfo.T {
	return &Zt_TestEmbed
}

// Implements [typeinfo.Repeats] for a slice of TestEmbed.
func (op *TestEmbed_Slice) Repeats() bool {
	return len(*op) > 0
}

type TestFlow struct {
	Slot   TestSlot
	Txt    string
	Num    float64
	Bool   TestBool
	Slots  []TestSlot
	Markup map[string]any
}

// test_flow, a type of flow.
var Zt_TestFlow typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TestFlow) TypeInfo() typeinfo.T {
	return &Zt_TestFlow
}

// Implements [typeinfo.Markup]
func (op *TestFlow) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ TestSlot = (*TestFlow)(nil)

// Holds a slice of type TestFlow.
type TestFlow_Slice []TestFlow

// Implements [typeinfo.Instance] for a slice of TestFlow.
func (*TestFlow_Slice) TypeInfo() typeinfo.T {
	return &Zt_TestFlow
}

// Implements [typeinfo.Repeats] for a slice of TestFlow.
func (op *TestFlow_Slice) Repeats() bool {
	return len(*op) > 0
}

// TestBool, a type of str enum.
type TestBool int

// The enumerated values of TestBool.
const (
	C_TestBool_True TestBool = iota
	C_TestBool_False
)

func MakeTestBool(str string) (ret TestBool, okay bool) {
	if i := Zt_TestBool.FindOption(str); i >= 0 {
		ret, okay = TestBool(i), true
	}
	return
}

func (op TestBool) String() (ret string) {
	if i, opts := int(op), Zt_TestBool.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid TestBool(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// test_bool, a type of str enum.
var Zt_TestBool = typeinfo.Str{
	Name: "test_bool",
	Options: []string{
		"true",
		"false",
	},
}

// TestStr, a type of str enum.
type TestStr int

// The enumerated values of TestStr.
const (
	C_TestStr_One TestStr = iota
	C_TestStr_Other
	C_TestStr_Option
)

func MakeTestStr(str string) (ret TestStr, okay bool) {
	if i := Zt_TestStr.FindOption(str); i >= 0 {
		ret, okay = TestStr(i), true
	}
	return
}

func (op TestStr) String() (ret string) {
	if i, opts := int(op), Zt_TestStr.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid TestStr(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// test_str, a type of str enum.
var Zt_TestStr = typeinfo.Str{
	Name: "test_str",
	Options: []string{
		"one",
		"other",
		"option",
	},
}

// TestTxt, a type of str.
var Zt_TestTxt = typeinfo.Str{
	Name: "test_txt",
}

// TestNum, a type of num.
var Zt_TestNum = typeinfo.Num{
	Name: "test_num",
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_TestEmbed = typeinfo.Flow{
		Name: "test_embed",
		Lede: "embed",
		Terms: []typeinfo.Term{{
			Name:  "test_flow",
			Label: "test_flow",
			Type:  &Zt_TestFlow,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_TestSlot,
		},
	}
	Zt_TestFlow = typeinfo.Flow{
		Name: "test_flow",
		Lede: "flow",
		Terms: []typeinfo.Term{{
			Name:     "slot",
			Label:    "slot",
			Optional: true,
			Type:     &Zt_TestSlot,
		}, {
			Name:     "txt",
			Label:    "txt",
			Optional: true,
			Type:     &Zt_TestTxt,
		}, {
			Name:     "num",
			Label:    "num",
			Optional: true,
			Type:     &Zt_TestNum,
		}, {
			Name:     "bool",
			Label:    "bool",
			Optional: true,
			Type:     &Zt_TestBool,
		}, {
			Name:     "slots",
			Label:    "slots",
			Optional: true,
			Repeats:  true,
			Type:     &Zt_TestSlot,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_TestSlot,
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "testdl",
	Comment: []string{
		"testdl",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Str:        z_str_list,
	Num:        z_num_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_TestSlot,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_TestEmbed,
	&Zt_TestFlow,
}

// A list of all strs in this this package.
var z_str_list = []*typeinfo.Str{
	&Zt_TestBool,
	&Zt_TestStr,
	&Zt_TestTxt,
}

// A list of all nums in this this package.
var z_num_list = []*typeinfo.Num{
	&Zt_TestNum,
}

// gob like registration
func Register(reg func(any)) {
	reg(TestEmbed{})
	reg(TestFlow{})
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	4674877661722404900:  (*TestEmbed)(nil), /* test_slot=Embed testFlow: */
	6035317458491358757:  (*TestFlow)(nil),  /* test_slot=Flow */
	3180197217674355987:  (*TestFlow)(nil),  /* test_slot=Flow bool: */
	7800787521023201210:  (*TestFlow)(nil),  /* test_slot=Flow bool:slots: */
	1352478831057267749:  (*TestFlow)(nil),  /* test_slot=Flow num: */
	5418383768131476581:  (*TestFlow)(nil),  /* test_slot=Flow num:bool: */
	7291931087597771892:  (*TestFlow)(nil),  /* test_slot=Flow num:bool:slots: */
	6297018247826912692:  (*TestFlow)(nil),  /* test_slot=Flow num:slots: */
	12951016320825491083: (*TestFlow)(nil),  /* test_slot=Flow slot: */
	9305516548358700591:  (*TestFlow)(nil),  /* test_slot=Flow slot:bool: */
	5145100175048896574:  (*TestFlow)(nil),  /* test_slot=Flow slot:bool:slots: */
	17015981910898011913: (*TestFlow)(nil),  /* test_slot=Flow slot:num: */
	1311123221862663321:  (*TestFlow)(nil),  /* test_slot=Flow slot:num:bool: */
	8394834950289276944:  (*TestFlow)(nil),  /* test_slot=Flow slot:num:bool:slots: */
	7555590340079896384:  (*TestFlow)(nil),  /* test_slot=Flow slot:num:slots: */
	12633006641875816738: (*TestFlow)(nil),  /* test_slot=Flow slot:slots: */
	15158636115026315841: (*TestFlow)(nil),  /* test_slot=Flow slot:txt: */
	14129076392559381825: (*TestFlow)(nil),  /* test_slot=Flow slot:txt:bool: */
	12962075234394227848: (*TestFlow)(nil),  /* test_slot=Flow slot:txt:bool:slots: */
	12920314065270770223: (*TestFlow)(nil),  /* test_slot=Flow slot:txt:num: */
	11065472324065071427: (*TestFlow)(nil),  /* test_slot=Flow slot:txt:num:bool: */
	1751948850686087210:  (*TestFlow)(nil),  /* test_slot=Flow slot:txt:num:bool:slots: */
	1821468357792341054:  (*TestFlow)(nil),  /* test_slot=Flow slot:txt:num:slots: */
	4820696260179335560:  (*TestFlow)(nil),  /* test_slot=Flow slot:txt:slots: */
	9022305410891129358:  (*TestFlow)(nil),  /* test_slot=Flow slots: */
	13864086419337359925: (*TestFlow)(nil),  /* test_slot=Flow txt: */
	6197717516868531189:  (*TestFlow)(nil),  /* test_slot=Flow txt:bool: */
	12039181645319947460: (*TestFlow)(nil),  /* test_slot=Flow txt:bool:slots: */
	3282522180982023931:  (*TestFlow)(nil),  /* test_slot=Flow txt:num: */
	14112799375577386271: (*TestFlow)(nil),  /* test_slot=Flow txt:num:bool: */
	15951227895458002862: (*TestFlow)(nil),  /* test_slot=Flow txt:num:bool:slots: */
	1596042300229332818:  (*TestFlow)(nil),  /* test_slot=Flow txt:num:slots: */
	445595344264097156:   (*TestFlow)(nil),  /* test_slot=Flow txt:slots: */
}
