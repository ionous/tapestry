// Code generated by "makeops"; edit at your own risk.
package testdl

import (
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/jsn"
	"github.com/ionous/errutil"
)

// TestBool requires a predefined string.
type TestBool struct {
	Str string
}

func (op *TestBool) String() string {
	return op.Str
}

const TestBool_True = "$TRUE"
const TestBool_False = "$FALSE"

func (*TestBool) Compose() composer.Spec {
	return composer.Spec{
		Name: TestBool_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			TestBool_True, TestBool_False,
		},
		Strings: []string{
			"true", "false",
		},
	}
}

const TestBool_Type = "test_bool"

func (op *TestBool) Marshal(m jsn.Marshaler) error {
	return TestBool_Marshal(m, op)
}

func TestBool_Optional_Marshal(m jsn.Marshaler, val *TestBool) (err error) {
	var zero TestBool
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestBool_Marshal(m, val)
	}
	return
}

func TestBool_Marshal(m jsn.Marshaler, val *TestBool) (err error) {
	return m.MarshalValue(TestBool_Type, jsn.MakeEnum(val, &val.Str))
}

type TestBool_Slice []TestBool

func (op *TestBool_Slice) GetType() string { return TestBool_Type }

func (op *TestBool_Slice) Marshal(m jsn.Marshaler) error {
	return TestBool_Repeats_Marshal(m, (*[]TestBool)(op))
}

func (op *TestBool_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestBool_Slice) SetSize(cnt int) {
	var els []TestBool
	if cnt >= 0 {
		els = make(TestBool_Slice, cnt)
	}
	(*op) = els
}

func (op *TestBool_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestBool_Marshal(m, &(*op)[i])
}

func TestBool_Repeats_Marshal(m jsn.Marshaler, vals *[]TestBool) error {
	return jsn.RepeatBlock(m, (*TestBool_Slice)(vals))
}

func TestBool_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestBool) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestBool_Repeats_Marshal(m, pv)
	}
	return
}

// TestEmbed
type TestEmbed struct {
	TestFlow    TestFlow `if:"label=test_flow"`
	UserComment string
}

// User implemented slots:
var _ TestSlot = (*TestEmbed)(nil)

func (*TestEmbed) Compose() composer.Spec {
	return composer.Spec{
		Name: TestEmbed_Type,
		Uses: composer.Type_Flow,
		Lede: "embed",
	}
}

const TestEmbed_Type = "test_embed"
const TestEmbed_Field_TestFlow = "$TEST_FLOW"

func (op *TestEmbed) Marshal(m jsn.Marshaler) error {
	return TestEmbed_Marshal(m, op)
}

type TestEmbed_Slice []TestEmbed

func (op *TestEmbed_Slice) GetType() string { return TestEmbed_Type }

func (op *TestEmbed_Slice) Marshal(m jsn.Marshaler) error {
	return TestEmbed_Repeats_Marshal(m, (*[]TestEmbed)(op))
}

func (op *TestEmbed_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestEmbed_Slice) SetSize(cnt int) {
	var els []TestEmbed
	if cnt >= 0 {
		els = make(TestEmbed_Slice, cnt)
	}
	(*op) = els
}

func (op *TestEmbed_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestEmbed_Marshal(m, &(*op)[i])
}

func TestEmbed_Repeats_Marshal(m jsn.Marshaler, vals *[]TestEmbed) error {
	return jsn.RepeatBlock(m, (*TestEmbed_Slice)(vals))
}

func TestEmbed_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestEmbed) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestEmbed_Repeats_Marshal(m, pv)
	}
	return
}

type TestEmbed_Flow struct{ ptr *TestEmbed }

func (n TestEmbed_Flow) GetType() string      { return TestEmbed_Type }
func (n TestEmbed_Flow) GetLede() string      { return "embed" }
func (n TestEmbed_Flow) GetFlow() interface{} { return n.ptr }
func (n TestEmbed_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*TestEmbed); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func TestEmbed_Optional_Marshal(m jsn.Marshaler, pv **TestEmbed) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = TestEmbed_Marshal(m, *pv)
	} else if !enc {
		var v TestEmbed
		if err = TestEmbed_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func TestEmbed_Marshal(m jsn.Marshaler, val *TestEmbed) (err error) {
	m.SetComment(&val.UserComment)
	if err = m.MarshalBlock(TestEmbed_Flow{val}); err == nil {
		e0 := m.MarshalKey("test_flow", TestEmbed_Field_TestFlow)
		if e0 == nil {
			e0 = TestFlow_Marshal(m, &val.TestFlow)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", TestEmbed_Field_TestFlow))
		}
		m.EndBlock()
	}
	return
}

// TestFlow
type TestFlow struct {
	Slot        TestSlot   `if:"label=slot,optional"`
	Txt         TestTxt    `if:"label=txt,optional"`
	Num         float64    `if:"label=num,optional,type=test_num"`
	Bool        TestBool   `if:"label=bool,optional"`
	Swap        TestSwap   `if:"label=swap,optional"`
	Slots       []TestSlot `if:"label=slots,optional"`
	UserComment string
}

// User implemented slots:
var _ TestSlot = (*TestFlow)(nil)

func (*TestFlow) Compose() composer.Spec {
	return composer.Spec{
		Name: TestFlow_Type,
		Uses: composer.Type_Flow,
		Lede: "flow",
	}
}

const TestFlow_Type = "test_flow"
const TestFlow_Field_Slot = "$SLOT"
const TestFlow_Field_Txt = "$TXT"
const TestFlow_Field_Num = "$NUM"
const TestFlow_Field_Bool = "$BOOL"
const TestFlow_Field_Swap = "$SWAP"
const TestFlow_Field_Slots = "$SLOTS"

func (op *TestFlow) Marshal(m jsn.Marshaler) error {
	return TestFlow_Marshal(m, op)
}

type TestFlow_Slice []TestFlow

func (op *TestFlow_Slice) GetType() string { return TestFlow_Type }

func (op *TestFlow_Slice) Marshal(m jsn.Marshaler) error {
	return TestFlow_Repeats_Marshal(m, (*[]TestFlow)(op))
}

func (op *TestFlow_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestFlow_Slice) SetSize(cnt int) {
	var els []TestFlow
	if cnt >= 0 {
		els = make(TestFlow_Slice, cnt)
	}
	(*op) = els
}

func (op *TestFlow_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestFlow_Marshal(m, &(*op)[i])
}

func TestFlow_Repeats_Marshal(m jsn.Marshaler, vals *[]TestFlow) error {
	return jsn.RepeatBlock(m, (*TestFlow_Slice)(vals))
}

func TestFlow_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestFlow) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestFlow_Repeats_Marshal(m, pv)
	}
	return
}

type TestFlow_Flow struct{ ptr *TestFlow }

func (n TestFlow_Flow) GetType() string      { return TestFlow_Type }
func (n TestFlow_Flow) GetLede() string      { return "flow" }
func (n TestFlow_Flow) GetFlow() interface{} { return n.ptr }
func (n TestFlow_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*TestFlow); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func TestFlow_Optional_Marshal(m jsn.Marshaler, pv **TestFlow) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = TestFlow_Marshal(m, *pv)
	} else if !enc {
		var v TestFlow
		if err = TestFlow_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func TestFlow_Marshal(m jsn.Marshaler, val *TestFlow) (err error) {
	m.SetComment(&val.UserComment)
	if err = m.MarshalBlock(TestFlow_Flow{val}); err == nil {
		e0 := m.MarshalKey("slot", TestFlow_Field_Slot)
		if e0 == nil {
			e0 = TestSlot_Optional_Marshal(m, &val.Slot)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", TestFlow_Field_Slot))
		}
		e1 := m.MarshalKey("txt", TestFlow_Field_Txt)
		if e1 == nil {
			e1 = TestTxt_Optional_Marshal(m, &val.Txt)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", TestFlow_Field_Txt))
		}
		e2 := m.MarshalKey("num", TestFlow_Field_Num)
		if e2 == nil {
			e2 = TestNum_Unboxed_Optional_Marshal(m, &val.Num)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", TestFlow_Field_Num))
		}
		e3 := m.MarshalKey("bool", TestFlow_Field_Bool)
		if e3 == nil {
			e3 = TestBool_Optional_Marshal(m, &val.Bool)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", TestFlow_Field_Bool))
		}
		e4 := m.MarshalKey("swap", TestFlow_Field_Swap)
		if e4 == nil {
			e4 = TestSwap_Optional_Marshal(m, &val.Swap)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", TestFlow_Field_Swap))
		}
		e5 := m.MarshalKey("slots", TestFlow_Field_Slots)
		if e5 == nil {
			e5 = TestSlot_Optional_Repeats_Marshal(m, &val.Slots)
		}
		if e5 != nil && e5 != jsn.Missing {
			m.Error(errutil.New(e5, "in flow at", TestFlow_Field_Slots))
		}
		m.EndBlock()
	}
	return
}

// TestNum requires a user-specified number.
type TestNum struct {
	Num float64
}

func (*TestNum) Compose() composer.Spec {
	return composer.Spec{
		Name: TestNum_Type,
		Uses: composer.Type_Num,
	}
}

const TestNum_Type = "test_num"

func (op *TestNum) Marshal(m jsn.Marshaler) error {
	return TestNum_Marshal(m, op)
}

type TestNum_Unboxed_Slice []float64

func (op *TestNum_Unboxed_Slice) GetType() string { return TestNum_Type }

func (op *TestNum_Unboxed_Slice) Marshal(m jsn.Marshaler) error {
	return TestNum_Unboxed_Repeats_Marshal(m, (*[]float64)(op))
}

func (op *TestNum_Unboxed_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestNum_Unboxed_Slice) SetSize(cnt int) {
	var els []float64
	if cnt >= 0 {
		els = make(TestNum_Unboxed_Slice, cnt)
	}
	(*op) = els
}

func (op *TestNum_Unboxed_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestNum_Unboxed_Marshal(m, &(*op)[i])
}

func TestNum_Unboxed_Repeats_Marshal(m jsn.Marshaler, vals *[]float64) error {
	return jsn.RepeatBlock(m, (*TestNum_Unboxed_Slice)(vals))
}

func TestNum_Unboxed_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]float64) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestNum_Unboxed_Repeats_Marshal(m, pv)
	}
	return
}

func TestNum_Unboxed_Optional_Marshal(m jsn.Marshaler, val *float64) (err error) {
	var zero float64
	if enc := m.IsEncoding(); !enc || *val != zero {
		err = TestNum_Unboxed_Marshal(m, val)
	}
	return
}

func TestNum_Unboxed_Marshal(m jsn.Marshaler, val *float64) error {
	return m.MarshalValue(TestNum_Type, jsn.BoxFloat64(val))
}

func TestNum_Optional_Marshal(m jsn.Marshaler, val *TestNum) (err error) {
	var zero TestNum
	if enc := m.IsEncoding(); !enc || val.Num != zero.Num {
		err = TestNum_Marshal(m, val)
	}
	return
}

func TestNum_Marshal(m jsn.Marshaler, val *TestNum) (err error) {
	return m.MarshalValue(TestNum_Type, &val.Num)
}

type TestNum_Slice []TestNum

func (op *TestNum_Slice) GetType() string { return TestNum_Type }

func (op *TestNum_Slice) Marshal(m jsn.Marshaler) error {
	return TestNum_Repeats_Marshal(m, (*[]TestNum)(op))
}

func (op *TestNum_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestNum_Slice) SetSize(cnt int) {
	var els []TestNum
	if cnt >= 0 {
		els = make(TestNum_Slice, cnt)
	}
	(*op) = els
}

func (op *TestNum_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestNum_Marshal(m, &(*op)[i])
}

func TestNum_Repeats_Marshal(m jsn.Marshaler, vals *[]TestNum) error {
	return jsn.RepeatBlock(m, (*TestNum_Slice)(vals))
}

func TestNum_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestNum) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestNum_Repeats_Marshal(m, pv)
	}
	return
}

const TestSlot_Type = "test_slot"

var TestSlot_Optional_Marshal = TestSlot_Marshal

type TestSlot_Slot struct{ Value *TestSlot }

func (at TestSlot_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at TestSlot_Slot) GetType() string              { return TestSlot_Type }
func (at TestSlot_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at TestSlot_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(TestSlot)
	return
}

func TestSlot_Marshal(m jsn.Marshaler, ptr *TestSlot) (err error) {
	slot := TestSlot_Slot{ptr}
	return slot.Marshal(m)
}

type TestSlot_Slice []TestSlot

func (op *TestSlot_Slice) GetType() string { return TestSlot_Type }

func (op *TestSlot_Slice) Marshal(m jsn.Marshaler) error {
	return TestSlot_Repeats_Marshal(m, (*[]TestSlot)(op))
}

func (op *TestSlot_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestSlot_Slice) SetSize(cnt int) {
	var els []TestSlot
	if cnt >= 0 {
		els = make(TestSlot_Slice, cnt)
	}
	(*op) = els
}

func (op *TestSlot_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestSlot_Marshal(m, &(*op)[i])
}

func TestSlot_Repeats_Marshal(m jsn.Marshaler, vals *[]TestSlot) error {
	return jsn.RepeatBlock(m, (*TestSlot_Slice)(vals))
}

func TestSlot_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestSlot) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestSlot_Repeats_Marshal(m, pv)
	}
	return
}

// TestStr requires a predefined string.
type TestStr struct {
	Str string
}

func (op *TestStr) String() string {
	return op.Str
}

const TestStr_One = "$ONE"
const TestStr_Other = "$OTHER"
const TestStr_Option = "$OPTION"

func (*TestStr) Compose() composer.Spec {
	return composer.Spec{
		Name: TestStr_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			TestStr_One, TestStr_Other, TestStr_Option,
		},
		Strings: []string{
			"one", "other", "option",
		},
	}
}

const TestStr_Type = "test_str"

func (op *TestStr) Marshal(m jsn.Marshaler) error {
	return TestStr_Marshal(m, op)
}

func TestStr_Optional_Marshal(m jsn.Marshaler, val *TestStr) (err error) {
	var zero TestStr
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestStr_Marshal(m, val)
	}
	return
}

func TestStr_Marshal(m jsn.Marshaler, val *TestStr) (err error) {
	return m.MarshalValue(TestStr_Type, jsn.MakeEnum(val, &val.Str))
}

type TestStr_Slice []TestStr

func (op *TestStr_Slice) GetType() string { return TestStr_Type }

func (op *TestStr_Slice) Marshal(m jsn.Marshaler) error {
	return TestStr_Repeats_Marshal(m, (*[]TestStr)(op))
}

func (op *TestStr_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestStr_Slice) SetSize(cnt int) {
	var els []TestStr
	if cnt >= 0 {
		els = make(TestStr_Slice, cnt)
	}
	(*op) = els
}

func (op *TestStr_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestStr_Marshal(m, &(*op)[i])
}

func TestStr_Repeats_Marshal(m jsn.Marshaler, vals *[]TestStr) error {
	return jsn.RepeatBlock(m, (*TestStr_Slice)(vals))
}

func TestStr_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestStr) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestStr_Repeats_Marshal(m, pv)
	}
	return
}

// TestSwap swaps between various options
type TestSwap struct {
	Choice string
	Value  interface{}
}

var TestSwap_Optional_Marshal = TestSwap_Marshal

const TestSwap_A_Opt = "$A"
const TestSwap_B_Opt = "$B"
const TestSwap_C_Opt = "$C"

func (*TestSwap) Compose() composer.Spec {
	return composer.Spec{
		Name: TestSwap_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			TestSwap_A_Opt, TestSwap_B_Opt, TestSwap_C_Opt,
		},
		Swaps: []interface{}{
			(*TestFlow)(nil),
			(*TestSlot)(nil),
			(*TestTxt)(nil),
		},
	}
}

const TestSwap_Type = "test_swap"

func (op *TestSwap) GetType() string { return TestSwap_Type }

func (op *TestSwap) GetSwap() (string, interface{}) {
	return op.Choice, op.Value
}

func (op *TestSwap) SetSwap(c string) (okay bool) {
	switch c {
	case "":
		op.Choice, op.Value = c, nil
		okay = true
	case TestSwap_A_Opt:
		op.Choice, op.Value = c, new(TestFlow)
		okay = true
	case TestSwap_B_Opt:
		op.Choice, op.Value = c, new(TestSlot)
		okay = true
	case TestSwap_C_Opt:
		op.Choice, op.Value = c, new(TestTxt)
		okay = true
	}
	return
}

func (op *TestSwap) Marshal(m jsn.Marshaler) error {
	return TestSwap_Marshal(m, op)
}
func TestSwap_Marshal(m jsn.Marshaler, val *TestSwap) (err error) {
	if err = m.MarshalBlock(val); err == nil {
		if _, ptr := val.GetSwap(); ptr != nil {
			if e := ptr.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}

type TestSwap_Slice []TestSwap

func (op *TestSwap_Slice) GetType() string { return TestSwap_Type }

func (op *TestSwap_Slice) Marshal(m jsn.Marshaler) error {
	return TestSwap_Repeats_Marshal(m, (*[]TestSwap)(op))
}

func (op *TestSwap_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestSwap_Slice) SetSize(cnt int) {
	var els []TestSwap
	if cnt >= 0 {
		els = make(TestSwap_Slice, cnt)
	}
	(*op) = els
}

func (op *TestSwap_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestSwap_Marshal(m, &(*op)[i])
}

func TestSwap_Repeats_Marshal(m jsn.Marshaler, vals *[]TestSwap) error {
	return jsn.RepeatBlock(m, (*TestSwap_Slice)(vals))
}

func TestSwap_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestSwap) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestSwap_Repeats_Marshal(m, pv)
	}
	return
}

// TestTxt requires a user-specified string.
type TestTxt struct {
	Str string
}

func (op *TestTxt) String() string {
	return op.Str
}

func (*TestTxt) Compose() composer.Spec {
	return composer.Spec{
		Name:        TestTxt_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const TestTxt_Type = "test_txt"

func (op *TestTxt) Marshal(m jsn.Marshaler) error {
	return TestTxt_Marshal(m, op)
}

func TestTxt_Optional_Marshal(m jsn.Marshaler, val *TestTxt) (err error) {
	var zero TestTxt
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestTxt_Marshal(m, val)
	}
	return
}

func TestTxt_Marshal(m jsn.Marshaler, val *TestTxt) (err error) {
	return m.MarshalValue(TestTxt_Type, &val.Str)
}

type TestTxt_Slice []TestTxt

func (op *TestTxt_Slice) GetType() string { return TestTxt_Type }

func (op *TestTxt_Slice) Marshal(m jsn.Marshaler) error {
	return TestTxt_Repeats_Marshal(m, (*[]TestTxt)(op))
}

func (op *TestTxt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestTxt_Slice) SetSize(cnt int) {
	var els []TestTxt
	if cnt >= 0 {
		els = make(TestTxt_Slice, cnt)
	}
	(*op) = els
}

func (op *TestTxt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestTxt_Marshal(m, &(*op)[i])
}

func TestTxt_Repeats_Marshal(m jsn.Marshaler, vals *[]TestTxt) error {
	return jsn.RepeatBlock(m, (*TestTxt_Slice)(vals))
}

func TestTxt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestTxt) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestTxt_Repeats_Marshal(m, pv)
	}
	return
}

var Slots = []interface{}{
	(*TestSlot)(nil),
}

var Slats = []composer.Composer{
	(*TestBool)(nil),
	(*TestEmbed)(nil),
	(*TestFlow)(nil),
	(*TestNum)(nil),
	(*TestStr)(nil),
	(*TestSwap)(nil),
	(*TestTxt)(nil),
}

var Signatures = map[uint64]interface{}{
	6779047885654485068:  (*TestEmbed)(nil), /* Embed testFlow:=test_slot */
	3688618323957392439:  (*TestFlow)(nil),  /* Flow bool:swap a:=test_slot */
	9436993074158038710:  (*TestFlow)(nil),  /* Flow bool:swap a:slots:=test_slot */
	5189272866956168184:  (*TestFlow)(nil),  /* Flow bool:swap b:=test_slot */
	8468132404644678141:  (*TestFlow)(nil),  /* Flow bool:swap b:slots:=test_slot */
	16538050737092128733: (*TestFlow)(nil),  /* Flow bool:swap c:=test_slot */
	3224628532457165020:  (*TestFlow)(nil),  /* Flow bool:swap c:slots:=test_slot */
	13372467131933752713: (*TestFlow)(nil),  /* Flow num:bool:swap a:=test_slot */
	15220808006837848608: (*TestFlow)(nil),  /* Flow num:bool:swap a:slots:=test_slot */
	7017578992982000006:  (*TestFlow)(nil),  /* Flow num:bool:swap b:=test_slot */
	15819321462172118747: (*TestFlow)(nil),  /* Flow num:bool:swap b:slots:=test_slot */
	16484181579527507875: (*TestFlow)(nil),  /* Flow num:bool:swap c:=test_slot */
	7477347955562513546:  (*TestFlow)(nil),  /* Flow num:bool:swap c:slots:=test_slot */
	54838208942663369:    (*TestFlow)(nil),  /* Flow num:swap a:=test_slot */
	10248333891342008288: (*TestFlow)(nil),  /* Flow num:swap a:slots:=test_slot */
	1402238046612373958:  (*TestFlow)(nil),  /* Flow num:swap b:=test_slot */
	11780820579200563355: (*TestFlow)(nil),  /* Flow num:swap b:slots:=test_slot */
	9665565189955124451:  (*TestFlow)(nil),  /* Flow num:swap c:=test_slot */
	4811064453254620234:  (*TestFlow)(nil),  /* Flow num:swap c:slots:=test_slot */
	1543212984134619859:  (*TestFlow)(nil),  /* Flow slot:bool:swap a:=test_slot */
	10614308334707840570: (*TestFlow)(nil),  /* Flow slot:bool:swap a:slots:=test_slot */
	5846792428240459972:  (*TestFlow)(nil),  /* Flow slot:bool:swap b:=test_slot */
	9314528121375136849:  (*TestFlow)(nil),  /* Flow slot:bool:swap b:slots:=test_slot */
	7058124099988545977:  (*TestFlow)(nil),  /* Flow slot:bool:swap c:=test_slot */
	2573622781665981008:  (*TestFlow)(nil),  /* Flow slot:bool:swap c:slots:=test_slot */
	17347181744533648141: (*TestFlow)(nil),  /* Flow slot:num:bool:swap a:=test_slot */
	15176357430826535564: (*TestFlow)(nil),  /* Flow slot:num:bool:swap a:slots:=test_slot */
	9932329067659996586:  (*TestFlow)(nil),  /* Flow slot:num:bool:swap b:=test_slot */
	4287903168200072263:  (*TestFlow)(nil),  /* Flow slot:num:bool:swap b:slots:=test_slot */
	1883817729729661543:  (*TestFlow)(nil),  /* Flow slot:num:bool:swap c:=test_slot */
	8111725536738093670:  (*TestFlow)(nil),  /* Flow slot:num:bool:swap c:slots:=test_slot */
	4635694403500335677:  (*TestFlow)(nil),  /* Flow slot:num:swap a:=test_slot */
	14325576302842858940: (*TestFlow)(nil),  /* Flow slot:num:swap a:slots:=test_slot */
	11983764394291658586: (*TestFlow)(nil),  /* Flow slot:num:swap b:=test_slot */
	6041622937830708791:  (*TestFlow)(nil),  /* Flow slot:num:swap b:slots:=test_slot */
	11352050272522730647: (*TestFlow)(nil),  /* Flow slot:num:swap c:=test_slot */
	3979711114908897046:  (*TestFlow)(nil),  /* Flow slot:num:swap c:slots:=test_slot */
	15435809820590180367: (*TestFlow)(nil),  /* Flow slot:swap a:=test_slot */
	5301710390101760702:  (*TestFlow)(nil),  /* Flow slot:swap a:slots:=test_slot */
	4230518693620673200:  (*TestFlow)(nil),  /* Flow slot:swap b:=test_slot */
	6082419732096942149:  (*TestFlow)(nil),  /* Flow slot:swap b:slots:=test_slot */
	1368660875544930453:  (*TestFlow)(nil),  /* Flow slot:swap c:=test_slot */
	536003260384377732:   (*TestFlow)(nil),  /* Flow slot:swap c:slots:=test_slot */
	2721804460038652341:  (*TestFlow)(nil),  /* Flow slot:txt:bool:swap a:=test_slot */
	9799743118466874276:  (*TestFlow)(nil),  /* Flow slot:txt:bool:swap a:slots:=test_slot */
	832453203159819602:   (*TestFlow)(nil),  /* Flow slot:txt:bool:swap b:=test_slot */
	10681972034550345151: (*TestFlow)(nil),  /* Flow slot:txt:bool:swap b:slots:=test_slot */
	12040050381098573615: (*TestFlow)(nil),  /* Flow slot:txt:bool:swap c:=test_slot */
	10544761725646704094: (*TestFlow)(nil),  /* Flow slot:txt:bool:swap c:slots:=test_slot */
	3667305716146626855:  (*TestFlow)(nil),  /* Flow slot:txt:num:bool:swap a:=test_slot */
	15824184759748966054: (*TestFlow)(nil),  /* Flow slot:txt:num:bool:swap a:slots:=test_slot */
	6778827195477540712:  (*TestFlow)(nil),  /* Flow slot:txt:num:bool:swap b:=test_slot */
	1657306804829399405:  (*TestFlow)(nil),  /* Flow slot:txt:num:bool:swap b:slots:=test_slot */
	12863838139919888333: (*TestFlow)(nil),  /* Flow slot:txt:num:bool:swap c:=test_slot */
	8138407403331762124:  (*TestFlow)(nil),  /* Flow slot:txt:num:bool:swap c:slots:=test_slot */
	2458091869952166867:  (*TestFlow)(nil),  /* Flow slot:txt:num:swap a:=test_slot */
	798181228027053882:   (*TestFlow)(nil),  /* Flow slot:txt:num:swap a:slots:=test_slot */
	6761671314058006980:  (*TestFlow)(nil),  /* Flow slot:txt:num:swap b:=test_slot */
	17945145088403901777: (*TestFlow)(nil),  /* Flow slot:txt:num:swap b:slots:=test_slot */
	7973002985806092985:  (*TestFlow)(nil),  /* Flow slot:txt:num:swap c:=test_slot */
	11204239748694745936: (*TestFlow)(nil),  /* Flow slot:txt:num:swap c:slots:=test_slot */
	16539445169268410485: (*TestFlow)(nil),  /* Flow slot:txt:swap a:=test_slot */
	18379859567183839716: (*TestFlow)(nil),  /* Flow slot:txt:swap a:slots:=test_slot */
	4725633733891214354:  (*TestFlow)(nil),  /* Flow slot:txt:swap b:=test_slot */
	7106311331314617599:  (*TestFlow)(nil),  /* Flow slot:txt:swap b:slots:=test_slot */
	946685338405703663:   (*TestFlow)(nil),  /* Flow slot:txt:swap c:=test_slot */
	4838075165788364830:  (*TestFlow)(nil),  /* Flow slot:txt:swap c:slots:=test_slot */
	12528135065518498595: (*TestFlow)(nil),  /* Flow swap a:=test_slot */
	12814732566962068490: (*TestFlow)(nil),  /* Flow swap a:slots:=test_slot */
	4942740625606731988:  (*TestFlow)(nil),  /* Flow swap b:=test_slot */
	7511205977241007009:  (*TestFlow)(nil),  /* Flow swap b:slots:=test_slot */
	9416420617924743433:  (*TestFlow)(nil),  /* Flow swap c:=test_slot */
	2111448544527851936:  (*TestFlow)(nil),  /* Flow swap c:slots:=test_slot */
	540774464816585177:   (*TestFlow)(nil),  /* Flow txt:bool:swap a:=test_slot */
	4584357186375998192:  (*TestFlow)(nil),  /* Flow txt:bool:swap a:slots:=test_slot */
	7517635820319975510:  (*TestFlow)(nil),  /* Flow txt:bool:swap b:=test_slot */
	3301782137274543659:  (*TestFlow)(nil),  /* Flow txt:bool:swap b:slots:=test_slot */
	14630173693679259507: (*TestFlow)(nil),  /* Flow txt:bool:swap c:=test_slot */
	3486504181298381018:  (*TestFlow)(nil),  /* Flow txt:bool:swap c:slots:=test_slot */
	17476458043444239171: (*TestFlow)(nil),  /* Flow txt:num:bool:swap a:=test_slot */
	16232447517281310506: (*TestFlow)(nil),  /* Flow txt:num:bool:swap a:slots:=test_slot */
	3914172493750698612:  (*TestFlow)(nil),  /* Flow txt:num:bool:swap b:=test_slot */
	30217429469191233:    (*TestFlow)(nil),  /* Flow txt:num:bool:swap b:slots:=test_slot */
	1762780695846053417:  (*TestFlow)(nil),  /* Flow txt:num:bool:swap c:=test_slot */
	16698064196194210880: (*TestFlow)(nil),  /* Flow txt:num:bool:swap c:slots:=test_slot */
	9255371118094672319:  (*TestFlow)(nil),  /* Flow txt:num:swap a:=test_slot */
	17691472641608940462: (*TestFlow)(nil),  /* Flow txt:num:swap a:slots:=test_slot */
	8663292675378016416:  (*TestFlow)(nil),  /* Flow txt:num:swap b:=test_slot */
	2757075402580186165:  (*TestFlow)(nil),  /* Flow txt:num:swap b:slots:=test_slot */
	8465376681151271429:  (*TestFlow)(nil),  /* Flow txt:num:swap c:=test_slot */
	11837442146010930868: (*TestFlow)(nil),  /* Flow txt:num:swap c:slots:=test_slot */
	9423917379246691225:  (*TestFlow)(nil),  /* Flow txt:swap a:=test_slot */
	16780028850027183152: (*TestFlow)(nil),  /* Flow txt:swap a:slots:=test_slot */
	7368002230923003414:  (*TestFlow)(nil),  /* Flow txt:swap b:=test_slot */
	4713231559481668459:  (*TestFlow)(nil),  /* Flow txt:swap b:slots:=test_slot */
	4391756811732312115:  (*TestFlow)(nil),  /* Flow txt:swap c:=test_slot */
	11876850302059944218: (*TestFlow)(nil),  /* Flow txt:swap c:slots:=test_slot */
}
