// Code generated by "makeops"; edit at your own risk.
package frame

import (
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/jsn"
	"github.com/ionous/errutil"
)

const Event_Type = "event"

var Event_Optional_Marshal = Event_Marshal

type Event_Slot struct{ Value *Event }

func (at Event_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at Event_Slot) GetType() string              { return Event_Type }
func (at Event_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at Event_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(Event)
	return
}

func Event_Marshal(m jsn.Marshaler, ptr *Event) (err error) {
	slot := Event_Slot{ptr}
	return slot.Marshal(m)
}

type Event_Slice []Event

func (op *Event_Slice) GetType() string { return Event_Type }

func (op *Event_Slice) Marshal(m jsn.Marshaler) error {
	return Event_Repeats_Marshal(m, (*[]Event)(op))
}

func (op *Event_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Event_Slice) SetSize(cnt int) {
	var els []Event
	if cnt >= 0 {
		els = make(Event_Slice, cnt)
	}
	(*op) = els
}

func (op *Event_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Event_Marshal(m, &(*op)[i])
}

func Event_Repeats_Marshal(m jsn.Marshaler, vals *[]Event) error {
	return jsn.RepeatBlock(m, (*Event_Slice)(vals))
}

func Event_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Event) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Event_Repeats_Marshal(m, pv)
	}
	return
}

// Frame
type Frame struct {
	Result string  `if:"label=result,type=text"`
	Events []Event `if:"label=events"`
	Error  string  `if:"label=error,optional,type=text"`
	Markup map[string]any
}

func (*Frame) Compose() composer.Spec {
	return composer.Spec{
		Name: Frame_Type,
		Uses: composer.Type_Flow,
	}
}

const Frame_Type = "frame"
const Frame_Field_Result = "$RESULT"
const Frame_Field_Events = "$EVENTS"
const Frame_Field_Error = "$ERROR"

func (op *Frame) Marshal(m jsn.Marshaler) error {
	return Frame_Marshal(m, op)
}

type Frame_Slice []Frame

func (op *Frame_Slice) GetType() string { return Frame_Type }

func (op *Frame_Slice) Marshal(m jsn.Marshaler) error {
	return Frame_Repeats_Marshal(m, (*[]Frame)(op))
}

func (op *Frame_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Frame_Slice) SetSize(cnt int) {
	var els []Frame
	if cnt >= 0 {
		els = make(Frame_Slice, cnt)
	}
	(*op) = els
}

func (op *Frame_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Frame_Marshal(m, &(*op)[i])
}

func Frame_Repeats_Marshal(m jsn.Marshaler, vals *[]Frame) error {
	return jsn.RepeatBlock(m, (*Frame_Slice)(vals))
}

func Frame_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Frame) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Frame_Repeats_Marshal(m, pv)
	}
	return
}

type Frame_Flow struct{ ptr *Frame }

func (n Frame_Flow) GetType() string      { return Frame_Type }
func (n Frame_Flow) GetLede() string      { return Frame_Type }
func (n Frame_Flow) GetFlow() interface{} { return n.ptr }
func (n Frame_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Frame); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Frame_Optional_Marshal(m jsn.Marshaler, pv **Frame) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Frame_Marshal(m, *pv)
	} else if !enc {
		var v Frame
		if err = Frame_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Frame_Marshal(m jsn.Marshaler, val *Frame) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Frame_Flow{val}); err == nil {
		e0 := m.MarshalKey("result", Frame_Field_Result)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Result)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Frame_Field_Result))
		}
		e1 := m.MarshalKey("events", Frame_Field_Events)
		if e1 == nil {
			e1 = Event_Repeats_Marshal(m, &val.Events)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Frame_Field_Events))
		}
		e2 := m.MarshalKey("error", Frame_Field_Error)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Optional_Marshal(m, &val.Error)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Frame_Field_Error))
		}
		m.EndBlock()
	}
	return
}

// FrameOutput
type FrameOutput struct {
	Text   string `if:"label=_,type=text"`
	Markup map[string]any
}

// User implemented slots:
var _ Event = (*FrameOutput)(nil)

func (*FrameOutput) Compose() composer.Spec {
	return composer.Spec{
		Name: FrameOutput_Type,
		Uses: composer.Type_Flow,
	}
}

const FrameOutput_Type = "frame_output"
const FrameOutput_Field_Text = "$TEXT"

func (op *FrameOutput) Marshal(m jsn.Marshaler) error {
	return FrameOutput_Marshal(m, op)
}

type FrameOutput_Slice []FrameOutput

func (op *FrameOutput_Slice) GetType() string { return FrameOutput_Type }

func (op *FrameOutput_Slice) Marshal(m jsn.Marshaler) error {
	return FrameOutput_Repeats_Marshal(m, (*[]FrameOutput)(op))
}

func (op *FrameOutput_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *FrameOutput_Slice) SetSize(cnt int) {
	var els []FrameOutput
	if cnt >= 0 {
		els = make(FrameOutput_Slice, cnt)
	}
	(*op) = els
}

func (op *FrameOutput_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return FrameOutput_Marshal(m, &(*op)[i])
}

func FrameOutput_Repeats_Marshal(m jsn.Marshaler, vals *[]FrameOutput) error {
	return jsn.RepeatBlock(m, (*FrameOutput_Slice)(vals))
}

func FrameOutput_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]FrameOutput) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = FrameOutput_Repeats_Marshal(m, pv)
	}
	return
}

type FrameOutput_Flow struct{ ptr *FrameOutput }

func (n FrameOutput_Flow) GetType() string      { return FrameOutput_Type }
func (n FrameOutput_Flow) GetLede() string      { return FrameOutput_Type }
func (n FrameOutput_Flow) GetFlow() interface{} { return n.ptr }
func (n FrameOutput_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*FrameOutput); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func FrameOutput_Optional_Marshal(m jsn.Marshaler, pv **FrameOutput) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FrameOutput_Marshal(m, *pv)
	} else if !enc {
		var v FrameOutput
		if err = FrameOutput_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FrameOutput_Marshal(m jsn.Marshaler, val *FrameOutput) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(FrameOutput_Flow{val}); err == nil {
		e0 := m.MarshalKey("", FrameOutput_Field_Text)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Text)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FrameOutput_Field_Text))
		}
		m.EndBlock()
	}
	return
}

// PairChanged
type PairChanged struct {
	A      string `if:"label=a,type=text"`
	B      string `if:"label=b,type=text"`
	Rel    string `if:"label=rel,type=text"`
	Markup map[string]any
}

// User implemented slots:
var _ Event = (*PairChanged)(nil)

func (*PairChanged) Compose() composer.Spec {
	return composer.Spec{
		Name: PairChanged_Type,
		Uses: composer.Type_Flow,
	}
}

const PairChanged_Type = "pair_changed"
const PairChanged_Field_A = "$A"
const PairChanged_Field_B = "$B"
const PairChanged_Field_Rel = "$REL"

func (op *PairChanged) Marshal(m jsn.Marshaler) error {
	return PairChanged_Marshal(m, op)
}

type PairChanged_Slice []PairChanged

func (op *PairChanged_Slice) GetType() string { return PairChanged_Type }

func (op *PairChanged_Slice) Marshal(m jsn.Marshaler) error {
	return PairChanged_Repeats_Marshal(m, (*[]PairChanged)(op))
}

func (op *PairChanged_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *PairChanged_Slice) SetSize(cnt int) {
	var els []PairChanged
	if cnt >= 0 {
		els = make(PairChanged_Slice, cnt)
	}
	(*op) = els
}

func (op *PairChanged_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return PairChanged_Marshal(m, &(*op)[i])
}

func PairChanged_Repeats_Marshal(m jsn.Marshaler, vals *[]PairChanged) error {
	return jsn.RepeatBlock(m, (*PairChanged_Slice)(vals))
}

func PairChanged_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]PairChanged) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = PairChanged_Repeats_Marshal(m, pv)
	}
	return
}

type PairChanged_Flow struct{ ptr *PairChanged }

func (n PairChanged_Flow) GetType() string      { return PairChanged_Type }
func (n PairChanged_Flow) GetLede() string      { return PairChanged_Type }
func (n PairChanged_Flow) GetFlow() interface{} { return n.ptr }
func (n PairChanged_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*PairChanged); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func PairChanged_Optional_Marshal(m jsn.Marshaler, pv **PairChanged) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = PairChanged_Marshal(m, *pv)
	} else if !enc {
		var v PairChanged
		if err = PairChanged_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func PairChanged_Marshal(m jsn.Marshaler, val *PairChanged) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(PairChanged_Flow{val}); err == nil {
		e0 := m.MarshalKey("a", PairChanged_Field_A)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.A)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", PairChanged_Field_A))
		}
		e1 := m.MarshalKey("b", PairChanged_Field_B)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.B)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", PairChanged_Field_B))
		}
		e2 := m.MarshalKey("rel", PairChanged_Field_Rel)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.Rel)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", PairChanged_Field_Rel))
		}
		m.EndBlock()
	}
	return
}

// SceneEnded
type SceneEnded struct {
	Domains []string `if:"label=_,type=text"`
	Markup  map[string]any
}

// User implemented slots:
var _ Event = (*SceneEnded)(nil)

func (*SceneEnded) Compose() composer.Spec {
	return composer.Spec{
		Name: SceneEnded_Type,
		Uses: composer.Type_Flow,
	}
}

const SceneEnded_Type = "scene_ended"
const SceneEnded_Field_Domains = "$DOMAINS"

func (op *SceneEnded) Marshal(m jsn.Marshaler) error {
	return SceneEnded_Marshal(m, op)
}

type SceneEnded_Slice []SceneEnded

func (op *SceneEnded_Slice) GetType() string { return SceneEnded_Type }

func (op *SceneEnded_Slice) Marshal(m jsn.Marshaler) error {
	return SceneEnded_Repeats_Marshal(m, (*[]SceneEnded)(op))
}

func (op *SceneEnded_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *SceneEnded_Slice) SetSize(cnt int) {
	var els []SceneEnded
	if cnt >= 0 {
		els = make(SceneEnded_Slice, cnt)
	}
	(*op) = els
}

func (op *SceneEnded_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return SceneEnded_Marshal(m, &(*op)[i])
}

func SceneEnded_Repeats_Marshal(m jsn.Marshaler, vals *[]SceneEnded) error {
	return jsn.RepeatBlock(m, (*SceneEnded_Slice)(vals))
}

func SceneEnded_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]SceneEnded) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = SceneEnded_Repeats_Marshal(m, pv)
	}
	return
}

type SceneEnded_Flow struct{ ptr *SceneEnded }

func (n SceneEnded_Flow) GetType() string      { return SceneEnded_Type }
func (n SceneEnded_Flow) GetLede() string      { return SceneEnded_Type }
func (n SceneEnded_Flow) GetFlow() interface{} { return n.ptr }
func (n SceneEnded_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*SceneEnded); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func SceneEnded_Optional_Marshal(m jsn.Marshaler, pv **SceneEnded) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = SceneEnded_Marshal(m, *pv)
	} else if !enc {
		var v SceneEnded
		if err = SceneEnded_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func SceneEnded_Marshal(m jsn.Marshaler, val *SceneEnded) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(SceneEnded_Flow{val}); err == nil {
		e0 := m.MarshalKey("", SceneEnded_Field_Domains)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Repeats_Marshal(m, &val.Domains)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", SceneEnded_Field_Domains))
		}
		m.EndBlock()
	}
	return
}

// SceneStarted
type SceneStarted struct {
	Domains []string `if:"label=_,type=text"`
	Markup  map[string]any
}

// User implemented slots:
var _ Event = (*SceneStarted)(nil)

func (*SceneStarted) Compose() composer.Spec {
	return composer.Spec{
		Name: SceneStarted_Type,
		Uses: composer.Type_Flow,
	}
}

const SceneStarted_Type = "scene_started"
const SceneStarted_Field_Domains = "$DOMAINS"

func (op *SceneStarted) Marshal(m jsn.Marshaler) error {
	return SceneStarted_Marshal(m, op)
}

type SceneStarted_Slice []SceneStarted

func (op *SceneStarted_Slice) GetType() string { return SceneStarted_Type }

func (op *SceneStarted_Slice) Marshal(m jsn.Marshaler) error {
	return SceneStarted_Repeats_Marshal(m, (*[]SceneStarted)(op))
}

func (op *SceneStarted_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *SceneStarted_Slice) SetSize(cnt int) {
	var els []SceneStarted
	if cnt >= 0 {
		els = make(SceneStarted_Slice, cnt)
	}
	(*op) = els
}

func (op *SceneStarted_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return SceneStarted_Marshal(m, &(*op)[i])
}

func SceneStarted_Repeats_Marshal(m jsn.Marshaler, vals *[]SceneStarted) error {
	return jsn.RepeatBlock(m, (*SceneStarted_Slice)(vals))
}

func SceneStarted_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]SceneStarted) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = SceneStarted_Repeats_Marshal(m, pv)
	}
	return
}

type SceneStarted_Flow struct{ ptr *SceneStarted }

func (n SceneStarted_Flow) GetType() string      { return SceneStarted_Type }
func (n SceneStarted_Flow) GetLede() string      { return SceneStarted_Type }
func (n SceneStarted_Flow) GetFlow() interface{} { return n.ptr }
func (n SceneStarted_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*SceneStarted); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func SceneStarted_Optional_Marshal(m jsn.Marshaler, pv **SceneStarted) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = SceneStarted_Marshal(m, *pv)
	} else if !enc {
		var v SceneStarted
		if err = SceneStarted_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func SceneStarted_Marshal(m jsn.Marshaler, val *SceneStarted) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(SceneStarted_Flow{val}); err == nil {
		e0 := m.MarshalKey("", SceneStarted_Field_Domains)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Repeats_Marshal(m, &val.Domains)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", SceneStarted_Field_Domains))
		}
		m.EndBlock()
	}
	return
}

// StateChanged
type StateChanged struct {
	Noun   string `if:"label=noun,type=text"`
	Aspect string `if:"label=aspect,type=text"`
	Trait  string `if:"label=trait,type=text"`
	Markup map[string]any
}

// User implemented slots:
var _ Event = (*StateChanged)(nil)

func (*StateChanged) Compose() composer.Spec {
	return composer.Spec{
		Name: StateChanged_Type,
		Uses: composer.Type_Flow,
	}
}

const StateChanged_Type = "state_changed"
const StateChanged_Field_Noun = "$NOUN"
const StateChanged_Field_Aspect = "$ASPECT"
const StateChanged_Field_Trait = "$TRAIT"

func (op *StateChanged) Marshal(m jsn.Marshaler) error {
	return StateChanged_Marshal(m, op)
}

type StateChanged_Slice []StateChanged

func (op *StateChanged_Slice) GetType() string { return StateChanged_Type }

func (op *StateChanged_Slice) Marshal(m jsn.Marshaler) error {
	return StateChanged_Repeats_Marshal(m, (*[]StateChanged)(op))
}

func (op *StateChanged_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *StateChanged_Slice) SetSize(cnt int) {
	var els []StateChanged
	if cnt >= 0 {
		els = make(StateChanged_Slice, cnt)
	}
	(*op) = els
}

func (op *StateChanged_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return StateChanged_Marshal(m, &(*op)[i])
}

func StateChanged_Repeats_Marshal(m jsn.Marshaler, vals *[]StateChanged) error {
	return jsn.RepeatBlock(m, (*StateChanged_Slice)(vals))
}

func StateChanged_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]StateChanged) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = StateChanged_Repeats_Marshal(m, pv)
	}
	return
}

type StateChanged_Flow struct{ ptr *StateChanged }

func (n StateChanged_Flow) GetType() string      { return StateChanged_Type }
func (n StateChanged_Flow) GetLede() string      { return StateChanged_Type }
func (n StateChanged_Flow) GetFlow() interface{} { return n.ptr }
func (n StateChanged_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*StateChanged); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func StateChanged_Optional_Marshal(m jsn.Marshaler, pv **StateChanged) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = StateChanged_Marshal(m, *pv)
	} else if !enc {
		var v StateChanged
		if err = StateChanged_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func StateChanged_Marshal(m jsn.Marshaler, val *StateChanged) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(StateChanged_Flow{val}); err == nil {
		e0 := m.MarshalKey("noun", StateChanged_Field_Noun)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Noun)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", StateChanged_Field_Noun))
		}
		e1 := m.MarshalKey("aspect", StateChanged_Field_Aspect)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Aspect)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", StateChanged_Field_Aspect))
		}
		e2 := m.MarshalKey("trait", StateChanged_Field_Trait)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.Trait)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", StateChanged_Field_Trait))
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*Event)(nil),
}

var Slats = []composer.Composer{
	(*Frame)(nil),
	(*FrameOutput)(nil),
	(*PairChanged)(nil),
	(*SceneEnded)(nil),
	(*SceneStarted)(nil),
	(*StateChanged)(nil),
}

var Signatures = map[uint64]interface{}{
	14657663848717440116: (*Frame)(nil),        /* Frame result:events: */
	2438049115146588168:  (*Frame)(nil),        /* Frame result:events:error: */
	4385780296792938688:  (*FrameOutput)(nil),  /* event=FrameOutput: */
	17021232753503984522: (*PairChanged)(nil),  /* event=PairChanged a:b:rel: */
	14005264853352099464: (*SceneEnded)(nil),   /* event=SceneEnded: */
	12902248384806780167: (*SceneStarted)(nil), /* event=SceneStarted: */
	8020611754012510413:  (*StateChanged)(nil), /* event=StateChanged noun:aspect:trait: */
}
