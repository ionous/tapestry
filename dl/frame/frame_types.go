// Code generated by Tapestry; edit at your own risk.
package frame

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// event, a type of slot.
const Z_Event_Type = "event"

var Z_Event_Info = typeinfo.Slot{
	Name: Z_Event_Type,
}

// holds a single slot
// FIX: currently provided by the spec
type FIX_Event_Slot struct{ Value Event }

// implements typeinfo.Inspector for a single slot.
func (*Event_Slot) Inspect() typeinfo.T {
	return &Z_Event_Info
}

// holds a slice of slots
type Event_Slots []Event

// implements typeinfo.Inspector for a series of slots.
func (*Event_Slots) Inspect() typeinfo.T {
	return &Z_Event_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Frame struct {
	Result string
	Events Event
	Error  string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Frame) Inspect() typeinfo.T {
	return &Z_Frame_Info
}

// return a valid markup map, creating it if necessary.
func (op *Frame) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// frame, a type of flow.
const Z_Frame_Type = "frame"

var Z_Frame_Info = typeinfo.Flow{
	Name: Z_Frame_Type,
	Lede: "frame",
	Terms: []typeinfo.Term{{
		Name:  "result",
		Label: "result",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:    "events",
		Label:   "events",
		Repeats: true,
		Type:    &Z_Event_Info,
	}, {
		Name:     "error",
		Label:    "error",
		Optional: true,
		Type:     &prim.Z_Text_Info,
	}},
}

// holds a slice of type frame
// FIX: duplicates the spec decl.
type FIX_Frame_Slice []Frame

// implements typeinfo.Inspector
func (*Frame_Slice) Inspect() typeinfo.T {
	return &Z_Frame_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_FrameOutput struct {
	Text   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*FrameOutput) Inspect() typeinfo.T {
	return &Z_FrameOutput_Info
}

// return a valid markup map, creating it if necessary.
func (op *FrameOutput) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// frame_output, a type of flow.
const Z_FrameOutput_Type = "frame_output"

// ensure the command implements its specified slots:
var _ Event = (*FrameOutput)(nil)

var Z_FrameOutput_Info = typeinfo.Flow{
	Name: Z_FrameOutput_Type,
	Lede: "frame_output",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&Z_Event_Info,
	},
}

// holds a slice of type frame_output
// FIX: duplicates the spec decl.
type FIX_FrameOutput_Slice []FrameOutput

// implements typeinfo.Inspector
func (*FrameOutput_Slice) Inspect() typeinfo.T {
	return &Z_FrameOutput_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SceneStarted struct {
	Domains string
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*SceneStarted) Inspect() typeinfo.T {
	return &Z_SceneStarted_Info
}

// return a valid markup map, creating it if necessary.
func (op *SceneStarted) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// scene_started, a type of flow.
const Z_SceneStarted_Type = "scene_started"

// ensure the command implements its specified slots:
var _ Event = (*SceneStarted)(nil)

var Z_SceneStarted_Info = typeinfo.Flow{
	Name: Z_SceneStarted_Type,
	Lede: "scene_started",
	Terms: []typeinfo.Term{{
		Name:    "domains",
		Label:   "_",
		Repeats: true,
		Type:    &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&Z_Event_Info,
	},
}

// holds a slice of type scene_started
// FIX: duplicates the spec decl.
type FIX_SceneStarted_Slice []SceneStarted

// implements typeinfo.Inspector
func (*SceneStarted_Slice) Inspect() typeinfo.T {
	return &Z_SceneStarted_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SceneEnded struct {
	Domains string
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*SceneEnded) Inspect() typeinfo.T {
	return &Z_SceneEnded_Info
}

// return a valid markup map, creating it if necessary.
func (op *SceneEnded) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// scene_ended, a type of flow.
const Z_SceneEnded_Type = "scene_ended"

// ensure the command implements its specified slots:
var _ Event = (*SceneEnded)(nil)

var Z_SceneEnded_Info = typeinfo.Flow{
	Name: Z_SceneEnded_Type,
	Lede: "scene_ended",
	Terms: []typeinfo.Term{{
		Name:    "domains",
		Label:   "_",
		Repeats: true,
		Type:    &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&Z_Event_Info,
	},
}

// holds a slice of type scene_ended
// FIX: duplicates the spec decl.
type FIX_SceneEnded_Slice []SceneEnded

// implements typeinfo.Inspector
func (*SceneEnded_Slice) Inspect() typeinfo.T {
	return &Z_SceneEnded_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_StateChanged struct {
	Noun   string
	Aspect string
	Prev   string
	Trait  string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*StateChanged) Inspect() typeinfo.T {
	return &Z_StateChanged_Info
}

// return a valid markup map, creating it if necessary.
func (op *StateChanged) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// state_changed, a type of flow.
const Z_StateChanged_Type = "state_changed"

// ensure the command implements its specified slots:
var _ Event = (*StateChanged)(nil)

var Z_StateChanged_Info = typeinfo.Flow{
	Name: Z_StateChanged_Type,
	Lede: "state_changed",
	Terms: []typeinfo.Term{{
		Name:  "noun",
		Label: "noun",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:  "aspect",
		Label: "aspect",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:  "prev",
		Label: "prev",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:  "trait",
		Label: "trait",
		Type:  &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&Z_Event_Info,
	},
}

// holds a slice of type state_changed
// FIX: duplicates the spec decl.
type FIX_StateChanged_Slice []StateChanged

// implements typeinfo.Inspector
func (*StateChanged_Slice) Inspect() typeinfo.T {
	return &Z_StateChanged_Info
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_PairChanged struct {
	A      string
	B      string
	Rel    string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*PairChanged) Inspect() typeinfo.T {
	return &Z_PairChanged_Info
}

// return a valid markup map, creating it if necessary.
func (op *PairChanged) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// pair_changed, a type of flow.
const Z_PairChanged_Type = "pair_changed"

// ensure the command implements its specified slots:
var _ Event = (*PairChanged)(nil)

var Z_PairChanged_Info = typeinfo.Flow{
	Name: Z_PairChanged_Type,
	Lede: "pair_changed",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "a",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:  "b",
		Label: "b",
		Type:  &prim.Z_Text_Info,
	}, {
		Name:  "rel",
		Label: "rel",
		Type:  &prim.Z_Text_Info,
	}},
	Slots: []*typeinfo.Slot{
		&Z_Event_Info,
	},
}

// holds a slice of type pair_changed
// FIX: duplicates the spec decl.
type FIX_PairChanged_Slice []PairChanged

// implements typeinfo.Inspector
func (*PairChanged_Slice) Inspect() typeinfo.T {
	return &Z_PairChanged_Info
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var Y_slot_List = []*typeinfo.Slot{
	&Z_Event_Info,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var Y_flow_List = []*typeinfo.Flow{
	&Z_Frame_Info,
	&Z_FrameOutput_Info,
	&Z_SceneStarted_Info,
	&Z_SceneEnded_Info,
	&Z_StateChanged_Info,
	&Z_PairChanged_Info,
}

// a list of all command signatures
// ( for processing and verifying story files )
var Z_Signatures = map[uint64]interface{}{}
