// Code generated by Tapestry; edit at your own risk.
package frame

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// event, a type of slot.
var Zt_Event = typeinfo.Slot{
	Name: "event",
}

// holds a single slot.
type Event_Slot struct{ Value Event }

// implements typeinfo.Instance for a single slot.
func (*Event_Slot) TypeInfo() typeinfo.T {
	return &Zt_Event
}

// holds a slice of slots.
type Event_Slots []Event

// implements typeinfo.Instance for a series of slots.
func (*Event_Slots) TypeInfo() typeinfo.T {
	return &Zt_Event
}

// implements typeinfo.Repeats
func (op *Event_Slots) Repeats() bool {
	return len(*op) > 0
}

type Frame struct {
	Result string
	Events []Event
	Error  string
	Markup map[string]any
}

// implements typeinfo.Instance
func (*Frame) TypeInfo() typeinfo.T {
	return &Zt_Frame
}

// return a valid markup map, creating it if necessary.
func (op *Frame) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// frame, a type of flow.
var Zt_Frame = typeinfo.Flow{
	Name: "frame",
	Lede: "frame",
	Terms: []typeinfo.Term{{
		Name:  "result",
		Label: "result",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "events",
		Label:   "events",
		Repeats: true,
		Type:    &Zt_Event,
	}, {
		Name:     "error",
		Label:    "error",
		Optional: true,
		Type:     &prim.Zt_Text,
	}},
}

// holds a slice of type frame
type Frame_Slice []Frame

// implements typeinfo.Instance
func (*Frame_Slice) TypeInfo() typeinfo.T {
	return &Zt_Frame
}

// implements typeinfo.Repeats
func (op *Frame_Slice) Repeats() bool {
	return len(*op) > 0
}

type FrameOutput struct {
	Text   string
	Markup map[string]any
}

// implements typeinfo.Instance
func (*FrameOutput) TypeInfo() typeinfo.T {
	return &Zt_FrameOutput
}

// return a valid markup map, creating it if necessary.
func (op *FrameOutput) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Event = (*FrameOutput)(nil)

// frame_output, a type of flow.
var Zt_FrameOutput = typeinfo.Flow{
	Name: "frame_output",
	Lede: "frame_output",
	Terms: []typeinfo.Term{{
		Name: "text",
		Type: &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_Event,
	},
}

// holds a slice of type frame_output
type FrameOutput_Slice []FrameOutput

// implements typeinfo.Instance
func (*FrameOutput_Slice) TypeInfo() typeinfo.T {
	return &Zt_FrameOutput
}

// implements typeinfo.Repeats
func (op *FrameOutput_Slice) Repeats() bool {
	return len(*op) > 0
}

type SceneStarted struct {
	Domains []string
	Markup  map[string]any
}

// implements typeinfo.Instance
func (*SceneStarted) TypeInfo() typeinfo.T {
	return &Zt_SceneStarted
}

// return a valid markup map, creating it if necessary.
func (op *SceneStarted) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Event = (*SceneStarted)(nil)

// scene_started, a type of flow.
var Zt_SceneStarted = typeinfo.Flow{
	Name: "scene_started",
	Lede: "scene_started",
	Terms: []typeinfo.Term{{
		Name:    "domains",
		Repeats: true,
		Type:    &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_Event,
	},
}

// holds a slice of type scene_started
type SceneStarted_Slice []SceneStarted

// implements typeinfo.Instance
func (*SceneStarted_Slice) TypeInfo() typeinfo.T {
	return &Zt_SceneStarted
}

// implements typeinfo.Repeats
func (op *SceneStarted_Slice) Repeats() bool {
	return len(*op) > 0
}

type SceneEnded struct {
	Domains []string
	Markup  map[string]any
}

// implements typeinfo.Instance
func (*SceneEnded) TypeInfo() typeinfo.T {
	return &Zt_SceneEnded
}

// return a valid markup map, creating it if necessary.
func (op *SceneEnded) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Event = (*SceneEnded)(nil)

// scene_ended, a type of flow.
var Zt_SceneEnded = typeinfo.Flow{
	Name: "scene_ended",
	Lede: "scene_ended",
	Terms: []typeinfo.Term{{
		Name:    "domains",
		Repeats: true,
		Type:    &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_Event,
	},
}

// holds a slice of type scene_ended
type SceneEnded_Slice []SceneEnded

// implements typeinfo.Instance
func (*SceneEnded_Slice) TypeInfo() typeinfo.T {
	return &Zt_SceneEnded
}

// implements typeinfo.Repeats
func (op *SceneEnded_Slice) Repeats() bool {
	return len(*op) > 0
}

type StateChanged struct {
	Noun   string
	Aspect string
	Prev   string
	Trait  string
	Markup map[string]any
}

// implements typeinfo.Instance
func (*StateChanged) TypeInfo() typeinfo.T {
	return &Zt_StateChanged
}

// return a valid markup map, creating it if necessary.
func (op *StateChanged) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Event = (*StateChanged)(nil)

// state_changed, a type of flow.
var Zt_StateChanged = typeinfo.Flow{
	Name: "state_changed",
	Lede: "state_changed",
	Terms: []typeinfo.Term{{
		Name:  "noun",
		Label: "noun",
		Type:  &prim.Zt_Text,
	}, {
		Name:  "aspect",
		Label: "aspect",
		Type:  &prim.Zt_Text,
	}, {
		Name:  "prev",
		Label: "prev",
		Type:  &prim.Zt_Text,
	}, {
		Name:  "trait",
		Label: "trait",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_Event,
	},
}

// holds a slice of type state_changed
type StateChanged_Slice []StateChanged

// implements typeinfo.Instance
func (*StateChanged_Slice) TypeInfo() typeinfo.T {
	return &Zt_StateChanged
}

// implements typeinfo.Repeats
func (op *StateChanged_Slice) Repeats() bool {
	return len(*op) > 0
}

type PairChanged struct {
	A      string
	B      string
	Rel    string
	Markup map[string]any
}

// implements typeinfo.Instance
func (*PairChanged) TypeInfo() typeinfo.T {
	return &Zt_PairChanged
}

// return a valid markup map, creating it if necessary.
func (op *PairChanged) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Event = (*PairChanged)(nil)

// pair_changed, a type of flow.
var Zt_PairChanged = typeinfo.Flow{
	Name: "pair_changed",
	Lede: "pair_changed",
	Terms: []typeinfo.Term{{
		Name:  "a",
		Label: "a",
		Type:  &prim.Zt_Text,
	}, {
		Name:  "b",
		Label: "b",
		Type:  &prim.Zt_Text,
	}, {
		Name:  "rel",
		Label: "rel",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_Event,
	},
}

// holds a slice of type pair_changed
type PairChanged_Slice []PairChanged

// implements typeinfo.Instance
func (*PairChanged_Slice) TypeInfo() typeinfo.T {
	return &Zt_PairChanged
}

// implements typeinfo.Repeats
func (op *PairChanged_Slice) Repeats() bool {
	return len(*op) > 0
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "frame",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Event,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Frame,
	&Zt_FrameOutput,
	&Zt_SceneStarted,
	&Zt_SceneEnded,
	&Zt_StateChanged,
	&Zt_PairChanged,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	14657663848717440116: (*Frame)(nil),        /* Frame result:events: */
	2438049115146588168:  (*Frame)(nil),        /* Frame result:events:error: */
	4385780296792938688:  (*FrameOutput)(nil),  /* event=FrameOutput: */
	17021232753503984522: (*PairChanged)(nil),  /* event=PairChanged a:b:rel: */
	14005264853352099464: (*SceneEnded)(nil),   /* event=SceneEnded: */
	12902248384806780167: (*SceneStarted)(nil), /* event=SceneStarted: */
	7027046405509259850:  (*StateChanged)(nil), /* event=StateChanged noun:aspect:prev:trait: */
}
