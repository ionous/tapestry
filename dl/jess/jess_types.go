// Code generated by Tapestry; edit at your own risk.
package jess

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// matched, a type of slot.
var Zt_Matched = typeinfo.Slot{
	Name: "matched",
	Markup: map[string]any{
		"comment": []interface{}{"a snippet of matching text;", "defined via an interface to allow instances", "to track additional information (ex. db row)."},
	},
}

// holds a single slot.
type Matched_Slot struct{ Value Matched }

// implements typeinfo.Instance for a single slot.
func (*Matched_Slot) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// holds a slice of slots.
type Matched_Slots []Matched

// implements typeinfo.Instance for a series of slots.
func (*Matched_Slots) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// implements typeinfo.Repeats
func (op *Matched_Slots) Repeats() bool {
	return len(*op) > 0
}

// matches, a type of slot.
var Zt_Matches = typeinfo.Slot{
	Name: "matches",
	Markup: map[string]any{
		"comment": "the root of a sentence matching tree.",
	},
}

// holds a single slot.
type Matches_Slot struct{ Value Matches }

// implements typeinfo.Instance for a single slot.
func (*Matches_Slot) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// holds a slice of slots.
type Matches_Slots []Matches

// implements typeinfo.Instance for a series of slots.
func (*Matches_Slots) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// implements typeinfo.Repeats
func (op *Matches_Slots) Repeats() bool {
	return len(*op) > 0
}

// name_called, a type of slot.
var Zt_NameCalled = typeinfo.Slot{
	Name: "name_called",
	Markup: map[string]any{
		"comment": []interface{}{"represents a single name or \"x called y\" phrase", "both can generate a name.", "todo: find a better name for this slot."},
	},
}

// holds a single slot.
type NameCalled_Slot struct{ Value NameCalled }

// implements typeinfo.Instance for a single slot.
func (*NameCalled_Slot) TypeInfo() typeinfo.T {
	return &Zt_NameCalled
}

// holds a slice of slots.
type NameCalled_Slots []NameCalled

// implements typeinfo.Instance for a series of slots.
func (*NameCalled_Slots) TypeInfo() typeinfo.T {
	return &Zt_NameCalled
}

// implements typeinfo.Repeats
func (op *NameCalled_Slots) Repeats() bool {
	return len(*op) > 0
}

type Article struct {
	Matched Matched
	Markup  map[string]any
}

// article, a type of flow.
var Zt_Article typeinfo.Flow

// implements typeinfo.Instance
func (*Article) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Markup
func (op *Article) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type article
type Article_Slice []Article

// implements typeinfo.Instance
func (*Article_Slice) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Repeats
func (op *Article_Slice) Repeats() bool {
	return len(*op) > 0
}

// conjunction junction
type CommaAnd struct {
	Matched Matched
	Markup  map[string]any
}

// comma_and, a type of flow.
var Zt_CommaAnd typeinfo.Flow

// implements typeinfo.Instance
func (*CommaAnd) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Markup
func (op *CommaAnd) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type comma_and
type CommaAnd_Slice []CommaAnd

// implements typeinfo.Instance
func (*CommaAnd_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Repeats
func (op *CommaAnd_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches "is" or "are".
type Are struct {
	Matched Matched
	Markup  map[string]any
}

// are, a type of flow.
var Zt_Are typeinfo.Flow

// implements typeinfo.Instance
func (*Are) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Markup
func (op *Are) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type are
type Are_Slice []Are

// implements typeinfo.Instance
func (*Are_Slice) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Repeats
func (op *Are_Slice) Repeats() bool {
	return len(*op) > 0
}

type Counted struct {
	Number float64
	Markup map[string]any
}

// counted, a type of flow.
var Zt_Counted typeinfo.Flow

// implements typeinfo.Instance
func (*Counted) TypeInfo() typeinfo.T {
	return &Zt_Counted
}

// implements typeinfo.Markup
func (op *Counted) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type counted
type Counted_Slice []Counted

// implements typeinfo.Instance
func (*Counted_Slice) TypeInfo() typeinfo.T {
	return &Zt_Counted
}

// implements typeinfo.Repeats
func (op *Counted_Slice) Repeats() bool {
	return len(*op) > 0
}

type TheName struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// the_name, a type of flow.
var Zt_TheName typeinfo.Flow

// implements typeinfo.Instance
func (*TheName) TypeInfo() typeinfo.T {
	return &Zt_TheName
}

// implements typeinfo.Markup
func (op *TheName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ NameCalled = (*TheName)(nil)

// holds a slice of type the_name
type TheName_Slice []TheName

// implements typeinfo.Instance
func (*TheName_Slice) TypeInfo() typeinfo.T {
	return &Zt_TheName
}

// implements typeinfo.Repeats
func (op *TheName_Slice) Repeats() bool {
	return len(*op) > 0
}

type Called struct {
	TheKind TheKind
	Called  Words
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// called, a type of flow.
var Zt_Called typeinfo.Flow

// implements typeinfo.Instance
func (*Called) TypeInfo() typeinfo.T {
	return &Zt_Called
}

// implements typeinfo.Markup
func (op *Called) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ NameCalled = (*Called)(nil)

// holds a slice of type called
type Called_Slice []Called

// implements typeinfo.Instance
func (*Called_Slice) TypeInfo() typeinfo.T {
	return &Zt_Called
}

// implements typeinfo.Repeats
func (op *Called_Slice) Repeats() bool {
	return len(*op) > 0
}

type Names struct {
	NameCalled      NameCalled
	AdditionalNames *AdditionalNames
	Markup          map[string]any
}

// names, a type of flow.
var Zt_Names typeinfo.Flow

// implements typeinfo.Instance
func (*Names) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Markup
func (op *Names) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type names
type Names_Slice []Names

// implements typeinfo.Instance
func (*Names_Slice) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Repeats
func (op *Names_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a name following another name.
type AdditionalNames struct {
	CommaAnd CommaAnd
	Names    Names
	Markup   map[string]any
}

// additional_names, a type of flow.
var Zt_AdditionalNames typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalNames) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Markup
func (op *AdditionalNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_names
type AdditionalNames_Slice []AdditionalNames

// implements typeinfo.Instance
func (*AdditionalNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Repeats
func (op *AdditionalNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an (existing) kind.
type TheKind struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// the_kind, a type of flow.
var Zt_TheKind typeinfo.Flow

// implements typeinfo.Instance
func (*TheKind) TypeInfo() typeinfo.T {
	return &Zt_TheKind
}

// implements typeinfo.Markup
func (op *TheKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type the_kind
type TheKind_Slice []TheKind

// implements typeinfo.Instance
func (*TheKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_TheKind
}

// implements typeinfo.Repeats
func (op *TheKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches at least one kind.
type Kinds struct {
	TheKind         TheKind
	AdditionalKinds *AdditionalKinds
	Markup          map[string]any
}

// kinds, a type of flow.
var Zt_Kinds typeinfo.Flow

// implements typeinfo.Instance
func (*Kinds) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Markup
func (op *Kinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds
type Kinds_Slice []Kinds

// implements typeinfo.Instance
func (*Kinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Repeats
func (op *Kinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a kind following another kind.
type AdditionalKinds struct {
	CommaAnd CommaAnd
	Kinds    Kinds
	Markup   map[string]any
}

// additional_kinds, a type of flow.
var Zt_AdditionalKinds typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalKinds) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Markup
func (op *AdditionalKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_kinds
type AdditionalKinds_Slice []AdditionalKinds

// implements typeinfo.Instance
func (*AdditionalKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Repeats
func (op *AdditionalKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an (existing) trait.
type TheTrait struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// the_trait, a type of flow.
var Zt_TheTrait typeinfo.Flow

// implements typeinfo.Instance
func (*TheTrait) TypeInfo() typeinfo.T {
	return &Zt_TheTrait
}

// implements typeinfo.Markup
func (op *TheTrait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type the_trait
type TheTrait_Slice []TheTrait

// implements typeinfo.Instance
func (*TheTrait_Slice) TypeInfo() typeinfo.T {
	return &Zt_TheTrait
}

// implements typeinfo.Repeats
func (op *TheTrait_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches at least one trait.
type Traits struct {
	TheTrait         TheTrait
	AdditionalTraits *AdditionalTraits
	Markup           map[string]any
}

// traits, a type of flow.
var Zt_Traits typeinfo.Flow

// implements typeinfo.Instance
func (*Traits) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Markup
func (op *Traits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type traits
type Traits_Slice []Traits

// implements typeinfo.Instance
func (*Traits_Slice) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Repeats
func (op *Traits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a trait following another trait
type AdditionalTraits struct {
	CommaAnd *CommaAnd
	Traits   Traits
	Markup   map[string]any
}

// additional_traits, a type of flow.
var Zt_AdditionalTraits typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalTraits) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Markup
func (op *AdditionalTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_traits
type AdditionalTraits_Slice []AdditionalTraits

// implements typeinfo.Instance
func (*AdditionalTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Repeats
func (op *AdditionalTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches one or more predefined words
type Words struct {
	Matched Matched
	Markup  map[string]any
}

// words, a type of flow.
var Zt_Words typeinfo.Flow

// implements typeinfo.Instance
func (*Words) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Markup
func (op *Words) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type words
type Words_Slice []Words

// implements typeinfo.Instance
func (*Words_Slice) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Repeats
func (op *Words_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches one or more predefined verbs
type Verb struct {
	Matched Matched
	Macro   Macro
	Markup  map[string]any
}

// verb, a type of flow.
var Zt_Verb typeinfo.Flow

// implements typeinfo.Instance
func (*Verb) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// implements typeinfo.Markup
func (op *Verb) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb
type Verb_Slice []Verb

// implements typeinfo.Instance
func (*Verb_Slice) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// implements typeinfo.Repeats
func (op *Verb_Slice) Repeats() bool {
	return len(*op) > 0
}

type KindsAreTraits struct {
	Kinds   Kinds
	Are     Are
	Usually Words
	Traits  Traits
	Markup  map[string]any
}

// kinds_are_traits, a type of flow.
var Zt_KindsAreTraits typeinfo.Flow

// implements typeinfo.Instance
func (*KindsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Markup
func (op *KindsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Matches = (*KindsAreTraits)(nil)

// holds a slice of type kinds_are_traits
type KindsAreTraits_Slice []KindsAreTraits

// implements typeinfo.Instance
func (*KindsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Repeats
func (op *KindsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

type VerbPhrase struct {
	Verb   Verb
	Names  Names
	Markup map[string]any
}

// verb_phrase, a type of flow.
var Zt_VerbPhrase typeinfo.Flow

// implements typeinfo.Instance
func (*VerbPhrase) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// implements typeinfo.Markup
func (op *VerbPhrase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb_phrase
type VerbPhrase_Slice []VerbPhrase

// implements typeinfo.Instance
func (*VerbPhrase_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// implements typeinfo.Repeats
func (op *VerbPhrase_Slice) Repeats() bool {
	return len(*op) > 0
}

type NounsTraitsKinds struct {
	Names    Names
	Are      Are
	Traits   *Traits
	CommaAnd *CommaAnd
	Kinds    *Kinds
	Markup   map[string]any
}

// nouns_traits_kinds, a type of flow.
var Zt_NounsTraitsKinds typeinfo.Flow

// implements typeinfo.Instance
func (*NounsTraitsKinds) TypeInfo() typeinfo.T {
	return &Zt_NounsTraitsKinds
}

// implements typeinfo.Markup
func (op *NounsTraitsKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Matches = (*NounsTraitsKinds)(nil)

// holds a slice of type nouns_traits_kinds
type NounsTraitsKinds_Slice []NounsTraitsKinds

// implements typeinfo.Instance
func (*NounsTraitsKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_NounsTraitsKinds
}

// implements typeinfo.Repeats
func (op *NounsTraitsKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

type KindsOf struct {
	Names   Names
	Are     Are
	KindsOf Words
	Traits  *Traits
	TheKind TheKind
	Markup  map[string]any
}

// kinds_of, a type of flow.
var Zt_KindsOf typeinfo.Flow

// implements typeinfo.Instance
func (*KindsOf) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Markup
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Matches = (*KindsOf)(nil)

// holds a slice of type kinds_of
type KindsOf_Slice []KindsOf

// implements typeinfo.Instance
func (*KindsOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Repeats
func (op *KindsOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "jess",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Matched,
	&Zt_Matches,
	&Zt_NameCalled,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Article,
	&Zt_CommaAnd,
	&Zt_Are,
	&Zt_Counted,
	&Zt_TheName,
	&Zt_Called,
	&Zt_Names,
	&Zt_AdditionalNames,
	&Zt_TheKind,
	&Zt_Kinds,
	&Zt_AdditionalKinds,
	&Zt_TheTrait,
	&Zt_Traits,
	&Zt_AdditionalTraits,
	&Zt_Words,
	&Zt_Verb,
	&Zt_KindsAreTraits,
	&Zt_VerbPhrase,
	&Zt_NounsTraitsKinds,
	&Zt_KindsOf,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	12174030489678544826: (*AdditionalKinds)(nil),  /* AdditionalKinds commaAnd:kinds: */
	16975120945491427296: (*AdditionalNames)(nil),  /* AdditionalNames commaAnd:names: */
	508023169458945308:   (*AdditionalTraits)(nil), /* AdditionalTraits commaAnd:traits: */
	1887918947148326916:  (*AdditionalTraits)(nil), /* AdditionalTraits traits: */
	14557216947727331217: (*Are)(nil),              /* Are matched: */
	3899130289676196213:  (*Article)(nil),          /* Article matched: */
	5180090635119408685:  (*CommaAnd)(nil),         /* CommaAnd matched: */
	1185530102945670924:  (*Counted)(nil),          /* Counted number: */
	10421923522043872481: (*Kinds)(nil),            /* Kinds theKind: */
	18280685063133167459: (*Kinds)(nil),            /* Kinds theKind:additionalKinds: */
	2885167070626735883:  (*Names)(nil),            /* Names nameCalled: */
	13348099214983340196: (*Names)(nil),            /* Names nameCalled:additionalNames: */
	12076317517271379796: (*TheKind)(nil),          /* TheKind article:matched: */
	6230264765648121104:  (*TheKind)(nil),          /* TheKind matched: */
	7468431442424932014:  (*TheTrait)(nil),         /* TheTrait article:matched: */
	14778705293893825422: (*TheTrait)(nil),         /* TheTrait matched: */
	11945901594929875297: (*Traits)(nil),           /* Traits theTrait: */
	16728500392330698885: (*Traits)(nil),           /* Traits theTrait:additionalTraits: */
	4698992564801604870:  (*Verb)(nil),             /* Verb matched: */
	17939229312172807626: (*VerbPhrase)(nil),       /* VerbPhrase verb:names: */
	17678340847396548932: (*Words)(nil),            /* Words matched: */
	12822082579973214140: (*Called)(nil),           /* name_called=Called theKind:called:article:matched: */
	15500595481135520776: (*Called)(nil),           /* name_called=Called theKind:called:matched: */
	14842108735299651344: (*KindsAreTraits)(nil),   /* matches=KindsAreTraits kinds:are:usually:traits: */
	17030040669174033088: (*KindsOf)(nil),          /* matches=KindsOf names:are:kindsOf:theKind: */
	12963855546066833119: (*KindsOf)(nil),          /* matches=KindsOf names:are:kindsOf:traits:theKind: */
	3419427774986167184:  (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are: */
	7089760760810957754:  (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:commaAnd: */
	5233850846045406501:  (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:commaAnd:kinds: */
	14150606450452057931: (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:kinds: */
	16839405364450437245: (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:traits: */
	5883225696954482601:  (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:traits:commaAnd: */
	16875727907901245378: (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:traits:commaAnd:kinds: */
	13829425671282372374: (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:traits:kinds: */
	6248925786232291787:  (*TheName)(nil),          /* name_called=TheName article:matched: */
	15540175724772968887: (*TheName)(nil),          /* name_called=TheName matched: */
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Article = typeinfo.Flow{
		Name: "article",
		Lede: "article",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one of a predefined set of determiners:", "the, a, some, etc.", "see 'count' for leading numbers"},
		},
	}
	Zt_CommaAnd = typeinfo.Flow{
		Name: "comma_and",
		Lede: "comma_and",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "conjunction junction",
		},
	}
	Zt_Are = typeinfo.Flow{
		Name: "are",
		Lede: "are",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches \"is\" or \"are\".",
		},
	}
	Zt_Counted = typeinfo.Flow{
		Name: "counted",
		Lede: "counted",
		Terms: []typeinfo.Term{{
			Name:  "number",
			Label: "number",
			Type:  &prim.Zt_Number,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"provides english specification of a number of objects.", "can be used in many places an article can."},
		},
	}
	Zt_TheName = typeinfo.Flow{
		Name: "the_name",
		Lede: "the_name",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "# the match is always implemented as a span.",
			},
			Type: &Zt_Matched,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NameCalled,
		},
		Markup: map[string]any{
			"comment": []interface{}{"matches a name of unknown type", "for nouns, these names may be treated as aliases for existing nouns.", "For example, when matching: \"Gold Roger's treasure chest is a container. The chest is open.\"", "The name \"chest\" implies the treasure chest.", "there are some assumptions for optimizing matching:", "the words \"is/are/comma/and\" are never part of noun names.", "future: allow quoted \"titles\" ( which are then allowed to break those assumptions )", "( see also called )"},
		},
	}
	Zt_Called = typeinfo.Flow{
		Name: "called",
		Lede: "called",
		Terms: []typeinfo.Term{{
			Name:  "the_kind",
			Label: "the_kind",
			Type:  &Zt_TheKind,
		}, {
			Name:  "called",
			Label: "called",
			Markup: map[string]any{
				"comment": "the word \"called\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NameCalled,
		},
		Markup: map[string]any{
			"comment": []interface{}{"called defines a noun and its kind in a single phrase.", "<kind> \"called\" [the] _name_.", "as per inform, the name of the noun is everything after the word called", "until \"is\" or \"are\" or the end of the line.", "For instance: `The container called the trunk and the box is in the lobby`", "generates a single noun named \"the trunk and the box.\""},
		},
	}
	Zt_Names = typeinfo.Flow{
		Name: "names",
		Lede: "names",
		Terms: []typeinfo.Term{{
			Name:  "name_called",
			Label: "name_called",
			Type:  &Zt_NameCalled,
		}, {
			Name:     "additional_names",
			Label:    "additional_names",
			Optional: true,
			Type:     &Zt_AdditionalNames,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches at least one name.", "fix: maybe this should be called \"nouns\" ( and additional nouns )"},
		},
	}
	Zt_AdditionalNames = typeinfo.Flow{
		Name: "additional_names",
		Lede: "additional_names",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "unlike traits, a separator is required between the names of names",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "matches a name following another name.",
		},
	}
	Zt_TheKind = typeinfo.Flow{
		Name: "the_kind",
		Lede: "the_kind",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every kind", "it doesn't influence which kind gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an (existing) kind.",
		},
	}
	Zt_Kinds = typeinfo.Flow{
		Name: "kinds",
		Lede: "kinds",
		Terms: []typeinfo.Term{{
			Name:  "the_kind",
			Label: "the_kind",
			Type:  &Zt_TheKind,
		}, {
			Name:     "additional_kinds",
			Label:    "additional_kinds",
			Optional: true,
			Type:     &Zt_AdditionalKinds,
		}},
		Markup: map[string]any{
			"comment": "matches at least one kind.",
		},
	}
	Zt_AdditionalKinds = typeinfo.Flow{
		Name: "additional_kinds",
		Lede: "additional_kinds",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "unlike traits, a separator is required between the names of kinds",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}},
		Markup: map[string]any{
			"comment": "matches a kind following another kind.",
		},
	}
	Zt_TheTrait = typeinfo.Flow{
		Name: "the_trait",
		Lede: "the_trait",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every trait", "it doesn't influence which trait gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an (existing) trait.",
		},
	}
	Zt_Traits = typeinfo.Flow{
		Name: "traits",
		Lede: "traits",
		Terms: []typeinfo.Term{{
			Name:  "the_trait",
			Label: "the_trait",
			Type:  &Zt_TheTrait,
		}, {
			Name:     "additional_traits",
			Label:    "additional_traits",
			Optional: true,
			Type:     &Zt_AdditionalTraits,
		}},
		Markup: map[string]any{
			"comment": "matches at least one trait.",
		},
	}
	Zt_AdditionalTraits = typeinfo.Flow{
		Name: "additional_traits",
		Lede: "additional_traits",
		Terms: []typeinfo.Term{{
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Type:     &Zt_CommaAnd,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": "matches a trait following another trait",
		},
	}
	Zt_Words = typeinfo.Flow{
		Name: "words",
		Lede: "words",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches one or more predefined words",
		},
	}
	Zt_Verb = typeinfo.Flow{
		Name: "verb",
		Lede: "verb",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}, {
			Name:    "macro",
			Label:   "macro",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": "matches one or more predefined verbs",
		},
	}
	Zt_KindsAreTraits = typeinfo.Flow{
		Name: "kinds_are_traits",
		Lede: "kinds_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "usually",
			Label: "usually",
			Type:  &Zt_Words,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Matches,
		},
		Markup: map[string]any{
			"comment": []interface{}{"assigns default traits to a kind.", "<the kind> are \"usually\" <traits>"},
		},
	}
	Zt_VerbPhrase = typeinfo.Flow{
		Name: "verb_phrase",
		Lede: "verb_phrase",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"ex. \".... in the kitchen.\", or \"... carries the football and sousaphone.\"", "jess expects these names to be nouns", "without traits ( adjectives )"},
		},
	}
	Zt_NounsTraitsKinds = typeinfo.Flow{
		Name: "nouns_traits_kinds",
		Lede: "nouns_traits_kinds",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Type:     &Zt_Traits,
		}, {
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"exists to support phrases like:", "`the box is transparent and a container.`"},
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:     "kinds",
			Label:    "kinds",
			Optional: true,
			Type:     &Zt_Kinds,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Matches,
		},
		Markup: map[string]any{
			"comment": []interface{}{"declares nouns with traits and kinds.", "<names> are <traits> <kinds>.", "ex. `The bottle is a closed container`, and `The bottle is closed.`", "note that although traits and kinds are both optional,", "at least one of the two are required to make a match."},
		},
	}
	Zt_KindsOf = typeinfo.Flow{
		Name: "kinds_of",
		Lede: "kinds_of",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "kinds_of",
			Label: "kinds_of",
			Markup: map[string]any{
				"comment": "the phrases \"a kind of\" or \"kinds of\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform doesnt allow commas or ands here,", "since this definition reuses the traits list: it does allow comma/and."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "the_kind",
			Label: "the_kind",
			Markup: map[string]any{
				"comment": []interface{}{"inform (weirdly) allows multiple kinds:", "`A box is a kind of container and things.`", "but not if traits are specified, suggesting a switch there.", "this doesnt switch to special traits, and doesnt allow multiple kinds."},
			},
			Type: &Zt_TheKind,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Matches,
		},
		Markup: map[string]any{
			"comment": []interface{}{"<names> <are> \"a kind of\"/\"kinds of\" <traits> <kind>.", "interesting to note that inform allows \"some kind/s of\"", "this is more strict.", "like inform this doesn't try to limit the names", "`The animals called kittens are a kind of things.` is legal."},
		},
	}
}
