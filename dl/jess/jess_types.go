// Code generated by Tapestry; edit at your own risk.
package jess

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// matched, a type of slot.
var Zt_Matched = typeinfo.Slot{
	Name: "matched",
	Markup: map[string]any{
		"comment": []interface{}{"a snippet of matching text;", "defined via an interface to allow instances", "to track additional information (ex. db row)."},
	},
}

// holds a single slot.
type Matched_Slot struct{ Value Matched }

// implements typeinfo.Instance for a single slot.
func (*Matched_Slot) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// holds a slice of slots.
type Matched_Slots []Matched

// implements typeinfo.Instance for a series of slots.
func (*Matched_Slots) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// implements typeinfo.Repeats
func (op *Matched_Slots) Repeats() bool {
	return len(*op) > 0
}

// one of a predefined set of determiners:
// the, a, some, etc.
// see 'counted_name' for names with leading numbers.
type Article struct {
	Matched Matched
	Markup  map[string]any
}

// article, a type of flow.
var Zt_Article typeinfo.Flow

// implements typeinfo.Instance
func (*Article) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Markup
func (op *Article) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type article
type Article_Slice []Article

// implements typeinfo.Instance
func (*Article_Slice) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Repeats
func (op *Article_Slice) Repeats() bool {
	return len(*op) > 0
}

// conjunction junction
// matches "," or "and" or ", and"
// relies on the fact package match treats commas and ands each as their own words.
type CommaAnd struct {
	Matched Matched
	Markup  map[string]any
}

// comma_and, a type of flow.
var Zt_CommaAnd typeinfo.Flow

// implements typeinfo.Instance
func (*CommaAnd) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Markup
func (op *CommaAnd) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type comma_and
type CommaAnd_Slice []CommaAnd

// implements typeinfo.Instance
func (*CommaAnd_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Repeats
func (op *CommaAnd_Slice) Repeats() bool {
	return len(*op) > 0
}

// conjunction junction 2.
// matches commas, ands, and ors.
// relies on the fact package match treats commas and ands each as their own words.
type CommaAndOr struct {
	Matched Matched
	Markup  map[string]any
}

// comma_and_or, a type of flow.
var Zt_CommaAndOr typeinfo.Flow

// implements typeinfo.Instance
func (*CommaAndOr) TypeInfo() typeinfo.T {
	return &Zt_CommaAndOr
}

// implements typeinfo.Markup
func (op *CommaAndOr) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type comma_and_or
type CommaAndOr_Slice []CommaAndOr

// implements typeinfo.Instance
func (*CommaAndOr_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAndOr
}

// implements typeinfo.Repeats
func (op *CommaAndOr_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches "is" or "are".
type Are struct {
	Matched Matched
	Markup  map[string]any
}

// are, a type of flow.
var Zt_Are typeinfo.Flow

// implements typeinfo.Instance
func (*Are) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Markup
func (op *Are) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type are
type Are_Slice []Are

// implements typeinfo.Instance
func (*Are_Slice) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Repeats
func (op *Are_Slice) Repeats() bool {
	return len(*op) > 0
}

// Specifies a single name, in full or in part.
// For example, when matching: "Gold Roger's treasure chest is a container. The chest is open."
// The name "chest" implies the treasure chest.
// To optimizing matching the words "is/are/comma/and" are never part of name names.
// future: allow quoted "titles" ( which are then allowed to break those assumptions )
// ( see also 'kind_called' )
type Name struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// name, a type of flow.
var Zt_Name typeinfo.Flow

// implements typeinfo.Instance
func (*Name) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// implements typeinfo.Markup
func (op *Name) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type name
type Name_Slice []Name

// implements typeinfo.Instance
func (*Name_Slice) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// implements typeinfo.Repeats
func (op *Name_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a name and its kind in a single phrase.
// kind "called" [the] _name_.
// as per inform, the name of the name is everything after the word called
// until "is" or "are" or the end of the line.
// For instance: `The container called the trunk and the box is in the lobby`
// generates a single name named "the trunk and the box."
type KindCalled struct {
	Traits     *Traits
	Kind       Kind
	CalledName CalledName
	Markup     map[string]any
}

// kind_called, a type of flow.
var Zt_KindCalled typeinfo.Flow

// implements typeinfo.Instance
func (*KindCalled) TypeInfo() typeinfo.T {
	return &Zt_KindCalled
}

// implements typeinfo.Markup
func (op *KindCalled) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kind_called
type KindCalled_Slice []KindCalled

// implements typeinfo.Instance
func (*KindCalled_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindCalled
}

// implements typeinfo.Repeats
func (op *KindCalled_Slice) Repeats() bool {
	return len(*op) > 0
}

type CalledName struct {
	Called  Words
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// called_name, a type of flow.
var Zt_CalledName typeinfo.Flow

// implements typeinfo.Instance
func (*CalledName) TypeInfo() typeinfo.T {
	return &Zt_CalledName
}

// implements typeinfo.Markup
func (op *CalledName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type called_name
type CalledName_Slice []CalledName

// implements typeinfo.Instance
func (*CalledName_Slice) TypeInfo() typeinfo.T {
	return &Zt_CalledName
}

// implements typeinfo.Repeats
func (op *CalledName_Slice) Repeats() bool {
	return len(*op) > 0
}

// Specifies one or more nouns, in full or in part.
// Only one of the options, plus possibly 'additional_names', will match.
// Not all options are valid in all contexts;
// the users of 'names' may discard or avoid certain matches.
// ( the options could be represented as a slot; this feels easier for now )
type Names struct {
	CountedName     *CountedName
	KindCalled      *KindCalled
	Kind            *Kind
	Name            *Name
	AdditionalNames *AdditionalNames
	Markup          map[string]any
}

// names, a type of flow.
var Zt_Names typeinfo.Flow

// implements typeinfo.Instance
func (*Names) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Markup
func (op *Names) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type names
type Names_Slice []Names

// implements typeinfo.Instance
func (*Names_Slice) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Repeats
func (op *Names_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a name following another name.
type AdditionalNames struct {
	CommaAnd CommaAnd
	Names    Names
	Markup   map[string]any
}

// additional_names, a type of flow.
var Zt_AdditionalNames typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalNames) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Markup
func (op *AdditionalNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_names
type AdditionalNames_Slice []AdditionalNames

// implements typeinfo.Instance
func (*AdditionalNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Repeats
func (op *AdditionalNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// provides english specification of a number of objects.
// note: yes, `the five the containers` is permitted.
type CountedName struct {
	Article        *Article
	MatchingNumber MatchingNumber
	Kind           Kind
	Matched        Matched
	Markup         map[string]any
}

// counted_name, a type of flow.
var Zt_CountedName typeinfo.Flow

// implements typeinfo.Instance
func (*CountedName) TypeInfo() typeinfo.T {
	return &Zt_CountedName
}

// implements typeinfo.Markup
func (op *CountedName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type counted_name
type CountedName_Slice []CountedName

// implements typeinfo.Instance
func (*CountedName_Slice) TypeInfo() typeinfo.T {
	return &Zt_CountedName
}

// implements typeinfo.Repeats
func (op *CountedName_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an existing kind.
type Kind struct {
	Article    *Article
	Matched    Matched
	ActualKind ActualKind
	Markup     map[string]any
}

// kind, a type of flow.
var Zt_Kind typeinfo.Flow

// implements typeinfo.Instance
func (*Kind) TypeInfo() typeinfo.T {
	return &Zt_Kind
}

// implements typeinfo.Markup
func (op *Kind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kind
type Kind_Slice []Kind

// implements typeinfo.Instance
func (*Kind_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kind
}

// implements typeinfo.Repeats
func (op *Kind_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a set of possible kinds as part of kinds_are_traits
// jess tests for but prohibits leading traits.
type Kinds struct {
	Traits          *Traits
	Article         *Article
	Matched         Matched
	AdditionalKinds *AdditionalKinds
	Markup          map[string]any
}

// kinds, a type of flow.
var Zt_Kinds typeinfo.Flow

// implements typeinfo.Instance
func (*Kinds) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Markup
func (op *Kinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds
type Kinds_Slice []Kinds

// implements typeinfo.Instance
func (*Kinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Repeats
func (op *Kinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a kind following another kind.
type AdditionalKinds struct {
	CommaAnd CommaAnd
	Kinds    Kinds
	Markup   map[string]any
}

// additional_kinds, a type of flow.
var Zt_AdditionalKinds typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalKinds) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Markup
func (op *AdditionalKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_kinds
type AdditionalKinds_Slice []AdditionalKinds

// implements typeinfo.Instance
func (*AdditionalKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Repeats
func (op *AdditionalKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of a field in a kind.
type Property struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// property, a type of flow.
var Zt_Property typeinfo.Flow

// implements typeinfo.Instance
func (*Property) TypeInfo() typeinfo.T {
	return &Zt_Property
}

// implements typeinfo.Markup
func (op *Property) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type property
type Property_Slice []Property

// implements typeinfo.Instance
func (*Property_Slice) TypeInfo() typeinfo.T {
	return &Zt_Property
}

// implements typeinfo.Repeats
func (op *Property_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an (existing) trait.
type Trait struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// trait, a type of flow.
var Zt_Trait typeinfo.Flow

// implements typeinfo.Instance
func (*Trait) TypeInfo() typeinfo.T {
	return &Zt_Trait
}

// implements typeinfo.Markup
func (op *Trait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type trait
type Trait_Slice []Trait

// implements typeinfo.Instance
func (*Trait_Slice) TypeInfo() typeinfo.T {
	return &Zt_Trait
}

// implements typeinfo.Repeats
func (op *Trait_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches at least one trait.
type Traits struct {
	Trait            Trait
	AdditionalTraits *AdditionalTraits
	Markup           map[string]any
}

// traits, a type of flow.
var Zt_Traits typeinfo.Flow

// implements typeinfo.Instance
func (*Traits) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Markup
func (op *Traits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type traits
type Traits_Slice []Traits

// implements typeinfo.Instance
func (*Traits_Slice) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Repeats
func (op *Traits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a trait following another trait
type AdditionalTraits struct {
	CommaAnd *CommaAnd
	Traits   Traits
	Markup   map[string]any
}

// additional_traits, a type of flow.
var Zt_AdditionalTraits typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalTraits) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Markup
func (op *AdditionalTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_traits
type AdditionalTraits_Slice []AdditionalTraits

// implements typeinfo.Instance
func (*AdditionalTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Repeats
func (op *AdditionalTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches one or more predefined words
type Words struct {
	Matched Matched
	Markup  map[string]any
}

// words, a type of flow.
var Zt_Words typeinfo.Flow

// implements typeinfo.Instance
func (*Words) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Markup
func (op *Words) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type words
type Words_Slice []Words

// implements typeinfo.Instance
func (*Words_Slice) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Repeats
func (op *Words_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches one or more predefined verbs
type Verb struct {
	Matched Matched
	Macro   Macro
	Markup  map[string]any
}

// verb, a type of flow.
var Zt_Verb typeinfo.Flow

// implements typeinfo.Instance
func (*Verb) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// implements typeinfo.Markup
func (op *Verb) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb
type Verb_Slice []Verb

// implements typeinfo.Instance
func (*Verb_Slice) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// implements typeinfo.Repeats
func (op *Verb_Slice) Repeats() bool {
	return len(*op) > 0
}

// union of all possible matching sentences:
// tests these in-order to find a match.
// ( an alternative would be slots, and a registry; this is fine for now )
type MatchingPhrases struct {
	Understand          Understand
	KindsAreTraits      KindsAreTraits
	KindsOf             KindsOf
	KindsHaveProperties KindsHaveProperties
	KindsAreEither      KindsAreEither
	VerbNamesAreNames   VerbNamesAreNames
	NamesVerbNames      NamesVerbNames
	NamesAreLikeVerbs   NamesAreLikeVerbs
	PropertyNounValue   PropertyNounValue
	NounPropertyValue   NounPropertyValue
	AspectsAreTraits    AspectsAreTraits
	Markup              map[string]any
}

// matching_phrases, a type of flow.
var Zt_MatchingPhrases typeinfo.Flow

// implements typeinfo.Instance
func (*MatchingPhrases) TypeInfo() typeinfo.T {
	return &Zt_MatchingPhrases
}

// implements typeinfo.Markup
func (op *MatchingPhrases) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type matching_phrases
type MatchingPhrases_Slice []MatchingPhrases

// implements typeinfo.Instance
func (*MatchingPhrases_Slice) TypeInfo() typeinfo.T {
	return &Zt_MatchingPhrases
}

// implements typeinfo.Repeats
func (op *MatchingPhrases_Slice) Repeats() bool {
	return len(*op) > 0
}

// names are "a kind of"/"kinds of" traits kind:any.
// interesting to note that inform allows "some kind/s of"
// this is more strict.
// like inform this doesn't try to limit the names
// `The animals called kittens are a kind of things.` is legal.
type KindsOf struct {
	Names   Names
	Are     Are
	KindsOf Words
	Traits  *Traits
	Kind    Kind
	Markup  map[string]any
}

// kinds_of, a type of flow.
var Zt_KindsOf typeinfo.Flow

// implements typeinfo.Instance
func (*KindsOf) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Markup
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_of
type KindsOf_Slice []KindsOf

// implements typeinfo.Instance
func (*KindsOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Repeats
func (op *KindsOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// assigns default traits to a kind.
// kinds:objects are "usually" traits
// inform doesn't require the "usually" --
//
//	i like it as a way to differentiate phrases about kinds vs. phrases about nouns.
//
// future: inform allows limiting traits to kinds with other traits:
// for example, `the closed containers are fixed in place.`
// makes any containers that are *initially* closed also immovable.
type KindsAreTraits struct {
	Kinds   Kinds
	Are     Are
	Usually Words
	Traits  Traits
	Markup  map[string]any
}

// kinds_are_traits, a type of flow.
var Zt_KindsAreTraits typeinfo.Flow

// implements typeinfo.Instance
func (*KindsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Markup
func (op *KindsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_are_traits
type KindsAreTraits_Slice []KindsAreTraits

// implements typeinfo.Instance
func (*KindsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Repeats
func (op *KindsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// defines traits for a kind of aspect.
// aspect are names
// ex. The colors are a kind of aspect. The colors are red, blue, and greasy green.
// aspects_are_traits, kinds_are_traits, and names_are_like_verbs all handle similar phrasing.
// this is limited to a single kind of type aspect and matches plain names (the traits dont exist yet)
type AspectsAreTraits struct {
	Aspect Kind
	Are    Are
	Names  Names
	Markup map[string]any
}

// aspects_are_traits, a type of flow.
var Zt_AspectsAreTraits typeinfo.Flow

// implements typeinfo.Instance
func (*AspectsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_AspectsAreTraits
}

// implements typeinfo.Markup
func (op *AspectsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type aspects_are_traits
type AspectsAreTraits_Slice []AspectsAreTraits

// implements typeinfo.Instance
func (*AspectsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AspectsAreTraits
}

// implements typeinfo.Repeats
func (op *AspectsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// verb names are (other) names.
// ex. `In the coffin are some coins, a notebook, and the gripping hand.`
// This intentionally doesn't recognize adjectives attached to named names.
// "In the closed coffin" generates a name with the name "closed coffin"
// not a coffin in an initially closed state.
type VerbNamesAreNames struct {
	Verb       Verb
	Names      Names
	Are        Are
	OtherNames Names
	Markup     map[string]any
}

// verb_names_are_names, a type of flow.
var Zt_VerbNamesAreNames typeinfo.Flow

// implements typeinfo.Instance
func (*VerbNamesAreNames) TypeInfo() typeinfo.T {
	return &Zt_VerbNamesAreNames
}

// implements typeinfo.Markup
func (op *VerbNamesAreNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb_names_are_names
type VerbNamesAreNames_Slice []VerbNamesAreNames

// implements typeinfo.Instance
func (*VerbNamesAreNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbNamesAreNames
}

// implements typeinfo.Repeats
func (op *VerbNamesAreNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// names are verb (other) names.
// ex. `The thing called the stake is on the supporter called the altar.`
type NamesVerbNames struct {
	Names      Names
	Are        Are
	Verb       Verb
	OtherNames Names
	Markup     map[string]any
}

// names_verb_names, a type of flow.
var Zt_NamesVerbNames typeinfo.Flow

// implements typeinfo.Instance
func (*NamesVerbNames) TypeInfo() typeinfo.T {
	return &Zt_NamesVerbNames
}

// implements typeinfo.Markup
func (op *NamesVerbNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type names_verb_names
type NamesVerbNames_Slice []NamesVerbNames

// implements typeinfo.Instance
func (*NamesVerbNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamesVerbNames
}

// implements typeinfo.Repeats
func (op *NamesVerbNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// names are adjectives [verb names].
// ex. `The bottle is a transparent, open, container.`
// `The coffin is a closed container [in the antechamber]`
// This is the *only* way of assigning names initial states directly.
// All other phrases require a kind to be involved, here the kind is optional.
type NamesAreLikeVerbs struct {
	Names      Names
	Are        Are
	Adjectives Adjectives
	VerbPhrase *VerbPhrase
	Markup     map[string]any
}

// names_are_like_verbs, a type of flow.
var Zt_NamesAreLikeVerbs typeinfo.Flow

// implements typeinfo.Instance
func (*NamesAreLikeVerbs) TypeInfo() typeinfo.T {
	return &Zt_NamesAreLikeVerbs
}

// implements typeinfo.Markup
func (op *NamesAreLikeVerbs) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type names_are_like_verbs
type NamesAreLikeVerbs_Slice []NamesAreLikeVerbs

// implements typeinfo.Instance
func (*NamesAreLikeVerbs_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamesAreLikeVerbs
}

// implements typeinfo.Repeats
func (op *NamesAreLikeVerbs_Slice) Repeats() bool {
	return len(*op) > 0
}

// ex. ".... in the kitchen.", or "... carries the football and sousaphone."
type VerbPhrase struct {
	Verb   Verb
	Names  Names
	Markup map[string]any
}

// verb_phrase, a type of flow.
var Zt_VerbPhrase typeinfo.Flow

// implements typeinfo.Instance
func (*VerbPhrase) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// implements typeinfo.Markup
func (op *VerbPhrase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb_phrase
type VerbPhrase_Slice []VerbPhrase

// implements typeinfo.Instance
func (*VerbPhrase_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// implements typeinfo.Repeats
func (op *VerbPhrase_Slice) Repeats() bool {
	return len(*op) > 0
}

// one or more phrases consisting of traits and a kind.
// while all parts are marked as optional, matching expects
// there will be at least one trait or one kind
// and that there can only be additional adjective phrases
// if the previous one ended with a kind.
// ex. `a container`
//
//	`closed and fixed in place`,
//	`a closed container and a fixed in place thing`.
type Adjectives struct {
	Traits               *Traits
	CommaAnd             *CommaAnd
	Kind                 *Kind
	AdditionalAdjectives *AdditionalAdjectives
	Markup               map[string]any
}

// adjectives, a type of flow.
var Zt_Adjectives typeinfo.Flow

// implements typeinfo.Instance
func (*Adjectives) TypeInfo() typeinfo.T {
	return &Zt_Adjectives
}

// implements typeinfo.Markup
func (op *Adjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type adjectives
type Adjectives_Slice []Adjectives

// implements typeinfo.Instance
func (*Adjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_Adjectives
}

// implements typeinfo.Repeats
func (op *Adjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

// an additional set of traits and a kind
type AdditionalAdjectives struct {
	CommaAnd   CommaAnd
	Adjectives Adjectives
	Markup     map[string]any
}

// additional_adjectives, a type of flow.
var Zt_AdditionalAdjectives typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalAdjectives) TypeInfo() typeinfo.T {
	return &Zt_AdditionalAdjectives
}

// implements typeinfo.Markup
func (op *AdditionalAdjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_adjectives
type AdditionalAdjectives_Slice []AdditionalAdjectives

// implements typeinfo.Instance
func (*AdditionalAdjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalAdjectives
}

// implements typeinfo.Repeats
func (op *AdditionalAdjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

// assigns a default value to a noun.
// ex. `The description of the pen is "mightier than the sword.`
type PropertyNounValue struct {
	Article     *Article
	Property    Property
	Of          Words
	Noun        Name
	Are         Are
	SingleValue SingleValue
	Markup      map[string]any
}

// property_noun_value, a type of flow.
var Zt_PropertyNounValue typeinfo.Flow

// implements typeinfo.Instance
func (*PropertyNounValue) TypeInfo() typeinfo.T {
	return &Zt_PropertyNounValue
}

// implements typeinfo.Markup
func (op *PropertyNounValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type property_noun_value
type PropertyNounValue_Slice []PropertyNounValue

// implements typeinfo.Instance
func (*PropertyNounValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_PropertyNounValue
}

// implements typeinfo.Repeats
func (op *PropertyNounValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// assigns a default value to a noun.
// ex. `The pen has the description "mightier than the sword.`
// like inform, adjectives ( in phrases with "is" ) cannot be combined with property phrases ( "has/of" )
type NounPropertyValue struct {
	Noun        Name
	Has         Words
	Article     *Article
	Property    Property
	Of          *Words
	SingleValue SingleValue
	Markup      map[string]any
}

// noun_property_value, a type of flow.
var Zt_NounPropertyValue typeinfo.Flow

// implements typeinfo.Instance
func (*NounPropertyValue) TypeInfo() typeinfo.T {
	return &Zt_NounPropertyValue
}

// implements typeinfo.Markup
func (op *NounPropertyValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type noun_property_value
type NounPropertyValue_Slice []NounPropertyValue

// implements typeinfo.Instance
func (*NounPropertyValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_NounPropertyValue
}

// implements typeinfo.Repeats
func (op *NounPropertyValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches only one of its options
// ( the options could be represented as a slot; this feels easier for now )
type SingleValue struct {
	QuotedText     *QuotedText
	MatchingNumber *MatchingNumber
	Markup         map[string]any
}

// single_value, a type of flow.
var Zt_SingleValue typeinfo.Flow

// implements typeinfo.Instance
func (*SingleValue) TypeInfo() typeinfo.T {
	return &Zt_SingleValue
}

// implements typeinfo.Markup
func (op *SingleValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type single_value
type SingleValue_Slice []SingleValue

// implements typeinfo.Instance
func (*SingleValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_SingleValue
}

// implements typeinfo.Repeats
func (op *SingleValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// text that begins and ends with double quotes.
// the quotes themselves are not part of the matched text.
type QuotedText struct {
	Matched Matched
	Markup  map[string]any
}

// quoted_text, a type of flow.
var Zt_QuotedText typeinfo.Flow

// implements typeinfo.Instance
func (*QuotedText) TypeInfo() typeinfo.T {
	return &Zt_QuotedText
}

// implements typeinfo.Markup
func (op *QuotedText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type quoted_text
type QuotedText_Slice []QuotedText

// implements typeinfo.Instance
func (*QuotedText_Slice) TypeInfo() typeinfo.T {
	return &Zt_QuotedText
}

// implements typeinfo.Repeats
func (op *QuotedText_Slice) Repeats() bool {
	return len(*op) > 0
}

// reads a number specified in words or as digits.
// stores the result as the parsed number.
type MatchingNumber struct {
	Number float64
	Markup map[string]any
}

// matching_number, a type of flow.
var Zt_MatchingNumber typeinfo.Flow

// implements typeinfo.Instance
func (*MatchingNumber) TypeInfo() typeinfo.T {
	return &Zt_MatchingNumber
}

// implements typeinfo.Markup
func (op *MatchingNumber) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type matching_number
type MatchingNumber_Slice []MatchingNumber

// implements typeinfo.Instance
func (*MatchingNumber_Slice) TypeInfo() typeinfo.T {
	return &Zt_MatchingNumber
}

// implements typeinfo.Repeats
func (op *MatchingNumber_Slice) Repeats() bool {
	return len(*op) > 0
}

// kinds "have" a ["list of"] type ["called a" ...]
// ex. Things have some text called a description.
type KindsHaveProperties struct {
	Kind         Kind
	Have         Words
	Article      *Article
	ListOf       Matched
	PropertyType PropertyType
	CalledName   *CalledName
	Markup       map[string]any
}

// kinds_have_properties, a type of flow.
var Zt_KindsHaveProperties typeinfo.Flow

// implements typeinfo.Instance
func (*KindsHaveProperties) TypeInfo() typeinfo.T {
	return &Zt_KindsHaveProperties
}

// implements typeinfo.Markup
func (op *KindsHaveProperties) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_have_properties
type KindsHaveProperties_Slice []KindsHaveProperties

// implements typeinfo.Instance
func (*KindsHaveProperties_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsHaveProperties
}

// implements typeinfo.Repeats
func (op *KindsHaveProperties_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches text, number, kind ( kind|aspect|record )
// as part of 'kinds_have_properties'
// exactly one member can match
type PropertyType struct {
	Primitive Matched
	Kind      *Kind
	Markup    map[string]any
}

// property_type, a type of flow.
var Zt_PropertyType typeinfo.Flow

// implements typeinfo.Instance
func (*PropertyType) TypeInfo() typeinfo.T {
	return &Zt_PropertyType
}

// implements typeinfo.Markup
func (op *PropertyType) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type property_type
type PropertyType_Slice []PropertyType

// implements typeinfo.Instance
func (*PropertyType_Slice) TypeInfo() typeinfo.T {
	return &Zt_PropertyType
}

// implements typeinfo.Repeats
func (op *PropertyType_Slice) Repeats() bool {
	return len(*op) > 0
}

// kinds ("can be"|"are either") new_trait [or new_trait...]
// ex. A thing can be open or closed.
type KindsAreEither struct {
	Kind   Kind
	CanBe  Words
	Traits NewTrait
	Markup map[string]any
}

// kinds_are_either, a type of flow.
var Zt_KindsAreEither typeinfo.Flow

// implements typeinfo.Instance
func (*KindsAreEither) TypeInfo() typeinfo.T {
	return &Zt_KindsAreEither
}

// implements typeinfo.Markup
func (op *KindsAreEither) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_are_either
type KindsAreEither_Slice []KindsAreEither

// implements typeinfo.Instance
func (*KindsAreEither_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreEither
}

// implements typeinfo.Repeats
func (op *KindsAreEither_Slice) Repeats() bool {
	return len(*op) > 0
}

// one or more new trait names,
// separated by the word "or"
type NewTrait struct {
	Matched  Matched
	NewTrait *NewTrait
	Markup   map[string]any
}

// new_trait, a type of flow.
var Zt_NewTrait typeinfo.Flow

// implements typeinfo.Instance
func (*NewTrait) TypeInfo() typeinfo.T {
	return &Zt_NewTrait
}

// implements typeinfo.Markup
func (op *NewTrait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type new_trait
type NewTrait_Slice []NewTrait

// implements typeinfo.Instance
func (*NewTrait_Slice) TypeInfo() typeinfo.T {
	return &Zt_NewTrait
}

// implements typeinfo.Repeats
func (op *NewTrait_Slice) Repeats() bool {
	return len(*op) > 0
}

// one or more strings of quoted text
// separated by the words "and", "comma", or "or".
type QuotedTexts struct {
	QuotedText     QuotedText
	AdditionalText *AdditionalText
	Markup         map[string]any
}

// quoted_texts, a type of flow.
var Zt_QuotedTexts typeinfo.Flow

// implements typeinfo.Instance
func (*QuotedTexts) TypeInfo() typeinfo.T {
	return &Zt_QuotedTexts
}

// implements typeinfo.Markup
func (op *QuotedTexts) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type quoted_texts
type QuotedTexts_Slice []QuotedTexts

// implements typeinfo.Instance
func (*QuotedTexts_Slice) TypeInfo() typeinfo.T {
	return &Zt_QuotedTexts
}

// implements typeinfo.Repeats
func (op *QuotedTexts_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a text following another some previous text.
type AdditionalText struct {
	CommaAndOr  CommaAndOr
	QuotedTexts QuotedTexts
	Markup      map[string]any
}

// additional_text, a type of flow.
var Zt_AdditionalText typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalText) TypeInfo() typeinfo.T {
	return &Zt_AdditionalText
}

// implements typeinfo.Markup
func (op *AdditionalText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_text
type AdditionalText_Slice []AdditionalText

// implements typeinfo.Instance
func (*AdditionalText_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalText
}

// implements typeinfo.Repeats
func (op *AdditionalText_Slice) Repeats() bool {
	return len(*op) > 0
}

// various phrases, all starting with the word "Understand"
type Understand struct {
	Understand  Words
	QuotedTexts QuotedTexts
	As          Words
	Article     *Article
	PluralOf    Matched
	Names       Names
	Markup      map[string]any
}

// understand, a type of flow.
var Zt_Understand typeinfo.Flow

// implements typeinfo.Instance
func (*Understand) TypeInfo() typeinfo.T {
	return &Zt_Understand
}

// implements typeinfo.Markup
func (op *Understand) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type understand
type Understand_Slice []Understand

// implements typeinfo.Instance
func (*Understand_Slice) TypeInfo() typeinfo.T {
	return &Zt_Understand
}

// implements typeinfo.Repeats
func (op *Understand_Slice) Repeats() bool {
	return len(*op) > 0
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "jess",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Matched,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Article,
	&Zt_CommaAnd,
	&Zt_CommaAndOr,
	&Zt_Are,
	&Zt_Name,
	&Zt_KindCalled,
	&Zt_CalledName,
	&Zt_Names,
	&Zt_AdditionalNames,
	&Zt_CountedName,
	&Zt_Kind,
	&Zt_Kinds,
	&Zt_AdditionalKinds,
	&Zt_Property,
	&Zt_Trait,
	&Zt_Traits,
	&Zt_AdditionalTraits,
	&Zt_Words,
	&Zt_Verb,
	&Zt_MatchingPhrases,
	&Zt_KindsOf,
	&Zt_KindsAreTraits,
	&Zt_AspectsAreTraits,
	&Zt_VerbNamesAreNames,
	&Zt_NamesVerbNames,
	&Zt_NamesAreLikeVerbs,
	&Zt_VerbPhrase,
	&Zt_Adjectives,
	&Zt_AdditionalAdjectives,
	&Zt_PropertyNounValue,
	&Zt_NounPropertyValue,
	&Zt_SingleValue,
	&Zt_QuotedText,
	&Zt_MatchingNumber,
	&Zt_KindsHaveProperties,
	&Zt_PropertyType,
	&Zt_KindsAreEither,
	&Zt_NewTrait,
	&Zt_QuotedTexts,
	&Zt_AdditionalText,
	&Zt_Understand,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	12489206644669467772: (*AdditionalAdjectives)(nil), /* AdditionalAdjectives commaAnd:adjectives: */
	12174030489678544826: (*AdditionalKinds)(nil),      /* AdditionalKinds commaAnd:kinds: */
	16975120945491427296: (*AdditionalNames)(nil),      /* AdditionalNames commaAnd:names: */
	12949801356443185096: (*AdditionalText)(nil),       /* AdditionalText commaAndOr:quotedTexts: */
	508023169458945308:   (*AdditionalTraits)(nil),     /* AdditionalTraits commaAnd:traits: */
	1887918947148326916:  (*AdditionalTraits)(nil),     /* AdditionalTraits traits: */
	10618851046870477413: (*Adjectives)(nil),           /* Adjectives */
	12215120732458766748: (*Adjectives)(nil),           /* Adjectives additionalAdjectives: */
	724420376605497959:   (*Adjectives)(nil),           /* Adjectives commaAnd: */
	17477522713582243508: (*Adjectives)(nil),           /* Adjectives commaAnd:additionalAdjectives: */
	1568830118683768373:  (*Adjectives)(nil),           /* Adjectives commaAnd:kind: */
	7021517372525507842:  (*Adjectives)(nil),           /* Adjectives commaAnd:kind:additionalAdjectives: */
	7663368451290651677:  (*Adjectives)(nil),           /* Adjectives kind: */
	16725271580009929658: (*Adjectives)(nil),           /* Adjectives kind:additionalAdjectives: */
	13544991759812118088: (*Adjectives)(nil),           /* Adjectives traits: */
	13327572087367323885: (*Adjectives)(nil),           /* Adjectives traits:additionalAdjectives: */
	2209109858568160146:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd: */
	11777076077986952519: (*Adjectives)(nil),           /* Adjectives traits:commaAnd:additionalAdjectives: */
	5997117370605758938:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd:kind: */
	5841657992957591039:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd:kind:additionalAdjectives: */
	11552995266309396480: (*Adjectives)(nil),           /* Adjectives traits:kind: */
	8078288476520567765:  (*Adjectives)(nil),           /* Adjectives traits:kind:additionalAdjectives: */
	14557216947727331217: (*Are)(nil),                  /* Are matched: */
	3899130289676196213:  (*Article)(nil),              /* Article matched: */
	2432146112131878337:  (*AspectsAreTraits)(nil),     /* AspectsAreTraits aspect:are:names: */
	4459312168816416564:  (*CalledName)(nil),           /* CalledName called:article:matched: */
	5598625672403523312:  (*CalledName)(nil),           /* CalledName called:matched: */
	5180090635119408685:  (*CommaAnd)(nil),             /* CommaAnd matched: */
	4143979682086652670:  (*CommaAndOr)(nil),           /* CommaAndOr matched: */
	2237036151518779634:  (*CountedName)(nil),          /* CountedName article:matchingNumber:kind: */
	6139323499442568526:  (*CountedName)(nil),          /* CountedName matchingNumber:kind: */
	17839012382227179591: (*Kind)(nil),                 /* Kind article:matched: */
	17757668305058379307: (*Kind)(nil),                 /* Kind matched: */
	14410370178407404046: (*KindCalled)(nil),           /* KindCalled kind:calledName: */
	17999201427714166607: (*KindCalled)(nil),           /* KindCalled traits:kind:calledName: */
	16939996019861136326: (*Kinds)(nil),                /* Kinds article:matched: */
	16946855517465005572: (*Kinds)(nil),                /* Kinds article:matched:additionalKinds: */
	17808071339216334934: (*Kinds)(nil),                /* Kinds matched: */
	17872094200105304436: (*Kinds)(nil),                /* Kinds matched:additionalKinds: */
	4933212495013814755:  (*Kinds)(nil),                /* Kinds traits:article:matched: */
	1182820540821259821:  (*Kinds)(nil),                /* Kinds traits:article:matched:additionalKinds: */
	831875526186841727:   (*Kinds)(nil),                /* Kinds traits:matched: */
	3736619607479472409:  (*Kinds)(nil),                /* Kinds traits:matched:additionalKinds: */
	2480868085776671009:  (*KindsAreEither)(nil),       /* KindsAreEither kind:canBe:traits: */
	8826794343109131276:  (*KindsAreTraits)(nil),       /* KindsAreTraits kinds:are:usually:traits: */
	17116270036433389047: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:listOf:propertyType: */
	17156006172306843757: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:listOf:propertyType:calledName: */
	8108884175448666030:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:propertyType: */
	5228896930769074198:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:propertyType:calledName: */
	2093759548632112131:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:listOf:propertyType: */
	11010766076935860857: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:listOf:propertyType:calledName: */
	13822756587399879234: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:propertyType: */
	8006675921873519578:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:propertyType:calledName: */
	3548848131135117387:  (*KindsOf)(nil),              /* KindsOf names:are:kindsOf:kind: */
	16884802454329910582: (*KindsOf)(nil),              /* KindsOf names:are:kindsOf:traits:kind: */
	5641041111806881294:  (*MatchingNumber)(nil),       /* MatchingNumber number: */
	7194637704405545739:  (*MatchingPhrases)(nil),      /* MatchingPhrases understand:kindsAreTraits:kindsOf:kindsHaveProperties:kindsAreEither:verbNamesAreNames:namesVerbNames:namesAreLikeVerbs:propertyNounValue:nounPropertyValue:aspectsAreTraits: */
	8378947654433865548:  (*Name)(nil),                 /* Name article:matched: */
	6273971456499216312:  (*Name)(nil),                 /* Name matched: */
	7786741787633711023:  (*Names)(nil),                /* Names */
	2651340957450283514:  (*Names)(nil),                /* Names additionalNames: */
	14434599770315422844: (*Names)(nil),                /* Names countedName: */
	9886115040157153195:  (*Names)(nil),                /* Names countedName:additionalNames: */
	5713683783650676748:  (*Names)(nil),                /* Names countedName:kind: */
	11696938860312845211: (*Names)(nil),                /* Names countedName:kind:additionalNames: */
	758506744303684007:   (*Names)(nil),                /* Names countedName:kind:name: */
	14864729949414126072: (*Names)(nil),                /* Names countedName:kind:name:additionalNames: */
	7253272718308834379:  (*Names)(nil),                /* Names countedName:kindCalled: */
	7381532013512958308:  (*Names)(nil),                /* Names countedName:kindCalled:additionalNames: */
	8408184179066850945:  (*Names)(nil),                /* Names countedName:kindCalled:kind: */
	7338366429769939062:  (*Names)(nil),                /* Names countedName:kindCalled:kind:additionalNames: */
	2599493857747890432:  (*Names)(nil),                /* Names countedName:kindCalled:kind:name: */
	6118560200350627847:  (*Names)(nil),                /* Names countedName:kindCalled:kind:name:additionalNames: */
	10095315050340635774: (*Names)(nil),                /* Names countedName:kindCalled:name: */
	12303183222075615441: (*Names)(nil),                /* Names countedName:kindCalled:name:additionalNames: */
	4084573660669905687:  (*Names)(nil),                /* Names countedName:name: */
	4746500019507238408:  (*Names)(nil),                /* Names countedName:name:additionalNames: */
	10083583177877560579: (*Names)(nil),                /* Names kind: */
	10358197305705491068: (*Names)(nil),                /* Names kind:additionalNames: */
	4765472119311194486:  (*Names)(nil),                /* Names kind:name: */
	6827326204135250665:  (*Names)(nil),                /* Names kind:name:additionalNames: */
	17127273420174886912: (*Names)(nil),                /* Names kindCalled: */
	17398615419225362183: (*Names)(nil),                /* Names kindCalled:additionalNames: */
	5709340463761574280:  (*Names)(nil),                /* Names kindCalled:kind: */
	2606241887328501871:  (*Names)(nil),                /* Names kindCalled:kind:additionalNames: */
	14491670955720618019: (*Names)(nil),                /* Names kindCalled:kind:name: */
	6231970138046816860:  (*Names)(nil),                /* Names kindCalled:kind:name:additionalNames: */
	2889757484689352859:  (*Names)(nil),                /* Names kindCalled:name: */
	17641125891389017492: (*Names)(nil),                /* Names kindCalled:name:additionalNames: */
	4500297491524973516:  (*Names)(nil),                /* Names name: */
	17351915174502247643: (*Names)(nil),                /* Names name:additionalNames: */
	9752692754416089114:  (*NamesAreLikeVerbs)(nil),    /* NamesAreLikeVerbs names:are:adjectives: */
	12792661932982325564: (*NamesAreLikeVerbs)(nil),    /* NamesAreLikeVerbs names:are:adjectives:verbPhrase: */
	2930727231635963135:  (*NamesVerbNames)(nil),       /* NamesVerbNames names:are:verb:otherNames: */
	8736862563783456239:  (*NewTrait)(nil),             /* NewTrait matched: */
	8812100125409583293:  (*NewTrait)(nil),             /* NewTrait matched:newTrait: */
	6502702423569934278:  (*NounPropertyValue)(nil),    /* NounPropertyValue noun:has:article:property:of:singleValue: */
	9912988654777640387:  (*NounPropertyValue)(nil),    /* NounPropertyValue noun:has:article:property:singleValue: */
	11825351964218879050: (*NounPropertyValue)(nil),    /* NounPropertyValue noun:has:property:of:singleValue: */
	17930228889254639535: (*NounPropertyValue)(nil),    /* NounPropertyValue noun:has:property:singleValue: */
	11106580022094386190: (*Property)(nil),             /* Property article:matched: */
	7038723543321541230:  (*Property)(nil),             /* Property matched: */
	8361206308538973804:  (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:noun:are:singleValue: */
	7473469395579866548:  (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:noun:are:singleValue: */
	3271806062429822368:  (*PropertyType)(nil),         /* PropertyType */
	11567946081716077320: (*PropertyType)(nil),         /* PropertyType kind: */
	8224056348026199873:  (*PropertyType)(nil),         /* PropertyType primitive: */
	8660980422311242175:  (*PropertyType)(nil),         /* PropertyType primitive:kind: */
	6626169867101049892:  (*QuotedText)(nil),           /* QuotedText matched: */
	15490383194906526516: (*QuotedTexts)(nil),          /* QuotedTexts quotedText: */
	18124669431880345752: (*QuotedTexts)(nil),          /* QuotedTexts quotedText:additionalText: */
	8620010389824513622:  (*SingleValue)(nil),          /* SingleValue */
	747026252029666750:   (*SingleValue)(nil),          /* SingleValue matchingNumber: */
	3958109237643295925:  (*SingleValue)(nil),          /* SingleValue quotedText: */
	17617190106567464055: (*SingleValue)(nil),          /* SingleValue quotedText:matchingNumber: */
	14664763846497769151: (*Trait)(nil),                /* Trait article:matched: */
	12725361887885713715: (*Trait)(nil),                /* Trait matched: */
	2416383336069566114:  (*Traits)(nil),               /* Traits trait: */
	2878025327467574768:  (*Traits)(nil),               /* Traits trait:additionalTraits: */
	15200598710934343751: (*Understand)(nil),           /* Understand understand:quotedTexts:as:article:names: */
	8602404775723907374:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:article:pluralOf:names: */
	4257336208718925827:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:names: */
	1299769703937557498:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:pluralOf:names: */
	4698992564801604870:  (*Verb)(nil),                 /* Verb matched: */
	3016234452937755523:  (*VerbNamesAreNames)(nil),    /* VerbNamesAreNames verb:names:are:otherNames: */
	17939229312172807626: (*VerbPhrase)(nil),           /* VerbPhrase verb:names: */
	17678340847396548932: (*Words)(nil),                /* Words matched: */
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Article = typeinfo.Flow{
		Name: "article",
		Lede: "article",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one of a predefined set of determiners:", "the, a, some, etc.", "see 'counted_name' for names with leading numbers."},
		},
	}
	Zt_CommaAnd = typeinfo.Flow{
		Name: "comma_and",
		Lede: "comma_and",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"conjunction junction", "matches \",\" or \"and\" or \", and\"", "relies on the fact package match treats commas and ands each as their own words."},
		},
	}
	Zt_CommaAndOr = typeinfo.Flow{
		Name: "comma_and_or",
		Lede: "comma_and_or",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"conjunction junction 2.", "matches commas, ands, and ors.", "relies on the fact package match treats commas and ands each as their own words."},
		},
	}
	Zt_Are = typeinfo.Flow{
		Name: "are",
		Lede: "are",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches \"is\" or \"are\".",
		},
	}
	Zt_Name = typeinfo.Flow{
		Name: "name",
		Lede: "name",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Specifies a single name, in full or in part.", "For example, when matching: \"Gold Roger's treasure chest is a container. The chest is open.\"", "The name \"chest\" implies the treasure chest.", "To optimizing matching the words \"is/are/comma/and\" are never part of name names.", "future: allow quoted \"titles\" ( which are then allowed to break those assumptions )", "( see also 'kind_called' )"},
		},
	}
	Zt_KindCalled = typeinfo.Flow{
		Name: "kind_called",
		Lede: "kind_called",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"note: doesn't use 'adjectives' because this doesn't allow", "repetitions of the traits and kind."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "called_name",
			Label: "called_name",
			Type:  &Zt_CalledName,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a name and its kind in a single phrase.", "kind \"called\" [the] _name_.", "as per inform, the name of the name is everything after the word called", "until \"is\" or \"are\" or the end of the line.", "For instance: `The container called the trunk and the box is in the lobby`", "generates a single name named \"the trunk and the box.\""},
		},
	}
	Zt_CalledName = typeinfo.Flow{
		Name: "called_name",
		Lede: "called_name",
		Terms: []typeinfo.Term{{
			Name:  "called",
			Label: "called",
			Markup: map[string]any{
				"comment": "the word \"called\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
	}
	Zt_Names = typeinfo.Flow{
		Name: "names",
		Lede: "names",
		Terms: []typeinfo.Term{{
			Name:     "counted_name",
			Label:    "counted_name",
			Optional: true,
			Type:     &Zt_CountedName,
		}, {
			Name:     "kind_called",
			Label:    "kind_called",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"note: because this phrase is greedy", "once used, no additional names will match."},
			},
			Type: &Zt_KindCalled,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"used primarily for anonymous nouns: \"the container\"", "noting that anonymous nouns are prohibited from starting a sentence."},
			},
			Type: &Zt_Kind,
		}, {
			Name:     "name",
			Label:    "name",
			Optional: true,
			Type:     &Zt_Name,
		}, {
			Name:     "additional_names",
			Label:    "additional_names",
			Optional: true,
			Type:     &Zt_AdditionalNames,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Specifies one or more nouns, in full or in part.", "Only one of the options, plus possibly 'additional_names', will match.", "Not all options are valid in all contexts;", "the users of 'names' may discard or avoid certain matches.", "( the options could be represented as a slot; this feels easier for now )"},
		},
	}
	Zt_AdditionalNames = typeinfo.Flow{
		Name: "additional_names",
		Lede: "additional_names",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "a separator is required between names",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "matches a name following another name.",
		},
	}
	Zt_CountedName = typeinfo.Flow{
		Name: "counted_name",
		Lede: "counted_name",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matching_number",
			Label: "matching_number",
			Type:  &Zt_MatchingNumber,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:    "matched",
			Label:   "matched",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"provides english specification of a number of objects.", "note: yes, `the five the containers` is permitted."},
		},
	}
	Zt_Kind = typeinfo.Flow{
		Name: "kind",
		Lede: "kind",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every kind", "it doesn't influence which kind gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}, {
			Name:    "actual_kind",
			Label:   "actual_kind",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an existing kind.",
		},
	}
	Zt_Kinds = typeinfo.Flow{
		Name: "kinds",
		Lede: "kinds",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform uses traits specified here to select", "matching nouns; jess is not that clever."},
			},
			Type: &Zt_Traits,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "matches a span ending with \"is/are/comma/and\"",
			},
			Type: &Zt_Matched,
		}, {
			Name:     "additional_kinds",
			Label:    "additional_kinds",
			Optional: true,
			Type:     &Zt_AdditionalKinds,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches a set of possible kinds as part of kinds_are_traits", "jess tests for but prohibits leading traits."},
		},
	}
	Zt_AdditionalKinds = typeinfo.Flow{
		Name: "additional_kinds",
		Lede: "additional_kinds",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "a separator is required between the names of kinds",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}},
		Markup: map[string]any{
			"comment": "matches a kind following another kind.",
		},
	}
	Zt_Property = typeinfo.Flow{
		Name: "property",
		Lede: "property",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches the name of a field in a kind.",
		},
	}
	Zt_Trait = typeinfo.Flow{
		Name: "trait",
		Lede: "trait",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every trait", "it doesn't influence which trait gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an (existing) trait.",
		},
	}
	Zt_Traits = typeinfo.Flow{
		Name: "traits",
		Lede: "traits",
		Terms: []typeinfo.Term{{
			Name:  "trait",
			Label: "trait",
			Type:  &Zt_Trait,
		}, {
			Name:     "additional_traits",
			Label:    "additional_traits",
			Optional: true,
			Type:     &Zt_AdditionalTraits,
		}},
		Markup: map[string]any{
			"comment": "matches at least one trait.",
		},
	}
	Zt_AdditionalTraits = typeinfo.Flow{
		Name: "additional_traits",
		Lede: "additional_traits",
		Terms: []typeinfo.Term{{
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Type:     &Zt_CommaAnd,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": "matches a trait following another trait",
		},
	}
	Zt_Words = typeinfo.Flow{
		Name: "words",
		Lede: "words",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches one or more predefined words",
		},
	}
	Zt_Verb = typeinfo.Flow{
		Name: "verb",
		Lede: "verb",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}, {
			Name:    "macro",
			Label:   "macro",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": "matches one or more predefined verbs",
		},
	}
	Zt_MatchingPhrases = typeinfo.Flow{
		Name: "matching_phrases",
		Lede: "matching_phrases",
		Terms: []typeinfo.Term{{
			Name:  "understand",
			Label: "understand",
			Type:  &Zt_Understand,
		}, {
			Name:  "kinds_are_traits",
			Label: "kinds_are_traits",
			Markup: map[string]any{
				"comment": []interface{}{"fix? combine similar starts to speed matching?", "(nothing that the kinds have different filters)"},
			},
			Type: &Zt_KindsAreTraits,
		}, {
			Name:  "kinds_of",
			Label: "kinds_of",
			Type:  &Zt_KindsOf,
		}, {
			Name:  "kinds_have_properties",
			Label: "kinds_have_properties",
			Type:  &Zt_KindsHaveProperties,
		}, {
			Name:  "kinds_are_either",
			Label: "kinds_are_either",
			Type:  &Zt_KindsAreEither,
		}, {
			Name:  "verb_names_are_names",
			Label: "verb_names_are_names",
			Type:  &Zt_VerbNamesAreNames,
		}, {
			Name:  "names_verb_names",
			Label: "names_verb_names",
			Type:  &Zt_NamesVerbNames,
		}, {
			Name:  "names_are_like_verbs",
			Label: "names_are_like_verbs",
			Type:  &Zt_NamesAreLikeVerbs,
		}, {
			Name:  "property_noun_value",
			Label: "property_noun_value",
			Type:  &Zt_PropertyNounValue,
		}, {
			Name:  "noun_property_value",
			Label: "noun_property_value",
			Type:  &Zt_NounPropertyValue,
		}, {
			Name:  "aspects_are_traits",
			Label: "aspects_are_traits",
			Type:  &Zt_AspectsAreTraits,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"union of all possible matching sentences:", "tests these in-order to find a match.", "( an alternative would be slots, and a registry; this is fine for now )"},
		},
	}
	Zt_KindsOf = typeinfo.Flow{
		Name: "kinds_of",
		Lede: "kinds_of",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"a counted name here doesn't indicate multiple kinds", "instead it generates a kind that has a number leading its name."},
			},
			Type: &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "kinds_of",
			Label: "kinds_of",
			Markup: map[string]any{
				"comment": "the phrases \"a kind of\" or \"kinds of\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform doesnt allow commas or ands here,", "jess reuses the traits list here, so it does allow comma/and."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "kind",
			Label: "kind",
			Markup: map[string]any{
				"comment": []interface{}{"inform (weirdly) allows multiple kinds:", "`A box is a kind of container and things.`", "but not if traits are specified, suggesting a switch there.", "this doesnt switch to special traits, and doesnt allow multiple kinds."},
			},
			Type: &Zt_Kind,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"names are \"a kind of\"/\"kinds of\" traits kind:any.", "interesting to note that inform allows \"some kind/s of\"", "this is more strict.", "like inform this doesn't try to limit the names", "`The animals called kittens are a kind of things.` is legal."},
		},
	}
	Zt_KindsAreTraits = typeinfo.Flow{
		Name: "kinds_are_traits",
		Lede: "kinds_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "usually",
			Label: "usually",
			Type:  &Zt_Words,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"assigns default traits to a kind.", "kinds:objects are \"usually\" traits", "inform doesn't require the \"usually\" --", " i like it as a way to differentiate phrases about kinds vs. phrases about nouns.", "future: inform allows limiting traits to kinds with other traits:", "for example, `the closed containers are fixed in place.`", "makes any containers that are *initially* closed also immovable."},
		},
	}
	Zt_AspectsAreTraits = typeinfo.Flow{
		Name: "aspects_are_traits",
		Lede: "aspects_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "aspect",
			Label: "aspect",
			Type:  &Zt_Kind,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": "plain names, no kinds.",
			},
			Type: &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"defines traits for a kind of aspect.", "aspect are names", "ex. The colors are a kind of aspect. The colors are red, blue, and greasy green.", "aspects_are_traits, kinds_are_traits, and names_are_like_verbs all handle similar phrasing.", "this is limited to a single kind of type aspect and matches plain names (the traits dont exist yet)"},
		},
	}
	Zt_VerbNamesAreNames = typeinfo.Flow{
		Name: "verb_names_are_names",
		Lede: "verb_names_are_names",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "other_names",
			Label: "other_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"verb names are (other) names.", "ex. `In the coffin are some coins, a notebook, and the gripping hand.`", "This intentionally doesn't recognize adjectives attached to named names.", "\"In the closed coffin\" generates a name with the name \"closed coffin\"", "not a coffin in an initially closed state."},
		},
	}
	Zt_NamesVerbNames = typeinfo.Flow{
		Name: "names_verb_names",
		Lede: "names_verb_names",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "other_names",
			Label: "other_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"names are verb (other) names.", "ex. `The thing called the stake is on the supporter called the altar.`"},
		},
	}
	Zt_NamesAreLikeVerbs = typeinfo.Flow{
		Name: "names_are_like_verbs",
		Lede: "names_are_like_verbs",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "adjectives",
			Label: "adjectives",
			Markup: map[string]any{
				"comment": []interface{}{"adjectives are *not* optional.", "if there are no adjectives present,", "then 'names_verb_names' (might) match instead."},
			},
			Type: &Zt_Adjectives,
		}, {
			Name:     "verb_phrase",
			Label:    "verb_phrase",
			Optional: true,
			Type:     &Zt_VerbPhrase,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"names are adjectives [verb names].", "ex. `The bottle is a transparent, open, container.`", "`The coffin is a closed container [in the antechamber]`", "This is the *only* way of assigning names initial states directly.", "All other phrases require a kind to be involved, here the kind is optional."},
		},
	}
	Zt_VerbPhrase = typeinfo.Flow{
		Name: "verb_phrase",
		Lede: "verb_phrase",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": "only succeeds on plain names.",
			},
			Type: &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "ex. \".... in the kitchen.\", or \"... carries the football and sousaphone.\"",
		},
	}
	Zt_Adjectives = typeinfo.Flow{
		Name: "adjectives",
		Lede: "adjectives",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Type:     &Zt_Traits,
		}, {
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"exists to support phrases like:", "`the box is transparent and a container.`"},
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Type:     &Zt_Kind,
		}, {
			Name:     "additional_adjectives",
			Label:    "additional_adjectives",
			Optional: true,
			Type:     &Zt_AdditionalAdjectives,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one or more phrases consisting of traits and a kind.", "while all parts are marked as optional, matching expects", "there will be at least one trait or one kind", "and that there can only be additional adjective phrases", "if the previous one ended with a kind.", "ex. `a container`", "    `closed and fixed in place`,", "    `a closed container and a fixed in place thing`."},
		},
	}
	Zt_AdditionalAdjectives = typeinfo.Flow{
		Name: "additional_adjectives",
		Lede: "additional_adjectives",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Type:  &Zt_CommaAnd,
		}, {
			Name:  "adjectives",
			Label: "adjectives",
			Type:  &Zt_Adjectives,
		}},
		Markup: map[string]any{
			"comment": "an additional set of traits and a kind",
		},
	}
	Zt_PropertyNounValue = typeinfo.Flow{
		Name: "property_noun_value",
		Lede: "property_noun_value",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "property",
			Label: "property",
			Type:  &Zt_Property,
		}, {
			Name:  "of",
			Label: "of",
			Markup: map[string]any{
				"comment": "the word \"of\"",
			},
			Type: &Zt_Words,
		}, {
			Name:  "noun",
			Label: "noun",
			Markup: map[string]any{
				"comment": "note: \"called the\" isn't allowed here.",
			},
			Type: &Zt_Name,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "single_value",
			Label: "single_value",
			Type:  &Zt_SingleValue,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"assigns a default value to a noun.", "ex. `The description of the pen is \"mightier than the sword.`"},
		},
	}
	Zt_NounPropertyValue = typeinfo.Flow{
		Name: "noun_property_value",
		Lede: "noun_property_value",
		Terms: []typeinfo.Term{{
			Name:  "noun",
			Label: "noun",
			Markup: map[string]any{
				"comment": "note: \"called the\" isn't allowed here.",
			},
			Type: &Zt_Name,
		}, {
			Name:  "has",
			Label: "has",
			Markup: map[string]any{
				"comment": "the word \"has\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "property",
			Label: "property",
			Type:  &Zt_Property,
		}, {
			Name:     "of",
			Label:    "of",
			Optional: true,
			Markup: map[string]any{
				"comment": "the word \"of\", sometimes reads better this way",
			},
			Type: &Zt_Words,
		}, {
			Name:  "single_value",
			Label: "single_value",
			Type:  &Zt_SingleValue,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"assigns a default value to a noun.", "ex. `The pen has the description \"mightier than the sword.`", "like inform, adjectives ( in phrases with \"is\" ) cannot be combined with property phrases ( \"has/of\" )"},
		},
	}
	Zt_SingleValue = typeinfo.Flow{
		Name: "single_value",
		Lede: "single_value",
		Terms: []typeinfo.Term{{
			Name:     "quoted_text",
			Label:    "quoted_text",
			Optional: true,
			Type:     &Zt_QuotedText,
		}, {
			Name:     "matching_number",
			Label:    "matching_number",
			Optional: true,
			Type:     &Zt_MatchingNumber,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches only one of its options", "( the options could be represented as a slot; this feels easier for now )"},
		},
	}
	Zt_QuotedText = typeinfo.Flow{
		Name: "quoted_text",
		Lede: "quoted_text",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"text that begins and ends with double quotes.", "the quotes themselves are not part of the matched text."},
		},
	}
	Zt_MatchingNumber = typeinfo.Flow{
		Name: "matching_number",
		Lede: "matching_number",
		Terms: []typeinfo.Term{{
			Name:  "number",
			Label: "number",
			Type:  &prim.Zt_Number,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"reads a number specified in words or as digits.", "stores the result as the parsed number."},
		},
	}
	Zt_KindsHaveProperties = typeinfo.Flow{
		Name: "kinds_have_properties",
		Lede: "kinds_have_properties",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "have",
			Label: "have",
			Type:  &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:     "list_of",
			Label:    "list_of",
			Optional: true,
			Type:     &Zt_Matched,
		}, {
			Name:  "property_type",
			Label: "property_type",
			Type:  &Zt_PropertyType,
		}, {
			Name:     "called_name",
			Label:    "called_name",
			Optional: true,
			Type:     &Zt_CalledName,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"kinds \"have\" a [\"list of\"] type [\"called a\" ...]", "ex. Things have some text called a description."},
		},
	}
	Zt_PropertyType = typeinfo.Flow{
		Name: "property_type",
		Lede: "property_type",
		Terms: []typeinfo.Term{{
			Name:     "primitive",
			Label:    "primitive",
			Optional: true,
			Type:     &Zt_Matched,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": "kinds|aspects|records",
			},
			Type: &Zt_Kind,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches text, number, kind ( kind|aspect|record )", "as part of 'kinds_have_properties'", "exactly one member can match"},
		},
	}
	Zt_KindsAreEither = typeinfo.Flow{
		Name: "kinds_are_either",
		Lede: "kinds_are_either",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "can_be",
			Label: "can_be",
			Type:  &Zt_Words,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_NewTrait,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"kinds (\"can be\"|\"are either\") new_trait [or new_trait...]", "ex. A thing can be open or closed."},
		},
	}
	Zt_NewTrait = typeinfo.Flow{
		Name: "new_trait",
		Lede: "new_trait",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}, {
			Name:     "new_trait",
			Label:    "new_trait",
			Optional: true,
			Type:     &Zt_NewTrait,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one or more new trait names,", "separated by the word \"or\""},
		},
	}
	Zt_QuotedTexts = typeinfo.Flow{
		Name: "quoted_texts",
		Lede: "quoted_texts",
		Terms: []typeinfo.Term{{
			Name:  "quoted_text",
			Label: "quoted_text",
			Type:  &Zt_QuotedText,
		}, {
			Name:     "additional_text",
			Label:    "additional_text",
			Optional: true,
			Type:     &Zt_AdditionalText,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one or more strings of quoted text", "separated by the words \"and\", \"comma\", or \"or\"."},
		},
	}
	Zt_AdditionalText = typeinfo.Flow{
		Name: "additional_text",
		Lede: "additional_text",
		Terms: []typeinfo.Term{{
			Name:  "comma_and_or",
			Label: "comma_and_or",
			Type:  &Zt_CommaAndOr,
		}, {
			Name:  "quoted_texts",
			Label: "quoted_texts",
			Type:  &Zt_QuotedTexts,
		}},
		Markup: map[string]any{
			"comment": "matches a text following another some previous text.",
		},
	}
	Zt_Understand = typeinfo.Flow{
		Name: "understand",
		Lede: "understand",
		Terms: []typeinfo.Term{{
			Name:  "understand",
			Label: "understand",
			Type:  &Zt_Words,
		}, {
			Name:  "quoted_texts",
			Label: "quoted_texts",
			Markup: map[string]any{
				"comment": "all of jess's understand start with quoted text",
			},
			Type: &Zt_QuotedTexts,
		}, {
			Name:  "as",
			Label: "as",
			Type:  &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform is smart enough to *not* allow articles before actions.", "i am lazy."},
			},
			Type: &Zt_Article,
		}, {
			Name:     "plural_of",
			Label:    "plural_of",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"ex. Understand \"birds\" and \"ruddy ducks\" as the plural of duck.", "fix? in jess this (also) influences the story interpretation."},
			},
			Type: &Zt_Matched,
		}, {
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"this matches one or more nouns or kinds:", "generation susses out what to do with those nouns or kinds.", "* aliases for nouns: Understand \"floor\" or \"sawdust\" as the message.", "* aliases for kinds: Understand \"cupboard\" or \"cupboards\" or \"cabinets\" as a cabinet.", "* grammar for actions: Understand \"reach underneath/under/beneath/-- [something]\" as looking under.", "jess doesn't permit aliases for kinds, those generate errors."},
			},
			Type: &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "various phrases, all starting with the word \"Understand\"",
		},
	}
}
