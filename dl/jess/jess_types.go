// Code generated by Tapestry; edit at your own risk.
package jess

import (
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// matched, a type of slot.
var Zt_Matched = typeinfo.Slot{
	Name: "matched",
	Markup: map[string]any{
		"comment": []interface{}{"a snippet of matching text;", "defined via an interface to allow instances", "to track additional information (ex. db row)."},
	},
}

// holds a single slot.
type Matched_Slot struct{ Value Matched }

// implements typeinfo.Instance for a single slot.
func (*Matched_Slot) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// holds a slice of slots.
type Matched_Slots []Matched

// implements typeinfo.Instance for a series of slots.
func (*Matched_Slots) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// implements typeinfo.Repeats
func (op *Matched_Slots) Repeats() bool {
	return len(*op) > 0
}

// matches, a type of slot.
var Zt_Matches = typeinfo.Slot{
	Name: "matches",
	Markup: map[string]any{
		"comment": "the root of a sentence matching tree.",
	},
}

// holds a single slot.
type Matches_Slot struct{ Value Matches }

// implements typeinfo.Instance for a single slot.
func (*Matches_Slot) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// holds a slice of slots.
type Matches_Slots []Matches

// implements typeinfo.Instance for a series of slots.
func (*Matches_Slots) TypeInfo() typeinfo.T {
	return &Zt_Matches
}

// implements typeinfo.Repeats
func (op *Matches_Slots) Repeats() bool {
	return len(*op) > 0
}

type Article struct {
	Matched Matched
	Markup  map[string]any
}

// article, a type of flow.
var Zt_Article typeinfo.Flow

// implements typeinfo.Instance
func (*Article) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Markup
func (op *Article) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type article
type Article_Slice []Article

// implements typeinfo.Instance
func (*Article_Slice) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Repeats
func (op *Article_Slice) Repeats() bool {
	return len(*op) > 0
}

// conjunction junction
type CommaAnd struct {
	Matched Matched
	Markup  map[string]any
}

// comma_and, a type of flow.
var Zt_CommaAnd typeinfo.Flow

// implements typeinfo.Instance
func (*CommaAnd) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Markup
func (op *CommaAnd) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type comma_and
type CommaAnd_Slice []CommaAnd

// implements typeinfo.Instance
func (*CommaAnd_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Repeats
func (op *CommaAnd_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches "is" or "are".
type Are struct {
	Matched Matched
	Markup  map[string]any
}

// are, a type of flow.
var Zt_Are typeinfo.Flow

// implements typeinfo.Instance
func (*Are) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Markup
func (op *Are) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type are
type Are_Slice []Are

// implements typeinfo.Instance
func (*Are_Slice) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Repeats
func (op *Are_Slice) Repeats() bool {
	return len(*op) > 0
}

type Name struct {
	Matched Matched
	Markup  map[string]any
}

// name, a type of flow.
var Zt_Name typeinfo.Flow

// implements typeinfo.Instance
func (*Name) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// implements typeinfo.Markup
func (op *Name) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type name
type Name_Slice []Name

// implements typeinfo.Instance
func (*Name_Slice) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// implements typeinfo.Repeats
func (op *Name_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches at least one name.
type Names struct {
	Article         *Article
	Name            Name
	AdditionalNames *AdditionalNames
	Markup          map[string]any
}

// names, a type of flow.
var Zt_Names typeinfo.Flow

// implements typeinfo.Instance
func (*Names) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Markup
func (op *Names) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type names
type Names_Slice []Names

// implements typeinfo.Instance
func (*Names_Slice) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Repeats
func (op *Names_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a name following another name.
type AdditionalNames struct {
	CommaAnd CommaAnd
	Names    Names
	Markup   map[string]any
}

// additional_names, a type of flow.
var Zt_AdditionalNames typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalNames) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Markup
func (op *AdditionalNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_names
type AdditionalNames_Slice []AdditionalNames

// implements typeinfo.Instance
func (*AdditionalNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Repeats
func (op *AdditionalNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an (existing) kind.
type NamedKind struct {
	Matched Matched
	Markup  map[string]any
}

// named_kind, a type of flow.
var Zt_NamedKind typeinfo.Flow

// implements typeinfo.Instance
func (*NamedKind) TypeInfo() typeinfo.T {
	return &Zt_NamedKind
}

// implements typeinfo.Markup
func (op *NamedKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type named_kind
type NamedKind_Slice []NamedKind

// implements typeinfo.Instance
func (*NamedKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamedKind
}

// implements typeinfo.Repeats
func (op *NamedKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches at least one kind.
type Kinds struct {
	Article         *Article
	NamedKind       NamedKind
	AdditionalKinds *AdditionalKinds
	Markup          map[string]any
}

// kinds, a type of flow.
var Zt_Kinds typeinfo.Flow

// implements typeinfo.Instance
func (*Kinds) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Markup
func (op *Kinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds
type Kinds_Slice []Kinds

// implements typeinfo.Instance
func (*Kinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Repeats
func (op *Kinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a kind following another kind.
type AdditionalKinds struct {
	CommaAnd CommaAnd
	Kinds    Kinds
	Markup   map[string]any
}

// additional_kinds, a type of flow.
var Zt_AdditionalKinds typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalKinds) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Markup
func (op *AdditionalKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_kinds
type AdditionalKinds_Slice []AdditionalKinds

// implements typeinfo.Instance
func (*AdditionalKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Repeats
func (op *AdditionalKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an (existing) trait.
type NamedTrait struct {
	Matched Matched
	Markup  map[string]any
}

// named_trait, a type of flow.
var Zt_NamedTrait typeinfo.Flow

// implements typeinfo.Instance
func (*NamedTrait) TypeInfo() typeinfo.T {
	return &Zt_NamedTrait
}

// implements typeinfo.Markup
func (op *NamedTrait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type named_trait
type NamedTrait_Slice []NamedTrait

// implements typeinfo.Instance
func (*NamedTrait_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamedTrait
}

// implements typeinfo.Repeats
func (op *NamedTrait_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches at least one trait.
type Traits struct {
	Article          *Article
	NamedTrait       NamedTrait
	AdditionalTraits *AdditionalTraits
	Markup           map[string]any
}

// traits, a type of flow.
var Zt_Traits typeinfo.Flow

// implements typeinfo.Instance
func (*Traits) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Markup
func (op *Traits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type traits
type Traits_Slice []Traits

// implements typeinfo.Instance
func (*Traits_Slice) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Repeats
func (op *Traits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a trait following another trait
type AdditionalTraits struct {
	CommaAnd *CommaAnd
	Traits   Traits
	Markup   map[string]any
}

// additional_traits, a type of flow.
var Zt_AdditionalTraits typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalTraits) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Markup
func (op *AdditionalTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_traits
type AdditionalTraits_Slice []AdditionalTraits

// implements typeinfo.Instance
func (*AdditionalTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Repeats
func (op *AdditionalTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

type Keywords struct {
	Matched Matched
	Markup  map[string]any
}

// keywords, a type of flow.
var Zt_Keywords typeinfo.Flow

// implements typeinfo.Instance
func (*Keywords) TypeInfo() typeinfo.T {
	return &Zt_Keywords
}

// implements typeinfo.Markup
func (op *Keywords) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type keywords
type Keywords_Slice []Keywords

// implements typeinfo.Instance
func (*Keywords_Slice) TypeInfo() typeinfo.T {
	return &Zt_Keywords
}

// implements typeinfo.Repeats
func (op *Keywords_Slice) Repeats() bool {
	return len(*op) > 0
}

type MacroName struct {
	Matched Matched
	Macro   Macro
	Markup  map[string]any
}

// macro_name, a type of flow.
var Zt_MacroName typeinfo.Flow

// implements typeinfo.Instance
func (*MacroName) TypeInfo() typeinfo.T {
	return &Zt_MacroName
}

// implements typeinfo.Markup
func (op *MacroName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type macro_name
type MacroName_Slice []MacroName

// implements typeinfo.Instance
func (*MacroName_Slice) TypeInfo() typeinfo.T {
	return &Zt_MacroName
}

// implements typeinfo.Repeats
func (op *MacroName_Slice) Repeats() bool {
	return len(*op) > 0
}

type KindsAreTraits struct {
	Kinds   Kinds
	Are     Are
	Usually MacroName
	Traits  Traits
	Markup  map[string]any
}

// kinds_are_traits, a type of flow.
var Zt_KindsAreTraits typeinfo.Flow

// implements typeinfo.Instance
func (*KindsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Markup
func (op *KindsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Matches = (*KindsAreTraits)(nil)

// holds a slice of type kinds_are_traits
type KindsAreTraits_Slice []KindsAreTraits

// implements typeinfo.Instance
func (*KindsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Repeats
func (op *KindsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

type NounsTraitsKinds struct {
	Names  Names
	Are    Are
	Traits *Traits
	Kinds  *Kinds
	Markup map[string]any
}

// nouns_traits_kinds, a type of flow.
var Zt_NounsTraitsKinds typeinfo.Flow

// implements typeinfo.Instance
func (*NounsTraitsKinds) TypeInfo() typeinfo.T {
	return &Zt_NounsTraitsKinds
}

// implements typeinfo.Markup
func (op *NounsTraitsKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ Matches = (*NounsTraitsKinds)(nil)

// holds a slice of type nouns_traits_kinds
type NounsTraitsKinds_Slice []NounsTraitsKinds

// implements typeinfo.Instance
func (*NounsTraitsKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_NounsTraitsKinds
}

// implements typeinfo.Repeats
func (op *NounsTraitsKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "jess",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Matched,
	&Zt_Matches,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Article,
	&Zt_CommaAnd,
	&Zt_Are,
	&Zt_Name,
	&Zt_Names,
	&Zt_AdditionalNames,
	&Zt_NamedKind,
	&Zt_Kinds,
	&Zt_AdditionalKinds,
	&Zt_NamedTrait,
	&Zt_Traits,
	&Zt_AdditionalTraits,
	&Zt_Keywords,
	&Zt_MacroName,
	&Zt_KindsAreTraits,
	&Zt_NounsTraitsKinds,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	12174030489678544826: (*AdditionalKinds)(nil),  /* AdditionalKinds commaAnd:kinds: */
	16975120945491427296: (*AdditionalNames)(nil),  /* AdditionalNames commaAnd:names: */
	508023169458945308:   (*AdditionalTraits)(nil), /* AdditionalTraits commaAnd:traits: */
	1887918947148326916:  (*AdditionalTraits)(nil), /* AdditionalTraits traits: */
	503552734697422485:   (*Are)(nil),              /* Are: */
	8854300316672007225:  (*Article)(nil),          /* Article: */
	4230553755039810705:  (*CommaAnd)(nil),         /* CommaAnd: */
	3748071630827580029:  (*Keywords)(nil),         /* Keywords: */
	906205099353614907:   (*Kinds)(nil),            /* Kinds article:namedKind: */
	13757561154068086581: (*Kinds)(nil),            /* Kinds article:namedKind:additionalKinds: */
	5500689320692290603:  (*Kinds)(nil),            /* Kinds namedKind: */
	3201719486692867525:  (*Kinds)(nil),            /* Kinds namedKind:additionalKinds: */
	15972029076576488422: (*MacroName)(nil),        /* MacroName: */
	7786819852959314004:  (*Name)(nil),             /* Name: */
	7841004129963498806:  (*NamedKind)(nil),        /* NamedKind: */
	10153339211572068944: (*NamedTrait)(nil),       /* NamedTrait: */
	10073336598044816960: (*Names)(nil),            /* Names article:name: */
	15330476688882292167: (*Names)(nil),            /* Names article:name:additionalNames: */
	4500297491524973516:  (*Names)(nil),            /* Names name: */
	17351915174502247643: (*Names)(nil),            /* Names name:additionalNames: */
	5152227064767964907:  (*Traits)(nil),           /* Traits article:namedTrait: */
	9701794894107240735:  (*Traits)(nil),           /* Traits article:namedTrait:additionalTraits: */
	931939769765876491:   (*Traits)(nil),           /* Traits namedTrait: */
	15792725219640924031: (*Traits)(nil),           /* Traits namedTrait:additionalTraits: */
	14842108735299651344: (*KindsAreTraits)(nil),   /* matches=KindsAreTraits kinds:are:usually:traits: */
	3419427774986167184:  (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are: */
	14150606450452057931: (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:kinds: */
	16839405364450437245: (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:traits: */
	13829425671282372374: (*NounsTraitsKinds)(nil), /* matches=NounsTraitsKinds names:are:traits:kinds: */
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Article = typeinfo.Flow{
		Name: "article",
		Lede: "article",
		Terms: []typeinfo.Term{{
			Name: "matched",
			Type: &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one of a predefined set of determiners:", "the, a, some, etc.", "see 'count' for leading numbers"},
		},
	}
	Zt_CommaAnd = typeinfo.Flow{
		Name: "comma_and",
		Lede: "comma_and",
		Terms: []typeinfo.Term{{
			Name: "matched",
			Type: &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "conjunction junction",
		},
	}
	Zt_Are = typeinfo.Flow{
		Name: "are",
		Lede: "are",
		Terms: []typeinfo.Term{{
			Name: "matched",
			Type: &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches \"is\" or \"are\".",
		},
	}
	Zt_Name = typeinfo.Flow{
		Name: "name",
		Lede: "name",
		Terms: []typeinfo.Term{{
			Name: "matched",
			Markup: map[string]any{
				"comment": "the matched type is always a span.",
			},
			Type: &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches a name of unknown type ( usually nouns... )", "there are some assumptions for optimization:", "the words \"is/are/comma/and\" are never part of noun names.", "future: allow quoted \"titles\" ( which are then allowed to break those assumptions )"},
		},
	}
	Zt_Names = typeinfo.Flow{
		Name: "names",
		Lede: "names",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "name",
			Label: "name",
			Type:  &Zt_Name,
		}, {
			Name:     "additional_names",
			Label:    "additional_names",
			Optional: true,
			Type:     &Zt_AdditionalNames,
		}},
		Markup: map[string]any{
			"comment": "matches at least one name.",
		},
	}
	Zt_AdditionalNames = typeinfo.Flow{
		Name: "additional_names",
		Lede: "additional_names",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "unlike traits, a separator is required between the names of names",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "matches a name following another name.",
		},
	}
	Zt_NamedKind = typeinfo.Flow{
		Name: "named_kind",
		Lede: "named_kind",
		Terms: []typeinfo.Term{{
			Name: "matched",
			Type: &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an (existing) kind.",
		},
	}
	Zt_Kinds = typeinfo.Flow{
		Name: "kinds",
		Lede: "kinds",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every kind", "it doesn't influence which kind gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "named_kind",
			Label: "named_kind",
			Type:  &Zt_NamedKind,
		}, {
			Name:     "additional_kinds",
			Label:    "additional_kinds",
			Optional: true,
			Type:     &Zt_AdditionalKinds,
		}},
		Markup: map[string]any{
			"comment": "matches at least one kind.",
		},
	}
	Zt_AdditionalKinds = typeinfo.Flow{
		Name: "additional_kinds",
		Lede: "additional_kinds",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "unlike traits, a separator is required between the names of kinds",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}},
		Markup: map[string]any{
			"comment": "matches a kind following another kind.",
		},
	}
	Zt_NamedTrait = typeinfo.Flow{
		Name: "named_trait",
		Lede: "named_trait",
		Terms: []typeinfo.Term{{
			Name: "matched",
			Type: &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an (existing) trait.",
		},
	}
	Zt_Traits = typeinfo.Flow{
		Name: "traits",
		Lede: "traits",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every trait", "it doesn't influence which trait gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "named_trait",
			Label: "named_trait",
			Type:  &Zt_NamedTrait,
		}, {
			Name:     "additional_traits",
			Label:    "additional_traits",
			Optional: true,
			Type:     &Zt_AdditionalTraits,
		}},
		Markup: map[string]any{
			"comment": "matches at least one trait.",
		},
	}
	Zt_AdditionalTraits = typeinfo.Flow{
		Name: "additional_traits",
		Lede: "additional_traits",
		Terms: []typeinfo.Term{{
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Type:     &Zt_CommaAnd,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": "matches a trait following another trait",
		},
	}
	Zt_Keywords = typeinfo.Flow{
		Name: "keywords",
		Lede: "keywords",
		Terms: []typeinfo.Term{{
			Name: "matched",
			Type: &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches one or more predefined words", "the specific words are specified via metadata", "on the term where this flow is declared."},
		},
	}
	Zt_MacroName = typeinfo.Flow{
		Name: "macro_name",
		Lede: "macro_name",
		Terms: []typeinfo.Term{{
			Name: "matched",
			Type: &Zt_Matched,
		}, {
			Name:    "macro",
			Label:   "macro",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches one or more predefined words", "and returns a macro. like keywords", "the phrase and macro are on defined via metadata"},
		},
	}
	Zt_KindsAreTraits = typeinfo.Flow{
		Name: "kinds_are_traits",
		Lede: "kinds_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "usually",
			Label: "usually",
			Markup: map[string]any{
				"comment": "always the \"implies\" macro",
				"phrase":  "usually",
			},
			Type: &Zt_MacroName,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Matches,
		},
		Markup: map[string]any{
			"comment": []interface{}{"assigns default traits to a kind.", "[the] <kind> are \"usually\" <traits>"},
		},
	}
	Zt_NounsTraitsKinds = typeinfo.Flow{
		Name: "nouns_traits_kinds",
		Lede: "nouns_traits_kinds",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Type:     &Zt_Traits,
		}, {
			Name:     "kinds",
			Label:    "kinds",
			Optional: true,
			Type:     &Zt_Kinds,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_Matches,
		},
		Markup: map[string]any{
			"comment": []interface{}{"declares nouns with traits and kinds.", "[the] <nouns> are <traits> <kinds>", "although traits and kinds are both optional,", "at least one is required to match"},
		},
	}
}
