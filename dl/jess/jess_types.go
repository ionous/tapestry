// Code generated by Tapestry; edit at your own risk.
package jess

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// matched, a type of slot.
var Zt_Matched = typeinfo.Slot{
	Name: "matched",
	Markup: map[string]any{
		"comment": []interface{}{"a snippet of matching text;", "defined via an interface to allow instances", "to track additional information (ex. db row)."},
	},
}

// holds a single slot.
type Matched_Slot struct{ Value Matched }

// implements typeinfo.Instance for a single slot.
func (*Matched_Slot) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// holds a slice of slots.
type Matched_Slots []Matched

// implements typeinfo.Instance for a series of slots.
func (*Matched_Slots) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// implements typeinfo.Repeats
func (op *Matched_Slots) Repeats() bool {
	return len(*op) > 0
}

type Article struct {
	Matched Matched
	Markup  map[string]any
}

// article, a type of flow.
var Zt_Article typeinfo.Flow

// implements typeinfo.Instance
func (*Article) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Markup
func (op *Article) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type article
type Article_Slice []Article

// implements typeinfo.Instance
func (*Article_Slice) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Repeats
func (op *Article_Slice) Repeats() bool {
	return len(*op) > 0
}

type CommaAnd struct {
	Matched Matched
	Markup  map[string]any
}

// comma_and, a type of flow.
var Zt_CommaAnd typeinfo.Flow

// implements typeinfo.Instance
func (*CommaAnd) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Markup
func (op *CommaAnd) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type comma_and
type CommaAnd_Slice []CommaAnd

// implements typeinfo.Instance
func (*CommaAnd_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Repeats
func (op *CommaAnd_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches "is" or "are".
type Are struct {
	Matched Matched
	Markup  map[string]any
}

// are, a type of flow.
var Zt_Are typeinfo.Flow

// implements typeinfo.Instance
func (*Are) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Markup
func (op *Are) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type are
type Are_Slice []Are

// implements typeinfo.Instance
func (*Are_Slice) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Repeats
func (op *Are_Slice) Repeats() bool {
	return len(*op) > 0
}

type Name struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// name, a type of flow.
var Zt_Name typeinfo.Flow

// implements typeinfo.Instance
func (*Name) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// implements typeinfo.Markup
func (op *Name) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type name
type Name_Slice []Name

// implements typeinfo.Instance
func (*Name_Slice) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// implements typeinfo.Repeats
func (op *Name_Slice) Repeats() bool {
	return len(*op) > 0
}

type KindCalled struct {
	Traits  *Traits
	Kind    Kind
	Called  Words
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// kind_called, a type of flow.
var Zt_KindCalled typeinfo.Flow

// implements typeinfo.Instance
func (*KindCalled) TypeInfo() typeinfo.T {
	return &Zt_KindCalled
}

// implements typeinfo.Markup
func (op *KindCalled) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kind_called
type KindCalled_Slice []KindCalled

// implements typeinfo.Instance
func (*KindCalled_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindCalled
}

// implements typeinfo.Repeats
func (op *KindCalled_Slice) Repeats() bool {
	return len(*op) > 0
}

type Names struct {
	CountedName     *CountedName
	KindCalled      *KindCalled
	Kind            *Kind
	Name            *Name
	AdditionalNames *AdditionalNames
	Markup          map[string]any
}

// names, a type of flow.
var Zt_Names typeinfo.Flow

// implements typeinfo.Instance
func (*Names) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Markup
func (op *Names) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type names
type Names_Slice []Names

// implements typeinfo.Instance
func (*Names_Slice) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Repeats
func (op *Names_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a name following another name.
type AdditionalNames struct {
	CommaAnd CommaAnd
	Names    Names
	Markup   map[string]any
}

// additional_names, a type of flow.
var Zt_AdditionalNames typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalNames) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Markup
func (op *AdditionalNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_names
type AdditionalNames_Slice []AdditionalNames

// implements typeinfo.Instance
func (*AdditionalNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Repeats
func (op *AdditionalNames_Slice) Repeats() bool {
	return len(*op) > 0
}

type CountedName struct {
	Article        *Article
	MatchingNumber MatchingNumber
	Kind           Kind
	Matched        Matched
	Markup         map[string]any
}

// counted_name, a type of flow.
var Zt_CountedName typeinfo.Flow

// implements typeinfo.Instance
func (*CountedName) TypeInfo() typeinfo.T {
	return &Zt_CountedName
}

// implements typeinfo.Markup
func (op *CountedName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type counted_name
type CountedName_Slice []CountedName

// implements typeinfo.Instance
func (*CountedName_Slice) TypeInfo() typeinfo.T {
	return &Zt_CountedName
}

// implements typeinfo.Repeats
func (op *CountedName_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an existing kind.
type Kind struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// kind, a type of flow.
var Zt_Kind typeinfo.Flow

// implements typeinfo.Instance
func (*Kind) TypeInfo() typeinfo.T {
	return &Zt_Kind
}

// implements typeinfo.Markup
func (op *Kind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kind
type Kind_Slice []Kind

// implements typeinfo.Instance
func (*Kind_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kind
}

// implements typeinfo.Repeats
func (op *Kind_Slice) Repeats() bool {
	return len(*op) > 0
}

type Kinds struct {
	Traits          *Traits
	Article         *Article
	Matched         Matched
	AdditionalKinds *AdditionalKinds
	Markup          map[string]any
}

// kinds, a type of flow.
var Zt_Kinds typeinfo.Flow

// implements typeinfo.Instance
func (*Kinds) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Markup
func (op *Kinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds
type Kinds_Slice []Kinds

// implements typeinfo.Instance
func (*Kinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Repeats
func (op *Kinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a kind following another kind.
type AdditionalKinds struct {
	CommaAnd CommaAnd
	Kinds    Kinds
	Markup   map[string]any
}

// additional_kinds, a type of flow.
var Zt_AdditionalKinds typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalKinds) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Markup
func (op *AdditionalKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_kinds
type AdditionalKinds_Slice []AdditionalKinds

// implements typeinfo.Instance
func (*AdditionalKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Repeats
func (op *AdditionalKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an (existing) trait.
type Trait struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// trait, a type of flow.
var Zt_Trait typeinfo.Flow

// implements typeinfo.Instance
func (*Trait) TypeInfo() typeinfo.T {
	return &Zt_Trait
}

// implements typeinfo.Markup
func (op *Trait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type trait
type Trait_Slice []Trait

// implements typeinfo.Instance
func (*Trait_Slice) TypeInfo() typeinfo.T {
	return &Zt_Trait
}

// implements typeinfo.Repeats
func (op *Trait_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches at least one trait.
type Traits struct {
	Trait            Trait
	AdditionalTraits *AdditionalTraits
	Markup           map[string]any
}

// traits, a type of flow.
var Zt_Traits typeinfo.Flow

// implements typeinfo.Instance
func (*Traits) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Markup
func (op *Traits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type traits
type Traits_Slice []Traits

// implements typeinfo.Instance
func (*Traits_Slice) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Repeats
func (op *Traits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a trait following another trait
type AdditionalTraits struct {
	CommaAnd *CommaAnd
	Traits   Traits
	Markup   map[string]any
}

// additional_traits, a type of flow.
var Zt_AdditionalTraits typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalTraits) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Markup
func (op *AdditionalTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_traits
type AdditionalTraits_Slice []AdditionalTraits

// implements typeinfo.Instance
func (*AdditionalTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Repeats
func (op *AdditionalTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches one or more predefined words
type Words struct {
	Matched Matched
	Markup  map[string]any
}

// words, a type of flow.
var Zt_Words typeinfo.Flow

// implements typeinfo.Instance
func (*Words) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Markup
func (op *Words) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type words
type Words_Slice []Words

// implements typeinfo.Instance
func (*Words_Slice) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Repeats
func (op *Words_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches one or more predefined verbs
type Verb struct {
	Matched Matched
	Macro   Macro
	Markup  map[string]any
}

// verb, a type of flow.
var Zt_Verb typeinfo.Flow

// implements typeinfo.Instance
func (*Verb) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// implements typeinfo.Markup
func (op *Verb) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb
type Verb_Slice []Verb

// implements typeinfo.Instance
func (*Verb_Slice) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// implements typeinfo.Repeats
func (op *Verb_Slice) Repeats() bool {
	return len(*op) > 0
}

type KindsAreTraits struct {
	Kinds   Kinds
	Are     Are
	Usually Words
	Traits  Traits
	Markup  map[string]any
}

// kinds_are_traits, a type of flow.
var Zt_KindsAreTraits typeinfo.Flow

// implements typeinfo.Instance
func (*KindsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Markup
func (op *KindsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_are_traits
type KindsAreTraits_Slice []KindsAreTraits

// implements typeinfo.Instance
func (*KindsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Repeats
func (op *KindsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

type MatchingPhrases struct {
	KindsAreTraits  KindsAreTraits
	KindsOf         KindsOf
	VerbLinks       VerbLinks
	LinksVerb       LinksVerb
	LinksAdjectives LinksAdjectives
	NounValue       NounValue
	Markup          map[string]any
}

// matching_phrases, a type of flow.
var Zt_MatchingPhrases typeinfo.Flow

// implements typeinfo.Instance
func (*MatchingPhrases) TypeInfo() typeinfo.T {
	return &Zt_MatchingPhrases
}

// implements typeinfo.Markup
func (op *MatchingPhrases) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type matching_phrases
type MatchingPhrases_Slice []MatchingPhrases

// implements typeinfo.Instance
func (*MatchingPhrases_Slice) TypeInfo() typeinfo.T {
	return &Zt_MatchingPhrases
}

// implements typeinfo.Repeats
func (op *MatchingPhrases_Slice) Repeats() bool {
	return len(*op) > 0
}

type KindsOf struct {
	Names   Names
	Are     Are
	KindsOf Words
	Traits  *Traits
	Kind    Kind
	Markup  map[string]any
}

// kinds_of, a type of flow.
var Zt_KindsOf typeinfo.Flow

// implements typeinfo.Instance
func (*KindsOf) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Markup
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_of
type KindsOf_Slice []KindsOf

// implements typeinfo.Instance
func (*KindsOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Repeats
func (op *KindsOf_Slice) Repeats() bool {
	return len(*op) > 0
}

type VerbLinks struct {
	Verb       Verb
	Names      Names
	Are        Are
	OtherNames Names
	Markup     map[string]any
}

// verb_links, a type of flow.
var Zt_VerbLinks typeinfo.Flow

// implements typeinfo.Instance
func (*VerbLinks) TypeInfo() typeinfo.T {
	return &Zt_VerbLinks
}

// implements typeinfo.Markup
func (op *VerbLinks) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb_links
type VerbLinks_Slice []VerbLinks

// implements typeinfo.Instance
func (*VerbLinks_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbLinks
}

// implements typeinfo.Repeats
func (op *VerbLinks_Slice) Repeats() bool {
	return len(*op) > 0
}

type LinksVerb struct {
	Names      Names
	Are        Are
	Verb       Verb
	OtherNames Names
	Markup     map[string]any
}

// links_verb, a type of flow.
var Zt_LinksVerb typeinfo.Flow

// implements typeinfo.Instance
func (*LinksVerb) TypeInfo() typeinfo.T {
	return &Zt_LinksVerb
}

// implements typeinfo.Markup
func (op *LinksVerb) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type links_verb
type LinksVerb_Slice []LinksVerb

// implements typeinfo.Instance
func (*LinksVerb_Slice) TypeInfo() typeinfo.T {
	return &Zt_LinksVerb
}

// implements typeinfo.Repeats
func (op *LinksVerb_Slice) Repeats() bool {
	return len(*op) > 0
}

type LinksAdjectives struct {
	Names      Names
	Are        Are
	Adjectives Adjectives
	VerbPhrase *VerbPhrase
	Markup     map[string]any
}

// links_adjectives, a type of flow.
var Zt_LinksAdjectives typeinfo.Flow

// implements typeinfo.Instance
func (*LinksAdjectives) TypeInfo() typeinfo.T {
	return &Zt_LinksAdjectives
}

// implements typeinfo.Markup
func (op *LinksAdjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type links_adjectives
type LinksAdjectives_Slice []LinksAdjectives

// implements typeinfo.Instance
func (*LinksAdjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_LinksAdjectives
}

// implements typeinfo.Repeats
func (op *LinksAdjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

// ex. ".... in the kitchen.", or "... carries the football and sousaphone."
type VerbPhrase struct {
	Verb   Verb
	Names  Names
	Markup map[string]any
}

// verb_phrase, a type of flow.
var Zt_VerbPhrase typeinfo.Flow

// implements typeinfo.Instance
func (*VerbPhrase) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// implements typeinfo.Markup
func (op *VerbPhrase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb_phrase
type VerbPhrase_Slice []VerbPhrase

// implements typeinfo.Instance
func (*VerbPhrase_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// implements typeinfo.Repeats
func (op *VerbPhrase_Slice) Repeats() bool {
	return len(*op) > 0
}

type Adjectives struct {
	Traits               *Traits
	CommaAnd             *CommaAnd
	Kind                 *Kind
	AdditionalAdjectives *AdditionalAdjectives
	Markup               map[string]any
}

// adjectives, a type of flow.
var Zt_Adjectives typeinfo.Flow

// implements typeinfo.Instance
func (*Adjectives) TypeInfo() typeinfo.T {
	return &Zt_Adjectives
}

// implements typeinfo.Markup
func (op *Adjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type adjectives
type Adjectives_Slice []Adjectives

// implements typeinfo.Instance
func (*Adjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_Adjectives
}

// implements typeinfo.Repeats
func (op *Adjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

// an additional set of traits and a kind
type AdditionalAdjectives struct {
	CommaAnd   CommaAnd
	Adjectives Adjectives
	Markup     map[string]any
}

// additional_adjectives, a type of flow.
var Zt_AdditionalAdjectives typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalAdjectives) TypeInfo() typeinfo.T {
	return &Zt_AdditionalAdjectives
}

// implements typeinfo.Markup
func (op *AdditionalAdjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_adjectives
type AdditionalAdjectives_Slice []AdditionalAdjectives

// implements typeinfo.Instance
func (*AdditionalAdjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalAdjectives
}

// implements typeinfo.Repeats
func (op *AdditionalAdjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

type NounValue struct {
	Article     *Article
	Property    Matched
	Noun        Name
	Are         Are
	SingleValue SingleValue
	Markup      map[string]any
}

// noun_value, a type of flow.
var Zt_NounValue typeinfo.Flow

// implements typeinfo.Instance
func (*NounValue) TypeInfo() typeinfo.T {
	return &Zt_NounValue
}

// implements typeinfo.Markup
func (op *NounValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type noun_value
type NounValue_Slice []NounValue

// implements typeinfo.Instance
func (*NounValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_NounValue
}

// implements typeinfo.Repeats
func (op *NounValue_Slice) Repeats() bool {
	return len(*op) > 0
}

type SingleValue struct {
	QuotedText     *QuotedText
	MatchingNumber *MatchingNumber
	Markup         map[string]any
}

// single_value, a type of flow.
var Zt_SingleValue typeinfo.Flow

// implements typeinfo.Instance
func (*SingleValue) TypeInfo() typeinfo.T {
	return &Zt_SingleValue
}

// implements typeinfo.Markup
func (op *SingleValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type single_value
type SingleValue_Slice []SingleValue

// implements typeinfo.Instance
func (*SingleValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_SingleValue
}

// implements typeinfo.Repeats
func (op *SingleValue_Slice) Repeats() bool {
	return len(*op) > 0
}

type QuotedText struct {
	Matched Matched
	Markup  map[string]any
}

// quoted_text, a type of flow.
var Zt_QuotedText typeinfo.Flow

// implements typeinfo.Instance
func (*QuotedText) TypeInfo() typeinfo.T {
	return &Zt_QuotedText
}

// implements typeinfo.Markup
func (op *QuotedText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type quoted_text
type QuotedText_Slice []QuotedText

// implements typeinfo.Instance
func (*QuotedText_Slice) TypeInfo() typeinfo.T {
	return &Zt_QuotedText
}

// implements typeinfo.Repeats
func (op *QuotedText_Slice) Repeats() bool {
	return len(*op) > 0
}

type MatchingNumber struct {
	Number float64
	Markup map[string]any
}

// matching_number, a type of flow.
var Zt_MatchingNumber typeinfo.Flow

// implements typeinfo.Instance
func (*MatchingNumber) TypeInfo() typeinfo.T {
	return &Zt_MatchingNumber
}

// implements typeinfo.Markup
func (op *MatchingNumber) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type matching_number
type MatchingNumber_Slice []MatchingNumber

// implements typeinfo.Instance
func (*MatchingNumber_Slice) TypeInfo() typeinfo.T {
	return &Zt_MatchingNumber
}

// implements typeinfo.Repeats
func (op *MatchingNumber_Slice) Repeats() bool {
	return len(*op) > 0
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "jess",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Matched,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Article,
	&Zt_CommaAnd,
	&Zt_Are,
	&Zt_Name,
	&Zt_KindCalled,
	&Zt_Names,
	&Zt_AdditionalNames,
	&Zt_CountedName,
	&Zt_Kind,
	&Zt_Kinds,
	&Zt_AdditionalKinds,
	&Zt_Trait,
	&Zt_Traits,
	&Zt_AdditionalTraits,
	&Zt_Words,
	&Zt_Verb,
	&Zt_KindsAreTraits,
	&Zt_MatchingPhrases,
	&Zt_KindsOf,
	&Zt_VerbLinks,
	&Zt_LinksVerb,
	&Zt_LinksAdjectives,
	&Zt_VerbPhrase,
	&Zt_Adjectives,
	&Zt_AdditionalAdjectives,
	&Zt_NounValue,
	&Zt_SingleValue,
	&Zt_QuotedText,
	&Zt_MatchingNumber,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	12489206644669467772: (*AdditionalAdjectives)(nil), /* AdditionalAdjectives commaAnd:adjectives: */
	12174030489678544826: (*AdditionalKinds)(nil),      /* AdditionalKinds commaAnd:kinds: */
	16975120945491427296: (*AdditionalNames)(nil),      /* AdditionalNames commaAnd:names: */
	508023169458945308:   (*AdditionalTraits)(nil),     /* AdditionalTraits commaAnd:traits: */
	1887918947148326916:  (*AdditionalTraits)(nil),     /* AdditionalTraits traits: */
	10618851046870477413: (*Adjectives)(nil),           /* Adjectives */
	12215120732458766748: (*Adjectives)(nil),           /* Adjectives additionalAdjectives: */
	724420376605497959:   (*Adjectives)(nil),           /* Adjectives commaAnd: */
	17477522713582243508: (*Adjectives)(nil),           /* Adjectives commaAnd:additionalAdjectives: */
	1568830118683768373:  (*Adjectives)(nil),           /* Adjectives commaAnd:kind: */
	7021517372525507842:  (*Adjectives)(nil),           /* Adjectives commaAnd:kind:additionalAdjectives: */
	7663368451290651677:  (*Adjectives)(nil),           /* Adjectives kind: */
	16725271580009929658: (*Adjectives)(nil),           /* Adjectives kind:additionalAdjectives: */
	13544991759812118088: (*Adjectives)(nil),           /* Adjectives traits: */
	13327572087367323885: (*Adjectives)(nil),           /* Adjectives traits:additionalAdjectives: */
	2209109858568160146:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd: */
	11777076077986952519: (*Adjectives)(nil),           /* Adjectives traits:commaAnd:additionalAdjectives: */
	5997117370605758938:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd:kind: */
	5841657992957591039:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd:kind:additionalAdjectives: */
	11552995266309396480: (*Adjectives)(nil),           /* Adjectives traits:kind: */
	8078288476520567765:  (*Adjectives)(nil),           /* Adjectives traits:kind:additionalAdjectives: */
	14557216947727331217: (*Are)(nil),                  /* Are matched: */
	3899130289676196213:  (*Article)(nil),              /* Article matched: */
	5180090635119408685:  (*CommaAnd)(nil),             /* CommaAnd matched: */
	2237036151518779634:  (*CountedName)(nil),          /* CountedName article:matchingNumber:kind: */
	6139323499442568526:  (*CountedName)(nil),          /* CountedName matchingNumber:kind: */
	17839012382227179591: (*Kind)(nil),                 /* Kind article:matched: */
	17757668305058379307: (*Kind)(nil),                 /* Kind matched: */
	2217456341527734037:  (*KindCalled)(nil),           /* KindCalled kind:called:article:matched: */
	7883278166734757597:  (*KindCalled)(nil),           /* KindCalled kind:called:matched: */
	11434548771906794500: (*KindCalled)(nil),           /* KindCalled traits:kind:called:article:matched: */
	15204937038648752928: (*KindCalled)(nil),           /* KindCalled traits:kind:called:matched: */
	16939996019861136326: (*Kinds)(nil),                /* Kinds article:matched: */
	16946855517465005572: (*Kinds)(nil),                /* Kinds article:matched:additionalKinds: */
	17808071339216334934: (*Kinds)(nil),                /* Kinds matched: */
	17872094200105304436: (*Kinds)(nil),                /* Kinds matched:additionalKinds: */
	4933212495013814755:  (*Kinds)(nil),                /* Kinds traits:article:matched: */
	1182820540821259821:  (*Kinds)(nil),                /* Kinds traits:article:matched:additionalKinds: */
	831875526186841727:   (*Kinds)(nil),                /* Kinds traits:matched: */
	3736619607479472409:  (*Kinds)(nil),                /* Kinds traits:matched:additionalKinds: */
	8826794343109131276:  (*KindsAreTraits)(nil),       /* KindsAreTraits kinds:are:usually:traits: */
	3548848131135117387:  (*KindsOf)(nil),              /* KindsOf names:are:kindsOf:kind: */
	16884802454329910582: (*KindsOf)(nil),              /* KindsOf names:are:kindsOf:traits:kind: */
	7402680883116510138:  (*LinksAdjectives)(nil),      /* LinksAdjectives names:are:adjectives: */
	13051355243450165788: (*LinksAdjectives)(nil),      /* LinksAdjectives names:are:adjectives:verbPhrase: */
	14912868615589777512: (*LinksVerb)(nil),            /* LinksVerb names:are:verb:otherNames: */
	5641041111806881294:  (*MatchingNumber)(nil),       /* MatchingNumber number: */
	4465373173743747470:  (*MatchingPhrases)(nil),      /* MatchingPhrases kindsAreTraits:kindsOf:verbLinks:linksVerb:linksAdjectives:nounValue: */
	8378947654433865548:  (*Name)(nil),                 /* Name article:matched: */
	6273971456499216312:  (*Name)(nil),                 /* Name matched: */
	7786741787633711023:  (*Names)(nil),                /* Names */
	2651340957450283514:  (*Names)(nil),                /* Names additionalNames: */
	14434599770315422844: (*Names)(nil),                /* Names countedName: */
	9886115040157153195:  (*Names)(nil),                /* Names countedName:additionalNames: */
	5713683783650676748:  (*Names)(nil),                /* Names countedName:kind: */
	11696938860312845211: (*Names)(nil),                /* Names countedName:kind:additionalNames: */
	758506744303684007:   (*Names)(nil),                /* Names countedName:kind:name: */
	14864729949414126072: (*Names)(nil),                /* Names countedName:kind:name:additionalNames: */
	7253272718308834379:  (*Names)(nil),                /* Names countedName:kindCalled: */
	7381532013512958308:  (*Names)(nil),                /* Names countedName:kindCalled:additionalNames: */
	8408184179066850945:  (*Names)(nil),                /* Names countedName:kindCalled:kind: */
	7338366429769939062:  (*Names)(nil),                /* Names countedName:kindCalled:kind:additionalNames: */
	2599493857747890432:  (*Names)(nil),                /* Names countedName:kindCalled:kind:name: */
	6118560200350627847:  (*Names)(nil),                /* Names countedName:kindCalled:kind:name:additionalNames: */
	10095315050340635774: (*Names)(nil),                /* Names countedName:kindCalled:name: */
	12303183222075615441: (*Names)(nil),                /* Names countedName:kindCalled:name:additionalNames: */
	4084573660669905687:  (*Names)(nil),                /* Names countedName:name: */
	4746500019507238408:  (*Names)(nil),                /* Names countedName:name:additionalNames: */
	10083583177877560579: (*Names)(nil),                /* Names kind: */
	10358197305705491068: (*Names)(nil),                /* Names kind:additionalNames: */
	4765472119311194486:  (*Names)(nil),                /* Names kind:name: */
	6827326204135250665:  (*Names)(nil),                /* Names kind:name:additionalNames: */
	17127273420174886912: (*Names)(nil),                /* Names kindCalled: */
	17398615419225362183: (*Names)(nil),                /* Names kindCalled:additionalNames: */
	5709340463761574280:  (*Names)(nil),                /* Names kindCalled:kind: */
	2606241887328501871:  (*Names)(nil),                /* Names kindCalled:kind:additionalNames: */
	14491670955720618019: (*Names)(nil),                /* Names kindCalled:kind:name: */
	6231970138046816860:  (*Names)(nil),                /* Names kindCalled:kind:name:additionalNames: */
	2889757484689352859:  (*Names)(nil),                /* Names kindCalled:name: */
	17641125891389017492: (*Names)(nil),                /* Names kindCalled:name:additionalNames: */
	4500297491524973516:  (*Names)(nil),                /* Names name: */
	17351915174502247643: (*Names)(nil),                /* Names name:additionalNames: */
	10337279124314240622: (*NounValue)(nil),            /* NounValue article:property:noun:are:singleValue: */
	17479735805403962906: (*NounValue)(nil),            /* NounValue property:noun:are:singleValue: */
	6626169867101049892:  (*QuotedText)(nil),           /* QuotedText matched: */
	8620010389824513622:  (*SingleValue)(nil),          /* SingleValue */
	747026252029666750:   (*SingleValue)(nil),          /* SingleValue matchingNumber: */
	3958109237643295925:  (*SingleValue)(nil),          /* SingleValue quotedText: */
	17617190106567464055: (*SingleValue)(nil),          /* SingleValue quotedText:matchingNumber: */
	14664763846497769151: (*Trait)(nil),                /* Trait article:matched: */
	12725361887885713715: (*Trait)(nil),                /* Trait matched: */
	2416383336069566114:  (*Traits)(nil),               /* Traits trait: */
	2878025327467574768:  (*Traits)(nil),               /* Traits trait:additionalTraits: */
	4698992564801604870:  (*Verb)(nil),                 /* Verb matched: */
	16284439795500881562: (*VerbLinks)(nil),            /* VerbLinks verb:names:are:otherNames: */
	17939229312172807626: (*VerbPhrase)(nil),           /* VerbPhrase verb:names: */
	17678340847396548932: (*Words)(nil),                /* Words matched: */
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Article = typeinfo.Flow{
		Name: "article",
		Lede: "article",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one of a predefined set of determiners:", "the, a, some, etc.", "see 'counted_name' for names with leading numbers."},
		},
	}
	Zt_CommaAnd = typeinfo.Flow{
		Name: "comma_and",
		Lede: "comma_and",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"conjunction junction", "matches \",\" or \"and\" or \", and\"", "relies on the fact package match treats commas and ands each as their own words."},
		},
	}
	Zt_Are = typeinfo.Flow{
		Name: "are",
		Lede: "are",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches \"is\" or \"are\".",
		},
	}
	Zt_Name = typeinfo.Flow{
		Name: "name",
		Lede: "name",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "# the match is always implemented as a span.",
			},
			Type: &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Specifies a single name, in full or in part.", "For example, when matching: \"Gold Roger's treasure chest is a container. The chest is open.\"", "The name \"chest\" implies the treasure chest.", "To optimizing matching the words \"is/are/comma/and\" are never part of name names.", "future: allow quoted \"titles\" ( which are then allowed to break those assumptions )", "( see also 'kind_called' )"},
		},
	}
	Zt_KindCalled = typeinfo.Flow{
		Name: "kind_called",
		Lede: "kind_called",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"note: doesn't use 'adjectives' because this doesn't allow", "repetitions of the traits and kind."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "called",
			Label: "called",
			Markup: map[string]any{
				"comment": "the word \"called\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a name and its kind in a single phrase.", "<kind> \"called\" [the] _name_.", "as per inform, the name of the name is everything after the word called", "until \"is\" or \"are\" or the end of the line.", "For instance: `The container called the trunk and the box is in the lobby`", "generates a single name named \"the trunk and the box.\""},
		},
	}
	Zt_Names = typeinfo.Flow{
		Name: "names",
		Lede: "names",
		Terms: []typeinfo.Term{{
			Name:     "counted_name",
			Label:    "counted_name",
			Optional: true,
			Type:     &Zt_CountedName,
		}, {
			Name:     "kind_called",
			Label:    "kind_called",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"note: because this phrase is greedy", "once used, no additional names will match."},
			},
			Type: &Zt_KindCalled,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"used primarily for anonymous nouns: \"the container\"", "noting that anonymous nouns are prohibited from starting a sentence."},
			},
			Type: &Zt_Kind,
		}, {
			Name:     "name",
			Label:    "name",
			Optional: true,
			Type:     &Zt_Name,
		}, {
			Name:     "additional_names",
			Label:    "additional_names",
			Optional: true,
			Type:     &Zt_AdditionalNames,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Specifies one or more nouns, in full or in part.", "Only one of the options, plus possibly 'additional_names', will match.", "Not all options are valid in all contexts;", "the users of 'names' may discard or avoid certain matches.", "( the options could be represented as a slot; this feels easier for now )"},
		},
	}
	Zt_AdditionalNames = typeinfo.Flow{
		Name: "additional_names",
		Lede: "additional_names",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "a separator is required between names",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "matches a name following another name.",
		},
	}
	Zt_CountedName = typeinfo.Flow{
		Name: "counted_name",
		Lede: "counted_name",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matching_number",
			Label: "matching_number",
			Type:  &Zt_MatchingNumber,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:    "matched",
			Label:   "matched",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"provides english specification of a number of objects.", "note: yes, `the five the containers` is permitted."},
		},
	}
	Zt_Kind = typeinfo.Flow{
		Name: "kind",
		Lede: "kind",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every kind", "it doesn't influence which kind gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an existing kind.",
		},
	}
	Zt_Kinds = typeinfo.Flow{
		Name: "kinds",
		Lede: "kinds",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform uses traits specified here to select", "matching nouns; jess is not that clever."},
			},
			Type: &Zt_Traits,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "matches a span ending with \"is/are/comma/and\"",
			},
			Type: &Zt_Matched,
		}, {
			Name:     "additional_kinds",
			Label:    "additional_kinds",
			Optional: true,
			Type:     &Zt_AdditionalKinds,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches a set of possible kinds as part of kinds_are_traits", "jess tests for but prohibits leading traits."},
		},
	}
	Zt_AdditionalKinds = typeinfo.Flow{
		Name: "additional_kinds",
		Lede: "additional_kinds",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "a separator is required between the names of kinds",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}},
		Markup: map[string]any{
			"comment": "matches a kind following another kind.",
		},
	}
	Zt_Trait = typeinfo.Flow{
		Name: "trait",
		Lede: "trait",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every trait", "it doesn't influence which trait gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an (existing) trait.",
		},
	}
	Zt_Traits = typeinfo.Flow{
		Name: "traits",
		Lede: "traits",
		Terms: []typeinfo.Term{{
			Name:  "trait",
			Label: "trait",
			Type:  &Zt_Trait,
		}, {
			Name:     "additional_traits",
			Label:    "additional_traits",
			Optional: true,
			Type:     &Zt_AdditionalTraits,
		}},
		Markup: map[string]any{
			"comment": "matches at least one trait.",
		},
	}
	Zt_AdditionalTraits = typeinfo.Flow{
		Name: "additional_traits",
		Lede: "additional_traits",
		Terms: []typeinfo.Term{{
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Type:     &Zt_CommaAnd,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": "matches a trait following another trait",
		},
	}
	Zt_Words = typeinfo.Flow{
		Name: "words",
		Lede: "words",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "matches one or more predefined words",
		},
	}
	Zt_Verb = typeinfo.Flow{
		Name: "verb",
		Lede: "verb",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}, {
			Name:    "macro",
			Label:   "macro",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": "matches one or more predefined verbs",
		},
	}
	Zt_KindsAreTraits = typeinfo.Flow{
		Name: "kinds_are_traits",
		Lede: "kinds_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "usually",
			Label: "usually",
			Type:  &Zt_Words,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"assigns default traits to a kind.", "<the kind> are \"usually\" <traits>", "future: inform allows limiting traits to kinds with other traits:", "for example, `the closed containers are fixed in place.`", "makes any containers that are *initially* closed also immovable."},
		},
	}
	Zt_MatchingPhrases = typeinfo.Flow{
		Name: "matching_phrases",
		Lede: "matching_phrases",
		Terms: []typeinfo.Term{{
			Name:  "kinds_are_traits",
			Label: "kinds_are_traits",
			Type:  &Zt_KindsAreTraits,
		}, {
			Name:  "kinds_of",
			Label: "kinds_of",
			Type:  &Zt_KindsOf,
		}, {
			Name:  "verb_links",
			Label: "verb_links",
			Type:  &Zt_VerbLinks,
		}, {
			Name:  "links_verb",
			Label: "links_verb",
			Type:  &Zt_LinksVerb,
		}, {
			Name:  "links_adjectives",
			Label: "links_adjectives",
			Type:  &Zt_LinksAdjectives,
		}, {
			Name:  "noun_value",
			Label: "noun_value",
			Type:  &Zt_NounValue,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"union of all possible matching sentences:", "tests these in-order to find a match.", "( an alternative would be slots, and a registry; this is fine for now )"},
		},
	}
	Zt_KindsOf = typeinfo.Flow{
		Name: "kinds_of",
		Lede: "kinds_of",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"a counted name here doesn't indicate multiple kinds", "instead it generates a kind that has a number leading its name."},
			},
			Type: &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "kinds_of",
			Label: "kinds_of",
			Markup: map[string]any{
				"comment": "the phrases \"a kind of\" or \"kinds of\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform doesnt allow commas or ands here,", "jess reuses the traits list here, so it does allow comma/and."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "kind",
			Label: "kind",
			Markup: map[string]any{
				"comment": []interface{}{"inform (weirdly) allows multiple kinds:", "`A box is a kind of container and things.`", "but not if traits are specified, suggesting a switch there.", "this doesnt switch to special traits, and doesnt allow multiple kinds."},
			},
			Type: &Zt_Kind,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"<names> <are> \"a kind of\"/\"kinds of\" <traits> <kind>.", "interesting to note that inform allows \"some kind/s of\"", "this is more strict.", "like inform this doesn't try to limit the names", "`The animals called kittens are a kind of things.` is legal."},
		},
	}
	Zt_VerbLinks = typeinfo.Flow{
		Name: "verb_links",
		Lede: "verb_links",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "other_names",
			Label: "other_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"verb names are (other) names.", "ex. `In the coffin are some coins, a notebook, and the gripping hand.`", "This intentionally doesn't recognize adjectives attached to named names.", "\"In the closed coffin\" generates a name with the name \"closed coffin\"", "not a coffin in an initially closed state."},
		},
	}
	Zt_LinksVerb = typeinfo.Flow{
		Name: "links_verb",
		Lede: "links_verb",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "other_names",
			Label: "other_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"names are verb (other) names.", "ex. `The thing called the stake is on the supporter called the altar.`"},
		},
	}
	Zt_LinksAdjectives = typeinfo.Flow{
		Name: "links_adjectives",
		Lede: "links_adjectives",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "adjectives",
			Label: "adjectives",
			Markup: map[string]any{
				"comment": []interface{}{"adjectives are *not* optional.", "if there are no adjectives present,", "then 'links_verb' (might) match instead."},
			},
			Type: &Zt_Adjectives,
		}, {
			Name:     "verb_phrase",
			Label:    "verb_phrase",
			Optional: true,
			Type:     &Zt_VerbPhrase,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"names are adjectives [verb names].", "ex. `The bottle is a transparent, open, container.`", "`The coffin is a closed container [in the antechamber]`", "This is the *only* way of assigning names initial states directly.", "All other phrases require a kind to be involved, here the kind is optional."},
		},
	}
	Zt_VerbPhrase = typeinfo.Flow{
		Name: "verb_phrase",
		Lede: "verb_phrase",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": "only succeeds on plain names.",
			},
			Type: &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "ex. \".... in the kitchen.\", or \"... carries the football and sousaphone.\"",
		},
	}
	Zt_Adjectives = typeinfo.Flow{
		Name: "adjectives",
		Lede: "adjectives",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Type:     &Zt_Traits,
		}, {
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"exists to support phrases like:", "`the box is transparent and a container.`"},
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Type:     &Zt_Kind,
		}, {
			Name:     "additional_adjectives",
			Label:    "additional_adjectives",
			Optional: true,
			Type:     &Zt_AdditionalAdjectives,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one or more phrases consisting of traits and a kind.", "while all parts are marked as optional, matching expects", "there will be at least one trait or one kind", "and that there can only be additional adjective phrases", "if the previous one ended with a kind.", "ex. `a container`", "    `closed and fixed in place`,", "    `a closed container and a fixed in place thing`."},
		},
	}
	Zt_AdditionalAdjectives = typeinfo.Flow{
		Name: "additional_adjectives",
		Lede: "additional_adjectives",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Type:  &Zt_CommaAnd,
		}, {
			Name:  "adjectives",
			Label: "adjectives",
			Type:  &Zt_Adjectives,
		}},
		Markup: map[string]any{
			"comment": "an additional set of traits and a kind",
		},
	}
	Zt_NounValue = typeinfo.Flow{
		Name: "noun_value",
		Lede: "noun_value",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "property",
			Label: "property",
			Markup: map[string]any{
				"comment": "a span ending with the word \"of\"",
			},
			Type: &Zt_Matched,
		}, {
			Name:  "noun",
			Label: "noun",
			Markup: map[string]any{
				"comment": "note: \"called the\" isn't allowed here.",
			},
			Type: &Zt_Name,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "single_value",
			Label: "single_value",
			Type:  &Zt_SingleValue,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"assigns a default value to a noun.", "The description of the pen is \"mightier than the sword.\""},
		},
	}
	Zt_SingleValue = typeinfo.Flow{
		Name: "single_value",
		Lede: "single_value",
		Terms: []typeinfo.Term{{
			Name:     "quoted_text",
			Label:    "quoted_text",
			Optional: true,
			Type:     &Zt_QuotedText,
		}, {
			Name:     "matching_number",
			Label:    "matching_number",
			Optional: true,
			Type:     &Zt_MatchingNumber,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches only one of its options", "( the options could be represented as a slot; this feels easier for now )"},
		},
	}
	Zt_QuotedText = typeinfo.Flow{
		Name: "quoted_text",
		Lede: "quoted_text",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"text that begins and ends with double quotes.", "the quotes themselves are not part of the matched text."},
		},
	}
	Zt_MatchingNumber = typeinfo.Flow{
		Name: "matching_number",
		Lede: "matching_number",
		Terms: []typeinfo.Term{{
			Name:  "number",
			Label: "number",
			Type:  &prim.Zt_Number,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"reads a number specified in words or as digits.", "stores the result as the parsed number."},
		},
	}
}
