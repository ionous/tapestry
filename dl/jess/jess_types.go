// Game world modeling using English-like sentences.
// For example:
//
//	The kitchen is a room. The closed container called the cabinet is in the kitchen.
//	The cabinet contains a mug. The mug is transparent.
//
// The types of sentences jess can process are based on Inform7. The way in which jess processes sentences, however, are based on parse trees defined by Tapestry commands.
//
// The root of all parse trees is the "MatchingPhrases:" command.
// Each successfully matched plain English sentence results a single [MatchingPhrases] instance with exactly one valid member.
package jess

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// matched, a type of slot.
var Zt_Matched = typeinfo.Slot{
	Name: "matched",
	Markup: map[string]any{
		"comment": "Used to store matching text.",
	},
}

// Holds a single slot.
type Matched_Slot struct{ Value Matched }

// Implements [typeinfo.Instance] for a single slot.
func (*Matched_Slot) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// Holds a slice of slots.
type Matched_Slots []Matched

// Implements [typeinfo.Instance] for a slice of slots.
func (*Matched_Slots) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *Matched_Slots) Repeats() bool {
	return len(*op) > 0
}

// noun_builder, a type of slot.
var Zt_NounBuilder = typeinfo.Slot{
	Name: "noun_builder",
	Markup: map[string]any{
		"comment": "Indicates a matcher which can define a noun.",
	},
}

// Holds a single slot.
type NounBuilder_Slot struct{ Value NounBuilder }

// Implements [typeinfo.Instance] for a single slot.
func (*NounBuilder_Slot) TypeInfo() typeinfo.T {
	return &Zt_NounBuilder
}

// Holds a slice of slots.
type NounBuilder_Slots []NounBuilder

// Implements [typeinfo.Instance] for a slice of slots.
func (*NounBuilder_Slots) TypeInfo() typeinfo.T {
	return &Zt_NounBuilder
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *NounBuilder_Slots) Repeats() bool {
	return len(*op) > 0
}

// One of a predefined set of determiners: the, a/n, some, our.
// This only matches if the first letter is lowercase, or uppercase at the start of a sentence;
// otherwise, the article gets treated as part of the name.
//
// Also note:
//   - The lack of a recognized article makes something proper-named.
//   - See 'counted_kind' for names with leading numbers: (ex. five or 27).
//   - Using "some"  (ex. "some coins") will set nouns as "plural named".
type Article struct {
	Text   string
	Flags  ArticleFlags
	Markup map[string]any
}

// article, a type of flow.
var Zt_Article typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Article) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// Implements [typeinfo.Markup]
func (op *Article) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Article.
type Article_Slice []Article

// Implements [typeinfo.Instance] for a slice of Article.
func (*Article_Slice) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// Implements [typeinfo.Repeats] for a slice of Article.
func (op *Article_Slice) Repeats() bool {
	return len(*op) > 0
}

// This matches commas, "and", or ", and".
// It relies on the fact package match treats commas and the word "and" each as their own words.
type CommaAnd struct {
	Matched Matched
	Markup  map[string]any
}

// comma_and, a type of flow.
var Zt_CommaAnd typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CommaAnd) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// Implements [typeinfo.Markup]
func (op *CommaAnd) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type CommaAnd.
type CommaAnd_Slice []CommaAnd

// Implements [typeinfo.Instance] for a slice of CommaAnd.
func (*CommaAnd_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// Implements [typeinfo.Repeats] for a slice of CommaAnd.
func (op *CommaAnd_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches commas, "and", or "or".
// relies on the fact package match treats commas and ands each as their own words.
type CommaAndOr struct {
	Matched Matched
	Markup  map[string]any
}

// comma_and_or, a type of flow.
var Zt_CommaAndOr typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CommaAndOr) TypeInfo() typeinfo.T {
	return &Zt_CommaAndOr
}

// Implements [typeinfo.Markup]
func (op *CommaAndOr) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type CommaAndOr.
type CommaAndOr_Slice []CommaAndOr

// Implements [typeinfo.Instance] for a slice of CommaAndOr.
func (*CommaAndOr_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAndOr
}

// Implements [typeinfo.Repeats] for a slice of CommaAndOr.
func (op *CommaAndOr_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches the words "is" or "are".
type Are struct {
	Matched Matched
	Markup  map[string]any
}

// are, a type of flow.
var Zt_Are typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Are) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// Implements [typeinfo.Markup]
func (op *Are) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Are.
type Are_Slice []Are

// Implements [typeinfo.Instance] for a slice of Are.
func (*Are_Slice) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// Implements [typeinfo.Repeats] for a slice of Are.
func (op *Are_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches the word "called".
type Called struct {
	Matched Matched
	Markup  map[string]any
}

// called, a type of flow.
var Zt_Called typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Called) TypeInfo() typeinfo.T {
	return &Zt_Called
}

// Implements [typeinfo.Markup]
func (op *Called) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Called.
type Called_Slice []Called

// Implements [typeinfo.Instance] for a slice of Called.
func (*Called_Slice) TypeInfo() typeinfo.T {
	return &Zt_Called
}

// Implements [typeinfo.Repeats] for a slice of Called.
func (op *Called_Slice) Repeats() bool {
	return len(*op) > 0
}

// Specifies a name who's meaning depends on context.
// For example, when matching: "Gold Roger's treasure chest is a container. The chest is open."
// the "chest" implies the noun "treasure chest."
// In other cases, the name might be a kind, or trait, or pretty much anything else.
//
// To optimizing matching the words "is/are/comma/and" are never part of name names.
//
// Future: allow quoted "titles" ( which are then allowed to break those assumptions )
type Name struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// name, a type of flow.
var Zt_Name typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Name) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// Implements [typeinfo.Markup]
func (op *Name) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ NounBuilder = (*Name)(nil)

// Holds a slice of type Name.
type Name_Slice []Name

// Implements [typeinfo.Instance] for a slice of Name.
func (*Name_Slice) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// Implements [typeinfo.Repeats] for a slice of Name.
func (op *Name_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches an existing noun
// ( by checking multiple words for the best match ).
type Noun struct {
	Article    *Article
	Matched    Matched
	ActualNoun ActualNoun
	Markup     map[string]any
}

// noun, a type of flow.
var Zt_Noun typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Noun) TypeInfo() typeinfo.T {
	return &Zt_Noun
}

// Implements [typeinfo.Markup]
func (op *Noun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ NounBuilder = (*Noun)(nil)

// Holds a slice of type Noun.
type Noun_Slice []Noun

// Implements [typeinfo.Instance] for a slice of Noun.
func (*Noun_Slice) TypeInfo() typeinfo.T {
	return &Zt_Noun
}

// Implements [typeinfo.Repeats] for a slice of Noun.
func (op *Noun_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches an existing noun, or if not: then something new.
type NamedNoun struct {
	Noun   *Noun
	Name   *Name
	Markup map[string]any
}

// named_noun, a type of flow.
var Zt_NamedNoun typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NamedNoun) TypeInfo() typeinfo.T {
	return &Zt_NamedNoun
}

// Implements [typeinfo.Markup]
func (op *NamedNoun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ NounBuilder = (*NamedNoun)(nil)

// Holds a slice of type NamedNoun.
type NamedNoun_Slice []NamedNoun

// Implements [typeinfo.Instance] for a slice of NamedNoun.
func (*NamedNoun_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamedNoun
}

// Implements [typeinfo.Repeats] for a slice of NamedNoun.
func (op *NamedNoun_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a name and its kind in a single phrase.
// Matches: (traits) kind "called" {the name}.
// For example:
//
//	The closed container called the trunk is in the lobby.
//
// As per inform, the name includes all text after the word "called"
// until "is", "are", or the end of the sentence;
// and specifying "called the/our ..." gives the noun an indefinite article.
type KindCalled struct {
	Traits    *Traits
	Kind      Kind
	Called    Called
	NamedNoun NamedNoun
	Markup    map[string]any
}

// kind_called, a type of flow.
var Zt_KindCalled typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindCalled) TypeInfo() typeinfo.T {
	return &Zt_KindCalled
}

// Implements [typeinfo.Markup]
func (op *KindCalled) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type KindCalled.
type KindCalled_Slice []KindCalled

// Implements [typeinfo.Instance] for a slice of KindCalled.
func (*KindCalled_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindCalled
}

// Implements [typeinfo.Repeats] for a slice of KindCalled.
func (op *KindCalled_Slice) Repeats() bool {
	return len(*op) > 0
}

// Specifies one or more nouns, in full or in part.
// Only one of the options, plus possibly 'additional_names', will match.
// Not all options are valid in all contexts.
type Names struct {
	CountedKind     *CountedKind
	KindCalled      *KindCalled
	Noun            *Noun
	Kind            *Kind
	Name            *Name
	AdditionalNames *AdditionalNames
	Markup          map[string]any
}

// names, a type of flow.
var Zt_Names typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Names) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// Implements [typeinfo.Markup]
func (op *Names) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ NounBuilder = (*Names)(nil)

// Holds a slice of type Names.
type Names_Slice []Names

// Implements [typeinfo.Instance] for a slice of Names.
func (*Names_Slice) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// Implements [typeinfo.Repeats] for a slice of Names.
func (op *Names_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches a name following another name.
type AdditionalNames struct {
	CommaAnd CommaAnd
	Names    Names
	Markup   map[string]any
}

// additional_names, a type of flow.
var Zt_AdditionalNames typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AdditionalNames) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// Implements [typeinfo.Markup]
func (op *AdditionalNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type AdditionalNames.
type AdditionalNames_Slice []AdditionalNames

// Implements [typeinfo.Instance] for a slice of AdditionalNames.
func (*AdditionalNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// Implements [typeinfo.Repeats] for a slice of AdditionalNames.
func (op *AdditionalNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// Provides English specification of a number of objects.
// ( yes, `the five the containers` is permitted. )
type CountedKind struct {
	Article     *Article
	MatchingNum MatchingNum
	Kind        Kind
	Matched     Matched
	Markup      map[string]any
}

// counted_kind, a type of flow.
var Zt_CountedKind typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CountedKind) TypeInfo() typeinfo.T {
	return &Zt_CountedKind
}

// Implements [typeinfo.Markup]
func (op *CountedKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ NounBuilder = (*CountedKind)(nil)

// Holds a slice of type CountedKind.
type CountedKind_Slice []CountedKind

// Implements [typeinfo.Instance] for a slice of CountedKind.
func (*CountedKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_CountedKind
}

// Implements [typeinfo.Repeats] for a slice of CountedKind.
func (op *CountedKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches the name of an existing kind.
// Can generate a single anonymous noun.
type Kind struct {
	Article    *Article
	Matched    Matched
	ActualKind ActualKind
	Markup     map[string]any
}

// kind, a type of flow.
var Zt_Kind typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Kind) TypeInfo() typeinfo.T {
	return &Zt_Kind
}

// Implements [typeinfo.Markup]
func (op *Kind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ NounBuilder = (*Kind)(nil)

// Holds a slice of type Kind.
type Kind_Slice []Kind

// Implements [typeinfo.Instance] for a slice of Kind.
func (*Kind_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kind
}

// Implements [typeinfo.Repeats] for a slice of Kind.
func (op *Kind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches a set of possible kinds as part of kinds_are_traits.
// jess looks for but prohibits leading traits.
type Kinds struct {
	Traits          *Traits
	Article         *Article
	Matched         Matched
	AdditionalKinds *AdditionalKinds
	Markup          map[string]any
}

// kinds, a type of flow.
var Zt_Kinds typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Kinds) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// Implements [typeinfo.Markup]
func (op *Kinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Kinds.
type Kinds_Slice []Kinds

// Implements [typeinfo.Instance] for a slice of Kinds.
func (*Kinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// Implements [typeinfo.Repeats] for a slice of Kinds.
func (op *Kinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches a kind following another kind.
type AdditionalKinds struct {
	CommaAnd CommaAnd
	Kinds    Kinds
	Markup   map[string]any
}

// additional_kinds, a type of flow.
var Zt_AdditionalKinds typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AdditionalKinds) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// Implements [typeinfo.Markup]
func (op *AdditionalKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type AdditionalKinds.
type AdditionalKinds_Slice []AdditionalKinds

// Implements [typeinfo.Instance] for a slice of AdditionalKinds.
func (*AdditionalKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// Implements [typeinfo.Repeats] for a slice of AdditionalKinds.
func (op *AdditionalKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches the name of a field in a kind.
type Property struct {
	Article *Article
	Matched string
	Markup  map[string]any
}

// property, a type of flow.
var Zt_Property typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Property) TypeInfo() typeinfo.T {
	return &Zt_Property
}

// Implements [typeinfo.Markup]
func (op *Property) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Property.
type Property_Slice []Property

// Implements [typeinfo.Instance] for a slice of Property.
func (*Property_Slice) TypeInfo() typeinfo.T {
	return &Zt_Property
}

// Implements [typeinfo.Repeats] for a slice of Property.
func (op *Property_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches the name of an (existing) trait.
type Trait struct {
	Article *Article
	Matched string
	Markup  map[string]any
}

// trait, a type of flow.
var Zt_Trait typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Trait) TypeInfo() typeinfo.T {
	return &Zt_Trait
}

// Implements [typeinfo.Markup]
func (op *Trait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Trait.
type Trait_Slice []Trait

// Implements [typeinfo.Instance] for a slice of Trait.
func (*Trait_Slice) TypeInfo() typeinfo.T {
	return &Zt_Trait
}

// Implements [typeinfo.Repeats] for a slice of Trait.
func (op *Trait_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches at least one trait.
type Traits struct {
	Trait            Trait
	AdditionalTraits *AdditionalTraits
	Markup           map[string]any
}

// traits, a type of flow.
var Zt_Traits typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Traits) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// Implements [typeinfo.Markup]
func (op *Traits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Traits.
type Traits_Slice []Traits

// Implements [typeinfo.Instance] for a slice of Traits.
func (*Traits_Slice) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// Implements [typeinfo.Repeats] for a slice of Traits.
func (op *Traits_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches a trait following another trait.
type AdditionalTraits struct {
	CommaAnd *CommaAnd
	Traits   Traits
	Markup   map[string]any
}

// additional_traits, a type of flow.
var Zt_AdditionalTraits typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AdditionalTraits) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// Implements [typeinfo.Markup]
func (op *AdditionalTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type AdditionalTraits.
type AdditionalTraits_Slice []AdditionalTraits

// Implements [typeinfo.Instance] for a slice of AdditionalTraits.
func (*AdditionalTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// Implements [typeinfo.Repeats] for a slice of AdditionalTraits.
func (op *AdditionalTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches one or more predefined words.
type Words struct {
	Matched Matched
	Markup  map[string]any
}

// words, a type of flow.
var Zt_Words typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Words) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// Implements [typeinfo.Markup]
func (op *Words) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Words.
type Words_Slice []Words

// Implements [typeinfo.Instance] for a slice of Words.
func (*Words_Slice) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// Implements [typeinfo.Repeats] for a slice of Words.
func (op *Words_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches one or more predefined verbs.
// ( verbs are nouns of the verb kind )
type Verb struct {
	Text   string
	Markup map[string]any
}

// verb, a type of flow.
var Zt_Verb typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Verb) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// Implements [typeinfo.Markup]
func (op *Verb) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Verb.
type Verb_Slice []Verb

// Implements [typeinfo.Instance] for a slice of Verb.
func (*Verb_Slice) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// Implements [typeinfo.Repeats] for a slice of Verb.
func (op *Verb_Slice) Repeats() bool {
	return len(*op) > 0
}

// This is the union of all possible matching phrases.
// For any given plain text sentence,
// jess tries each of these looking for the first to succeed.
// Different phrases belong to different scheduled phases;
// scheduling is handled manually.
// ( tbd: an alternative might be slots and some scheduling metadata;
// this is fine for now )
type MatchingPhrases struct {
	Understand          Understand
	TimedRule           TimedRule
	KindsAreKind        KindsAreKind
	AspectsAreTraits    AspectsAreTraits
	KindsAreTraits      KindsAreTraits
	KindsHaveProperties KindsHaveProperties
	KindsAreEither      KindsAreEither
	MapConnections      MapConnections
	MapDirections       MapDirections
	MapLocations        MapLocations
	PropertyNounValue   PropertyNounValue
	NounPropertyValue   NounPropertyValue
	VerbNamesAreNames   VerbNamesAreNames
	NamesVerbNames      NamesVerbNames
	NamesAreLikeVerbs   NamesAreLikeVerbs
	Markup              map[string]any
}

// matching_phrases, a type of flow.
var Zt_MatchingPhrases typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MatchingPhrases) TypeInfo() typeinfo.T {
	return &Zt_MatchingPhrases
}

// Implements [typeinfo.Markup]
func (op *MatchingPhrases) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type MatchingPhrases.
type MatchingPhrases_Slice []MatchingPhrases

// Implements [typeinfo.Instance] for a slice of MatchingPhrases.
func (*MatchingPhrases_Slice) TypeInfo() typeinfo.T {
	return &Zt_MatchingPhrases
}

// Implements [typeinfo.Repeats] for a slice of MatchingPhrases.
func (op *MatchingPhrases_Slice) Repeats() bool {
	return len(*op) > 0
}

// Names are "a kind of"/"kinds of" traits kind:any.
// Interesting to note that inform allows "some kind/s of", but
// this is more strict.
// Like inform `The animals called kittens are a kind of things.` is legal.
type KindsAreKind struct {
	Names        Names
	Are          Are
	KindsAreKind Words
	Traits       *Traits
	Name         Name
	Markup       map[string]any
}

// kinds_are_kind, a type of flow.
var Zt_KindsAreKind typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindsAreKind) TypeInfo() typeinfo.T {
	return &Zt_KindsAreKind
}

// Implements [typeinfo.Markup]
func (op *KindsAreKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type KindsAreKind.
type KindsAreKind_Slice []KindsAreKind

// Implements [typeinfo.Instance] for a slice of KindsAreKind.
func (*KindsAreKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreKind
}

// Implements [typeinfo.Repeats] for a slice of KindsAreKind.
func (op *KindsAreKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Assigns default traits to a kind.
// kinds:objects are "usually" traits.
// Inform doesn't require the "usually", but i like it as a way to differentiate phrases about kinds vs. phrases about nouns.
//
// Future: allow limiting traits to kinds with other traits.
// For example, in Inform:
//
//	The closed containers are fixed in place.
//
// makes any containers that are *initially* closed also immovable.
type KindsAreTraits struct {
	Kinds   Kinds
	Are     Are
	Usually Words
	Traits  Traits
	Markup  map[string]any
}

// kinds_are_traits, a type of flow.
var Zt_KindsAreTraits typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// Implements [typeinfo.Markup]
func (op *KindsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type KindsAreTraits.
type KindsAreTraits_Slice []KindsAreTraits

// Implements [typeinfo.Instance] for a slice of KindsAreTraits.
func (*KindsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// Implements [typeinfo.Repeats] for a slice of KindsAreTraits.
func (op *KindsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines traits for aspects that can be (re)used by various other kinds.
// ex.
//
//	The colors are a kind of aspect. The colors are red, blue, and greasy green.
//
// The commands aspects_are_traits, kinds_are_traits, and names_are_like_verbs all handle similar phrasing.
type AspectsAreTraits struct {
	Aspect     Kind
	Are        Are
	PlainNames Names
	Markup     map[string]any
}

// aspects_are_traits, a type of flow.
var Zt_AspectsAreTraits typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AspectsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_AspectsAreTraits
}

// Implements [typeinfo.Markup]
func (op *AspectsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type AspectsAreTraits.
type AspectsAreTraits_Slice []AspectsAreTraits

// Implements [typeinfo.Instance] for a slice of AspectsAreTraits.
func (*AspectsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AspectsAreTraits
}

// Implements [typeinfo.Repeats] for a slice of AspectsAreTraits.
func (op *AspectsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// Verb names are (other) names.
// ex.
//
//	In the coffin are some coins, a notebook, and the gripping hand.
//
// This intentionally doesn't recognize adjectives attached to named names.
// "In the closed coffin" generates a name with the name "closed coffin"
// not a coffin in an initially closed state.
type VerbNamesAreNames struct {
	Verb       Verb
	Names      Names
	Are        Are
	OtherNames Names
	Markup     map[string]any
}

// verb_names_are_names, a type of flow.
var Zt_VerbNamesAreNames typeinfo.Flow

// Implements [typeinfo.Instance]
func (*VerbNamesAreNames) TypeInfo() typeinfo.T {
	return &Zt_VerbNamesAreNames
}

// Implements [typeinfo.Markup]
func (op *VerbNamesAreNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type VerbNamesAreNames.
type VerbNamesAreNames_Slice []VerbNamesAreNames

// Implements [typeinfo.Instance] for a slice of VerbNamesAreNames.
func (*VerbNamesAreNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbNamesAreNames
}

// Implements [typeinfo.Repeats] for a slice of VerbNamesAreNames.
func (op *VerbNamesAreNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// Names are verb (other) names.
// ex.
//
//	The thing called the stake is on the supporter called the altar.
type NamesVerbNames struct {
	Names      Names
	Are        Are
	Verb       Verb
	OtherNames Names
	Markup     map[string]any
}

// names_verb_names, a type of flow.
var Zt_NamesVerbNames typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NamesVerbNames) TypeInfo() typeinfo.T {
	return &Zt_NamesVerbNames
}

// Implements [typeinfo.Markup]
func (op *NamesVerbNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type NamesVerbNames.
type NamesVerbNames_Slice []NamesVerbNames

// Implements [typeinfo.Instance] for a slice of NamesVerbNames.
func (*NamesVerbNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamesVerbNames
}

// Implements [typeinfo.Repeats] for a slice of NamesVerbNames.
func (op *NamesVerbNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// Names are adjectives [verb names].
// ex.
//
//	The bottle is a transparent, open, container.
//	The coffin is a closed container [in the antechamber].
//
// This is the *only* way of assigning names initial states directly.
// All other phrases require a kind to be involved, here the kind is optional.
type NamesAreLikeVerbs struct {
	Names      Names
	Are        Are
	Adjectives Adjectives
	VerbPhrase *VerbPhrase
	Markup     map[string]any
}

// names_are_like_verbs, a type of flow.
var Zt_NamesAreLikeVerbs typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NamesAreLikeVerbs) TypeInfo() typeinfo.T {
	return &Zt_NamesAreLikeVerbs
}

// Implements [typeinfo.Markup]
func (op *NamesAreLikeVerbs) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type NamesAreLikeVerbs.
type NamesAreLikeVerbs_Slice []NamesAreLikeVerbs

// Implements [typeinfo.Instance] for a slice of NamesAreLikeVerbs.
func (*NamesAreLikeVerbs_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamesAreLikeVerbs
}

// Implements [typeinfo.Repeats] for a slice of NamesAreLikeVerbs.
func (op *NamesAreLikeVerbs_Slice) Repeats() bool {
	return len(*op) > 0
}

// A phrase, starting with a verb, that ends a sentence.
// ex.
//
//	... in the kitchen.
//	... carries the football and sousaphone.
type VerbPhrase struct {
	Verb       Verb
	PlainNames Names
	Markup     map[string]any
}

// verb_phrase, a type of flow.
var Zt_VerbPhrase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*VerbPhrase) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// Implements [typeinfo.Markup]
func (op *VerbPhrase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type VerbPhrase.
type VerbPhrase_Slice []VerbPhrase

// Implements [typeinfo.Instance] for a slice of VerbPhrase.
func (*VerbPhrase_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// Implements [typeinfo.Repeats] for a slice of VerbPhrase.
func (op *VerbPhrase_Slice) Repeats() bool {
	return len(*op) > 0
}

// One or more phrases consisting of traits and a kind.
// while all parts are marked as optional, matching expects
// there will be at least one trait or one kind
// and that there can only be additional adjective phrases
// if the previous one ended with a kind.
// ex.
//
//	a container
//	closed and fixed in place
//	a closed container and a fixed in place thing
type Adjectives struct {
	Traits               *Traits
	CommaAnd             *CommaAnd
	Kind                 *Kind
	AdditionalAdjectives *AdditionalAdjectives
	Markup               map[string]any
}

// adjectives, a type of flow.
var Zt_Adjectives typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Adjectives) TypeInfo() typeinfo.T {
	return &Zt_Adjectives
}

// Implements [typeinfo.Markup]
func (op *Adjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Adjectives.
type Adjectives_Slice []Adjectives

// Implements [typeinfo.Instance] for a slice of Adjectives.
func (*Adjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_Adjectives
}

// Implements [typeinfo.Repeats] for a slice of Adjectives.
func (op *Adjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

// An additional set of traits and a kind.
type AdditionalAdjectives struct {
	CommaAnd   CommaAnd
	Adjectives Adjectives
	Markup     map[string]any
}

// additional_adjectives, a type of flow.
var Zt_AdditionalAdjectives typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AdditionalAdjectives) TypeInfo() typeinfo.T {
	return &Zt_AdditionalAdjectives
}

// Implements [typeinfo.Markup]
func (op *AdditionalAdjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type AdditionalAdjectives.
type AdditionalAdjectives_Slice []AdditionalAdjectives

// Implements [typeinfo.Instance] for a slice of AdditionalAdjectives.
func (*AdditionalAdjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalAdjectives
}

// Implements [typeinfo.Repeats] for a slice of AdditionalAdjectives.
func (op *AdditionalAdjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

// Assigns a default value to a noun.
// ex.
//
//	The description of the pen is "mightier than the sword.
//
// As a special case this also allows a list of quoted text
// indicated with "are" ( versus "is" )
type PropertyNounValue struct {
	Article     *Article
	Property    Property
	Of          Words
	NamedNoun   NamedNoun
	Are         Are
	SingleValue *SingleValue
	QuotedTexts *QuotedTexts
	Markup      map[string]any
}

// property_noun_value, a type of flow.
var Zt_PropertyNounValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PropertyNounValue) TypeInfo() typeinfo.T {
	return &Zt_PropertyNounValue
}

// Implements [typeinfo.Markup]
func (op *PropertyNounValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type PropertyNounValue.
type PropertyNounValue_Slice []PropertyNounValue

// Implements [typeinfo.Instance] for a slice of PropertyNounValue.
func (*PropertyNounValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_PropertyNounValue
}

// Implements [typeinfo.Repeats] for a slice of PropertyNounValue.
func (op *PropertyNounValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Assigns a default value to a noun.
// ex.
//
//	The pen has (the) description (of) "mightier than the sword."
//
// like inform, adjectives ( in phrases with "is" ) cannot be combined with property phrases ( "has/of" )
type NounPropertyValue struct {
	NamedNoun   NamedNoun
	Has         Words
	Article     *Article
	Property    Property
	Of          *Words
	SingleValue SingleValue
	Markup      map[string]any
}

// noun_property_value, a type of flow.
var Zt_NounPropertyValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NounPropertyValue) TypeInfo() typeinfo.T {
	return &Zt_NounPropertyValue
}

// Implements [typeinfo.Markup]
func (op *NounPropertyValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type NounPropertyValue.
type NounPropertyValue_Slice []NounPropertyValue

// Implements [typeinfo.Instance] for a slice of NounPropertyValue.
func (*NounPropertyValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_NounPropertyValue
}

// Implements [typeinfo.Repeats] for a slice of NounPropertyValue.
func (op *NounPropertyValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// This matches only one of its options.
// ( The options could be represented as a slot; this feels easier for now ).
type SingleValue struct {
	QuotedText  *QuotedText
	MatchingNum *MatchingNum
	Noun        *Noun
	Kind        *Kind
	Markup      map[string]any
}

// single_value, a type of flow.
var Zt_SingleValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SingleValue) TypeInfo() typeinfo.T {
	return &Zt_SingleValue
}

// Implements [typeinfo.Markup]
func (op *SingleValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type SingleValue.
type SingleValue_Slice []SingleValue

// Implements [typeinfo.Instance] for a slice of SingleValue.
func (*SingleValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_SingleValue
}

// Implements [typeinfo.Repeats] for a slice of SingleValue.
func (op *SingleValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Text that begins and ends with double quotes.
// The quotes themselves are not part of the matched text.
type QuotedText struct {
	Matched string
	Markup  map[string]any
}

// quoted_text, a type of flow.
var Zt_QuotedText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*QuotedText) TypeInfo() typeinfo.T {
	return &Zt_QuotedText
}

// Implements [typeinfo.Markup]
func (op *QuotedText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type QuotedText.
type QuotedText_Slice []QuotedText

// Implements [typeinfo.Instance] for a slice of QuotedText.
func (*QuotedText_Slice) TypeInfo() typeinfo.T {
	return &Zt_QuotedText
}

// Implements [typeinfo.Repeats] for a slice of QuotedText.
func (op *QuotedText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Reads a number specified in words or as digits.
// Stores the result as the parsed number.
type MatchingNum struct {
	Value  float64
	Markup map[string]any
}

// matching_num, a type of flow.
var Zt_MatchingNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MatchingNum) TypeInfo() typeinfo.T {
	return &Zt_MatchingNum
}

// Implements [typeinfo.Markup]
func (op *MatchingNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type MatchingNum.
type MatchingNum_Slice []MatchingNum

// Implements [typeinfo.Instance] for a slice of MatchingNum.
func (*MatchingNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_MatchingNum
}

// Implements [typeinfo.Repeats] for a slice of MatchingNum.
func (op *MatchingNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Kinds "have" a ("list of") type ("called" name).
// ex.
//
//	Things have some text called a description.
type KindsHaveProperties struct {
	Kind         Kind
	Have         Words
	Article      *Article
	ListOf       string
	PropertyType PropertyType
	CalledName   *CalledName
	Markup       map[string]any
}

// kinds_have_properties, a type of flow.
var Zt_KindsHaveProperties typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindsHaveProperties) TypeInfo() typeinfo.T {
	return &Zt_KindsHaveProperties
}

// Implements [typeinfo.Markup]
func (op *KindsHaveProperties) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type KindsHaveProperties.
type KindsHaveProperties_Slice []KindsHaveProperties

// Implements [typeinfo.Instance] for a slice of KindsHaveProperties.
func (*KindsHaveProperties_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsHaveProperties
}

// Implements [typeinfo.Repeats] for a slice of KindsHaveProperties.
func (op *KindsHaveProperties_Slice) Repeats() bool {
	return len(*op) > 0
}

// Used for kinds_have_properties.
// like kind_called, specifying "called the/our ..." gives the noun an indefinite article.
type CalledName struct {
	Called Called
	Name   Name
	Markup map[string]any
}

// called_name, a type of flow.
var Zt_CalledName typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CalledName) TypeInfo() typeinfo.T {
	return &Zt_CalledName
}

// Implements [typeinfo.Markup]
func (op *CalledName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type CalledName.
type CalledName_Slice []CalledName

// Implements [typeinfo.Instance] for a slice of CalledName.
func (*CalledName_Slice) TypeInfo() typeinfo.T {
	return &Zt_CalledName
}

// Implements [typeinfo.Repeats] for a slice of CalledName.
func (op *CalledName_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches text, number, kind ( kind|aspect|record )
// as part of 'kinds_have_properties'.
// Exactly one member can match.
type PropertyType struct {
	Primitive string
	Kind      *Kind
	Markup    map[string]any
}

// property_type, a type of flow.
var Zt_PropertyType typeinfo.Flow

// Implements [typeinfo.Instance]
func (*PropertyType) TypeInfo() typeinfo.T {
	return &Zt_PropertyType
}

// Implements [typeinfo.Markup]
func (op *PropertyType) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type PropertyType.
type PropertyType_Slice []PropertyType

// Implements [typeinfo.Instance] for a slice of PropertyType.
func (*PropertyType_Slice) TypeInfo() typeinfo.T {
	return &Zt_PropertyType
}

// Implements [typeinfo.Repeats] for a slice of PropertyType.
func (op *PropertyType_Slice) Repeats() bool {
	return len(*op) > 0
}

// Kinds ("can be"|"are either") new_trait [or new_trait...].
// ex.
//
//	A thing can be open or closed.
type KindsAreEither struct {
	Kind   Kind
	CanBe  Words
	Traits NewTrait
	Markup map[string]any
}

// kinds_are_either, a type of flow.
var Zt_KindsAreEither typeinfo.Flow

// Implements [typeinfo.Instance]
func (*KindsAreEither) TypeInfo() typeinfo.T {
	return &Zt_KindsAreEither
}

// Implements [typeinfo.Markup]
func (op *KindsAreEither) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type KindsAreEither.
type KindsAreEither_Slice []KindsAreEither

// Implements [typeinfo.Instance] for a slice of KindsAreEither.
func (*KindsAreEither_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreEither
}

// Implements [typeinfo.Repeats] for a slice of KindsAreEither.
func (op *KindsAreEither_Slice) Repeats() bool {
	return len(*op) > 0
}

// One or more new trait names,
// separated by the word "or".
type NewTrait struct {
	Matched  Matched
	NewTrait *NewTrait
	Markup   map[string]any
}

// new_trait, a type of flow.
var Zt_NewTrait typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NewTrait) TypeInfo() typeinfo.T {
	return &Zt_NewTrait
}

// Implements [typeinfo.Markup]
func (op *NewTrait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type NewTrait.
type NewTrait_Slice []NewTrait

// Implements [typeinfo.Instance] for a slice of NewTrait.
func (*NewTrait_Slice) TypeInfo() typeinfo.T {
	return &Zt_NewTrait
}

// Implements [typeinfo.Repeats] for a slice of NewTrait.
func (op *NewTrait_Slice) Repeats() bool {
	return len(*op) > 0
}

// One or more strings of quoted text
// separated by the words "and", "comma", or "or".
type QuotedTexts struct {
	QuotedText     QuotedText
	AdditionalText *AdditionalText
	Markup         map[string]any
}

// quoted_texts, a type of flow.
var Zt_QuotedTexts typeinfo.Flow

// Implements [typeinfo.Instance]
func (*QuotedTexts) TypeInfo() typeinfo.T {
	return &Zt_QuotedTexts
}

// Implements [typeinfo.Markup]
func (op *QuotedTexts) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type QuotedTexts.
type QuotedTexts_Slice []QuotedTexts

// Implements [typeinfo.Instance] for a slice of QuotedTexts.
func (*QuotedTexts_Slice) TypeInfo() typeinfo.T {
	return &Zt_QuotedTexts
}

// Implements [typeinfo.Repeats] for a slice of QuotedTexts.
func (op *QuotedTexts_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches a text following another some previous text.
type AdditionalText struct {
	CommaAndOr  CommaAndOr
	QuotedTexts QuotedTexts
	Markup      map[string]any
}

// additional_text, a type of flow.
var Zt_AdditionalText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AdditionalText) TypeInfo() typeinfo.T {
	return &Zt_AdditionalText
}

// Implements [typeinfo.Markup]
func (op *AdditionalText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type AdditionalText.
type AdditionalText_Slice []AdditionalText

// Implements [typeinfo.Instance] for a slice of AdditionalText.
func (*AdditionalText_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalText
}

// Implements [typeinfo.Repeats] for a slice of AdditionalText.
func (op *AdditionalText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches rule prefixes:
// before, instead of, when, after, report
type RulePrefix struct {
	PrefixValue PrefixValue
	Markup      map[string]any
}

// rule_prefix, a type of flow.
var Zt_RulePrefix typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RulePrefix) TypeInfo() typeinfo.T {
	return &Zt_RulePrefix
}

// Implements [typeinfo.Markup]
func (op *RulePrefix) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type RulePrefix.
type RulePrefix_Slice []RulePrefix

// Implements [typeinfo.Instance] for a slice of RulePrefix.
func (*RulePrefix_Slice) TypeInfo() typeinfo.T {
	return &Zt_RulePrefix
}

// Implements [typeinfo.Repeats] for a slice of RulePrefix.
func (op *RulePrefix_Slice) Repeats() bool {
	return len(*op) > 0
}

// Controls what to do after matching a rule.
// Matches "then continue", "then stop", "then skip phase",
// and "begins", "ends" ( for domain rules )
// with an optional leading comma.
type RuleSuffix struct {
	SuffixValue SuffixValue
	Markup      map[string]any
}

// rule_suffix, a type of flow.
var Zt_RuleSuffix typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RuleSuffix) TypeInfo() typeinfo.T {
	return &Zt_RuleSuffix
}

// Implements [typeinfo.Markup]
func (op *RuleSuffix) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type RuleSuffix.
type RuleSuffix_Slice []RuleSuffix

// Implements [typeinfo.Instance] for a slice of RuleSuffix.
func (*RuleSuffix_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleSuffix
}

// Implements [typeinfo.Repeats] for a slice of RuleSuffix.
func (op *RuleSuffix_Slice) Repeats() bool {
	return len(*op) > 0
}

// Specific names can follow rule declarations.
// ex.
//
//	( this is the witness light rule )
type RuleName struct {
	Prefix  bool
	Article string
	Matched Matched
	Suffix  bool
	Markup  map[string]any
}

// rule_name, a type of flow.
var Zt_RuleName typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RuleName) TypeInfo() typeinfo.T {
	return &Zt_RuleName
}

// Implements [typeinfo.Markup]
func (op *RuleName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type RuleName.
type RuleName_Slice []RuleName

// Implements [typeinfo.Instance] for a slice of RuleName.
func (*RuleName_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleName
}

// Implements [typeinfo.Repeats] for a slice of RuleName.
func (op *RuleName_Slice) Repeats() bool {
	return len(*op) > 0
}

type RuleTarget struct {
	Kind   *Kind
	Noun   *Noun
	Markup map[string]any
}

// rule_target, a type of flow.
var Zt_RuleTarget typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RuleTarget) TypeInfo() typeinfo.T {
	return &Zt_RuleTarget
}

// Implements [typeinfo.Markup]
func (op *RuleTarget) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type RuleTarget.
type RuleTarget_Slice []RuleTarget

// Implements [typeinfo.Instance] for a slice of RuleTarget.
func (*RuleTarget_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleTarget
}

// Implements [typeinfo.Repeats] for a slice of RuleTarget.
func (op *RuleTarget_Slice) Repeats() bool {
	return len(*op) > 0
}

// Phrases can break out of plain text and into structured tell docs.
// The documents start with a colon (:) followed by a newline
// the next line is assumed to be an indented tell mapping or sequence
// which ends with the first unindented line.
// Sequences are treated as execute blocks;
// Mappings are assumed to be a valid eval
// ( ie. an implementation of one of the rtti interfaces. )
type SubAssignment struct {
	Assignment rtti.Assignment
	Markup     map[string]any
}

// sub_assignment, a type of flow.
var Zt_SubAssignment typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SubAssignment) TypeInfo() typeinfo.T {
	return &Zt_SubAssignment
}

// Implements [typeinfo.Markup]
func (op *SubAssignment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type SubAssignment.
type SubAssignment_Slice []SubAssignment

// Implements [typeinfo.Instance] for a slice of SubAssignment.
func (*SubAssignment_Slice) TypeInfo() typeinfo.T {
	return &Zt_SubAssignment
}

// Implements [typeinfo.Repeats] for a slice of SubAssignment.
func (op *SubAssignment_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches pattern rule definitions.
type TimedRule struct {
	RulePrefix    RulePrefix
	Someone       bool
	Pattern       Kind
	RuleTarget    *RuleTarget
	RuleSuffix    *RuleSuffix
	RuleName      *RuleName
	SubAssignment SubAssignment
	Markup        map[string]any
}

// timed_rule, a type of flow.
var Zt_TimedRule typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TimedRule) TypeInfo() typeinfo.T {
	return &Zt_TimedRule
}

// Implements [typeinfo.Markup]
func (op *TimedRule) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type TimedRule.
type TimedRule_Slice []TimedRule

// Implements [typeinfo.Instance] for a slice of TimedRule.
func (*TimedRule_Slice) TypeInfo() typeinfo.T {
	return &Zt_TimedRule
}

// Implements [typeinfo.Repeats] for a slice of TimedRule.
func (op *TimedRule_Slice) Repeats() bool {
	return len(*op) > 0
}

// Various phrases, all starting with the word "Understand".
type Understand struct {
	Understand  Words
	QuotedTexts QuotedTexts
	As          Words
	Article     *Article
	PluralOf    string
	Names       Names
	Markup      map[string]any
}

// understand, a type of flow.
var Zt_Understand typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Understand) TypeInfo() typeinfo.T {
	return &Zt_Understand
}

// Implements [typeinfo.Markup]
func (op *Understand) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Understand.
type Understand_Slice []Understand

// Implements [typeinfo.Instance] for a slice of Understand.
func (*Understand_Slice) TypeInfo() typeinfo.T {
	return &Zt_Understand
}

// Implements [typeinfo.Repeats] for a slice of Understand.
func (op *Understand_Slice) Repeats() bool {
	return len(*op) > 0
}

// A mapping declaration starting with a room or door.
// ex.
//
//	A dead end called the Airport is west of the Road and north of the Farm.
type MapLocations struct {
	Linking              Linking
	Are                  Are
	DirectionOfLinking   DirectionOfLinking
	AdditionalDirections *AdditionalDirections
	Markup               map[string]any
}

// map_locations, a type of flow.
var Zt_MapLocations typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MapLocations) TypeInfo() typeinfo.T {
	return &Zt_MapLocations
}

// Implements [typeinfo.Markup]
func (op *MapLocations) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type MapLocations.
type MapLocations_Slice []MapLocations

// Implements [typeinfo.Instance] for a slice of MapLocations.
func (*MapLocations_Slice) TypeInfo() typeinfo.T {
	return &Zt_MapLocations
}

// Implements [typeinfo.Repeats] for a slice of MapLocations.
func (op *MapLocations_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches additional directions.
// only used by map_locations.
type AdditionalDirections struct {
	CommaAnd             CommaAnd
	DirectionOfLinking   DirectionOfLinking
	AdditionalDirections *AdditionalDirections
	Markup               map[string]any
}

// additional_directions, a type of flow.
var Zt_AdditionalDirections typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AdditionalDirections) TypeInfo() typeinfo.T {
	return &Zt_AdditionalDirections
}

// Implements [typeinfo.Markup]
func (op *AdditionalDirections) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type AdditionalDirections.
type AdditionalDirections_Slice []AdditionalDirections

// Implements [typeinfo.Instance] for a slice of AdditionalDirections.
func (*AdditionalDirections_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalDirections
}

// Implements [typeinfo.Repeats] for a slice of AdditionalDirections.
func (op *AdditionalDirections_Slice) Repeats() bool {
	return len(*op) > 0
}

// A mapping declaration starting with a direction.
type MapDirections struct {
	DirectionOfLinking DirectionOfLinking
	Are                Are
	Linking            *Linking
	Redirect           *DirectionOfLinking
	Markup             map[string]any
}

// map_directions, a type of flow.
var Zt_MapDirections typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MapDirections) TypeInfo() typeinfo.T {
	return &Zt_MapDirections
}

// Implements [typeinfo.Markup]
func (op *MapDirections) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type MapDirections.
type MapDirections_Slice []MapDirections

// Implements [typeinfo.Instance] for a slice of MapDirections.
func (*MapDirections_Slice) TypeInfo() typeinfo.T {
	return &Zt_MapDirections
}

// Implements [typeinfo.Repeats] for a slice of MapDirections.
func (op *MapDirections_Slice) Repeats() bool {
	return len(*op) > 0
}

// A mapping declaration to set the destination of doors.
// ex.
//
//	Through the long slide is the cellar.
//	Through the blue door and the red door is the kitchen.
//
// The destination of a door is always treated as a room or nowhere.
// ( Inform doesn't allow nowhere, but it seems like a good idea. )
type MapConnections struct {
	Through         bool
	Doors           Linking
	AdditionalLinks *AdditionalLinks
	Are             Are
	Room            Linking
	Markup          map[string]any
}

// map_connections, a type of flow.
var Zt_MapConnections typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MapConnections) TypeInfo() typeinfo.T {
	return &Zt_MapConnections
}

// Implements [typeinfo.Markup]
func (op *MapConnections) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type MapConnections.
type MapConnections_Slice []MapConnections

// Implements [typeinfo.Instance] for a slice of MapConnections.
func (*MapConnections_Slice) TypeInfo() typeinfo.T {
	return &Zt_MapConnections
}

// Implements [typeinfo.Repeats] for a slice of MapConnections.
func (op *MapConnections_Slice) Repeats() bool {
	return len(*op) > 0
}

// Partial phrase for mapping declarations.
type DirectionOfLinking struct {
	Direction Direction
	FromOf    Words
	Linking   Linking
	Markup    map[string]any
}

// direction_of_linking, a type of flow.
var Zt_DirectionOfLinking typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DirectionOfLinking) TypeInfo() typeinfo.T {
	return &Zt_DirectionOfLinking
}

// Implements [typeinfo.Markup]
func (op *DirectionOfLinking) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type DirectionOfLinking.
type DirectionOfLinking_Slice []DirectionOfLinking

// Implements [typeinfo.Instance] for a slice of DirectionOfLinking.
func (*DirectionOfLinking_Slice) TypeInfo() typeinfo.T {
	return &Zt_DirectionOfLinking
}

// Implements [typeinfo.Repeats] for a slice of DirectionOfLinking.
func (op *DirectionOfLinking_Slice) Repeats() bool {
	return len(*op) > 0
}

// Matches some existing compass direction.
type Direction struct {
	Text   string
	Markup map[string]any
}

// direction, a type of flow.
var Zt_Direction typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Direction) TypeInfo() typeinfo.T {
	return &Zt_Direction
}

// Implements [typeinfo.Markup]
func (op *Direction) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Direction.
type Direction_Slice []Direction

// Implements [typeinfo.Instance] for a slice of Direction.
func (*Direction_Slice) TypeInfo() typeinfo.T {
	return &Zt_Direction
}

// Implements [typeinfo.Repeats] for a slice of Direction.
func (op *Direction_Slice) Repeats() bool {
	return len(*op) > 0
}

// Generates a room, a door, or nowhere.
// ( This i similar to, but distinct from other noun matching phrases. )
type Linking struct {
	Nowhere    bool
	KindCalled *KindCalled
	Noun       *Noun
	Name       *Name
	Markup     map[string]any
}

// linking, a type of flow.
var Zt_Linking typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Linking) TypeInfo() typeinfo.T {
	return &Zt_Linking
}

// Implements [typeinfo.Markup]
func (op *Linking) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Linking.
type Linking_Slice []Linking

// Implements [typeinfo.Instance] for a slice of Linking.
func (*Linking_Slice) TypeInfo() typeinfo.T {
	return &Zt_Linking
}

// Implements [typeinfo.Repeats] for a slice of Linking.
func (op *Linking_Slice) Repeats() bool {
	return len(*op) > 0
}

// Partial phrase used for map connections.
// This allows multiple doors, etc. on the lhs.
type AdditionalLinks struct {
	CommaAnd        CommaAnd
	Linking         Linking
	AdditionalLinks *AdditionalLinks
	Markup          map[string]any
}

// additional_links, a type of flow.
var Zt_AdditionalLinks typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AdditionalLinks) TypeInfo() typeinfo.T {
	return &Zt_AdditionalLinks
}

// Implements [typeinfo.Markup]
func (op *AdditionalLinks) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type AdditionalLinks.
type AdditionalLinks_Slice []AdditionalLinks

// Implements [typeinfo.Instance] for a slice of AdditionalLinks.
func (*AdditionalLinks_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalLinks
}

// Implements [typeinfo.Repeats] for a slice of AdditionalLinks.
func (op *AdditionalLinks_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Article = typeinfo.Flow{
		Name: "article",
		Lede: "article",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "flags",
			Label:   "flags",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"One of a predefined set of determiners: the, a/n, some, our.", "This only matches if the first letter is lowercase, or uppercase at the start of a sentence;", "otherwise, the article gets treated as part of the name.", "", "Also note:", "  - The lack of a recognized article makes something proper-named.", "  - See 'counted_kind' for names with leading numbers: (ex. five or 27).", "  - Using \"some\"  (ex. \"some coins\") will set nouns as \"plural named\"."},
		},
	}
	Zt_CommaAnd = typeinfo.Flow{
		Name: "comma_and",
		Lede: "comma_and",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"This matches commas, \"and\", or \", and\".", "It relies on the fact package match treats commas and the word \"and\" each as their own words."},
		},
	}
	Zt_CommaAndOr = typeinfo.Flow{
		Name: "comma_and_or",
		Lede: "comma_and_or",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Matches commas, \"and\", or \"or\".", "relies on the fact package match treats commas and ands each as their own words."},
		},
	}
	Zt_Are = typeinfo.Flow{
		Name: "are",
		Lede: "are",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "Matches the words \"is\" or \"are\".",
		},
	}
	Zt_Called = typeinfo.Flow{
		Name: "called",
		Lede: "called",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "Matches the word \"called\".",
		},
	}
	Zt_Name = typeinfo.Flow{
		Name: "name",
		Lede: "name",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Specifies a name who's meaning depends on context.", "For example, when matching: \"Gold Roger's treasure chest is a container. The chest is open.\"", "the \"chest\" implies the noun \"treasure chest.\"", "In other cases, the name might be a kind, or trait, or pretty much anything else.", "", "To optimizing matching the words \"is/are/comma/and\" are never part of name names.", "", "Future: allow quoted \"titles\" ( which are then allowed to break those assumptions )"},
		},
	}
	Zt_Noun = typeinfo.Flow{
		Name: "noun",
		Lede: "noun",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "the string that matched ( a noun name or alias )",
			},
			Type: &Zt_Matched,
		}, {
			Name:    "actual_noun",
			Label:   "actual_noun",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Matches an existing noun", "( by checking multiple words for the best match )."},
		},
	}
	Zt_NamedNoun = typeinfo.Flow{
		Name: "named_noun",
		Lede: "named_noun",
		Terms: []typeinfo.Term{{
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Type:     &Zt_Noun,
		}, {
			Name:     "name",
			Label:    "name",
			Optional: true,
			Type:     &Zt_Name,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": "Matches an existing noun, or if not: then something new.",
		},
	}
	Zt_KindCalled = typeinfo.Flow{
		Name: "kind_called",
		Lede: "kind_called",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"note: doesn't use 'adjectives' because this doesn't allow", "repetitions of the traits and kind."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "called",
			Label: "called",
			Type:  &Zt_Called,
		}, {
			Name:  "named_noun",
			Label: "named_noun",
			Type:  &Zt_NamedNoun,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a name and its kind in a single phrase.", "Matches: (traits) kind \"called\" {the name}.", "For example:", "   The closed container called the trunk is in the lobby.", "As per inform, the name includes all text after the word \"called\"", "until \"is\", \"are\", or the end of the sentence;", "and specifying \"called the/our ...\" gives the noun an indefinite article."},
		},
	}
	Zt_Names = typeinfo.Flow{
		Name: "names",
		Lede: "names",
		Terms: []typeinfo.Term{{
			Name:     "counted_kind",
			Label:    "counted_kind",
			Optional: true,
			Type:     &Zt_CountedKind,
		}, {
			Name:     "kind_called",
			Label:    "kind_called",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"note that because this phrase is greedy", "once used, no additional names will match."},
			},
			Type: &Zt_KindCalled,
		}, {
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Markup: map[string]any{
				"comment": "matches existing nouns",
			},
			Type: &Zt_Noun,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"used primarily for anonymous nouns: ex. \"the container\"", "note that anonymous nouns are prohibited from starting a sentence."},
			},
			Type: &Zt_Kind,
		}, {
			Name:     "name",
			Label:    "name",
			Optional: true,
			Type:     &Zt_Name,
		}, {
			Name:     "additional_names",
			Label:    "additional_names",
			Optional: true,
			Type:     &Zt_AdditionalNames,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Specifies one or more nouns, in full or in part.", "Only one of the options, plus possibly 'additional_names', will match.", "Not all options are valid in all contexts."},
		},
	}
	Zt_AdditionalNames = typeinfo.Flow{
		Name: "additional_names",
		Lede: "additional_names",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "a separator is required between names",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "Matches a name following another name.",
		},
	}
	Zt_CountedKind = typeinfo.Flow{
		Name: "counted_kind",
		Lede: "counted_kind",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matching_num",
			Label: "matching_num",
			Type:  &Zt_MatchingNum,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Provides English specification of a number of objects.", "( yes, `the five the containers` is permitted. )"},
		},
	}
	Zt_Kind = typeinfo.Flow{
		Name: "kind",
		Lede: "kind",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every kind", "it doesn't influence which kind gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "the string that matched",
			},
			Type: &Zt_Matched,
		}, {
			Name:    "actual_kind",
			Label:   "actual_kind",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Matches the name of an existing kind.", "Can generate a single anonymous noun."},
		},
	}
	Zt_Kinds = typeinfo.Flow{
		Name: "kinds",
		Lede: "kinds",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform uses traits specified here to select", "matching nouns; jess is not that clever."},
			},
			Type: &Zt_Traits,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "matches a span ending with \"is/are/comma/and\"",
			},
			Type: &Zt_Matched,
		}, {
			Name:     "additional_kinds",
			Label:    "additional_kinds",
			Optional: true,
			Type:     &Zt_AdditionalKinds,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Matches a set of possible kinds as part of kinds_are_traits.", "jess looks for but prohibits leading traits."},
		},
	}
	Zt_AdditionalKinds = typeinfo.Flow{
		Name: "additional_kinds",
		Lede: "additional_kinds",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "a separator is required between the names of kinds",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}},
		Markup: map[string]any{
			"comment": "Matches a kind following another kind.",
		},
	}
	Zt_Property = typeinfo.Flow{
		Name: "property",
		Lede: "property",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "Matches the name of a field in a kind.",
		},
	}
	Zt_Trait = typeinfo.Flow{
		Name: "trait",
		Lede: "trait",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every trait", "it doesn't influence which trait gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "Matches the name of an (existing) trait.",
		},
	}
	Zt_Traits = typeinfo.Flow{
		Name: "traits",
		Lede: "traits",
		Terms: []typeinfo.Term{{
			Name:  "trait",
			Label: "trait",
			Type:  &Zt_Trait,
		}, {
			Name:     "additional_traits",
			Label:    "additional_traits",
			Optional: true,
			Type:     &Zt_AdditionalTraits,
		}},
		Markup: map[string]any{
			"comment": "Matches at least one trait.",
		},
	}
	Zt_AdditionalTraits = typeinfo.Flow{
		Name: "additional_traits",
		Lede: "additional_traits",
		Terms: []typeinfo.Term{{
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Type:     &Zt_CommaAnd,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": "Matches a trait following another trait.",
		},
	}
	Zt_Words = typeinfo.Flow{
		Name: "words",
		Lede: "words",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Markup: map[string]any{
			"comment": "Matches one or more predefined words.",
		},
	}
	Zt_Verb = typeinfo.Flow{
		Name: "verb",
		Lede: "verb",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Matches one or more predefined verbs.", "( verbs are nouns of the verb kind )"},
		},
	}
	Zt_MatchingPhrases = typeinfo.Flow{
		Name: "matching_phrases",
		Lede: "matching_phrases",
		Terms: []typeinfo.Term{{
			Name:  "understand",
			Label: "understand",
			Type:  &Zt_Understand,
		}, {
			Name:  "timed_rule",
			Label: "timed_rule",
			Type:  &Zt_TimedRule,
		}, {
			Name:  "kinds_are_kind",
			Label: "kinds_are_kind",
			Type:  &Zt_KindsAreKind,
		}, {
			Name:  "aspects_are_traits",
			Label: "aspects_are_traits",
			Type:  &Zt_AspectsAreTraits,
		}, {
			Name:  "kinds_are_traits",
			Label: "kinds_are_traits",
			Type:  &Zt_KindsAreTraits,
		}, {
			Name:  "kinds_have_properties",
			Label: "kinds_have_properties",
			Type:  &Zt_KindsHaveProperties,
		}, {
			Name:  "kinds_are_either",
			Label: "kinds_are_either",
			Type:  &Zt_KindsAreEither,
		}, {
			Name:  "map_connections",
			Label: "map_connections",
			Type:  &Zt_MapConnections,
		}, {
			Name:  "map_directions",
			Label: "map_directions",
			Type:  &Zt_MapDirections,
		}, {
			Name:  "map_locations",
			Label: "map_locations",
			Type:  &Zt_MapLocations,
		}, {
			Name:  "property_noun_value",
			Label: "property_noun_value",
			Type:  &Zt_PropertyNounValue,
		}, {
			Name:  "noun_property_value",
			Label: "noun_property_value",
			Type:  &Zt_NounPropertyValue,
		}, {
			Name:  "verb_names_are_names",
			Label: "verb_names_are_names",
			Type:  &Zt_VerbNamesAreNames,
		}, {
			Name:  "names_verb_names",
			Label: "names_verb_names",
			Type:  &Zt_NamesVerbNames,
		}, {
			Name:  "names_are_like_verbs",
			Label: "names_are_like_verbs",
			Type:  &Zt_NamesAreLikeVerbs,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"This is the union of all possible matching phrases.", "For any given plain text sentence,", "jess tries each of these looking for the first to succeed.", "Different phrases belong to different scheduled phases;", "scheduling is handled manually.", "( tbd: an alternative might be slots and some scheduling metadata;", "this is fine for now )"},
		},
	}
	Zt_KindsAreKind = typeinfo.Flow{
		Name: "kinds_are_kind",
		Lede: "kinds_are_kind",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"can match plain names and existing kinds;", "only allows a leading kind called, and errors on all counted kinds."},
			},
			Type: &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "kinds_are_kind",
			Label: "kinds_are_kind",
			Markup: map[string]any{
				"comment": "the phrases \"a kind of\" or \"kinds of\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform doesnt allow commas or ands here,", "jess reuses the traits list here, so it does allow comma/and."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "name",
			Label: "name",
			Markup: map[string]any{
				"comment": []interface{}{"inform (weirdly) allows multiple kinds on the rhs:", "`A box is a kind of container and things.`", "but not if traits are specified, suggesting a switch there;", "possibly to detect and reject `A box is a kind of closed and openable container.`", "which it wants written as `A box is a kind of closed openable container.`", "this doesnt switch to special traits, and doesnt allow multiple kinds."},
			},
			Type: &Zt_Name,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Names are \"a kind of\"/\"kinds of\" traits kind:any.", "Interesting to note that inform allows \"some kind/s of\", but", "this is more strict.", "Like inform `The animals called kittens are a kind of things.` is legal."},
		},
	}
	Zt_KindsAreTraits = typeinfo.Flow{
		Name: "kinds_are_traits",
		Lede: "kinds_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "usually",
			Label: "usually",
			Type:  &Zt_Words,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Assigns default traits to a kind.", "kinds:objects are \"usually\" traits.", "Inform doesn't require the \"usually\", but i like it as a way to differentiate phrases about kinds vs. phrases about nouns.", "", "Future: allow limiting traits to kinds with other traits.", "For example, in Inform:", " The closed containers are fixed in place.", "makes any containers that are *initially* closed also immovable."},
		},
	}
	Zt_AspectsAreTraits = typeinfo.Flow{
		Name: "aspects_are_traits",
		Lede: "aspects_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "aspect",
			Label: "aspect",
			Type:  &Zt_Kind,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "plain_names",
			Label: "plain_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Defines traits for aspects that can be (re)used by various other kinds.", "ex.", "  The colors are a kind of aspect. The colors are red, blue, and greasy green.", "The commands aspects_are_traits, kinds_are_traits, and names_are_like_verbs all handle similar phrasing."},
		},
	}
	Zt_VerbNamesAreNames = typeinfo.Flow{
		Name: "verb_names_are_names",
		Lede: "verb_names_are_names",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "other_names",
			Label: "other_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Verb names are (other) names.", "ex.", "  In the coffin are some coins, a notebook, and the gripping hand.", "This intentionally doesn't recognize adjectives attached to named names.", "\"In the closed coffin\" generates a name with the name \"closed coffin\"", "not a coffin in an initially closed state."},
		},
	}
	Zt_NamesVerbNames = typeinfo.Flow{
		Name: "names_verb_names",
		Lede: "names_verb_names",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "other_names",
			Label: "other_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Names are verb (other) names.", "ex.", " The thing called the stake is on the supporter called the altar."},
		},
	}
	Zt_NamesAreLikeVerbs = typeinfo.Flow{
		Name: "names_are_like_verbs",
		Lede: "names_are_like_verbs",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "adjectives",
			Label: "adjectives",
			Markup: map[string]any{
				"comment": []interface{}{"adjectives are *not* optional.", "if there are no adjectives present,", "then 'names_verb_names' (might) match instead."},
			},
			Type: &Zt_Adjectives,
		}, {
			Name:     "verb_phrase",
			Label:    "verb_phrase",
			Optional: true,
			Type:     &Zt_VerbPhrase,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Names are adjectives [verb names].", "ex.", "   The bottle is a transparent, open, container.", "   The coffin is a closed container [in the antechamber].", "This is the *only* way of assigning names initial states directly.", "All other phrases require a kind to be involved, here the kind is optional."},
		},
	}
	Zt_VerbPhrase = typeinfo.Flow{
		Name: "verb_phrase",
		Lede: "verb_phrase",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "plain_names",
			Label: "plain_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"A phrase, starting with a verb, that ends a sentence.", "ex.", "  ... in the kitchen.", "  ... carries the football and sousaphone."},
		},
	}
	Zt_Adjectives = typeinfo.Flow{
		Name: "adjectives",
		Lede: "adjectives",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Type:     &Zt_Traits,
		}, {
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"exists to support phrases like:", "`the box is transparent and a container.`"},
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Type:     &Zt_Kind,
		}, {
			Name:     "additional_adjectives",
			Label:    "additional_adjectives",
			Optional: true,
			Type:     &Zt_AdditionalAdjectives,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"One or more phrases consisting of traits and a kind.", "while all parts are marked as optional, matching expects", "there will be at least one trait or one kind", "and that there can only be additional adjective phrases", "if the previous one ended with a kind.", "ex.", "  a container", "  closed and fixed in place", "  a closed container and a fixed in place thing"},
		},
	}
	Zt_AdditionalAdjectives = typeinfo.Flow{
		Name: "additional_adjectives",
		Lede: "additional_adjectives",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Type:  &Zt_CommaAnd,
		}, {
			Name:  "adjectives",
			Label: "adjectives",
			Type:  &Zt_Adjectives,
		}},
		Markup: map[string]any{
			"comment": "An additional set of traits and a kind.",
		},
	}
	Zt_PropertyNounValue = typeinfo.Flow{
		Name: "property_noun_value",
		Lede: "property_noun_value",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "property",
			Label: "property",
			Type:  &Zt_Property,
		}, {
			Name:  "of",
			Label: "of",
			Markup: map[string]any{
				"comment": "the word \"of\"",
			},
			Type: &Zt_Words,
		}, {
			Name:  "named_noun",
			Label: "named_noun",
			Type:  &Zt_NamedNoun,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:     "single_value",
			Label:    "single_value",
			Optional: true,
			Type:     &Zt_SingleValue,
		}, {
			Name:     "quoted_texts",
			Label:    "quoted_texts",
			Optional: true,
			Type:     &Zt_QuotedTexts,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Assigns a default value to a noun.", "ex.", "  The description of the pen is \"mightier than the sword.", "As a special case this also allows a list of quoted text", "indicated with \"are\" ( versus \"is\" )"},
		},
	}
	Zt_NounPropertyValue = typeinfo.Flow{
		Name: "noun_property_value",
		Lede: "noun_property_value",
		Terms: []typeinfo.Term{{
			Name:  "named_noun",
			Label: "named_noun",
			Type:  &Zt_NamedNoun,
		}, {
			Name:  "has",
			Label: "has",
			Type:  &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "property",
			Label: "property",
			Type:  &Zt_Property,
		}, {
			Name:     "of",
			Label:    "of",
			Optional: true,
			Markup: map[string]any{
				"comment": "the word \"of\", sometimes reads better this way",
			},
			Type: &Zt_Words,
		}, {
			Name:  "single_value",
			Label: "single_value",
			Type:  &Zt_SingleValue,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Assigns a default value to a noun.", "ex.", "  The pen has (the) description (of) \"mightier than the sword.\"", "like inform, adjectives ( in phrases with \"is\" ) cannot be combined with property phrases ( \"has/of\" )"},
		},
	}
	Zt_SingleValue = typeinfo.Flow{
		Name: "single_value",
		Lede: "single_value",
		Terms: []typeinfo.Term{{
			Name:     "quoted_text",
			Label:    "quoted_text",
			Optional: true,
			Type:     &Zt_QuotedText,
		}, {
			Name:     "matching_num",
			Label:    "matching_num",
			Optional: true,
			Type:     &Zt_MatchingNum,
		}, {
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Type:     &Zt_Noun,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Type:     &Zt_Kind,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"This matches only one of its options.", "( The options could be represented as a slot; this feels easier for now )."},
		},
	}
	Zt_QuotedText = typeinfo.Flow{
		Name: "quoted_text",
		Lede: "quoted_text",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Text that begins and ends with double quotes.", "The quotes themselves are not part of the matched text."},
		},
	}
	Zt_MatchingNum = typeinfo.Flow{
		Name: "matching_num",
		Lede: "matching_num",
		Terms: []typeinfo.Term{{
			Name:  "value",
			Label: "value",
			Type:  &prim.Zt_Num,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Reads a number specified in words or as digits.", "Stores the result as the parsed number."},
		},
	}
	Zt_KindsHaveProperties = typeinfo.Flow{
		Name: "kinds_have_properties",
		Lede: "kinds_have_properties",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "have",
			Label: "have",
			Type:  &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:     "list_of",
			Label:    "list_of",
			Optional: true,
			Type:     &prim.Zt_Text,
		}, {
			Name:  "property_type",
			Label: "property_type",
			Type:  &Zt_PropertyType,
		}, {
			Name:     "called_name",
			Label:    "called_name",
			Optional: true,
			Type:     &Zt_CalledName,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Kinds \"have\" a (\"list of\") type (\"called\" name).", "ex.", "  Things have some text called a description."},
		},
	}
	Zt_CalledName = typeinfo.Flow{
		Name: "called_name",
		Lede: "called_name",
		Terms: []typeinfo.Term{{
			Name:  "called",
			Label: "called",
			Type:  &Zt_Called,
		}, {
			Name:  "name",
			Label: "name",
			Type:  &Zt_Name,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Used for kinds_have_properties.", "like kind_called, specifying \"called the/our ...\" gives the noun an indefinite article."},
		},
	}
	Zt_PropertyType = typeinfo.Flow{
		Name: "property_type",
		Lede: "property_type",
		Terms: []typeinfo.Term{{
			Name:     "primitive",
			Label:    "primitive",
			Optional: true,
			Type:     &prim.Zt_Text,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": "kinds|aspects|records",
			},
			Type: &Zt_Kind,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Matches text, number, kind ( kind|aspect|record )", "as part of 'kinds_have_properties'.", "Exactly one member can match."},
		},
	}
	Zt_KindsAreEither = typeinfo.Flow{
		Name: "kinds_are_either",
		Lede: "kinds_are_either",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "can_be",
			Label: "can_be",
			Type:  &Zt_Words,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_NewTrait,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Kinds (\"can be\"|\"are either\") new_trait [or new_trait...].", "ex.", " A thing can be open or closed."},
		},
	}
	Zt_NewTrait = typeinfo.Flow{
		Name: "new_trait",
		Lede: "new_trait",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}, {
			Name:     "new_trait",
			Label:    "new_trait",
			Optional: true,
			Type:     &Zt_NewTrait,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"One or more new trait names,", "separated by the word \"or\"."},
		},
	}
	Zt_QuotedTexts = typeinfo.Flow{
		Name: "quoted_texts",
		Lede: "quoted_texts",
		Terms: []typeinfo.Term{{
			Name:  "quoted_text",
			Label: "quoted_text",
			Type:  &Zt_QuotedText,
		}, {
			Name:     "additional_text",
			Label:    "additional_text",
			Optional: true,
			Type:     &Zt_AdditionalText,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"One or more strings of quoted text", "separated by the words \"and\", \"comma\", or \"or\"."},
		},
	}
	Zt_AdditionalText = typeinfo.Flow{
		Name: "additional_text",
		Lede: "additional_text",
		Terms: []typeinfo.Term{{
			Name:  "comma_and_or",
			Label: "comma_and_or",
			Type:  &Zt_CommaAndOr,
		}, {
			Name:  "quoted_texts",
			Label: "quoted_texts",
			Type:  &Zt_QuotedTexts,
		}},
		Markup: map[string]any{
			"comment": "Matches a text following another some previous text.",
		},
	}
	Zt_RulePrefix = typeinfo.Flow{
		Name: "rule_prefix",
		Lede: "rule_prefix",
		Terms: []typeinfo.Term{{
			Name:    "prefix_value",
			Label:   "prefix_value",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Matches rule prefixes:", "before, instead of, when, after, report"},
		},
	}
	Zt_RuleSuffix = typeinfo.Flow{
		Name: "rule_suffix",
		Lede: "rule_suffix",
		Terms: []typeinfo.Term{{
			Name:    "suffix_value",
			Label:   "suffix_value",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Controls what to do after matching a rule.", "Matches \"then continue\", \"then stop\", \"then skip phase\",", "and \"begins\", \"ends\" ( for domain rules )", "with an optional leading comma."},
		},
	}
	Zt_RuleName = typeinfo.Flow{
		Name: "rule_name",
		Lede: "rule_name",
		Terms: []typeinfo.Term{{
			Name:     "prefix",
			Label:    "prefix",
			Optional: true,
			Markup: map[string]any{
				"comment": "\"this is the\"",
			},
			Type: &prim.Zt_Bool,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &prim.Zt_Text,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}, {
			Name:     "suffix",
			Label:    "suffix",
			Optional: true,
			Markup: map[string]any{
				"comment": "the word \"rule\"",
			},
			Type: &prim.Zt_Bool,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Specific names can follow rule declarations.", "ex.", " ( this is the witness light rule )"},
		},
	}
	Zt_RuleTarget = typeinfo.Flow{
		Name: "rule_target",
		Lede: "rule_target",
		Terms: []typeinfo.Term{{
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Type:     &Zt_Kind,
		}, {
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Type:     &Zt_Noun,
		}},
	}
	Zt_SubAssignment = typeinfo.Flow{
		Name: "sub_assignment",
		Lede: "sub_assignment",
		Terms: []typeinfo.Term{{
			Name:  "assignment",
			Label: "assignment",
			Type:  &rtti.Zt_Assignment,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Phrases can break out of plain text and into structured tell docs.", "The documents start with a colon (:) followed by a newline", "the next line is assumed to be an indented tell mapping or sequence", "which ends with the first unindented line.", "Sequences are treated as execute blocks;", "Mappings are assumed to be a valid eval", "( ie. an implementation of one of the rtti interfaces. )"},
		},
	}
	Zt_TimedRule = typeinfo.Flow{
		Name: "timed_rule",
		Lede: "timed_rule",
		Terms: []typeinfo.Term{{
			Name:  "rule_prefix",
			Label: "rule_prefix",
			Type:  &Zt_RulePrefix,
		}, {
			Name:     "someone",
			Label:    "someone",
			Optional: true,
			Type:     &prim.Zt_Bool,
		}, {
			Name:  "pattern",
			Label: "pattern",
			Markup: map[string]any{
				"comment": []interface{}{"the pattern this rule targets.", "the pattern must exist for this phrase to generate successfully.", "ex. \"instead of traveling\""},
			},
			Type: &Zt_Kind,
		}, {
			Name:     "rule_target",
			Label:    "rule_target",
			Optional: true,
			Type:     &Zt_RuleTarget,
		}, {
			Name:     "rule_suffix",
			Label:    "rule_suffix",
			Optional: true,
			Type:     &Zt_RuleSuffix,
		}, {
			Name:     "rule_name",
			Label:    "rule_name",
			Optional: true,
			Markup: map[string]any{
				"comment": "parenthetical text",
			},
			Type: &Zt_RuleName,
		}, {
			Name:  "sub_assignment",
			Label: "sub_assignment",
			Type:  &Zt_SubAssignment,
		}},
		Markup: map[string]any{
			"comment": "Matches pattern rule definitions.",
		},
	}
	Zt_Understand = typeinfo.Flow{
		Name: "understand",
		Lede: "understand",
		Terms: []typeinfo.Term{{
			Name:  "understand",
			Label: "understand",
			Type:  &Zt_Words,
		}, {
			Name:  "quoted_texts",
			Label: "quoted_texts",
			Markup: map[string]any{
				"comment": "all of jess's understand start with quoted text",
			},
			Type: &Zt_QuotedTexts,
		}, {
			Name:  "as",
			Label: "as",
			Type:  &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform is smart enough to *not* allow articles before actions.", "i am lazy."},
			},
			Type: &Zt_Article,
		}, {
			Name:     "plural_of",
			Label:    "plural_of",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"ex. Understand \"birds\" and \"ruddy ducks\" as the plural of duck.", "fix? in jess this (also) influences the story interpretation."},
			},
			Type: &prim.Zt_Text,
		}, {
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"this matches one or more nouns or kinds:", "generation susses out what to do with those nouns or kinds.", "* aliases for nouns: Understand \"floor\" or \"sawdust\" as the message.", "* aliases for kinds: Understand \"cupboard\" or \"cupboards\" or \"cabinets\" as a cabinet.", "* grammar for actions: Understand \"reach underneath/under/beneath/-- [something]\" as looking under.", "jess doesn't permit aliases for kinds, those generate errors."},
			},
			Type: &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "Various phrases, all starting with the word \"Understand\".",
		},
	}
	Zt_MapLocations = typeinfo.Flow{
		Name: "map_locations",
		Lede: "map_locations",
		Terms: []typeinfo.Term{{
			Name:  "linking",
			Label: "linking",
			Type:  &Zt_Linking,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "direction_of_linking",
			Label: "direction_of_linking",
			Type:  &Zt_DirectionOfLinking,
		}, {
			Name:     "additional_directions",
			Label:    "additional_directions",
			Optional: true,
			Type:     &Zt_AdditionalDirections,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"A mapping declaration starting with a room or door.", "ex.", "  A dead end called the Airport is west of the Road and north of the Farm."},
		},
	}
	Zt_AdditionalDirections = typeinfo.Flow{
		Name: "additional_directions",
		Lede: "additional_directions",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Type:  &Zt_CommaAnd,
		}, {
			Name:  "direction_of_linking",
			Label: "direction_of_linking",
			Type:  &Zt_DirectionOfLinking,
		}, {
			Name:     "additional_directions",
			Label:    "additional_directions",
			Optional: true,
			Type:     &Zt_AdditionalDirections,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Matches additional directions.", "only used by map_locations."},
		},
	}
	Zt_MapDirections = typeinfo.Flow{
		Name: "map_directions",
		Lede: "map_directions",
		Terms: []typeinfo.Term{{
			Name:  "direction_of_linking",
			Label: "direction_of_linking",
			Type:  &Zt_DirectionOfLinking,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:     "linking",
			Label:    "linking",
			Optional: true,
			Markup: map[string]any{
				"comment": "ex. `[Inside from the Meadow] is... the woodcutter's hut.`",
			},
			Type: &Zt_Linking,
		}, {
			Name:     "redirect",
			Label:    "redirect",
			Optional: true,
			Markup: map[string]any{
				"comment": "ex. `[West of the Garden] is ... south of the Meadow.`",
			},
			Type: &Zt_DirectionOfLinking,
		}},
		Markup: map[string]any{
			"comment": "A mapping declaration starting with a direction.",
		},
	}
	Zt_MapConnections = typeinfo.Flow{
		Name: "map_connections",
		Lede: "map_connections",
		Terms: []typeinfo.Term{{
			Name:  "through",
			Label: "through",
			Type:  &prim.Zt_Bool,
		}, {
			Name:  "doors",
			Label: "doors",
			Type:  &Zt_Linking,
		}, {
			Name:     "additional_links",
			Label:    "additional_links",
			Optional: true,
			Type:     &Zt_AdditionalLinks,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "room",
			Label: "room",
			Type:  &Zt_Linking,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"A mapping declaration to set the destination of doors.", "ex.", " Through the long slide is the cellar.", " Through the blue door and the red door is the kitchen.", "The destination of a door is always treated as a room or nowhere.", "( Inform doesn't allow nowhere, but it seems like a good idea. )"},
		},
	}
	Zt_DirectionOfLinking = typeinfo.Flow{
		Name: "direction_of_linking",
		Lede: "direction_of_linking",
		Terms: []typeinfo.Term{{
			Name:  "direction",
			Label: "direction",
			Type:  &Zt_Direction,
		}, {
			Name:  "from_of",
			Label: "from_of",
			Type:  &Zt_Words,
		}, {
			Name:  "linking",
			Label: "linking",
			Markup: map[string]any{
				"comment": "a room or door.",
			},
			Type: &Zt_Linking,
		}},
		Markup: map[string]any{
			"comment": "Partial phrase for mapping declarations.",
		},
	}
	Zt_Direction = typeinfo.Flow{
		Name: "direction",
		Lede: "direction",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "Matches some existing compass direction.",
		},
	}
	Zt_Linking = typeinfo.Flow{
		Name: "linking",
		Lede: "linking",
		Terms: []typeinfo.Term{{
			Name:     "nowhere",
			Label:    "nowhere",
			Optional: true,
			Type:     &prim.Zt_Bool,
		}, {
			Name:     "kind_called",
			Label:    "kind_called",
			Optional: true,
			Type:     &Zt_KindCalled,
		}, {
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Type:     &Zt_Noun,
		}, {
			Name:     "name",
			Label:    "name",
			Optional: true,
			Type:     &Zt_Name,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Generates a room, a door, or nowhere.", "( This i similar to, but distinct from other noun matching phrases. )"},
		},
	}
	Zt_AdditionalLinks = typeinfo.Flow{
		Name: "additional_links",
		Lede: "additional_links",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Type:  &Zt_CommaAnd,
		}, {
			Name:  "linking",
			Label: "linking",
			Type:  &Zt_Linking,
		}, {
			Name:     "additional_links",
			Label:    "additional_links",
			Optional: true,
			Type:     &Zt_AdditionalLinks,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Partial phrase used for map connections.", "This allows multiple doors, etc. on the lhs."},
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "jess",
	Comment: []string{
		"Game world modeling using English-like sentences.",
		"For example:",
		"",
		" The kitchen is a room. The closed container called the cabinet is in the kitchen.",
		" The cabinet contains a mug. The mug is transparent.",
		"",
		"The types of sentences jess can process are based on Inform7. The way in which jess processes sentences, however, are based on parse trees defined by Tapestry commands.",
		"",
		"The root of all parse trees is the \"MatchingPhrases:\" command.",
		"Each successfully matched plain English sentence results a single [MatchingPhrases] instance with exactly one valid member.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Matched,
	&Zt_NounBuilder,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Article,
	&Zt_CommaAnd,
	&Zt_CommaAndOr,
	&Zt_Are,
	&Zt_Called,
	&Zt_Name,
	&Zt_Noun,
	&Zt_NamedNoun,
	&Zt_KindCalled,
	&Zt_Names,
	&Zt_AdditionalNames,
	&Zt_CountedKind,
	&Zt_Kind,
	&Zt_Kinds,
	&Zt_AdditionalKinds,
	&Zt_Property,
	&Zt_Trait,
	&Zt_Traits,
	&Zt_AdditionalTraits,
	&Zt_Words,
	&Zt_Verb,
	&Zt_MatchingPhrases,
	&Zt_KindsAreKind,
	&Zt_KindsAreTraits,
	&Zt_AspectsAreTraits,
	&Zt_VerbNamesAreNames,
	&Zt_NamesVerbNames,
	&Zt_NamesAreLikeVerbs,
	&Zt_VerbPhrase,
	&Zt_Adjectives,
	&Zt_AdditionalAdjectives,
	&Zt_PropertyNounValue,
	&Zt_NounPropertyValue,
	&Zt_SingleValue,
	&Zt_QuotedText,
	&Zt_MatchingNum,
	&Zt_KindsHaveProperties,
	&Zt_CalledName,
	&Zt_PropertyType,
	&Zt_KindsAreEither,
	&Zt_NewTrait,
	&Zt_QuotedTexts,
	&Zt_AdditionalText,
	&Zt_RulePrefix,
	&Zt_RuleSuffix,
	&Zt_RuleName,
	&Zt_RuleTarget,
	&Zt_SubAssignment,
	&Zt_TimedRule,
	&Zt_Understand,
	&Zt_MapLocations,
	&Zt_AdditionalDirections,
	&Zt_MapDirections,
	&Zt_MapConnections,
	&Zt_DirectionOfLinking,
	&Zt_Direction,
	&Zt_Linking,
	&Zt_AdditionalLinks,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	12489206644669467772: (*AdditionalAdjectives)(nil), /* AdditionalAdjectives commaAnd:adjectives: */
	13976572281991597662: (*AdditionalDirections)(nil), /* AdditionalDirections commaAnd:directionOfLinking: */
	3987359216723603269:  (*AdditionalDirections)(nil), /* AdditionalDirections commaAnd:directionOfLinking:additionalDirections: */
	12174030489678544826: (*AdditionalKinds)(nil),      /* AdditionalKinds commaAnd:kinds: */
	3282054325918314061:  (*AdditionalLinks)(nil),      /* AdditionalLinks commaAnd:linking: */
	5988669985902941853:  (*AdditionalLinks)(nil),      /* AdditionalLinks commaAnd:linking:additionalLinks: */
	16975120945491427296: (*AdditionalNames)(nil),      /* AdditionalNames commaAnd:names: */
	12949801356443185096: (*AdditionalText)(nil),       /* AdditionalText commaAndOr:quotedTexts: */
	508023169458945308:   (*AdditionalTraits)(nil),     /* AdditionalTraits commaAnd:traits: */
	1887918947148326916:  (*AdditionalTraits)(nil),     /* AdditionalTraits traits: */
	10618851046870477413: (*Adjectives)(nil),           /* Adjectives */
	12215120732458766748: (*Adjectives)(nil),           /* Adjectives additionalAdjectives: */
	724420376605497959:   (*Adjectives)(nil),           /* Adjectives commaAnd: */
	17477522713582243508: (*Adjectives)(nil),           /* Adjectives commaAnd:additionalAdjectives: */
	1568830118683768373:  (*Adjectives)(nil),           /* Adjectives commaAnd:kind: */
	7021517372525507842:  (*Adjectives)(nil),           /* Adjectives commaAnd:kind:additionalAdjectives: */
	7663368451290651677:  (*Adjectives)(nil),           /* Adjectives kind: */
	16725271580009929658: (*Adjectives)(nil),           /* Adjectives kind:additionalAdjectives: */
	13544991759812118088: (*Adjectives)(nil),           /* Adjectives traits: */
	13327572087367323885: (*Adjectives)(nil),           /* Adjectives traits:additionalAdjectives: */
	2209109858568160146:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd: */
	11777076077986952519: (*Adjectives)(nil),           /* Adjectives traits:commaAnd:additionalAdjectives: */
	5997117370605758938:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd:kind: */
	5841657992957591039:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd:kind:additionalAdjectives: */
	11552995266309396480: (*Adjectives)(nil),           /* Adjectives traits:kind: */
	8078288476520567765:  (*Adjectives)(nil),           /* Adjectives traits:kind:additionalAdjectives: */
	14557216947727331217: (*Are)(nil),                  /* Are matched: */
	10435354424123783362: (*Article)(nil),              /* Article text: */
	3333774278464825615:  (*AspectsAreTraits)(nil),     /* AspectsAreTraits aspect:are:plainNames: */
	1429396826658837670:  (*Called)(nil),               /* Called matched: */
	1453048882349619361:  (*CalledName)(nil),           /* CalledName called:name: */
	5180090635119408685:  (*CommaAnd)(nil),             /* CommaAnd matched: */
	4143979682086652670:  (*CommaAndOr)(nil),           /* CommaAndOr matched: */
	11748118905044300293: (*Direction)(nil),            /* Direction text: */
	15872175738337217373: (*DirectionOfLinking)(nil),   /* DirectionOfLinking direction:fromOf:linking: */
	381833413316053162:   (*KindCalled)(nil),           /* KindCalled kind:called:namedNoun: */
	15647995089065713351: (*KindCalled)(nil),           /* KindCalled traits:kind:called:namedNoun: */
	16939996019861136326: (*Kinds)(nil),                /* Kinds article:matched: */
	16946855517465005572: (*Kinds)(nil),                /* Kinds article:matched:additionalKinds: */
	17808071339216334934: (*Kinds)(nil),                /* Kinds matched: */
	17872094200105304436: (*Kinds)(nil),                /* Kinds matched:additionalKinds: */
	4933212495013814755:  (*Kinds)(nil),                /* Kinds traits:article:matched: */
	1182820540821259821:  (*Kinds)(nil),                /* Kinds traits:article:matched:additionalKinds: */
	831875526186841727:   (*Kinds)(nil),                /* Kinds traits:matched: */
	3736619607479472409:  (*Kinds)(nil),                /* Kinds traits:matched:additionalKinds: */
	2480868085776671009:  (*KindsAreEither)(nil),       /* KindsAreEither kind:canBe:traits: */
	7915827911946681158:  (*KindsAreKind)(nil),         /* KindsAreKind names:are:kindsAreKind:name: */
	15219253650407427455: (*KindsAreKind)(nil),         /* KindsAreKind names:are:kindsAreKind:traits:name: */
	8826794343109131276:  (*KindsAreTraits)(nil),       /* KindsAreTraits kinds:are:usually:traits: */
	17116270036433389047: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:listOf:propertyType: */
	17156006172306843757: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:listOf:propertyType:calledName: */
	8108884175448666030:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:propertyType: */
	5228896930769074198:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:propertyType:calledName: */
	2093759548632112131:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:listOf:propertyType: */
	11010766076935860857: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:listOf:propertyType:calledName: */
	13822756587399879234: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:propertyType: */
	8006675921873519578:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:propertyType:calledName: */
	1268488188857917463:  (*Linking)(nil),              /* Linking */
	5424212330747857864:  (*Linking)(nil),              /* Linking kindCalled: */
	6446505275065105379:  (*Linking)(nil),              /* Linking kindCalled:name: */
	2710323341843582806:  (*Linking)(nil),              /* Linking kindCalled:noun: */
	3374566505223385661:  (*Linking)(nil),              /* Linking kindCalled:noun:name: */
	6388981702446933508:  (*Linking)(nil),              /* Linking name: */
	699798969473871641:   (*Linking)(nil),              /* Linking noun: */
	7057336974261527000:  (*Linking)(nil),              /* Linking noun:name: */
	12985609098990274833: (*Linking)(nil),              /* Linking nowhere: */
	14771750539341337516: (*Linking)(nil),              /* Linking nowhere:kindCalled: */
	5903702872919052743:  (*Linking)(nil),              /* Linking nowhere:kindCalled:name: */
	5217319623359730706:  (*Linking)(nil),              /* Linking nowhere:kindCalled:noun: */
	3495762696381881337:  (*Linking)(nil),              /* Linking nowhere:kindCalled:noun:name: */
	5842644028483118736:  (*Linking)(nil),              /* Linking nowhere:name: */
	6234445843544605613:  (*Linking)(nil),              /* Linking nowhere:noun: */
	215166621636789820:   (*Linking)(nil),              /* Linking nowhere:noun:name: */
	14338407882822574093: (*MapConnections)(nil),       /* MapConnections through:doors:additionalLinks:are:room: */
	13548965473900735969: (*MapConnections)(nil),       /* MapConnections through:doors:are:room: */
	8340425706814700105:  (*MapDirections)(nil),        /* MapDirections directionOfLinking:are: */
	11792054126316928315: (*MapDirections)(nil),        /* MapDirections directionOfLinking:are:linking: */
	17410395297541184115: (*MapDirections)(nil),        /* MapDirections directionOfLinking:are:linking:redirect: */
	7836789797345891325:  (*MapDirections)(nil),        /* MapDirections directionOfLinking:are:redirect: */
	10172864188299309151: (*MapLocations)(nil),         /* MapLocations linking:are:directionOfLinking: */
	4228974132366036894:  (*MapLocations)(nil),         /* MapLocations linking:are:directionOfLinking:additionalDirections: */
	11956449617596421399: (*MatchingNum)(nil),          /* MatchingNum value: */
	5298623852324545062:  (*MatchingPhrases)(nil),      /* MatchingPhrases understand:timedRule:kindsAreKind:aspectsAreTraits:kindsAreTraits:kindsHaveProperties:kindsAreEither:mapConnections:mapDirections:mapLocations:propertyNounValue:nounPropertyValue:verbNamesAreNames:namesVerbNames:namesAreLikeVerbs: */
	9752692754416089114:  (*NamesAreLikeVerbs)(nil),    /* NamesAreLikeVerbs names:are:adjectives: */
	12792661932982325564: (*NamesAreLikeVerbs)(nil),    /* NamesAreLikeVerbs names:are:adjectives:verbPhrase: */
	2930727231635963135:  (*NamesVerbNames)(nil),       /* NamesVerbNames names:are:verb:otherNames: */
	8736862563783456239:  (*NewTrait)(nil),             /* NewTrait matched: */
	8812100125409583293:  (*NewTrait)(nil),             /* NewTrait matched:newTrait: */
	2974378055008641127:  (*NounPropertyValue)(nil),    /* NounPropertyValue namedNoun:has:article:property:of:singleValue: */
	15033098472290183804: (*NounPropertyValue)(nil),    /* NounPropertyValue namedNoun:has:article:property:singleValue: */
	12848318806630146367: (*NounPropertyValue)(nil),    /* NounPropertyValue namedNoun:has:property:of:singleValue: */
	10878709482269586052: (*NounPropertyValue)(nil),    /* NounPropertyValue namedNoun:has:property:singleValue: */
	11106580022094386190: (*Property)(nil),             /* Property article:matched: */
	7038723543321541230:  (*Property)(nil),             /* Property matched: */
	12495940289451013068: (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:namedNoun:are: */
	3073222598673922702:  (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:namedNoun:are:quotedTexts: */
	3232071257951321417:  (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:namedNoun:are:singleValue: */
	12779492266059217511: (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:namedNoun:are:singleValue:quotedTexts: */
	9991119609101366868:  (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:namedNoun:are: */
	13706825447213238054: (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:namedNoun:are:quotedTexts: */
	9176481845249379681:  (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:namedNoun:are:singleValue: */
	15509934208360069807: (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:namedNoun:are:singleValue:quotedTexts: */
	3271806062429822368:  (*PropertyType)(nil),         /* PropertyType */
	11567946081716077320: (*PropertyType)(nil),         /* PropertyType kind: */
	8224056348026199873:  (*PropertyType)(nil),         /* PropertyType primitive: */
	8660980422311242175:  (*PropertyType)(nil),         /* PropertyType primitive:kind: */
	6626169867101049892:  (*QuotedText)(nil),           /* QuotedText matched: */
	15490383194906526516: (*QuotedTexts)(nil),          /* QuotedTexts quotedText: */
	18124669431880345752: (*QuotedTexts)(nil),          /* QuotedTexts quotedText:additionalText: */
	13648613004771847774: (*RuleName)(nil),             /* RuleName article:matched: */
	9590534200503230547:  (*RuleName)(nil),             /* RuleName article:matched:suffix: */
	10604149086097886046: (*RuleName)(nil),             /* RuleName matched: */
	1396372580611190611:  (*RuleName)(nil),             /* RuleName matched:suffix: */
	10185222741034633300: (*RuleName)(nil),             /* RuleName prefix:article:matched: */
	3408594760617413485:  (*RuleName)(nil),             /* RuleName prefix:article:matched:suffix: */
	8153362324797089296:  (*RuleName)(nil),             /* RuleName prefix:matched: */
	6292556720924657065:  (*RuleName)(nil),             /* RuleName prefix:matched:suffix: */
	6834190963007140391:  (*RulePrefix)(nil),           /* RulePrefix */
	9987385698008157446:  (*RuleSuffix)(nil),           /* RuleSuffix */
	3168366490539674518:  (*RuleTarget)(nil),           /* RuleTarget */
	1634876132861208202:  (*RuleTarget)(nil),           /* RuleTarget kind: */
	14594080518908639404: (*RuleTarget)(nil),           /* RuleTarget kind:noun: */
	16511386036724990548: (*RuleTarget)(nil),           /* RuleTarget noun: */
	8620010389824513622:  (*SingleValue)(nil),          /* SingleValue */
	15504423809522254666: (*SingleValue)(nil),          /* SingleValue kind: */
	13476648886480809019: (*SingleValue)(nil),          /* SingleValue matchingNum: */
	17245554944686574961: (*SingleValue)(nil),          /* SingleValue matchingNum:kind: */
	10898654930796235819: (*SingleValue)(nil),          /* SingleValue matchingNum:noun: */
	15096293982933464929: (*SingleValue)(nil),          /* SingleValue matchingNum:noun:kind: */
	11550266937804910612: (*SingleValue)(nil),          /* SingleValue noun: */
	15983631673684921876: (*SingleValue)(nil),          /* SingleValue noun:kind: */
	3958109237643295925:  (*SingleValue)(nil),          /* SingleValue quotedText: */
	5530597249301129963:  (*SingleValue)(nil),          /* SingleValue quotedText:kind: */
	7535017425513492456:  (*SingleValue)(nil),          /* SingleValue quotedText:matchingNum: */
	9722056324474338464:  (*SingleValue)(nil),          /* SingleValue quotedText:matchingNum:kind: */
	7599452507404660086:  (*SingleValue)(nil),          /* SingleValue quotedText:matchingNum:noun: */
	17308391889632685670: (*SingleValue)(nil),          /* SingleValue quotedText:matchingNum:noun:kind: */
	7763015042528813017:  (*SingleValue)(nil),          /* SingleValue quotedText:noun: */
	1174375068044253639:  (*SingleValue)(nil),          /* SingleValue quotedText:noun:kind: */
	3161285017754785721:  (*SubAssignment)(nil),        /* SubAssignment assignment: */
	8641297100372239080:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleName:subAssignment: */
	1656499122350834261:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleSuffix:ruleName:subAssignment: */
	11245891509928755726: (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleSuffix:subAssignment: */
	5942283442270160717:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleTarget:ruleName:subAssignment: */
	1341518374945402682:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleTarget:ruleSuffix:ruleName:subAssignment: */
	11971369972990827443: (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleTarget:ruleSuffix:subAssignment: */
	15914112945604367254: (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleTarget:subAssignment: */
	8025626927280177953:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:subAssignment: */
	11886989456270920378: (*TimedRule)(nil),            /* TimedRule rulePrefix:someone:pattern:ruleName:subAssignment: */
	11973597951319921255: (*TimedRule)(nil),            /* TimedRule rulePrefix:someone:pattern:ruleSuffix:ruleName:subAssignment: */
	18120234146621178072: (*TimedRule)(nil),            /* TimedRule rulePrefix:someone:pattern:ruleSuffix:subAssignment: */
	7932554349672161467:  (*TimedRule)(nil),            /* TimedRule rulePrefix:someone:pattern:ruleTarget:ruleName:subAssignment: */
	4030485101470664976:  (*TimedRule)(nil),            /* TimedRule rulePrefix:someone:pattern:ruleTarget:ruleSuffix:ruleName:subAssignment: */
	8840422668263390841:  (*TimedRule)(nil),            /* TimedRule rulePrefix:someone:pattern:ruleTarget:ruleSuffix:subAssignment: */
	15591696920291023604: (*TimedRule)(nil),            /* TimedRule rulePrefix:someone:pattern:ruleTarget:subAssignment: */
	13116956132782342707: (*TimedRule)(nil),            /* TimedRule rulePrefix:someone:pattern:subAssignment: */
	14664763846497769151: (*Trait)(nil),                /* Trait article:matched: */
	12725361887885713715: (*Trait)(nil),                /* Trait matched: */
	2416383336069566114:  (*Traits)(nil),               /* Traits trait: */
	2878025327467574768:  (*Traits)(nil),               /* Traits trait:additionalTraits: */
	15200598710934343751: (*Understand)(nil),           /* Understand understand:quotedTexts:as:article:names: */
	8602404775723907374:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:article:pluralOf:names: */
	4257336208718925827:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:names: */
	1299769703937557498:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:pluralOf:names: */
	5125756836274165399:  (*Verb)(nil),                 /* Verb text: */
	3016234452937755523:  (*VerbNamesAreNames)(nil),    /* VerbNamesAreNames verb:names:are:otherNames: */
	7322259980003111582:  (*VerbPhrase)(nil),           /* VerbPhrase verb:plainNames: */
	17678340847396548932: (*Words)(nil),                /* Words matched: */
	11996597499153245749: (*CountedKind)(nil),          /* noun_builder=CountedKind article:matchingNum:kind:matched: */
	11024152495623398821: (*CountedKind)(nil),          /* noun_builder=CountedKind matchingNum:kind:matched: */
	643122070839149560:   (*Kind)(nil),                 /* noun_builder=Kind article:matched: */
	12803964412357300908: (*Kind)(nil),                 /* noun_builder=Kind matched: */
	16595966641928411799: (*Name)(nil),                 /* noun_builder=Name article:matched: */
	4672836465996832923:  (*Name)(nil),                 /* noun_builder=Name matched: */
	18272900946848200057: (*NamedNoun)(nil),            /* noun_builder=NamedNoun */
	15792878411416494446: (*NamedNoun)(nil),            /* noun_builder=NamedNoun name: */
	4609637404391733803:  (*NamedNoun)(nil),            /* noun_builder=NamedNoun noun: */
	12436910703333794014: (*NamedNoun)(nil),            /* noun_builder=NamedNoun noun:name: */
	2640583889409900672:  (*Names)(nil),                /* noun_builder=Names */
	12738701442995129767: (*Names)(nil),                /* noun_builder=Names additionalNames: */
	18240362602181459374: (*Names)(nil),                /* noun_builder=Names countedKind: */
	12037276021421474977: (*Names)(nil),                /* noun_builder=Names countedKind:additionalNames: */
	11318456940554365262: (*Names)(nil),                /* noun_builder=Names countedKind:kind: */
	2921561536254769409:  (*Names)(nil),                /* noun_builder=Names countedKind:kind:additionalNames: */
	13682022206539604949: (*Names)(nil),                /* noun_builder=Names countedKind:kind:name: */
	11386403162429699442: (*Names)(nil),                /* noun_builder=Names countedKind:kind:name:additionalNames: */
	4820492468237421857:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled: */
	4857057301878550486:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:additionalNames: */
	4610133023990007327:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:kind: */
	306331290473716240:   (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:kind:additionalNames: */
	12828387939941830738: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:kind:name: */
	13812482964698333117: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:kind:name:additionalNames: */
	3933914708907484064:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:name: */
	5386185730384130791:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:name:additionalNames: */
	2738021730814332381:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun: */
	3703234872673498778:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:additionalNames: */
	12823222385333700579: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:kind: */
	10265094182115599260: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:kind:additionalNames: */
	10650274376302874710: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:kind:name: */
	14970606785357505161: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:kind:name:additionalNames: */
	7240077436469524524:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:name: */
	16627837112229598459: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:name:additionalNames: */
	15188605287333602229: (*Names)(nil),                /* noun_builder=Names countedKind:name: */
	10005531180398488466: (*Names)(nil),                /* noun_builder=Names countedKind:name:additionalNames: */
	2732786101127601032:  (*Names)(nil),                /* noun_builder=Names countedKind:noun: */
	11074441579857580655: (*Names)(nil),                /* noun_builder=Names countedKind:noun:additionalNames: */
	5699674351646236608:  (*Names)(nil),                /* noun_builder=Names countedKind:noun:kind: */
	11208875936483827527: (*Names)(nil),                /* noun_builder=Names countedKind:noun:kind:additionalNames: */
	4114723026604174811:  (*Names)(nil),                /* noun_builder=Names countedKind:noun:kind:name: */
	17665316277083130708: (*Names)(nil),                /* noun_builder=Names countedKind:noun:kind:name:additionalNames: */
	7558135697584793123:  (*Names)(nil),                /* noun_builder=Names countedKind:noun:name: */
	4307309335598848092:  (*Names)(nil),                /* noun_builder=Names countedKind:noun:name:additionalNames: */
	8731626769408708840:  (*Names)(nil),                /* noun_builder=Names kind: */
	5229708717675470479:  (*Names)(nil),                /* noun_builder=Names kind:additionalNames: */
	10589513982817099011: (*Names)(nil),                /* noun_builder=Names kind:name: */
	12371250482715634300: (*Names)(nil),                /* noun_builder=Names kind:name:additionalNames: */
	1696243941719473959:  (*Names)(nil),                /* noun_builder=Names kindCalled: */
	16924085558067939192: (*Names)(nil),                /* noun_builder=Names kindCalled:additionalNames: */
	17975453262944337013: (*Names)(nil),                /* noun_builder=Names kindCalled:kind: */
	1690461824825161682:  (*Names)(nil),                /* noun_builder=Names kindCalled:kind:additionalNames: */
	8025575955095143172:  (*Names)(nil),                /* noun_builder=Names kindCalled:kind:name: */
	4411930061699572051:  (*Names)(nil),                /* noun_builder=Names kindCalled:kind:name:additionalNames: */
	8470829746237860794:  (*Names)(nil),                /* noun_builder=Names kindCalled:name: */
	2285294953849975365:  (*Names)(nil),                /* noun_builder=Names kindCalled:name:additionalNames: */
	456838907409351087:   (*Names)(nil),                /* noun_builder=Names kindCalled:noun: */
	3607075457371268800:  (*Names)(nil),                /* noun_builder=Names kindCalled:noun:additionalNames: */
	10428480112727021197: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:kind: */
	14860782265429290474: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:kind:additionalNames: */
	14089547370513396124: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:kind:name: */
	18215615836863081227: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:kind:name:additionalNames: */
	15212080762452775330: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:name: */
	15368829543700440685: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:name:additionalNames: */
	5911903052848076411:  (*Names)(nil),                /* noun_builder=Names name: */
	12319710271794432948: (*Names)(nil),                /* noun_builder=Names name:additionalNames: */
	2828161936031789150:  (*Names)(nil),                /* noun_builder=Names noun: */
	6435800613231659505:  (*Names)(nil),                /* noun_builder=Names noun:additionalNames: */
	1013731956332121214:  (*Names)(nil),                /* noun_builder=Names noun:kind: */
	2837764967510892753:  (*Names)(nil),                /* noun_builder=Names noun:kind:additionalNames: */
	1168764988217479109:  (*Names)(nil),                /* noun_builder=Names noun:kind:name: */
	14830046638313199170: (*Names)(nil),                /* noun_builder=Names noun:kind:name:additionalNames: */
	7779767529101118373:  (*Names)(nil),                /* noun_builder=Names noun:name: */
	8867758540341244642:  (*Names)(nil),                /* noun_builder=Names noun:name:additionalNames: */
	4465529434619879510:  (*Noun)(nil),                 /* noun_builder=Noun article:matched: */
	2598335774687055558:  (*Noun)(nil),                 /* noun_builder=Noun matched: */
}
