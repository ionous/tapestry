// Code generated by Tapestry; edit at your own risk.
package jess

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// matched, a type of slot.
var Zt_Matched = typeinfo.Slot{
	Name: "matched",
	Markup: map[string]any{
		"comment": "Used to store matching text",
	},
}

// holds a single slot.
type Matched_Slot struct{ Value Matched }

// implements typeinfo.Instance for a single slot.
func (*Matched_Slot) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// holds a slice of slots.
type Matched_Slots []Matched

// implements typeinfo.Instance for a series of slots.
func (*Matched_Slots) TypeInfo() typeinfo.T {
	return &Zt_Matched
}

// implements typeinfo.Repeats
func (op *Matched_Slots) Repeats() bool {
	return len(*op) > 0
}

// noun_builder, a type of slot.
var Zt_NounBuilder = typeinfo.Slot{
	Name: "noun_builder",
}

// holds a single slot.
type NounBuilder_Slot struct{ Value NounBuilder }

// implements typeinfo.Instance for a single slot.
func (*NounBuilder_Slot) TypeInfo() typeinfo.T {
	return &Zt_NounBuilder
}

// holds a slice of slots.
type NounBuilder_Slots []NounBuilder

// implements typeinfo.Instance for a series of slots.
func (*NounBuilder_Slots) TypeInfo() typeinfo.T {
	return &Zt_NounBuilder
}

// implements typeinfo.Repeats
func (op *NounBuilder_Slots) Repeats() bool {
	return len(*op) > 0
}

// one of a predefined set of determiners: the, a/n, some, our.
// only matches if the first letter is lowercase, or uppercase at the start of a sentence;
// otherwise, the article gets treated as part of the name.
// the lack of a recognized article makes something proper-named.
// see 'counted_kind' for names with leading numbers: (ex. five or 27)
// using "some"  (ex. "some coins") will set nouns as "plural named"
type Article struct {
	Text   string
	Flags  ArticleFlags
	Markup map[string]any
}

// article, a type of flow.
var Zt_Article typeinfo.Flow

// implements typeinfo.Instance
func (*Article) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Markup
func (op *Article) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type article
type Article_Slice []Article

// implements typeinfo.Instance
func (*Article_Slice) TypeInfo() typeinfo.T {
	return &Zt_Article
}

// implements typeinfo.Repeats
func (op *Article_Slice) Repeats() bool {
	return len(*op) > 0
}

// conjunction junction.
// matches "," or "and" or ", and"
// relies on the fact package match treats commas and ands each as their own words.
type CommaAnd struct {
	Matched string
	Markup  map[string]any
}

// comma_and, a type of flow.
var Zt_CommaAnd typeinfo.Flow

// implements typeinfo.Instance
func (*CommaAnd) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Markup
func (op *CommaAnd) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type comma_and
type CommaAnd_Slice []CommaAnd

// implements typeinfo.Instance
func (*CommaAnd_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAnd
}

// implements typeinfo.Repeats
func (op *CommaAnd_Slice) Repeats() bool {
	return len(*op) > 0
}

// conjunction or junction.
// matches commas, ands, and ors.
// relies on the fact package match treats commas and ands each as their own words.
type CommaAndOr struct {
	Matched string
	Markup  map[string]any
}

// comma_and_or, a type of flow.
var Zt_CommaAndOr typeinfo.Flow

// implements typeinfo.Instance
func (*CommaAndOr) TypeInfo() typeinfo.T {
	return &Zt_CommaAndOr
}

// implements typeinfo.Markup
func (op *CommaAndOr) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type comma_and_or
type CommaAndOr_Slice []CommaAndOr

// implements typeinfo.Instance
func (*CommaAndOr_Slice) TypeInfo() typeinfo.T {
	return &Zt_CommaAndOr
}

// implements typeinfo.Repeats
func (op *CommaAndOr_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches "is" or "are".
type Are struct {
	Matched string
	Markup  map[string]any
}

// are, a type of flow.
var Zt_Are typeinfo.Flow

// implements typeinfo.Instance
func (*Are) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Markup
func (op *Are) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type are
type Are_Slice []Are

// implements typeinfo.Instance
func (*Are_Slice) TypeInfo() typeinfo.T {
	return &Zt_Are
}

// implements typeinfo.Repeats
func (op *Are_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the word "called".
type Called struct {
	Matched string
	Markup  map[string]any
}

// called, a type of flow.
var Zt_Called typeinfo.Flow

// implements typeinfo.Instance
func (*Called) TypeInfo() typeinfo.T {
	return &Zt_Called
}

// implements typeinfo.Markup
func (op *Called) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type called
type Called_Slice []Called

// implements typeinfo.Instance
func (*Called_Slice) TypeInfo() typeinfo.T {
	return &Zt_Called
}

// implements typeinfo.Repeats
func (op *Called_Slice) Repeats() bool {
	return len(*op) > 0
}

// Specifies a name who's meaning depends on context.
// For example, when matching: "Gold Roger's treasure chest is a container. The chest is open."
// the "chest" implies the noun "treasure chest."
// In other cases, the name might be a kind, or trait, or pretty much anything else.
// To optimizing matching the words "is/are/comma/and" are never part of name names.
// future: allow quoted "titles" ( which are then allowed to break those assumptions )
type Name struct {
	Article *Article
	Matched Matched
	Markup  map[string]any
}

// name, a type of flow.
var Zt_Name typeinfo.Flow

// implements typeinfo.Instance
func (*Name) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// implements typeinfo.Markup
func (op *Name) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ NounBuilder = (*Name)(nil)

// holds a slice of type name
type Name_Slice []Name

// implements typeinfo.Instance
func (*Name_Slice) TypeInfo() typeinfo.T {
	return &Zt_Name
}

// implements typeinfo.Repeats
func (op *Name_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches an existing noun
// by checking multiple words for the best match.
type Noun struct {
	Article    *Article
	Matched    string
	ActualNoun ActualNoun
	Markup     map[string]any
}

// noun, a type of flow.
var Zt_Noun typeinfo.Flow

// implements typeinfo.Instance
func (*Noun) TypeInfo() typeinfo.T {
	return &Zt_Noun
}

// implements typeinfo.Markup
func (op *Noun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ NounBuilder = (*Noun)(nil)

// holds a slice of type noun
type Noun_Slice []Noun

// implements typeinfo.Instance
func (*Noun_Slice) TypeInfo() typeinfo.T {
	return &Zt_Noun
}

// implements typeinfo.Repeats
func (op *Noun_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches an existing noun, or if not: then something new.
type NamedNoun struct {
	Noun   *Noun
	Name   *Name
	Markup map[string]any
}

// named_noun, a type of flow.
var Zt_NamedNoun typeinfo.Flow

// implements typeinfo.Instance
func (*NamedNoun) TypeInfo() typeinfo.T {
	return &Zt_NamedNoun
}

// implements typeinfo.Markup
func (op *NamedNoun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ NounBuilder = (*NamedNoun)(nil)

// holds a slice of type named_noun
type NamedNoun_Slice []NamedNoun

// implements typeinfo.Instance
func (*NamedNoun_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamedNoun
}

// implements typeinfo.Repeats
func (op *NamedNoun_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a name and its kind in a single phrase.
// Matches: (traits) kind "called" {the name}.
// For example: `The closed container called the trunk is in the lobby.`
// As per inform, the name includes all text after the word "called"
// until "is", "are", or the end of the sentence;
// and specifying "called the/our ..." gives the noun an indefinite article.
type KindCalled struct {
	Traits    *Traits
	Kind      Kind
	Called    Called
	NamedNoun NamedNoun
	Markup    map[string]any
}

// kind_called, a type of flow.
var Zt_KindCalled typeinfo.Flow

// implements typeinfo.Instance
func (*KindCalled) TypeInfo() typeinfo.T {
	return &Zt_KindCalled
}

// implements typeinfo.Markup
func (op *KindCalled) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kind_called
type KindCalled_Slice []KindCalled

// implements typeinfo.Instance
func (*KindCalled_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindCalled
}

// implements typeinfo.Repeats
func (op *KindCalled_Slice) Repeats() bool {
	return len(*op) > 0
}

// Specifies one or more nouns, in full or in part.
// Only one of the options, plus possibly 'additional_names', will match.
// Not all options are valid in all contexts.
type Names struct {
	CountedKind     *CountedKind
	KindCalled      *KindCalled
	Noun            *Noun
	Kind            *Kind
	Name            *Name
	AdditionalNames *AdditionalNames
	Markup          map[string]any
}

// names, a type of flow.
var Zt_Names typeinfo.Flow

// implements typeinfo.Instance
func (*Names) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Markup
func (op *Names) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ NounBuilder = (*Names)(nil)

// holds a slice of type names
type Names_Slice []Names

// implements typeinfo.Instance
func (*Names_Slice) TypeInfo() typeinfo.T {
	return &Zt_Names
}

// implements typeinfo.Repeats
func (op *Names_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a name following another name.
type AdditionalNames struct {
	CommaAnd CommaAnd
	Names    Names
	Markup   map[string]any
}

// additional_names, a type of flow.
var Zt_AdditionalNames typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalNames) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Markup
func (op *AdditionalNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_names
type AdditionalNames_Slice []AdditionalNames

// implements typeinfo.Instance
func (*AdditionalNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalNames
}

// implements typeinfo.Repeats
func (op *AdditionalNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// provides english specification of a number of objects.
// ( note: yes, `the five the containers` is permitted. )
type CountedKind struct {
	Article        *Article
	MatchingNumber MatchingNumber
	Kind           Kind
	Matched        CountedText
	Markup         map[string]any
}

// counted_kind, a type of flow.
var Zt_CountedKind typeinfo.Flow

// implements typeinfo.Instance
func (*CountedKind) TypeInfo() typeinfo.T {
	return &Zt_CountedKind
}

// implements typeinfo.Markup
func (op *CountedKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ NounBuilder = (*CountedKind)(nil)

// holds a slice of type counted_kind
type CountedKind_Slice []CountedKind

// implements typeinfo.Instance
func (*CountedKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_CountedKind
}

// implements typeinfo.Repeats
func (op *CountedKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an existing kind;
// can generate a single anonymous noun.
type Kind struct {
	Article    *Article
	Matched    string
	ActualKind ActualKind
	Markup     map[string]any
}

// kind, a type of flow.
var Zt_Kind typeinfo.Flow

// implements typeinfo.Instance
func (*Kind) TypeInfo() typeinfo.T {
	return &Zt_Kind
}

// implements typeinfo.Markup
func (op *Kind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ NounBuilder = (*Kind)(nil)

// holds a slice of type kind
type Kind_Slice []Kind

// implements typeinfo.Instance
func (*Kind_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kind
}

// implements typeinfo.Repeats
func (op *Kind_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a set of possible kinds as part of kinds_are_traits
// jess tests for but prohibits leading traits.
type Kinds struct {
	Traits          *Traits
	Article         *Article
	Matched         string
	AdditionalKinds *AdditionalKinds
	Markup          map[string]any
}

// kinds, a type of flow.
var Zt_Kinds typeinfo.Flow

// implements typeinfo.Instance
func (*Kinds) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Markup
func (op *Kinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds
type Kinds_Slice []Kinds

// implements typeinfo.Instance
func (*Kinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_Kinds
}

// implements typeinfo.Repeats
func (op *Kinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a kind following another kind.
type AdditionalKinds struct {
	CommaAnd CommaAnd
	Kinds    Kinds
	Markup   map[string]any
}

// additional_kinds, a type of flow.
var Zt_AdditionalKinds typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalKinds) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Markup
func (op *AdditionalKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_kinds
type AdditionalKinds_Slice []AdditionalKinds

// implements typeinfo.Instance
func (*AdditionalKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalKinds
}

// implements typeinfo.Repeats
func (op *AdditionalKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of a field in a kind.
type Property struct {
	Article *Article
	Matched string
	Markup  map[string]any
}

// property, a type of flow.
var Zt_Property typeinfo.Flow

// implements typeinfo.Instance
func (*Property) TypeInfo() typeinfo.T {
	return &Zt_Property
}

// implements typeinfo.Markup
func (op *Property) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type property
type Property_Slice []Property

// implements typeinfo.Instance
func (*Property_Slice) TypeInfo() typeinfo.T {
	return &Zt_Property
}

// implements typeinfo.Repeats
func (op *Property_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches the name of an (existing) trait.
type Trait struct {
	Article *Article
	Matched string
	Markup  map[string]any
}

// trait, a type of flow.
var Zt_Trait typeinfo.Flow

// implements typeinfo.Instance
func (*Trait) TypeInfo() typeinfo.T {
	return &Zt_Trait
}

// implements typeinfo.Markup
func (op *Trait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type trait
type Trait_Slice []Trait

// implements typeinfo.Instance
func (*Trait_Slice) TypeInfo() typeinfo.T {
	return &Zt_Trait
}

// implements typeinfo.Repeats
func (op *Trait_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches at least one trait.
type Traits struct {
	Trait            Trait
	AdditionalTraits *AdditionalTraits
	Markup           map[string]any
}

// traits, a type of flow.
var Zt_Traits typeinfo.Flow

// implements typeinfo.Instance
func (*Traits) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Markup
func (op *Traits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type traits
type Traits_Slice []Traits

// implements typeinfo.Instance
func (*Traits_Slice) TypeInfo() typeinfo.T {
	return &Zt_Traits
}

// implements typeinfo.Repeats
func (op *Traits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a trait following another trait
type AdditionalTraits struct {
	CommaAnd *CommaAnd
	Traits   Traits
	Markup   map[string]any
}

// additional_traits, a type of flow.
var Zt_AdditionalTraits typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalTraits) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Markup
func (op *AdditionalTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_traits
type AdditionalTraits_Slice []AdditionalTraits

// implements typeinfo.Instance
func (*AdditionalTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalTraits
}

// implements typeinfo.Repeats
func (op *AdditionalTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches one or more predefined words
type Words struct {
	Matched string
	Markup  map[string]any
}

// words, a type of flow.
var Zt_Words typeinfo.Flow

// implements typeinfo.Instance
func (*Words) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Markup
func (op *Words) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type words
type Words_Slice []Words

// implements typeinfo.Instance
func (*Words_Slice) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Repeats
func (op *Words_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches one or more predefined verbs
// ( verbs are nouns of the verb kind )
type Verb struct {
	Text   string
	Markup map[string]any
}

// verb, a type of flow.
var Zt_Verb typeinfo.Flow

// implements typeinfo.Instance
func (*Verb) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// implements typeinfo.Markup
func (op *Verb) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb
type Verb_Slice []Verb

// implements typeinfo.Instance
func (*Verb_Slice) TypeInfo() typeinfo.T {
	return &Zt_Verb
}

// implements typeinfo.Repeats
func (op *Verb_Slice) Repeats() bool {
	return len(*op) > 0
}

// union of all possible matching phrases.
// for any given plain text sentence,
// jess tries each of these looking for the first to succeed.
// different phrases belong to different scheduled phases;
// scheduling is handled manually.
// ( an alternative might be slots and some scheduling metadata;
// | this is fine for now )
type MatchingPhrases struct {
	Understand          Understand
	TimedRule           TimedRule
	KindsOf             KindsOf
	AspectsAreTraits    AspectsAreTraits
	KindsAreTraits      KindsAreTraits
	KindsHaveProperties KindsHaveProperties
	KindsAreEither      KindsAreEither
	MapConnections      MapConnections
	MapDirections       MapDirections
	MapLocations        MapLocations
	PropertyNounValue   PropertyNounValue
	NounPropertyValue   NounPropertyValue
	VerbNamesAreNames   VerbNamesAreNames
	NamesVerbNames      NamesVerbNames
	NamesAreLikeVerbs   NamesAreLikeVerbs
	Markup              map[string]any
}

// matching_phrases, a type of flow.
var Zt_MatchingPhrases typeinfo.Flow

// implements typeinfo.Instance
func (*MatchingPhrases) TypeInfo() typeinfo.T {
	return &Zt_MatchingPhrases
}

// implements typeinfo.Markup
func (op *MatchingPhrases) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type matching_phrases
type MatchingPhrases_Slice []MatchingPhrases

// implements typeinfo.Instance
func (*MatchingPhrases_Slice) TypeInfo() typeinfo.T {
	return &Zt_MatchingPhrases
}

// implements typeinfo.Repeats
func (op *MatchingPhrases_Slice) Repeats() bool {
	return len(*op) > 0
}

// names are "a kind of"/"kinds of" traits kind:any.
// interesting to note that inform allows "some kind/s of"
// this is more strict.
// like inform `The animals called kittens are a kind of things.` is legal.
type KindsOf struct {
	Names   Names
	Are     Are
	KindsOf Words
	Traits  *Traits
	Name    Name
	Markup  map[string]any
}

// kinds_of, a type of flow.
var Zt_KindsOf typeinfo.Flow

// implements typeinfo.Instance
func (*KindsOf) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Markup
func (op *KindsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_of
type KindsOf_Slice []KindsOf

// implements typeinfo.Instance
func (*KindsOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsOf
}

// implements typeinfo.Repeats
func (op *KindsOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// assigns default traits to a kind.
// kinds:objects are "usually" traits
// inform doesn't require the "usually" --
//
//	i like it as a way to differentiate phrases about kinds vs. phrases about nouns.
//
// future: inform allows limiting traits to kinds with other traits:
// for example, `the closed containers are fixed in place.`
// makes any containers that are *initially* closed also immovable.
type KindsAreTraits struct {
	Kinds   Kinds
	Are     Are
	Usually Words
	Traits  Traits
	Markup  map[string]any
}

// kinds_are_traits, a type of flow.
var Zt_KindsAreTraits typeinfo.Flow

// implements typeinfo.Instance
func (*KindsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Markup
func (op *KindsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_are_traits
type KindsAreTraits_Slice []KindsAreTraits

// implements typeinfo.Instance
func (*KindsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreTraits
}

// implements typeinfo.Repeats
func (op *KindsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// defines traits for aspects that can be (re)used by various other kinds.
// ex. `The colors are a kind of aspect. The colors are red, blue, and greasy green.`
// aspects_are_traits, kinds_are_traits, and names_are_like_verbs all handle similar phrasing.
type AspectsAreTraits struct {
	Aspect     Kind
	Are        Are
	PlainNames Names
	Markup     map[string]any
}

// aspects_are_traits, a type of flow.
var Zt_AspectsAreTraits typeinfo.Flow

// implements typeinfo.Instance
func (*AspectsAreTraits) TypeInfo() typeinfo.T {
	return &Zt_AspectsAreTraits
}

// implements typeinfo.Markup
func (op *AspectsAreTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type aspects_are_traits
type AspectsAreTraits_Slice []AspectsAreTraits

// implements typeinfo.Instance
func (*AspectsAreTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_AspectsAreTraits
}

// implements typeinfo.Repeats
func (op *AspectsAreTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

// verb names are (other) names.
// ex. `In the coffin are some coins, a notebook, and the gripping hand.`
// This intentionally doesn't recognize adjectives attached to named names.
// "In the closed coffin" generates a name with the name "closed coffin"
// not a coffin in an initially closed state.
type VerbNamesAreNames struct {
	Verb       Verb
	Names      Names
	Are        Are
	OtherNames Names
	Markup     map[string]any
}

// verb_names_are_names, a type of flow.
var Zt_VerbNamesAreNames typeinfo.Flow

// implements typeinfo.Instance
func (*VerbNamesAreNames) TypeInfo() typeinfo.T {
	return &Zt_VerbNamesAreNames
}

// implements typeinfo.Markup
func (op *VerbNamesAreNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb_names_are_names
type VerbNamesAreNames_Slice []VerbNamesAreNames

// implements typeinfo.Instance
func (*VerbNamesAreNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbNamesAreNames
}

// implements typeinfo.Repeats
func (op *VerbNamesAreNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// names are verb (other) names.
// ex. `The thing called the stake is on the supporter called the altar.`
type NamesVerbNames struct {
	Names      Names
	Are        Are
	Verb       Verb
	OtherNames Names
	Markup     map[string]any
}

// names_verb_names, a type of flow.
var Zt_NamesVerbNames typeinfo.Flow

// implements typeinfo.Instance
func (*NamesVerbNames) TypeInfo() typeinfo.T {
	return &Zt_NamesVerbNames
}

// implements typeinfo.Markup
func (op *NamesVerbNames) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type names_verb_names
type NamesVerbNames_Slice []NamesVerbNames

// implements typeinfo.Instance
func (*NamesVerbNames_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamesVerbNames
}

// implements typeinfo.Repeats
func (op *NamesVerbNames_Slice) Repeats() bool {
	return len(*op) > 0
}

// names are adjectives [verb names].
// ex. `The bottle is a transparent, open, container.`
// `The coffin is a closed container [in the antechamber]`
// This is the *only* way of assigning names initial states directly.
// All other phrases require a kind to be involved, here the kind is optional.
type NamesAreLikeVerbs struct {
	Names      Names
	Are        Are
	Adjectives Adjectives
	VerbPhrase *VerbPhrase
	Markup     map[string]any
}

// names_are_like_verbs, a type of flow.
var Zt_NamesAreLikeVerbs typeinfo.Flow

// implements typeinfo.Instance
func (*NamesAreLikeVerbs) TypeInfo() typeinfo.T {
	return &Zt_NamesAreLikeVerbs
}

// implements typeinfo.Markup
func (op *NamesAreLikeVerbs) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type names_are_like_verbs
type NamesAreLikeVerbs_Slice []NamesAreLikeVerbs

// implements typeinfo.Instance
func (*NamesAreLikeVerbs_Slice) TypeInfo() typeinfo.T {
	return &Zt_NamesAreLikeVerbs
}

// implements typeinfo.Repeats
func (op *NamesAreLikeVerbs_Slice) Repeats() bool {
	return len(*op) > 0
}

// ex. ".... in the kitchen.", or "... carries the football and sousaphone."
type VerbPhrase struct {
	Verb       Verb
	PlainNames Names
	Markup     map[string]any
}

// verb_phrase, a type of flow.
var Zt_VerbPhrase typeinfo.Flow

// implements typeinfo.Instance
func (*VerbPhrase) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// implements typeinfo.Markup
func (op *VerbPhrase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type verb_phrase
type VerbPhrase_Slice []VerbPhrase

// implements typeinfo.Instance
func (*VerbPhrase_Slice) TypeInfo() typeinfo.T {
	return &Zt_VerbPhrase
}

// implements typeinfo.Repeats
func (op *VerbPhrase_Slice) Repeats() bool {
	return len(*op) > 0
}

// one or more phrases consisting of traits and a kind.
// while all parts are marked as optional, matching expects
// there will be at least one trait or one kind
// and that there can only be additional adjective phrases
// if the previous one ended with a kind.
// ex. `a container`
//
//	`closed and fixed in place`,
//	`a closed container and a fixed in place thing`.
type Adjectives struct {
	Traits               *Traits
	CommaAnd             *CommaAnd
	Kind                 *Kind
	AdditionalAdjectives *AdditionalAdjectives
	Markup               map[string]any
}

// adjectives, a type of flow.
var Zt_Adjectives typeinfo.Flow

// implements typeinfo.Instance
func (*Adjectives) TypeInfo() typeinfo.T {
	return &Zt_Adjectives
}

// implements typeinfo.Markup
func (op *Adjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type adjectives
type Adjectives_Slice []Adjectives

// implements typeinfo.Instance
func (*Adjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_Adjectives
}

// implements typeinfo.Repeats
func (op *Adjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

// an additional set of traits and a kind
type AdditionalAdjectives struct {
	CommaAnd   CommaAnd
	Adjectives Adjectives
	Markup     map[string]any
}

// additional_adjectives, a type of flow.
var Zt_AdditionalAdjectives typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalAdjectives) TypeInfo() typeinfo.T {
	return &Zt_AdditionalAdjectives
}

// implements typeinfo.Markup
func (op *AdditionalAdjectives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_adjectives
type AdditionalAdjectives_Slice []AdditionalAdjectives

// implements typeinfo.Instance
func (*AdditionalAdjectives_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalAdjectives
}

// implements typeinfo.Repeats
func (op *AdditionalAdjectives_Slice) Repeats() bool {
	return len(*op) > 0
}

// assigns a default value to a noun.
// ex. `The description of the pen is "mightier than the sword.`
// as a special case allows also allows a list of quoted text
// indicated with "are" ( versus "is" )
type PropertyNounValue struct {
	Article     *Article
	Property    Property
	Of          Words
	NamedNoun   NamedNoun
	Are         Are
	SingleValue *SingleValue
	QuotedTexts *QuotedTexts
	Markup      map[string]any
}

// property_noun_value, a type of flow.
var Zt_PropertyNounValue typeinfo.Flow

// implements typeinfo.Instance
func (*PropertyNounValue) TypeInfo() typeinfo.T {
	return &Zt_PropertyNounValue
}

// implements typeinfo.Markup
func (op *PropertyNounValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type property_noun_value
type PropertyNounValue_Slice []PropertyNounValue

// implements typeinfo.Instance
func (*PropertyNounValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_PropertyNounValue
}

// implements typeinfo.Repeats
func (op *PropertyNounValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// assigns a default value to a noun.
// ex. `The pen has (the) description (of) "mightier than the sword."`
// like inform, adjectives ( in phrases with "is" ) cannot be combined with property phrases ( "has/of" )
type NounPropertyValue struct {
	NamedNoun   NamedNoun
	Has         Words
	Article     *Article
	Property    Property
	Of          *Words
	SingleValue SingleValue
	Markup      map[string]any
}

// noun_property_value, a type of flow.
var Zt_NounPropertyValue typeinfo.Flow

// implements typeinfo.Instance
func (*NounPropertyValue) TypeInfo() typeinfo.T {
	return &Zt_NounPropertyValue
}

// implements typeinfo.Markup
func (op *NounPropertyValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type noun_property_value
type NounPropertyValue_Slice []NounPropertyValue

// implements typeinfo.Instance
func (*NounPropertyValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_NounPropertyValue
}

// implements typeinfo.Repeats
func (op *NounPropertyValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches only one of its options
// ( the options could be represented as a slot; this feels easier for now )
type SingleValue struct {
	QuotedText     *QuotedText
	MatchingNumber *MatchingNumber
	Noun           *Noun
	Kind           *Kind
	Markup         map[string]any
}

// single_value, a type of flow.
var Zt_SingleValue typeinfo.Flow

// implements typeinfo.Instance
func (*SingleValue) TypeInfo() typeinfo.T {
	return &Zt_SingleValue
}

// implements typeinfo.Markup
func (op *SingleValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type single_value
type SingleValue_Slice []SingleValue

// implements typeinfo.Instance
func (*SingleValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_SingleValue
}

// implements typeinfo.Repeats
func (op *SingleValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// text that begins and ends with double quotes.
// the quotes themselves are not part of the matched text.
type QuotedText struct {
	Matched string
	Markup  map[string]any
}

// quoted_text, a type of flow.
var Zt_QuotedText typeinfo.Flow

// implements typeinfo.Instance
func (*QuotedText) TypeInfo() typeinfo.T {
	return &Zt_QuotedText
}

// implements typeinfo.Markup
func (op *QuotedText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type quoted_text
type QuotedText_Slice []QuotedText

// implements typeinfo.Instance
func (*QuotedText_Slice) TypeInfo() typeinfo.T {
	return &Zt_QuotedText
}

// implements typeinfo.Repeats
func (op *QuotedText_Slice) Repeats() bool {
	return len(*op) > 0
}

// reads a number specified in words or as digits.
// stores the result as the parsed number.
type MatchingNumber struct {
	Number float64
	Markup map[string]any
}

// matching_number, a type of flow.
var Zt_MatchingNumber typeinfo.Flow

// implements typeinfo.Instance
func (*MatchingNumber) TypeInfo() typeinfo.T {
	return &Zt_MatchingNumber
}

// implements typeinfo.Markup
func (op *MatchingNumber) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type matching_number
type MatchingNumber_Slice []MatchingNumber

// implements typeinfo.Instance
func (*MatchingNumber_Slice) TypeInfo() typeinfo.T {
	return &Zt_MatchingNumber
}

// implements typeinfo.Repeats
func (op *MatchingNumber_Slice) Repeats() bool {
	return len(*op) > 0
}

// kinds "have" a ("list of") type ("called" name)
// ex. Things have some text called a description.
type KindsHaveProperties struct {
	Kind         Kind
	Have         Words
	Article      *Article
	ListOf       string
	PropertyType PropertyType
	CalledName   *CalledName
	Markup       map[string]any
}

// kinds_have_properties, a type of flow.
var Zt_KindsHaveProperties typeinfo.Flow

// implements typeinfo.Instance
func (*KindsHaveProperties) TypeInfo() typeinfo.T {
	return &Zt_KindsHaveProperties
}

// implements typeinfo.Markup
func (op *KindsHaveProperties) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_have_properties
type KindsHaveProperties_Slice []KindsHaveProperties

// implements typeinfo.Instance
func (*KindsHaveProperties_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsHaveProperties
}

// implements typeinfo.Repeats
func (op *KindsHaveProperties_Slice) Repeats() bool {
	return len(*op) > 0
}

// for kinds_have_properties
// like kind_called, specifying "called the/our ..." gives the noun an indefinite article.
type CalledName struct {
	Called Called
	Name   Name
	Markup map[string]any
}

// called_name, a type of flow.
var Zt_CalledName typeinfo.Flow

// implements typeinfo.Instance
func (*CalledName) TypeInfo() typeinfo.T {
	return &Zt_CalledName
}

// implements typeinfo.Markup
func (op *CalledName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type called_name
type CalledName_Slice []CalledName

// implements typeinfo.Instance
func (*CalledName_Slice) TypeInfo() typeinfo.T {
	return &Zt_CalledName
}

// implements typeinfo.Repeats
func (op *CalledName_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches text, number, kind ( kind|aspect|record )
// as part of 'kinds_have_properties'
// exactly one member can match
type PropertyType struct {
	Primitive string
	Kind      *Kind
	Markup    map[string]any
}

// property_type, a type of flow.
var Zt_PropertyType typeinfo.Flow

// implements typeinfo.Instance
func (*PropertyType) TypeInfo() typeinfo.T {
	return &Zt_PropertyType
}

// implements typeinfo.Markup
func (op *PropertyType) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type property_type
type PropertyType_Slice []PropertyType

// implements typeinfo.Instance
func (*PropertyType_Slice) TypeInfo() typeinfo.T {
	return &Zt_PropertyType
}

// implements typeinfo.Repeats
func (op *PropertyType_Slice) Repeats() bool {
	return len(*op) > 0
}

// kinds ("can be"|"are either") new_trait [or new_trait...]
// ex. A thing can be open or closed.
type KindsAreEither struct {
	Kind   Kind
	CanBe  Words
	Traits NewTrait
	Markup map[string]any
}

// kinds_are_either, a type of flow.
var Zt_KindsAreEither typeinfo.Flow

// implements typeinfo.Instance
func (*KindsAreEither) TypeInfo() typeinfo.T {
	return &Zt_KindsAreEither
}

// implements typeinfo.Markup
func (op *KindsAreEither) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type kinds_are_either
type KindsAreEither_Slice []KindsAreEither

// implements typeinfo.Instance
func (*KindsAreEither_Slice) TypeInfo() typeinfo.T {
	return &Zt_KindsAreEither
}

// implements typeinfo.Repeats
func (op *KindsAreEither_Slice) Repeats() bool {
	return len(*op) > 0
}

// one or more new trait names,
// separated by the word "or"
type NewTrait struct {
	Matched  string
	NewTrait *NewTrait
	Markup   map[string]any
}

// new_trait, a type of flow.
var Zt_NewTrait typeinfo.Flow

// implements typeinfo.Instance
func (*NewTrait) TypeInfo() typeinfo.T {
	return &Zt_NewTrait
}

// implements typeinfo.Markup
func (op *NewTrait) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type new_trait
type NewTrait_Slice []NewTrait

// implements typeinfo.Instance
func (*NewTrait_Slice) TypeInfo() typeinfo.T {
	return &Zt_NewTrait
}

// implements typeinfo.Repeats
func (op *NewTrait_Slice) Repeats() bool {
	return len(*op) > 0
}

// one or more strings of quoted text
// separated by the words "and", "comma", or "or".
type QuotedTexts struct {
	QuotedText     QuotedText
	AdditionalText *AdditionalText
	Markup         map[string]any
}

// quoted_texts, a type of flow.
var Zt_QuotedTexts typeinfo.Flow

// implements typeinfo.Instance
func (*QuotedTexts) TypeInfo() typeinfo.T {
	return &Zt_QuotedTexts
}

// implements typeinfo.Markup
func (op *QuotedTexts) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type quoted_texts
type QuotedTexts_Slice []QuotedTexts

// implements typeinfo.Instance
func (*QuotedTexts_Slice) TypeInfo() typeinfo.T {
	return &Zt_QuotedTexts
}

// implements typeinfo.Repeats
func (op *QuotedTexts_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches a text following another some previous text.
type AdditionalText struct {
	CommaAndOr  CommaAndOr
	QuotedTexts QuotedTexts
	Markup      map[string]any
}

// additional_text, a type of flow.
var Zt_AdditionalText typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalText) TypeInfo() typeinfo.T {
	return &Zt_AdditionalText
}

// implements typeinfo.Markup
func (op *AdditionalText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_text
type AdditionalText_Slice []AdditionalText

// implements typeinfo.Instance
func (*AdditionalText_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalText
}

// implements typeinfo.Repeats
func (op *AdditionalText_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches rule prefixes
// before, instead of, when, after, report
type RulePrefix struct {
	PrefixValue PrefixValue
	Markup      map[string]any
}

// rule_prefix, a type of flow.
var Zt_RulePrefix typeinfo.Flow

// implements typeinfo.Instance
func (*RulePrefix) TypeInfo() typeinfo.T {
	return &Zt_RulePrefix
}

// implements typeinfo.Markup
func (op *RulePrefix) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type rule_prefix
type RulePrefix_Slice []RulePrefix

// implements typeinfo.Instance
func (*RulePrefix_Slice) TypeInfo() typeinfo.T {
	return &Zt_RulePrefix
}

// implements typeinfo.Repeats
func (op *RulePrefix_Slice) Repeats() bool {
	return len(*op) > 0
}

// controls what to do after matching a rule
// matches "then continue", "then stop", "then jump",
// and "begins", "ends" ( for domain rules )
// with an optional leading comma
type RuleSuffix struct {
	SuffixValue SuffixValue
	Markup      map[string]any
}

// rule_suffix, a type of flow.
var Zt_RuleSuffix typeinfo.Flow

// implements typeinfo.Instance
func (*RuleSuffix) TypeInfo() typeinfo.T {
	return &Zt_RuleSuffix
}

// implements typeinfo.Markup
func (op *RuleSuffix) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type rule_suffix
type RuleSuffix_Slice []RuleSuffix

// implements typeinfo.Instance
func (*RuleSuffix_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleSuffix
}

// implements typeinfo.Repeats
func (op *RuleSuffix_Slice) Repeats() bool {
	return len(*op) > 0
}

// specific names can follow rule declarations
// "( this is the witness light rule )"
type RuleName struct {
	Prefix  bool
	Article string
	Matched string
	Suffix  bool
	Markup  map[string]any
}

// rule_name, a type of flow.
var Zt_RuleName typeinfo.Flow

// implements typeinfo.Instance
func (*RuleName) TypeInfo() typeinfo.T {
	return &Zt_RuleName
}

// implements typeinfo.Markup
func (op *RuleName) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type rule_name
type RuleName_Slice []RuleName

// implements typeinfo.Instance
func (*RuleName_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleName
}

// implements typeinfo.Repeats
func (op *RuleName_Slice) Repeats() bool {
	return len(*op) > 0
}

// phrases can break out of plain text and into structured tell docs.
// the documents start with a colon (:) followed by a newline
// the next line is assumed to be an indented tell mapping or sequence
// which ends with the first unindented line.
// sequences are treated as execute blocks
// mappings are assumed to be a valid eval
// ( ie. an implementation of one of the rtti interfaces. )
type SubAssignment struct {
	Assignment rtti.Assignment
	Markup     map[string]any
}

// sub_assignment, a type of flow.
var Zt_SubAssignment typeinfo.Flow

// implements typeinfo.Instance
func (*SubAssignment) TypeInfo() typeinfo.T {
	return &Zt_SubAssignment
}

// implements typeinfo.Markup
func (op *SubAssignment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type sub_assignment
type SubAssignment_Slice []SubAssignment

// implements typeinfo.Instance
func (*SubAssignment_Slice) TypeInfo() typeinfo.T {
	return &Zt_SubAssignment
}

// implements typeinfo.Repeats
func (op *SubAssignment_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches pattern rule definitions
type TimedRule struct {
	RulePrefix    RulePrefix
	Pattern       Kind
	Target        *Noun
	RuleSuffix    *RuleSuffix
	RuleName      string
	SubAssignment SubAssignment
	Markup        map[string]any
}

// timed_rule, a type of flow.
var Zt_TimedRule typeinfo.Flow

// implements typeinfo.Instance
func (*TimedRule) TypeInfo() typeinfo.T {
	return &Zt_TimedRule
}

// implements typeinfo.Markup
func (op *TimedRule) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type timed_rule
type TimedRule_Slice []TimedRule

// implements typeinfo.Instance
func (*TimedRule_Slice) TypeInfo() typeinfo.T {
	return &Zt_TimedRule
}

// implements typeinfo.Repeats
func (op *TimedRule_Slice) Repeats() bool {
	return len(*op) > 0
}

// various phrases, all starting with the word "Understand"
type Understand struct {
	Understand  Words
	QuotedTexts QuotedTexts
	As          Words
	Article     *Article
	PluralOf    string
	Names       Names
	Markup      map[string]any
}

// understand, a type of flow.
var Zt_Understand typeinfo.Flow

// implements typeinfo.Instance
func (*Understand) TypeInfo() typeinfo.T {
	return &Zt_Understand
}

// implements typeinfo.Markup
func (op *Understand) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type understand
type Understand_Slice []Understand

// implements typeinfo.Instance
func (*Understand_Slice) TypeInfo() typeinfo.T {
	return &Zt_Understand
}

// implements typeinfo.Repeats
func (op *Understand_Slice) Repeats() bool {
	return len(*op) > 0
}

// A mapping declaration starting with a room or door.
// ex. `A dead end called the Airport is west of the Road and north of the Farm.`
type MapLocations struct {
	Linking              Linking
	Are                  Are
	DirectionOfLinking   DirectionOfLinking
	AdditionalDirections *AdditionalDirections
	Markup               map[string]any
}

// map_locations, a type of flow.
var Zt_MapLocations typeinfo.Flow

// implements typeinfo.Instance
func (*MapLocations) TypeInfo() typeinfo.T {
	return &Zt_MapLocations
}

// implements typeinfo.Markup
func (op *MapLocations) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type map_locations
type MapLocations_Slice []MapLocations

// implements typeinfo.Instance
func (*MapLocations_Slice) TypeInfo() typeinfo.T {
	return &Zt_MapLocations
}

// implements typeinfo.Repeats
func (op *MapLocations_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches additional directions
// only used by map_locations
type AdditionalDirections struct {
	CommaAnd             CommaAnd
	DirectionOfLinking   DirectionOfLinking
	AdditionalDirections *AdditionalDirections
	Markup               map[string]any
}

// additional_directions, a type of flow.
var Zt_AdditionalDirections typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalDirections) TypeInfo() typeinfo.T {
	return &Zt_AdditionalDirections
}

// implements typeinfo.Markup
func (op *AdditionalDirections) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_directions
type AdditionalDirections_Slice []AdditionalDirections

// implements typeinfo.Instance
func (*AdditionalDirections_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalDirections
}

// implements typeinfo.Repeats
func (op *AdditionalDirections_Slice) Repeats() bool {
	return len(*op) > 0
}

// A mapping declaration starting with a direction.
type MapDirections struct {
	DirectionOfLinking DirectionOfLinking
	Are                Are
	Linking            *Linking
	Redirect           *DirectionOfLinking
	Markup             map[string]any
}

// map_directions, a type of flow.
var Zt_MapDirections typeinfo.Flow

// implements typeinfo.Instance
func (*MapDirections) TypeInfo() typeinfo.T {
	return &Zt_MapDirections
}

// implements typeinfo.Markup
func (op *MapDirections) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type map_directions
type MapDirections_Slice []MapDirections

// implements typeinfo.Instance
func (*MapDirections_Slice) TypeInfo() typeinfo.T {
	return &Zt_MapDirections
}

// implements typeinfo.Repeats
func (op *MapDirections_Slice) Repeats() bool {
	return len(*op) > 0
}

// A mapping declaration to set the destination of doors.
// ex. `Through the long slide is the cellar.`
//
//	` Through the blue door and the red door is the kitchen.`
//
// The destination of a door is always treated as a room or nowhere.
// ( Inform doesn't allow nowhere, but it seems like a good idea. )
type MapConnections struct {
	Through         bool
	Doors           Linking
	AdditionalLinks *AdditionalLinks
	Are             Are
	Room            Linking
	Markup          map[string]any
}

// map_connections, a type of flow.
var Zt_MapConnections typeinfo.Flow

// implements typeinfo.Instance
func (*MapConnections) TypeInfo() typeinfo.T {
	return &Zt_MapConnections
}

// implements typeinfo.Markup
func (op *MapConnections) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type map_connections
type MapConnections_Slice []MapConnections

// implements typeinfo.Instance
func (*MapConnections_Slice) TypeInfo() typeinfo.T {
	return &Zt_MapConnections
}

// implements typeinfo.Repeats
func (op *MapConnections_Slice) Repeats() bool {
	return len(*op) > 0
}

// partial phrase for mapping declarations.
type DirectionOfLinking struct {
	Direction Direction
	FromOf    Words
	Linking   Linking
	Markup    map[string]any
}

// direction_of_linking, a type of flow.
var Zt_DirectionOfLinking typeinfo.Flow

// implements typeinfo.Instance
func (*DirectionOfLinking) TypeInfo() typeinfo.T {
	return &Zt_DirectionOfLinking
}

// implements typeinfo.Markup
func (op *DirectionOfLinking) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type direction_of_linking
type DirectionOfLinking_Slice []DirectionOfLinking

// implements typeinfo.Instance
func (*DirectionOfLinking_Slice) TypeInfo() typeinfo.T {
	return &Zt_DirectionOfLinking
}

// implements typeinfo.Repeats
func (op *DirectionOfLinking_Slice) Repeats() bool {
	return len(*op) > 0
}

// matches some existing compass direction.
type Direction struct {
	Text   string
	Markup map[string]any
}

// direction, a type of flow.
var Zt_Direction typeinfo.Flow

// implements typeinfo.Instance
func (*Direction) TypeInfo() typeinfo.T {
	return &Zt_Direction
}

// implements typeinfo.Markup
func (op *Direction) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type direction
type Direction_Slice []Direction

// implements typeinfo.Instance
func (*Direction_Slice) TypeInfo() typeinfo.T {
	return &Zt_Direction
}

// implements typeinfo.Repeats
func (op *Direction_Slice) Repeats() bool {
	return len(*op) > 0
}

// generates a room, a door, or nowhere.
// ( similar to, but distinct from other noun matching phrases. )
type Linking struct {
	Nowhere    bool
	KindCalled *KindCalled
	Noun       *Noun
	Name       *Name
	Markup     map[string]any
}

// linking, a type of flow.
var Zt_Linking typeinfo.Flow

// implements typeinfo.Instance
func (*Linking) TypeInfo() typeinfo.T {
	return &Zt_Linking
}

// implements typeinfo.Markup
func (op *Linking) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type linking
type Linking_Slice []Linking

// implements typeinfo.Instance
func (*Linking_Slice) TypeInfo() typeinfo.T {
	return &Zt_Linking
}

// implements typeinfo.Repeats
func (op *Linking_Slice) Repeats() bool {
	return len(*op) > 0
}

// partial phrase used for map connections
// allows multiple doors, etc. on the lhs.
type AdditionalLinks struct {
	CommaAnd        CommaAnd
	Linking         Linking
	AdditionalLinks *AdditionalLinks
	Markup          map[string]any
}

// additional_links, a type of flow.
var Zt_AdditionalLinks typeinfo.Flow

// implements typeinfo.Instance
func (*AdditionalLinks) TypeInfo() typeinfo.T {
	return &Zt_AdditionalLinks
}

// implements typeinfo.Markup
func (op *AdditionalLinks) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type additional_links
type AdditionalLinks_Slice []AdditionalLinks

// implements typeinfo.Instance
func (*AdditionalLinks_Slice) TypeInfo() typeinfo.T {
	return &Zt_AdditionalLinks
}

// implements typeinfo.Repeats
func (op *AdditionalLinks_Slice) Repeats() bool {
	return len(*op) > 0
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "jess",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Matched,
	&Zt_NounBuilder,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Article,
	&Zt_CommaAnd,
	&Zt_CommaAndOr,
	&Zt_Are,
	&Zt_Called,
	&Zt_Name,
	&Zt_Noun,
	&Zt_NamedNoun,
	&Zt_KindCalled,
	&Zt_Names,
	&Zt_AdditionalNames,
	&Zt_CountedKind,
	&Zt_Kind,
	&Zt_Kinds,
	&Zt_AdditionalKinds,
	&Zt_Property,
	&Zt_Trait,
	&Zt_Traits,
	&Zt_AdditionalTraits,
	&Zt_Words,
	&Zt_Verb,
	&Zt_MatchingPhrases,
	&Zt_KindsOf,
	&Zt_KindsAreTraits,
	&Zt_AspectsAreTraits,
	&Zt_VerbNamesAreNames,
	&Zt_NamesVerbNames,
	&Zt_NamesAreLikeVerbs,
	&Zt_VerbPhrase,
	&Zt_Adjectives,
	&Zt_AdditionalAdjectives,
	&Zt_PropertyNounValue,
	&Zt_NounPropertyValue,
	&Zt_SingleValue,
	&Zt_QuotedText,
	&Zt_MatchingNumber,
	&Zt_KindsHaveProperties,
	&Zt_CalledName,
	&Zt_PropertyType,
	&Zt_KindsAreEither,
	&Zt_NewTrait,
	&Zt_QuotedTexts,
	&Zt_AdditionalText,
	&Zt_RulePrefix,
	&Zt_RuleSuffix,
	&Zt_RuleName,
	&Zt_SubAssignment,
	&Zt_TimedRule,
	&Zt_Understand,
	&Zt_MapLocations,
	&Zt_AdditionalDirections,
	&Zt_MapDirections,
	&Zt_MapConnections,
	&Zt_DirectionOfLinking,
	&Zt_Direction,
	&Zt_Linking,
	&Zt_AdditionalLinks,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	12489206644669467772: (*AdditionalAdjectives)(nil), /* AdditionalAdjectives commaAnd:adjectives: */
	13976572281991597662: (*AdditionalDirections)(nil), /* AdditionalDirections commaAnd:directionOfLinking: */
	3987359216723603269:  (*AdditionalDirections)(nil), /* AdditionalDirections commaAnd:directionOfLinking:additionalDirections: */
	12174030489678544826: (*AdditionalKinds)(nil),      /* AdditionalKinds commaAnd:kinds: */
	3282054325918314061:  (*AdditionalLinks)(nil),      /* AdditionalLinks commaAnd:linking: */
	5988669985902941853:  (*AdditionalLinks)(nil),      /* AdditionalLinks commaAnd:linking:additionalLinks: */
	16975120945491427296: (*AdditionalNames)(nil),      /* AdditionalNames commaAnd:names: */
	12949801356443185096: (*AdditionalText)(nil),       /* AdditionalText commaAndOr:quotedTexts: */
	508023169458945308:   (*AdditionalTraits)(nil),     /* AdditionalTraits commaAnd:traits: */
	1887918947148326916:  (*AdditionalTraits)(nil),     /* AdditionalTraits traits: */
	10618851046870477413: (*Adjectives)(nil),           /* Adjectives */
	12215120732458766748: (*Adjectives)(nil),           /* Adjectives additionalAdjectives: */
	724420376605497959:   (*Adjectives)(nil),           /* Adjectives commaAnd: */
	17477522713582243508: (*Adjectives)(nil),           /* Adjectives commaAnd:additionalAdjectives: */
	1568830118683768373:  (*Adjectives)(nil),           /* Adjectives commaAnd:kind: */
	7021517372525507842:  (*Adjectives)(nil),           /* Adjectives commaAnd:kind:additionalAdjectives: */
	7663368451290651677:  (*Adjectives)(nil),           /* Adjectives kind: */
	16725271580009929658: (*Adjectives)(nil),           /* Adjectives kind:additionalAdjectives: */
	13544991759812118088: (*Adjectives)(nil),           /* Adjectives traits: */
	13327572087367323885: (*Adjectives)(nil),           /* Adjectives traits:additionalAdjectives: */
	2209109858568160146:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd: */
	11777076077986952519: (*Adjectives)(nil),           /* Adjectives traits:commaAnd:additionalAdjectives: */
	5997117370605758938:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd:kind: */
	5841657992957591039:  (*Adjectives)(nil),           /* Adjectives traits:commaAnd:kind:additionalAdjectives: */
	11552995266309396480: (*Adjectives)(nil),           /* Adjectives traits:kind: */
	8078288476520567765:  (*Adjectives)(nil),           /* Adjectives traits:kind:additionalAdjectives: */
	14557216947727331217: (*Are)(nil),                  /* Are matched: */
	10435354424123783362: (*Article)(nil),              /* Article text: */
	3333774278464825615:  (*AspectsAreTraits)(nil),     /* AspectsAreTraits aspect:are:plainNames: */
	1429396826658837670:  (*Called)(nil),               /* Called matched: */
	1453048882349619361:  (*CalledName)(nil),           /* CalledName called:name: */
	5180090635119408685:  (*CommaAnd)(nil),             /* CommaAnd matched: */
	4143979682086652670:  (*CommaAndOr)(nil),           /* CommaAndOr matched: */
	11748118905044300293: (*Direction)(nil),            /* Direction text: */
	15872175738337217373: (*DirectionOfLinking)(nil),   /* DirectionOfLinking direction:fromOf:linking: */
	381833413316053162:   (*KindCalled)(nil),           /* KindCalled kind:called:namedNoun: */
	15647995089065713351: (*KindCalled)(nil),           /* KindCalled traits:kind:called:namedNoun: */
	16939996019861136326: (*Kinds)(nil),                /* Kinds article:matched: */
	16946855517465005572: (*Kinds)(nil),                /* Kinds article:matched:additionalKinds: */
	17808071339216334934: (*Kinds)(nil),                /* Kinds matched: */
	17872094200105304436: (*Kinds)(nil),                /* Kinds matched:additionalKinds: */
	4933212495013814755:  (*Kinds)(nil),                /* Kinds traits:article:matched: */
	1182820540821259821:  (*Kinds)(nil),                /* Kinds traits:article:matched:additionalKinds: */
	831875526186841727:   (*Kinds)(nil),                /* Kinds traits:matched: */
	3736619607479472409:  (*Kinds)(nil),                /* Kinds traits:matched:additionalKinds: */
	2480868085776671009:  (*KindsAreEither)(nil),       /* KindsAreEither kind:canBe:traits: */
	8826794343109131276:  (*KindsAreTraits)(nil),       /* KindsAreTraits kinds:are:usually:traits: */
	17116270036433389047: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:listOf:propertyType: */
	17156006172306843757: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:listOf:propertyType:calledName: */
	8108884175448666030:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:propertyType: */
	5228896930769074198:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:article:propertyType:calledName: */
	2093759548632112131:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:listOf:propertyType: */
	11010766076935860857: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:listOf:propertyType:calledName: */
	13822756587399879234: (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:propertyType: */
	8006675921873519578:  (*KindsHaveProperties)(nil),  /* KindsHaveProperties kind:have:propertyType:calledName: */
	11715331887122574628: (*KindsOf)(nil),              /* KindsOf names:are:kindsOf:name: */
	17568620593785114477: (*KindsOf)(nil),              /* KindsOf names:are:kindsOf:traits:name: */
	1268488188857917463:  (*Linking)(nil),              /* Linking */
	5424212330747857864:  (*Linking)(nil),              /* Linking kindCalled: */
	6446505275065105379:  (*Linking)(nil),              /* Linking kindCalled:name: */
	2710323341843582806:  (*Linking)(nil),              /* Linking kindCalled:noun: */
	3374566505223385661:  (*Linking)(nil),              /* Linking kindCalled:noun:name: */
	6388981702446933508:  (*Linking)(nil),              /* Linking name: */
	699798969473871641:   (*Linking)(nil),              /* Linking noun: */
	7057336974261527000:  (*Linking)(nil),              /* Linking noun:name: */
	12985609098990274833: (*Linking)(nil),              /* Linking nowhere: */
	14771750539341337516: (*Linking)(nil),              /* Linking nowhere:kindCalled: */
	5903702872919052743:  (*Linking)(nil),              /* Linking nowhere:kindCalled:name: */
	5217319623359730706:  (*Linking)(nil),              /* Linking nowhere:kindCalled:noun: */
	3495762696381881337:  (*Linking)(nil),              /* Linking nowhere:kindCalled:noun:name: */
	5842644028483118736:  (*Linking)(nil),              /* Linking nowhere:name: */
	6234445843544605613:  (*Linking)(nil),              /* Linking nowhere:noun: */
	215166621636789820:   (*Linking)(nil),              /* Linking nowhere:noun:name: */
	14338407882822574093: (*MapConnections)(nil),       /* MapConnections through:doors:additionalLinks:are:room: */
	13548965473900735969: (*MapConnections)(nil),       /* MapConnections through:doors:are:room: */
	8340425706814700105:  (*MapDirections)(nil),        /* MapDirections directionOfLinking:are: */
	11792054126316928315: (*MapDirections)(nil),        /* MapDirections directionOfLinking:are:linking: */
	17410395297541184115: (*MapDirections)(nil),        /* MapDirections directionOfLinking:are:linking:redirect: */
	7836789797345891325:  (*MapDirections)(nil),        /* MapDirections directionOfLinking:are:redirect: */
	10172864188299309151: (*MapLocations)(nil),         /* MapLocations linking:are:directionOfLinking: */
	4228974132366036894:  (*MapLocations)(nil),         /* MapLocations linking:are:directionOfLinking:additionalDirections: */
	5641041111806881294:  (*MatchingNumber)(nil),       /* MatchingNumber number: */
	12459504191875059457: (*MatchingPhrases)(nil),      /* MatchingPhrases understand:timedRule:kindsOf:aspectsAreTraits:kindsAreTraits:kindsHaveProperties:kindsAreEither:mapConnections:mapDirections:mapLocations:propertyNounValue:nounPropertyValue:verbNamesAreNames:namesVerbNames:namesAreLikeVerbs: */
	9752692754416089114:  (*NamesAreLikeVerbs)(nil),    /* NamesAreLikeVerbs names:are:adjectives: */
	12792661932982325564: (*NamesAreLikeVerbs)(nil),    /* NamesAreLikeVerbs names:are:adjectives:verbPhrase: */
	2930727231635963135:  (*NamesVerbNames)(nil),       /* NamesVerbNames names:are:verb:otherNames: */
	8736862563783456239:  (*NewTrait)(nil),             /* NewTrait matched: */
	8812100125409583293:  (*NewTrait)(nil),             /* NewTrait matched:newTrait: */
	2974378055008641127:  (*NounPropertyValue)(nil),    /* NounPropertyValue namedNoun:has:article:property:of:singleValue: */
	15033098472290183804: (*NounPropertyValue)(nil),    /* NounPropertyValue namedNoun:has:article:property:singleValue: */
	12848318806630146367: (*NounPropertyValue)(nil),    /* NounPropertyValue namedNoun:has:property:of:singleValue: */
	10878709482269586052: (*NounPropertyValue)(nil),    /* NounPropertyValue namedNoun:has:property:singleValue: */
	11106580022094386190: (*Property)(nil),             /* Property article:matched: */
	7038723543321541230:  (*Property)(nil),             /* Property matched: */
	12495940289451013068: (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:namedNoun:are: */
	3073222598673922702:  (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:namedNoun:are:quotedTexts: */
	3232071257951321417:  (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:namedNoun:are:singleValue: */
	12779492266059217511: (*PropertyNounValue)(nil),    /* PropertyNounValue article:property:of:namedNoun:are:singleValue:quotedTexts: */
	9991119609101366868:  (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:namedNoun:are: */
	13706825447213238054: (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:namedNoun:are:quotedTexts: */
	9176481845249379681:  (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:namedNoun:are:singleValue: */
	15509934208360069807: (*PropertyNounValue)(nil),    /* PropertyNounValue property:of:namedNoun:are:singleValue:quotedTexts: */
	3271806062429822368:  (*PropertyType)(nil),         /* PropertyType */
	11567946081716077320: (*PropertyType)(nil),         /* PropertyType kind: */
	8224056348026199873:  (*PropertyType)(nil),         /* PropertyType primitive: */
	8660980422311242175:  (*PropertyType)(nil),         /* PropertyType primitive:kind: */
	6626169867101049892:  (*QuotedText)(nil),           /* QuotedText matched: */
	15490383194906526516: (*QuotedTexts)(nil),          /* QuotedTexts quotedText: */
	18124669431880345752: (*QuotedTexts)(nil),          /* QuotedTexts quotedText:additionalText: */
	13648613004771847774: (*RuleName)(nil),             /* RuleName article:matched: */
	9590534200503230547:  (*RuleName)(nil),             /* RuleName article:matched:suffix: */
	10604149086097886046: (*RuleName)(nil),             /* RuleName matched: */
	1396372580611190611:  (*RuleName)(nil),             /* RuleName matched:suffix: */
	10185222741034633300: (*RuleName)(nil),             /* RuleName prefix:article:matched: */
	3408594760617413485:  (*RuleName)(nil),             /* RuleName prefix:article:matched:suffix: */
	8153362324797089296:  (*RuleName)(nil),             /* RuleName prefix:matched: */
	6292556720924657065:  (*RuleName)(nil),             /* RuleName prefix:matched:suffix: */
	6834190963007140391:  (*RulePrefix)(nil),           /* RulePrefix */
	9987385698008157446:  (*RuleSuffix)(nil),           /* RuleSuffix */
	8620010389824513622:  (*SingleValue)(nil),          /* SingleValue */
	15504423809522254666: (*SingleValue)(nil),          /* SingleValue kind: */
	747026252029666750:   (*SingleValue)(nil),          /* SingleValue matchingNumber: */
	3199991737231408734:  (*SingleValue)(nil),          /* SingleValue matchingNumber:kind: */
	17789670957933718200: (*SingleValue)(nil),          /* SingleValue matchingNumber:noun: */
	12644158024662816112: (*SingleValue)(nil),          /* SingleValue matchingNumber:noun:kind: */
	11550266937804910612: (*SingleValue)(nil),          /* SingleValue noun: */
	15983631673684921876: (*SingleValue)(nil),          /* SingleValue noun:kind: */
	3958109237643295925:  (*SingleValue)(nil),          /* SingleValue quotedText: */
	5530597249301129963:  (*SingleValue)(nil),          /* SingleValue quotedText:kind: */
	17617190106567464055: (*SingleValue)(nil),          /* SingleValue quotedText:matchingNumber: */
	13435854409171053573: (*SingleValue)(nil),          /* SingleValue quotedText:matchingNumber:kind: */
	16335742359860243615: (*SingleValue)(nil),          /* SingleValue quotedText:matchingNumber:noun: */
	8688649593759560061:  (*SingleValue)(nil),          /* SingleValue quotedText:matchingNumber:noun:kind: */
	7763015042528813017:  (*SingleValue)(nil),          /* SingleValue quotedText:noun: */
	1174375068044253639:  (*SingleValue)(nil),          /* SingleValue quotedText:noun:kind: */
	3161285017754785721:  (*SubAssignment)(nil),        /* SubAssignment assignment: */
	8641297100372239080:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleName:subAssignment: */
	1656499122350834261:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleSuffix:ruleName:subAssignment: */
	11245891509928755726: (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:ruleSuffix:subAssignment: */
	8025626927280177953:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:subAssignment: */
	4350630926229098963:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:target:ruleName:subAssignment: */
	10719807371802907896: (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:target:ruleSuffix:ruleName:subAssignment: */
	10614078949980130993: (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:target:ruleSuffix:subAssignment: */
	7967826310862149340:  (*TimedRule)(nil),            /* TimedRule rulePrefix:pattern:target:subAssignment: */
	14664763846497769151: (*Trait)(nil),                /* Trait article:matched: */
	12725361887885713715: (*Trait)(nil),                /* Trait matched: */
	2416383336069566114:  (*Traits)(nil),               /* Traits trait: */
	2878025327467574768:  (*Traits)(nil),               /* Traits trait:additionalTraits: */
	15200598710934343751: (*Understand)(nil),           /* Understand understand:quotedTexts:as:article:names: */
	8602404775723907374:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:article:pluralOf:names: */
	4257336208718925827:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:names: */
	1299769703937557498:  (*Understand)(nil),           /* Understand understand:quotedTexts:as:pluralOf:names: */
	5125756836274165399:  (*Verb)(nil),                 /* Verb text: */
	3016234452937755523:  (*VerbNamesAreNames)(nil),    /* VerbNamesAreNames verb:names:are:otherNames: */
	7322259980003111582:  (*VerbPhrase)(nil),           /* VerbPhrase verb:plainNames: */
	17678340847396548932: (*Words)(nil),                /* Words matched: */
	17929352418080814012: (*CountedKind)(nil),          /* noun_builder=CountedKind article:matchingNumber:kind: */
	11334937790230459436: (*CountedKind)(nil),          /* noun_builder=CountedKind matchingNumber:kind: */
	643122070839149560:   (*Kind)(nil),                 /* noun_builder=Kind article:matched: */
	12803964412357300908: (*Kind)(nil),                 /* noun_builder=Kind matched: */
	16595966641928411799: (*Name)(nil),                 /* noun_builder=Name article:matched: */
	4672836465996832923:  (*Name)(nil),                 /* noun_builder=Name matched: */
	18272900946848200057: (*NamedNoun)(nil),            /* noun_builder=NamedNoun */
	15792878411416494446: (*NamedNoun)(nil),            /* noun_builder=NamedNoun name: */
	4609637404391733803:  (*NamedNoun)(nil),            /* noun_builder=NamedNoun noun: */
	12436910703333794014: (*NamedNoun)(nil),            /* noun_builder=NamedNoun noun:name: */
	2640583889409900672:  (*Names)(nil),                /* noun_builder=Names */
	12738701442995129767: (*Names)(nil),                /* noun_builder=Names additionalNames: */
	18240362602181459374: (*Names)(nil),                /* noun_builder=Names countedKind: */
	12037276021421474977: (*Names)(nil),                /* noun_builder=Names countedKind:additionalNames: */
	11318456940554365262: (*Names)(nil),                /* noun_builder=Names countedKind:kind: */
	2921561536254769409:  (*Names)(nil),                /* noun_builder=Names countedKind:kind:additionalNames: */
	13682022206539604949: (*Names)(nil),                /* noun_builder=Names countedKind:kind:name: */
	11386403162429699442: (*Names)(nil),                /* noun_builder=Names countedKind:kind:name:additionalNames: */
	4820492468237421857:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled: */
	4857057301878550486:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:additionalNames: */
	4610133023990007327:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:kind: */
	306331290473716240:   (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:kind:additionalNames: */
	12828387939941830738: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:kind:name: */
	13812482964698333117: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:kind:name:additionalNames: */
	3933914708907484064:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:name: */
	5386185730384130791:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:name:additionalNames: */
	2738021730814332381:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun: */
	3703234872673498778:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:additionalNames: */
	12823222385333700579: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:kind: */
	10265094182115599260: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:kind:additionalNames: */
	10650274376302874710: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:kind:name: */
	14970606785357505161: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:kind:name:additionalNames: */
	7240077436469524524:  (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:name: */
	16627837112229598459: (*Names)(nil),                /* noun_builder=Names countedKind:kindCalled:noun:name:additionalNames: */
	15188605287333602229: (*Names)(nil),                /* noun_builder=Names countedKind:name: */
	10005531180398488466: (*Names)(nil),                /* noun_builder=Names countedKind:name:additionalNames: */
	2732786101127601032:  (*Names)(nil),                /* noun_builder=Names countedKind:noun: */
	11074441579857580655: (*Names)(nil),                /* noun_builder=Names countedKind:noun:additionalNames: */
	5699674351646236608:  (*Names)(nil),                /* noun_builder=Names countedKind:noun:kind: */
	11208875936483827527: (*Names)(nil),                /* noun_builder=Names countedKind:noun:kind:additionalNames: */
	4114723026604174811:  (*Names)(nil),                /* noun_builder=Names countedKind:noun:kind:name: */
	17665316277083130708: (*Names)(nil),                /* noun_builder=Names countedKind:noun:kind:name:additionalNames: */
	7558135697584793123:  (*Names)(nil),                /* noun_builder=Names countedKind:noun:name: */
	4307309335598848092:  (*Names)(nil),                /* noun_builder=Names countedKind:noun:name:additionalNames: */
	8731626769408708840:  (*Names)(nil),                /* noun_builder=Names kind: */
	5229708717675470479:  (*Names)(nil),                /* noun_builder=Names kind:additionalNames: */
	10589513982817099011: (*Names)(nil),                /* noun_builder=Names kind:name: */
	12371250482715634300: (*Names)(nil),                /* noun_builder=Names kind:name:additionalNames: */
	1696243941719473959:  (*Names)(nil),                /* noun_builder=Names kindCalled: */
	16924085558067939192: (*Names)(nil),                /* noun_builder=Names kindCalled:additionalNames: */
	17975453262944337013: (*Names)(nil),                /* noun_builder=Names kindCalled:kind: */
	1690461824825161682:  (*Names)(nil),                /* noun_builder=Names kindCalled:kind:additionalNames: */
	8025575955095143172:  (*Names)(nil),                /* noun_builder=Names kindCalled:kind:name: */
	4411930061699572051:  (*Names)(nil),                /* noun_builder=Names kindCalled:kind:name:additionalNames: */
	8470829746237860794:  (*Names)(nil),                /* noun_builder=Names kindCalled:name: */
	2285294953849975365:  (*Names)(nil),                /* noun_builder=Names kindCalled:name:additionalNames: */
	456838907409351087:   (*Names)(nil),                /* noun_builder=Names kindCalled:noun: */
	3607075457371268800:  (*Names)(nil),                /* noun_builder=Names kindCalled:noun:additionalNames: */
	10428480112727021197: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:kind: */
	14860782265429290474: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:kind:additionalNames: */
	14089547370513396124: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:kind:name: */
	18215615836863081227: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:kind:name:additionalNames: */
	15212080762452775330: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:name: */
	15368829543700440685: (*Names)(nil),                /* noun_builder=Names kindCalled:noun:name:additionalNames: */
	5911903052848076411:  (*Names)(nil),                /* noun_builder=Names name: */
	12319710271794432948: (*Names)(nil),                /* noun_builder=Names name:additionalNames: */
	2828161936031789150:  (*Names)(nil),                /* noun_builder=Names noun: */
	6435800613231659505:  (*Names)(nil),                /* noun_builder=Names noun:additionalNames: */
	1013731956332121214:  (*Names)(nil),                /* noun_builder=Names noun:kind: */
	2837764967510892753:  (*Names)(nil),                /* noun_builder=Names noun:kind:additionalNames: */
	1168764988217479109:  (*Names)(nil),                /* noun_builder=Names noun:kind:name: */
	14830046638313199170: (*Names)(nil),                /* noun_builder=Names noun:kind:name:additionalNames: */
	7779767529101118373:  (*Names)(nil),                /* noun_builder=Names noun:name: */
	8867758540341244642:  (*Names)(nil),                /* noun_builder=Names noun:name:additionalNames: */
	4465529434619879510:  (*Noun)(nil),                 /* noun_builder=Noun article:matched: */
	2598335774687055558:  (*Noun)(nil),                 /* noun_builder=Noun matched: */
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Article = typeinfo.Flow{
		Name: "article",
		Lede: "article",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "flags",
			Label:   "flags",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one of a predefined set of determiners: the, a/n, some, our.", "only matches if the first letter is lowercase, or uppercase at the start of a sentence;", "otherwise, the article gets treated as part of the name.", "the lack of a recognized article makes something proper-named.", "see 'counted_kind' for names with leading numbers: (ex. five or 27)", "using \"some\"  (ex. \"some coins\") will set nouns as \"plural named\""},
		},
	}
	Zt_CommaAnd = typeinfo.Flow{
		Name: "comma_and",
		Lede: "comma_and",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"conjunction junction.", "matches \",\" or \"and\" or \", and\"", "relies on the fact package match treats commas and ands each as their own words."},
		},
	}
	Zt_CommaAndOr = typeinfo.Flow{
		Name: "comma_and_or",
		Lede: "comma_and_or",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"conjunction or junction.", "matches commas, ands, and ors.", "relies on the fact package match treats commas and ands each as their own words."},
		},
	}
	Zt_Are = typeinfo.Flow{
		Name: "are",
		Lede: "are",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "matches \"is\" or \"are\".",
		},
	}
	Zt_Called = typeinfo.Flow{
		Name: "called",
		Lede: "called",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "matches the word \"called\".",
		},
	}
	Zt_Name = typeinfo.Flow{
		Name: "name",
		Lede: "name",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &Zt_Matched,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Specifies a name who's meaning depends on context.", "For example, when matching: \"Gold Roger's treasure chest is a container. The chest is open.\"", "the \"chest\" implies the noun \"treasure chest.\"", "In other cases, the name might be a kind, or trait, or pretty much anything else.", "To optimizing matching the words \"is/are/comma/and\" are never part of name names.", "future: allow quoted \"titles\" ( which are then allowed to break those assumptions )"},
		},
	}
	Zt_Noun = typeinfo.Flow{
		Name: "noun",
		Lede: "noun",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "the string that matched ( a noun name or alias )",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "actual_noun",
			Label:   "actual_noun",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"matches an existing noun", "by checking multiple words for the best match."},
		},
	}
	Zt_NamedNoun = typeinfo.Flow{
		Name: "named_noun",
		Lede: "named_noun",
		Terms: []typeinfo.Term{{
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Type:     &Zt_Noun,
		}, {
			Name:     "name",
			Label:    "name",
			Optional: true,
			Type:     &Zt_Name,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": "matches an existing noun, or if not: then something new.",
		},
	}
	Zt_KindCalled = typeinfo.Flow{
		Name: "kind_called",
		Lede: "kind_called",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"note: doesn't use 'adjectives' because this doesn't allow", "repetitions of the traits and kind."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "called",
			Label: "called",
			Type:  &Zt_Called,
		}, {
			Name:  "named_noun",
			Label: "named_noun",
			Type:  &Zt_NamedNoun,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a name and its kind in a single phrase.", "Matches: (traits) kind \"called\" {the name}.", "For example: `The closed container called the trunk is in the lobby.`", "As per inform, the name includes all text after the word \"called\"", "until \"is\", \"are\", or the end of the sentence;", "and specifying \"called the/our ...\" gives the noun an indefinite article."},
		},
	}
	Zt_Names = typeinfo.Flow{
		Name: "names",
		Lede: "names",
		Terms: []typeinfo.Term{{
			Name:     "counted_kind",
			Label:    "counted_kind",
			Optional: true,
			Type:     &Zt_CountedKind,
		}, {
			Name:     "kind_called",
			Label:    "kind_called",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"note that because this phrase is greedy", "once used, no additional names will match."},
			},
			Type: &Zt_KindCalled,
		}, {
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Markup: map[string]any{
				"comment": "matches existing nouns",
			},
			Type: &Zt_Noun,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"used primarily for anonymous nouns: ex. \"the container\"", "note that anonymous nouns are prohibited from starting a sentence."},
			},
			Type: &Zt_Kind,
		}, {
			Name:     "name",
			Label:    "name",
			Optional: true,
			Type:     &Zt_Name,
		}, {
			Name:     "additional_names",
			Label:    "additional_names",
			Optional: true,
			Type:     &Zt_AdditionalNames,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Specifies one or more nouns, in full or in part.", "Only one of the options, plus possibly 'additional_names', will match.", "Not all options are valid in all contexts."},
		},
	}
	Zt_AdditionalNames = typeinfo.Flow{
		Name: "additional_names",
		Lede: "additional_names",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "a separator is required between names",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "matches a name following another name.",
		},
	}
	Zt_CountedKind = typeinfo.Flow{
		Name: "counted_kind",
		Lede: "counted_kind",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matching_number",
			Label: "matching_number",
			Type:  &Zt_MatchingNumber,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:    "matched",
			Label:   "matched",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"provides english specification of a number of objects.", "( note: yes, `the five the containers` is permitted. )"},
		},
	}
	Zt_Kind = typeinfo.Flow{
		Name: "kind",
		Lede: "kind",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every kind", "it doesn't influence which kind gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "the string that matched",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "actual_kind",
			Label:   "actual_kind",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_NounBuilder,
		},
		Markup: map[string]any{
			"comment": []interface{}{"matches the name of an existing kind;", "can generate a single anonymous noun."},
		},
	}
	Zt_Kinds = typeinfo.Flow{
		Name: "kinds",
		Lede: "kinds",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform uses traits specified here to select", "matching nouns; jess is not that clever."},
			},
			Type: &Zt_Traits,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Markup: map[string]any{
				"comment": "matches a span ending with \"is/are/comma/and\"",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:     "additional_kinds",
			Label:    "additional_kinds",
			Optional: true,
			Type:     &Zt_AdditionalKinds,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches a set of possible kinds as part of kinds_are_traits", "jess tests for but prohibits leading traits."},
		},
	}
	Zt_AdditionalKinds = typeinfo.Flow{
		Name: "additional_kinds",
		Lede: "additional_kinds",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Markup: map[string]any{
				"comment": "a separator is required between the names of kinds",
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}},
		Markup: map[string]any{
			"comment": "matches a kind following another kind.",
		},
	}
	Zt_Property = typeinfo.Flow{
		Name: "property",
		Lede: "property",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "matches the name of a field in a kind.",
		},
	}
	Zt_Trait = typeinfo.Flow{
		Name: "trait",
		Lede: "trait",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"while an article can precede every trait", "it doesn't influence which trait gets matched."},
			},
			Type: &Zt_Article,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "matches the name of an (existing) trait.",
		},
	}
	Zt_Traits = typeinfo.Flow{
		Name: "traits",
		Lede: "traits",
		Terms: []typeinfo.Term{{
			Name:  "trait",
			Label: "trait",
			Type:  &Zt_Trait,
		}, {
			Name:     "additional_traits",
			Label:    "additional_traits",
			Optional: true,
			Type:     &Zt_AdditionalTraits,
		}},
		Markup: map[string]any{
			"comment": "matches at least one trait.",
		},
	}
	Zt_AdditionalTraits = typeinfo.Flow{
		Name: "additional_traits",
		Lede: "additional_traits",
		Terms: []typeinfo.Term{{
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Type:     &Zt_CommaAnd,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": "matches a trait following another trait",
		},
	}
	Zt_Words = typeinfo.Flow{
		Name: "words",
		Lede: "words",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "matches one or more predefined words",
		},
	}
	Zt_Verb = typeinfo.Flow{
		Name: "verb",
		Lede: "verb",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches one or more predefined verbs", "( verbs are nouns of the verb kind )"},
		},
	}
	Zt_MatchingPhrases = typeinfo.Flow{
		Name: "matching_phrases",
		Lede: "matching_phrases",
		Terms: []typeinfo.Term{{
			Name:  "understand",
			Label: "understand",
			Type:  &Zt_Understand,
		}, {
			Name:  "timed_rule",
			Label: "timed_rule",
			Type:  &Zt_TimedRule,
		}, {
			Name:  "kinds_of",
			Label: "kinds_of",
			Type:  &Zt_KindsOf,
		}, {
			Name:  "aspects_are_traits",
			Label: "aspects_are_traits",
			Type:  &Zt_AspectsAreTraits,
		}, {
			Name:  "kinds_are_traits",
			Label: "kinds_are_traits",
			Type:  &Zt_KindsAreTraits,
		}, {
			Name:  "kinds_have_properties",
			Label: "kinds_have_properties",
			Type:  &Zt_KindsHaveProperties,
		}, {
			Name:  "kinds_are_either",
			Label: "kinds_are_either",
			Type:  &Zt_KindsAreEither,
		}, {
			Name:  "map_connections",
			Label: "map_connections",
			Type:  &Zt_MapConnections,
		}, {
			Name:  "map_directions",
			Label: "map_directions",
			Type:  &Zt_MapDirections,
		}, {
			Name:  "map_locations",
			Label: "map_locations",
			Type:  &Zt_MapLocations,
		}, {
			Name:  "property_noun_value",
			Label: "property_noun_value",
			Type:  &Zt_PropertyNounValue,
		}, {
			Name:  "noun_property_value",
			Label: "noun_property_value",
			Type:  &Zt_NounPropertyValue,
		}, {
			Name:  "verb_names_are_names",
			Label: "verb_names_are_names",
			Type:  &Zt_VerbNamesAreNames,
		}, {
			Name:  "names_verb_names",
			Label: "names_verb_names",
			Type:  &Zt_NamesVerbNames,
		}, {
			Name:  "names_are_like_verbs",
			Label: "names_are_like_verbs",
			Type:  &Zt_NamesAreLikeVerbs,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"union of all possible matching phrases.", "for any given plain text sentence,", "jess tries each of these looking for the first to succeed.", "different phrases belong to different scheduled phases;", "scheduling is handled manually.", "( an alternative might be slots and some scheduling metadata;", "| this is fine for now )"},
		},
	}
	Zt_KindsOf = typeinfo.Flow{
		Name: "kinds_of",
		Lede: "kinds_of",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"can match plain names and existing kinds;", "only allows a leading kind called, and errors on all counted kinds."},
			},
			Type: &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "kinds_of",
			Label: "kinds_of",
			Markup: map[string]any{
				"comment": "the phrases \"a kind of\" or \"kinds of\"",
			},
			Type: &Zt_Words,
		}, {
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform doesnt allow commas or ands here,", "jess reuses the traits list here, so it does allow comma/and."},
			},
			Type: &Zt_Traits,
		}, {
			Name:  "name",
			Label: "name",
			Markup: map[string]any{
				"comment": []interface{}{"inform (weirdly) allows multiple kinds on the rhs:", "`A box is a kind of container and things.`", "but not if traits are specified, suggesting a switch there;", "possibly to detect and reject `A box is a kind of closed and openable container.`", "which it wants written as `A box is a kind of closed openable container.`", "this doesnt switch to special traits, and doesnt allow multiple kinds."},
			},
			Type: &Zt_Name,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"names are \"a kind of\"/\"kinds of\" traits kind:any.", "interesting to note that inform allows \"some kind/s of\"", "this is more strict.", "like inform `The animals called kittens are a kind of things.` is legal."},
		},
	}
	Zt_KindsAreTraits = typeinfo.Flow{
		Name: "kinds_are_traits",
		Lede: "kinds_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "kinds",
			Label: "kinds",
			Type:  &Zt_Kinds,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "usually",
			Label: "usually",
			Type:  &Zt_Words,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_Traits,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"assigns default traits to a kind.", "kinds:objects are \"usually\" traits", "inform doesn't require the \"usually\" --", " i like it as a way to differentiate phrases about kinds vs. phrases about nouns.", "future: inform allows limiting traits to kinds with other traits:", "for example, `the closed containers are fixed in place.`", "makes any containers that are *initially* closed also immovable."},
		},
	}
	Zt_AspectsAreTraits = typeinfo.Flow{
		Name: "aspects_are_traits",
		Lede: "aspects_are_traits",
		Terms: []typeinfo.Term{{
			Name:  "aspect",
			Label: "aspect",
			Type:  &Zt_Kind,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "plain_names",
			Label: "plain_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"defines traits for aspects that can be (re)used by various other kinds.", "ex. `The colors are a kind of aspect. The colors are red, blue, and greasy green.`", "aspects_are_traits, kinds_are_traits, and names_are_like_verbs all handle similar phrasing."},
		},
	}
	Zt_VerbNamesAreNames = typeinfo.Flow{
		Name: "verb_names_are_names",
		Lede: "verb_names_are_names",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "other_names",
			Label: "other_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"verb names are (other) names.", "ex. `In the coffin are some coins, a notebook, and the gripping hand.`", "This intentionally doesn't recognize adjectives attached to named names.", "\"In the closed coffin\" generates a name with the name \"closed coffin\"", "not a coffin in an initially closed state."},
		},
	}
	Zt_NamesVerbNames = typeinfo.Flow{
		Name: "names_verb_names",
		Lede: "names_verb_names",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "other_names",
			Label: "other_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"names are verb (other) names.", "ex. `The thing called the stake is on the supporter called the altar.`"},
		},
	}
	Zt_NamesAreLikeVerbs = typeinfo.Flow{
		Name: "names_are_like_verbs",
		Lede: "names_are_like_verbs",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "names",
			Type:  &Zt_Names,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "adjectives",
			Label: "adjectives",
			Markup: map[string]any{
				"comment": []interface{}{"adjectives are *not* optional.", "if there are no adjectives present,", "then 'names_verb_names' (might) match instead."},
			},
			Type: &Zt_Adjectives,
		}, {
			Name:     "verb_phrase",
			Label:    "verb_phrase",
			Optional: true,
			Type:     &Zt_VerbPhrase,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"names are adjectives [verb names].", "ex. `The bottle is a transparent, open, container.`", "`The coffin is a closed container [in the antechamber]`", "This is the *only* way of assigning names initial states directly.", "All other phrases require a kind to be involved, here the kind is optional."},
		},
	}
	Zt_VerbPhrase = typeinfo.Flow{
		Name: "verb_phrase",
		Lede: "verb_phrase",
		Terms: []typeinfo.Term{{
			Name:  "verb",
			Label: "verb",
			Type:  &Zt_Verb,
		}, {
			Name:  "plain_names",
			Label: "plain_names",
			Type:  &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "ex. \".... in the kitchen.\", or \"... carries the football and sousaphone.\"",
		},
	}
	Zt_Adjectives = typeinfo.Flow{
		Name: "adjectives",
		Lede: "adjectives",
		Terms: []typeinfo.Term{{
			Name:     "traits",
			Label:    "traits",
			Optional: true,
			Type:     &Zt_Traits,
		}, {
			Name:     "comma_and",
			Label:    "comma_and",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"exists to support phrases like:", "`the box is transparent and a container.`"},
			},
			Type: &Zt_CommaAnd,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Type:     &Zt_Kind,
		}, {
			Name:     "additional_adjectives",
			Label:    "additional_adjectives",
			Optional: true,
			Type:     &Zt_AdditionalAdjectives,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one or more phrases consisting of traits and a kind.", "while all parts are marked as optional, matching expects", "there will be at least one trait or one kind", "and that there can only be additional adjective phrases", "if the previous one ended with a kind.", "ex. `a container`", "    `closed and fixed in place`,", "    `a closed container and a fixed in place thing`."},
		},
	}
	Zt_AdditionalAdjectives = typeinfo.Flow{
		Name: "additional_adjectives",
		Lede: "additional_adjectives",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Type:  &Zt_CommaAnd,
		}, {
			Name:  "adjectives",
			Label: "adjectives",
			Type:  &Zt_Adjectives,
		}},
		Markup: map[string]any{
			"comment": "an additional set of traits and a kind",
		},
	}
	Zt_PropertyNounValue = typeinfo.Flow{
		Name: "property_noun_value",
		Lede: "property_noun_value",
		Terms: []typeinfo.Term{{
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "property",
			Label: "property",
			Type:  &Zt_Property,
		}, {
			Name:  "of",
			Label: "of",
			Markup: map[string]any{
				"comment": "the word \"of\"",
			},
			Type: &Zt_Words,
		}, {
			Name:  "named_noun",
			Label: "named_noun",
			Type:  &Zt_NamedNoun,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:     "single_value",
			Label:    "single_value",
			Optional: true,
			Type:     &Zt_SingleValue,
		}, {
			Name:     "quoted_texts",
			Label:    "quoted_texts",
			Optional: true,
			Type:     &Zt_QuotedTexts,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"assigns a default value to a noun.", "ex. `The description of the pen is \"mightier than the sword.`", "as a special case allows also allows a list of quoted text", "indicated with \"are\" ( versus \"is\" )"},
		},
	}
	Zt_NounPropertyValue = typeinfo.Flow{
		Name: "noun_property_value",
		Lede: "noun_property_value",
		Terms: []typeinfo.Term{{
			Name:  "named_noun",
			Label: "named_noun",
			Type:  &Zt_NamedNoun,
		}, {
			Name:  "has",
			Label: "has",
			Type:  &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:  "property",
			Label: "property",
			Type:  &Zt_Property,
		}, {
			Name:     "of",
			Label:    "of",
			Optional: true,
			Markup: map[string]any{
				"comment": "the word \"of\", sometimes reads better this way",
			},
			Type: &Zt_Words,
		}, {
			Name:  "single_value",
			Label: "single_value",
			Type:  &Zt_SingleValue,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"assigns a default value to a noun.", "ex. `The pen has (the) description (of) \"mightier than the sword.\"`", "like inform, adjectives ( in phrases with \"is\" ) cannot be combined with property phrases ( \"has/of\" )"},
		},
	}
	Zt_SingleValue = typeinfo.Flow{
		Name: "single_value",
		Lede: "single_value",
		Terms: []typeinfo.Term{{
			Name:     "quoted_text",
			Label:    "quoted_text",
			Optional: true,
			Type:     &Zt_QuotedText,
		}, {
			Name:     "matching_number",
			Label:    "matching_number",
			Optional: true,
			Type:     &Zt_MatchingNumber,
		}, {
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Type:     &Zt_Noun,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Type:     &Zt_Kind,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches only one of its options", "( the options could be represented as a slot; this feels easier for now )"},
		},
	}
	Zt_QuotedText = typeinfo.Flow{
		Name: "quoted_text",
		Lede: "quoted_text",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"text that begins and ends with double quotes.", "the quotes themselves are not part of the matched text."},
		},
	}
	Zt_MatchingNumber = typeinfo.Flow{
		Name: "matching_number",
		Lede: "matching_number",
		Terms: []typeinfo.Term{{
			Name:  "number",
			Label: "number",
			Type:  &prim.Zt_Number,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"reads a number specified in words or as digits.", "stores the result as the parsed number."},
		},
	}
	Zt_KindsHaveProperties = typeinfo.Flow{
		Name: "kinds_have_properties",
		Lede: "kinds_have_properties",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "have",
			Label: "have",
			Type:  &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &Zt_Article,
		}, {
			Name:     "list_of",
			Label:    "list_of",
			Optional: true,
			Type:     &prim.Zt_Text,
		}, {
			Name:  "property_type",
			Label: "property_type",
			Type:  &Zt_PropertyType,
		}, {
			Name:     "called_name",
			Label:    "called_name",
			Optional: true,
			Type:     &Zt_CalledName,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"kinds \"have\" a (\"list of\") type (\"called\" name)", "ex. Things have some text called a description."},
		},
	}
	Zt_CalledName = typeinfo.Flow{
		Name: "called_name",
		Lede: "called_name",
		Terms: []typeinfo.Term{{
			Name:  "called",
			Label: "called",
			Type:  &Zt_Called,
		}, {
			Name:  "name",
			Label: "name",
			Type:  &Zt_Name,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"for kinds_have_properties", "like kind_called, specifying \"called the/our ...\" gives the noun an indefinite article."},
		},
	}
	Zt_PropertyType = typeinfo.Flow{
		Name: "property_type",
		Lede: "property_type",
		Terms: []typeinfo.Term{{
			Name:     "primitive",
			Label:    "primitive",
			Optional: true,
			Type:     &prim.Zt_Text,
		}, {
			Name:     "kind",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": "kinds|aspects|records",
			},
			Type: &Zt_Kind,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches text, number, kind ( kind|aspect|record )", "as part of 'kinds_have_properties'", "exactly one member can match"},
		},
	}
	Zt_KindsAreEither = typeinfo.Flow{
		Name: "kinds_are_either",
		Lede: "kinds_are_either",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Type:  &Zt_Kind,
		}, {
			Name:  "can_be",
			Label: "can_be",
			Type:  &Zt_Words,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &Zt_NewTrait,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"kinds (\"can be\"|\"are either\") new_trait [or new_trait...]", "ex. A thing can be open or closed."},
		},
	}
	Zt_NewTrait = typeinfo.Flow{
		Name: "new_trait",
		Lede: "new_trait",
		Terms: []typeinfo.Term{{
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}, {
			Name:     "new_trait",
			Label:    "new_trait",
			Optional: true,
			Type:     &Zt_NewTrait,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one or more new trait names,", "separated by the word \"or\""},
		},
	}
	Zt_QuotedTexts = typeinfo.Flow{
		Name: "quoted_texts",
		Lede: "quoted_texts",
		Terms: []typeinfo.Term{{
			Name:  "quoted_text",
			Label: "quoted_text",
			Type:  &Zt_QuotedText,
		}, {
			Name:     "additional_text",
			Label:    "additional_text",
			Optional: true,
			Type:     &Zt_AdditionalText,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"one or more strings of quoted text", "separated by the words \"and\", \"comma\", or \"or\"."},
		},
	}
	Zt_AdditionalText = typeinfo.Flow{
		Name: "additional_text",
		Lede: "additional_text",
		Terms: []typeinfo.Term{{
			Name:  "comma_and_or",
			Label: "comma_and_or",
			Type:  &Zt_CommaAndOr,
		}, {
			Name:  "quoted_texts",
			Label: "quoted_texts",
			Type:  &Zt_QuotedTexts,
		}},
		Markup: map[string]any{
			"comment": "matches a text following another some previous text.",
		},
	}
	Zt_RulePrefix = typeinfo.Flow{
		Name: "rule_prefix",
		Lede: "rule_prefix",
		Terms: []typeinfo.Term{{
			Name:    "prefix_value",
			Label:   "prefix_value",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches rule prefixes", "before, instead of, when, after, report"},
		},
	}
	Zt_RuleSuffix = typeinfo.Flow{
		Name: "rule_suffix",
		Lede: "rule_suffix",
		Terms: []typeinfo.Term{{
			Name:    "suffix_value",
			Label:   "suffix_value",
			Private: true,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"controls what to do after matching a rule", "matches \"then continue\", \"then stop\", \"then jump\",", "and \"begins\", \"ends\" ( for domain rules )", "with an optional leading comma"},
		},
	}
	Zt_RuleName = typeinfo.Flow{
		Name: "rule_name",
		Lede: "rule_name",
		Terms: []typeinfo.Term{{
			Name:     "prefix",
			Label:    "prefix",
			Optional: true,
			Markup: map[string]any{
				"comment": "\"this is the\"",
			},
			Type: &prim.Zt_Bool,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Type:     &prim.Zt_Text,
		}, {
			Name:  "matched",
			Label: "matched",
			Type:  &prim.Zt_Text,
		}, {
			Name:     "suffix",
			Label:    "suffix",
			Optional: true,
			Markup: map[string]any{
				"comment": "the word \"rule\"",
			},
			Type: &prim.Zt_Bool,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"specific names can follow rule declarations", "\"( this is the witness light rule )\""},
		},
	}
	Zt_SubAssignment = typeinfo.Flow{
		Name: "sub_assignment",
		Lede: "sub_assignment",
		Terms: []typeinfo.Term{{
			Name:  "assignment",
			Label: "assignment",
			Type:  &rtti.Zt_Assignment,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"phrases can break out of plain text and into structured tell docs.", "the documents start with a colon (:) followed by a newline", "the next line is assumed to be an indented tell mapping or sequence", "which ends with the first unindented line.", "sequences are treated as execute blocks", "mappings are assumed to be a valid eval", "( ie. an implementation of one of the rtti interfaces. )"},
		},
	}
	Zt_TimedRule = typeinfo.Flow{
		Name: "timed_rule",
		Lede: "timed_rule",
		Terms: []typeinfo.Term{{
			Name:  "rule_prefix",
			Label: "rule_prefix",
			Type:  &Zt_RulePrefix,
		}, {
			Name:  "pattern",
			Label: "pattern",
			Markup: map[string]any{
				"comment": []interface{}{"the pattern this rule targets.", "the pattern must exist for this phrase to generate successfully.", "ex. \"instead of traveling\""},
			},
			Type: &Zt_Kind,
		}, {
			Name:     "target",
			Label:    "target",
			Optional: true,
			Type:     &Zt_Noun,
		}, {
			Name:     "rule_suffix",
			Label:    "rule_suffix",
			Optional: true,
			Type:     &Zt_RuleSuffix,
		}, {
			Name:     "rule_name",
			Label:    "rule_name",
			Optional: true,
			Type:     &prim.Zt_Text,
		}, {
			Name:  "sub_assignment",
			Label: "sub_assignment",
			Type:  &Zt_SubAssignment,
		}},
		Markup: map[string]any{
			"comment": "matches pattern rule definitions",
		},
	}
	Zt_Understand = typeinfo.Flow{
		Name: "understand",
		Lede: "understand",
		Terms: []typeinfo.Term{{
			Name:  "understand",
			Label: "understand",
			Type:  &Zt_Words,
		}, {
			Name:  "quoted_texts",
			Label: "quoted_texts",
			Markup: map[string]any{
				"comment": "all of jess's understand start with quoted text",
			},
			Type: &Zt_QuotedTexts,
		}, {
			Name:  "as",
			Label: "as",
			Type:  &Zt_Words,
		}, {
			Name:     "article",
			Label:    "article",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"inform is smart enough to *not* allow articles before actions.", "i am lazy."},
			},
			Type: &Zt_Article,
		}, {
			Name:     "plural_of",
			Label:    "plural_of",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"ex. Understand \"birds\" and \"ruddy ducks\" as the plural of duck.", "fix? in jess this (also) influences the story interpretation."},
			},
			Type: &prim.Zt_Text,
		}, {
			Name:  "names",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"this matches one or more nouns or kinds:", "generation susses out what to do with those nouns or kinds.", "* aliases for nouns: Understand \"floor\" or \"sawdust\" as the message.", "* aliases for kinds: Understand \"cupboard\" or \"cupboards\" or \"cabinets\" as a cabinet.", "* grammar for actions: Understand \"reach underneath/under/beneath/-- [something]\" as looking under.", "jess doesn't permit aliases for kinds, those generate errors."},
			},
			Type: &Zt_Names,
		}},
		Markup: map[string]any{
			"comment": "various phrases, all starting with the word \"Understand\"",
		},
	}
	Zt_MapLocations = typeinfo.Flow{
		Name: "map_locations",
		Lede: "map_locations",
		Terms: []typeinfo.Term{{
			Name:  "linking",
			Label: "linking",
			Type:  &Zt_Linking,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "direction_of_linking",
			Label: "direction_of_linking",
			Type:  &Zt_DirectionOfLinking,
		}, {
			Name:     "additional_directions",
			Label:    "additional_directions",
			Optional: true,
			Type:     &Zt_AdditionalDirections,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"A mapping declaration starting with a room or door.", "ex. `A dead end called the Airport is west of the Road and north of the Farm.`"},
		},
	}
	Zt_AdditionalDirections = typeinfo.Flow{
		Name: "additional_directions",
		Lede: "additional_directions",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Type:  &Zt_CommaAnd,
		}, {
			Name:  "direction_of_linking",
			Label: "direction_of_linking",
			Type:  &Zt_DirectionOfLinking,
		}, {
			Name:     "additional_directions",
			Label:    "additional_directions",
			Optional: true,
			Type:     &Zt_AdditionalDirections,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"matches additional directions", "only used by map_locations"},
		},
	}
	Zt_MapDirections = typeinfo.Flow{
		Name: "map_directions",
		Lede: "map_directions",
		Terms: []typeinfo.Term{{
			Name:  "direction_of_linking",
			Label: "direction_of_linking",
			Type:  &Zt_DirectionOfLinking,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:     "linking",
			Label:    "linking",
			Optional: true,
			Markup: map[string]any{
				"comment": "ex. `[Inside from the Meadow] is... the woodcutter's hut.`",
			},
			Type: &Zt_Linking,
		}, {
			Name:     "redirect",
			Label:    "redirect",
			Optional: true,
			Markup: map[string]any{
				"comment": "ex. `[West of the Garden] is ... south of the Meadow.`",
			},
			Type: &Zt_DirectionOfLinking,
		}},
		Markup: map[string]any{
			"comment": "A mapping declaration starting with a direction.",
		},
	}
	Zt_MapConnections = typeinfo.Flow{
		Name: "map_connections",
		Lede: "map_connections",
		Terms: []typeinfo.Term{{
			Name:  "through",
			Label: "through",
			Type:  &prim.Zt_Bool,
		}, {
			Name:  "doors",
			Label: "doors",
			Type:  &Zt_Linking,
		}, {
			Name:     "additional_links",
			Label:    "additional_links",
			Optional: true,
			Type:     &Zt_AdditionalLinks,
		}, {
			Name:  "are",
			Label: "are",
			Type:  &Zt_Are,
		}, {
			Name:  "room",
			Label: "room",
			Type:  &Zt_Linking,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"A mapping declaration to set the destination of doors.", "ex. `Through the long slide is the cellar.`", "    ` Through the blue door and the red door is the kitchen.`", "The destination of a door is always treated as a room or nowhere.", "( Inform doesn't allow nowhere, but it seems like a good idea. )"},
		},
	}
	Zt_DirectionOfLinking = typeinfo.Flow{
		Name: "direction_of_linking",
		Lede: "direction_of_linking",
		Terms: []typeinfo.Term{{
			Name:  "direction",
			Label: "direction",
			Type:  &Zt_Direction,
		}, {
			Name:  "from_of",
			Label: "from_of",
			Type:  &Zt_Words,
		}, {
			Name:  "linking",
			Label: "linking",
			Markup: map[string]any{
				"comment": "a room or door.",
			},
			Type: &Zt_Linking,
		}},
		Markup: map[string]any{
			"comment": "partial phrase for mapping declarations.",
		},
	}
	Zt_Direction = typeinfo.Flow{
		Name: "direction",
		Lede: "direction",
		Terms: []typeinfo.Term{{
			Name:  "text",
			Label: "text",
			Type:  &prim.Zt_Text,
		}},
		Markup: map[string]any{
			"comment": "matches some existing compass direction.",
		},
	}
	Zt_Linking = typeinfo.Flow{
		Name: "linking",
		Lede: "linking",
		Terms: []typeinfo.Term{{
			Name:     "nowhere",
			Label:    "nowhere",
			Optional: true,
			Type:     &prim.Zt_Bool,
		}, {
			Name:     "kind_called",
			Label:    "kind_called",
			Optional: true,
			Type:     &Zt_KindCalled,
		}, {
			Name:     "noun",
			Label:    "noun",
			Optional: true,
			Type:     &Zt_Noun,
		}, {
			Name:     "name",
			Label:    "name",
			Optional: true,
			Type:     &Zt_Name,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"generates a room, a door, or nowhere.", "( similar to, but distinct from other noun matching phrases. )"},
		},
	}
	Zt_AdditionalLinks = typeinfo.Flow{
		Name: "additional_links",
		Lede: "additional_links",
		Terms: []typeinfo.Term{{
			Name:  "comma_and",
			Label: "comma_and",
			Type:  &Zt_CommaAnd,
		}, {
			Name:  "linking",
			Label: "linking",
			Type:  &Zt_Linking,
		}, {
			Name:     "additional_links",
			Label:    "additional_links",
			Optional: true,
			Type:     &Zt_AdditionalLinks,
		}},
		Markup: map[string]any{
			"comment": []interface{}{"partial phrase used for map connections", "allows multiple doors, etc. on the lhs."},
		},
	}
}
