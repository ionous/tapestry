// Code generated by "makeops"; edit at your own risk.
package story

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// AbstractAction requires a user-specified string.
type AbstractAction string

func (*AbstractAction) Choices() (choices map[string]string) {
	return map[string]string{
		"$NOTHING": "nothing",
	}
}

func (*AbstractAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "abstract_action",
		Strings: []string{
			"nothing",
		},
	}
}

// ActionContext
type ActionContext struct {
	Kind string `if:"label=kind"`
}

func (*ActionContext) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_context",
		Lede: "and one ",
	}
}

// ActionDecl Activities help actors perform tasks: for instance, picking up or dropping items.
type ActionDecl struct {
	Event        string       `if:"label=act"`
	Action       string       `if:"label=acting"`
	ActionParams ActionParams `if:"label=action_params"`
}

func (*ActionDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_decl",
		Lede: "Agents can ",
	}
}

// ActionParams swaps between various options
type ActionParams struct {
	Opt interface{}
}

func (*ActionParams) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_params",
	}
}

func (*ActionParams) Choices() map[string]interface{} {
	return map[string]interface{}{
		"common": (*CommonAction)(nil),
		"dual":   (*PairedAction)(nil),
		"none":   (*AbstractAction)(nil),
	}
}

// AreAn requires a user-specified string.
type AreAn string

func (*AreAn) Choices() (choices map[string]string) {
	return map[string]string{
		"$ARE": "are", "$AREA": "area", "$AREAN": "arean", "$IS": "is", "$ISA": "isa", "$ISAN": "isan",
	}
}

func (*AreAn) Compose() composer.Spec {
	return composer.Spec{
		Name: "are_an",
		Strings: []string{
			"are", "area", "arean", "is", "isa", "isan",
		},
	}
}

// AspectTraits
type AspectTraits struct {
	Aspect      string      `if:"label=aspect"`
	TraitPhrase TraitPhrase `if:"label=trait_phrase"`
}

func (*AspectTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: "aspect_traits",
	}
}

// BoxedNumber
type BoxedNumber struct {
	Number float64 `if:"label=number"`
}

func (*BoxedNumber) Compose() composer.Spec {
	return composer.Spec{
		Name: "boxed_number",
	}
}

// BoxedText
type BoxedText struct {
	Text value.Text `if:"label=text"`
}

func (*BoxedText) Compose() composer.Spec {
	return composer.Spec{
		Name: "boxed_text",
	}
}

// Certainties
type Certainties struct {
	PluralKinds string    `if:"label=plural_kinds"`
	AreBeing    bool      `if:"label=are_being"`
	Certainty   Certainty `if:"label=certainty"`
	Trait       string    `if:"label=trait"`
}

func (*Certainties) Compose() composer.Spec {
	return composer.Spec{
		Name: "certainties",
	}
}

// Certainty requires a user-specified string.
type Certainty string

func (*Certainty) Choices() (choices map[string]string) {
	return map[string]string{
		"$USUALLY": "usually", "$ALWAYS": "always", "$SELDOM": "seldom", "$NEVER": "never",
	}
}

func (*Certainty) Compose() composer.Spec {
	return composer.Spec{
		Name: "certainty",
		Strings: []string{
			"usually", "always", "seldom", "never",
		},
	}
}

// Comment Information about the story for you and other authors.
type Comment struct {
	Lines string `if:"label=comment"`
}

func (*Comment) Compose() composer.Spec {
	return composer.Spec{
		Name: "comment",
		Lede: "Note: ",
	}
}

// CommonAction
type CommonAction struct {
	Kind          string         `if:"label=kind"`
	ActionContext *ActionContext `if:"label=action_context,optional"`
}

func (*CommonAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "common_action",
		Lede: "one ",
	}
}

// Determiner requires a user-specified string.
type Determiner string

func (*Determiner) Choices() (choices map[string]string) {
	return map[string]string{
		"$A": "a", "$AN": "an", "$THE": "the", "$OUR": "our",
	}
}

func (*Determiner) Compose() composer.Spec {
	return composer.Spec{
		Name:        "determiner",
		OpenStrings: true,
		Strings: []string{
			"a", "an", "the", "our",
		},
	}
}

// EventBlock Listeners let objects in the game world react to changes before, during, or after they happen.
type EventBlock struct {
	Target   EventTarget    `if:"label=the_target"`
	Handlers []EventHandler `if:"label=handlers"`
}

func (*EventBlock) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_block",
		Lede: "For ",
	}
}

// EventHandler
type EventHandler struct {
	EventPhase   EventPhase     `if:"label=event_phase"`
	Event        string         `if:"label=the_event"`
	Locals       *PatternLocals `if:"label=with_locals,optional"`
	PatternRules PatternRules   `if:"label=pattern_rules"`
}

func (*EventHandler) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_handler",
	}
}

// EventPhase requires a user-specified string.
type EventPhase string

func (*EventPhase) Choices() (choices map[string]string) {
	return map[string]string{
		"$BEFORE": "before", "$WHILE": "while", "$AFTER": "after",
	}
}

func (*EventPhase) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_phase",
		Strings: []string{
			"before", "while", "after",
		},
	}
}

// EventTarget swaps between various options
type EventTarget struct {
	Opt interface{}
}

func (*EventTarget) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_target",
		Lede: "the ",
	}
}

func (*EventTarget) Choices() map[string]interface{} {
	return map[string]interface{}{
		"kinds":      (*string)(nil),
		"named_noun": (*NamedNoun)(nil),
	}
}

// ExtType swaps between various options
type ExtType struct {
	Opt interface{}
}

func (*ExtType) Compose() composer.Spec {
	return composer.Spec{
		Name: "ext_type",
		Lede: "a list of ",
	}
}

func (*ExtType) Choices() map[string]interface{} {
	return map[string]interface{}{
		"numbers":        (*NumberListType)(nil),
		"text_list_type": (*TextListType)(nil),
		"record":         (*RecordType)(nil),
		"records":        (*RecordListType)(nil),
	}
}

// KindOfNoun
type KindOfNoun struct {
	AreAn        AreAn         `if:"label=are_an"`
	Trait        []string      `if:"label=trait,optional"`
	Kind         string        `if:"label=kind"`
	NounRelation *NounRelation `if:"label=noun_relation,optional"`
}

func (*KindOfNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of_noun",
	}
}

// KindOfRelation
type KindOfRelation struct {
	Relation            string              `if:"label=relation"`
	RelationCardinality RelationCardinality `if:"label=relation_cardinality"`
}

func (*KindOfRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of_relation",
	}
}

// KindsOfAspect
type KindsOfAspect struct {
	Aspect string `if:"label=aspect"`
}

func (*KindsOfAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_aspect",
	}
}

// KindsOfKind
type KindsOfKind struct {
	PluralKinds  string `if:"label=plural_kinds"`
	SingularKind string `if:"label=singular_kind"`
}

func (*KindsOfKind) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_kind",
	}
}

// KindsOfRecord
type KindsOfRecord struct {
	RecordPlural string `if:"label=records"`
}

func (*KindsOfRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_record",
	}
}

// KindsPossessProperties
type KindsPossessProperties struct {
	PluralKinds  string         `if:"label=plural_kinds"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*KindsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_possess_properties",
	}
}

// Lede Describes one or more nouns.
type Lede struct {
	Nouns      []NamedNoun `if:"label=nouns"`
	NounPhrase NounPhrase  `if:"label=noun_phrase"`
}

func (*Lede) Compose() composer.Spec {
	return composer.Spec{
		Name: "lede",
	}
}

// LocalDecl local variables can use the parameters of a pattern to compute temporary values.
type LocalDecl struct {
	VariableDecl VariableDecl `if:"label=variable_decl"`
	Value        *LocalInit   `if:"label=starting_as,optional"`
}

func (*LocalDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "local_decl",
		Lede: " using ",
	}
}

// LocalInit local variables can use the parameters of a pattern to compute temporary values.
type LocalInit struct {
	Value rt.Assignment `if:"label=value"`
}

func (*LocalInit) Compose() composer.Spec {
	return composer.Spec{
		Name: "local_init",
		Lede: " starting as ",
	}
}

// ManyToMany
type ManyToMany struct {
	Kinds      string `if:"label=kinds"`
	OtherKinds string `if:"label=other_kinds"`
}

func (*ManyToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: "many_to_many",
		Lede: "many ",
	}
}

// ManyToOne
type ManyToOne struct {
	Kinds string `if:"label=kinds"`
	Kind  string `if:"label=kind"`
}

func (*ManyToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: "many_to_one",
		Lede: "many ",
	}
}

// NamedNoun
type NamedNoun struct {
	Determiner Determiner `if:"label=determiner"`
	Name       string     `if:"label=name"`
}

func (*NamedNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "named_noun",
	}
}

// NounAssignment Assign text.
type NounAssignment struct {
	Property string      `if:"label=property"`
	Nouns    []NamedNoun `if:"label=nouns"`
	Lines    string      `if:"label=the_text"`
}

func (*NounAssignment) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_assignment",
		Lede: "The ",
	}
}

// NounPhrase swaps between various options
type NounPhrase struct {
	Opt interface{}
}

func (*NounPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_phrase",
	}
}

func (*NounPhrase) Choices() map[string]interface{} {
	return map[string]interface{}{
		"kind_of_noun":  (*KindOfNoun)(nil),
		"noun_traits":   (*NounTraits)(nil),
		"noun_relation": (*NounRelation)(nil),
	}
}

// NounRelation
type NounRelation struct {
	AreBeing bool        `if:"label=are_being,optional"`
	Relation string      `if:"label=relation"`
	Nouns    []NamedNoun `if:"label=nouns"`
}

func (*NounRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_relation",
	}
}

// NounStatement Describes people, places, or things.
type NounStatement struct {
	Lede    Lede     `if:"label=lede"`
	Tail    []Tail   `if:"label=tail,optional"`
	Summary *Summary `if:"label=summary,optional"`
}

func (*NounStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_statement",
	}
}

// NounTraits
type NounTraits struct {
	AreBeing bool     `if:"label=are_being"`
	Trait    []string `if:"label=trait"`
}

func (*NounTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_traits",
	}
}

// NumberListType requires a user-specified string.
type NumberListType string

func (*NumberListType) Choices() (choices map[string]string) {
	return map[string]string{
		"$LIST": "list",
	}
}

func (*NumberListType) Compose() composer.Spec {
	return composer.Spec{
		Name: "number_list_type",
		Strings: []string{
			"list",
		},
	}
}

// ObjectType
type ObjectType struct {
	An   bool   `if:"label=an"`
	Kind string `if:"label=kind_of"`
}

func (*ObjectType) Compose() composer.Spec {
	return composer.Spec{
		Name: "object_type",
	}
}

// OneToMany
type OneToMany struct {
	Kind  string `if:"label=kind"`
	Kinds string `if:"label=kinds"`
}

func (*OneToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: "one_to_many",
		Lede: "one ",
	}
}

// OneToOne
type OneToOne struct {
	Kind      string `if:"label=kind"`
	OtherKind string `if:"label=other_kind"`
}

func (*OneToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: "one_to_one",
		Lede: "one ",
	}
}

// PairedAction
type PairedAction struct {
	Kinds string `if:"label=kinds"`
}

func (*PairedAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "paired_action",
		Lede: "two ",
	}
}

// Paragraph
type Paragraph struct {
	StoryStatement []StoryStatement `if:"label=story_statement,optional"`
}

func (*Paragraph) Compose() composer.Spec {
	return composer.Spec{
		Name: "paragraph",
	}
}

// PatternActions Actions to take when using a pattern.
type PatternActions struct {
	Name          string         `if:"label=pattern_name"`
	PatternLocals *PatternLocals `if:"label=pattern_locals,optional"`
	PatternReturn *PatternReturn `if:"label=pattern_return,optional"`
	PatternRules  PatternRules   `if:"label=pattern_rules"`
}

func (*PatternActions) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_actions",
		Lede: "To determine ",
	}
}

// PatternDecl A pattern is a bundle of functions which can either change the game world or provide information about it.
type PatternDecl struct {
	Type          PatternType           `if:"label=type"`
	Name          string                `if:"label=name"`
	Optvars       *PatternVariablesTail `if:"label=parameters,optional"`
	PatternReturn *PatternReturn        `if:"label=pattern_return,optional"`
	About         *Comment              `if:"label=about,optional"`
}

func (*PatternDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_decl",
	}
}

// PatternFlags requires a user-specified string.
type PatternFlags string

func (*PatternFlags) Choices() (choices map[string]string) {
	return map[string]string{
		"$BEFORE": "before", "$AFTER": "after", "$TERMINATE": "terminate",
	}
}

func (*PatternFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_flags",
		Strings: []string{
			"before", "after", "terminate",
		},
	}
}

// PatternLocals
type PatternLocals struct {
	LocalDecl []LocalDecl `if:"label=local_decl"`
}

func (*PatternLocals) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_locals",
	}
}

// PatternReturn
type PatternReturn struct {
	Result VariableDecl `if:"label=result"`
}

func (*PatternReturn) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_return",
		Lede: "returning ",
	}
}

// PatternRule
type PatternRule struct {
	Guard rt.BoolEval  `if:"label=conditions_are met"`
	Flags PatternFlags `if:"label=continue,optional"`
	Hook  ProgramHook  `if:"label=do"`
}

func (*PatternRule) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_rule",
		Lede: "When ",
	}
}

// PatternRules
type PatternRules struct {
	PatternRule []PatternRule `if:"label=pattern_rule,optional"`
}

func (*PatternRules) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_rules",
	}
}

// PatternType requires a user-specified string.
type PatternType string

func (*PatternType) Choices() (choices map[string]string) {
	return map[string]string{
		"$PATTERNS": "patterns", "$ACTIONS": "actions", "$EVENTS": "events",
	}
}

func (*PatternType) Compose() composer.Spec {
	return composer.Spec{
		Name:        "pattern_type",
		OpenStrings: true,
		Strings: []string{
			"patterns", "actions", "events",
		},
	}
}

// PatternVariablesDecl Values provided when calling a pattern.
type PatternVariablesDecl struct {
	PatternName  string         `if:"label=pattern_name"`
	VariableDecl []VariableDecl `if:"label=variable_decl"`
}

func (*PatternVariablesDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_variables_decl",
		Lede: "The pattern ",
	}
}

// PatternVariablesTail Storage for values used during the execution of a pattern.
type PatternVariablesTail struct {
	VariableDecl []VariableDecl `if:"label=variable_decl"`
}

func (*PatternVariablesTail) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_variables_tail",
		Lede: "It requires ",
	}
}

// PrimitiveType requires a user-specified string.
type PrimitiveType string

func (*PrimitiveType) Choices() (choices map[string]string) {
	return map[string]string{
		"$NUMBER": "number", "$TEXT": "text", "$BOOL": "bool",
	}
}

func (*PrimitiveType) Compose() composer.Spec {
	return composer.Spec{
		Name: "primitive_type",
		Strings: []string{
			"number", "text", "bool",
		},
	}
}

// PrimitiveValue swaps between various options
type PrimitiveValue struct {
	Opt interface{}
}

func (*PrimitiveValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "primitive_value",
	}
}

func (*PrimitiveValue) Choices() map[string]interface{} {
	return map[string]interface{}{
		"boxed_text":   (*BoxedText)(nil),
		"boxed_number": (*BoxedNumber)(nil),
	}
}

// ProgramHook swaps between various options
type ProgramHook struct {
	Opt interface{}
}

func (*ProgramHook) Compose() composer.Spec {
	return composer.Spec{
		Name: "program_hook",
		Lede: "do ",
	}
}

func (*ProgramHook) Choices() map[string]interface{} {
	return map[string]interface{}{
		"activity": (*core.Activity)(nil),
	}
}

// Pronoun requires a user-specified string.
type Pronoun string

func (*Pronoun) Choices() (choices map[string]string) {
	return map[string]string{
		"$IT": "it", "$THEY": "they",
	}
}

func (*Pronoun) Compose() composer.Spec {
	return composer.Spec{
		Name:        "pronoun",
		OpenStrings: true,
		Strings: []string{
			"it", "they",
		},
	}
}

// PropertyAspect requires a user-specified string.
type PropertyAspect string

func (*PropertyAspect) Choices() (choices map[string]string) {
	return map[string]string{
		"$ASPECT": "aspect",
	}
}

func (*PropertyAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_aspect",
		Strings: []string{
			"aspect",
		},
	}
}

// PropertyDecl
type PropertyDecl struct {
	An           Determiner   `if:"label=an"`
	Property     string       `if:"label=property"`
	PropertyType PropertyType `if:"label=property_type"`
	Comment      string       `if:"label=comment,optional"`
}

func (*PropertyDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_decl",
	}
}

// PropertyType swaps between various options
type PropertyType struct {
	Opt interface{}
}

func (*PropertyType) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_type",
		Lede: "an ",
	}
}

func (*PropertyType) Choices() map[string]interface{} {
	return map[string]interface{}{
		"property_aspect": (*PropertyAspect)(nil),
		"primitive":       (*PrimitiveType)(nil),
		"ext":             (*ExtType)(nil),
	}
}

// RecordListType
type RecordListType struct {
	Kind string `if:"label=kind"`
}

func (*RecordListType) Compose() composer.Spec {
	return composer.Spec{
		Name: "record_list_type",
		Lede: "a list of ",
	}
}

// RecordType
type RecordType struct {
	Kind string `if:"label=kind"`
}

func (*RecordType) Compose() composer.Spec {
	return composer.Spec{
		Name: "record_type",
		Lede: "a record of ",
	}
}

// RecordsPossessProperties
type RecordsPossessProperties struct {
	RecordPlural string         `if:"label=records"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*RecordsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: "records_possess_properties",
	}
}

// RelationCardinality swaps between various options
type RelationCardinality struct {
	Opt interface{}
}

func (*RelationCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: "relation_cardinality",
	}
}

func (*RelationCardinality) Choices() map[string]interface{} {
	return map[string]interface{}{
		"one_to_one":   (*OneToOne)(nil),
		"one_to_many":  (*OneToMany)(nil),
		"many_to_one":  (*ManyToOne)(nil),
		"many_to_many": (*ManyToMany)(nil),
	}
}

// RelativeToNoun
type RelativeToNoun struct {
	Relation string      `if:"label=relation"`
	Nouns    []NamedNoun `if:"label=nouns"`
	AreBeing bool        `if:"label=are_being"`
	Nouns1   []NamedNoun `if:"label=nouns"`
}

func (*RelativeToNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "relative_to_noun",
		Lede: "The ",
	}
}

// Story
type Story struct {
	Paragraph []Paragraph `if:"label=paragraph,optional"`
}

func (*Story) Compose() composer.Spec {
	return composer.Spec{
		Name: "story",
	}
}

// Summary
type Summary struct {
	Lines string `if:"label=summary"`
}

func (*Summary) Compose() composer.Spec {
	return composer.Spec{
		Name: "summary",
		Lede: "The summary is: ",
	}
}

// Tail Adds details about the preceding noun or nouns.
type Tail struct {
	Pronoun    Pronoun    `if:"label=pronoun"`
	NounPhrase NounPhrase `if:"label=noun_phrase"`
}

func (*Tail) Compose() composer.Spec {
	return composer.Spec{
		Name: "tail",
	}
}

// TestName requires a user-specified string.
type TestName string

func (*TestName) Choices() (choices map[string]string) {
	return map[string]string{
		"$CURRENT_TEST": "current_test",
	}
}

func (*TestName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "test_name",
		OpenStrings: true,
		Strings: []string{
			"current_test",
		},
	}
}

// TestOutput Expect that a test uses &#x27;Say&#x27; to print some specific text.
type TestOutput struct {
	Lines string `if:"label=lines"`
}

func (*TestOutput) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_output",
		Lede: "output ",
	}
}

// TestRule
type TestRule struct {
	TestName TestName    `if:"label=test_name"`
	Hook     ProgramHook `if:"label=do"`
}

func (*TestRule) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_rule",
		Lede: "To test ",
	}
}

// TestScene
type TestScene struct {
	TestName TestName `if:"label=test_name"`
	Story    Story    `if:"label=story"`
}

func (*TestScene) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_scene",
		Lede: "While testing ",
	}
}

// TestStatement
type TestStatement struct {
	TestName TestName `if:"label=test_name"`
	Test     Testing  `if:"label=expectation"`
}

func (*TestStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_statement",
		Lede: "Expect ",
	}
}

// TextListType requires a user-specified string.
type TextListType string

func (*TextListType) Choices() (choices map[string]string) {
	return map[string]string{
		"$LIST": "list",
	}
}

func (*TextListType) Compose() composer.Spec {
	return composer.Spec{
		Name: "text_list_type",
		Strings: []string{
			"list",
		},
	}
}

// TraitPhrase
type TraitPhrase struct {
	AreEither bool     `if:"label=are_either"`
	Trait     []string `if:"label=trait"`
}

func (*TraitPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: "trait_phrase",
	}
}

// VariableDecl
type VariableDecl struct {
	An      Determiner   `if:"label=an"`
	Name    string       `if:"label=name"`
	Type    VariableType `if:"label=type"`
	Comment string       `if:"label=comment,optional"`
}

func (*VariableDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "variable_decl",
	}
}

// VariableType swaps between various options
type VariableType struct {
	Opt interface{}
}

func (*VariableType) Compose() composer.Spec {
	return composer.Spec{
		Name: "variable_type",
		Lede: "a ",
	}
}

func (*VariableType) Choices() map[string]interface{} {
	return map[string]interface{}{
		"primitive": (*PrimitiveType)(nil),
		"object":    (*ObjectType)(nil),
		"ext":       (*ExtType)(nil),
	}
}

var Slots = []interface{}{
	(*StoryStatement)(nil),
	(*Testing)(nil),
}
var Swaps = []interface{}{
	(*ActionParams)(nil),
	(*EventTarget)(nil),
	(*ExtType)(nil),
	(*NounPhrase)(nil),
	(*PrimitiveValue)(nil),
	(*ProgramHook)(nil),
	(*PropertyType)(nil),
	(*RelationCardinality)(nil),
	(*VariableType)(nil),
}
var Flows = []interface{}{
	(*ActionContext)(nil),
	(*ActionDecl)(nil),
	(*AspectTraits)(nil),
	(*BoxedNumber)(nil),
	(*BoxedText)(nil),
	(*Certainties)(nil),
	(*Comment)(nil),
	(*CommonAction)(nil),
	(*EventBlock)(nil),
	(*EventHandler)(nil),
	(*KindOfNoun)(nil),
	(*KindOfRelation)(nil),
	(*KindsOfAspect)(nil),
	(*KindsOfKind)(nil),
	(*KindsOfRecord)(nil),
	(*KindsPossessProperties)(nil),
	(*Lede)(nil),
	(*LocalDecl)(nil),
	(*LocalInit)(nil),
	(*ManyToMany)(nil),
	(*ManyToOne)(nil),
	(*NamedNoun)(nil),
	(*NounAssignment)(nil),
	(*NounRelation)(nil),
	(*NounStatement)(nil),
	(*NounTraits)(nil),
	(*ObjectType)(nil),
	(*OneToMany)(nil),
	(*OneToOne)(nil),
	(*PairedAction)(nil),
	(*Paragraph)(nil),
	(*PatternActions)(nil),
	(*PatternDecl)(nil),
	(*PatternLocals)(nil),
	(*PatternReturn)(nil),
	(*PatternRule)(nil),
	(*PatternRules)(nil),
	(*PatternVariablesDecl)(nil),
	(*PatternVariablesTail)(nil),
	(*PropertyDecl)(nil),
	(*RecordListType)(nil),
	(*RecordType)(nil),
	(*RecordsPossessProperties)(nil),
	(*RelativeToNoun)(nil),
	(*Story)(nil),
	(*Summary)(nil),
	(*Tail)(nil),
	(*TestOutput)(nil),
	(*TestRule)(nil),
	(*TestScene)(nil),
	(*TestStatement)(nil),
	(*TraitPhrase)(nil),
	(*VariableDecl)(nil),
}
