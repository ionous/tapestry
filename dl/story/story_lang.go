// Code generated by "makeops"; edit at your own risk.
package story

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/grammar"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/jsn"
	"git.sr.ht/~ionous/tapestry/rt"
	"github.com/ionous/errutil"
)

// AspectField
type AspectField struct {
	Aspect string `if:"label=_,type=text"`
	Markup map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*AspectField)(nil)

func (*AspectField) Compose() composer.Spec {
	return composer.Spec{
		Name: AspectField_Type,
		Uses: composer.Type_Flow,
		Lede: "aspect",
	}
}

const AspectField_Type = "aspect_field"
const AspectField_Field_Aspect = "$ASPECT"

func (op *AspectField) Marshal(m jsn.Marshaler) error {
	return AspectField_Marshal(m, op)
}

type AspectField_Slice []AspectField

func (op *AspectField_Slice) GetType() string { return AspectField_Type }

func (op *AspectField_Slice) Marshal(m jsn.Marshaler) error {
	return AspectField_Repeats_Marshal(m, (*[]AspectField)(op))
}

func (op *AspectField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *AspectField_Slice) SetSize(cnt int) {
	var els []AspectField
	if cnt >= 0 {
		els = make(AspectField_Slice, cnt)
	}
	(*op) = els
}

func (op *AspectField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return AspectField_Marshal(m, &(*op)[i])
}

func AspectField_Repeats_Marshal(m jsn.Marshaler, vals *[]AspectField) error {
	return jsn.RepeatBlock(m, (*AspectField_Slice)(vals))
}

func AspectField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]AspectField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = AspectField_Repeats_Marshal(m, pv)
	}
	return
}

type AspectField_Flow struct{ ptr *AspectField }

func (n AspectField_Flow) GetType() string      { return AspectField_Type }
func (n AspectField_Flow) GetLede() string      { return "aspect" }
func (n AspectField_Flow) GetFlow() interface{} { return n.ptr }
func (n AspectField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*AspectField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func AspectField_Optional_Marshal(m jsn.Marshaler, pv **AspectField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AspectField_Marshal(m, *pv)
	} else if !enc {
		var v AspectField
		if err = AspectField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AspectField_Marshal(m jsn.Marshaler, val *AspectField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(AspectField_Flow{val}); err == nil {
		e0 := m.MarshalKey("", AspectField_Field_Aspect)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Aspect)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AspectField_Field_Aspect))
		}
		m.EndBlock()
	}
	return
}

// BoolField
type BoolField struct {
	Name      string      `if:"label=_,type=text"`
	Type      string      `if:"label=kind,optional,type=text"`
	Initially rt.BoolEval `if:"label=initially,optional"`
	Markup    map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*BoolField)(nil)

func (*BoolField) Compose() composer.Spec {
	return composer.Spec{
		Name: BoolField_Type,
		Uses: composer.Type_Flow,
		Lede: "bool",
	}
}

const BoolField_Type = "bool_field"
const BoolField_Field_Name = "$NAME"
const BoolField_Field_Type = "$TYPE"
const BoolField_Field_Initially = "$INITIALLY"

func (op *BoolField) Marshal(m jsn.Marshaler) error {
	return BoolField_Marshal(m, op)
}

type BoolField_Slice []BoolField

func (op *BoolField_Slice) GetType() string { return BoolField_Type }

func (op *BoolField_Slice) Marshal(m jsn.Marshaler) error {
	return BoolField_Repeats_Marshal(m, (*[]BoolField)(op))
}

func (op *BoolField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *BoolField_Slice) SetSize(cnt int) {
	var els []BoolField
	if cnt >= 0 {
		els = make(BoolField_Slice, cnt)
	}
	(*op) = els
}

func (op *BoolField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return BoolField_Marshal(m, &(*op)[i])
}

func BoolField_Repeats_Marshal(m jsn.Marshaler, vals *[]BoolField) error {
	return jsn.RepeatBlock(m, (*BoolField_Slice)(vals))
}

func BoolField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]BoolField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = BoolField_Repeats_Marshal(m, pv)
	}
	return
}

type BoolField_Flow struct{ ptr *BoolField }

func (n BoolField_Flow) GetType() string      { return BoolField_Type }
func (n BoolField_Flow) GetLede() string      { return "bool" }
func (n BoolField_Flow) GetFlow() interface{} { return n.ptr }
func (n BoolField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*BoolField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func BoolField_Optional_Marshal(m jsn.Marshaler, pv **BoolField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = BoolField_Marshal(m, *pv)
	} else if !enc {
		var v BoolField
		if err = BoolField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func BoolField_Marshal(m jsn.Marshaler, val *BoolField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(BoolField_Flow{val}); err == nil {
		e0 := m.MarshalKey("", BoolField_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", BoolField_Field_Name))
		}
		e1 := m.MarshalKey("kind", BoolField_Field_Type)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Optional_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", BoolField_Field_Type))
		}
		e2 := m.MarshalKey("initially", BoolField_Field_Initially)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Initially)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", BoolField_Field_Initially))
		}
		m.EndBlock()
	}
	return
}

// CallMacro Executes a macro, and potentially returns a value.
type CallMacro struct {
	MacroName string       `if:"label=macro,type=text"`
	Arguments []assign.Arg `if:"label=args"`
	Markup    map[string]any
}

// User implemented slots:
var _ rt.Execute = (*CallMacro)(nil)
var _ rt.BoolEval = (*CallMacro)(nil)
var _ rt.NumberEval = (*CallMacro)(nil)
var _ rt.TextEval = (*CallMacro)(nil)
var _ rt.RecordEval = (*CallMacro)(nil)
var _ rt.NumListEval = (*CallMacro)(nil)
var _ rt.TextListEval = (*CallMacro)(nil)
var _ rt.RecordListEval = (*CallMacro)(nil)
var _ StoryStatement = (*CallMacro)(nil)

func (*CallMacro) Compose() composer.Spec {
	return composer.Spec{
		Name: CallMacro_Type,
		Uses: composer.Type_Flow,
		Lede: "call",
	}
}

const CallMacro_Type = "call_macro"
const CallMacro_Field_MacroName = "$MACRO_NAME"
const CallMacro_Field_Arguments = "$ARGUMENTS"

func (op *CallMacro) Marshal(m jsn.Marshaler) error {
	return CallMacro_Marshal(m, op)
}

type CallMacro_Slice []CallMacro

func (op *CallMacro_Slice) GetType() string { return CallMacro_Type }

func (op *CallMacro_Slice) Marshal(m jsn.Marshaler) error {
	return CallMacro_Repeats_Marshal(m, (*[]CallMacro)(op))
}

func (op *CallMacro_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *CallMacro_Slice) SetSize(cnt int) {
	var els []CallMacro
	if cnt >= 0 {
		els = make(CallMacro_Slice, cnt)
	}
	(*op) = els
}

func (op *CallMacro_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return CallMacro_Marshal(m, &(*op)[i])
}

func CallMacro_Repeats_Marshal(m jsn.Marshaler, vals *[]CallMacro) error {
	return jsn.RepeatBlock(m, (*CallMacro_Slice)(vals))
}

func CallMacro_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]CallMacro) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = CallMacro_Repeats_Marshal(m, pv)
	}
	return
}

type CallMacro_Flow struct{ ptr *CallMacro }

func (n CallMacro_Flow) GetType() string      { return CallMacro_Type }
func (n CallMacro_Flow) GetLede() string      { return "call" }
func (n CallMacro_Flow) GetFlow() interface{} { return n.ptr }
func (n CallMacro_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*CallMacro); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func CallMacro_Optional_Marshal(m jsn.Marshaler, pv **CallMacro) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = CallMacro_Marshal(m, *pv)
	} else if !enc {
		var v CallMacro
		if err = CallMacro_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func CallMacro_Marshal(m jsn.Marshaler, val *CallMacro) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(CallMacro_Flow{val}); err == nil {
		e0 := m.MarshalKey("macro", CallMacro_Field_MacroName)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.MacroName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", CallMacro_Field_MacroName))
		}
		e1 := m.MarshalKey("args", CallMacro_Field_Arguments)
		if e1 == nil {
			e1 = assign.Arg_Repeats_Marshal(m, &val.Arguments)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", CallMacro_Field_Arguments))
		}
		m.EndBlock()
	}
	return
}

// Comment Add a note.
// Information about the story for you and other authors.
type Comment struct {
	Lines  prim.Lines `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ StoryStatement = (*Comment)(nil)
var _ rt.Execute = (*Comment)(nil)

func (*Comment) Compose() composer.Spec {
	return composer.Spec{
		Name: Comment_Type,
		Uses: composer.Type_Flow,
	}
}

const Comment_Type = "comment"
const Comment_Field_Lines = "$LINES"

func (op *Comment) Marshal(m jsn.Marshaler) error {
	return Comment_Marshal(m, op)
}

type Comment_Slice []Comment

func (op *Comment_Slice) GetType() string { return Comment_Type }

func (op *Comment_Slice) Marshal(m jsn.Marshaler) error {
	return Comment_Repeats_Marshal(m, (*[]Comment)(op))
}

func (op *Comment_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Comment_Slice) SetSize(cnt int) {
	var els []Comment
	if cnt >= 0 {
		els = make(Comment_Slice, cnt)
	}
	(*op) = els
}

func (op *Comment_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Comment_Marshal(m, &(*op)[i])
}

func Comment_Repeats_Marshal(m jsn.Marshaler, vals *[]Comment) error {
	return jsn.RepeatBlock(m, (*Comment_Slice)(vals))
}

func Comment_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Comment) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Comment_Repeats_Marshal(m, pv)
	}
	return
}

type Comment_Flow struct{ ptr *Comment }

func (n Comment_Flow) GetType() string      { return Comment_Type }
func (n Comment_Flow) GetLede() string      { return Comment_Type }
func (n Comment_Flow) GetFlow() interface{} { return n.ptr }
func (n Comment_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Comment); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Comment_Optional_Marshal(m jsn.Marshaler, pv **Comment) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Comment_Marshal(m, *pv)
	} else if !enc {
		var v Comment
		if err = Comment_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Comment_Marshal(m jsn.Marshaler, val *Comment) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Comment_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Comment_Field_Lines)
		if e0 == nil {
			e0 = prim.Lines_Marshal(m, &val.Lines)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Comment_Field_Lines))
		}
		m.EndBlock()
	}
	return
}

// CountOf A guard which returns true based on a counter.
// Counters start at zero and are incremented every time the guard gets checked.
type CountOf struct {
	Trigger core.Trigger  `if:"label=_"`
	Num     rt.NumberEval `if:"label=num"`
	Markup  map[string]any
}

// User implemented slots:
var _ rt.BoolEval = (*CountOf)(nil)

func (*CountOf) Compose() composer.Spec {
	return composer.Spec{
		Name: CountOf_Type,
		Uses: composer.Type_Flow,
	}
}

const CountOf_Type = "count_of"
const CountOf_Field_Trigger = "$TRIGGER"
const CountOf_Field_Num = "$NUM"

func (op *CountOf) Marshal(m jsn.Marshaler) error {
	return CountOf_Marshal(m, op)
}

type CountOf_Slice []CountOf

func (op *CountOf_Slice) GetType() string { return CountOf_Type }

func (op *CountOf_Slice) Marshal(m jsn.Marshaler) error {
	return CountOf_Repeats_Marshal(m, (*[]CountOf)(op))
}

func (op *CountOf_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *CountOf_Slice) SetSize(cnt int) {
	var els []CountOf
	if cnt >= 0 {
		els = make(CountOf_Slice, cnt)
	}
	(*op) = els
}

func (op *CountOf_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return CountOf_Marshal(m, &(*op)[i])
}

func CountOf_Repeats_Marshal(m jsn.Marshaler, vals *[]CountOf) error {
	return jsn.RepeatBlock(m, (*CountOf_Slice)(vals))
}

func CountOf_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]CountOf) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = CountOf_Repeats_Marshal(m, pv)
	}
	return
}

type CountOf_Flow struct{ ptr *CountOf }

func (n CountOf_Flow) GetType() string      { return CountOf_Type }
func (n CountOf_Flow) GetLede() string      { return CountOf_Type }
func (n CountOf_Flow) GetFlow() interface{} { return n.ptr }
func (n CountOf_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*CountOf); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func CountOf_Optional_Marshal(m jsn.Marshaler, pv **CountOf) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = CountOf_Marshal(m, *pv)
	} else if !enc {
		var v CountOf
		if err = CountOf_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func CountOf_Marshal(m jsn.Marshaler, val *CountOf) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(CountOf_Flow{val}); err == nil {
		e0 := m.MarshalKey("", CountOf_Field_Trigger)
		if e0 == nil {
			e0 = core.Trigger_Marshal(m, &val.Trigger)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", CountOf_Field_Trigger))
		}
		e1 := m.MarshalKey("num", CountOf_Field_Num)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Num)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", CountOf_Field_Num))
		}
		m.EndBlock()
	}
	return
}

// CycleText When called multiple times, returns each of its inputs in turn.
type CycleText struct {
	Parts  []rt.TextEval `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.TextEval = (*CycleText)(nil)

func (*CycleText) Compose() composer.Spec {
	return composer.Spec{
		Name: CycleText_Type,
		Uses: composer.Type_Flow,
	}
}

const CycleText_Type = "cycle_text"
const CycleText_Field_Parts = "$PARTS"

func (op *CycleText) Marshal(m jsn.Marshaler) error {
	return CycleText_Marshal(m, op)
}

type CycleText_Slice []CycleText

func (op *CycleText_Slice) GetType() string { return CycleText_Type }

func (op *CycleText_Slice) Marshal(m jsn.Marshaler) error {
	return CycleText_Repeats_Marshal(m, (*[]CycleText)(op))
}

func (op *CycleText_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *CycleText_Slice) SetSize(cnt int) {
	var els []CycleText
	if cnt >= 0 {
		els = make(CycleText_Slice, cnt)
	}
	(*op) = els
}

func (op *CycleText_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return CycleText_Marshal(m, &(*op)[i])
}

func CycleText_Repeats_Marshal(m jsn.Marshaler, vals *[]CycleText) error {
	return jsn.RepeatBlock(m, (*CycleText_Slice)(vals))
}

func CycleText_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]CycleText) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = CycleText_Repeats_Marshal(m, pv)
	}
	return
}

type CycleText_Flow struct{ ptr *CycleText }

func (n CycleText_Flow) GetType() string      { return CycleText_Type }
func (n CycleText_Flow) GetLede() string      { return CycleText_Type }
func (n CycleText_Flow) GetFlow() interface{} { return n.ptr }
func (n CycleText_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*CycleText); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func CycleText_Optional_Marshal(m jsn.Marshaler, pv **CycleText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = CycleText_Marshal(m, *pv)
	} else if !enc {
		var v CycleText
		if err = CycleText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func CycleText_Marshal(m jsn.Marshaler, val *CycleText) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(CycleText_Flow{val}); err == nil {
		e0 := m.MarshalKey("", CycleText_Field_Parts)
		if e0 == nil {
			e0 = rt.TextEval_Repeats_Marshal(m, &val.Parts)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", CycleText_Field_Parts))
		}
		m.EndBlock()
	}
	return
}

// DeclareStatement Simple english like definitions of nouns, kinds, and their relatives.
type DeclareStatement struct {
	Text   rt.TextEval `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DeclareStatement)(nil)

func (*DeclareStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: DeclareStatement_Type,
		Uses: composer.Type_Flow,
		Lede: "declare",
	}
}

const DeclareStatement_Type = "declare_statement"
const DeclareStatement_Field_Text = "$TEXT"

func (op *DeclareStatement) Marshal(m jsn.Marshaler) error {
	return DeclareStatement_Marshal(m, op)
}

type DeclareStatement_Slice []DeclareStatement

func (op *DeclareStatement_Slice) GetType() string { return DeclareStatement_Type }

func (op *DeclareStatement_Slice) Marshal(m jsn.Marshaler) error {
	return DeclareStatement_Repeats_Marshal(m, (*[]DeclareStatement)(op))
}

func (op *DeclareStatement_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DeclareStatement_Slice) SetSize(cnt int) {
	var els []DeclareStatement
	if cnt >= 0 {
		els = make(DeclareStatement_Slice, cnt)
	}
	(*op) = els
}

func (op *DeclareStatement_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DeclareStatement_Marshal(m, &(*op)[i])
}

func DeclareStatement_Repeats_Marshal(m jsn.Marshaler, vals *[]DeclareStatement) error {
	return jsn.RepeatBlock(m, (*DeclareStatement_Slice)(vals))
}

func DeclareStatement_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DeclareStatement) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DeclareStatement_Repeats_Marshal(m, pv)
	}
	return
}

type DeclareStatement_Flow struct{ ptr *DeclareStatement }

func (n DeclareStatement_Flow) GetType() string      { return DeclareStatement_Type }
func (n DeclareStatement_Flow) GetLede() string      { return "declare" }
func (n DeclareStatement_Flow) GetFlow() interface{} { return n.ptr }
func (n DeclareStatement_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DeclareStatement); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DeclareStatement_Optional_Marshal(m jsn.Marshaler, pv **DeclareStatement) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DeclareStatement_Marshal(m, *pv)
	} else if !enc {
		var v DeclareStatement
		if err = DeclareStatement_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DeclareStatement_Marshal(m jsn.Marshaler, val *DeclareStatement) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DeclareStatement_Flow{val}); err == nil {
		e0 := m.MarshalKey("", DeclareStatement_Field_Text)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Text)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DeclareStatement_Field_Text))
		}
		m.EndBlock()
	}
	return
}

// DefineAction Declare an activity: Activities help actors perform tasks: for instance, picking up or dropping items.  Activities involve either the player or an npc and possibly one or two other objects.
type DefineAction struct {
	Action rt.TextEval       `if:"label=action"`
	Params []FieldDefinition `if:"label=requires"`
	Locals []FieldDefinition `if:"label=provides,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineAction)(nil)
var _ rt.Execute = (*DefineAction)(nil)

func (*DefineAction) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineAction_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineAction_Type = "define_action"
const DefineAction_Field_Action = "$ACTION"
const DefineAction_Field_Params = "$PARAMS"
const DefineAction_Field_Locals = "$LOCALS"

func (op *DefineAction) Marshal(m jsn.Marshaler) error {
	return DefineAction_Marshal(m, op)
}

type DefineAction_Slice []DefineAction

func (op *DefineAction_Slice) GetType() string { return DefineAction_Type }

func (op *DefineAction_Slice) Marshal(m jsn.Marshaler) error {
	return DefineAction_Repeats_Marshal(m, (*[]DefineAction)(op))
}

func (op *DefineAction_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineAction_Slice) SetSize(cnt int) {
	var els []DefineAction
	if cnt >= 0 {
		els = make(DefineAction_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineAction_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineAction_Marshal(m, &(*op)[i])
}

func DefineAction_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineAction) error {
	return jsn.RepeatBlock(m, (*DefineAction_Slice)(vals))
}

func DefineAction_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineAction) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineAction_Repeats_Marshal(m, pv)
	}
	return
}

type DefineAction_Flow struct{ ptr *DefineAction }

func (n DefineAction_Flow) GetType() string      { return DefineAction_Type }
func (n DefineAction_Flow) GetLede() string      { return "define" }
func (n DefineAction_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineAction_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineAction); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineAction_Optional_Marshal(m jsn.Marshaler, pv **DefineAction) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineAction_Marshal(m, *pv)
	} else if !enc {
		var v DefineAction
		if err = DefineAction_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineAction_Marshal(m jsn.Marshaler, val *DefineAction) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineAction_Flow{val}); err == nil {
		e0 := m.MarshalKey("action", DefineAction_Field_Action)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Action)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineAction_Field_Action))
		}
		e1 := m.MarshalKey("requires", DefineAction_Field_Params)
		if e1 == nil {
			e1 = FieldDefinition_Repeats_Marshal(m, &val.Params)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineAction_Field_Params))
		}
		e2 := m.MarshalKey("provides", DefineAction_Field_Locals)
		if e2 == nil {
			e2 = FieldDefinition_Optional_Repeats_Marshal(m, &val.Locals)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefineAction_Field_Locals))
		}
		m.EndBlock()
	}
	return
}

// DefineFields Add properties to a kind
type DefineFields struct {
	Kind   rt.TextEval       `if:"label=kind"`
	Fields []FieldDefinition `if:"label=fields"`
	Markup map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineFields)(nil)
var _ rt.Execute = (*DefineFields)(nil)

func (*DefineFields) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineFields_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineFields_Type = "define_fields"
const DefineFields_Field_Kind = "$KIND"
const DefineFields_Field_Fields = "$FIELDS"

func (op *DefineFields) Marshal(m jsn.Marshaler) error {
	return DefineFields_Marshal(m, op)
}

type DefineFields_Slice []DefineFields

func (op *DefineFields_Slice) GetType() string { return DefineFields_Type }

func (op *DefineFields_Slice) Marshal(m jsn.Marshaler) error {
	return DefineFields_Repeats_Marshal(m, (*[]DefineFields)(op))
}

func (op *DefineFields_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineFields_Slice) SetSize(cnt int) {
	var els []DefineFields
	if cnt >= 0 {
		els = make(DefineFields_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineFields_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineFields_Marshal(m, &(*op)[i])
}

func DefineFields_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineFields) error {
	return jsn.RepeatBlock(m, (*DefineFields_Slice)(vals))
}

func DefineFields_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineFields) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineFields_Repeats_Marshal(m, pv)
	}
	return
}

type DefineFields_Flow struct{ ptr *DefineFields }

func (n DefineFields_Flow) GetType() string      { return DefineFields_Type }
func (n DefineFields_Flow) GetLede() string      { return "define" }
func (n DefineFields_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineFields_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineFields); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineFields_Optional_Marshal(m jsn.Marshaler, pv **DefineFields) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineFields_Marshal(m, *pv)
	} else if !enc {
		var v DefineFields
		if err = DefineFields_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineFields_Marshal(m jsn.Marshaler, val *DefineFields) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineFields_Flow{val}); err == nil {
		e0 := m.MarshalKey("kind", DefineFields_Field_Kind)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Kind)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineFields_Field_Kind))
		}
		e1 := m.MarshalKey("fields", DefineFields_Field_Fields)
		if e1 == nil {
			e1 = FieldDefinition_Repeats_Marshal(m, &val.Fields)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineFields_Field_Fields))
		}
		m.EndBlock()
	}
	return
}

// DefineKinds
type DefineKinds struct {
	Kinds    rt.TextListEval `if:"label=kinds"`
	Ancestor rt.TextEval     `if:"label=as"`
	Markup   map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineKinds)(nil)
var _ rt.Execute = (*DefineKinds)(nil)

func (*DefineKinds) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineKinds_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineKinds_Type = "define_kinds"
const DefineKinds_Field_Kinds = "$KINDS"
const DefineKinds_Field_Ancestor = "$ANCESTOR"

func (op *DefineKinds) Marshal(m jsn.Marshaler) error {
	return DefineKinds_Marshal(m, op)
}

type DefineKinds_Slice []DefineKinds

func (op *DefineKinds_Slice) GetType() string { return DefineKinds_Type }

func (op *DefineKinds_Slice) Marshal(m jsn.Marshaler) error {
	return DefineKinds_Repeats_Marshal(m, (*[]DefineKinds)(op))
}

func (op *DefineKinds_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineKinds_Slice) SetSize(cnt int) {
	var els []DefineKinds
	if cnt >= 0 {
		els = make(DefineKinds_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineKinds_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineKinds_Marshal(m, &(*op)[i])
}

func DefineKinds_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineKinds) error {
	return jsn.RepeatBlock(m, (*DefineKinds_Slice)(vals))
}

func DefineKinds_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineKinds) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineKinds_Repeats_Marshal(m, pv)
	}
	return
}

type DefineKinds_Flow struct{ ptr *DefineKinds }

func (n DefineKinds_Flow) GetType() string      { return DefineKinds_Type }
func (n DefineKinds_Flow) GetLede() string      { return "define" }
func (n DefineKinds_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineKinds_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineKinds); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineKinds_Optional_Marshal(m jsn.Marshaler, pv **DefineKinds) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineKinds_Marshal(m, *pv)
	} else if !enc {
		var v DefineKinds
		if err = DefineKinds_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineKinds_Marshal(m jsn.Marshaler, val *DefineKinds) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineKinds_Flow{val}); err == nil {
		e0 := m.MarshalKey("kinds", DefineKinds_Field_Kinds)
		if e0 == nil {
			e0 = rt.TextListEval_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineKinds_Field_Kinds))
		}
		e1 := m.MarshalKey("as", DefineKinds_Field_Ancestor)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Ancestor)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineKinds_Field_Ancestor))
		}
		m.EndBlock()
	}
	return
}

// DefineMacro Declare a function which can produce statements about the game world.
// They are processed at import time, and they cannot call patterns
// nor can patterns -- which are processed during play -- call macros.
// Unlike patterns, they cannot be extended; the entire definition must live in one place.
type DefineMacro struct {
	MacroName       rt.TextEval       `if:"label=macro"`
	Params          []FieldDefinition `if:"label=requires"`
	Result          FieldDefinition   `if:"label=result"`
	Locals          []FieldDefinition `if:"label=provides,optional"`
	MacroStatements []rt.Execute      `if:"label=with"`
	Markup          map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineMacro)(nil)
var _ rt.Execute = (*DefineMacro)(nil)

func (*DefineMacro) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineMacro_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineMacro_Type = "define_macro"
const DefineMacro_Field_MacroName = "$MACRO_NAME"
const DefineMacro_Field_Params = "$PARAMS"
const DefineMacro_Field_Result = "$RESULT"
const DefineMacro_Field_Locals = "$LOCALS"
const DefineMacro_Field_MacroStatements = "$MACRO_STATEMENTS"

func (op *DefineMacro) Marshal(m jsn.Marshaler) error {
	return DefineMacro_Marshal(m, op)
}

type DefineMacro_Slice []DefineMacro

func (op *DefineMacro_Slice) GetType() string { return DefineMacro_Type }

func (op *DefineMacro_Slice) Marshal(m jsn.Marshaler) error {
	return DefineMacro_Repeats_Marshal(m, (*[]DefineMacro)(op))
}

func (op *DefineMacro_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineMacro_Slice) SetSize(cnt int) {
	var els []DefineMacro
	if cnt >= 0 {
		els = make(DefineMacro_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineMacro_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineMacro_Marshal(m, &(*op)[i])
}

func DefineMacro_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineMacro) error {
	return jsn.RepeatBlock(m, (*DefineMacro_Slice)(vals))
}

func DefineMacro_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineMacro) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineMacro_Repeats_Marshal(m, pv)
	}
	return
}

type DefineMacro_Flow struct{ ptr *DefineMacro }

func (n DefineMacro_Flow) GetType() string      { return DefineMacro_Type }
func (n DefineMacro_Flow) GetLede() string      { return "define" }
func (n DefineMacro_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineMacro_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineMacro); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineMacro_Optional_Marshal(m jsn.Marshaler, pv **DefineMacro) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineMacro_Marshal(m, *pv)
	} else if !enc {
		var v DefineMacro
		if err = DefineMacro_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineMacro_Marshal(m jsn.Marshaler, val *DefineMacro) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineMacro_Flow{val}); err == nil {
		e0 := m.MarshalKey("macro", DefineMacro_Field_MacroName)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.MacroName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineMacro_Field_MacroName))
		}
		e1 := m.MarshalKey("requires", DefineMacro_Field_Params)
		if e1 == nil {
			e1 = FieldDefinition_Repeats_Marshal(m, &val.Params)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineMacro_Field_Params))
		}
		e2 := m.MarshalKey("result", DefineMacro_Field_Result)
		if e2 == nil {
			e2 = FieldDefinition_Marshal(m, &val.Result)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefineMacro_Field_Result))
		}
		e3 := m.MarshalKey("provides", DefineMacro_Field_Locals)
		if e3 == nil {
			e3 = FieldDefinition_Optional_Repeats_Marshal(m, &val.Locals)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", DefineMacro_Field_Locals))
		}
		e4 := m.MarshalKey("with", DefineMacro_Field_MacroStatements)
		if e4 == nil {
			e4 = rt.Execute_Repeats_Marshal(m, &val.MacroStatements)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", DefineMacro_Field_MacroStatements))
		}
		m.EndBlock()
	}
	return
}

// DefineNounTraits
type DefineNounTraits struct {
	Nouns  rt.TextListEval `if:"label=nouns"`
	Kind   rt.TextEval     `if:"label=as,optional"`
	Traits rt.TextListEval `if:"label=traits"`
	Markup map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineNounTraits)(nil)
var _ rt.Execute = (*DefineNounTraits)(nil)

func (*DefineNounTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineNounTraits_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineNounTraits_Type = "define_noun_traits"
const DefineNounTraits_Field_Nouns = "$NOUNS"
const DefineNounTraits_Field_Kind = "$KIND"
const DefineNounTraits_Field_Traits = "$TRAITS"

func (op *DefineNounTraits) Marshal(m jsn.Marshaler) error {
	return DefineNounTraits_Marshal(m, op)
}

type DefineNounTraits_Slice []DefineNounTraits

func (op *DefineNounTraits_Slice) GetType() string { return DefineNounTraits_Type }

func (op *DefineNounTraits_Slice) Marshal(m jsn.Marshaler) error {
	return DefineNounTraits_Repeats_Marshal(m, (*[]DefineNounTraits)(op))
}

func (op *DefineNounTraits_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineNounTraits_Slice) SetSize(cnt int) {
	var els []DefineNounTraits
	if cnt >= 0 {
		els = make(DefineNounTraits_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineNounTraits_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineNounTraits_Marshal(m, &(*op)[i])
}

func DefineNounTraits_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineNounTraits) error {
	return jsn.RepeatBlock(m, (*DefineNounTraits_Slice)(vals))
}

func DefineNounTraits_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineNounTraits) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineNounTraits_Repeats_Marshal(m, pv)
	}
	return
}

type DefineNounTraits_Flow struct{ ptr *DefineNounTraits }

func (n DefineNounTraits_Flow) GetType() string      { return DefineNounTraits_Type }
func (n DefineNounTraits_Flow) GetLede() string      { return "define" }
func (n DefineNounTraits_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineNounTraits_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineNounTraits); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineNounTraits_Optional_Marshal(m jsn.Marshaler, pv **DefineNounTraits) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineNounTraits_Marshal(m, *pv)
	} else if !enc {
		var v DefineNounTraits
		if err = DefineNounTraits_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineNounTraits_Marshal(m jsn.Marshaler, val *DefineNounTraits) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineNounTraits_Flow{val}); err == nil {
		e0 := m.MarshalKey("nouns", DefineNounTraits_Field_Nouns)
		if e0 == nil {
			e0 = rt.TextListEval_Marshal(m, &val.Nouns)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineNounTraits_Field_Nouns))
		}
		e1 := m.MarshalKey("as", DefineNounTraits_Field_Kind)
		if e1 == nil {
			e1 = rt.TextEval_Optional_Marshal(m, &val.Kind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineNounTraits_Field_Kind))
		}
		e2 := m.MarshalKey("traits", DefineNounTraits_Field_Traits)
		if e2 == nil {
			e2 = rt.TextListEval_Marshal(m, &val.Traits)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefineNounTraits_Field_Traits))
		}
		m.EndBlock()
	}
	return
}

// DefineNouns
type DefineNouns struct {
	Nouns  rt.TextListEval `if:"label=nouns"`
	Kind   rt.TextEval     `if:"label=as"`
	Markup map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineNouns)(nil)
var _ rt.Execute = (*DefineNouns)(nil)

func (*DefineNouns) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineNouns_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineNouns_Type = "define_nouns"
const DefineNouns_Field_Nouns = "$NOUNS"
const DefineNouns_Field_Kind = "$KIND"

func (op *DefineNouns) Marshal(m jsn.Marshaler) error {
	return DefineNouns_Marshal(m, op)
}

type DefineNouns_Slice []DefineNouns

func (op *DefineNouns_Slice) GetType() string { return DefineNouns_Type }

func (op *DefineNouns_Slice) Marshal(m jsn.Marshaler) error {
	return DefineNouns_Repeats_Marshal(m, (*[]DefineNouns)(op))
}

func (op *DefineNouns_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineNouns_Slice) SetSize(cnt int) {
	var els []DefineNouns
	if cnt >= 0 {
		els = make(DefineNouns_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineNouns_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineNouns_Marshal(m, &(*op)[i])
}

func DefineNouns_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineNouns) error {
	return jsn.RepeatBlock(m, (*DefineNouns_Slice)(vals))
}

func DefineNouns_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineNouns) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineNouns_Repeats_Marshal(m, pv)
	}
	return
}

type DefineNouns_Flow struct{ ptr *DefineNouns }

func (n DefineNouns_Flow) GetType() string      { return DefineNouns_Type }
func (n DefineNouns_Flow) GetLede() string      { return "define" }
func (n DefineNouns_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineNouns_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineNouns); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineNouns_Optional_Marshal(m jsn.Marshaler, pv **DefineNouns) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineNouns_Marshal(m, *pv)
	} else if !enc {
		var v DefineNouns
		if err = DefineNouns_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineNouns_Marshal(m jsn.Marshaler, val *DefineNouns) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineNouns_Flow{val}); err == nil {
		e0 := m.MarshalKey("nouns", DefineNouns_Field_Nouns)
		if e0 == nil {
			e0 = rt.TextListEval_Marshal(m, &val.Nouns)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineNouns_Field_Nouns))
		}
		e1 := m.MarshalKey("as", DefineNouns_Field_Kind)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Kind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineNouns_Field_Kind))
		}
		m.EndBlock()
	}
	return
}

// DefineOtherRelatives Relate nouns to each other
type DefineOtherRelatives struct {
	Relation   rt.TextEval     `if:"label=relative_to"`
	Nouns      rt.TextListEval `if:"label=nouns"`
	OtherNouns rt.TextListEval `if:"label=other_nouns"`
	Markup     map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineOtherRelatives)(nil)
var _ rt.Execute = (*DefineOtherRelatives)(nil)

func (*DefineOtherRelatives) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineOtherRelatives_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineOtherRelatives_Type = "define_other_relatives"
const DefineOtherRelatives_Field_Relation = "$RELATION"
const DefineOtherRelatives_Field_Nouns = "$NOUNS"
const DefineOtherRelatives_Field_OtherNouns = "$OTHER_NOUNS"

func (op *DefineOtherRelatives) Marshal(m jsn.Marshaler) error {
	return DefineOtherRelatives_Marshal(m, op)
}

type DefineOtherRelatives_Slice []DefineOtherRelatives

func (op *DefineOtherRelatives_Slice) GetType() string { return DefineOtherRelatives_Type }

func (op *DefineOtherRelatives_Slice) Marshal(m jsn.Marshaler) error {
	return DefineOtherRelatives_Repeats_Marshal(m, (*[]DefineOtherRelatives)(op))
}

func (op *DefineOtherRelatives_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineOtherRelatives_Slice) SetSize(cnt int) {
	var els []DefineOtherRelatives
	if cnt >= 0 {
		els = make(DefineOtherRelatives_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineOtherRelatives_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineOtherRelatives_Marshal(m, &(*op)[i])
}

func DefineOtherRelatives_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineOtherRelatives) error {
	return jsn.RepeatBlock(m, (*DefineOtherRelatives_Slice)(vals))
}

func DefineOtherRelatives_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineOtherRelatives) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineOtherRelatives_Repeats_Marshal(m, pv)
	}
	return
}

type DefineOtherRelatives_Flow struct{ ptr *DefineOtherRelatives }

func (n DefineOtherRelatives_Flow) GetType() string      { return DefineOtherRelatives_Type }
func (n DefineOtherRelatives_Flow) GetLede() string      { return "define" }
func (n DefineOtherRelatives_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineOtherRelatives_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineOtherRelatives); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineOtherRelatives_Optional_Marshal(m jsn.Marshaler, pv **DefineOtherRelatives) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineOtherRelatives_Marshal(m, *pv)
	} else if !enc {
		var v DefineOtherRelatives
		if err = DefineOtherRelatives_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineOtherRelatives_Marshal(m jsn.Marshaler, val *DefineOtherRelatives) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineOtherRelatives_Flow{val}); err == nil {
		e0 := m.MarshalKey("relative_to", DefineOtherRelatives_Field_Relation)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Relation)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineOtherRelatives_Field_Relation))
		}
		e1 := m.MarshalKey("nouns", DefineOtherRelatives_Field_Nouns)
		if e1 == nil {
			e1 = rt.TextListEval_Marshal(m, &val.Nouns)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineOtherRelatives_Field_Nouns))
		}
		e2 := m.MarshalKey("other_nouns", DefineOtherRelatives_Field_OtherNouns)
		if e2 == nil {
			e2 = rt.TextListEval_Marshal(m, &val.OtherNouns)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefineOtherRelatives_Field_OtherNouns))
		}
		m.EndBlock()
	}
	return
}

// DefinePattern Declare a new pattern.
// A pattern is a bundle of functions which can either change the game world or provide information about it.
// Each function in a given pattern has "guards" which determine whether the function applies in a particular situation.
type DefinePattern struct {
	PatternName rt.TextEval       `if:"label=pattern"`
	Params      []FieldDefinition `if:"label=requires"`
	Result      FieldDefinition   `if:"label=result"`
	Locals      []FieldDefinition `if:"label=provides,optional"`
	Rules       []PatternRule     `if:"label=with_rules"`
	Markup      map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefinePattern)(nil)
var _ rt.Execute = (*DefinePattern)(nil)

func (*DefinePattern) Compose() composer.Spec {
	return composer.Spec{
		Name: DefinePattern_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefinePattern_Type = "define_pattern"
const DefinePattern_Field_PatternName = "$PATTERN_NAME"
const DefinePattern_Field_Params = "$PARAMS"
const DefinePattern_Field_Result = "$RESULT"
const DefinePattern_Field_Locals = "$LOCALS"
const DefinePattern_Field_Rules = "$RULES"

func (op *DefinePattern) Marshal(m jsn.Marshaler) error {
	return DefinePattern_Marshal(m, op)
}

type DefinePattern_Slice []DefinePattern

func (op *DefinePattern_Slice) GetType() string { return DefinePattern_Type }

func (op *DefinePattern_Slice) Marshal(m jsn.Marshaler) error {
	return DefinePattern_Repeats_Marshal(m, (*[]DefinePattern)(op))
}

func (op *DefinePattern_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefinePattern_Slice) SetSize(cnt int) {
	var els []DefinePattern
	if cnt >= 0 {
		els = make(DefinePattern_Slice, cnt)
	}
	(*op) = els
}

func (op *DefinePattern_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefinePattern_Marshal(m, &(*op)[i])
}

func DefinePattern_Repeats_Marshal(m jsn.Marshaler, vals *[]DefinePattern) error {
	return jsn.RepeatBlock(m, (*DefinePattern_Slice)(vals))
}

func DefinePattern_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefinePattern) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefinePattern_Repeats_Marshal(m, pv)
	}
	return
}

type DefinePattern_Flow struct{ ptr *DefinePattern }

func (n DefinePattern_Flow) GetType() string      { return DefinePattern_Type }
func (n DefinePattern_Flow) GetLede() string      { return "define" }
func (n DefinePattern_Flow) GetFlow() interface{} { return n.ptr }
func (n DefinePattern_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefinePattern); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefinePattern_Optional_Marshal(m jsn.Marshaler, pv **DefinePattern) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefinePattern_Marshal(m, *pv)
	} else if !enc {
		var v DefinePattern
		if err = DefinePattern_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefinePattern_Marshal(m jsn.Marshaler, val *DefinePattern) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefinePattern_Flow{val}); err == nil {
		e0 := m.MarshalKey("pattern", DefinePattern_Field_PatternName)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.PatternName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefinePattern_Field_PatternName))
		}
		e1 := m.MarshalKey("requires", DefinePattern_Field_Params)
		if e1 == nil {
			e1 = FieldDefinition_Repeats_Marshal(m, &val.Params)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefinePattern_Field_Params))
		}
		e2 := m.MarshalKey("result", DefinePattern_Field_Result)
		if e2 == nil {
			e2 = FieldDefinition_Marshal(m, &val.Result)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefinePattern_Field_Result))
		}
		e3 := m.MarshalKey("provides", DefinePattern_Field_Locals)
		if e3 == nil {
			e3 = FieldDefinition_Optional_Repeats_Marshal(m, &val.Locals)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", DefinePattern_Field_Locals))
		}
		e4 := m.MarshalKey("with_rules", DefinePattern_Field_Rules)
		if e4 == nil {
			e4 = PatternRule_Repeats_Marshal(m, &val.Rules)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", DefinePattern_Field_Rules))
		}
		m.EndBlock()
	}
	return
}

// DefinePhrase Define a phrase that can be used with 'natural language' statements.
type DefinePhrase struct {
	Phrase   rt.TextEval `if:"label=phrase"`
	Macro    rt.TextEval `if:"label=as_macro"`
	Reversed rt.BoolEval `if:"label=reversed,optional"`
	Markup   map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefinePhrase)(nil)

func (*DefinePhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: DefinePhrase_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefinePhrase_Type = "define_phrase"
const DefinePhrase_Field_Phrase = "$PHRASE"
const DefinePhrase_Field_Macro = "$MACRO"
const DefinePhrase_Field_Reversed = "$REVERSED"

func (op *DefinePhrase) Marshal(m jsn.Marshaler) error {
	return DefinePhrase_Marshal(m, op)
}

type DefinePhrase_Slice []DefinePhrase

func (op *DefinePhrase_Slice) GetType() string { return DefinePhrase_Type }

func (op *DefinePhrase_Slice) Marshal(m jsn.Marshaler) error {
	return DefinePhrase_Repeats_Marshal(m, (*[]DefinePhrase)(op))
}

func (op *DefinePhrase_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefinePhrase_Slice) SetSize(cnt int) {
	var els []DefinePhrase
	if cnt >= 0 {
		els = make(DefinePhrase_Slice, cnt)
	}
	(*op) = els
}

func (op *DefinePhrase_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefinePhrase_Marshal(m, &(*op)[i])
}

func DefinePhrase_Repeats_Marshal(m jsn.Marshaler, vals *[]DefinePhrase) error {
	return jsn.RepeatBlock(m, (*DefinePhrase_Slice)(vals))
}

func DefinePhrase_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefinePhrase) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefinePhrase_Repeats_Marshal(m, pv)
	}
	return
}

type DefinePhrase_Flow struct{ ptr *DefinePhrase }

func (n DefinePhrase_Flow) GetType() string      { return DefinePhrase_Type }
func (n DefinePhrase_Flow) GetLede() string      { return "define" }
func (n DefinePhrase_Flow) GetFlow() interface{} { return n.ptr }
func (n DefinePhrase_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefinePhrase); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefinePhrase_Optional_Marshal(m jsn.Marshaler, pv **DefinePhrase) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefinePhrase_Marshal(m, *pv)
	} else if !enc {
		var v DefinePhrase
		if err = DefinePhrase_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefinePhrase_Marshal(m jsn.Marshaler, val *DefinePhrase) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefinePhrase_Flow{val}); err == nil {
		e0 := m.MarshalKey("phrase", DefinePhrase_Field_Phrase)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Phrase)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefinePhrase_Field_Phrase))
		}
		e1 := m.MarshalKey("as_macro", DefinePhrase_Field_Macro)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Macro)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefinePhrase_Field_Macro))
		}
		e2 := m.MarshalKey("reversed", DefinePhrase_Field_Reversed)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Reversed)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefinePhrase_Field_Reversed))
		}
		m.EndBlock()
	}
	return
}

// DefineRelation
type DefineRelation struct {
	Relation    rt.TextEval         `if:"label=relation"`
	Cardinality RelationCardinality `if:"label=cardinality"`
	Markup      map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineRelation)(nil)
var _ rt.Execute = (*DefineRelation)(nil)

func (*DefineRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineRelation_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineRelation_Type = "define_relation"
const DefineRelation_Field_Relation = "$RELATION"
const DefineRelation_Field_Cardinality = "$CARDINALITY"

func (op *DefineRelation) Marshal(m jsn.Marshaler) error {
	return DefineRelation_Marshal(m, op)
}

type DefineRelation_Slice []DefineRelation

func (op *DefineRelation_Slice) GetType() string { return DefineRelation_Type }

func (op *DefineRelation_Slice) Marshal(m jsn.Marshaler) error {
	return DefineRelation_Repeats_Marshal(m, (*[]DefineRelation)(op))
}

func (op *DefineRelation_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineRelation_Slice) SetSize(cnt int) {
	var els []DefineRelation
	if cnt >= 0 {
		els = make(DefineRelation_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineRelation_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineRelation_Marshal(m, &(*op)[i])
}

func DefineRelation_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineRelation) error {
	return jsn.RepeatBlock(m, (*DefineRelation_Slice)(vals))
}

func DefineRelation_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineRelation) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineRelation_Repeats_Marshal(m, pv)
	}
	return
}

type DefineRelation_Flow struct{ ptr *DefineRelation }

func (n DefineRelation_Flow) GetType() string      { return DefineRelation_Type }
func (n DefineRelation_Flow) GetLede() string      { return "define" }
func (n DefineRelation_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineRelation_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineRelation); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineRelation_Optional_Marshal(m jsn.Marshaler, pv **DefineRelation) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineRelation_Marshal(m, *pv)
	} else if !enc {
		var v DefineRelation
		if err = DefineRelation_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineRelation_Marshal(m jsn.Marshaler, val *DefineRelation) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineRelation_Flow{val}); err == nil {
		e0 := m.MarshalKey("relation", DefineRelation_Field_Relation)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Relation)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineRelation_Field_Relation))
		}
		e1 := m.MarshalKey("cardinality", DefineRelation_Field_Cardinality)
		if e1 == nil {
			e1 = RelationCardinality_Marshal(m, &val.Cardinality)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineRelation_Field_Cardinality))
		}
		m.EndBlock()
	}
	return
}

// DefineRelatives Relate nouns to each other
type DefineRelatives struct {
	Nouns      rt.TextListEval `if:"label=nouns"`
	Relation   rt.TextEval     `if:"label=relative_to"`
	OtherNouns rt.TextListEval `if:"label=other_nouns"`
	Markup     map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineRelatives)(nil)
var _ rt.Execute = (*DefineRelatives)(nil)

func (*DefineRelatives) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineRelatives_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineRelatives_Type = "define_relatives"
const DefineRelatives_Field_Nouns = "$NOUNS"
const DefineRelatives_Field_Relation = "$RELATION"
const DefineRelatives_Field_OtherNouns = "$OTHER_NOUNS"

func (op *DefineRelatives) Marshal(m jsn.Marshaler) error {
	return DefineRelatives_Marshal(m, op)
}

type DefineRelatives_Slice []DefineRelatives

func (op *DefineRelatives_Slice) GetType() string { return DefineRelatives_Type }

func (op *DefineRelatives_Slice) Marshal(m jsn.Marshaler) error {
	return DefineRelatives_Repeats_Marshal(m, (*[]DefineRelatives)(op))
}

func (op *DefineRelatives_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineRelatives_Slice) SetSize(cnt int) {
	var els []DefineRelatives
	if cnt >= 0 {
		els = make(DefineRelatives_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineRelatives_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineRelatives_Marshal(m, &(*op)[i])
}

func DefineRelatives_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineRelatives) error {
	return jsn.RepeatBlock(m, (*DefineRelatives_Slice)(vals))
}

func DefineRelatives_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineRelatives) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineRelatives_Repeats_Marshal(m, pv)
	}
	return
}

type DefineRelatives_Flow struct{ ptr *DefineRelatives }

func (n DefineRelatives_Flow) GetType() string      { return DefineRelatives_Type }
func (n DefineRelatives_Flow) GetLede() string      { return "define" }
func (n DefineRelatives_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineRelatives_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineRelatives); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineRelatives_Optional_Marshal(m jsn.Marshaler, pv **DefineRelatives) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineRelatives_Marshal(m, *pv)
	} else if !enc {
		var v DefineRelatives
		if err = DefineRelatives_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineRelatives_Marshal(m jsn.Marshaler, val *DefineRelatives) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineRelatives_Flow{val}); err == nil {
		e0 := m.MarshalKey("nouns", DefineRelatives_Field_Nouns)
		if e0 == nil {
			e0 = rt.TextListEval_Marshal(m, &val.Nouns)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineRelatives_Field_Nouns))
		}
		e1 := m.MarshalKey("relative_to", DefineRelatives_Field_Relation)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Relation)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineRelatives_Field_Relation))
		}
		e2 := m.MarshalKey("other_nouns", DefineRelatives_Field_OtherNouns)
		if e2 == nil {
			e2 = rt.TextListEval_Marshal(m, &val.OtherNouns)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefineRelatives_Field_OtherNouns))
		}
		m.EndBlock()
	}
	return
}

// DefineScene Define a sub world.
type DefineScene struct {
	Scene     rt.TextEval      `if:"label=scene"`
	DependsOn rt.TextListEval  `if:"label=depends_on,optional"`
	With      []StoryStatement `if:"label=with"`
	Markup    map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineScene)(nil)

func (*DefineScene) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineScene_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineScene_Type = "define_scene"
const DefineScene_Field_Scene = "$SCENE"
const DefineScene_Field_DependsOn = "$DEPENDS_ON"
const DefineScene_Field_With = "$WITH"

func (op *DefineScene) Marshal(m jsn.Marshaler) error {
	return DefineScene_Marshal(m, op)
}

type DefineScene_Slice []DefineScene

func (op *DefineScene_Slice) GetType() string { return DefineScene_Type }

func (op *DefineScene_Slice) Marshal(m jsn.Marshaler) error {
	return DefineScene_Repeats_Marshal(m, (*[]DefineScene)(op))
}

func (op *DefineScene_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineScene_Slice) SetSize(cnt int) {
	var els []DefineScene
	if cnt >= 0 {
		els = make(DefineScene_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineScene_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineScene_Marshal(m, &(*op)[i])
}

func DefineScene_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineScene) error {
	return jsn.RepeatBlock(m, (*DefineScene_Slice)(vals))
}

func DefineScene_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineScene) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineScene_Repeats_Marshal(m, pv)
	}
	return
}

type DefineScene_Flow struct{ ptr *DefineScene }

func (n DefineScene_Flow) GetType() string      { return DefineScene_Type }
func (n DefineScene_Flow) GetLede() string      { return "define" }
func (n DefineScene_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineScene_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineScene); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineScene_Optional_Marshal(m jsn.Marshaler, pv **DefineScene) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineScene_Marshal(m, *pv)
	} else if !enc {
		var v DefineScene
		if err = DefineScene_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineScene_Marshal(m jsn.Marshaler, val *DefineScene) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineScene_Flow{val}); err == nil {
		e0 := m.MarshalKey("scene", DefineScene_Field_Scene)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Scene)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineScene_Field_Scene))
		}
		e1 := m.MarshalKey("depends_on", DefineScene_Field_DependsOn)
		if e1 == nil {
			e1 = rt.TextListEval_Optional_Marshal(m, &val.DependsOn)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineScene_Field_DependsOn))
		}
		e2 := m.MarshalKey("with", DefineScene_Field_With)
		if e2 == nil {
			e2 = StoryStatement_Repeats_Marshal(m, &val.With)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefineScene_Field_With))
		}
		m.EndBlock()
	}
	return
}

// DefineTraits Add traits to an aspect
type DefineTraits struct {
	Traits rt.TextListEval `if:"label=traits"`
	Aspect rt.TextEval     `if:"label=as"`
	Markup map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineTraits)(nil)
var _ rt.Execute = (*DefineTraits)(nil)

func (*DefineTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineTraits_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineTraits_Type = "define_traits"
const DefineTraits_Field_Traits = "$TRAITS"
const DefineTraits_Field_Aspect = "$ASPECT"

func (op *DefineTraits) Marshal(m jsn.Marshaler) error {
	return DefineTraits_Marshal(m, op)
}

type DefineTraits_Slice []DefineTraits

func (op *DefineTraits_Slice) GetType() string { return DefineTraits_Type }

func (op *DefineTraits_Slice) Marshal(m jsn.Marshaler) error {
	return DefineTraits_Repeats_Marshal(m, (*[]DefineTraits)(op))
}

func (op *DefineTraits_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineTraits_Slice) SetSize(cnt int) {
	var els []DefineTraits
	if cnt >= 0 {
		els = make(DefineTraits_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineTraits_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineTraits_Marshal(m, &(*op)[i])
}

func DefineTraits_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineTraits) error {
	return jsn.RepeatBlock(m, (*DefineTraits_Slice)(vals))
}

func DefineTraits_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineTraits) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineTraits_Repeats_Marshal(m, pv)
	}
	return
}

type DefineTraits_Flow struct{ ptr *DefineTraits }

func (n DefineTraits_Flow) GetType() string      { return DefineTraits_Type }
func (n DefineTraits_Flow) GetLede() string      { return "define" }
func (n DefineTraits_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineTraits_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineTraits); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineTraits_Optional_Marshal(m jsn.Marshaler, pv **DefineTraits) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineTraits_Marshal(m, *pv)
	} else if !enc {
		var v DefineTraits
		if err = DefineTraits_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineTraits_Marshal(m jsn.Marshaler, val *DefineTraits) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineTraits_Flow{val}); err == nil {
		e0 := m.MarshalKey("traits", DefineTraits_Field_Traits)
		if e0 == nil {
			e0 = rt.TextListEval_Marshal(m, &val.Traits)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineTraits_Field_Traits))
		}
		e1 := m.MarshalKey("as", DefineTraits_Field_Aspect)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Aspect)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineTraits_Field_Aspect))
		}
		m.EndBlock()
	}
	return
}

// DefineValue Assign a starting value to the field of one or nouns.
type DefineValue struct {
	FieldName rt.TextEval       `if:"label=value"`
	Nouns     rt.TextListEval   `if:"label=of"`
	Value     assign.Assignment `if:"label=as"`
	Markup    map[string]any
}

// User implemented slots:
var _ StoryStatement = (*DefineValue)(nil)
var _ rt.Execute = (*DefineValue)(nil)

func (*DefineValue) Compose() composer.Spec {
	return composer.Spec{
		Name: DefineValue_Type,
		Uses: composer.Type_Flow,
		Lede: "define",
	}
}

const DefineValue_Type = "define_value"
const DefineValue_Field_FieldName = "$FIELD_NAME"
const DefineValue_Field_Nouns = "$NOUNS"
const DefineValue_Field_Value = "$VALUE"

func (op *DefineValue) Marshal(m jsn.Marshaler) error {
	return DefineValue_Marshal(m, op)
}

type DefineValue_Slice []DefineValue

func (op *DefineValue_Slice) GetType() string { return DefineValue_Type }

func (op *DefineValue_Slice) Marshal(m jsn.Marshaler) error {
	return DefineValue_Repeats_Marshal(m, (*[]DefineValue)(op))
}

func (op *DefineValue_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *DefineValue_Slice) SetSize(cnt int) {
	var els []DefineValue
	if cnt >= 0 {
		els = make(DefineValue_Slice, cnt)
	}
	(*op) = els
}

func (op *DefineValue_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return DefineValue_Marshal(m, &(*op)[i])
}

func DefineValue_Repeats_Marshal(m jsn.Marshaler, vals *[]DefineValue) error {
	return jsn.RepeatBlock(m, (*DefineValue_Slice)(vals))
}

func DefineValue_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]DefineValue) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = DefineValue_Repeats_Marshal(m, pv)
	}
	return
}

type DefineValue_Flow struct{ ptr *DefineValue }

func (n DefineValue_Flow) GetType() string      { return DefineValue_Type }
func (n DefineValue_Flow) GetLede() string      { return "define" }
func (n DefineValue_Flow) GetFlow() interface{} { return n.ptr }
func (n DefineValue_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*DefineValue); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func DefineValue_Optional_Marshal(m jsn.Marshaler, pv **DefineValue) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = DefineValue_Marshal(m, *pv)
	} else if !enc {
		var v DefineValue
		if err = DefineValue_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func DefineValue_Marshal(m jsn.Marshaler, val *DefineValue) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(DefineValue_Flow{val}); err == nil {
		e0 := m.MarshalKey("value", DefineValue_Field_FieldName)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.FieldName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", DefineValue_Field_FieldName))
		}
		e1 := m.MarshalKey("of", DefineValue_Field_Nouns)
		if e1 == nil {
			e1 = rt.TextListEval_Marshal(m, &val.Nouns)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", DefineValue_Field_Nouns))
		}
		e2 := m.MarshalKey("as", DefineValue_Field_Value)
		if e2 == nil {
			e2 = assign.Assignment_Marshal(m, &val.Value)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", DefineValue_Field_Value))
		}
		m.EndBlock()
	}
	return
}

// ExtendPattern Change the behavior of an existing pattern.
type ExtendPattern struct {
	PatternName rt.TextEval       `if:"label=pattern"`
	Locals      []FieldDefinition `if:"label=provides,optional"`
	Rules       []PatternRule     `if:"label=with_rules"`
	Markup      map[string]any
}

// User implemented slots:
var _ StoryStatement = (*ExtendPattern)(nil)
var _ rt.Execute = (*ExtendPattern)(nil)

func (*ExtendPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: ExtendPattern_Type,
		Uses: composer.Type_Flow,
		Lede: "extend",
	}
}

const ExtendPattern_Type = "extend_pattern"
const ExtendPattern_Field_PatternName = "$PATTERN_NAME"
const ExtendPattern_Field_Locals = "$LOCALS"
const ExtendPattern_Field_Rules = "$RULES"

func (op *ExtendPattern) Marshal(m jsn.Marshaler) error {
	return ExtendPattern_Marshal(m, op)
}

type ExtendPattern_Slice []ExtendPattern

func (op *ExtendPattern_Slice) GetType() string { return ExtendPattern_Type }

func (op *ExtendPattern_Slice) Marshal(m jsn.Marshaler) error {
	return ExtendPattern_Repeats_Marshal(m, (*[]ExtendPattern)(op))
}

func (op *ExtendPattern_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ExtendPattern_Slice) SetSize(cnt int) {
	var els []ExtendPattern
	if cnt >= 0 {
		els = make(ExtendPattern_Slice, cnt)
	}
	(*op) = els
}

func (op *ExtendPattern_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ExtendPattern_Marshal(m, &(*op)[i])
}

func ExtendPattern_Repeats_Marshal(m jsn.Marshaler, vals *[]ExtendPattern) error {
	return jsn.RepeatBlock(m, (*ExtendPattern_Slice)(vals))
}

func ExtendPattern_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ExtendPattern) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ExtendPattern_Repeats_Marshal(m, pv)
	}
	return
}

type ExtendPattern_Flow struct{ ptr *ExtendPattern }

func (n ExtendPattern_Flow) GetType() string      { return ExtendPattern_Type }
func (n ExtendPattern_Flow) GetLede() string      { return "extend" }
func (n ExtendPattern_Flow) GetFlow() interface{} { return n.ptr }
func (n ExtendPattern_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ExtendPattern); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ExtendPattern_Optional_Marshal(m jsn.Marshaler, pv **ExtendPattern) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ExtendPattern_Marshal(m, *pv)
	} else if !enc {
		var v ExtendPattern
		if err = ExtendPattern_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ExtendPattern_Marshal(m jsn.Marshaler, val *ExtendPattern) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ExtendPattern_Flow{val}); err == nil {
		e0 := m.MarshalKey("pattern", ExtendPattern_Field_PatternName)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.PatternName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ExtendPattern_Field_PatternName))
		}
		e1 := m.MarshalKey("provides", ExtendPattern_Field_Locals)
		if e1 == nil {
			e1 = FieldDefinition_Optional_Repeats_Marshal(m, &val.Locals)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ExtendPattern_Field_Locals))
		}
		e2 := m.MarshalKey("with_rules", ExtendPattern_Field_Rules)
		if e2 == nil {
			e2 = PatternRule_Repeats_Marshal(m, &val.Rules)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ExtendPattern_Field_Rules))
		}
		m.EndBlock()
	}
	return
}

const FieldDefinition_Type = "field_definition"

var FieldDefinition_Optional_Marshal = FieldDefinition_Marshal

type FieldDefinition_Slot struct{ Value *FieldDefinition }

func (at FieldDefinition_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at FieldDefinition_Slot) GetType() string              { return FieldDefinition_Type }
func (at FieldDefinition_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at FieldDefinition_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(FieldDefinition)
	return
}

func FieldDefinition_Marshal(m jsn.Marshaler, ptr *FieldDefinition) (err error) {
	slot := FieldDefinition_Slot{ptr}
	return slot.Marshal(m)
}

type FieldDefinition_Slice []FieldDefinition

func (op *FieldDefinition_Slice) GetType() string { return FieldDefinition_Type }

func (op *FieldDefinition_Slice) Marshal(m jsn.Marshaler) error {
	return FieldDefinition_Repeats_Marshal(m, (*[]FieldDefinition)(op))
}

func (op *FieldDefinition_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *FieldDefinition_Slice) SetSize(cnt int) {
	var els []FieldDefinition
	if cnt >= 0 {
		els = make(FieldDefinition_Slice, cnt)
	}
	(*op) = els
}

func (op *FieldDefinition_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return FieldDefinition_Marshal(m, &(*op)[i])
}

func FieldDefinition_Repeats_Marshal(m jsn.Marshaler, vals *[]FieldDefinition) error {
	return jsn.RepeatBlock(m, (*FieldDefinition_Slice)(vals))
}

func FieldDefinition_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]FieldDefinition) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = FieldDefinition_Repeats_Marshal(m, pv)
	}
	return
}

// MakeOpposite The opposite of east is west.
type MakeOpposite struct {
	Word     string `if:"label=_,type=text"`
	Opposite string `if:"label=opposite,type=text"`
	Markup   map[string]any
}

// User implemented slots:
var _ StoryStatement = (*MakeOpposite)(nil)
var _ rt.Execute = (*MakeOpposite)(nil)

func (*MakeOpposite) Compose() composer.Spec {
	return composer.Spec{
		Name: MakeOpposite_Type,
		Uses: composer.Type_Flow,
		Lede: "make",
	}
}

const MakeOpposite_Type = "make_opposite"
const MakeOpposite_Field_Word = "$WORD"
const MakeOpposite_Field_Opposite = "$OPPOSITE"

func (op *MakeOpposite) Marshal(m jsn.Marshaler) error {
	return MakeOpposite_Marshal(m, op)
}

type MakeOpposite_Slice []MakeOpposite

func (op *MakeOpposite_Slice) GetType() string { return MakeOpposite_Type }

func (op *MakeOpposite_Slice) Marshal(m jsn.Marshaler) error {
	return MakeOpposite_Repeats_Marshal(m, (*[]MakeOpposite)(op))
}

func (op *MakeOpposite_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MakeOpposite_Slice) SetSize(cnt int) {
	var els []MakeOpposite
	if cnt >= 0 {
		els = make(MakeOpposite_Slice, cnt)
	}
	(*op) = els
}

func (op *MakeOpposite_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MakeOpposite_Marshal(m, &(*op)[i])
}

func MakeOpposite_Repeats_Marshal(m jsn.Marshaler, vals *[]MakeOpposite) error {
	return jsn.RepeatBlock(m, (*MakeOpposite_Slice)(vals))
}

func MakeOpposite_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MakeOpposite) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MakeOpposite_Repeats_Marshal(m, pv)
	}
	return
}

type MakeOpposite_Flow struct{ ptr *MakeOpposite }

func (n MakeOpposite_Flow) GetType() string      { return MakeOpposite_Type }
func (n MakeOpposite_Flow) GetLede() string      { return "make" }
func (n MakeOpposite_Flow) GetFlow() interface{} { return n.ptr }
func (n MakeOpposite_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*MakeOpposite); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func MakeOpposite_Optional_Marshal(m jsn.Marshaler, pv **MakeOpposite) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = MakeOpposite_Marshal(m, *pv)
	} else if !enc {
		var v MakeOpposite
		if err = MakeOpposite_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func MakeOpposite_Marshal(m jsn.Marshaler, val *MakeOpposite) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(MakeOpposite_Flow{val}); err == nil {
		e0 := m.MarshalKey("", MakeOpposite_Field_Word)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Word)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", MakeOpposite_Field_Word))
		}
		e1 := m.MarshalKey("opposite", MakeOpposite_Field_Opposite)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Opposite)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", MakeOpposite_Field_Opposite))
		}
		m.EndBlock()
	}
	return
}

// MakePlural The plural of person is people.
// The plural of person is persons.
type MakePlural struct {
	Singular string `if:"label=_,type=text"`
	Plural   string `if:"label=plural,type=text"`
	Markup   map[string]any
}

// User implemented slots:
var _ StoryStatement = (*MakePlural)(nil)
var _ rt.Execute = (*MakePlural)(nil)

func (*MakePlural) Compose() composer.Spec {
	return composer.Spec{
		Name: MakePlural_Type,
		Uses: composer.Type_Flow,
		Lede: "make",
	}
}

const MakePlural_Type = "make_plural"
const MakePlural_Field_Singular = "$SINGULAR"
const MakePlural_Field_Plural = "$PLURAL"

func (op *MakePlural) Marshal(m jsn.Marshaler) error {
	return MakePlural_Marshal(m, op)
}

type MakePlural_Slice []MakePlural

func (op *MakePlural_Slice) GetType() string { return MakePlural_Type }

func (op *MakePlural_Slice) Marshal(m jsn.Marshaler) error {
	return MakePlural_Repeats_Marshal(m, (*[]MakePlural)(op))
}

func (op *MakePlural_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MakePlural_Slice) SetSize(cnt int) {
	var els []MakePlural
	if cnt >= 0 {
		els = make(MakePlural_Slice, cnt)
	}
	(*op) = els
}

func (op *MakePlural_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MakePlural_Marshal(m, &(*op)[i])
}

func MakePlural_Repeats_Marshal(m jsn.Marshaler, vals *[]MakePlural) error {
	return jsn.RepeatBlock(m, (*MakePlural_Slice)(vals))
}

func MakePlural_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MakePlural) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MakePlural_Repeats_Marshal(m, pv)
	}
	return
}

type MakePlural_Flow struct{ ptr *MakePlural }

func (n MakePlural_Flow) GetType() string      { return MakePlural_Type }
func (n MakePlural_Flow) GetLede() string      { return "make" }
func (n MakePlural_Flow) GetFlow() interface{} { return n.ptr }
func (n MakePlural_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*MakePlural); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func MakePlural_Optional_Marshal(m jsn.Marshaler, pv **MakePlural) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = MakePlural_Marshal(m, *pv)
	} else if !enc {
		var v MakePlural
		if err = MakePlural_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func MakePlural_Marshal(m jsn.Marshaler, val *MakePlural) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(MakePlural_Flow{val}); err == nil {
		e0 := m.MarshalKey("", MakePlural_Field_Singular)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Singular)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", MakePlural_Field_Singular))
		}
		e1 := m.MarshalKey("plural", MakePlural_Field_Plural)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Plural)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", MakePlural_Field_Plural))
		}
		m.EndBlock()
	}
	return
}

// ManyToMany
type ManyToMany struct {
	Kinds      rt.TextEval `if:"label=_"`
	OtherKinds rt.TextEval `if:"label=other_kinds"`
	Markup     map[string]any
}

func (*ManyToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyToMany_Type,
		Uses: composer.Type_Flow,
	}
}

const ManyToMany_Type = "many_to_many"
const ManyToMany_Field_Kinds = "$KINDS"
const ManyToMany_Field_OtherKinds = "$OTHER_KINDS"

func (op *ManyToMany) Marshal(m jsn.Marshaler) error {
	return ManyToMany_Marshal(m, op)
}

type ManyToMany_Slice []ManyToMany

func (op *ManyToMany_Slice) GetType() string { return ManyToMany_Type }

func (op *ManyToMany_Slice) Marshal(m jsn.Marshaler) error {
	return ManyToMany_Repeats_Marshal(m, (*[]ManyToMany)(op))
}

func (op *ManyToMany_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ManyToMany_Slice) SetSize(cnt int) {
	var els []ManyToMany
	if cnt >= 0 {
		els = make(ManyToMany_Slice, cnt)
	}
	(*op) = els
}

func (op *ManyToMany_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ManyToMany_Marshal(m, &(*op)[i])
}

func ManyToMany_Repeats_Marshal(m jsn.Marshaler, vals *[]ManyToMany) error {
	return jsn.RepeatBlock(m, (*ManyToMany_Slice)(vals))
}

func ManyToMany_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ManyToMany) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ManyToMany_Repeats_Marshal(m, pv)
	}
	return
}

type ManyToMany_Flow struct{ ptr *ManyToMany }

func (n ManyToMany_Flow) GetType() string      { return ManyToMany_Type }
func (n ManyToMany_Flow) GetLede() string      { return ManyToMany_Type }
func (n ManyToMany_Flow) GetFlow() interface{} { return n.ptr }
func (n ManyToMany_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ManyToMany); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ManyToMany_Optional_Marshal(m jsn.Marshaler, pv **ManyToMany) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ManyToMany_Marshal(m, *pv)
	} else if !enc {
		var v ManyToMany
		if err = ManyToMany_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ManyToMany_Marshal(m jsn.Marshaler, val *ManyToMany) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ManyToMany_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ManyToMany_Field_Kinds)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ManyToMany_Field_Kinds))
		}
		e1 := m.MarshalKey("other_kinds", ManyToMany_Field_OtherKinds)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.OtherKinds)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ManyToMany_Field_OtherKinds))
		}
		m.EndBlock()
	}
	return
}

// ManyToOne
type ManyToOne struct {
	Kinds  rt.TextEval `if:"label=_"`
	Kind   rt.TextEval `if:"label=kind"`
	Markup map[string]any
}

func (*ManyToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyToOne_Type,
		Uses: composer.Type_Flow,
	}
}

const ManyToOne_Type = "many_to_one"
const ManyToOne_Field_Kinds = "$KINDS"
const ManyToOne_Field_Kind = "$KIND"

func (op *ManyToOne) Marshal(m jsn.Marshaler) error {
	return ManyToOne_Marshal(m, op)
}

type ManyToOne_Slice []ManyToOne

func (op *ManyToOne_Slice) GetType() string { return ManyToOne_Type }

func (op *ManyToOne_Slice) Marshal(m jsn.Marshaler) error {
	return ManyToOne_Repeats_Marshal(m, (*[]ManyToOne)(op))
}

func (op *ManyToOne_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ManyToOne_Slice) SetSize(cnt int) {
	var els []ManyToOne
	if cnt >= 0 {
		els = make(ManyToOne_Slice, cnt)
	}
	(*op) = els
}

func (op *ManyToOne_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ManyToOne_Marshal(m, &(*op)[i])
}

func ManyToOne_Repeats_Marshal(m jsn.Marshaler, vals *[]ManyToOne) error {
	return jsn.RepeatBlock(m, (*ManyToOne_Slice)(vals))
}

func ManyToOne_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ManyToOne) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ManyToOne_Repeats_Marshal(m, pv)
	}
	return
}

type ManyToOne_Flow struct{ ptr *ManyToOne }

func (n ManyToOne_Flow) GetType() string      { return ManyToOne_Type }
func (n ManyToOne_Flow) GetLede() string      { return ManyToOne_Type }
func (n ManyToOne_Flow) GetFlow() interface{} { return n.ptr }
func (n ManyToOne_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ManyToOne); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ManyToOne_Optional_Marshal(m jsn.Marshaler, pv **ManyToOne) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ManyToOne_Marshal(m, *pv)
	} else if !enc {
		var v ManyToOne
		if err = ManyToOne_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ManyToOne_Marshal(m jsn.Marshaler, val *ManyToOne) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ManyToOne_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ManyToOne_Field_Kinds)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ManyToOne_Field_Kinds))
		}
		e1 := m.MarshalKey("kind", ManyToOne_Field_Kind)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Kind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ManyToOne_Field_Kind))
		}
		m.EndBlock()
	}
	return
}

// MapConnection requires a predefined string.
type MapConnection struct {
	Str string
}

func (op *MapConnection) String() string {
	return op.Str
}

const MapConnection_ArrivingAt = "$ARRIVING_AT"
const MapConnection_ConnectingTo = "$CONNECTING_TO"

func (*MapConnection) Compose() composer.Spec {
	return composer.Spec{
		Name: MapConnection_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			MapConnection_ArrivingAt, MapConnection_ConnectingTo,
		},
		Strings: []string{
			"arriving_at", "connecting_to",
		},
	}
}

const MapConnection_Type = "map_connection"

func (op *MapConnection) Marshal(m jsn.Marshaler) error {
	return MapConnection_Marshal(m, op)
}

func MapConnection_Optional_Marshal(m jsn.Marshaler, val *MapConnection) (err error) {
	var zero MapConnection
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = MapConnection_Marshal(m, val)
	}
	return
}

func MapConnection_Marshal(m jsn.Marshaler, val *MapConnection) (err error) {
	return m.MarshalValue(MapConnection_Type, jsn.MakeEnum(val, &val.Str))
}

type MapConnection_Slice []MapConnection

func (op *MapConnection_Slice) GetType() string { return MapConnection_Type }

func (op *MapConnection_Slice) Marshal(m jsn.Marshaler) error {
	return MapConnection_Repeats_Marshal(m, (*[]MapConnection)(op))
}

func (op *MapConnection_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MapConnection_Slice) SetSize(cnt int) {
	var els []MapConnection
	if cnt >= 0 {
		els = make(MapConnection_Slice, cnt)
	}
	(*op) = els
}

func (op *MapConnection_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MapConnection_Marshal(m, &(*op)[i])
}

func MapConnection_Repeats_Marshal(m jsn.Marshaler, vals *[]MapConnection) error {
	return jsn.RepeatBlock(m, (*MapConnection_Slice)(vals))
}

func MapConnection_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MapConnection) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MapConnection_Repeats_Marshal(m, pv)
	}
	return
}

// MapDeparting Leaving a room by by going through a door ( ex. departing the house via the front door... ).
type MapDeparting struct {
	RoomName      rt.TextEval   `if:"label=from"`
	DoorName      rt.TextEval   `if:"label=via"`
	MapConnection MapConnection `if:"label=and"`
	OtherRoomName rt.TextEval   `if:"label=other_room"`
	Markup        map[string]any
}

// User implemented slots:
var _ StoryStatement = (*MapDeparting)(nil)
var _ rt.Execute = (*MapDeparting)(nil)

func (*MapDeparting) Compose() composer.Spec {
	return composer.Spec{
		Name: MapDeparting_Type,
		Uses: composer.Type_Flow,
		Lede: "departing",
	}
}

const MapDeparting_Type = "map_departing"
const MapDeparting_Field_RoomName = "$ROOM_NAME"
const MapDeparting_Field_DoorName = "$DOOR_NAME"
const MapDeparting_Field_MapConnection = "$MAP_CONNECTION"
const MapDeparting_Field_OtherRoomName = "$OTHER_ROOM_NAME"

func (op *MapDeparting) Marshal(m jsn.Marshaler) error {
	return MapDeparting_Marshal(m, op)
}

type MapDeparting_Slice []MapDeparting

func (op *MapDeparting_Slice) GetType() string { return MapDeparting_Type }

func (op *MapDeparting_Slice) Marshal(m jsn.Marshaler) error {
	return MapDeparting_Repeats_Marshal(m, (*[]MapDeparting)(op))
}

func (op *MapDeparting_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MapDeparting_Slice) SetSize(cnt int) {
	var els []MapDeparting
	if cnt >= 0 {
		els = make(MapDeparting_Slice, cnt)
	}
	(*op) = els
}

func (op *MapDeparting_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MapDeparting_Marshal(m, &(*op)[i])
}

func MapDeparting_Repeats_Marshal(m jsn.Marshaler, vals *[]MapDeparting) error {
	return jsn.RepeatBlock(m, (*MapDeparting_Slice)(vals))
}

func MapDeparting_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MapDeparting) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MapDeparting_Repeats_Marshal(m, pv)
	}
	return
}

type MapDeparting_Flow struct{ ptr *MapDeparting }

func (n MapDeparting_Flow) GetType() string      { return MapDeparting_Type }
func (n MapDeparting_Flow) GetLede() string      { return "departing" }
func (n MapDeparting_Flow) GetFlow() interface{} { return n.ptr }
func (n MapDeparting_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*MapDeparting); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func MapDeparting_Optional_Marshal(m jsn.Marshaler, pv **MapDeparting) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = MapDeparting_Marshal(m, *pv)
	} else if !enc {
		var v MapDeparting
		if err = MapDeparting_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func MapDeparting_Marshal(m jsn.Marshaler, val *MapDeparting) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(MapDeparting_Flow{val}); err == nil {
		e0 := m.MarshalKey("from", MapDeparting_Field_RoomName)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.RoomName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", MapDeparting_Field_RoomName))
		}
		e1 := m.MarshalKey("via", MapDeparting_Field_DoorName)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.DoorName)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", MapDeparting_Field_DoorName))
		}
		e2 := m.MarshalKey("and", MapDeparting_Field_MapConnection)
		if e2 == nil {
			e2 = MapConnection_Marshal(m, &val.MapConnection)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", MapDeparting_Field_MapConnection))
		}
		e3 := m.MarshalKey("other_room", MapDeparting_Field_OtherRoomName)
		if e3 == nil {
			e3 = rt.TextEval_Marshal(m, &val.OtherRoomName)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", MapDeparting_Field_OtherRoomName))
		}
		m.EndBlock()
	}
	return
}

// MapDirection requires a user-specified string.
type MapDirection struct {
	Str string
}

func (op *MapDirection) String() string {
	return op.Str
}

func (*MapDirection) Compose() composer.Spec {
	return composer.Spec{
		Name:        MapDirection_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const MapDirection_Type = "map_direction"

func (op *MapDirection) Marshal(m jsn.Marshaler) error {
	return MapDirection_Marshal(m, op)
}

func MapDirection_Optional_Marshal(m jsn.Marshaler, val *MapDirection) (err error) {
	var zero MapDirection
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = MapDirection_Marshal(m, val)
	}
	return
}

func MapDirection_Marshal(m jsn.Marshaler, val *MapDirection) (err error) {
	return m.MarshalValue(MapDirection_Type, &val.Str)
}

type MapDirection_Slice []MapDirection

func (op *MapDirection_Slice) GetType() string { return MapDirection_Type }

func (op *MapDirection_Slice) Marshal(m jsn.Marshaler) error {
	return MapDirection_Repeats_Marshal(m, (*[]MapDirection)(op))
}

func (op *MapDirection_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MapDirection_Slice) SetSize(cnt int) {
	var els []MapDirection
	if cnt >= 0 {
		els = make(MapDirection_Slice, cnt)
	}
	(*op) = els
}

func (op *MapDirection_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MapDirection_Marshal(m, &(*op)[i])
}

func MapDirection_Repeats_Marshal(m jsn.Marshaler, vals *[]MapDirection) error {
	return jsn.RepeatBlock(m, (*MapDirection_Slice)(vals))
}

func MapDirection_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MapDirection) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MapDirection_Repeats_Marshal(m, pv)
	}
	return
}

// MapHeading Leaving a room by moving in a compass direction ( ex. heading east... ).
type MapHeading struct {
	Dir           MapDirection  `if:"label=_"`
	RoomName      rt.TextEval   `if:"label=from"`
	DoorName      rt.TextEval   `if:"label=via,optional"`
	MapConnection MapConnection `if:"label=and"`
	OtherRoomName rt.TextEval   `if:"label=other_room"`
	Markup        map[string]any
}

// User implemented slots:
var _ StoryStatement = (*MapHeading)(nil)
var _ rt.Execute = (*MapHeading)(nil)

func (*MapHeading) Compose() composer.Spec {
	return composer.Spec{
		Name: MapHeading_Type,
		Uses: composer.Type_Flow,
		Lede: "heading",
	}
}

const MapHeading_Type = "map_heading"
const MapHeading_Field_Dir = "$DIR"
const MapHeading_Field_RoomName = "$ROOM_NAME"
const MapHeading_Field_DoorName = "$DOOR_NAME"
const MapHeading_Field_MapConnection = "$MAP_CONNECTION"
const MapHeading_Field_OtherRoomName = "$OTHER_ROOM_NAME"

func (op *MapHeading) Marshal(m jsn.Marshaler) error {
	return MapHeading_Marshal(m, op)
}

type MapHeading_Slice []MapHeading

func (op *MapHeading_Slice) GetType() string { return MapHeading_Type }

func (op *MapHeading_Slice) Marshal(m jsn.Marshaler) error {
	return MapHeading_Repeats_Marshal(m, (*[]MapHeading)(op))
}

func (op *MapHeading_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MapHeading_Slice) SetSize(cnt int) {
	var els []MapHeading
	if cnt >= 0 {
		els = make(MapHeading_Slice, cnt)
	}
	(*op) = els
}

func (op *MapHeading_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MapHeading_Marshal(m, &(*op)[i])
}

func MapHeading_Repeats_Marshal(m jsn.Marshaler, vals *[]MapHeading) error {
	return jsn.RepeatBlock(m, (*MapHeading_Slice)(vals))
}

func MapHeading_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MapHeading) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MapHeading_Repeats_Marshal(m, pv)
	}
	return
}

type MapHeading_Flow struct{ ptr *MapHeading }

func (n MapHeading_Flow) GetType() string      { return MapHeading_Type }
func (n MapHeading_Flow) GetLede() string      { return "heading" }
func (n MapHeading_Flow) GetFlow() interface{} { return n.ptr }
func (n MapHeading_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*MapHeading); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func MapHeading_Optional_Marshal(m jsn.Marshaler, pv **MapHeading) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = MapHeading_Marshal(m, *pv)
	} else if !enc {
		var v MapHeading
		if err = MapHeading_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func MapHeading_Marshal(m jsn.Marshaler, val *MapHeading) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(MapHeading_Flow{val}); err == nil {
		e0 := m.MarshalKey("", MapHeading_Field_Dir)
		if e0 == nil {
			e0 = MapDirection_Marshal(m, &val.Dir)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", MapHeading_Field_Dir))
		}
		e1 := m.MarshalKey("from", MapHeading_Field_RoomName)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.RoomName)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", MapHeading_Field_RoomName))
		}
		e2 := m.MarshalKey("via", MapHeading_Field_DoorName)
		if e2 == nil {
			e2 = rt.TextEval_Optional_Marshal(m, &val.DoorName)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", MapHeading_Field_DoorName))
		}
		e3 := m.MarshalKey("and", MapHeading_Field_MapConnection)
		if e3 == nil {
			e3 = MapConnection_Marshal(m, &val.MapConnection)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", MapHeading_Field_MapConnection))
		}
		e4 := m.MarshalKey("other_room", MapHeading_Field_OtherRoomName)
		if e4 == nil {
			e4 = rt.TextEval_Marshal(m, &val.OtherRoomName)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", MapHeading_Field_OtherRoomName))
		}
		m.EndBlock()
	}
	return
}

// NothingField A valueless field.
// Intended mainly for patterns which don't need to return a value.
type NothingField struct {
	Markup map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*NothingField)(nil)

func (*NothingField) Compose() composer.Spec {
	return composer.Spec{
		Name: NothingField_Type,
		Uses: composer.Type_Flow,
		Lede: "nothing",
	}
}

const NothingField_Type = "nothing_field"

func (op *NothingField) Marshal(m jsn.Marshaler) error {
	return NothingField_Marshal(m, op)
}

type NothingField_Slice []NothingField

func (op *NothingField_Slice) GetType() string { return NothingField_Type }

func (op *NothingField_Slice) Marshal(m jsn.Marshaler) error {
	return NothingField_Repeats_Marshal(m, (*[]NothingField)(op))
}

func (op *NothingField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *NothingField_Slice) SetSize(cnt int) {
	var els []NothingField
	if cnt >= 0 {
		els = make(NothingField_Slice, cnt)
	}
	(*op) = els
}

func (op *NothingField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return NothingField_Marshal(m, &(*op)[i])
}

func NothingField_Repeats_Marshal(m jsn.Marshaler, vals *[]NothingField) error {
	return jsn.RepeatBlock(m, (*NothingField_Slice)(vals))
}

func NothingField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]NothingField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = NothingField_Repeats_Marshal(m, pv)
	}
	return
}

type NothingField_Flow struct{ ptr *NothingField }

func (n NothingField_Flow) GetType() string      { return NothingField_Type }
func (n NothingField_Flow) GetLede() string      { return "nothing" }
func (n NothingField_Flow) GetFlow() interface{} { return n.ptr }
func (n NothingField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*NothingField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func NothingField_Optional_Marshal(m jsn.Marshaler, pv **NothingField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = NothingField_Marshal(m, *pv)
	} else if !enc {
		var v NothingField
		if err = NothingField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func NothingField_Marshal(m jsn.Marshaler, val *NothingField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(NothingField_Flow{val}); err == nil {
		m.EndBlock()
	}
	return
}

// NumListField
type NumListField struct {
	Name      string         `if:"label=_,type=text"`
	Type      string         `if:"label=kind,optional,type=text"`
	Initially rt.NumListEval `if:"label=initially,optional"`
	Markup    map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*NumListField)(nil)

func (*NumListField) Compose() composer.Spec {
	return composer.Spec{
		Name: NumListField_Type,
		Uses: composer.Type_Flow,
		Lede: "num_list",
	}
}

const NumListField_Type = "num_list_field"
const NumListField_Field_Name = "$NAME"
const NumListField_Field_Type = "$TYPE"
const NumListField_Field_Initially = "$INITIALLY"

func (op *NumListField) Marshal(m jsn.Marshaler) error {
	return NumListField_Marshal(m, op)
}

type NumListField_Slice []NumListField

func (op *NumListField_Slice) GetType() string { return NumListField_Type }

func (op *NumListField_Slice) Marshal(m jsn.Marshaler) error {
	return NumListField_Repeats_Marshal(m, (*[]NumListField)(op))
}

func (op *NumListField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *NumListField_Slice) SetSize(cnt int) {
	var els []NumListField
	if cnt >= 0 {
		els = make(NumListField_Slice, cnt)
	}
	(*op) = els
}

func (op *NumListField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return NumListField_Marshal(m, &(*op)[i])
}

func NumListField_Repeats_Marshal(m jsn.Marshaler, vals *[]NumListField) error {
	return jsn.RepeatBlock(m, (*NumListField_Slice)(vals))
}

func NumListField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]NumListField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = NumListField_Repeats_Marshal(m, pv)
	}
	return
}

type NumListField_Flow struct{ ptr *NumListField }

func (n NumListField_Flow) GetType() string      { return NumListField_Type }
func (n NumListField_Flow) GetLede() string      { return "num_list" }
func (n NumListField_Flow) GetFlow() interface{} { return n.ptr }
func (n NumListField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*NumListField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func NumListField_Optional_Marshal(m jsn.Marshaler, pv **NumListField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = NumListField_Marshal(m, *pv)
	} else if !enc {
		var v NumListField
		if err = NumListField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func NumListField_Marshal(m jsn.Marshaler, val *NumListField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(NumListField_Flow{val}); err == nil {
		e0 := m.MarshalKey("", NumListField_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", NumListField_Field_Name))
		}
		e1 := m.MarshalKey("kind", NumListField_Field_Type)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Optional_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", NumListField_Field_Type))
		}
		e2 := m.MarshalKey("initially", NumListField_Field_Initially)
		if e2 == nil {
			e2 = rt.NumListEval_Optional_Marshal(m, &val.Initially)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", NumListField_Field_Initially))
		}
		m.EndBlock()
	}
	return
}

// NumberField
type NumberField struct {
	Name      string        `if:"label=_,type=text"`
	Type      string        `if:"label=kind,optional,type=text"`
	Initially rt.NumberEval `if:"label=initially,optional"`
	Markup    map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*NumberField)(nil)

func (*NumberField) Compose() composer.Spec {
	return composer.Spec{
		Name: NumberField_Type,
		Uses: composer.Type_Flow,
		Lede: "number",
	}
}

const NumberField_Type = "number_field"
const NumberField_Field_Name = "$NAME"
const NumberField_Field_Type = "$TYPE"
const NumberField_Field_Initially = "$INITIALLY"

func (op *NumberField) Marshal(m jsn.Marshaler) error {
	return NumberField_Marshal(m, op)
}

type NumberField_Slice []NumberField

func (op *NumberField_Slice) GetType() string { return NumberField_Type }

func (op *NumberField_Slice) Marshal(m jsn.Marshaler) error {
	return NumberField_Repeats_Marshal(m, (*[]NumberField)(op))
}

func (op *NumberField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *NumberField_Slice) SetSize(cnt int) {
	var els []NumberField
	if cnt >= 0 {
		els = make(NumberField_Slice, cnt)
	}
	(*op) = els
}

func (op *NumberField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return NumberField_Marshal(m, &(*op)[i])
}

func NumberField_Repeats_Marshal(m jsn.Marshaler, vals *[]NumberField) error {
	return jsn.RepeatBlock(m, (*NumberField_Slice)(vals))
}

func NumberField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]NumberField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = NumberField_Repeats_Marshal(m, pv)
	}
	return
}

type NumberField_Flow struct{ ptr *NumberField }

func (n NumberField_Flow) GetType() string      { return NumberField_Type }
func (n NumberField_Flow) GetLede() string      { return "number" }
func (n NumberField_Flow) GetFlow() interface{} { return n.ptr }
func (n NumberField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*NumberField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func NumberField_Optional_Marshal(m jsn.Marshaler, pv **NumberField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = NumberField_Marshal(m, *pv)
	} else if !enc {
		var v NumberField
		if err = NumberField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func NumberField_Marshal(m jsn.Marshaler, val *NumberField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(NumberField_Flow{val}); err == nil {
		e0 := m.MarshalKey("", NumberField_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", NumberField_Field_Name))
		}
		e1 := m.MarshalKey("kind", NumberField_Field_Type)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Optional_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", NumberField_Field_Type))
		}
		e2 := m.MarshalKey("initially", NumberField_Field_Initially)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.Initially)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", NumberField_Field_Initially))
		}
		m.EndBlock()
	}
	return
}

// OneToMany
type OneToMany struct {
	Kind   rt.TextEval `if:"label=_"`
	Kinds  rt.TextEval `if:"label=kinds"`
	Markup map[string]any
}

func (*OneToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: OneToMany_Type,
		Uses: composer.Type_Flow,
	}
}

const OneToMany_Type = "one_to_many"
const OneToMany_Field_Kind = "$KIND"
const OneToMany_Field_Kinds = "$KINDS"

func (op *OneToMany) Marshal(m jsn.Marshaler) error {
	return OneToMany_Marshal(m, op)
}

type OneToMany_Slice []OneToMany

func (op *OneToMany_Slice) GetType() string { return OneToMany_Type }

func (op *OneToMany_Slice) Marshal(m jsn.Marshaler) error {
	return OneToMany_Repeats_Marshal(m, (*[]OneToMany)(op))
}

func (op *OneToMany_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *OneToMany_Slice) SetSize(cnt int) {
	var els []OneToMany
	if cnt >= 0 {
		els = make(OneToMany_Slice, cnt)
	}
	(*op) = els
}

func (op *OneToMany_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return OneToMany_Marshal(m, &(*op)[i])
}

func OneToMany_Repeats_Marshal(m jsn.Marshaler, vals *[]OneToMany) error {
	return jsn.RepeatBlock(m, (*OneToMany_Slice)(vals))
}

func OneToMany_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]OneToMany) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = OneToMany_Repeats_Marshal(m, pv)
	}
	return
}

type OneToMany_Flow struct{ ptr *OneToMany }

func (n OneToMany_Flow) GetType() string      { return OneToMany_Type }
func (n OneToMany_Flow) GetLede() string      { return OneToMany_Type }
func (n OneToMany_Flow) GetFlow() interface{} { return n.ptr }
func (n OneToMany_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*OneToMany); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func OneToMany_Optional_Marshal(m jsn.Marshaler, pv **OneToMany) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = OneToMany_Marshal(m, *pv)
	} else if !enc {
		var v OneToMany
		if err = OneToMany_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func OneToMany_Marshal(m jsn.Marshaler, val *OneToMany) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(OneToMany_Flow{val}); err == nil {
		e0 := m.MarshalKey("", OneToMany_Field_Kind)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Kind)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", OneToMany_Field_Kind))
		}
		e1 := m.MarshalKey("kinds", OneToMany_Field_Kinds)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Kinds)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", OneToMany_Field_Kinds))
		}
		m.EndBlock()
	}
	return
}

// OneToOne
type OneToOne struct {
	Kind      rt.TextEval `if:"label=_"`
	OtherKind rt.TextEval `if:"label=other_kind"`
	Markup    map[string]any
}

func (*OneToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: OneToOne_Type,
		Uses: composer.Type_Flow,
	}
}

const OneToOne_Type = "one_to_one"
const OneToOne_Field_Kind = "$KIND"
const OneToOne_Field_OtherKind = "$OTHER_KIND"

func (op *OneToOne) Marshal(m jsn.Marshaler) error {
	return OneToOne_Marshal(m, op)
}

type OneToOne_Slice []OneToOne

func (op *OneToOne_Slice) GetType() string { return OneToOne_Type }

func (op *OneToOne_Slice) Marshal(m jsn.Marshaler) error {
	return OneToOne_Repeats_Marshal(m, (*[]OneToOne)(op))
}

func (op *OneToOne_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *OneToOne_Slice) SetSize(cnt int) {
	var els []OneToOne
	if cnt >= 0 {
		els = make(OneToOne_Slice, cnt)
	}
	(*op) = els
}

func (op *OneToOne_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return OneToOne_Marshal(m, &(*op)[i])
}

func OneToOne_Repeats_Marshal(m jsn.Marshaler, vals *[]OneToOne) error {
	return jsn.RepeatBlock(m, (*OneToOne_Slice)(vals))
}

func OneToOne_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]OneToOne) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = OneToOne_Repeats_Marshal(m, pv)
	}
	return
}

type OneToOne_Flow struct{ ptr *OneToOne }

func (n OneToOne_Flow) GetType() string      { return OneToOne_Type }
func (n OneToOne_Flow) GetLede() string      { return OneToOne_Type }
func (n OneToOne_Flow) GetFlow() interface{} { return n.ptr }
func (n OneToOne_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*OneToOne); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func OneToOne_Optional_Marshal(m jsn.Marshaler, pv **OneToOne) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = OneToOne_Marshal(m, *pv)
	} else if !enc {
		var v OneToOne
		if err = OneToOne_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func OneToOne_Marshal(m jsn.Marshaler, val *OneToOne) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(OneToOne_Flow{val}); err == nil {
		e0 := m.MarshalKey("", OneToOne_Field_Kind)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Kind)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", OneToOne_Field_Kind))
		}
		e1 := m.MarshalKey("other_kind", OneToOne_Field_OtherKind)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.OtherKind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", OneToOne_Field_OtherKind))
		}
		m.EndBlock()
	}
	return
}

// PairedAction
type PairedAction struct {
	Kinds  rt.TextEval `if:"label=_"`
	Markup map[string]any
}

func (*PairedAction) Compose() composer.Spec {
	return composer.Spec{
		Name: PairedAction_Type,
		Uses: composer.Type_Flow,
	}
}

const PairedAction_Type = "paired_action"
const PairedAction_Field_Kinds = "$KINDS"

func (op *PairedAction) Marshal(m jsn.Marshaler) error {
	return PairedAction_Marshal(m, op)
}

type PairedAction_Slice []PairedAction

func (op *PairedAction_Slice) GetType() string { return PairedAction_Type }

func (op *PairedAction_Slice) Marshal(m jsn.Marshaler) error {
	return PairedAction_Repeats_Marshal(m, (*[]PairedAction)(op))
}

func (op *PairedAction_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *PairedAction_Slice) SetSize(cnt int) {
	var els []PairedAction
	if cnt >= 0 {
		els = make(PairedAction_Slice, cnt)
	}
	(*op) = els
}

func (op *PairedAction_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return PairedAction_Marshal(m, &(*op)[i])
}

func PairedAction_Repeats_Marshal(m jsn.Marshaler, vals *[]PairedAction) error {
	return jsn.RepeatBlock(m, (*PairedAction_Slice)(vals))
}

func PairedAction_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]PairedAction) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = PairedAction_Repeats_Marshal(m, pv)
	}
	return
}

type PairedAction_Flow struct{ ptr *PairedAction }

func (n PairedAction_Flow) GetType() string      { return PairedAction_Type }
func (n PairedAction_Flow) GetLede() string      { return PairedAction_Type }
func (n PairedAction_Flow) GetFlow() interface{} { return n.ptr }
func (n PairedAction_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*PairedAction); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func PairedAction_Optional_Marshal(m jsn.Marshaler, pv **PairedAction) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = PairedAction_Marshal(m, *pv)
	} else if !enc {
		var v PairedAction
		if err = PairedAction_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func PairedAction_Marshal(m jsn.Marshaler, val *PairedAction) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(PairedAction_Flow{val}); err == nil {
		e0 := m.MarshalKey("", PairedAction_Field_Kinds)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Kinds)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", PairedAction_Field_Kinds))
		}
		m.EndBlock()
	}
	return
}

// PatternFlags requires a predefined string.
type PatternFlags struct {
	Str string
}

func (op *PatternFlags) String() string {
	return op.Str
}

const PatternFlags_Before = "$BEFORE"
const PatternFlags_After = "$AFTER"
const PatternFlags_Terminate = "$TERMINATE"

func (*PatternFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternFlags_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			PatternFlags_Before, PatternFlags_After, PatternFlags_Terminate,
		},
		Strings: []string{
			"before", "after", "terminate",
		},
	}
}

const PatternFlags_Type = "pattern_flags"

func (op *PatternFlags) Marshal(m jsn.Marshaler) error {
	return PatternFlags_Marshal(m, op)
}

func PatternFlags_Optional_Marshal(m jsn.Marshaler, val *PatternFlags) (err error) {
	var zero PatternFlags
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = PatternFlags_Marshal(m, val)
	}
	return
}

func PatternFlags_Marshal(m jsn.Marshaler, val *PatternFlags) (err error) {
	return m.MarshalValue(PatternFlags_Type, jsn.MakeEnum(val, &val.Str))
}

type PatternFlags_Slice []PatternFlags

func (op *PatternFlags_Slice) GetType() string { return PatternFlags_Type }

func (op *PatternFlags_Slice) Marshal(m jsn.Marshaler) error {
	return PatternFlags_Repeats_Marshal(m, (*[]PatternFlags)(op))
}

func (op *PatternFlags_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *PatternFlags_Slice) SetSize(cnt int) {
	var els []PatternFlags
	if cnt >= 0 {
		els = make(PatternFlags_Slice, cnt)
	}
	(*op) = els
}

func (op *PatternFlags_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return PatternFlags_Marshal(m, &(*op)[i])
}

func PatternFlags_Repeats_Marshal(m jsn.Marshaler, vals *[]PatternFlags) error {
	return jsn.RepeatBlock(m, (*PatternFlags_Slice)(vals))
}

func PatternFlags_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]PatternFlags) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = PatternFlags_Repeats_Marshal(m, pv)
	}
	return
}

// PatternRule Rule
type PatternRule struct {
	Guard  rt.BoolEval  `if:"label=_"`
	Flags  PatternFlags `if:"label=flags,optional"`
	Exe    []rt.Execute `if:"label=do"`
	Markup map[string]any
}

func (*PatternRule) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternRule_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternRule_Type = "pattern_rule"
const PatternRule_Field_Guard = "$GUARD"
const PatternRule_Field_Flags = "$FLAGS"
const PatternRule_Field_Exe = "$EXE"

func (op *PatternRule) Marshal(m jsn.Marshaler) error {
	return PatternRule_Marshal(m, op)
}

type PatternRule_Slice []PatternRule

func (op *PatternRule_Slice) GetType() string { return PatternRule_Type }

func (op *PatternRule_Slice) Marshal(m jsn.Marshaler) error {
	return PatternRule_Repeats_Marshal(m, (*[]PatternRule)(op))
}

func (op *PatternRule_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *PatternRule_Slice) SetSize(cnt int) {
	var els []PatternRule
	if cnt >= 0 {
		els = make(PatternRule_Slice, cnt)
	}
	(*op) = els
}

func (op *PatternRule_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return PatternRule_Marshal(m, &(*op)[i])
}

func PatternRule_Repeats_Marshal(m jsn.Marshaler, vals *[]PatternRule) error {
	return jsn.RepeatBlock(m, (*PatternRule_Slice)(vals))
}

func PatternRule_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]PatternRule) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = PatternRule_Repeats_Marshal(m, pv)
	}
	return
}

type PatternRule_Flow struct{ ptr *PatternRule }

func (n PatternRule_Flow) GetType() string      { return PatternRule_Type }
func (n PatternRule_Flow) GetLede() string      { return PatternRule_Type }
func (n PatternRule_Flow) GetFlow() interface{} { return n.ptr }
func (n PatternRule_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*PatternRule); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func PatternRule_Optional_Marshal(m jsn.Marshaler, pv **PatternRule) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = PatternRule_Marshal(m, *pv)
	} else if !enc {
		var v PatternRule
		if err = PatternRule_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func PatternRule_Marshal(m jsn.Marshaler, val *PatternRule) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(PatternRule_Flow{val}); err == nil {
		e0 := m.MarshalKey("", PatternRule_Field_Guard)
		if e0 == nil {
			e0 = rt.BoolEval_Marshal(m, &val.Guard)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", PatternRule_Field_Guard))
		}
		e1 := m.MarshalKey("flags", PatternRule_Field_Flags)
		if e1 == nil {
			e1 = PatternFlags_Optional_Marshal(m, &val.Flags)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", PatternRule_Field_Flags))
		}
		e2 := m.MarshalKey("do", PatternRule_Field_Exe)
		if e2 == nil {
			e2 = rt.Execute_Repeats_Marshal(m, &val.Exe)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", PatternRule_Field_Exe))
		}
		m.EndBlock()
	}
	return
}

// PatternType requires a predefined or user-specified string.
type PatternType struct {
	Str string
}

func (op *PatternType) String() string {
	return op.Str
}

const PatternType_Patterns = "$PATTERNS"
const PatternType_Actions = "$ACTIONS"
const PatternType_Events = "$EVENTS"

func (*PatternType) Compose() composer.Spec {
	return composer.Spec{
		Name:        PatternType_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			PatternType_Patterns, PatternType_Actions, PatternType_Events,
		},
		Strings: []string{
			"patterns", "actions", "events",
		},
	}
}

const PatternType_Type = "pattern_type"

func (op *PatternType) Marshal(m jsn.Marshaler) error {
	return PatternType_Marshal(m, op)
}

func PatternType_Optional_Marshal(m jsn.Marshaler, val *PatternType) (err error) {
	var zero PatternType
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = PatternType_Marshal(m, val)
	}
	return
}

func PatternType_Marshal(m jsn.Marshaler, val *PatternType) (err error) {
	return m.MarshalValue(PatternType_Type, jsn.MakeEnum(val, &val.Str))
}

type PatternType_Slice []PatternType

func (op *PatternType_Slice) GetType() string { return PatternType_Type }

func (op *PatternType_Slice) Marshal(m jsn.Marshaler) error {
	return PatternType_Repeats_Marshal(m, (*[]PatternType)(op))
}

func (op *PatternType_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *PatternType_Slice) SetSize(cnt int) {
	var els []PatternType
	if cnt >= 0 {
		els = make(PatternType_Slice, cnt)
	}
	(*op) = els
}

func (op *PatternType_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return PatternType_Marshal(m, &(*op)[i])
}

func PatternType_Repeats_Marshal(m jsn.Marshaler, vals *[]PatternType) error {
	return jsn.RepeatBlock(m, (*PatternType_Slice)(vals))
}

func PatternType_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]PatternType) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = PatternType_Repeats_Marshal(m, pv)
	}
	return
}

// RecordField
type RecordField struct {
	Name      string        `if:"label=_,type=text"`
	Type      string        `if:"label=kind,optional,type=text"`
	Initially rt.RecordEval `if:"label=initially,optional"`
	Markup    map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*RecordField)(nil)

func (*RecordField) Compose() composer.Spec {
	return composer.Spec{
		Name: RecordField_Type,
		Uses: composer.Type_Flow,
		Lede: "record",
	}
}

const RecordField_Type = "record_field"
const RecordField_Field_Name = "$NAME"
const RecordField_Field_Type = "$TYPE"
const RecordField_Field_Initially = "$INITIALLY"

func (op *RecordField) Marshal(m jsn.Marshaler) error {
	return RecordField_Marshal(m, op)
}

type RecordField_Slice []RecordField

func (op *RecordField_Slice) GetType() string { return RecordField_Type }

func (op *RecordField_Slice) Marshal(m jsn.Marshaler) error {
	return RecordField_Repeats_Marshal(m, (*[]RecordField)(op))
}

func (op *RecordField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *RecordField_Slice) SetSize(cnt int) {
	var els []RecordField
	if cnt >= 0 {
		els = make(RecordField_Slice, cnt)
	}
	(*op) = els
}

func (op *RecordField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return RecordField_Marshal(m, &(*op)[i])
}

func RecordField_Repeats_Marshal(m jsn.Marshaler, vals *[]RecordField) error {
	return jsn.RepeatBlock(m, (*RecordField_Slice)(vals))
}

func RecordField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]RecordField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = RecordField_Repeats_Marshal(m, pv)
	}
	return
}

type RecordField_Flow struct{ ptr *RecordField }

func (n RecordField_Flow) GetType() string      { return RecordField_Type }
func (n RecordField_Flow) GetLede() string      { return "record" }
func (n RecordField_Flow) GetFlow() interface{} { return n.ptr }
func (n RecordField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*RecordField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func RecordField_Optional_Marshal(m jsn.Marshaler, pv **RecordField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = RecordField_Marshal(m, *pv)
	} else if !enc {
		var v RecordField
		if err = RecordField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func RecordField_Marshal(m jsn.Marshaler, val *RecordField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(RecordField_Flow{val}); err == nil {
		e0 := m.MarshalKey("", RecordField_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", RecordField_Field_Name))
		}
		e1 := m.MarshalKey("kind", RecordField_Field_Type)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Optional_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", RecordField_Field_Type))
		}
		e2 := m.MarshalKey("initially", RecordField_Field_Initially)
		if e2 == nil {
			e2 = rt.RecordEval_Optional_Marshal(m, &val.Initially)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", RecordField_Field_Initially))
		}
		m.EndBlock()
	}
	return
}

// RecordListField
type RecordListField struct {
	Name      string            `if:"label=_,type=text"`
	Type      string            `if:"label=kind,optional,type=text"`
	Initially rt.RecordListEval `if:"label=initially,optional"`
	Markup    map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*RecordListField)(nil)

func (*RecordListField) Compose() composer.Spec {
	return composer.Spec{
		Name: RecordListField_Type,
		Uses: composer.Type_Flow,
		Lede: "record_list",
	}
}

const RecordListField_Type = "record_list_field"
const RecordListField_Field_Name = "$NAME"
const RecordListField_Field_Type = "$TYPE"
const RecordListField_Field_Initially = "$INITIALLY"

func (op *RecordListField) Marshal(m jsn.Marshaler) error {
	return RecordListField_Marshal(m, op)
}

type RecordListField_Slice []RecordListField

func (op *RecordListField_Slice) GetType() string { return RecordListField_Type }

func (op *RecordListField_Slice) Marshal(m jsn.Marshaler) error {
	return RecordListField_Repeats_Marshal(m, (*[]RecordListField)(op))
}

func (op *RecordListField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *RecordListField_Slice) SetSize(cnt int) {
	var els []RecordListField
	if cnt >= 0 {
		els = make(RecordListField_Slice, cnt)
	}
	(*op) = els
}

func (op *RecordListField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return RecordListField_Marshal(m, &(*op)[i])
}

func RecordListField_Repeats_Marshal(m jsn.Marshaler, vals *[]RecordListField) error {
	return jsn.RepeatBlock(m, (*RecordListField_Slice)(vals))
}

func RecordListField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]RecordListField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = RecordListField_Repeats_Marshal(m, pv)
	}
	return
}

type RecordListField_Flow struct{ ptr *RecordListField }

func (n RecordListField_Flow) GetType() string      { return RecordListField_Type }
func (n RecordListField_Flow) GetLede() string      { return "record_list" }
func (n RecordListField_Flow) GetFlow() interface{} { return n.ptr }
func (n RecordListField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*RecordListField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func RecordListField_Optional_Marshal(m jsn.Marshaler, pv **RecordListField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = RecordListField_Marshal(m, *pv)
	} else if !enc {
		var v RecordListField
		if err = RecordListField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func RecordListField_Marshal(m jsn.Marshaler, val *RecordListField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(RecordListField_Flow{val}); err == nil {
		e0 := m.MarshalKey("", RecordListField_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", RecordListField_Field_Name))
		}
		e1 := m.MarshalKey("kind", RecordListField_Field_Type)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Optional_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", RecordListField_Field_Type))
		}
		e2 := m.MarshalKey("initially", RecordListField_Field_Initially)
		if e2 == nil {
			e2 = rt.RecordListEval_Optional_Marshal(m, &val.Initially)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", RecordListField_Field_Initially))
		}
		m.EndBlock()
	}
	return
}

// RelationCardinality swaps between various options
type RelationCardinality struct {
	Choice string
	Value  interface{}
}

var RelationCardinality_Optional_Marshal = RelationCardinality_Marshal

const RelationCardinality_OneToOne_Opt = "$ONE_TO_ONE"
const RelationCardinality_OneToMany_Opt = "$ONE_TO_MANY"
const RelationCardinality_ManyToOne_Opt = "$MANY_TO_ONE"
const RelationCardinality_ManyToMany_Opt = "$MANY_TO_MANY"

func (*RelationCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: RelationCardinality_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			RelationCardinality_OneToOne_Opt, RelationCardinality_OneToMany_Opt, RelationCardinality_ManyToOne_Opt, RelationCardinality_ManyToMany_Opt,
		},
		Swaps: []interface{}{
			(*OneToOne)(nil),
			(*OneToMany)(nil),
			(*ManyToOne)(nil),
			(*ManyToMany)(nil),
		},
	}
}

const RelationCardinality_Type = "relation_cardinality"

func (op *RelationCardinality) GetType() string { return RelationCardinality_Type }

func (op *RelationCardinality) GetSwap() (string, interface{}) {
	return op.Choice, op.Value
}

func (op *RelationCardinality) SetSwap(c string) (okay bool) {
	switch c {
	case "":
		op.Choice, op.Value = c, nil
		okay = true
	case RelationCardinality_OneToOne_Opt:
		op.Choice, op.Value = c, new(OneToOne)
		okay = true
	case RelationCardinality_OneToMany_Opt:
		op.Choice, op.Value = c, new(OneToMany)
		okay = true
	case RelationCardinality_ManyToOne_Opt:
		op.Choice, op.Value = c, new(ManyToOne)
		okay = true
	case RelationCardinality_ManyToMany_Opt:
		op.Choice, op.Value = c, new(ManyToMany)
		okay = true
	}
	return
}

func (op *RelationCardinality) Marshal(m jsn.Marshaler) error {
	return RelationCardinality_Marshal(m, op)
}
func RelationCardinality_Marshal(m jsn.Marshaler, val *RelationCardinality) (err error) {
	if err = m.MarshalBlock(val); err == nil {
		if _, ptr := val.GetSwap(); ptr != nil {
			if e := ptr.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}

type RelationCardinality_Slice []RelationCardinality

func (op *RelationCardinality_Slice) GetType() string { return RelationCardinality_Type }

func (op *RelationCardinality_Slice) Marshal(m jsn.Marshaler) error {
	return RelationCardinality_Repeats_Marshal(m, (*[]RelationCardinality)(op))
}

func (op *RelationCardinality_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *RelationCardinality_Slice) SetSize(cnt int) {
	var els []RelationCardinality
	if cnt >= 0 {
		els = make(RelationCardinality_Slice, cnt)
	}
	(*op) = els
}

func (op *RelationCardinality_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return RelationCardinality_Marshal(m, &(*op)[i])
}

func RelationCardinality_Repeats_Marshal(m jsn.Marshaler, vals *[]RelationCardinality) error {
	return jsn.RepeatBlock(m, (*RelationCardinality_Slice)(vals))
}

func RelationCardinality_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]RelationCardinality) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = RelationCardinality_Repeats_Marshal(m, pv)
	}
	return
}

// RuleForKind Change the behavior of an existing pattern.
// The default behavior for events is to fall through to the next handler unless canceled or stopped.
type RuleForKind struct {
	PatternName rt.TextEval  `if:"label=for"`
	KindName    rt.TextEval  `if:"label=kind"`
	Exactly     rt.BoolEval  `if:"label=exactly,optional"`
	RuleName    rt.TextEval  `if:"label=named,optional"`
	Exe         []rt.Execute `if:"label=do"`
	Markup      map[string]any
}

// User implemented slots:
var _ StoryStatement = (*RuleForKind)(nil)
var _ rt.Execute = (*RuleForKind)(nil)

func (*RuleForKind) Compose() composer.Spec {
	return composer.Spec{
		Name: RuleForKind_Type,
		Uses: composer.Type_Flow,
		Lede: "rule",
	}
}

const RuleForKind_Type = "rule_for_kind"
const RuleForKind_Field_PatternName = "$PATTERN_NAME"
const RuleForKind_Field_KindName = "$KIND_NAME"
const RuleForKind_Field_Exactly = "$EXACTLY"
const RuleForKind_Field_RuleName = "$RULE_NAME"
const RuleForKind_Field_Exe = "$EXE"

func (op *RuleForKind) Marshal(m jsn.Marshaler) error {
	return RuleForKind_Marshal(m, op)
}

type RuleForKind_Slice []RuleForKind

func (op *RuleForKind_Slice) GetType() string { return RuleForKind_Type }

func (op *RuleForKind_Slice) Marshal(m jsn.Marshaler) error {
	return RuleForKind_Repeats_Marshal(m, (*[]RuleForKind)(op))
}

func (op *RuleForKind_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *RuleForKind_Slice) SetSize(cnt int) {
	var els []RuleForKind
	if cnt >= 0 {
		els = make(RuleForKind_Slice, cnt)
	}
	(*op) = els
}

func (op *RuleForKind_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return RuleForKind_Marshal(m, &(*op)[i])
}

func RuleForKind_Repeats_Marshal(m jsn.Marshaler, vals *[]RuleForKind) error {
	return jsn.RepeatBlock(m, (*RuleForKind_Slice)(vals))
}

func RuleForKind_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]RuleForKind) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = RuleForKind_Repeats_Marshal(m, pv)
	}
	return
}

type RuleForKind_Flow struct{ ptr *RuleForKind }

func (n RuleForKind_Flow) GetType() string      { return RuleForKind_Type }
func (n RuleForKind_Flow) GetLede() string      { return "rule" }
func (n RuleForKind_Flow) GetFlow() interface{} { return n.ptr }
func (n RuleForKind_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*RuleForKind); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func RuleForKind_Optional_Marshal(m jsn.Marshaler, pv **RuleForKind) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = RuleForKind_Marshal(m, *pv)
	} else if !enc {
		var v RuleForKind
		if err = RuleForKind_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func RuleForKind_Marshal(m jsn.Marshaler, val *RuleForKind) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(RuleForKind_Flow{val}); err == nil {
		e0 := m.MarshalKey("for", RuleForKind_Field_PatternName)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.PatternName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", RuleForKind_Field_PatternName))
		}
		e1 := m.MarshalKey("kind", RuleForKind_Field_KindName)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.KindName)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", RuleForKind_Field_KindName))
		}
		e2 := m.MarshalKey("exactly", RuleForKind_Field_Exactly)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Exactly)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", RuleForKind_Field_Exactly))
		}
		e3 := m.MarshalKey("named", RuleForKind_Field_RuleName)
		if e3 == nil {
			e3 = rt.TextEval_Optional_Marshal(m, &val.RuleName)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", RuleForKind_Field_RuleName))
		}
		e4 := m.MarshalKey("do", RuleForKind_Field_Exe)
		if e4 == nil {
			e4 = rt.Execute_Repeats_Marshal(m, &val.Exe)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", RuleForKind_Field_Exe))
		}
		m.EndBlock()
	}
	return
}

// RuleForNoun Change the behavior of an existing pattern.
// The default behavior for events is to fall through to the next handler unless canceled or stopped.
type RuleForNoun struct {
	PatternName rt.TextEval  `if:"label=for"`
	NounName    rt.TextEval  `if:"label=noun"`
	RuleName    rt.TextEval  `if:"label=named,optional"`
	Exe         []rt.Execute `if:"label=do"`
	Markup      map[string]any
}

// User implemented slots:
var _ StoryStatement = (*RuleForNoun)(nil)
var _ rt.Execute = (*RuleForNoun)(nil)

func (*RuleForNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: RuleForNoun_Type,
		Uses: composer.Type_Flow,
		Lede: "rule",
	}
}

const RuleForNoun_Type = "rule_for_noun"
const RuleForNoun_Field_PatternName = "$PATTERN_NAME"
const RuleForNoun_Field_NounName = "$NOUN_NAME"
const RuleForNoun_Field_RuleName = "$RULE_NAME"
const RuleForNoun_Field_Exe = "$EXE"

func (op *RuleForNoun) Marshal(m jsn.Marshaler) error {
	return RuleForNoun_Marshal(m, op)
}

type RuleForNoun_Slice []RuleForNoun

func (op *RuleForNoun_Slice) GetType() string { return RuleForNoun_Type }

func (op *RuleForNoun_Slice) Marshal(m jsn.Marshaler) error {
	return RuleForNoun_Repeats_Marshal(m, (*[]RuleForNoun)(op))
}

func (op *RuleForNoun_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *RuleForNoun_Slice) SetSize(cnt int) {
	var els []RuleForNoun
	if cnt >= 0 {
		els = make(RuleForNoun_Slice, cnt)
	}
	(*op) = els
}

func (op *RuleForNoun_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return RuleForNoun_Marshal(m, &(*op)[i])
}

func RuleForNoun_Repeats_Marshal(m jsn.Marshaler, vals *[]RuleForNoun) error {
	return jsn.RepeatBlock(m, (*RuleForNoun_Slice)(vals))
}

func RuleForNoun_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]RuleForNoun) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = RuleForNoun_Repeats_Marshal(m, pv)
	}
	return
}

type RuleForNoun_Flow struct{ ptr *RuleForNoun }

func (n RuleForNoun_Flow) GetType() string      { return RuleForNoun_Type }
func (n RuleForNoun_Flow) GetLede() string      { return "rule" }
func (n RuleForNoun_Flow) GetFlow() interface{} { return n.ptr }
func (n RuleForNoun_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*RuleForNoun); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func RuleForNoun_Optional_Marshal(m jsn.Marshaler, pv **RuleForNoun) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = RuleForNoun_Marshal(m, *pv)
	} else if !enc {
		var v RuleForNoun
		if err = RuleForNoun_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func RuleForNoun_Marshal(m jsn.Marshaler, val *RuleForNoun) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(RuleForNoun_Flow{val}); err == nil {
		e0 := m.MarshalKey("for", RuleForNoun_Field_PatternName)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.PatternName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", RuleForNoun_Field_PatternName))
		}
		e1 := m.MarshalKey("noun", RuleForNoun_Field_NounName)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.NounName)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", RuleForNoun_Field_NounName))
		}
		e2 := m.MarshalKey("named", RuleForNoun_Field_RuleName)
		if e2 == nil {
			e2 = rt.TextEval_Optional_Marshal(m, &val.RuleName)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", RuleForNoun_Field_RuleName))
		}
		e3 := m.MarshalKey("do", RuleForNoun_Field_Exe)
		if e3 == nil {
			e3 = rt.Execute_Repeats_Marshal(m, &val.Exe)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", RuleForNoun_Field_Exe))
		}
		m.EndBlock()
	}
	return
}

// RuleForPattern Change the behavior of an existing pattern.
// For events, this adds a listener that responds to the targeted object only when triggered by the player.
// By default, rules with filters continue on to the next rule automatically.
// Because event listeners have filters they continue to the next listener unless specifically stopped.
type RuleForPattern struct {
	PatternName rt.TextEval  `if:"label=for"`
	RuleName    rt.TextEval  `if:"label=named,optional"`
	Exe         []rt.Execute `if:"label=do"`
	Markup      map[string]any
}

// User implemented slots:
var _ StoryStatement = (*RuleForPattern)(nil)
var _ rt.Execute = (*RuleForPattern)(nil)

func (*RuleForPattern) Compose() composer.Spec {
	return composer.Spec{
		Name: RuleForPattern_Type,
		Uses: composer.Type_Flow,
		Lede: "rule",
	}
}

const RuleForPattern_Type = "rule_for_pattern"
const RuleForPattern_Field_PatternName = "$PATTERN_NAME"
const RuleForPattern_Field_RuleName = "$RULE_NAME"
const RuleForPattern_Field_Exe = "$EXE"

func (op *RuleForPattern) Marshal(m jsn.Marshaler) error {
	return RuleForPattern_Marshal(m, op)
}

type RuleForPattern_Slice []RuleForPattern

func (op *RuleForPattern_Slice) GetType() string { return RuleForPattern_Type }

func (op *RuleForPattern_Slice) Marshal(m jsn.Marshaler) error {
	return RuleForPattern_Repeats_Marshal(m, (*[]RuleForPattern)(op))
}

func (op *RuleForPattern_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *RuleForPattern_Slice) SetSize(cnt int) {
	var els []RuleForPattern
	if cnt >= 0 {
		els = make(RuleForPattern_Slice, cnt)
	}
	(*op) = els
}

func (op *RuleForPattern_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return RuleForPattern_Marshal(m, &(*op)[i])
}

func RuleForPattern_Repeats_Marshal(m jsn.Marshaler, vals *[]RuleForPattern) error {
	return jsn.RepeatBlock(m, (*RuleForPattern_Slice)(vals))
}

func RuleForPattern_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]RuleForPattern) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = RuleForPattern_Repeats_Marshal(m, pv)
	}
	return
}

type RuleForPattern_Flow struct{ ptr *RuleForPattern }

func (n RuleForPattern_Flow) GetType() string      { return RuleForPattern_Type }
func (n RuleForPattern_Flow) GetLede() string      { return "rule" }
func (n RuleForPattern_Flow) GetFlow() interface{} { return n.ptr }
func (n RuleForPattern_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*RuleForPattern); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func RuleForPattern_Optional_Marshal(m jsn.Marshaler, pv **RuleForPattern) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = RuleForPattern_Marshal(m, *pv)
	} else if !enc {
		var v RuleForPattern
		if err = RuleForPattern_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func RuleForPattern_Marshal(m jsn.Marshaler, val *RuleForPattern) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(RuleForPattern_Flow{val}); err == nil {
		e0 := m.MarshalKey("for", RuleForPattern_Field_PatternName)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.PatternName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", RuleForPattern_Field_PatternName))
		}
		e1 := m.MarshalKey("named", RuleForPattern_Field_RuleName)
		if e1 == nil {
			e1 = rt.TextEval_Optional_Marshal(m, &val.RuleName)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", RuleForPattern_Field_RuleName))
		}
		e2 := m.MarshalKey("do", RuleForPattern_Field_Exe)
		if e2 == nil {
			e2 = rt.Execute_Repeats_Marshal(m, &val.Exe)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", RuleForPattern_Field_Exe))
		}
		m.EndBlock()
	}
	return
}

// SayResponse Generate text in a replaceable manner.
// ( note: this is transformed for the runtime into a named 'RenderResponse'. )
type SayResponse struct {
	Name   string      `if:"label=response,type=text"`
	Text   rt.TextEval `if:"label=with"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*SayResponse)(nil)
var _ rt.TextEval = (*SayResponse)(nil)

func (*SayResponse) Compose() composer.Spec {
	return composer.Spec{
		Name: SayResponse_Type,
		Uses: composer.Type_Flow,
		Lede: "say",
	}
}

const SayResponse_Type = "say_response"
const SayResponse_Field_Name = "$NAME"
const SayResponse_Field_Text = "$TEXT"

func (op *SayResponse) Marshal(m jsn.Marshaler) error {
	return SayResponse_Marshal(m, op)
}

type SayResponse_Slice []SayResponse

func (op *SayResponse_Slice) GetType() string { return SayResponse_Type }

func (op *SayResponse_Slice) Marshal(m jsn.Marshaler) error {
	return SayResponse_Repeats_Marshal(m, (*[]SayResponse)(op))
}

func (op *SayResponse_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *SayResponse_Slice) SetSize(cnt int) {
	var els []SayResponse
	if cnt >= 0 {
		els = make(SayResponse_Slice, cnt)
	}
	(*op) = els
}

func (op *SayResponse_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return SayResponse_Marshal(m, &(*op)[i])
}

func SayResponse_Repeats_Marshal(m jsn.Marshaler, vals *[]SayResponse) error {
	return jsn.RepeatBlock(m, (*SayResponse_Slice)(vals))
}

func SayResponse_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]SayResponse) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = SayResponse_Repeats_Marshal(m, pv)
	}
	return
}

type SayResponse_Flow struct{ ptr *SayResponse }

func (n SayResponse_Flow) GetType() string      { return SayResponse_Type }
func (n SayResponse_Flow) GetLede() string      { return "say" }
func (n SayResponse_Flow) GetFlow() interface{} { return n.ptr }
func (n SayResponse_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*SayResponse); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func SayResponse_Optional_Marshal(m jsn.Marshaler, pv **SayResponse) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = SayResponse_Marshal(m, *pv)
	} else if !enc {
		var v SayResponse
		if err = SayResponse_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func SayResponse_Marshal(m jsn.Marshaler, val *SayResponse) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(SayResponse_Flow{val}); err == nil {
		e0 := m.MarshalKey("response", SayResponse_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", SayResponse_Field_Name))
		}
		e1 := m.MarshalKey("with", SayResponse_Field_Text)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Text)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", SayResponse_Field_Text))
		}
		m.EndBlock()
	}
	return
}

// SayTemplate Used for displaying text to the player.
// The text can contain 'inline-templates';
// mini-commands that help to simplify printing text.
// See also: https://github.com/ionous/iffy/wiki/Templates.
// ( note: this is transformed for the runtime into an unnamed 'RenderResponse'. )
type SayTemplate struct {
	Template prim.Lines `if:"label=_"`
	Markup   map[string]any
}

// User implemented slots:
var _ rt.Execute = (*SayTemplate)(nil)
var _ rt.TextEval = (*SayTemplate)(nil)

func (*SayTemplate) Compose() composer.Spec {
	return composer.Spec{
		Name: SayTemplate_Type,
		Uses: composer.Type_Flow,
		Lede: "say",
	}
}

const SayTemplate_Type = "say_template"
const SayTemplate_Field_Template = "$TEMPLATE"

func (op *SayTemplate) Marshal(m jsn.Marshaler) error {
	return SayTemplate_Marshal(m, op)
}

type SayTemplate_Slice []SayTemplate

func (op *SayTemplate_Slice) GetType() string { return SayTemplate_Type }

func (op *SayTemplate_Slice) Marshal(m jsn.Marshaler) error {
	return SayTemplate_Repeats_Marshal(m, (*[]SayTemplate)(op))
}

func (op *SayTemplate_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *SayTemplate_Slice) SetSize(cnt int) {
	var els []SayTemplate
	if cnt >= 0 {
		els = make(SayTemplate_Slice, cnt)
	}
	(*op) = els
}

func (op *SayTemplate_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return SayTemplate_Marshal(m, &(*op)[i])
}

func SayTemplate_Repeats_Marshal(m jsn.Marshaler, vals *[]SayTemplate) error {
	return jsn.RepeatBlock(m, (*SayTemplate_Slice)(vals))
}

func SayTemplate_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]SayTemplate) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = SayTemplate_Repeats_Marshal(m, pv)
	}
	return
}

type SayTemplate_Flow struct{ ptr *SayTemplate }

func (n SayTemplate_Flow) GetType() string      { return SayTemplate_Type }
func (n SayTemplate_Flow) GetLede() string      { return "say" }
func (n SayTemplate_Flow) GetFlow() interface{} { return n.ptr }
func (n SayTemplate_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*SayTemplate); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func SayTemplate_Optional_Marshal(m jsn.Marshaler, pv **SayTemplate) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = SayTemplate_Marshal(m, *pv)
	} else if !enc {
		var v SayTemplate
		if err = SayTemplate_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func SayTemplate_Marshal(m jsn.Marshaler, val *SayTemplate) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(SayTemplate_Flow{val}); err == nil {
		e0 := m.MarshalKey("", SayTemplate_Field_Template)
		if e0 == nil {
			e0 = prim.Lines_Marshal(m, &val.Template)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", SayTemplate_Field_Template))
		}
		m.EndBlock()
	}
	return
}

// ShuffleText When called multiple times returns its inputs at random.
type ShuffleText struct {
	Parts  []rt.TextEval `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.TextEval = (*ShuffleText)(nil)

func (*ShuffleText) Compose() composer.Spec {
	return composer.Spec{
		Name: ShuffleText_Type,
		Uses: composer.Type_Flow,
	}
}

const ShuffleText_Type = "shuffle_text"
const ShuffleText_Field_Parts = "$PARTS"

func (op *ShuffleText) Marshal(m jsn.Marshaler) error {
	return ShuffleText_Marshal(m, op)
}

type ShuffleText_Slice []ShuffleText

func (op *ShuffleText_Slice) GetType() string { return ShuffleText_Type }

func (op *ShuffleText_Slice) Marshal(m jsn.Marshaler) error {
	return ShuffleText_Repeats_Marshal(m, (*[]ShuffleText)(op))
}

func (op *ShuffleText_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ShuffleText_Slice) SetSize(cnt int) {
	var els []ShuffleText
	if cnt >= 0 {
		els = make(ShuffleText_Slice, cnt)
	}
	(*op) = els
}

func (op *ShuffleText_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ShuffleText_Marshal(m, &(*op)[i])
}

func ShuffleText_Repeats_Marshal(m jsn.Marshaler, vals *[]ShuffleText) error {
	return jsn.RepeatBlock(m, (*ShuffleText_Slice)(vals))
}

func ShuffleText_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ShuffleText) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ShuffleText_Repeats_Marshal(m, pv)
	}
	return
}

type ShuffleText_Flow struct{ ptr *ShuffleText }

func (n ShuffleText_Flow) GetType() string      { return ShuffleText_Type }
func (n ShuffleText_Flow) GetLede() string      { return ShuffleText_Type }
func (n ShuffleText_Flow) GetFlow() interface{} { return n.ptr }
func (n ShuffleText_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ShuffleText); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ShuffleText_Optional_Marshal(m jsn.Marshaler, pv **ShuffleText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ShuffleText_Marshal(m, *pv)
	} else if !enc {
		var v ShuffleText
		if err = ShuffleText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ShuffleText_Marshal(m jsn.Marshaler, val *ShuffleText) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ShuffleText_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ShuffleText_Field_Parts)
		if e0 == nil {
			e0 = rt.TextEval_Repeats_Marshal(m, &val.Parts)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ShuffleText_Field_Parts))
		}
		m.EndBlock()
	}
	return
}

// StoppingText When called multiple times returns each of its inputs in turn, sticking to the last one.
type StoppingText struct {
	Parts  []rt.TextEval `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.TextEval = (*StoppingText)(nil)

func (*StoppingText) Compose() composer.Spec {
	return composer.Spec{
		Name: StoppingText_Type,
		Uses: composer.Type_Flow,
	}
}

const StoppingText_Type = "stopping_text"
const StoppingText_Field_Parts = "$PARTS"

func (op *StoppingText) Marshal(m jsn.Marshaler) error {
	return StoppingText_Marshal(m, op)
}

type StoppingText_Slice []StoppingText

func (op *StoppingText_Slice) GetType() string { return StoppingText_Type }

func (op *StoppingText_Slice) Marshal(m jsn.Marshaler) error {
	return StoppingText_Repeats_Marshal(m, (*[]StoppingText)(op))
}

func (op *StoppingText_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *StoppingText_Slice) SetSize(cnt int) {
	var els []StoppingText
	if cnt >= 0 {
		els = make(StoppingText_Slice, cnt)
	}
	(*op) = els
}

func (op *StoppingText_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return StoppingText_Marshal(m, &(*op)[i])
}

func StoppingText_Repeats_Marshal(m jsn.Marshaler, vals *[]StoppingText) error {
	return jsn.RepeatBlock(m, (*StoppingText_Slice)(vals))
}

func StoppingText_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]StoppingText) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = StoppingText_Repeats_Marshal(m, pv)
	}
	return
}

type StoppingText_Flow struct{ ptr *StoppingText }

func (n StoppingText_Flow) GetType() string      { return StoppingText_Type }
func (n StoppingText_Flow) GetLede() string      { return StoppingText_Type }
func (n StoppingText_Flow) GetFlow() interface{} { return n.ptr }
func (n StoppingText_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*StoppingText); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func StoppingText_Optional_Marshal(m jsn.Marshaler, pv **StoppingText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = StoppingText_Marshal(m, *pv)
	} else if !enc {
		var v StoppingText
		if err = StoppingText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func StoppingText_Marshal(m jsn.Marshaler, val *StoppingText) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(StoppingText_Flow{val}); err == nil {
		e0 := m.MarshalKey("", StoppingText_Field_Parts)
		if e0 == nil {
			e0 = rt.TextEval_Repeats_Marshal(m, &val.Parts)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", StoppingText_Field_Parts))
		}
		m.EndBlock()
	}
	return
}

// StoryAlias allows the player to refer to a noun by one or more other terms.
type StoryAlias struct {
	Names  []string `if:"label=alias,type=text"`
	AsNoun string   `if:"label=as_noun,type=text"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*StoryAlias)(nil)
var _ StoryStatement = (*StoryAlias)(nil)

func (*StoryAlias) Compose() composer.Spec {
	return composer.Spec{
		Name: StoryAlias_Type,
		Uses: composer.Type_Flow,
		Lede: "interpret",
	}
}

const StoryAlias_Type = "story_alias"
const StoryAlias_Field_Names = "$NAMES"
const StoryAlias_Field_AsNoun = "$AS_NOUN"

func (op *StoryAlias) Marshal(m jsn.Marshaler) error {
	return StoryAlias_Marshal(m, op)
}

type StoryAlias_Slice []StoryAlias

func (op *StoryAlias_Slice) GetType() string { return StoryAlias_Type }

func (op *StoryAlias_Slice) Marshal(m jsn.Marshaler) error {
	return StoryAlias_Repeats_Marshal(m, (*[]StoryAlias)(op))
}

func (op *StoryAlias_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *StoryAlias_Slice) SetSize(cnt int) {
	var els []StoryAlias
	if cnt >= 0 {
		els = make(StoryAlias_Slice, cnt)
	}
	(*op) = els
}

func (op *StoryAlias_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return StoryAlias_Marshal(m, &(*op)[i])
}

func StoryAlias_Repeats_Marshal(m jsn.Marshaler, vals *[]StoryAlias) error {
	return jsn.RepeatBlock(m, (*StoryAlias_Slice)(vals))
}

func StoryAlias_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]StoryAlias) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = StoryAlias_Repeats_Marshal(m, pv)
	}
	return
}

type StoryAlias_Flow struct{ ptr *StoryAlias }

func (n StoryAlias_Flow) GetType() string      { return StoryAlias_Type }
func (n StoryAlias_Flow) GetLede() string      { return "interpret" }
func (n StoryAlias_Flow) GetFlow() interface{} { return n.ptr }
func (n StoryAlias_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*StoryAlias); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func StoryAlias_Optional_Marshal(m jsn.Marshaler, pv **StoryAlias) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = StoryAlias_Marshal(m, *pv)
	} else if !enc {
		var v StoryAlias
		if err = StoryAlias_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func StoryAlias_Marshal(m jsn.Marshaler, val *StoryAlias) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(StoryAlias_Flow{val}); err == nil {
		e0 := m.MarshalKey("alias", StoryAlias_Field_Names)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Repeats_Marshal(m, &val.Names)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", StoryAlias_Field_Names))
		}
		e1 := m.MarshalKey("as_noun", StoryAlias_Field_AsNoun)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.AsNoun)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", StoryAlias_Field_AsNoun))
		}
		m.EndBlock()
	}
	return
}

// StoryBreak a command with a signature of the comment marker metadata.
// a cheat to allows nodes that have only a comment marker and no actual command.
// see also: debug.do_nothing
type StoryBreak struct {
	Markup map[string]any
}

// User implemented slots:
var _ StoryStatement = (*StoryBreak)(nil)

func (*StoryBreak) Compose() composer.Spec {
	return composer.Spec{
		Name: StoryBreak_Type,
		Uses: composer.Type_Flow,
		Lede: "--",
	}
}

const StoryBreak_Type = "story_break"

func (op *StoryBreak) Marshal(m jsn.Marshaler) error {
	return StoryBreak_Marshal(m, op)
}

type StoryBreak_Slice []StoryBreak

func (op *StoryBreak_Slice) GetType() string { return StoryBreak_Type }

func (op *StoryBreak_Slice) Marshal(m jsn.Marshaler) error {
	return StoryBreak_Repeats_Marshal(m, (*[]StoryBreak)(op))
}

func (op *StoryBreak_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *StoryBreak_Slice) SetSize(cnt int) {
	var els []StoryBreak
	if cnt >= 0 {
		els = make(StoryBreak_Slice, cnt)
	}
	(*op) = els
}

func (op *StoryBreak_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return StoryBreak_Marshal(m, &(*op)[i])
}

func StoryBreak_Repeats_Marshal(m jsn.Marshaler, vals *[]StoryBreak) error {
	return jsn.RepeatBlock(m, (*StoryBreak_Slice)(vals))
}

func StoryBreak_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]StoryBreak) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = StoryBreak_Repeats_Marshal(m, pv)
	}
	return
}

type StoryBreak_Flow struct{ ptr *StoryBreak }

func (n StoryBreak_Flow) GetType() string      { return StoryBreak_Type }
func (n StoryBreak_Flow) GetLede() string      { return "--" }
func (n StoryBreak_Flow) GetFlow() interface{} { return n.ptr }
func (n StoryBreak_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*StoryBreak); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func StoryBreak_Optional_Marshal(m jsn.Marshaler, pv **StoryBreak) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = StoryBreak_Marshal(m, *pv)
	} else if !enc {
		var v StoryBreak
		if err = StoryBreak_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func StoryBreak_Marshal(m jsn.Marshaler, val *StoryBreak) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(StoryBreak_Flow{val}); err == nil {
		m.EndBlock()
	}
	return
}

// StoryDirective starts a parser scanner.
type StoryDirective struct {
	Lede   []string               `if:"label=_,type=text"`
	Scans  []grammar.ScannerMaker `if:"label=with"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*StoryDirective)(nil)
var _ StoryStatement = (*StoryDirective)(nil)

func (*StoryDirective) Compose() composer.Spec {
	return composer.Spec{
		Name: StoryDirective_Type,
		Uses: composer.Type_Flow,
		Lede: "interpret",
	}
}

const StoryDirective_Type = "story_directive"
const StoryDirective_Field_Lede = "$LEDE"
const StoryDirective_Field_Scans = "$SCANS"

func (op *StoryDirective) Marshal(m jsn.Marshaler) error {
	return StoryDirective_Marshal(m, op)
}

type StoryDirective_Slice []StoryDirective

func (op *StoryDirective_Slice) GetType() string { return StoryDirective_Type }

func (op *StoryDirective_Slice) Marshal(m jsn.Marshaler) error {
	return StoryDirective_Repeats_Marshal(m, (*[]StoryDirective)(op))
}

func (op *StoryDirective_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *StoryDirective_Slice) SetSize(cnt int) {
	var els []StoryDirective
	if cnt >= 0 {
		els = make(StoryDirective_Slice, cnt)
	}
	(*op) = els
}

func (op *StoryDirective_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return StoryDirective_Marshal(m, &(*op)[i])
}

func StoryDirective_Repeats_Marshal(m jsn.Marshaler, vals *[]StoryDirective) error {
	return jsn.RepeatBlock(m, (*StoryDirective_Slice)(vals))
}

func StoryDirective_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]StoryDirective) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = StoryDirective_Repeats_Marshal(m, pv)
	}
	return
}

type StoryDirective_Flow struct{ ptr *StoryDirective }

func (n StoryDirective_Flow) GetType() string      { return StoryDirective_Type }
func (n StoryDirective_Flow) GetLede() string      { return "interpret" }
func (n StoryDirective_Flow) GetFlow() interface{} { return n.ptr }
func (n StoryDirective_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*StoryDirective); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func StoryDirective_Optional_Marshal(m jsn.Marshaler, pv **StoryDirective) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = StoryDirective_Marshal(m, *pv)
	} else if !enc {
		var v StoryDirective
		if err = StoryDirective_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func StoryDirective_Marshal(m jsn.Marshaler, val *StoryDirective) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(StoryDirective_Flow{val}); err == nil {
		e0 := m.MarshalKey("", StoryDirective_Field_Lede)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Repeats_Marshal(m, &val.Lede)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", StoryDirective_Field_Lede))
		}
		e1 := m.MarshalKey("with", StoryDirective_Field_Scans)
		if e1 == nil {
			e1 = grammar.ScannerMaker_Repeats_Marshal(m, &val.Scans)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", StoryDirective_Field_Scans))
		}
		m.EndBlock()
	}
	return
}

// StoryFile top level node, currently just for blockly might eventually contain story metadata  ex. author, description...
type StoryFile struct {
	StoryStatements []StoryStatement `if:"label=_"`
	Markup          map[string]any
}

func (*StoryFile) Compose() composer.Spec {
	return composer.Spec{
		Name: StoryFile_Type,
		Uses: composer.Type_Flow,
		Lede: "tapestry",
	}
}

const StoryFile_Type = "story_file"
const StoryFile_Field_StoryStatements = "$STORY_STATEMENTS"

func (op *StoryFile) Marshal(m jsn.Marshaler) error {
	return StoryFile_Marshal(m, op)
}

type StoryFile_Slice []StoryFile

func (op *StoryFile_Slice) GetType() string { return StoryFile_Type }

func (op *StoryFile_Slice) Marshal(m jsn.Marshaler) error {
	return StoryFile_Repeats_Marshal(m, (*[]StoryFile)(op))
}

func (op *StoryFile_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *StoryFile_Slice) SetSize(cnt int) {
	var els []StoryFile
	if cnt >= 0 {
		els = make(StoryFile_Slice, cnt)
	}
	(*op) = els
}

func (op *StoryFile_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return StoryFile_Marshal(m, &(*op)[i])
}

func StoryFile_Repeats_Marshal(m jsn.Marshaler, vals *[]StoryFile) error {
	return jsn.RepeatBlock(m, (*StoryFile_Slice)(vals))
}

func StoryFile_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]StoryFile) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = StoryFile_Repeats_Marshal(m, pv)
	}
	return
}

type StoryFile_Flow struct{ ptr *StoryFile }

func (n StoryFile_Flow) GetType() string      { return StoryFile_Type }
func (n StoryFile_Flow) GetLede() string      { return "tapestry" }
func (n StoryFile_Flow) GetFlow() interface{} { return n.ptr }
func (n StoryFile_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*StoryFile); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func StoryFile_Optional_Marshal(m jsn.Marshaler, pv **StoryFile) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = StoryFile_Marshal(m, *pv)
	} else if !enc {
		var v StoryFile
		if err = StoryFile_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func StoryFile_Marshal(m jsn.Marshaler, val *StoryFile) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(StoryFile_Flow{val}); err == nil {
		e0 := m.MarshalKey("", StoryFile_Field_StoryStatements)
		if e0 == nil {
			e0 = StoryStatement_Repeats_Marshal(m, &val.StoryStatements)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", StoryFile_Field_StoryStatements))
		}
		m.EndBlock()
	}
	return
}

const StoryStatement_Type = "story_statement"

var StoryStatement_Optional_Marshal = StoryStatement_Marshal

type StoryStatement_Slot struct{ Value *StoryStatement }

func (at StoryStatement_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at StoryStatement_Slot) GetType() string              { return StoryStatement_Type }
func (at StoryStatement_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at StoryStatement_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(StoryStatement)
	return
}

func StoryStatement_Marshal(m jsn.Marshaler, ptr *StoryStatement) (err error) {
	slot := StoryStatement_Slot{ptr}
	return slot.Marshal(m)
}

type StoryStatement_Slice []StoryStatement

func (op *StoryStatement_Slice) GetType() string { return StoryStatement_Type }

func (op *StoryStatement_Slice) Marshal(m jsn.Marshaler) error {
	return StoryStatement_Repeats_Marshal(m, (*[]StoryStatement)(op))
}

func (op *StoryStatement_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *StoryStatement_Slice) SetSize(cnt int) {
	var els []StoryStatement
	if cnt >= 0 {
		els = make(StoryStatement_Slice, cnt)
	}
	(*op) = els
}

func (op *StoryStatement_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return StoryStatement_Marshal(m, &(*op)[i])
}

func StoryStatement_Repeats_Marshal(m jsn.Marshaler, vals *[]StoryStatement) error {
	return jsn.RepeatBlock(m, (*StoryStatement_Slice)(vals))
}

func StoryStatement_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]StoryStatement) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = StoryStatement_Repeats_Marshal(m, pv)
	}
	return
}

// Test Create a scene
type Test struct {
	TestName       TestName         `if:"label=_"`
	DependsOn      TestName         `if:"label=depends_on,optional"`
	TestStatements []StoryStatement `if:"label=with_scene,optional"`
	Exe            []rt.Execute     `if:"label=do"`
	Markup         map[string]any
}

// User implemented slots:
var _ StoryStatement = (*Test)(nil)
var _ rt.Execute = (*Test)(nil)

func (*Test) Compose() composer.Spec {
	return composer.Spec{
		Name: Test_Type,
		Uses: composer.Type_Flow,
	}
}

const Test_Type = "test"
const Test_Field_TestName = "$TEST_NAME"
const Test_Field_DependsOn = "$DEPENDS_ON"
const Test_Field_TestStatements = "$TEST_STATEMENTS"
const Test_Field_Exe = "$EXE"

func (op *Test) Marshal(m jsn.Marshaler) error {
	return Test_Marshal(m, op)
}

type Test_Slice []Test

func (op *Test_Slice) GetType() string { return Test_Type }

func (op *Test_Slice) Marshal(m jsn.Marshaler) error {
	return Test_Repeats_Marshal(m, (*[]Test)(op))
}

func (op *Test_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Test_Slice) SetSize(cnt int) {
	var els []Test
	if cnt >= 0 {
		els = make(Test_Slice, cnt)
	}
	(*op) = els
}

func (op *Test_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Test_Marshal(m, &(*op)[i])
}

func Test_Repeats_Marshal(m jsn.Marshaler, vals *[]Test) error {
	return jsn.RepeatBlock(m, (*Test_Slice)(vals))
}

func Test_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Test) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Test_Repeats_Marshal(m, pv)
	}
	return
}

type Test_Flow struct{ ptr *Test }

func (n Test_Flow) GetType() string      { return Test_Type }
func (n Test_Flow) GetLede() string      { return Test_Type }
func (n Test_Flow) GetFlow() interface{} { return n.ptr }
func (n Test_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Test); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Test_Optional_Marshal(m jsn.Marshaler, pv **Test) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Test_Marshal(m, *pv)
	} else if !enc {
		var v Test
		if err = Test_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Test_Marshal(m jsn.Marshaler, val *Test) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Test_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Test_Field_TestName)
		if e0 == nil {
			e0 = TestName_Marshal(m, &val.TestName)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Test_Field_TestName))
		}
		e1 := m.MarshalKey("depends_on", Test_Field_DependsOn)
		if e1 == nil {
			e1 = TestName_Optional_Marshal(m, &val.DependsOn)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Test_Field_DependsOn))
		}
		e2 := m.MarshalKey("with_scene", Test_Field_TestStatements)
		if e2 == nil {
			e2 = StoryStatement_Optional_Repeats_Marshal(m, &val.TestStatements)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Test_Field_TestStatements))
		}
		e3 := m.MarshalKey("do", Test_Field_Exe)
		if e3 == nil {
			e3 = rt.Execute_Repeats_Marshal(m, &val.Exe)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", Test_Field_Exe))
		}
		m.EndBlock()
	}
	return
}

// TestName requires a predefined or user-specified string.
type TestName struct {
	Str string
}

func (op *TestName) String() string {
	return op.Str
}

const TestName_CurrentTest = "$CURRENT_TEST"

func (*TestName) Compose() composer.Spec {
	return composer.Spec{
		Name:        TestName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			TestName_CurrentTest,
		},
		Strings: []string{
			"current_test",
		},
	}
}

const TestName_Type = "test_name"

func (op *TestName) Marshal(m jsn.Marshaler) error {
	return TestName_Marshal(m, op)
}

func TestName_Optional_Marshal(m jsn.Marshaler, val *TestName) (err error) {
	var zero TestName
	if enc := m.IsEncoding(); !enc || val.Str != zero.Str {
		err = TestName_Marshal(m, val)
	}
	return
}

func TestName_Marshal(m jsn.Marshaler, val *TestName) (err error) {
	return m.MarshalValue(TestName_Type, jsn.MakeEnum(val, &val.Str))
}

type TestName_Slice []TestName

func (op *TestName_Slice) GetType() string { return TestName_Type }

func (op *TestName_Slice) Marshal(m jsn.Marshaler) error {
	return TestName_Repeats_Marshal(m, (*[]TestName)(op))
}

func (op *TestName_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TestName_Slice) SetSize(cnt int) {
	var els []TestName
	if cnt >= 0 {
		els = make(TestName_Slice, cnt)
	}
	(*op) = els
}

func (op *TestName_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TestName_Marshal(m, &(*op)[i])
}

func TestName_Repeats_Marshal(m jsn.Marshaler, vals *[]TestName) error {
	return jsn.RepeatBlock(m, (*TestName_Slice)(vals))
}

func TestName_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TestName) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TestName_Repeats_Marshal(m, pv)
	}
	return
}

// TextField
type TextField struct {
	Name      string      `if:"label=_,type=text"`
	Type      string      `if:"label=kind,optional,type=text"`
	Initially rt.TextEval `if:"label=initially,optional"`
	Markup    map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*TextField)(nil)

func (*TextField) Compose() composer.Spec {
	return composer.Spec{
		Name: TextField_Type,
		Uses: composer.Type_Flow,
		Lede: "text",
	}
}

const TextField_Type = "text_field"
const TextField_Field_Name = "$NAME"
const TextField_Field_Type = "$TYPE"
const TextField_Field_Initially = "$INITIALLY"

func (op *TextField) Marshal(m jsn.Marshaler) error {
	return TextField_Marshal(m, op)
}

type TextField_Slice []TextField

func (op *TextField_Slice) GetType() string { return TextField_Type }

func (op *TextField_Slice) Marshal(m jsn.Marshaler) error {
	return TextField_Repeats_Marshal(m, (*[]TextField)(op))
}

func (op *TextField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TextField_Slice) SetSize(cnt int) {
	var els []TextField
	if cnt >= 0 {
		els = make(TextField_Slice, cnt)
	}
	(*op) = els
}

func (op *TextField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TextField_Marshal(m, &(*op)[i])
}

func TextField_Repeats_Marshal(m jsn.Marshaler, vals *[]TextField) error {
	return jsn.RepeatBlock(m, (*TextField_Slice)(vals))
}

func TextField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TextField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TextField_Repeats_Marshal(m, pv)
	}
	return
}

type TextField_Flow struct{ ptr *TextField }

func (n TextField_Flow) GetType() string      { return TextField_Type }
func (n TextField_Flow) GetLede() string      { return "text" }
func (n TextField_Flow) GetFlow() interface{} { return n.ptr }
func (n TextField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*TextField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func TextField_Optional_Marshal(m jsn.Marshaler, pv **TextField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = TextField_Marshal(m, *pv)
	} else if !enc {
		var v TextField
		if err = TextField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func TextField_Marshal(m jsn.Marshaler, val *TextField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(TextField_Flow{val}); err == nil {
		e0 := m.MarshalKey("", TextField_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", TextField_Field_Name))
		}
		e1 := m.MarshalKey("kind", TextField_Field_Type)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Optional_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", TextField_Field_Type))
		}
		e2 := m.MarshalKey("initially", TextField_Field_Initially)
		if e2 == nil {
			e2 = rt.TextEval_Optional_Marshal(m, &val.Initially)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", TextField_Field_Initially))
		}
		m.EndBlock()
	}
	return
}

// TextListField
type TextListField struct {
	Name      string          `if:"label=_,type=text"`
	Type      string          `if:"label=kind,optional,type=text"`
	Initially rt.TextListEval `if:"label=initially,optional"`
	Markup    map[string]any
}

// User implemented slots:
var _ FieldDefinition = (*TextListField)(nil)

func (*TextListField) Compose() composer.Spec {
	return composer.Spec{
		Name: TextListField_Type,
		Uses: composer.Type_Flow,
		Lede: "text_list",
	}
}

const TextListField_Type = "text_list_field"
const TextListField_Field_Name = "$NAME"
const TextListField_Field_Type = "$TYPE"
const TextListField_Field_Initially = "$INITIALLY"

func (op *TextListField) Marshal(m jsn.Marshaler) error {
	return TextListField_Marshal(m, op)
}

type TextListField_Slice []TextListField

func (op *TextListField_Slice) GetType() string { return TextListField_Type }

func (op *TextListField_Slice) Marshal(m jsn.Marshaler) error {
	return TextListField_Repeats_Marshal(m, (*[]TextListField)(op))
}

func (op *TextListField_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *TextListField_Slice) SetSize(cnt int) {
	var els []TextListField
	if cnt >= 0 {
		els = make(TextListField_Slice, cnt)
	}
	(*op) = els
}

func (op *TextListField_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return TextListField_Marshal(m, &(*op)[i])
}

func TextListField_Repeats_Marshal(m jsn.Marshaler, vals *[]TextListField) error {
	return jsn.RepeatBlock(m, (*TextListField_Slice)(vals))
}

func TextListField_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]TextListField) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = TextListField_Repeats_Marshal(m, pv)
	}
	return
}

type TextListField_Flow struct{ ptr *TextListField }

func (n TextListField_Flow) GetType() string      { return TextListField_Type }
func (n TextListField_Flow) GetLede() string      { return "text_list" }
func (n TextListField_Flow) GetFlow() interface{} { return n.ptr }
func (n TextListField_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*TextListField); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func TextListField_Optional_Marshal(m jsn.Marshaler, pv **TextListField) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = TextListField_Marshal(m, *pv)
	} else if !enc {
		var v TextListField
		if err = TextListField_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func TextListField_Marshal(m jsn.Marshaler, val *TextListField) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(TextListField_Flow{val}); err == nil {
		e0 := m.MarshalKey("", TextListField_Field_Name)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.Name)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", TextListField_Field_Name))
		}
		e1 := m.MarshalKey("kind", TextListField_Field_Type)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Optional_Marshal(m, &val.Type)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", TextListField_Field_Type))
		}
		e2 := m.MarshalKey("initially", TextListField_Field_Initially)
		if e2 == nil {
			e2 = rt.TextListEval_Optional_Marshal(m, &val.Initially)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", TextListField_Field_Initially))
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*FieldDefinition)(nil),
	(*StoryStatement)(nil),
}

var Slats = []composer.Composer{
	(*AspectField)(nil),
	(*BoolField)(nil),
	(*CallMacro)(nil),
	(*Comment)(nil),
	(*CountOf)(nil),
	(*CycleText)(nil),
	(*DeclareStatement)(nil),
	(*DefineAction)(nil),
	(*DefineFields)(nil),
	(*DefineKinds)(nil),
	(*DefineMacro)(nil),
	(*DefineNounTraits)(nil),
	(*DefineNouns)(nil),
	(*DefineOtherRelatives)(nil),
	(*DefinePattern)(nil),
	(*DefinePhrase)(nil),
	(*DefineRelation)(nil),
	(*DefineRelatives)(nil),
	(*DefineScene)(nil),
	(*DefineTraits)(nil),
	(*DefineValue)(nil),
	(*ExtendPattern)(nil),
	(*MakeOpposite)(nil),
	(*MakePlural)(nil),
	(*ManyToMany)(nil),
	(*ManyToOne)(nil),
	(*MapConnection)(nil),
	(*MapDeparting)(nil),
	(*MapDirection)(nil),
	(*MapHeading)(nil),
	(*NothingField)(nil),
	(*NumListField)(nil),
	(*NumberField)(nil),
	(*OneToMany)(nil),
	(*OneToOne)(nil),
	(*PairedAction)(nil),
	(*PatternFlags)(nil),
	(*PatternRule)(nil),
	(*PatternType)(nil),
	(*RecordField)(nil),
	(*RecordListField)(nil),
	(*RelationCardinality)(nil),
	(*RuleForKind)(nil),
	(*RuleForNoun)(nil),
	(*RuleForPattern)(nil),
	(*SayResponse)(nil),
	(*SayTemplate)(nil),
	(*ShuffleText)(nil),
	(*StoppingText)(nil),
	(*StoryAlias)(nil),
	(*StoryBreak)(nil),
	(*StoryDirective)(nil),
	(*StoryFile)(nil),
	(*Test)(nil),
	(*TestName)(nil),
	(*TextField)(nil),
	(*TextListField)(nil),
}

var Signatures = map[uint64]interface{}{
	17563761532337350103: (*ManyToMany)(nil),           /* ManyToMany:otherKinds: */
	4129025779762507875:  (*ManyToOne)(nil),            /* ManyToOne:kind: */
	13422667607848275221: (*MapConnection)(nil),        /* MapConnection: */
	691606134106503892:   (*MapDirection)(nil),         /* MapDirection: */
	17075866407822548206: (*OneToMany)(nil),            /* OneToMany:kinds: */
	13766274136867271026: (*OneToOne)(nil),             /* OneToOne:otherKind: */
	18143853777230560632: (*PairedAction)(nil),         /* PairedAction: */
	355438255946453678:   (*PatternFlags)(nil),         /* PatternFlags: */
	12283514816093491040: (*PatternRule)(nil),          /* PatternRule:do: */
	573707243023402517:   (*PatternRule)(nil),          /* PatternRule:flags:do: */
	8871095629143932769:  (*PatternType)(nil),          /* PatternType: */
	14287924768394488954: (*RelationCardinality)(nil),  /* RelationCardinality manyToMany: */
	10453256446593418889: (*RelationCardinality)(nil),  /* RelationCardinality manyToOne: */
	18092929693239672593: (*RelationCardinality)(nil),  /* RelationCardinality oneToMany: */
	5587008972147064084:  (*RelationCardinality)(nil),  /* RelationCardinality oneToOne: */
	5991962903091297123:  (*StoryFile)(nil),            /* Tapestry: */
	11670818074991137908: (*TestName)(nil),             /* TestName: */
	4360765066804052293:  (*StoryBreak)(nil),           /* story_statement=-- */
	13010292396640781698: (*AspectField)(nil),          /* field_definition=Aspect: */
	12738236274201716794: (*BoolField)(nil),            /* field_definition=Bool: */
	18077675806901364237: (*BoolField)(nil),            /* field_definition=Bool:initially: */
	17184788623765734642: (*BoolField)(nil),            /* field_definition=Bool:kind: */
	124015053883609573:   (*BoolField)(nil),            /* field_definition=Bool:kind:initially: */
	4843373105631259652:  (*CallMacro)(nil),            /* bool_eval=Call macro:args: */
	10236024639985130132: (*CallMacro)(nil),            /* execute=Call macro:args: */
	5651581957203069121:  (*CallMacro)(nil),            /* num_list_eval=Call macro:args: */
	11693923858603804101: (*CallMacro)(nil),            /* number_eval=Call macro:args: */
	1853884795003797121:  (*CallMacro)(nil),            /* record_eval=Call macro:args: */
	12142382415765691372: (*CallMacro)(nil),            /* record_list_eval=Call macro:args: */
	15275988251373739424: (*CallMacro)(nil),            /* story_statement=Call macro:args: */
	14675240953305539039: (*CallMacro)(nil),            /* text_eval=Call macro:args: */
	7066713272892250094:  (*CallMacro)(nil),            /* text_list_eval=Call macro:args: */
	3991849378064754806:  (*Comment)(nil),              /* execute=Comment: */
	16586092333187989882: (*Comment)(nil),              /* story_statement=Comment: */
	10143132576483224253: (*CountOf)(nil),              /* bool_eval=CountOf:num: */
	231398832069830353:   (*CycleText)(nil),            /* text_eval=CycleText: */
	9796202271034753943:  (*DeclareStatement)(nil),     /* story_statement=Declare: */
	10109890763294157270: (*DefineAction)(nil),         /* execute=Define action:requires: */
	14790755516297707674: (*DefineAction)(nil),         /* story_statement=Define action:requires: */
	14322897916789725742: (*DefineAction)(nil),         /* execute=Define action:requires:provides: */
	5312053119535959994:  (*DefineAction)(nil),         /* story_statement=Define action:requires:provides: */
	2600953883978299185:  (*DefineFields)(nil),         /* execute=Define kind:fields: */
	15268150405724581221: (*DefineFields)(nil),         /* story_statement=Define kind:fields: */
	17025532743550436003: (*DefineKinds)(nil),          /* execute=Define kinds:as: */
	11622379079031968031: (*DefineKinds)(nil),          /* story_statement=Define kinds:as: */
	4088968181697308175:  (*DefineMacro)(nil),          /* execute=Define macro:requires:result:provides:with: */
	13649996907616853483: (*DefineMacro)(nil),          /* story_statement=Define macro:requires:result:provides:with: */
	15337064981331082689: (*DefineMacro)(nil),          /* execute=Define macro:requires:result:with: */
	17317068367254309973: (*DefineMacro)(nil),          /* story_statement=Define macro:requires:result:with: */
	4708575879451717005:  (*DefineNouns)(nil),          /* execute=Define nouns:as: */
	7397461044941158073:  (*DefineNouns)(nil),          /* story_statement=Define nouns:as: */
	11310404142062902510: (*DefineNounTraits)(nil),     /* execute=Define nouns:as:traits: */
	15286672803702417298: (*DefineNounTraits)(nil),     /* story_statement=Define nouns:as:traits: */
	9839172640820177073:  (*DefineRelatives)(nil),      /* execute=Define nouns:relativeTo:otherNouns: */
	7383237871303366677:  (*DefineRelatives)(nil),      /* story_statement=Define nouns:relativeTo:otherNouns: */
	9505217264701509662:  (*DefineNounTraits)(nil),     /* execute=Define nouns:traits: */
	15794171433650329114: (*DefineNounTraits)(nil),     /* story_statement=Define nouns:traits: */
	15358769559004192942: (*DefinePattern)(nil),        /* execute=Define pattern:requires:result:provides:withRules: */
	2733154260078704538:  (*DefinePattern)(nil),        /* story_statement=Define pattern:requires:result:provides:withRules: */
	13567867628780565820: (*DefinePattern)(nil),        /* execute=Define pattern:requires:result:withRules: */
	13056176094891343360: (*DefinePattern)(nil),        /* story_statement=Define pattern:requires:result:withRules: */
	4650767708903763835:  (*DefinePhrase)(nil),         /* story_statement=Define phrase:asMacro: */
	89301097593785617:    (*DefinePhrase)(nil),         /* story_statement=Define phrase:asMacro:reversed: */
	10321772035226997803: (*DefineRelation)(nil),       /* execute=Define relation:cardinality manyToMany: */
	14085782312273513943: (*DefineRelation)(nil),       /* story_statement=Define relation:cardinality manyToMany: */
	10263803882772415534: (*DefineRelation)(nil),       /* execute=Define relation:cardinality manyToOne: */
	13547088785328938282: (*DefineRelation)(nil),       /* story_statement=Define relation:cardinality manyToOne: */
	14579122932423107502: (*DefineRelation)(nil),       /* execute=Define relation:cardinality oneToMany: */
	8378907640508804698:  (*DefineRelation)(nil),       /* story_statement=Define relation:cardinality oneToMany: */
	7001459786598567501:  (*DefineRelation)(nil),       /* execute=Define relation:cardinality oneToOne: */
	13361645062989794537: (*DefineRelation)(nil),       /* story_statement=Define relation:cardinality oneToOne: */
	2570506749320892411:  (*DefineOtherRelatives)(nil), /* execute=Define relativeTo:nouns:otherNouns: */
	16389453623741136831: (*DefineOtherRelatives)(nil), /* story_statement=Define relativeTo:nouns:otherNouns: */
	5110919797933301972:  (*DefineScene)(nil),          /* story_statement=Define scene:dependsOn:with: */
	13479298094295759568: (*DefineScene)(nil),          /* story_statement=Define scene:with: */
	5891130802416685089:  (*DefineTraits)(nil),         /* execute=Define traits:as: */
	3652615969014829573:  (*DefineTraits)(nil),         /* story_statement=Define traits:as: */
	1692806160663601784:  (*DefineValue)(nil),          /* execute=Define value:of:as: */
	17805855959213202620: (*DefineValue)(nil),          /* story_statement=Define value:of:as: */
	5241959995092605683:  (*MapDeparting)(nil),         /* execute=Departing from:via:and:otherRoom: */
	12862689211056047959: (*MapDeparting)(nil),         /* story_statement=Departing from:via:and:otherRoom: */
	13239915769926244872: (*ExtendPattern)(nil),        /* execute=Extend pattern:provides:withRules: */
	17581573717059123596: (*ExtendPattern)(nil),        /* story_statement=Extend pattern:provides:withRules: */
	478002506548269918:   (*ExtendPattern)(nil),        /* execute=Extend pattern:withRules: */
	7244900390452508762:  (*ExtendPattern)(nil),        /* story_statement=Extend pattern:withRules: */
	12883151399789323215: (*MapHeading)(nil),           /* execute=Heading:from:and:otherRoom: */
	2625420806444094675:  (*MapHeading)(nil),           /* story_statement=Heading:from:and:otherRoom: */
	5055073108490323709:  (*MapHeading)(nil),           /* execute=Heading:from:via:and:otherRoom: */
	9997819433665596617:  (*MapHeading)(nil),           /* story_statement=Heading:from:via:and:otherRoom: */
	18076782925803178620: (*StoryAlias)(nil),           /* execute=Interpret alias:asNoun: */
	85958334792709048:    (*StoryAlias)(nil),           /* story_statement=Interpret alias:asNoun: */
	2895546536328156972:  (*StoryDirective)(nil),       /* execute=Interpret:with: */
	6001249499689096432:  (*StoryDirective)(nil),       /* story_statement=Interpret:with: */
	6624124429048254998:  (*MakeOpposite)(nil),         /* execute=Make:opposite: */
	12130342806058120266: (*MakeOpposite)(nil),         /* story_statement=Make:opposite: */
	14758176820705861311: (*MakePlural)(nil),           /* execute=Make:plural: */
	8107023930195182683:  (*MakePlural)(nil),           /* story_statement=Make:plural: */
	14427731589588473385: (*NothingField)(nil),         /* field_definition=Nothing */
	10299801658819864730: (*NumListField)(nil),         /* field_definition=NumList: */
	12762197545337845485: (*NumListField)(nil),         /* field_definition=NumList:initially: */
	2289982379805608146:  (*NumListField)(nil),         /* field_definition=NumList:kind: */
	223049567122462661:   (*NumListField)(nil),         /* field_definition=NumList:kind:initially: */
	16579038690333872565: (*NumberField)(nil),          /* field_definition=Number: */
	7599754526096278866:  (*NumberField)(nil),          /* field_definition=Number:initially: */
	13275028962550729195: (*NumberField)(nil),          /* field_definition=Number:kind: */
	8920589511475179656:  (*NumberField)(nil),          /* field_definition=Number:kind:initially: */
	7896413305974623897:  (*RecordField)(nil),          /* field_definition=Record: */
	9030081498362006310:  (*RecordField)(nil),          /* field_definition=Record:initially: */
	7215961239288768263:  (*RecordField)(nil),          /* field_definition=Record:kind: */
	8334583613109868292:  (*RecordField)(nil),          /* field_definition=Record:kind:initially: */
	3705957996596149197:  (*RecordListField)(nil),      /* field_definition=RecordList: */
	5153309692795646250:  (*RecordListField)(nil),      /* field_definition=RecordList:initially: */
	15479801779125468947: (*RecordListField)(nil),      /* field_definition=RecordList:kind: */
	17384295137903978384: (*RecordListField)(nil),      /* field_definition=RecordList:kind:initially: */
	15471847624221143333: (*RuleForPattern)(nil),       /* execute=Rule for:do: */
	5691084228856271265:  (*RuleForPattern)(nil),       /* story_statement=Rule for:do: */
	938756285616980517:   (*RuleForKind)(nil),          /* execute=Rule for:kind:do: */
	16646221460438913289: (*RuleForKind)(nil),          /* story_statement=Rule for:kind:do: */
	10882184547042038019: (*RuleForKind)(nil),          /* execute=Rule for:kind:exactly:do: */
	12713479648610369743: (*RuleForKind)(nil),          /* story_statement=Rule for:kind:exactly:do: */
	9392894978887212612:  (*RuleForKind)(nil),          /* execute=Rule for:kind:exactly:named:do: */
	15490214038101962512: (*RuleForKind)(nil),          /* story_statement=Rule for:kind:exactly:named:do: */
	2337098170631462782:  (*RuleForKind)(nil),          /* execute=Rule for:kind:named:do: */
	12374695652310029234: (*RuleForKind)(nil),          /* story_statement=Rule for:kind:named:do: */
	7388742198509115006:  (*RuleForPattern)(nil),       /* execute=Rule for:named:do: */
	16114040939072484954: (*RuleForPattern)(nil),       /* story_statement=Rule for:named:do: */
	5961726239343816143:  (*RuleForNoun)(nil),          /* execute=Rule for:noun:do: */
	9209820952942420835:  (*RuleForNoun)(nil),          /* story_statement=Rule for:noun:do: */
	244103529869767696:   (*RuleForNoun)(nil),          /* execute=Rule for:noun:named:do: */
	17931239271906416164: (*RuleForNoun)(nil),          /* story_statement=Rule for:noun:named:do: */
	12945074305202371477: (*SayResponse)(nil),          /* execute=Say response:with: */
	7921553818502082370:  (*SayResponse)(nil),          /* text_eval=Say response:with: */
	9556993961571292952:  (*SayTemplate)(nil),          /* execute=Say: */
	15989777734244204735: (*SayTemplate)(nil),          /* text_eval=Say: */
	9910951906340888308:  (*ShuffleText)(nil),          /* text_eval=ShuffleText: */
	13921723804355948971: (*StoppingText)(nil),         /* text_eval=StoppingText: */
	2871145226608221260:  (*Test)(nil),                 /* execute=Test:dependsOn:do: */
	9865864948070946448:  (*Test)(nil),                 /* story_statement=Test:dependsOn:do: */
	5453259149853633814:  (*Test)(nil),                 /* execute=Test:dependsOn:withScene:do: */
	12698818979331053506: (*Test)(nil),                 /* story_statement=Test:dependsOn:withScene:do: */
	13063212444104265068: (*Test)(nil),                 /* execute=Test:do: */
	9283516926116088792:  (*Test)(nil),                 /* story_statement=Test:do: */
	11682383000525011702: (*Test)(nil),                 /* execute=Test:withScene:do: */
	500333266696321514:   (*Test)(nil),                 /* story_statement=Test:withScene:do: */
	9387832592330456403:  (*TextField)(nil),            /* field_definition=Text: */
	16637694412733787472: (*TextField)(nil),            /* field_definition=Text:initially: */
	15791809714384972761: (*TextField)(nil),            /* field_definition=Text:kind: */
	16917317465644840422: (*TextField)(nil),            /* field_definition=Text:kind:initially: */
	3830912410254339707:  (*TextListField)(nil),        /* field_definition=TextList: */
	15743255383721832504: (*TextListField)(nil),        /* field_definition=TextList:initially: */
	2011197685129757745:  (*TextListField)(nil),        /* field_definition=TextList:kind: */
	3232692879001227038:  (*TextListField)(nil),        /* field_definition=TextList:kind:initially: */
}
