package story_test

import (
	"fmt"
	"testing"

	"git.sr.ht/~ionous/tapestry/dl/story"

	"git.sr.ht/~ionous/tapestry/dl/eph"
	"git.sr.ht/~ionous/tapestry/imp"
	"git.sr.ht/~ionous/tapestry/rt/kindsOf"
	"github.com/kr/pretty"
)

// test named nouns
// fix - this doesnt work properly because the implicit aspects are in script
func xTestImportNamedNouns(t *testing.T) {
	var els []eph.Ephemera
	k := imp.NewImporter(eph.NewCommandQueue(&els))
	// this is really import noun properties at this point...
	if _, e := story.ImportNounProperties(k, []string{
		"our Trevor",
		"an apple",
		// note: we cant really test counted nouns without weaving
		// "3", "triangles",
		// "one", "square",
		"a gaggle of robot sheep",
	}); e != nil {
		t.Fatal(e)
	}
	expect := concat([]eph.Ephemera{
		// implicitly generated object type
		&eph.EphKinds{
			Kind:     "objects",
			Ancestor: kindsOf.Kind.String(),
		},
		// various implicitly defined aspects
		&eph.EphAspects{
			Aspects: "noun_types",
			Traits:  []string{"common_named", "proper_named", "counted"},
		},
		&eph.EphKinds{
			Kind:    "objects",
			Contain: []eph.EphParams{eph.AspectParam("noun_types")},
		},
		&eph.EphAspects{
			Aspects: "private_names",
			Traits:  []string{"publicly_named", "privately_named"},
		},
		&eph.EphKinds{
			Kind:    "objects",
			Contain: []eph.EphParams{eph.AspectParam("private_names")},
		},
		//&eph.EphKinds{
		//	Kind:    "objects",
		//	Contain: []eph.EphParams{textParam("indefinite_article")},
		//},
		// the printed name field is implicitly generated by the counted nouns
		// &eph.EphKinds{
		// 	Kind:   "objects",
		// 	Contain: []eph.EphParams{textParam("printed_name")},
		// },
		// note: we dont expect to see &EphNoun;
		// the phrases we are using for the test only add values.
		// ( *except* for counted nouns because they're implicitly generated )
		//&eph.EphValues{
		//	Noun:  "Trevor",
		//	Field: "indefinite_article",
		//	Value: T("our"),
		//},

		&eph.EphValues{
			Noun:  "Trevor",
			Field: "proper_named",
			Value: B(true),
		},
		/*&eph.EphValues{
			Noun:  "apple",
			Field: "indefinite_article",
			Value: T("an"),
		}*/},
	// countedNouns("triangles", 3),
	// countedNouns("square", 1),
	// finally, our last object...

	// FIX: can't have this again until we can customize the determiner
	//[]eph.Ephemera{
	//	&eph.EphValues{
	//		Noun:  "robot sheep",
	//		Field: "indefinite_article",
	//		Value: T("a gaggle of"),
	//	},
	//},
	)
	if diff := pretty.Diff(els, expect); len(diff) > 0 {
		t.Log(diff)
		t.Error(pretty.Sprint(els))
	}
}

func concat(els ...[]eph.Ephemera) (out []eph.Ephemera) {
	for _, k := range els {
		out = append(out, k...)
	}
	return
}

// fix? previously the name would have been "triangle_1" now its "triangles_1"
func countedNouns(kind string, cnt int) (out []eph.Ephemera) {
	out = append(out, &eph.EphKinds{
		Kind:     kind,
		Ancestor: "thing",
	})
	for i := 1; i <= cnt; i++ {
		n := fmt.Sprintf("%s_%d", kind, i)
		out = append(out,
			&eph.EphNouns{Noun: n, Kind: kind},
			&eph.EphValues{
				Noun:  n,
				Field: "counted",
				Value: B(true),
			},
			// story.SingularCountedNoun(n),
			/*&eph.EphValues{
				Noun:  n,
				FieldDefinition: "printed_name",
				Value: T(kind),
			}*/)
	}
	return out
}

func textParam(name string) eph.EphParams {
	return eph.EphParams{
		Affinity: eph.Affinity{Str: eph.Affinity_Text},
		Name:     name,
	}
}
