package story_test

import (
	"fmt"
	"testing"

	"git.sr.ht/~ionous/tapestry/affine"
	"git.sr.ht/~ionous/tapestry/test/eph"
)

// test named nouns
// fix - this doesnt work properly because the implicit aspects are in script
func xTestImportNamedNouns(t *testing.T) {
	// var els []eph.Ephemera
	// k := weave.NewCatalog(eph.NewCommandQueue(&els))
	// // this is really import noun properties at this point...
	// if _, e := story.readNounsWithProperties(k, []string{
	// 	"our Trevor",
	// 	"an apple",
	// 	// note: we cant really test counted nouns without weaving
	// 	// "3", "triangles",
	// 	// "one", "square",
	// 	"a gaggle of robot sheep",
	// }); e != nil {
	// 	t.Fatal(e)
	// }
	// expect := concat([]eph.Ephemera{
	// 	// implicitly generated object type
	// 	&eph.Kinds{
	// 		Kind:     "objects",
	// 		Ancestor: kindsOf.Kind.String(),
	// 	},
	// 	// various implicitly defined aspects
	// 	&eph.Aspects{
	// 		Aspects: "noun types",
	// 		Traits:  []string{"common named", "proper named", "counted"},
	// 	},
	// 	&eph.Kinds{
	// 		Kind:    "objects",
	// 		Contain: []eph.Params{eph.AspectParam("noun types")},
	// 	},
	// 	&eph.Aspects{
	// 		Aspects: "private_names",
	// 		Traits:  []string{"publicly named", "privately named"},
	// 	},
	// 	&eph.Kinds{
	// 		Kind:    "objects",
	// 		Contain: []eph.Params{eph.AspectParam("private names")},
	// 	},
	// 	//&eph.Kinds{
	// 	//	Kind:    "objects",
	// 	//	Contain: []eph.Params{textParam("indefinite article")},
	// 	//},
	// 	// the printed name field is implicitly generated by the counted nouns
	// 	// &eph.Kinds{
	// 	// 	Kind:   "objects",
	// 	// 	Contain: []eph.Params{textParam("printed name")},
	// 	// },
	// 	// note: we dont expect to see &EphNoun;
	// 	// the phrases we are using for the test only add values.
	// 	// ( *except* for counted nouns because they're implicitly generated )
	// 	//&eph.Values{
	// 	//	Noun:  "Trevor",
	// 	//	Field: "indefinite article",
	// 	//	Value: T("our"),
	// 	//},

	// 	&eph.Values{
	// 		Noun:  "Trevor",
	// 		Field: "proper named",
	// 		Value: B(true),
	// 	},
	// 	/*&eph.Values{
	// 		Noun:  "apple",
	// 		Field: "indefinite article",
	// 		Value: T("an"),
	// 	}*/},
	// // countedNouns("triangles", 3),
	// // countedNouns("square", 1),
	// // finally, our last object...

	// // FIX: can't have this again until we can customize the determiner
	// //[]eph.Ephemera{
	// //	&eph.Values{
	// //		Noun:  "robot sheep",
	// //		Field: "indefinite article",
	// //		Value: T("a gaggle of"),
	// //	},
	// //},
	// )
	// if diff := pretty.Diff(els, expect); len(diff) > 0 {
	// 	t.Log(diff)
	// 	t.Error(pretty.Sprint(els))
	// }
}

func concat(els ...[]eph.Ephemera) (out []eph.Ephemera) {
	for _, k := range els {
		out = append(out, k...)
	}
	return
}

// fix? previously the name would have been "triangle_1" now its "triangles_1"
func countedNouns(kind string, cnt int) (out []eph.Ephemera) {
	out = append(out, &eph.Kinds{
		Kind:     kind,
		Ancestor: "thing",
	})
	for i := 1; i <= cnt; i++ {
		n := fmt.Sprintf("%s_%d", kind, i)
		out = append(out,
			&eph.Nouns{Noun: n, Kind: kind},
			&eph.Values{
				Noun:  n,
				Field: "counted",
				Value: B(true),
			})
	}
	return out
}

func textParam(name string) eph.Params {
	return eph.Params{
		Affinity: affine.Text,
		Name:     name,
	}
}
