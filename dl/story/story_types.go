// Contains modeling commands used to define a game world. These commands include the description of scenes, kinds of objects, specific nouns and their properties, the placement and relation between nouns, and so on.
//
// Most authors will probably prefer the jess plain english style of modeling over these, more explicit, commands. However, there are some commands -- like defining scenes -- which don't currently have a corollary within jess.
package story

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/grammar"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// story_statement, a type of slot.
var Zt_StoryStatement = typeinfo.Slot{
	Name: "story_statement",
	Markup: map[string]any{
		"blockly-color": "VARIABLES_HUE",
		"blockly-stack": true,
		"comment":       "A slot for modeling commands, used define a game world. All commands in a tell file start with a story statement. Specific commands can specify slots for other commands including those for running scripts, parsing the player's input, and more.",
	},
}

// Holds a single slot.
type StoryStatement_Slot struct{ Value StoryStatement }

// Implements [typeinfo.Instance] for a single slot.
func (*StoryStatement_Slot) TypeInfo() typeinfo.T {
	return &Zt_StoryStatement
}

// Holds a slice of slots.
type StoryStatement_Slots []StoryStatement

// Implements [typeinfo.Instance] for a slice of slots.
func (*StoryStatement_Slots) TypeInfo() typeinfo.T {
	return &Zt_StoryStatement
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *StoryStatement_Slots) Repeats() bool {
	return len(*op) > 0
}

// field_definition, a type of slot.
var Zt_FieldDefinition = typeinfo.Slot{
	Name: "field_definition",
	Markup: map[string]any{
		"comment": "Fields are used to define the members of kinds, records, patterns, and so on.",
	},
}

// Holds a single slot.
type FieldDefinition_Slot struct{ Value FieldDefinition }

// Implements [typeinfo.Instance] for a single slot.
func (*FieldDefinition_Slot) TypeInfo() typeinfo.T {
	return &Zt_FieldDefinition
}

// Holds a slice of slots.
type FieldDefinition_Slots []FieldDefinition

// Implements [typeinfo.Instance] for a slice of slots.
func (*FieldDefinition_Slots) TypeInfo() typeinfo.T {
	return &Zt_FieldDefinition
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *FieldDefinition_Slots) Repeats() bool {
	return len(*op) > 0
}

// Used internally as the container for every .tell file.
// Implements Story Statement to simplify how flex parsing works.
type StoryFile struct {
	Statements []StoryStatement
	Markup     map[string]any
}

// story_file, a type of flow.
var Zt_StoryFile typeinfo.Flow

// Implements [typeinfo.Instance]
func (*StoryFile) TypeInfo() typeinfo.T {
	return &Zt_StoryFile
}

// Implements [typeinfo.Markup]
func (op *StoryFile) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*StoryFile)(nil)

// Holds a slice of type StoryFile.
type StoryFile_Slice []StoryFile

// Implements [typeinfo.Instance] for a slice of StoryFile.
func (*StoryFile_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoryFile
}

// Implements [typeinfo.Repeats] for a slice of StoryFile.
func (op *StoryFile_Slice) Repeats() bool {
	return len(*op) > 0
}

// A legacy command, used in .if files as a visual divider ( because reading and writing json doesn't otherwise have a way to preserve whitespace. )
type StoryBreak struct {
	Markup map[string]any
}

// story_break, a type of flow.
var Zt_StoryBreak typeinfo.Flow

// Implements [typeinfo.Instance]
func (*StoryBreak) TypeInfo() typeinfo.T {
	return &Zt_StoryBreak
}

// Implements [typeinfo.Markup]
func (op *StoryBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*StoryBreak)(nil)

// Holds a slice of type StoryBreak.
type StoryBreak_Slice []StoryBreak

// Implements [typeinfo.Instance] for a slice of StoryBreak.
func (*StoryBreak_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoryBreak
}

// Implements [typeinfo.Repeats] for a slice of StoryBreak.
func (op *StoryBreak_Slice) Repeats() bool {
	return len(*op) > 0
}

// Adds documentation about the story for you and other authors.
// Notes can used as a modeling commands, or as part of an execute block.
// And, they are created automatically from hash-style comments (#) encountered within the plain text sections of tell files.
// When used in an execute block, notes become {"Log:value:"} commands.
type Note struct {
	Lines  []string
	Markup map[string]any
}

// note, a type of flow.
var Zt_Note typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Note) TypeInfo() typeinfo.T {
	return &Zt_Note
}

// Implements [typeinfo.Markup]
func (op *Note) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*Note)(nil)
var _ rtti.Execute = (*Note)(nil)

// Holds a slice of type Note.
type Note_Slice []Note

// Implements [typeinfo.Instance] for a slice of Note.
func (*Note_Slice) TypeInfo() typeinfo.T {
	return &Zt_Note
}

// Implements [typeinfo.Repeats] for a slice of Note.
func (op *Note_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a scene used for testing a story.
// Tests can be executed using the `tap check` command.
// TODO: see https://todo.sr.ht/~ionous/tapestry/42
type DefineTest struct {
	TestName           string
	RequiredSceneNames rtti.TextListEval
	Statements         []StoryStatement
	Exe                []rtti.Execute
	Markup             map[string]any
}

// define_test, a type of flow.
var Zt_DefineTest typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineTest) TypeInfo() typeinfo.T {
	return &Zt_DefineTest
}

// Implements [typeinfo.Markup]
func (op *DefineTest) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineTest)(nil)

// Holds a slice of type DefineTest.
type DefineTest_Slice []DefineTest

// Implements [typeinfo.Instance] for a slice of DefineTest.
func (*DefineTest_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineTest
}

// Implements [typeinfo.Repeats] for a slice of DefineTest.
func (op *DefineTest_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a collection of nouns, kinds, game rules, etc. used the game.
// Every .tell story has its own unique scene.
type DefineScene struct {
	SceneName          rtti.TextEval
	RequiredSceneNames rtti.TextListEval
	Statements         []StoryStatement
	Markup             map[string]any
}

// define_scene, a type of flow.
var Zt_DefineScene typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineScene) TypeInfo() typeinfo.T {
	return &Zt_DefineScene
}

// Implements [typeinfo.Markup]
func (op *DefineScene) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineScene)(nil)

// Holds a slice of type DefineScene.
type DefineScene_Slice []DefineScene

// Implements [typeinfo.Instance] for a slice of DefineScene.
func (*DefineScene_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineScene
}

// Implements [typeinfo.Repeats] for a slice of DefineScene.
func (op *DefineScene_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines an in-game behavior that can be triggered by an actor.
// Actions are a special kind of pattern, and like patterns use "rules" to define and customize their behavior. The shared library includes many common actions including things like moving from room to room, examining something, taking or dropping items, and so on.
// See the Tapestry guide for more information.
type DefineAction struct {
	PatternName rtti.TextEval
	Requires    []FieldDefinition
	Provides    []FieldDefinition
	Markup      map[string]any
}

// define_action, a type of flow.
var Zt_DefineAction typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineAction) TypeInfo() typeinfo.T {
	return &Zt_DefineAction
}

// Implements [typeinfo.Markup]
func (op *DefineAction) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineAction)(nil)

// Holds a slice of type DefineAction.
type DefineAction_Slice []DefineAction

// Implements [typeinfo.Instance] for a slice of DefineAction.
func (*DefineAction_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAction
}

// Implements [typeinfo.Repeats] for a slice of DefineAction.
func (op *DefineAction_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a set of mutually exclusive states that can be assigned to any kind of noun. By default, every noun with this set of states starts the game with the first state listed by this command. At runtime, a script can change to other states, ask whether a noun is in a particular state, or ask for the name of the current state from the set.
// Internally, these are also known as "aspects" and "traits."
// Many programming languages refer to these as "enumerations."
// See also: {"Set:state:"} and {"Object:field:"}
type DefineState struct {
	AspectName rtti.TextEval
	StateNames rtti.TextListEval
	Markup     map[string]any
}

// define_state, a type of flow.
var Zt_DefineState typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineState) TypeInfo() typeinfo.T {
	return &Zt_DefineState
}

// Implements [typeinfo.Markup]
func (op *DefineState) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineState)(nil)

// Holds a slice of type DefineState.
type DefineState_Slice []DefineState

// Implements [typeinfo.Instance] for a slice of DefineState.
func (*DefineState_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineState
}

// Implements [typeinfo.Repeats] for a slice of DefineState.
func (op *DefineState_Slice) Repeats() bool {
	return len(*op) > 0
}

// Interpret a name typed by the player as some existing noun.
// For example, if there is a noun called "the book", the story could define
// an alias so that "tome" also means the book.
type DefineAlias struct {
	Names    rtti.TextListEval
	NounName rtti.TextEval
	Markup   map[string]any
}

// define_alias, a type of flow.
var Zt_DefineAlias typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineAlias) TypeInfo() typeinfo.T {
	return &Zt_DefineAlias
}

// Implements [typeinfo.Markup]
func (op *DefineAlias) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineAlias)(nil)

// Holds a slice of type DefineAlias.
type DefineAlias_Slice []DefineAlias

// Implements [typeinfo.Instance] for a slice of DefineAlias.
func (*DefineAlias_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAlias
}

// Implements [typeinfo.Repeats] for a slice of DefineAlias.
func (op *DefineAlias_Slice) Repeats() bool {
	return len(*op) > 0
}

// Creates a grammar used to parse player input.
// See the Tapestry guide for details.
type DefineLeadingGrammar struct {
	Lede   []string
	Scans  []grammar.ScannerMaker
	Markup map[string]any
}

// define_leading_grammar, a type of flow.
var Zt_DefineLeadingGrammar typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineLeadingGrammar) TypeInfo() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// Implements [typeinfo.Markup]
func (op *DefineLeadingGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineLeadingGrammar)(nil)

// Holds a slice of type DefineLeadingGrammar.
type DefineLeadingGrammar_Slice []DefineLeadingGrammar

// Implements [typeinfo.Instance] for a slice of DefineLeadingGrammar.
func (*DefineLeadingGrammar_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// Implements [typeinfo.Repeats] for a slice of DefineLeadingGrammar.
func (op *DefineLeadingGrammar_Slice) Repeats() bool {
	return len(*op) > 0
}

// Creates a grammar to parse player input that can be referenced in other grammars.
// It can also be used for grammars that need more flexibility in matching the initial words of a sentence ( because {"Interpret:with:"} depends on a set of fixed words. )
type DefineNamedGrammar struct {
	Name   string
	Scans  []grammar.ScannerMaker
	Markup map[string]any
}

// define_named_grammar, a type of flow.
var Zt_DefineNamedGrammar typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineNamedGrammar) TypeInfo() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// Implements [typeinfo.Markup]
func (op *DefineNamedGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineNamedGrammar)(nil)

// Holds a slice of type DefineNamedGrammar.
type DefineNamedGrammar_Slice []DefineNamedGrammar

// Implements [typeinfo.Instance] for a slice of DefineNamedGrammar.
func (*DefineNamedGrammar_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// Implements [typeinfo.Repeats] for a slice of DefineNamedGrammar.
func (op *DefineNamedGrammar_Slice) Repeats() bool {
	return len(*op) > 0
}

// Used internally to contain the plain-text sections of .tell documents.
// Contains English-like definitions of nouns, kinds, and their relatives.
type DeclareStatement struct {
	Text    rtti.TextEval
	Assign  rtti.Assignment
	Matches JessMatches
	Markup  map[string]any
}

// declare_statement, a type of flow.
var Zt_DeclareStatement typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DeclareStatement) TypeInfo() typeinfo.T {
	return &Zt_DeclareStatement
}

// Implements [typeinfo.Markup]
func (op *DeclareStatement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DeclareStatement)(nil)

// Holds a slice of type DeclareStatement.
type DeclareStatement_Slice []DeclareStatement

// Implements [typeinfo.Instance] for a slice of DeclareStatement.
func (*DeclareStatement_Slice) TypeInfo() typeinfo.T {
	return &Zt_DeclareStatement
}

// Implements [typeinfo.Repeats] for a slice of DeclareStatement.
func (op *DeclareStatement_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a connection between different kinds of nouns.
// The shared library, for instance, defines a spatial relation between objects;
// allowing one object to be placed inside another.
type DefineRelation struct {
	RelationName  rtti.TextEval
	KindName      rtti.TextEval
	OtherKindName rtti.TextEval
	Cardinality   RelationCardinality
	Markup        map[string]any
}

// define_relation, a type of flow.
var Zt_DefineRelation typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineRelation) TypeInfo() typeinfo.T {
	return &Zt_DefineRelation
}

// Implements [typeinfo.Markup]
func (op *DefineRelation) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineRelation)(nil)

// Holds a slice of type DefineRelation.
type DefineRelation_Slice []DefineRelation

// Implements [typeinfo.Instance] for a slice of DefineRelation.
func (*DefineRelation_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRelation
}

// Implements [typeinfo.Repeats] for a slice of DefineRelation.
func (op *DefineRelation_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a new kind: a set of properties used by game objects.
// This command is similar to a sentence like:
// "Doors are a kind of opener."
type DefineKind struct {
	KindName         rtti.TextEval
	AncestorKindName rtti.TextEval
	Markup           map[string]any
}

// define_kind, a type of flow.
var Zt_DefineKind typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineKind) TypeInfo() typeinfo.T {
	return &Zt_DefineKind
}

// Implements [typeinfo.Markup]
func (op *DefineKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineKind)(nil)

// Holds a slice of type DefineKind.
type DefineKind_Slice []DefineKind

// Implements [typeinfo.Instance] for a slice of DefineKind.
func (*DefineKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineKind
}

// Implements [typeinfo.Repeats] for a slice of DefineKind.
func (op *DefineKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Adds properties to an existing kind.
// This command is similar to a sentence like:
// "Things have some text called a description."
type DefineFields struct {
	KindName   rtti.TextEval
	FieldNames []FieldDefinition
	Markup     map[string]any
}

// define_fields, a type of flow.
var Zt_DefineFields typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineFields) TypeInfo() typeinfo.T {
	return &Zt_DefineFields
}

// Implements [typeinfo.Markup]
func (op *DefineFields) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineFields)(nil)

// Holds a slice of type DefineFields.
type DefineFields_Slice []DefineFields

// Implements [typeinfo.Instance] for a slice of DefineFields.
func (*DefineFields_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineFields
}

// Implements [typeinfo.Repeats] for a slice of DefineFields.
func (op *DefineFields_Slice) Repeats() bool {
	return len(*op) > 0
}

// Controls how Tapestry pluralize words.
// Plurals are used both at runtime and during weave to
// guide the interpretation of nouns and kinds.
// A singular word can have multiple plurals;
// a plural word only has one singular form.
// For example:
// "The plural of person is people."
// "The plural of person is persons."
type DefinePlural struct {
	Singular rtti.TextEval
	Plural   rtti.TextEval
	Markup   map[string]any
}

// define_plural, a type of flow.
var Zt_DefinePlural typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefinePlural) TypeInfo() typeinfo.T {
	return &Zt_DefinePlural
}

// Implements [typeinfo.Markup]
func (op *DefinePlural) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefinePlural)(nil)

// Holds a slice of type DefinePlural.
type DefinePlural_Slice []DefinePlural

// Implements [typeinfo.Instance] for a slice of DefinePlural.
func (*DefinePlural_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePlural
}

// Implements [typeinfo.Repeats] for a slice of DefinePlural.
func (op *DefinePlural_Slice) Repeats() bool {
	return len(*op) > 0
}

// Ensures that a noun of the specified name and kind exists in the world.
type DefineNounKind struct {
	NounName rtti.TextEval
	KindName rtti.TextEval
	Markup   map[string]any
}

// define_noun_kind, a type of flow.
var Zt_DefineNounKind typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineNounKind) TypeInfo() typeinfo.T {
	return &Zt_DefineNounKind
}

// Implements [typeinfo.Markup]
func (op *DefineNounKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineNounKind)(nil)

// Holds a slice of type DefineNounKind.
type DefineNounKind_Slice []DefineNounKind

// Implements [typeinfo.Instance] for a slice of DefineNounKind.
func (*DefineNounKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounKind
}

// Implements [typeinfo.Repeats] for a slice of DefineNounKind.
func (op *DefineNounKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Assigns an initial value to a existing noun.
type DefineNounValue struct {
	NounName  rtti.TextEval
	FieldName rtti.TextEval
	Value     rtti.Assignment
	Markup    map[string]any
}

// define_noun_value, a type of flow.
var Zt_DefineNounValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineNounValue) TypeInfo() typeinfo.T {
	return &Zt_DefineNounValue
}

// Implements [typeinfo.Markup]
func (op *DefineNounValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineNounValue)(nil)

// Holds a slice of type DefineNounValue.
type DefineNounValue_Slice []DefineNounValue

// Implements [typeinfo.Instance] for a slice of DefineNounValue.
func (*DefineNounValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounValue
}

// Implements [typeinfo.Repeats] for a slice of DefineNounValue.
func (op *DefineNounValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Assigns one or more initial states to a existing noun.
type DefineNounStates struct {
	NounName   rtti.TextEval
	StateNames rtti.TextListEval
	Markup     map[string]any
}

// define_noun_states, a type of flow.
var Zt_DefineNounStates typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineNounStates) TypeInfo() typeinfo.T {
	return &Zt_DefineNounStates
}

// Implements [typeinfo.Markup]
func (op *DefineNounStates) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineNounStates)(nil)

// Holds a slice of type DefineNounStates.
type DefineNounStates_Slice []DefineNounStates

// Implements [typeinfo.Instance] for a slice of DefineNounStates.
func (*DefineNounStates_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounStates
}

// Implements [typeinfo.Repeats] for a slice of DefineNounStates.
func (op *DefineNounStates_Slice) Repeats() bool {
	return len(*op) > 0
}

// Declares a new pattern.
// A pattern is a set of author defined rules used at runtime to either change the game world, or to provide information about it. Patterns are the Tapestry equivalent of functions.
type DefinePattern struct {
	PatternName rtti.TextEval
	Requires    []FieldDefinition
	Provides    []FieldDefinition
	Exe         []rtti.Execute
	Markup      map[string]any
}

// define_pattern, a type of flow.
var Zt_DefinePattern typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefinePattern) TypeInfo() typeinfo.T {
	return &Zt_DefinePattern
}

// Implements [typeinfo.Markup]
func (op *DefinePattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefinePattern)(nil)

// Holds a slice of type DefinePattern.
type DefinePattern_Slice []DefinePattern

// Implements [typeinfo.Instance] for a slice of DefinePattern.
func (*DefinePattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePattern
}

// Implements [typeinfo.Repeats] for a slice of DefinePattern.
func (op *DefinePattern_Slice) Repeats() bool {
	return len(*op) > 0
}

// Adds one or more local variable to an existing pattern.
type DefinePatternProvides struct {
	PatternName rtti.TextEval
	Provides    []FieldDefinition
	Markup      map[string]any
}

// define_pattern_provides, a type of flow.
var Zt_DefinePatternProvides typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefinePatternProvides) TypeInfo() typeinfo.T {
	return &Zt_DefinePatternProvides
}

// Implements [typeinfo.Markup]
func (op *DefinePatternProvides) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefinePatternProvides)(nil)

// Holds a slice of type DefinePatternProvides.
type DefinePatternProvides_Slice []DefinePatternProvides

// Implements [typeinfo.Instance] for a slice of DefinePatternProvides.
func (*DefinePatternProvides_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePatternProvides
}

// Implements [typeinfo.Repeats] for a slice of DefinePatternProvides.
func (op *DefinePatternProvides_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change the behavior of an existing pattern.
//
// For patterns defined using [DefinePattern], if a rule starts with a [core.ChooseBranch] command, and none of the branches are chosen, the pattern checks the next specified rule; and so on, until the pattern finds a branch that succeeds.
//
// For patterns defined using [DefineAction], rules behave as "event listeners". They continue to the next listener unless specifically stopped. And, by default, they only respond to actions triggered by the player.
//
// See the Tapestry guide for more in-depth information.
type DefineRule struct {
	PatternName rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// define_rule, a type of flow.
var Zt_DefineRule typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineRule) TypeInfo() typeinfo.T {
	return &Zt_DefineRule
}

// Implements [typeinfo.Markup]
func (op *DefineRule) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineRule)(nil)

// Holds a slice of type DefineRule.
type DefineRule_Slice []DefineRule

// Implements [typeinfo.Instance] for a slice of DefineRule.
func (*DefineRule_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRule
}

// Implements [typeinfo.Repeats] for a slice of DefineRule.
func (op *DefineRule_Slice) Repeats() bool {
	return len(*op) > 0
}

// Adds an "event listener" which only runs if the target of the triggered action is the specified noun. See [DefineRule] for more information.
type DefineNounRule struct {
	NounName    rtti.TextEval
	PatternName rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// define_noun_rule, a type of flow.
var Zt_DefineNounRule typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineNounRule) TypeInfo() typeinfo.T {
	return &Zt_DefineNounRule
}

// Implements [typeinfo.Markup]
func (op *DefineNounRule) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineNounRule)(nil)

// Holds a slice of type DefineNounRule.
type DefineNounRule_Slice []DefineNounRule

// Implements [typeinfo.Instance] for a slice of DefineNounRule.
func (*DefineNounRule_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounRule
}

// Implements [typeinfo.Repeats] for a slice of DefineNounRule.
func (op *DefineNounRule_Slice) Repeats() bool {
	return len(*op) > 0
}

// Adds an "event listener" which only runs if the target of the triggered action a noun of the specified kind. See [DefineRule] for more information.
type DefineKindRule struct {
	KindName    rtti.TextEval
	PatternName rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// define_kind_rule, a type of flow.
var Zt_DefineKindRule typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineKindRule) TypeInfo() typeinfo.T {
	return &Zt_DefineKindRule
}

// Implements [typeinfo.Markup]
func (op *DefineKindRule) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineKindRule)(nil)

// Holds a slice of type DefineKindRule.
type DefineKindRule_Slice []DefineKindRule

// Implements [typeinfo.Instance] for a slice of DefineKindRule.
func (*DefineKindRule_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineKindRule
}

// Implements [typeinfo.Repeats] for a slice of DefineKindRule.
func (op *DefineKindRule_Slice) Repeats() bool {
	return len(*op) > 0
}

// Relate nouns to each other.
// Most users will probably prefer defining verbs and using jess to relate nouns.
// For instance: "Carrying is a verb. The relation of carrying is whereabouts. Bob is carrying the pen."
// See the Tapestry guide for details.
type DefineRelatives struct {
	RelationName   rtti.TextEval
	NounNames      rtti.TextListEval
	OtherNounNames rtti.TextListEval
	Markup         map[string]any
}

// define_relatives, a type of flow.
var Zt_DefineRelatives typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DefineRelatives) TypeInfo() typeinfo.T {
	return &Zt_DefineRelatives
}

// Implements [typeinfo.Markup]
func (op *DefineRelatives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ StoryStatement = (*DefineRelatives)(nil)

// Holds a slice of type DefineRelatives.
type DefineRelatives_Slice []DefineRelatives

// Implements [typeinfo.Instance] for a slice of DefineRelatives.
func (*DefineRelatives_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRelatives
}

// Implements [typeinfo.Repeats] for a slice of DefineRelatives.
func (op *DefineRelatives_Slice) Repeats() bool {
	return len(*op) > 0
}

// Print templated text. Templates contain commands executed at runtime.
// See the Tapestry guide for more information.
type SayTemplate struct {
	Template string
	Markup   map[string]any
}

// say_template, a type of flow.
var Zt_SayTemplate typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SayTemplate) TypeInfo() typeinfo.T {
	return &Zt_SayTemplate
}

// Implements [typeinfo.Markup]
func (op *SayTemplate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*SayTemplate)(nil)
var _ rtti.TextEval = (*SayTemplate)(nil)

// Holds a slice of type SayTemplate.
type SayTemplate_Slice []SayTemplate

// Implements [typeinfo.Instance] for a slice of SayTemplate.
func (*SayTemplate_Slice) TypeInfo() typeinfo.T {
	return &Zt_SayTemplate
}

// Implements [typeinfo.Repeats] for a slice of SayTemplate.
func (op *SayTemplate_Slice) Repeats() bool {
	return len(*op) > 0
}

// Print text in a replaceable manner.
// Each response has a unique name and a default bit of text it responds with.
// The response can be changed everywhere its used by replacing that text.
// ( ex. by using {"Define kind:fields": "response", "name of the response"} )
//
// The shared library uses responses for much of what it prints to the player
// so that stories can change the stock phrases.
type SayResponse struct {
	ResponseName string
	Text         rtti.TextEval
	Markup       map[string]any
}

// say_response, a type of flow.
var Zt_SayResponse typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SayResponse) TypeInfo() typeinfo.T {
	return &Zt_SayResponse
}

// Implements [typeinfo.Markup]
func (op *SayResponse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*SayResponse)(nil)
var _ rtti.TextEval = (*SayResponse)(nil)

// Holds a slice of type SayResponse.
type SayResponse_Slice []SayResponse

// Implements [typeinfo.Instance] for a slice of SayResponse.
func (*SayResponse_Slice) TypeInfo() typeinfo.T {
	return &Zt_SayResponse
}

// Implements [typeinfo.Repeats] for a slice of SayResponse.
func (op *SayResponse_Slice) Repeats() bool {
	return len(*op) > 0
}

// A guard which returns true based on a counter.
// Counters start at zero and are incremented every time the guard is checked.
type CountOf struct {
	Trigger core.Trigger
	Num     rtti.NumberEval
	Markup  map[string]any
}

// count_of, a type of flow.
var Zt_CountOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CountOf) TypeInfo() typeinfo.T {
	return &Zt_CountOf
}

// Implements [typeinfo.Markup]
func (op *CountOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CountOf)(nil)

// Holds a slice of type CountOf.
type CountOf_Slice []CountOf

// Implements [typeinfo.Instance] for a slice of CountOf.
func (*CountOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_CountOf
}

// Implements [typeinfo.Repeats] for a slice of CountOf.
func (op *CountOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns a single piece of text selected from a set of predefined values. When called multiple times, returns each one of the values in their specified order, then loops.
type CycleText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// cycle_text, a type of flow.
var Zt_CycleText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CycleText) TypeInfo() typeinfo.T {
	return &Zt_CycleText
}

// Implements [typeinfo.Markup]
func (op *CycleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*CycleText)(nil)

// Holds a slice of type CycleText.
type CycleText_Slice []CycleText

// Implements [typeinfo.Instance] for a slice of CycleText.
func (*CycleText_Slice) TypeInfo() typeinfo.T {
	return &Zt_CycleText
}

// Implements [typeinfo.Repeats] for a slice of CycleText.
func (op *CycleText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns a single piece of text selected from a set of predefined values. When called multiple times, returns each one of the values in a randomized order. After returning the available options, begins again with a new ordering.
type ShuffleText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// shuffle_text, a type of flow.
var Zt_ShuffleText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ShuffleText) TypeInfo() typeinfo.T {
	return &Zt_ShuffleText
}

// Implements [typeinfo.Markup]
func (op *ShuffleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*ShuffleText)(nil)

// Holds a slice of type ShuffleText.
type ShuffleText_Slice []ShuffleText

// Implements [typeinfo.Instance] for a slice of ShuffleText.
func (*ShuffleText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ShuffleText
}

// Implements [typeinfo.Repeats] for a slice of ShuffleText.
func (op *ShuffleText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns a single piece of text selected from a set of predefined values. When called multiple times returns each of its inputs in turn, sticking to the last one.
// As a special case, if there was only ever one option, returns that option followed by the empty string forever after.
type StoppingText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// stopping_text, a type of flow.
var Zt_StoppingText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*StoppingText) TypeInfo() typeinfo.T {
	return &Zt_StoppingText
}

// Implements [typeinfo.Markup]
func (op *StoppingText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*StoppingText)(nil)

// Holds a slice of type StoppingText.
type StoppingText_Slice []StoppingText

// Implements [typeinfo.Instance] for a slice of StoppingText.
func (*StoppingText_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoppingText
}

// Implements [typeinfo.Repeats] for a slice of StoppingText.
func (op *StoppingText_Slice) Repeats() bool {
	return len(*op) > 0
}

// A valueless field.
// Intended mainly as a way for patterns which don't return a value.
type NothingField struct {
	Markup map[string]any
}

// nothing_field, a type of flow.
var Zt_NothingField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NothingField) TypeInfo() typeinfo.T {
	return &Zt_NothingField
}

// Implements [typeinfo.Markup]
func (op *NothingField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*NothingField)(nil)

// Holds a slice of type NothingField.
type NothingField_Slice []NothingField

// Implements [typeinfo.Instance] for a slice of NothingField.
func (*NothingField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NothingField
}

// Implements [typeinfo.Repeats] for a slice of NothingField.
func (op *NothingField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing an aspect ( aka. a set of states. )
// Aspects are defined using the {"Define state:names:"} command.
type AspectField struct {
	AspectName rtti.TextEval
	Markup     map[string]any
}

// aspect_field, a type of flow.
var Zt_AspectField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AspectField) TypeInfo() typeinfo.T {
	return &Zt_AspectField
}

// Implements [typeinfo.Markup]
func (op *AspectField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*AspectField)(nil)

// Holds a slice of type AspectField.
type AspectField_Slice []AspectField

// Implements [typeinfo.Instance] for a slice of AspectField.
func (*AspectField_Slice) TypeInfo() typeinfo.T {
	return &Zt_AspectField
}

// Implements [typeinfo.Repeats] for a slice of AspectField.
func (op *AspectField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a boolean ( true/false ) value.
// As a special case, when used to define a boolean field in a kind,
// the boolean becomes a state set consisting of the state and its opposite.
// For instance, a boolean field called "reasonable" generates a set called "reasonable status" and the states "reasonable" and "not reasonable."
type BoolField struct {
	FieldName rtti.TextEval
	Initially rtti.BoolEval
	Markup    map[string]any
}

// bool_field, a type of flow.
var Zt_BoolField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*BoolField) TypeInfo() typeinfo.T {
	return &Zt_BoolField
}

// Implements [typeinfo.Markup]
func (op *BoolField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*BoolField)(nil)

// Holds a slice of type BoolField.
type BoolField_Slice []BoolField

// Implements [typeinfo.Instance] for a slice of BoolField.
func (*BoolField_Slice) TypeInfo() typeinfo.T {
	return &Zt_BoolField
}

// Implements [typeinfo.Repeats] for a slice of BoolField.
func (op *BoolField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a single number.
type NumberField struct {
	FieldName rtti.TextEval
	Initially rtti.NumberEval
	Markup    map[string]any
}

// number_field, a type of flow.
var Zt_NumberField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NumberField) TypeInfo() typeinfo.T {
	return &Zt_NumberField
}

// Implements [typeinfo.Markup]
func (op *NumberField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*NumberField)(nil)

// Holds a slice of type NumberField.
type NumberField_Slice []NumberField

// Implements [typeinfo.Instance] for a slice of NumberField.
func (*NumberField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NumberField
}

// Implements [typeinfo.Repeats] for a slice of NumberField.
func (op *NumberField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a single record.
type RecordField struct {
	FieldName  rtti.TextEval
	RecordName rtti.TextEval
	Initially  rtti.RecordEval
	Markup     map[string]any
}

// record_field, a type of flow.
var Zt_RecordField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RecordField) TypeInfo() typeinfo.T {
	return &Zt_RecordField
}

// Implements [typeinfo.Markup]
func (op *RecordField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*RecordField)(nil)

// Holds a slice of type RecordField.
type RecordField_Slice []RecordField

// Implements [typeinfo.Instance] for a slice of RecordField.
func (*RecordField_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordField
}

// Implements [typeinfo.Repeats] for a slice of RecordField.
func (op *RecordField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a single piece of text.
// Text fields can be used to store anything from the name of a noun, the name of a state or set of states, or something to display to the player.
type TextField struct {
	FieldName rtti.TextEval
	KindName  rtti.TextEval
	Initially rtti.TextEval
	Markup    map[string]any
}

// text_field, a type of flow.
var Zt_TextField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TextField) TypeInfo() typeinfo.T {
	return &Zt_TextField
}

// Implements [typeinfo.Markup]
func (op *TextField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*TextField)(nil)

// Holds a slice of type TextField.
type TextField_Slice []TextField

// Implements [typeinfo.Instance] for a slice of TextField.
func (*TextField_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextField
}

// Implements [typeinfo.Repeats] for a slice of TextField.
func (op *TextField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a list of text.
type TextListField struct {
	FieldName rtti.TextEval
	KindName  rtti.TextEval
	Initially rtti.TextListEval
	Markup    map[string]any
}

// text_list_field, a type of flow.
var Zt_TextListField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TextListField) TypeInfo() typeinfo.T {
	return &Zt_TextListField
}

// Implements [typeinfo.Markup]
func (op *TextListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*TextListField)(nil)

// Holds a slice of type TextListField.
type TextListField_Slice []TextListField

// Implements [typeinfo.Instance] for a slice of TextListField.
func (*TextListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextListField
}

// Implements [typeinfo.Repeats] for a slice of TextListField.
func (op *TextListField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a list of numbers.
type NumListField struct {
	FieldName rtti.TextEval
	Initially rtti.NumListEval
	Markup    map[string]any
}

// num_list_field, a type of flow.
var Zt_NumListField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*NumListField) TypeInfo() typeinfo.T {
	return &Zt_NumListField
}

// Implements [typeinfo.Markup]
func (op *NumListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*NumListField)(nil)

// Holds a slice of type NumListField.
type NumListField_Slice []NumListField

// Implements [typeinfo.Instance] for a slice of NumListField.
func (*NumListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NumListField
}

// Implements [typeinfo.Repeats] for a slice of NumListField.
func (op *NumListField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a list of records.
// All of the records in the list must be of the same type.
type RecordListField struct {
	FieldName  rtti.TextEval
	RecordName rtti.TextEval
	Initially  rtti.RecordListEval
	Markup     map[string]any
}

// record_list_field, a type of flow.
var Zt_RecordListField typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RecordListField) TypeInfo() typeinfo.T {
	return &Zt_RecordListField
}

// Implements [typeinfo.Markup]
func (op *RecordListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ FieldDefinition = (*RecordListField)(nil)

// Holds a slice of type RecordListField.
type RecordListField_Slice []RecordListField

// Implements [typeinfo.Instance] for a slice of RecordListField.
func (*RecordListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordListField
}

// Implements [typeinfo.Repeats] for a slice of RecordListField.
func (op *RecordListField_Slice) Repeats() bool {
	return len(*op) > 0
}

// Used as part of [DefineRelation] to declare a new kind of relationship between nouns.
type RelationCardinality int

// The enumerated values of RelationCardinality.
const (
	C_RelationCardinality_OneToOne RelationCardinality = iota
	C_RelationCardinality_OneToMany
	C_RelationCardinality_ManyToOne
	C_RelationCardinality_ManyToMany
)

func MakeRelationCardinality(str string) (ret RelationCardinality, okay bool) {
	if i := Zt_RelationCardinality.FindOption(str); i >= 0 {
		ret, okay = RelationCardinality(i), true
	}
	return
}

func (op RelationCardinality) String() (ret string) {
	if i, opts := int(op), Zt_RelationCardinality.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid RelationCardinality(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// relation_cardinality, a type of str enum.
var Zt_RelationCardinality = typeinfo.Str{
	Name: "relation_cardinality",
	Options: []string{
		"one_to_one",
		"one_to_many",
		"many_to_one",
		"many_to_many",
	},
	Markup: map[string]any{
		"comment": "Used as part of [DefineRelation] to declare a new kind of relationship between nouns.",
	},
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_StoryFile = typeinfo.Flow{
		Name: "story_file",
		Lede: "tapestry",
		Terms: []typeinfo.Term{{
			Name:    "statements",
			Repeats: true,
			Type:    &Zt_StoryStatement,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"blockly-color": "TAP_HUE_ROOT",
			"comment":       []interface{}{"Used internally as the container for every .tell file.", "Implements Story Statement to simplify how flex parsing works."},
			"mosaic-root":   true,
		},
	}
	Zt_StoryBreak = typeinfo.Flow{
		Name:  "story_break",
		Lede:  "--",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "A legacy command, used in .if files as a visual divider ( because reading and writing json doesn't otherwise have a way to preserve whitespace. )",
		},
	}
	Zt_Note = typeinfo.Flow{
		Name: "note",
		Lede: "note",
		Terms: []typeinfo.Term{{
			Name:    "lines",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more lines of text documentation.",
			},
			Type: &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Adds documentation about the story for you and other authors.", "Notes can used as a modeling commands, or as part of an execute block.", "And, they are created automatically from hash-style comments (#) encountered within the plain text sections of tell files.", "When used in an execute block, notes become {\"Log:value:\"} commands."},
		},
	}
	Zt_DefineTest = typeinfo.Flow{
		Name: "define_test",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "test_name",
			Label: "test",
			Markup: map[string]any{
				"comment": "A unique name for the test.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:     "required_scene_names",
			Label:    "requires",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"One or more scenes that this test depends on.", "Tests implicitly depend upon the scene within which they are defined.", "In order to reference the nouns, kinds, etc. of any other scenes in a test, that scene must be listed here."},
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:     "statements",
			Label:    "scene",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "Modeling commands for defining nouns, kinds, game rules, etc. used by this test. Those definitions will not be visible outside of the test ( unless this test is \"required\" by another. )",
			},
			Type: &Zt_StoryStatement,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"One or more commands to run when checking the test.", "The {\"Expect:\"} command will trigger a test failure when an author specified condition is not met."},
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a scene used for testing a story.", "Tests can be executed using the `tap check` command.", "TODO: see https://todo.sr.ht/~ionous/tapestry/42"},
		},
	}
	Zt_DefineScene = typeinfo.Flow{
		Name: "define_scene",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "scene_name",
			Label: "scene",
			Markup: map[string]any{
				"comment": "A unique name for the scene.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "required_scene_names",
			Label:    "requires",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"One or more scenes that this scene depends on.", "This is a one-way dependency. This scene can reference anything defined within the required scenes; the required scenes cannot reference anything declared within this scene. Circular dependencies are prevented by weave."},
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:     "statements",
			Label:    "with",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "Modeling commands for the defining nouns, kinds, game rules, etc. used by this scene.",
			},
			Type: &Zt_StoryStatement,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a collection of nouns, kinds, game rules, etc. used the game.", "Every .tell story has its own unique scene."},
		},
	}
	Zt_DefineAction = typeinfo.Flow{
		Name: "define_action",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "action",
			Markup: map[string]any{
				"comment": "A unique name for the action.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"Parameters to customize the behavior of an action.", "Most actions require an actor, and possibly one or two other objects.", "For instance: the standard \"storing\" action -- used for inserting something into a container -- requires an actor to perform the action, an object to store, and a container to receive that object."},
			},
			Type: &Zt_FieldDefinition,
		}, {
			Name:     "provides",
			Label:    "provides",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "A list of any local variables needed by the action carry out its behavior.",
			},
			Type: &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines an in-game behavior that can be triggered by an actor.", "Actions are a special kind of pattern, and like patterns use \"rules\" to define and customize their behavior. The shared library includes many common actions including things like moving from room to room, examining something, taking or dropping items, and so on.", "See the Tapestry guide for more information."},
		},
	}
	Zt_DefineState = typeinfo.Flow{
		Name: "define_state",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "aspect_name",
			Label: "state",
			Markup: map[string]any{
				"comment": "A unique name for the set of states.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "state_names",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"The names of the states in the set.", "TODO: a list of containing only one state should probably automatically generate its opposite the way that [BoolField] does."},
			},
			Type: &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a set of mutually exclusive states that can be assigned to any kind of noun. By default, every noun with this set of states starts the game with the first state listed by this command. At runtime, a script can change to other states, ask whether a noun is in a particular state, or ask for the name of the current state from the set.", "Internally, these are also known as \"aspects\" and \"traits.\"", "Many programming languages refer to these as \"enumerations.\"", "See also: {\"Set:state:\"} and {\"Object:field:\"}"},
		},
	}
	Zt_DefineAlias = typeinfo.Flow{
		Name: "define_alias",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "alias",
			Markup: map[string]any{
				"comment": "One or more alternative names for a noun.",
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:  "noun_name",
			Label: "as",
			Markup: map[string]any{
				"comment": "The noun the aliases refer to.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Interpret a name typed by the player as some existing noun.", "For example, if there is a noun called \"the book\", the story could define", "an alias so that \"tome\" also means the book."},
		},
	}
	Zt_DefineLeadingGrammar = typeinfo.Flow{
		Name: "define_leading_grammar",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:    "lede",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"One or more words to match against the player's input.", "For example, the standard \"examine\" action lists the words:", "\"examine\", \"x\", and \"describe\" all of which the player can use", "to trigger inspect a particular object."},
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "scans",
			Label:   "with",
			Repeats: true,
			Markup: map[string]any{
				"comment": "A tree of commands used to parse subsequent words.",
			},
			Type: &grammar.Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Creates a grammar used to parse player input.", "See the Tapestry guide for details."},
		},
	}
	Zt_DefineNamedGrammar = typeinfo.Flow{
		Name: "define_named_grammar",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "name",
			Markup: map[string]any{
				"comment": "A unique name which other grammars can use to refer the grammar defined by this command.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "scans",
			Label:   "with",
			Repeats: true,
			Markup: map[string]any{
				"comment": "A tree of commands used to parse player input.",
			},
			Type: &grammar.Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Creates a grammar to parse player input that can be referenced in other grammars.", "It can also be used for grammars that need more flexibility in matching the initial words of a sentence ( because {\"Interpret:with:\"} depends on a set of fixed words. )"},
		},
	}
	Zt_DeclareStatement = typeinfo.Flow{
		Name: "declare_statement",
		Lede: "declare",
		Terms: []typeinfo.Term{{
			Name: "text",
			Markup: map[string]any{
				"comment": "A single text string containing one or more plain English sentences used to model the game world.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "assign",
			Label:    "assign",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"The last sentence of the specified text can sometimes ( depending on the sentence structure ) break out into runtime commands. Those sentences always end with a colon.", "Most often, these are rules. For instance: {\"Instead of jumping:\" .... do something.}"},
			},
			Type: &rtti.Zt_Assignment,
		}, {
			Name:    "matches",
			Label:   "matches",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Used internally to contain the plain-text sections of .tell documents.", "Contains English-like definitions of nouns, kinds, and their relatives."},
		},
	}
	Zt_DefineRelation = typeinfo.Flow{
		Name: "define_relation",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "relation_name",
			Label: "relation",
			Markup: map[string]any{
				"comment": "Unique name for the relation.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "kind_name",
			Label: "kind",
			Markup: map[string]any{
				"comment": "The kind of nouns allowed on the \"left side\" of a relation.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "other_kind_name",
			Label: "other_kind",
			Markup: map[string]any{
				"comment": "The kind of nouns allowed on the \"right side\" of a relation.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "cardinality",
			Label: "cardinality",
			Markup: map[string]any{
				"comment": []interface{}{"Determines the number of times a noun can appear on the left", "or the right side of a given relation."},
			},
			Type: &Zt_RelationCardinality,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a connection between different kinds of nouns.", "The shared library, for instance, defines a spatial relation between objects;", "allowing one object to be placed inside another."},
		},
	}
	Zt_DefineKind = typeinfo.Flow{
		Name: "define_kind",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kind_name",
			Label: "kind",
			Markup: map[string]any{
				"comment": "A unique name for this kind.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "ancestor_kind_name",
			Label: "ancestor",
			Markup: map[string]any{
				"comment": []interface{}{"The parent of this kind.", "( In point of fact, this can be any ancestor of the kind", "so long as it doesn't conflict with other [DefineKind] statements. )"},
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a new kind: a set of properties used by game objects.", "This command is similar to a sentence like:", "\"Doors are a kind of opener.\""},
		},
	}
	Zt_DefineFields = typeinfo.Flow{
		Name: "define_fields",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kind_name",
			Label: "kind",
			Markup: map[string]any{
				"comment": "The name of the kind to which the fields will be assigned.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "field_names",
			Label:   "fields",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more fields to add to the kind.",
			},
			Type: &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Adds properties to an existing kind.", "This command is similar to a sentence like:", "\"Things have some text called a description.\""},
		},
	}
	Zt_DefinePlural = typeinfo.Flow{
		Name: "define_plural",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "singular",
			Label: "singular",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "plural",
			Label: "plural",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Controls how Tapestry pluralize words.", "Plurals are used both at runtime and during weave to", "guide the interpretation of nouns and kinds.", "A singular word can have multiple plurals;", "a plural word only has one singular form.", "For example:", "\"The plural of person is people.\"", "\"The plural of person is persons.\""},
		},
	}
	Zt_DefineNounKind = typeinfo.Flow{
		Name: "define_noun_kind",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "noun_name",
			Label: "noun",
			Markup: map[string]any{
				"comment": "The name of a new, or existing noun.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "kind_name",
			Label: "kind",
			Markup: map[string]any{
				"comment": "The name of an existing kind that describes the type of the noun.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Ensures that a noun of the specified name and kind exists in the world.",
		},
	}
	Zt_DefineNounValue = typeinfo.Flow{
		Name: "define_noun_value",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "noun_name",
			Label: "noun",
			Markup: map[string]any{
				"comment": "The name of an existing noun.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "field_name",
			Label: "value",
			Markup: map[string]any{
				"comment": []interface{}{"The name of the property to set.", "( The property must have been defined by the noun's kind or one of its ancestor kinds. )"},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "value",
			Label: "initially",
			Markup: map[string]any{
				"comment": []interface{}{"The value to assign the noun.", "The type of the value must match the type of the property.", "( ie. Text values can't be assigned to number properties, etc. )"},
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Assigns an initial value to a existing noun.",
		},
	}
	Zt_DefineNounStates = typeinfo.Flow{
		Name: "define_noun_states",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "noun_name",
			Label: "noun",
			Markup: map[string]any{
				"comment": "The name of an existing noun.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "state_names",
			Label: "states",
			Markup: map[string]any{
				"comment": []interface{}{"The state names to assign to the noun.", "The states must be part of a state set used by the noun's kind or one of its ancestor kinds."},
			},
			Type: &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Assigns one or more initial states to a existing noun.",
		},
	}
	Zt_DefinePattern = typeinfo.Flow{
		Name: "define_pattern",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "pattern",
			Markup: map[string]any{
				"comment": "A unique name for the pattern.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"Parameters a caller can specify when triggering the pattern.", "Despite the name, whether the parameters are actually required depends on the pattern's specific implementation."},
			},
			Type: &Zt_FieldDefinition,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"Local variables used by the pattern to carry out its goals.", "As a special case, the first provided variable also acts as a return value for the pattern."},
			},
			Type: &Zt_FieldDefinition,
		}, {
			Name:     "exe",
			Label:    "do",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "The default behavior of the pattern if no other rule applies.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Declares a new pattern.", "A pattern is a set of author defined rules used at runtime to either change the game world, or to provide information about it. Patterns are the Tapestry equivalent of functions."},
		},
	}
	Zt_DefinePatternProvides = typeinfo.Flow{
		Name: "define_pattern_provides",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "pattern",
			Markup: map[string]any{
				"comment": "The name of an existing pattern.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more variables that the pattern can use to carry out its goals.",
			},
			Type: &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Adds one or more local variable to an existing pattern.",
		},
	}
	Zt_DefineRule = typeinfo.Flow{
		Name: "define_rule",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Markup: map[string]any{
				"comment": []interface{}{"The pattern to which this rule applies.", "For event listeners, the name can start with a modifier which changes the event phase in which the rule applies:", "\"before\", \"instead of\", \"when\", \"after\", and \"report\".", "The modifier can be followed by the word \"someone\" so that it applies to all actors and not just the player."},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"Optionally, specify a unique name for the rule.", "Giving a rule a name allows it to be replaced by later rules."},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "The behavior of the rule.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "", "For patterns defined using [DefinePattern], if a rule starts with a [core.ChooseBranch] command, and none of the branches are chosen, the pattern checks the next specified rule; and so on, until the pattern finds a branch that succeeds.", "", "For patterns defined using [DefineAction], rules behave as \"event listeners\". They continue to the next listener unless specifically stopped. And, by default, they only respond to actions triggered by the player.", "", "See the Tapestry guide for more in-depth information."},
		},
	}
	Zt_DefineNounRule = typeinfo.Flow{
		Name: "define_noun_rule",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "noun_name",
			Label: "noun",
			Markup: map[string]any{
				"comment": "The name of the noun to which this rule applies.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "pattern_name",
			Label: "rule",
			Markup: map[string]any{
				"comment": "The pattern to which this rule applies.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Markup: map[string]any{
				"comment": "Optionally, specify a unique name for the rule.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "The behavior of the rule.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Adds an \"event listener\" which only runs if the target of the triggered action is the specified noun. See [DefineRule] for more information.",
		},
	}
	Zt_DefineKindRule = typeinfo.Flow{
		Name: "define_kind_rule",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kind_name",
			Label: "kind",
			Markup: map[string]any{
				"comment": "The name of the kind to which this rule applies.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "pattern_name",
			Label: "rule",
			Markup: map[string]any{
				"comment": "The pattern to which this rule applies.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Markup: map[string]any{
				"comment": "Optionally, specify a unique name for the rule.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": "The behavior of the rule.",
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Adds an \"event listener\" which only runs if the target of the triggered action a noun of the specified kind. See [DefineRule] for more information.",
		},
	}
	Zt_DefineRelatives = typeinfo.Flow{
		Name: "define_relatives",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "relation_name",
			Label: "relative",
			Markup: map[string]any{
				"comment": "The name of an existing relationship.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "noun_names",
			Label: "nouns",
			Markup: map[string]any{
				"comment": "The names of one or more nouns for the \"left side\" of this pairing.",
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:  "other_noun_names",
			Label: "other_nouns",
			Markup: map[string]any{
				"comment": "The names of one or more nouns for the \"right side\" of this pairing.",
			},
			Type: &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Relate nouns to each other.", "Most users will probably prefer defining verbs and using jess to relate nouns.", "For instance: \"Carrying is a verb. The relation of carrying is whereabouts. Bob is carrying the pen.\"", "See the Tapestry guide for details."},
		},
	}
	Zt_SayTemplate = typeinfo.Flow{
		Name: "say_template",
		Lede: "say",
		Terms: []typeinfo.Term{{
			Name: "template",
			Type: &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Print templated text. Templates contain commands executed at runtime.", "See the Tapestry guide for more information."},
		},
	}
	Zt_SayResponse = typeinfo.Flow{
		Name: "say_response",
		Lede: "say",
		Terms: []typeinfo.Term{{
			Name:  "response_name",
			Label: "response",
			Markup: map[string]any{
				"comment": "A globally unique name for the response.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:  "text",
			Label: "with",
			Markup: map[string]any{
				"comment": "The default text used for this response.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Print text in a replaceable manner.", "Each response has a unique name and a default bit of text it responds with.", "The response can be changed everywhere its used by replacing that text.", "( ex. by using {\"Define kind:fields\": \"response\", \"name of the response\"} )", "", "The shared library uses responses for much of what it prints to the player", "so that stories can change the stock phrases."},
		},
	}
	Zt_CountOf = typeinfo.Flow{
		Name: "count_of",
		Lede: "count_of",
		Terms: []typeinfo.Term{{
			Name: "trigger",
			Markup: map[string]any{
				"comment": "A unique name for this counter.",
			},
			Type: &core.Zt_Trigger,
		}, {
			Name:  "num",
			Label: "num",
			Markup: map[string]any{
				"comment": "The value at which this counter will start to return true.",
			},
			Type: &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A guard which returns true based on a counter.", "Counters start at zero and are incremented every time the guard is checked."},
		},
	}
	Zt_CycleText = typeinfo.Flow{
		Name: "cycle_text",
		Lede: "cycle_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more pieces of text to cycle through.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns a single piece of text selected from a set of predefined values. When called multiple times, returns each one of the values in their specified order, then loops.",
		},
	}
	Zt_ShuffleText = typeinfo.Flow{
		Name: "shuffle_text",
		Lede: "shuffle_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more pieces of text to shuffle through.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns a single piece of text selected from a set of predefined values. When called multiple times, returns each one of the values in a randomized order. After returning the available options, begins again with a new ordering.",
		},
	}
	Zt_StoppingText = typeinfo.Flow{
		Name: "stopping_text",
		Lede: "stopping_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more pieces of text to shift through.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Returns a single piece of text selected from a set of predefined values. When called multiple times returns each of its inputs in turn, sticking to the last one.", "As a special case, if there was only ever one option, returns that option followed by the empty string forever after."},
		},
	}
	Zt_NothingField = typeinfo.Flow{
		Name:  "nothing_field",
		Lede:  "nothing",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A valueless field.", "Intended mainly as a way for patterns which don't return a value."},
		},
	}
	Zt_AspectField = typeinfo.Flow{
		Name: "aspect_field",
		Lede: "aspect",
		Terms: []typeinfo.Term{{
			Name: "aspect_name",
			Markup: map[string]any{
				"comment": []interface{}{"Name for the aspect. Must be unique within the set of fields (eg. within the kind.)", "The field will have this same name."},
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A field containing an aspect ( aka. a set of states. )", "Aspects are defined using the {\"Define state:names:\"} command."},
		},
	}
	Zt_BoolField = typeinfo.Flow{
		Name: "bool_field",
		Lede: "bool",
		Terms: []typeinfo.Term{{
			Name: "field_name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "An initial value for the field, true if not otherwise specified.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A field containing a boolean ( true/false ) value.", "As a special case, when used to define a boolean field in a kind,", "the boolean becomes a state set consisting of the state and its opposite.", "For instance, a boolean field called \"reasonable\" generates a set called \"reasonable status\" and the states \"reasonable\" and \"not reasonable.\""},
		},
	}
	Zt_NumberField = typeinfo.Flow{
		Name: "number_field",
		Lede: "number",
		Terms: []typeinfo.Term{{
			Name: "field_name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; zero if not specified.",
			},
			Type: &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": "A field containing a single number.",
		},
	}
	Zt_RecordField = typeinfo.Flow{
		Name: "record_field",
		Lede: "record",
		Terms: []typeinfo.Term{{
			Name: "field_name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "record_name",
			Label: "kind",
			Markup: map[string]any{
				"comment": "The name of a valid record type.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"Provides a default value.", "If not specified, accessing the field in go returns nil;", "accessing via script returns a blank record with zero value fields."},
			},
			Type: &rtti.Zt_RecordEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": "A field containing a single record.",
		},
	}
	Zt_TextField = typeinfo.Flow{
		Name: "text_field",
		Lede: "text",
		Terms: []typeinfo.Term{{
			Name: "field_name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "kind_name",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": "A hint that this text refers to an object or some other predefined concept in the game world.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; the empty string if not specified.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A field containing a single piece of text.", "Text fields can be used to store anything from the name of a noun, the name of a state or set of states, or something to display to the player."},
		},
	}
	Zt_TextListField = typeinfo.Flow{
		Name: "text_list_field",
		Lede: "text_list",
		Terms: []typeinfo.Term{{
			Name: "field_name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "kind_name",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": "A hint that the specified text might refer to an object or some other predefined concept in the game world.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; an empty list if not specified.",
			},
			Type: &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": "A field containing a list of text.",
		},
	}
	Zt_NumListField = typeinfo.Flow{
		Name: "num_list_field",
		Lede: "num_list",
		Terms: []typeinfo.Term{{
			Name: "field_name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; an empty list if not specified.",
			},
			Type: &rtti.Zt_NumListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": "A field containing a list of numbers.",
		},
	}
	Zt_RecordListField = typeinfo.Flow{
		Name: "record_list_field",
		Lede: "record_list",
		Terms: []typeinfo.Term{{
			Name: "field_name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "record_name",
			Label: "kind",
			Markup: map[string]any{
				"comment": []interface{}{"The name of a valid record type.", "All records in the list must be of this type."},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; an empty list if not specified.",
			},
			Type: &rtti.Zt_RecordListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A field containing a list of records.", "All of the records in the list must be of the same type."},
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "story",
	Comment: []string{
		"Contains modeling commands used to define a game world. These commands include the description of scenes, kinds of objects, specific nouns and their properties, the placement and relation between nouns, and so on.",
		"",
		"Most authors will probably prefer the jess plain english style of modeling over these, more explicit, commands. However, there are some commands -- like defining scenes -- which don't currently have a corollary within jess.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_StoryStatement,
	&Zt_FieldDefinition,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_StoryFile,
	&Zt_StoryBreak,
	&Zt_Note,
	&Zt_DefineTest,
	&Zt_DefineScene,
	&Zt_DefineAction,
	&Zt_DefineState,
	&Zt_DefineAlias,
	&Zt_DefineLeadingGrammar,
	&Zt_DefineNamedGrammar,
	&Zt_DeclareStatement,
	&Zt_DefineRelation,
	&Zt_DefineKind,
	&Zt_DefineFields,
	&Zt_DefinePlural,
	&Zt_DefineNounKind,
	&Zt_DefineNounValue,
	&Zt_DefineNounStates,
	&Zt_DefinePattern,
	&Zt_DefinePatternProvides,
	&Zt_DefineRule,
	&Zt_DefineNounRule,
	&Zt_DefineKindRule,
	&Zt_DefineRelatives,
	&Zt_SayTemplate,
	&Zt_SayResponse,
	&Zt_CountOf,
	&Zt_CycleText,
	&Zt_ShuffleText,
	&Zt_StoppingText,
	&Zt_NothingField,
	&Zt_AspectField,
	&Zt_BoolField,
	&Zt_NumberField,
	&Zt_RecordField,
	&Zt_TextField,
	&Zt_TextListField,
	&Zt_NumListField,
	&Zt_RecordListField,
}

// A list of all strs in this this package.
var z_str_list = []*typeinfo.Str{
	&Zt_RelationCardinality,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	4360765066804052293:  (*StoryBreak)(nil),            /* story_statement=-- */
	13010292396640781698: (*AspectField)(nil),           /* field_definition=Aspect: */
	12738236274201716794: (*BoolField)(nil),             /* field_definition=Bool: */
	18077675806901364237: (*BoolField)(nil),             /* field_definition=Bool:initially: */
	10143132576483224253: (*CountOf)(nil),               /* bool_eval=CountOf:num: */
	231398832069830353:   (*CycleText)(nil),             /* text_eval=CycleText: */
	9796202271034753943:  (*DeclareStatement)(nil),      /* story_statement=Declare: */
	11228697653156044284: (*DeclareStatement)(nil),      /* story_statement=Declare:assign: */
	14790755516297707674: (*DefineAction)(nil),          /* story_statement=Define action:requires: */
	5312053119535959994:  (*DefineAction)(nil),          /* story_statement=Define action:requires:provides: */
	12790170204334923961: (*DefineKind)(nil),            /* story_statement=Define kind:ancestor: */
	15268150405724581221: (*DefineFields)(nil),          /* story_statement=Define kind:fields: */
	2634771595010145133:  (*DefineKindRule)(nil),        /* story_statement=Define kind:rule:do: */
	3253027546625561654:  (*DefineKindRule)(nil),        /* story_statement=Define kind:rule:named:do: */
	16821098817155896534: (*DefineNounKind)(nil),        /* story_statement=Define noun:kind: */
	9340117308812628027:  (*DefineNounRule)(nil),        /* story_statement=Define noun:rule:do: */
	10622511977506449612: (*DefineNounRule)(nil),        /* story_statement=Define noun:rule:named:do: */
	3688969656849355942:  (*DefineNounStates)(nil),      /* story_statement=Define noun:states: */
	9478300892459390916:  (*DefineNounValue)(nil),       /* story_statement=Define noun:value:initially: */
	2173982977263897352:  (*DefinePatternProvides)(nil), /* story_statement=Define pattern:provides: */
	14040325709851010602: (*DefinePattern)(nil),         /* story_statement=Define pattern:requires:provides: */
	729326910659609567:   (*DefinePattern)(nil),         /* story_statement=Define pattern:requires:provides:do: */
	15951965898335032430: (*DefineRelation)(nil),        /* story_statement=Define relation:kind:otherKind:cardinality: */
	7218292999752256394:  (*DefineRelatives)(nil),       /* story_statement=Define relative:nouns:otherNouns: */
	18093984368234904277: (*DefineRule)(nil),            /* story_statement=Define rule:do: */
	2007307886252117326:  (*DefineRule)(nil),            /* story_statement=Define rule:named:do: */
	16728157364207612750: (*DefineScene)(nil),           /* story_statement=Define scene: */
	10681959011863226668: (*DefineScene)(nil),           /* story_statement=Define scene:requires: */
	10209709135447127962: (*DefineScene)(nil),           /* story_statement=Define scene:requires:with: */
	13479298094295759568: (*DefineScene)(nil),           /* story_statement=Define scene:with: */
	1798652288281835623:  (*DefinePlural)(nil),          /* story_statement=Define singular:plural: */
	17999974279653753583: (*DefineState)(nil),           /* story_statement=Define state:names: */
	12489141410311466071: (*DefineTest)(nil),            /* story_statement=Define test:do: */
	3712030102885900665:  (*DefineTest)(nil),            /* story_statement=Define test:requires:do: */
	16978239348269462739: (*DefineTest)(nil),            /* story_statement=Define test:requires:scene:do: */
	13333326165932249009: (*DefineTest)(nil),            /* story_statement=Define test:scene:do: */
	12975771225654832812: (*DefineAlias)(nil),           /* story_statement=Interpret alias:as: */
	8001652437005351387:  (*DefineNamedGrammar)(nil),    /* story_statement=Interpret name:with: */
	6001249499689096432:  (*DefineLeadingGrammar)(nil),  /* story_statement=Interpret:with: */
	16242102660676547183: (*Note)(nil),                  /* execute=Note: */
	17718266473581357115: (*Note)(nil),                  /* story_statement=Note: */
	14427731589588473385: (*NothingField)(nil),          /* field_definition=Nothing */
	10299801658819864730: (*NumListField)(nil),          /* field_definition=NumList: */
	12762197545337845485: (*NumListField)(nil),          /* field_definition=NumList:initially: */
	16579038690333872565: (*NumberField)(nil),           /* field_definition=Number: */
	7599754526096278866:  (*NumberField)(nil),           /* field_definition=Number:initially: */
	7215961239288768263:  (*RecordField)(nil),           /* field_definition=Record:kind: */
	8334583613109868292:  (*RecordField)(nil),           /* field_definition=Record:kind:initially: */
	15479801779125468947: (*RecordListField)(nil),       /* field_definition=RecordList:kind: */
	17384295137903978384: (*RecordListField)(nil),       /* field_definition=RecordList:kind:initially: */
	12945074305202371477: (*SayResponse)(nil),           /* execute=Say response:with: */
	7921553818502082370:  (*SayResponse)(nil),           /* text_eval=Say response:with: */
	9556993961571292952:  (*SayTemplate)(nil),           /* execute=Say: */
	15989777734244204735: (*SayTemplate)(nil),           /* text_eval=Say: */
	9910951906340888308:  (*ShuffleText)(nil),           /* text_eval=ShuffleText: */
	13921723804355948971: (*StoppingText)(nil),          /* text_eval=StoppingText: */
	12956316934318450345: (*StoryFile)(nil),             /* story_statement=Tapestry: */
	9387832592330456403:  (*TextField)(nil),             /* field_definition=Text: */
	16637694412733787472: (*TextField)(nil),             /* field_definition=Text:initially: */
	15791809714384972761: (*TextField)(nil),             /* field_definition=Text:kind: */
	16917317465644840422: (*TextField)(nil),             /* field_definition=Text:kind:initially: */
	3830912410254339707:  (*TextListField)(nil),         /* field_definition=TextList: */
	15743255383721832504: (*TextListField)(nil),         /* field_definition=TextList:initially: */
	2011197685129757745:  (*TextListField)(nil),         /* field_definition=TextList:kind: */
	3232692879001227038:  (*TextListField)(nil),         /* field_definition=TextList:kind:initially: */
}
