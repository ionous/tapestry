// Contains modeling commands used to define a game world. These commands include the description of scenes, kinds of objects, specific nouns and their properties, the placement and relation between nouns, and so on.
//
// Most authors will probably prefer the jess plain english style of modeling over these, more explicit, commands. However, there are some commands -- like defining scenes -- which don't currently have a corollary within jess.
package story

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/grammar"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// story_statement, a type of slot.
var Zt_StoryStatement = typeinfo.Slot{
	Name: "story_statement",
	Markup: map[string]any{
		"blockly-color": "VARIABLES_HUE",
		"blockly-stack": true,
		"comment":       "A slot for modeling commands, used define a game world. All commands in a tell file start with a story statement. Specific commands can specify slots for other commands including those for running scripts, parsing the player's input, and more.",
	},
}

// holds a single slot.
type StoryStatement_Slot struct{ Value StoryStatement }

// implements typeinfo.Instance for a single slot.
func (*StoryStatement_Slot) TypeInfo() typeinfo.T {
	return &Zt_StoryStatement
}

// holds a slice of slots.
type StoryStatement_Slots []StoryStatement

// implements typeinfo.Instance for a series of slots.
func (*StoryStatement_Slots) TypeInfo() typeinfo.T {
	return &Zt_StoryStatement
}

// implements typeinfo.Repeats
func (op *StoryStatement_Slots) Repeats() bool {
	return len(*op) > 0
}

// field_definition, a type of slot.
var Zt_FieldDefinition = typeinfo.Slot{
	Name: "field_definition",
	Markup: map[string]any{
		"comment": "Fields are used to define the members of kinds, records, patterns, and so on.",
	},
}

// holds a single slot.
type FieldDefinition_Slot struct{ Value FieldDefinition }

// implements typeinfo.Instance for a single slot.
func (*FieldDefinition_Slot) TypeInfo() typeinfo.T {
	return &Zt_FieldDefinition
}

// holds a slice of slots.
type FieldDefinition_Slots []FieldDefinition

// implements typeinfo.Instance for a series of slots.
func (*FieldDefinition_Slots) TypeInfo() typeinfo.T {
	return &Zt_FieldDefinition
}

// implements typeinfo.Repeats
func (op *FieldDefinition_Slots) Repeats() bool {
	return len(*op) > 0
}

// Used internally as the container for every .tell file.
// Implements Story Statement to simplify how flex parsing works.
type StoryFile struct {
	Statements []StoryStatement
	Markup     map[string]any
}

// story_file, a type of flow.
var Zt_StoryFile typeinfo.Flow

// implements typeinfo.Instance
func (*StoryFile) TypeInfo() typeinfo.T {
	return &Zt_StoryFile
}

// implements typeinfo.Markup
func (op *StoryFile) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*StoryFile)(nil)

// holds a slice of type story_file
type StoryFile_Slice []StoryFile

// implements typeinfo.Instance
func (*StoryFile_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoryFile
}

// implements typeinfo.Repeats
func (op *StoryFile_Slice) Repeats() bool {
	return len(*op) > 0
}

// A legacy command, used in .if files as a visual divider ( because reading and writing json doesn't otherwise have a way to preserve whitespace. )
type StoryBreak struct {
	Markup map[string]any
}

// story_break, a type of flow.
var Zt_StoryBreak typeinfo.Flow

// implements typeinfo.Instance
func (*StoryBreak) TypeInfo() typeinfo.T {
	return &Zt_StoryBreak
}

// implements typeinfo.Markup
func (op *StoryBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*StoryBreak)(nil)

// holds a slice of type story_break
type StoryBreak_Slice []StoryBreak

// implements typeinfo.Instance
func (*StoryBreak_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoryBreak
}

// implements typeinfo.Repeats
func (op *StoryBreak_Slice) Repeats() bool {
	return len(*op) > 0
}

// Adds documentation about the story for you and other authors.
// Notes can used as a modeling commands, or as part of an execute block.
// And, they are created automatically from hash-style comments (#) encountered within the plain text sections of tell files.
// When used in an execute block, notes become {"Log:value:"} commands.
type Note struct {
	Lines  []string
	Markup map[string]any
}

// note, a type of flow.
var Zt_Note typeinfo.Flow

// implements typeinfo.Instance
func (*Note) TypeInfo() typeinfo.T {
	return &Zt_Note
}

// implements typeinfo.Markup
func (op *Note) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*Note)(nil)
var _ rtti.Execute = (*Note)(nil)

// holds a slice of type note
type Note_Slice []Note

// implements typeinfo.Instance
func (*Note_Slice) TypeInfo() typeinfo.T {
	return &Zt_Note
}

// implements typeinfo.Repeats
func (op *Note_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a scene used for testing a story.
// Tests can be executed using the `tap check` command.
// TODO: see https://todo.sr.ht/~ionous/tapestry/42
type DefineTest struct {
	TestName      string
	RequireScenes rtti.TextListEval
	Statements    []StoryStatement
	Exe           []rtti.Execute
	Markup        map[string]any
}

// define_test, a type of flow.
var Zt_DefineTest typeinfo.Flow

// implements typeinfo.Instance
func (*DefineTest) TypeInfo() typeinfo.T {
	return &Zt_DefineTest
}

// implements typeinfo.Markup
func (op *DefineTest) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineTest)(nil)

// holds a slice of type define_test
type DefineTest_Slice []DefineTest

// implements typeinfo.Instance
func (*DefineTest_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineTest
}

// implements typeinfo.Repeats
func (op *DefineTest_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a collection of nouns, kinds, game rules, etc. used the game.
// Every .tell story has its own unique scene.
type DefineScene struct {
	Scene         rtti.TextEval
	RequireScenes rtti.TextListEval
	Statements    []StoryStatement
	Markup        map[string]any
}

// define_scene, a type of flow.
var Zt_DefineScene typeinfo.Flow

// implements typeinfo.Instance
func (*DefineScene) TypeInfo() typeinfo.T {
	return &Zt_DefineScene
}

// implements typeinfo.Markup
func (op *DefineScene) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineScene)(nil)

// holds a slice of type define_scene
type DefineScene_Slice []DefineScene

// implements typeinfo.Instance
func (*DefineScene_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineScene
}

// implements typeinfo.Repeats
func (op *DefineScene_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines an in-game behavior that can be triggered by an actor.
// Actions are a special kind of pattern, and like patterns use "rules" to define and customize their behavior. The shared library includes many common actions including things like moving from room to room, examining something, taking or dropping items, and so on.
// See the Tapestry guide for more information.
type DefineAction struct {
	Action   rtti.TextEval
	Requires []FieldDefinition
	Provides []FieldDefinition
	Markup   map[string]any
}

// define_action, a type of flow.
var Zt_DefineAction typeinfo.Flow

// implements typeinfo.Instance
func (*DefineAction) TypeInfo() typeinfo.T {
	return &Zt_DefineAction
}

// implements typeinfo.Markup
func (op *DefineAction) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineAction)(nil)

// holds a slice of type define_action
type DefineAction_Slice []DefineAction

// implements typeinfo.Instance
func (*DefineAction_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAction
}

// implements typeinfo.Repeats
func (op *DefineAction_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a set of mutually exclusive states that can be assigned to any kind of noun. By default, every noun with this set of states starts the game with the first state listed by this command. At runtime, a script can change to other states, ask whether a noun is in a particular state, or ask for the name of the current state from the set.
// Internally, these are also known as "aspects" and "traits."
// Many programming languages refer to these as "enumerations."
// See also: {"Set:state:"} and {"Object:field:"}
type DefineState struct {
	Aspect rtti.TextEval
	Traits rtti.TextListEval
	Markup map[string]any
}

// define_state, a type of flow.
var Zt_DefineState typeinfo.Flow

// implements typeinfo.Instance
func (*DefineState) TypeInfo() typeinfo.T {
	return &Zt_DefineState
}

// implements typeinfo.Markup
func (op *DefineState) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineState)(nil)

// holds a slice of type define_state
type DefineState_Slice []DefineState

// implements typeinfo.Instance
func (*DefineState_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineState
}

// implements typeinfo.Repeats
func (op *DefineState_Slice) Repeats() bool {
	return len(*op) > 0
}

// Interpret a name typed by the player as some existing noun.
// For example, if there is a noun called "the book", the story could define
// an alias so that "tome" also means the book.
type DefineAlias struct {
	Names    rtti.TextListEval
	NounName rtti.TextEval
	Markup   map[string]any
}

// define_alias, a type of flow.
var Zt_DefineAlias typeinfo.Flow

// implements typeinfo.Instance
func (*DefineAlias) TypeInfo() typeinfo.T {
	return &Zt_DefineAlias
}

// implements typeinfo.Markup
func (op *DefineAlias) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineAlias)(nil)

// holds a slice of type define_alias
type DefineAlias_Slice []DefineAlias

// implements typeinfo.Instance
func (*DefineAlias_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAlias
}

// implements typeinfo.Repeats
func (op *DefineAlias_Slice) Repeats() bool {
	return len(*op) > 0
}

// Creates a grammar used to parse player input.
// See the Tapestry guide for details.
type DefineLeadingGrammar struct {
	Lede   []string
	Scans  []grammar.ScannerMaker
	Markup map[string]any
}

// define_leading_grammar, a type of flow.
var Zt_DefineLeadingGrammar typeinfo.Flow

// implements typeinfo.Instance
func (*DefineLeadingGrammar) TypeInfo() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// implements typeinfo.Markup
func (op *DefineLeadingGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineLeadingGrammar)(nil)

// holds a slice of type define_leading_grammar
type DefineLeadingGrammar_Slice []DefineLeadingGrammar

// implements typeinfo.Instance
func (*DefineLeadingGrammar_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// implements typeinfo.Repeats
func (op *DefineLeadingGrammar_Slice) Repeats() bool {
	return len(*op) > 0
}

// Creates a grammar to parse player input that can be referenced in other grammars.
// It can also be used for grammars that need more flexibility in matching the initial words of a sentence ( because {"Interpret:with:"} depends on a set of fixed words. )
type DefineNamedGrammar struct {
	Name   string
	Scans  []grammar.ScannerMaker
	Markup map[string]any
}

// define_named_grammar, a type of flow.
var Zt_DefineNamedGrammar typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNamedGrammar) TypeInfo() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// implements typeinfo.Markup
func (op *DefineNamedGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNamedGrammar)(nil)

// holds a slice of type define_named_grammar
type DefineNamedGrammar_Slice []DefineNamedGrammar

// implements typeinfo.Instance
func (*DefineNamedGrammar_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// implements typeinfo.Repeats
func (op *DefineNamedGrammar_Slice) Repeats() bool {
	return len(*op) > 0
}

// Used internally to contain the plain-text sections of .tell documents.
// Contains English-like definitions of nouns, kinds, and their relatives.
type DeclareStatement struct {
	Text    rtti.TextEval
	Assign  rtti.Assignment
	Matches JessMatches
	Markup  map[string]any
}

// declare_statement, a type of flow.
var Zt_DeclareStatement typeinfo.Flow

// implements typeinfo.Instance
func (*DeclareStatement) TypeInfo() typeinfo.T {
	return &Zt_DeclareStatement
}

// implements typeinfo.Markup
func (op *DeclareStatement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DeclareStatement)(nil)

// holds a slice of type declare_statement
type DeclareStatement_Slice []DeclareStatement

// implements typeinfo.Instance
func (*DeclareStatement_Slice) TypeInfo() typeinfo.T {
	return &Zt_DeclareStatement
}

// implements typeinfo.Repeats
func (op *DeclareStatement_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a connection between different kinds of nouns.
// The shared library, for instance, defines a spatial relation between objects;
// allowing one object to be placed inside another.
type DefineRelation struct {
	Relation    rtti.TextEval
	Kind        rtti.TextEval
	OtherKind   rtti.TextEval
	Cardinality RelationCardinality
	Markup      map[string]any
}

// define_relation, a type of flow.
var Zt_DefineRelation typeinfo.Flow

// implements typeinfo.Instance
func (*DefineRelation) TypeInfo() typeinfo.T {
	return &Zt_DefineRelation
}

// implements typeinfo.Markup
func (op *DefineRelation) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineRelation)(nil)

// holds a slice of type define_relation
type DefineRelation_Slice []DefineRelation

// implements typeinfo.Instance
func (*DefineRelation_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRelation
}

// implements typeinfo.Repeats
func (op *DefineRelation_Slice) Repeats() bool {
	return len(*op) > 0
}

// Defines a new kind: a set of properties used by game objects.
// This command is similar to a sentence like:
// "Doors are a kind of opener."
type DefineKind struct {
	Kind     rtti.TextEval
	Ancestor rtti.TextEval
	Markup   map[string]any
}

// define_kind, a type of flow.
var Zt_DefineKind typeinfo.Flow

// implements typeinfo.Instance
func (*DefineKind) TypeInfo() typeinfo.T {
	return &Zt_DefineKind
}

// implements typeinfo.Markup
func (op *DefineKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineKind)(nil)

// holds a slice of type define_kind
type DefineKind_Slice []DefineKind

// implements typeinfo.Instance
func (*DefineKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineKind
}

// implements typeinfo.Repeats
func (op *DefineKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Adds properties to an existing kind.
// This command is similar to a sentence like:
// "Things have some text called a description."
type DefineFields struct {
	Kind   rtti.TextEval
	Fields []FieldDefinition
	Markup map[string]any
}

// define_fields, a type of flow.
var Zt_DefineFields typeinfo.Flow

// implements typeinfo.Instance
func (*DefineFields) TypeInfo() typeinfo.T {
	return &Zt_DefineFields
}

// implements typeinfo.Markup
func (op *DefineFields) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineFields)(nil)

// holds a slice of type define_fields
type DefineFields_Slice []DefineFields

// implements typeinfo.Instance
func (*DefineFields_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineFields
}

// implements typeinfo.Repeats
func (op *DefineFields_Slice) Repeats() bool {
	return len(*op) > 0
}

// Plurals are used both at runtime and during weave to
// guide the interpretation of nouns and kinds.
// A singular word can have multiple plurals;
// a plural word only has one singular form.
// For example:
// "The plural of person is people."
// "The plural of person is persons."
type DefinePlural struct {
	Singular rtti.TextEval
	Plural   rtti.TextEval
	Markup   map[string]any
}

// define_plural, a type of flow.
var Zt_DefinePlural typeinfo.Flow

// implements typeinfo.Instance
func (*DefinePlural) TypeInfo() typeinfo.T {
	return &Zt_DefinePlural
}

// implements typeinfo.Markup
func (op *DefinePlural) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePlural)(nil)

// holds a slice of type define_plural
type DefinePlural_Slice []DefinePlural

// implements typeinfo.Instance
func (*DefinePlural_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePlural
}

// implements typeinfo.Repeats
func (op *DefinePlural_Slice) Repeats() bool {
	return len(*op) > 0
}

// Assign a starting value to the field of one or nouns.
type DefineNounValue struct {
	NounName  rtti.TextEval
	FieldName rtti.TextEval
	Value     rtti.Assignment
	Markup    map[string]any
}

// define_noun_value, a type of flow.
var Zt_DefineNounValue typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNounValue) TypeInfo() typeinfo.T {
	return &Zt_DefineNounValue
}

// implements typeinfo.Markup
func (op *DefineNounValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNounValue)(nil)

// holds a slice of type define_noun_value
type DefineNounValue_Slice []DefineNounValue

// implements typeinfo.Instance
func (*DefineNounValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounValue
}

// implements typeinfo.Repeats
func (op *DefineNounValue_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineNounKind struct {
	NounName rtti.TextEval
	KindName rtti.TextEval
	Markup   map[string]any
}

// define_noun_kind, a type of flow.
var Zt_DefineNounKind typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNounKind) TypeInfo() typeinfo.T {
	return &Zt_DefineNounKind
}

// implements typeinfo.Markup
func (op *DefineNounKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNounKind)(nil)

// holds a slice of type define_noun_kind
type DefineNounKind_Slice []DefineNounKind

// implements typeinfo.Instance
func (*DefineNounKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounKind
}

// implements typeinfo.Repeats
func (op *DefineNounKind_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineNounStates struct {
	NounName   rtti.TextEval
	StateNames rtti.TextListEval
	Markup     map[string]any
}

// define_noun_states, a type of flow.
var Zt_DefineNounStates typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNounStates) TypeInfo() typeinfo.T {
	return &Zt_DefineNounStates
}

// implements typeinfo.Markup
func (op *DefineNounStates) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNounStates)(nil)

// holds a slice of type define_noun_states
type DefineNounStates_Slice []DefineNounStates

// implements typeinfo.Instance
func (*DefineNounStates_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounStates
}

// implements typeinfo.Repeats
func (op *DefineNounStates_Slice) Repeats() bool {
	return len(*op) > 0
}

type RuleProvides struct {
	PatternName rtti.TextEval
	Provides    []FieldDefinition
	Markup      map[string]any
}

// rule_provides, a type of flow.
var Zt_RuleProvides typeinfo.Flow

// implements typeinfo.Instance
func (*RuleProvides) TypeInfo() typeinfo.T {
	return &Zt_RuleProvides
}

// implements typeinfo.Markup
func (op *RuleProvides) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleProvides)(nil)

// holds a slice of type rule_provides
type RuleProvides_Slice []RuleProvides

// implements typeinfo.Instance
func (*RuleProvides_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleProvides
}

// implements typeinfo.Repeats
func (op *RuleProvides_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change the behavior of an existing pattern.
// For events, this adds a listener that responds to the targeted object only when triggered by the player.
// By default, rules with filters continue on to the next rule automatically.
// Because event listeners have filters they continue to the next listener unless specifically stopped.
type RuleForPattern struct {
	PatternName rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_pattern, a type of flow.
var Zt_RuleForPattern typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForPattern) TypeInfo() typeinfo.T {
	return &Zt_RuleForPattern
}

// implements typeinfo.Markup
func (op *RuleForPattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForPattern)(nil)

// holds a slice of type rule_for_pattern
type RuleForPattern_Slice []RuleForPattern

// implements typeinfo.Instance
func (*RuleForPattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForPattern
}

// implements typeinfo.Repeats
func (op *RuleForPattern_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change the behavior of an existing pattern.
// The default behavior for events is to fall through to the next handler unless canceled or stopped.
type RuleForNoun struct {
	PatternName rtti.TextEval
	NounName    rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_noun, a type of flow.
var Zt_RuleForNoun typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForNoun) TypeInfo() typeinfo.T {
	return &Zt_RuleForNoun
}

// implements typeinfo.Markup
func (op *RuleForNoun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForNoun)(nil)

// holds a slice of type rule_for_noun
type RuleForNoun_Slice []RuleForNoun

// implements typeinfo.Instance
func (*RuleForNoun_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForNoun
}

// implements typeinfo.Repeats
func (op *RuleForNoun_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change the behavior of an existing pattern.
// The default behavior for events is to fall through to the next handler unless canceled or stopped.
type RuleForKind struct {
	PatternName rtti.TextEval
	KindName    rtti.TextEval
	Exactly     rtti.BoolEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_kind, a type of flow.
var Zt_RuleForKind typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForKind) TypeInfo() typeinfo.T {
	return &Zt_RuleForKind
}

// implements typeinfo.Markup
func (op *RuleForKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForKind)(nil)

// holds a slice of type rule_for_kind
type RuleForKind_Slice []RuleForKind

// implements typeinfo.Instance
func (*RuleForKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForKind
}

// implements typeinfo.Repeats
func (op *RuleForKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Declare a new pattern.
// A pattern is a bundle of functions which can either change the game world or provide information about it.
// Each function in a given pattern has "guards" which determine whether the function applies in a particular situation.
type DefinePattern struct {
	PatternName rtti.TextEval
	Requires    []FieldDefinition
	Provides    []FieldDefinition
	Exe         []rtti.Execute
	Markup      map[string]any
}

// define_pattern, a type of flow.
var Zt_DefinePattern typeinfo.Flow

// implements typeinfo.Instance
func (*DefinePattern) TypeInfo() typeinfo.T {
	return &Zt_DefinePattern
}

// implements typeinfo.Markup
func (op *DefinePattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePattern)(nil)

// holds a slice of type define_pattern
type DefinePattern_Slice []DefinePattern

// implements typeinfo.Instance
func (*DefinePattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePattern
}

// implements typeinfo.Repeats
func (op *DefinePattern_Slice) Repeats() bool {
	return len(*op) > 0
}

// Relate nouns to each other.
// Most users will probably prefer defining verbs and using jess to relate nouns.
// For instance: "Carrying is a verb. The relation of carrying is whereabouts. Bob is carrying the pen."
// See the Tapestry guide for details.
type DefineRelatives struct {
	Relation   rtti.TextEval
	Nouns      rtti.TextListEval
	OtherNouns rtti.TextListEval
	Markup     map[string]any
}

// define_relatives, a type of flow.
var Zt_DefineRelatives typeinfo.Flow

// implements typeinfo.Instance
func (*DefineRelatives) TypeInfo() typeinfo.T {
	return &Zt_DefineRelatives
}

// implements typeinfo.Markup
func (op *DefineRelatives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineRelatives)(nil)

// holds a slice of type define_relatives
type DefineRelatives_Slice []DefineRelatives

// implements typeinfo.Instance
func (*DefineRelatives_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRelatives
}

// implements typeinfo.Repeats
func (op *DefineRelatives_Slice) Repeats() bool {
	return len(*op) > 0
}

// Print templated text. Templates contain commands executed at runtime.
// See the Tapestry guide for more information.
type SayTemplate struct {
	Template string
	Markup   map[string]any
}

// say_template, a type of flow.
var Zt_SayTemplate typeinfo.Flow

// implements typeinfo.Instance
func (*SayTemplate) TypeInfo() typeinfo.T {
	return &Zt_SayTemplate
}

// implements typeinfo.Markup
func (op *SayTemplate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*SayTemplate)(nil)
var _ rtti.TextEval = (*SayTemplate)(nil)

// holds a slice of type say_template
type SayTemplate_Slice []SayTemplate

// implements typeinfo.Instance
func (*SayTemplate_Slice) TypeInfo() typeinfo.T {
	return &Zt_SayTemplate
}

// implements typeinfo.Repeats
func (op *SayTemplate_Slice) Repeats() bool {
	return len(*op) > 0
}

// Print text in a replaceable manner.
// Each response has a unique name and a default bit of text it responds with.
// The response can be changed everywhere its used by replacing that text.
// ( ex. by using {"Define kind:fields": "response", "name of the response"} )
//
// The shared library uses responses for much of what it prints to the player
// so that stories can change the stock phrases.
type SayResponse struct {
	Name   string
	Text   rtti.TextEval
	Markup map[string]any
}

// say_response, a type of flow.
var Zt_SayResponse typeinfo.Flow

// implements typeinfo.Instance
func (*SayResponse) TypeInfo() typeinfo.T {
	return &Zt_SayResponse
}

// implements typeinfo.Markup
func (op *SayResponse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*SayResponse)(nil)
var _ rtti.TextEval = (*SayResponse)(nil)

// holds a slice of type say_response
type SayResponse_Slice []SayResponse

// implements typeinfo.Instance
func (*SayResponse_Slice) TypeInfo() typeinfo.T {
	return &Zt_SayResponse
}

// implements typeinfo.Repeats
func (op *SayResponse_Slice) Repeats() bool {
	return len(*op) > 0
}

// A guard which returns true based on a counter.
// Counters start at zero and are incremented every time the guard is checked.
type CountOf struct {
	Trigger core.Trigger
	Num     rtti.NumberEval
	Markup  map[string]any
}

// count_of, a type of flow.
var Zt_CountOf typeinfo.Flow

// implements typeinfo.Instance
func (*CountOf) TypeInfo() typeinfo.T {
	return &Zt_CountOf
}

// implements typeinfo.Markup
func (op *CountOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CountOf)(nil)

// holds a slice of type count_of
type CountOf_Slice []CountOf

// implements typeinfo.Instance
func (*CountOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_CountOf
}

// implements typeinfo.Repeats
func (op *CountOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns a single piece of text selected from a set of predefined values. When called multiple times, returns each one of the values in their specified order, then loops.
type CycleText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// cycle_text, a type of flow.
var Zt_CycleText typeinfo.Flow

// implements typeinfo.Instance
func (*CycleText) TypeInfo() typeinfo.T {
	return &Zt_CycleText
}

// implements typeinfo.Markup
func (op *CycleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CycleText)(nil)

// holds a slice of type cycle_text
type CycleText_Slice []CycleText

// implements typeinfo.Instance
func (*CycleText_Slice) TypeInfo() typeinfo.T {
	return &Zt_CycleText
}

// implements typeinfo.Repeats
func (op *CycleText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns a single piece of text selected from a set of predefined values. When called multiple times, returns each one of the values in a randomized order. After returning the available options, begins again with a new ordering.
type ShuffleText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// shuffle_text, a type of flow.
var Zt_ShuffleText typeinfo.Flow

// implements typeinfo.Instance
func (*ShuffleText) TypeInfo() typeinfo.T {
	return &Zt_ShuffleText
}

// implements typeinfo.Markup
func (op *ShuffleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*ShuffleText)(nil)

// holds a slice of type shuffle_text
type ShuffleText_Slice []ShuffleText

// implements typeinfo.Instance
func (*ShuffleText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ShuffleText
}

// implements typeinfo.Repeats
func (op *ShuffleText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Returns a single piece of text selected from a set of predefined values. When called multiple times returns each of its inputs in turn, sticking to the last one.
// As a special case, if there was only ever one option, returns that option followed by the empty string forever after.
type StoppingText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// stopping_text, a type of flow.
var Zt_StoppingText typeinfo.Flow

// implements typeinfo.Instance
func (*StoppingText) TypeInfo() typeinfo.T {
	return &Zt_StoppingText
}

// implements typeinfo.Markup
func (op *StoppingText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*StoppingText)(nil)

// holds a slice of type stopping_text
type StoppingText_Slice []StoppingText

// implements typeinfo.Instance
func (*StoppingText_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoppingText
}

// implements typeinfo.Repeats
func (op *StoppingText_Slice) Repeats() bool {
	return len(*op) > 0
}

// A valueless field.
// Intended mainly as a way for patterns which don't return a value.
type NothingField struct {
	Markup map[string]any
}

// nothing_field, a type of flow.
var Zt_NothingField typeinfo.Flow

// implements typeinfo.Instance
func (*NothingField) TypeInfo() typeinfo.T {
	return &Zt_NothingField
}

// implements typeinfo.Markup
func (op *NothingField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NothingField)(nil)

// holds a slice of type nothing_field
type NothingField_Slice []NothingField

// implements typeinfo.Instance
func (*NothingField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NothingField
}

// implements typeinfo.Repeats
func (op *NothingField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing an aspect ( aka. a set of states. )
// Aspects are defined using the {"Define state:names:"} command.
type AspectField struct {
	Aspect rtti.TextEval
	Markup map[string]any
}

// aspect_field, a type of flow.
var Zt_AspectField typeinfo.Flow

// implements typeinfo.Instance
func (*AspectField) TypeInfo() typeinfo.T {
	return &Zt_AspectField
}

// implements typeinfo.Markup
func (op *AspectField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*AspectField)(nil)

// holds a slice of type aspect_field
type AspectField_Slice []AspectField

// implements typeinfo.Instance
func (*AspectField_Slice) TypeInfo() typeinfo.T {
	return &Zt_AspectField
}

// implements typeinfo.Repeats
func (op *AspectField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a boolean ( true/false ) value.
// As a special case, when used to define a boolean field in a kind,
// the boolean becomes a state set consisting of the state and its opposite.
// For instance, a boolean field called "reasonable" generates a set called "reasonable status" and the states "reasonable" and "not reasonable."
type BoolField struct {
	Name      rtti.TextEval
	Initially rtti.BoolEval
	Markup    map[string]any
}

// bool_field, a type of flow.
var Zt_BoolField typeinfo.Flow

// implements typeinfo.Instance
func (*BoolField) TypeInfo() typeinfo.T {
	return &Zt_BoolField
}

// implements typeinfo.Markup
func (op *BoolField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*BoolField)(nil)

// holds a slice of type bool_field
type BoolField_Slice []BoolField

// implements typeinfo.Instance
func (*BoolField_Slice) TypeInfo() typeinfo.T {
	return &Zt_BoolField
}

// implements typeinfo.Repeats
func (op *BoolField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a single number.
type NumberField struct {
	Name      rtti.TextEval
	Initially rtti.NumberEval
	Markup    map[string]any
}

// number_field, a type of flow.
var Zt_NumberField typeinfo.Flow

// implements typeinfo.Instance
func (*NumberField) TypeInfo() typeinfo.T {
	return &Zt_NumberField
}

// implements typeinfo.Markup
func (op *NumberField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NumberField)(nil)

// holds a slice of type number_field
type NumberField_Slice []NumberField

// implements typeinfo.Instance
func (*NumberField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NumberField
}

// implements typeinfo.Repeats
func (op *NumberField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a single record.
type RecordField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.RecordEval
	Markup    map[string]any
}

// record_field, a type of flow.
var Zt_RecordField typeinfo.Flow

// implements typeinfo.Instance
func (*RecordField) TypeInfo() typeinfo.T {
	return &Zt_RecordField
}

// implements typeinfo.Markup
func (op *RecordField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*RecordField)(nil)

// holds a slice of type record_field
type RecordField_Slice []RecordField

// implements typeinfo.Instance
func (*RecordField_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordField
}

// implements typeinfo.Repeats
func (op *RecordField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a single piece of text.
// Text fields can be used to store anything from the name of a noun, the name of a state or set of states, or something to display to the player.
type TextField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.TextEval
	Markup    map[string]any
}

// text_field, a type of flow.
var Zt_TextField typeinfo.Flow

// implements typeinfo.Instance
func (*TextField) TypeInfo() typeinfo.T {
	return &Zt_TextField
}

// implements typeinfo.Markup
func (op *TextField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*TextField)(nil)

// holds a slice of type text_field
type TextField_Slice []TextField

// implements typeinfo.Instance
func (*TextField_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextField
}

// implements typeinfo.Repeats
func (op *TextField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a list of text.
type TextListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.TextListEval
	Markup    map[string]any
}

// text_list_field, a type of flow.
var Zt_TextListField typeinfo.Flow

// implements typeinfo.Instance
func (*TextListField) TypeInfo() typeinfo.T {
	return &Zt_TextListField
}

// implements typeinfo.Markup
func (op *TextListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*TextListField)(nil)

// holds a slice of type text_list_field
type TextListField_Slice []TextListField

// implements typeinfo.Instance
func (*TextListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextListField
}

// implements typeinfo.Repeats
func (op *TextListField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a list of numbers.
type NumListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.NumListEval
	Markup    map[string]any
}

// num_list_field, a type of flow.
var Zt_NumListField typeinfo.Flow

// implements typeinfo.Instance
func (*NumListField) TypeInfo() typeinfo.T {
	return &Zt_NumListField
}

// implements typeinfo.Markup
func (op *NumListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NumListField)(nil)

// holds a slice of type num_list_field
type NumListField_Slice []NumListField

// implements typeinfo.Instance
func (*NumListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NumListField
}

// implements typeinfo.Repeats
func (op *NumListField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A field containing a list of records.
// All of the records in the list must be of the same type.
type RecordListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.RecordListEval
	Markup    map[string]any
}

// record_list_field, a type of flow.
var Zt_RecordListField typeinfo.Flow

// implements typeinfo.Instance
func (*RecordListField) TypeInfo() typeinfo.T {
	return &Zt_RecordListField
}

// implements typeinfo.Markup
func (op *RecordListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*RecordListField)(nil)

// holds a slice of type record_list_field
type RecordListField_Slice []RecordListField

// implements typeinfo.Instance
func (*RecordListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordListField
}

// implements typeinfo.Repeats
func (op *RecordListField_Slice) Repeats() bool {
	return len(*op) > 0
}

// RelationCardinality, a type of str enum.
type RelationCardinality int

// enumerated values of RelationCardinality
const (
	C_RelationCardinality_OneToOne RelationCardinality = iota
	C_RelationCardinality_OneToMany
	C_RelationCardinality_ManyToOne
	C_RelationCardinality_ManyToMany
)

func MakeRelationCardinality(str string) (ret RelationCardinality, okay bool) {
	if i := Zt_RelationCardinality.FindOption(str); i >= 0 {
		ret, okay = RelationCardinality(i), true
	}
	return
}

func (op RelationCardinality) String() (ret string) {
	if i, opts := int(op), Zt_RelationCardinality.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid RelationCardinality(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// relation_cardinality, a type of str enum.
var Zt_RelationCardinality = typeinfo.Str{
	Name: "relation_cardinality",
	Options: []string{
		"one_to_one",
		"one_to_many",
		"many_to_one",
		"many_to_many",
	},
	Markup: map[string]any{
		"comment": "Used as part of [DefineRelation] to declare a new kind of relationship between nouns.",
	},
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_StoryFile = typeinfo.Flow{
		Name: "story_file",
		Lede: "tapestry",
		Terms: []typeinfo.Term{{
			Name:    "statements",
			Repeats: true,
			Type:    &Zt_StoryStatement,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"blockly-color": "TAP_HUE_ROOT",
			"comment":       []interface{}{"Used internally as the container for every .tell file.", "Implements Story Statement to simplify how flex parsing works."},
			"mosaic-root":   true,
		},
	}
	Zt_StoryBreak = typeinfo.Flow{
		Name:  "story_break",
		Lede:  "--",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "A legacy command, used in .if files as a visual divider ( because reading and writing json doesn't otherwise have a way to preserve whitespace. )",
		},
	}
	Zt_Note = typeinfo.Flow{
		Name: "note",
		Lede: "note",
		Terms: []typeinfo.Term{{
			Name:    "lines",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more lines of text documentation.",
			},
			Type: &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Adds documentation about the story for you and other authors.", "Notes can used as a modeling commands, or as part of an execute block.", "And, they are created automatically from hash-style comments (#) encountered within the plain text sections of tell files.", "When used in an execute block, notes become {\"Log:value:\"} commands."},
		},
	}
	Zt_DefineTest = typeinfo.Flow{
		Name: "define_test",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "test_name",
			Label: "test",
			Markup: map[string]any{
				"comment": "A unique name for the test.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:     "require_scenes",
			Label:    "requires",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"One or more scenes that this test depends on.", "Tests implicitly depend upon the scene within which they are defined.", "In order to reference the nouns, kinds, etc. of any other scenes in a test, that scene must be listed here."},
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:     "statements",
			Label:    "scene",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "Modeling commands for defining nouns, kinds, game rules, etc. used by this test. Those definitions will not be visible outside of the test ( unless this test is \"required\" by another. )",
			},
			Type: &Zt_StoryStatement,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"One or more commands to run when checking the test.", "The {\"Expect:\"} command will trigger a test failure when an author specified condition is not met."},
			},
			Type: &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a scene used for testing a story.", "Tests can be executed using the `tap check` command.", "TODO: see https://todo.sr.ht/~ionous/tapestry/42"},
		},
	}
	Zt_DefineScene = typeinfo.Flow{
		Name: "define_scene",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "scene",
			Label: "scene",
			Markup: map[string]any{
				"comment": "A unique name for the scene.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "require_scenes",
			Label:    "requires",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"One or more scenes that this scene depends on.", "This is a one-way dependency. This scene can reference anything defined within the required scenes; the required scenes cannot reference anything declared within this scene. Circular dependencies are prevented by weave."},
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:     "statements",
			Label:    "with",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "Modeling commands for the defining nouns, kinds, game rules, etc. used by this scene.",
			},
			Type: &Zt_StoryStatement,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a collection of nouns, kinds, game rules, etc. used the game.", "Every .tell story has its own unique scene."},
		},
	}
	Zt_DefineAction = typeinfo.Flow{
		Name: "define_action",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "action",
			Label: "action",
			Markup: map[string]any{
				"comment": "A unique name for the action.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"Parameters to customize the behavior of an action.", "Most actions require an actor, and possibly one or two other objects.", "For instance: the standard \"storing\" action -- used for inserting something into a container -- requires an actor to perform the action, an object to store, and a container to receive that object."},
			},
			Type: &Zt_FieldDefinition,
		}, {
			Name:     "provides",
			Label:    "provides",
			Optional: true,
			Repeats:  true,
			Markup: map[string]any{
				"comment": "A list of any local variables needed by the action carry out its behavior.",
			},
			Type: &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines an in-game behavior that can be triggered by an actor.", "Actions are a special kind of pattern, and like patterns use \"rules\" to define and customize their behavior. The shared library includes many common actions including things like moving from room to room, examining something, taking or dropping items, and so on.", "See the Tapestry guide for more information."},
		},
	}
	Zt_DefineState = typeinfo.Flow{
		Name: "define_state",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "aspect",
			Label: "state",
			Markup: map[string]any{
				"comment": "A unique name for the set of states.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "traits",
			Label: "names",
			Markup: map[string]any{
				"comment": []interface{}{"The names of the states in the set.", "TODO: a list of containing only one state should probably automatically generate its opposite the way that [BoolField] does."},
			},
			Type: &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a set of mutually exclusive states that can be assigned to any kind of noun. By default, every noun with this set of states starts the game with the first state listed by this command. At runtime, a script can change to other states, ask whether a noun is in a particular state, or ask for the name of the current state from the set.", "Internally, these are also known as \"aspects\" and \"traits.\"", "Many programming languages refer to these as \"enumerations.\"", "See also: {\"Set:state:\"} and {\"Object:field:\"}"},
		},
	}
	Zt_DefineAlias = typeinfo.Flow{
		Name: "define_alias",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "alias",
			Markup: map[string]any{
				"comment": "One or more alternative names for a noun.",
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:  "noun_name",
			Label: "as",
			Markup: map[string]any{
				"comment": "The noun the aliases refer to.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Interpret a name typed by the player as some existing noun.", "For example, if there is a noun called \"the book\", the story could define", "an alias so that \"tome\" also means the book."},
		},
	}
	Zt_DefineLeadingGrammar = typeinfo.Flow{
		Name: "define_leading_grammar",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:    "lede",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"One or more words to match against the player's input.", "For example, the standard \"examine\" action lists the words:", "\"examine\", \"x\", and \"describe\" all of which the player can use", "to trigger inspect a particular object."},
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "scans",
			Label:   "with",
			Repeats: true,
			Markup: map[string]any{
				"comment": "A tree of commands used to parse subsequent words.",
			},
			Type: &grammar.Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Creates a grammar used to parse player input.", "See the Tapestry guide for details."},
		},
	}
	Zt_DefineNamedGrammar = typeinfo.Flow{
		Name: "define_named_grammar",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "name",
			Markup: map[string]any{
				"comment": "A unique name which other grammars can use to refer the grammar defined by this command.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "scans",
			Label:   "with",
			Repeats: true,
			Markup: map[string]any{
				"comment": "A tree of commands used to parse player input.",
			},
			Type: &grammar.Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Creates a grammar to parse player input that can be referenced in other grammars.", "It can also be used for grammars that need more flexibility in matching the initial words of a sentence ( because {\"Interpret:with:\"} depends on a set of fixed words. )"},
		},
	}
	Zt_DeclareStatement = typeinfo.Flow{
		Name: "declare_statement",
		Lede: "declare",
		Terms: []typeinfo.Term{{
			Name: "text",
			Markup: map[string]any{
				"comment": "A single text string containing one or more plain English sentences used to model the game world.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "assign",
			Label:    "assign",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"The last sentence of the specified text can sometimes ( depending on the sentence structure ) break out into runtime commands. Those sentences always end with a colon.", "Most often, these are rules. For instance: {\"Instead of jumping:\" .... do something.}"},
			},
			Type: &rtti.Zt_Assignment,
		}, {
			Name:    "matches",
			Label:   "matches",
			Private: true,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Used internally to contain the plain-text sections of .tell documents.", "Contains English-like definitions of nouns, kinds, and their relatives."},
		},
	}
	Zt_DefineRelation = typeinfo.Flow{
		Name: "define_relation",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "relation",
			Label: "relation",
			Markup: map[string]any{
				"comment": "Unique name for the relation.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "kind",
			Label: "kind",
			Markup: map[string]any{
				"comment": "The kind of nouns allowed on the \"left side\" of a relation.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "other_kind",
			Label: "other_kind",
			Markup: map[string]any{
				"comment": "The kind of nouns allowed on the \"right side\" of a relation.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "cardinality",
			Label: "cardinality",
			Markup: map[string]any{
				"comment": []interface{}{"Determines the number of times a noun can appear on the left", "or the right side of a given relation."},
			},
			Type: &Zt_RelationCardinality,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a connection between different kinds of nouns.", "The shared library, for instance, defines a spatial relation between objects;", "allowing one object to be placed inside another."},
		},
	}
	Zt_DefineKind = typeinfo.Flow{
		Name: "define_kind",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Markup: map[string]any{
				"comment": "A unique name for this kind.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "ancestor",
			Label: "ancestor",
			Markup: map[string]any{
				"comment": []interface{}{"The parent of this kind.", "( In point of fact, this can be any ancestor of the kind", "so long as it doesn't conflict with other [DefineKind] statements. )"},
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Defines a new kind: a set of properties used by game objects.", "This command is similar to a sentence like:", "\"Doors are a kind of opener.\""},
		},
	}
	Zt_DefineFields = typeinfo.Flow{
		Name: "define_fields",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Markup: map[string]any{
				"comment": "The name of the kind to which the fields will be assigned.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:    "fields",
			Label:   "fields",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more fields to add to the kind.",
			},
			Type: &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Adds properties to an existing kind.", "This command is similar to a sentence like:", "\"Things have some text called a description.\""},
		},
	}
	Zt_DefinePlural = typeinfo.Flow{
		Name: "define_plural",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "singular",
			Label: "singular",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "plural",
			Label: "plural",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Plurals are used both at runtime and during weave to", "guide the interpretation of nouns and kinds.", "A singular word can have multiple plurals;", "a plural word only has one singular form.", "For example:", "\"The plural of person is people.\"", "\"The plural of person is persons.\""},
		},
	}
	Zt_DefineNounValue = typeinfo.Flow{
		Name: "define_noun_value",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "noun_name",
			Label: "noun",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "field_name",
			Label: "value",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "value",
			Label: "initially",
			Type:  &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Assign a starting value to the field of one or nouns.",
		},
	}
	Zt_DefineNounKind = typeinfo.Flow{
		Name: "define_noun_kind",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "noun_name",
			Label: "noun",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "kind_name",
			Label: "kind",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
	}
	Zt_DefineNounStates = typeinfo.Flow{
		Name: "define_noun_states",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "noun_name",
			Label: "noun",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "state_names",
			Label: "states",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
	}
	Zt_RuleProvides = typeinfo.Flow{
		Name: "rule_provides",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
	}
	Zt_RuleForPattern = typeinfo.Flow{
		Name: "rule_for_pattern",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "For events, this adds a listener that responds to the targeted object only when triggered by the player.", "By default, rules with filters continue on to the next rule automatically.", "Because event listeners have filters they continue to the next listener unless specifically stopped."},
		},
	}
	Zt_RuleForNoun = typeinfo.Flow{
		Name: "rule_for_noun",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "noun_name",
			Label: "noun",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "The default behavior for events is to fall through to the next handler unless canceled or stopped."},
		},
	}
	Zt_RuleForKind = typeinfo.Flow{
		Name: "rule_for_kind",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "kind_name",
			Label: "kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "exactly",
			Label:    "exactly",
			Optional: true,
			Type:     &rtti.Zt_BoolEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "The default behavior for events is to fall through to the next handler unless canceled or stopped."},
		},
	}
	Zt_DefinePattern = typeinfo.Flow{
		Name: "define_pattern",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "pattern",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:     "exe",
			Label:    "do",
			Optional: true,
			Repeats:  true,
			Type:     &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Declare a new pattern.", "A pattern is a bundle of functions which can either change the game world or provide information about it.", "Each function in a given pattern has \"guards\" which determine whether the function applies in a particular situation."},
		},
	}
	Zt_DefineRelatives = typeinfo.Flow{
		Name: "define_relatives",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "relation",
			Label: "relative",
			Markup: map[string]any{
				"comment": "The name of an existing relationship.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "nouns",
			Label: "nouns",
			Markup: map[string]any{
				"comment": "The names of one or more nouns for the \"left side\" of this pairing.",
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:  "other_nouns",
			Label: "other_nouns",
			Markup: map[string]any{
				"comment": "The names of one or more nouns for the \"right side\" of this pairing.",
			},
			Type: &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Relate nouns to each other.", "Most users will probably prefer defining verbs and using jess to relate nouns.", "For instance: \"Carrying is a verb. The relation of carrying is whereabouts. Bob is carrying the pen.\"", "See the Tapestry guide for details."},
		},
	}
	Zt_SayTemplate = typeinfo.Flow{
		Name: "say_template",
		Lede: "say",
		Terms: []typeinfo.Term{{
			Name: "template",
			Type: &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Print templated text. Templates contain commands executed at runtime.", "See the Tapestry guide for more information."},
		},
	}
	Zt_SayResponse = typeinfo.Flow{
		Name: "say_response",
		Lede: "say",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "response",
			Markup: map[string]any{
				"comment": "A globally unique name for the response.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:  "text",
			Label: "with",
			Markup: map[string]any{
				"comment": "The default text used for this response.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Print text in a replaceable manner.", "Each response has a unique name and a default bit of text it responds with.", "The response can be changed everywhere its used by replacing that text.", "( ex. by using {\"Define kind:fields\": \"response\", \"name of the response\"} )", "", "The shared library uses responses for much of what it prints to the player", "so that stories can change the stock phrases."},
		},
	}
	Zt_CountOf = typeinfo.Flow{
		Name: "count_of",
		Lede: "count_of",
		Terms: []typeinfo.Term{{
			Name: "trigger",
			Markup: map[string]any{
				"comment": "A unique name for this counter.",
			},
			Type: &core.Zt_Trigger,
		}, {
			Name:  "num",
			Label: "num",
			Markup: map[string]any{
				"comment": "The value at which this counter will start to return true.",
			},
			Type: &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A guard which returns true based on a counter.", "Counters start at zero and are incremented every time the guard is checked."},
		},
	}
	Zt_CycleText = typeinfo.Flow{
		Name: "cycle_text",
		Lede: "cycle_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more pieces of text to cycle through.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns a single piece of text selected from a set of predefined values. When called multiple times, returns each one of the values in their specified order, then loops.",
		},
	}
	Zt_ShuffleText = typeinfo.Flow{
		Name: "shuffle_text",
		Lede: "shuffle_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more pieces of text to shuffle through.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "Returns a single piece of text selected from a set of predefined values. When called multiple times, returns each one of the values in a randomized order. After returning the available options, begins again with a new ordering.",
		},
	}
	Zt_StoppingText = typeinfo.Flow{
		Name: "stopping_text",
		Lede: "stopping_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Markup: map[string]any{
				"comment": "One or more pieces of text to shift through.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Returns a single piece of text selected from a set of predefined values. When called multiple times returns each of its inputs in turn, sticking to the last one.", "As a special case, if there was only ever one option, returns that option followed by the empty string forever after."},
		},
	}
	Zt_NothingField = typeinfo.Flow{
		Name:  "nothing_field",
		Lede:  "nothing",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A valueless field.", "Intended mainly as a way for patterns which don't return a value."},
		},
	}
	Zt_AspectField = typeinfo.Flow{
		Name: "aspect_field",
		Lede: "aspect",
		Terms: []typeinfo.Term{{
			Name: "aspect",
			Markup: map[string]any{
				"comment": []interface{}{"Name for the aspect. Must be unique within the set of fields (eg. within the kind.)", "The field will have this same name."},
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A field containing an aspect ( aka. a set of states. )", "Aspects are defined using the {\"Define state:names:\"} command."},
		},
	}
	Zt_BoolField = typeinfo.Flow{
		Name: "bool_field",
		Lede: "bool",
		Terms: []typeinfo.Term{{
			Name: "name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "An initial value for the field, true if not otherwise specified.",
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A field containing a boolean ( true/false ) value.", "As a special case, when used to define a boolean field in a kind,", "the boolean becomes a state set consisting of the state and its opposite.", "For instance, a boolean field called \"reasonable\" generates a set called \"reasonable status\" and the states \"reasonable\" and \"not reasonable.\""},
		},
	}
	Zt_NumberField = typeinfo.Flow{
		Name: "number_field",
		Lede: "number",
		Terms: []typeinfo.Term{{
			Name: "name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; zero if not specified.",
			},
			Type: &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": "A field containing a single number.",
		},
	}
	Zt_RecordField = typeinfo.Flow{
		Name: "record_field",
		Lede: "record",
		Terms: []typeinfo.Term{{
			Name: "name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "type",
			Label: "kind",
			Markup: map[string]any{
				"comment": "The name of a valid record type.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": []interface{}{"Provides a default value.", "If not specified, accessing the field in go returns nil;", "accessing via script returns a blank record with zero value fields."},
			},
			Type: &rtti.Zt_RecordEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": "A field containing a single record.",
		},
	}
	Zt_TextField = typeinfo.Flow{
		Name: "text_field",
		Lede: "text",
		Terms: []typeinfo.Term{{
			Name: "name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": "A hint that this text refers to an object or some other predefined concept in the game world.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; the empty string if not specified.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A field containing a single piece of text.", "Text fields can be used to store anything from the name of a noun, the name of a state or set of states, or something to display to the player."},
		},
	}
	Zt_TextListField = typeinfo.Flow{
		Name: "text_list_field",
		Lede: "text_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"comment": "A hint that the specified text might refer to an object or some other predefined concept in the game world.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; an empty list if not specified.",
			},
			Type: &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": "A field containing a list of text.",
		},
	}
	Zt_NumListField = typeinfo.Flow{
		Name: "num_list_field",
		Lede: "num_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; an empty list if not specified.",
			},
			Type: &rtti.Zt_NumListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": "A field containing a list of numbers.",
		},
	}
	Zt_RecordListField = typeinfo.Flow{
		Name: "record_list_field",
		Lede: "record_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Markup: map[string]any{
				"comment": "Name for the field. Must be unique within the set of fields (eg. within the kind.)",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "type",
			Label: "kind",
			Markup: map[string]any{
				"comment": []interface{}{"The name of a valid record type.", "All records in the list must be of this type."},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Markup: map[string]any{
				"comment": "Provides a default value; an empty list if not specified.",
			},
			Type: &rtti.Zt_RecordListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A field containing a list of records.", "All of the records in the list must be of the same type."},
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "story",
	Comment: []string{
		"Contains modeling commands used to define a game world. These commands include the description of scenes, kinds of objects, specific nouns and their properties, the placement and relation between nouns, and so on.",
		"",
		"Most authors will probably prefer the jess plain english style of modeling over these, more explicit, commands. However, there are some commands -- like defining scenes -- which don't currently have a corollary within jess.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_StoryStatement,
	&Zt_FieldDefinition,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_StoryFile,
	&Zt_StoryBreak,
	&Zt_Note,
	&Zt_DefineTest,
	&Zt_DefineScene,
	&Zt_DefineAction,
	&Zt_DefineState,
	&Zt_DefineAlias,
	&Zt_DefineLeadingGrammar,
	&Zt_DefineNamedGrammar,
	&Zt_DeclareStatement,
	&Zt_DefineRelation,
	&Zt_DefineKind,
	&Zt_DefineFields,
	&Zt_DefinePlural,
	&Zt_DefineNounValue,
	&Zt_DefineNounKind,
	&Zt_DefineNounStates,
	&Zt_RuleProvides,
	&Zt_RuleForPattern,
	&Zt_RuleForNoun,
	&Zt_RuleForKind,
	&Zt_DefinePattern,
	&Zt_DefineRelatives,
	&Zt_SayTemplate,
	&Zt_SayResponse,
	&Zt_CountOf,
	&Zt_CycleText,
	&Zt_ShuffleText,
	&Zt_StoppingText,
	&Zt_NothingField,
	&Zt_AspectField,
	&Zt_BoolField,
	&Zt_NumberField,
	&Zt_RecordField,
	&Zt_TextField,
	&Zt_TextListField,
	&Zt_NumListField,
	&Zt_RecordListField,
}

// a list of all strs in this this package
var z_str_list = []*typeinfo.Str{
	&Zt_RelationCardinality,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	4360765066804052293:  (*StoryBreak)(nil),           /* story_statement=-- */
	13010292396640781698: (*AspectField)(nil),          /* field_definition=Aspect: */
	12738236274201716794: (*BoolField)(nil),            /* field_definition=Bool: */
	18077675806901364237: (*BoolField)(nil),            /* field_definition=Bool:initially: */
	10143132576483224253: (*CountOf)(nil),              /* bool_eval=CountOf:num: */
	231398832069830353:   (*CycleText)(nil),            /* text_eval=CycleText: */
	9796202271034753943:  (*DeclareStatement)(nil),     /* story_statement=Declare: */
	11228697653156044284: (*DeclareStatement)(nil),     /* story_statement=Declare:assign: */
	14790755516297707674: (*DefineAction)(nil),         /* story_statement=Define action:requires: */
	5312053119535959994:  (*DefineAction)(nil),         /* story_statement=Define action:requires:provides: */
	12790170204334923961: (*DefineKind)(nil),           /* story_statement=Define kind:ancestor: */
	15268150405724581221: (*DefineFields)(nil),         /* story_statement=Define kind:fields: */
	16821098817155896534: (*DefineNounKind)(nil),       /* story_statement=Define noun:kind: */
	3688969656849355942:  (*DefineNounStates)(nil),     /* story_statement=Define noun:states: */
	9478300892459390916:  (*DefineNounValue)(nil),      /* story_statement=Define noun:value:initially: */
	14040325709851010602: (*DefinePattern)(nil),        /* story_statement=Define pattern:requires:provides: */
	729326910659609567:   (*DefinePattern)(nil),        /* story_statement=Define pattern:requires:provides:do: */
	15951965898335032430: (*DefineRelation)(nil),       /* story_statement=Define relation:kind:otherKind:cardinality: */
	7218292999752256394:  (*DefineRelatives)(nil),      /* story_statement=Define relative:nouns:otherNouns: */
	18093984368234904277: (*RuleForPattern)(nil),       /* story_statement=Define rule:do: */
	12136992210577308757: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:do: */
	10538385905361340595: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:exactly:do: */
	11666026550766211860: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:exactly:named:do: */
	2951940010570883790:  (*RuleForKind)(nil),          /* story_statement=Define rule:kind:named:do: */
	2007307886252117326:  (*RuleForPattern)(nil),       /* story_statement=Define rule:named:do: */
	4344965134492972319:  (*RuleForNoun)(nil),          /* story_statement=Define rule:noun:do: */
	16133739979148445504: (*RuleForNoun)(nil),          /* story_statement=Define rule:noun:named:do: */
	8031356368944964156:  (*RuleProvides)(nil),         /* story_statement=Define rule:provides: */
	16728157364207612750: (*DefineScene)(nil),          /* story_statement=Define scene: */
	10681959011863226668: (*DefineScene)(nil),          /* story_statement=Define scene:requires: */
	10209709135447127962: (*DefineScene)(nil),          /* story_statement=Define scene:requires:with: */
	13479298094295759568: (*DefineScene)(nil),          /* story_statement=Define scene:with: */
	1798652288281835623:  (*DefinePlural)(nil),         /* story_statement=Define singular:plural: */
	17999974279653753583: (*DefineState)(nil),          /* story_statement=Define state:names: */
	12489141410311466071: (*DefineTest)(nil),           /* story_statement=Define test:do: */
	3712030102885900665:  (*DefineTest)(nil),           /* story_statement=Define test:requires:do: */
	16978239348269462739: (*DefineTest)(nil),           /* story_statement=Define test:requires:scene:do: */
	13333326165932249009: (*DefineTest)(nil),           /* story_statement=Define test:scene:do: */
	12975771225654832812: (*DefineAlias)(nil),          /* story_statement=Interpret alias:as: */
	8001652437005351387:  (*DefineNamedGrammar)(nil),   /* story_statement=Interpret name:with: */
	6001249499689096432:  (*DefineLeadingGrammar)(nil), /* story_statement=Interpret:with: */
	16242102660676547183: (*Note)(nil),                 /* execute=Note: */
	17718266473581357115: (*Note)(nil),                 /* story_statement=Note: */
	14427731589588473385: (*NothingField)(nil),         /* field_definition=Nothing */
	10299801658819864730: (*NumListField)(nil),         /* field_definition=NumList: */
	12762197545337845485: (*NumListField)(nil),         /* field_definition=NumList:initially: */
	2289982379805608146:  (*NumListField)(nil),         /* field_definition=NumList:kind: */
	223049567122462661:   (*NumListField)(nil),         /* field_definition=NumList:kind:initially: */
	16579038690333872565: (*NumberField)(nil),          /* field_definition=Number: */
	7599754526096278866:  (*NumberField)(nil),          /* field_definition=Number:initially: */
	7215961239288768263:  (*RecordField)(nil),          /* field_definition=Record:kind: */
	8334583613109868292:  (*RecordField)(nil),          /* field_definition=Record:kind:initially: */
	15479801779125468947: (*RecordListField)(nil),      /* field_definition=RecordList:kind: */
	17384295137903978384: (*RecordListField)(nil),      /* field_definition=RecordList:kind:initially: */
	12945074305202371477: (*SayResponse)(nil),          /* execute=Say response:with: */
	7921553818502082370:  (*SayResponse)(nil),          /* text_eval=Say response:with: */
	9556993961571292952:  (*SayTemplate)(nil),          /* execute=Say: */
	15989777734244204735: (*SayTemplate)(nil),          /* text_eval=Say: */
	9910951906340888308:  (*ShuffleText)(nil),          /* text_eval=ShuffleText: */
	13921723804355948971: (*StoppingText)(nil),         /* text_eval=StoppingText: */
	12956316934318450345: (*StoryFile)(nil),            /* story_statement=Tapestry: */
	9387832592330456403:  (*TextField)(nil),            /* field_definition=Text: */
	16637694412733787472: (*TextField)(nil),            /* field_definition=Text:initially: */
	15791809714384972761: (*TextField)(nil),            /* field_definition=Text:kind: */
	16917317465644840422: (*TextField)(nil),            /* field_definition=Text:kind:initially: */
	3830912410254339707:  (*TextListField)(nil),        /* field_definition=TextList: */
	15743255383721832504: (*TextListField)(nil),        /* field_definition=TextList:initially: */
	2011197685129757745:  (*TextListField)(nil),        /* field_definition=TextList:kind: */
	3232692879001227038:  (*TextListField)(nil),        /* field_definition=TextList:kind:initially: */
}
