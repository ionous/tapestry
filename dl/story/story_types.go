// Code generated by Tapestry; edit at your own risk.
package story

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/grammar"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// field_definition, a type of slot.
var Zt_FieldDefinition = typeinfo.Slot{
	Name: "field_definition",
	Markup: map[string]any{
		"comment": "Fields are used to define the members of kinds, records, patterns, and so on.",
	},
}

// holds a single slot
// FIX: currently provided by the spec
type FIX_FieldDefinition_Slot struct{ Value FieldDefinition }

// implements typeinfo.Inspector for a single slot.
func (*FIX_FieldDefinition_Slot) Inspect() typeinfo.T {
	return &Zt_FieldDefinition
}

// holds a slice of slots
type FieldDefinition_Slots []FieldDefinition

// implements typeinfo.Inspector for a series of slots.
func (*FieldDefinition_Slots) Inspect() typeinfo.T {
	return &Zt_FieldDefinition
}

// story_statement, a type of slot.
var Zt_StoryStatement = typeinfo.Slot{
	Name: "story_statement",
	Markup: map[string]any{
		"blockly-color": "VARIABLES_HUE",
		"blockly-stack": true,
		"comment":       "Phrase",
	},
}

// holds a single slot
// FIX: currently provided by the spec
type FIX_StoryStatement_Slot struct{ Value StoryStatement }

// implements typeinfo.Inspector for a single slot.
func (*FIX_StoryStatement_Slot) Inspect() typeinfo.T {
	return &Zt_StoryStatement
}

// holds a slice of slots
type StoryStatement_Slots []StoryStatement

// implements typeinfo.Inspector for a series of slots.
func (*StoryStatement_Slots) Inspect() typeinfo.T {
	return &Zt_StoryStatement
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Comment struct {
	Lines  string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Comment) Inspect() typeinfo.T {
	return &Zt_Comment
}

// return a valid markup map, creating it if necessary.
func (op *Comment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*Comment)(nil)
var _ rtti.Execute = (*Comment)(nil)

// comment, a type of flow.
var Zt_Comment = typeinfo.Flow{
	Name: "comment",
	Lede: "comment",
	Terms: []typeinfo.Term{{
		Name:  "lines",
		Label: "_",
		Type:  &prim.Zt_Lines,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Add a note.", "Information about the story for you and other authors."},
	},
}

// holds a slice of type comment
// FIX: duplicates the spec decl.
type FIX_Comment_Slice []Comment

// implements typeinfo.Inspector
func (*Comment_Slice) Inspect() typeinfo.T {
	return &Zt_Comment
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Test struct {
	TestName       string
	SceneNames     string
	TestStatements StoryStatement
	Exe            rtti.Execute
	Markup         map[string]any
}

// implements typeinfo.Inspector
func (*Test) Inspect() typeinfo.T {
	return &Zt_Test
}

// return a valid markup map, creating it if necessary.
func (op *Test) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*Test)(nil)
var _ rtti.Execute = (*Test)(nil)

// test, a type of flow.
var Zt_Test = typeinfo.Flow{
	Name: "test",
	Lede: "test",
	Terms: []typeinfo.Term{{
		Name:  "test_name",
		Label: "_",
		Type:  &prim.Zt_Text,
	}, {
		Name:     "scene_names",
		Label:    "depends_on",
		Optional: true,
		Repeats:  true,
		Type:     &prim.Zt_Text,
	}, {
		Name:     "test_statements",
		Label:    "with_scene",
		Optional: true,
		Repeats:  true,
		Type:     &Zt_StoryStatement,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Create a scene",
	},
}

// holds a slice of type test
// FIX: duplicates the spec decl.
type FIX_Test_Slice []Test

// implements typeinfo.Inspector
func (*Test_Slice) Inspect() typeinfo.T {
	return &Zt_Test
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineScene struct {
	Scene     rtti.TextEval
	DependsOn rtti.TextListEval
	With      StoryStatement
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*DefineScene) Inspect() typeinfo.T {
	return &Zt_DefineScene
}

// return a valid markup map, creating it if necessary.
func (op *DefineScene) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineScene)(nil)

// define_scene, a type of flow.
var Zt_DefineScene = typeinfo.Flow{
	Name: "define_scene",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "scene",
		Label: "scene",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "depends_on",
		Label:    "depends_on",
		Optional: true,
		Type:     &rtti.Zt_TextListEval,
	}, {
		Name:    "with",
		Label:   "with",
		Repeats: true,
		Type:    &Zt_StoryStatement,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
	},
	Markup: map[string]any{
		"comment": "Define a sub world.",
	},
}

// holds a slice of type define_scene
// FIX: duplicates the spec decl.
type FIX_DefineScene_Slice []DefineScene

// implements typeinfo.Inspector
func (*DefineScene_Slice) Inspect() typeinfo.T {
	return &Zt_DefineScene
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineAction struct {
	Action   rtti.TextEval
	Requires FieldDefinition
	Provides FieldDefinition
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*DefineAction) Inspect() typeinfo.T {
	return &Zt_DefineAction
}

// return a valid markup map, creating it if necessary.
func (op *DefineAction) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineAction)(nil)
var _ rtti.Execute = (*DefineAction)(nil)

// define_action, a type of flow.
var Zt_DefineAction = typeinfo.Flow{
	Name: "define_action",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "action",
		Label: "action",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:    "requires",
		Label:   "requires",
		Repeats: true,
		Type:    &Zt_FieldDefinition,
	}, {
		Name:     "provides",
		Label:    "provides",
		Optional: true,
		Repeats:  true,
		Type:     &Zt_FieldDefinition,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Declare an activity: Activities help actors perform tasks: for instance, picking up or dropping items.  Activities involve either the player or an npc and possibly one or two other objects.",
	},
}

// holds a slice of type define_action
// FIX: duplicates the spec decl.
type FIX_DefineAction_Slice []DefineAction

// implements typeinfo.Inspector
func (*DefineAction_Slice) Inspect() typeinfo.T {
	return &Zt_DefineAction
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineTraits struct {
	Traits rtti.TextListEval
	Aspect rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DefineTraits) Inspect() typeinfo.T {
	return &Zt_DefineTraits
}

// return a valid markup map, creating it if necessary.
func (op *DefineTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineTraits)(nil)
var _ rtti.Execute = (*DefineTraits)(nil)

// define_traits, a type of flow.
var Zt_DefineTraits = typeinfo.Flow{
	Name: "define_traits",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "traits",
		Label: "traits",
		Type:  &rtti.Zt_TextListEval,
	}, {
		Name:  "aspect",
		Label: "as",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Add traits to an aspect",
	},
}

// holds a slice of type define_traits
// FIX: duplicates the spec decl.
type FIX_DefineTraits_Slice []DefineTraits

// implements typeinfo.Inspector
func (*DefineTraits_Slice) Inspect() typeinfo.T {
	return &Zt_DefineTraits
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_AspectField struct {
	Aspect rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*AspectField) Inspect() typeinfo.T {
	return &Zt_AspectField
}

// return a valid markup map, creating it if necessary.
func (op *AspectField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*AspectField)(nil)

// aspect_field, a type of flow.
var Zt_AspectField = typeinfo.Flow{
	Name: "aspect_field",
	Lede: "aspect",
	Terms: []typeinfo.Term{{
		Name:  "aspect",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
	Markup: map[string]any{
		"comment": []interface{}{"tbd: is a separate interface required for object kinds separate from everything else?", "in theory, generic.Kind supports fields of type aspect... but i'm not sure weave handles that."},
	},
}

// holds a slice of type aspect_field
// FIX: duplicates the spec decl.
type FIX_AspectField_Slice []AspectField

// implements typeinfo.Inspector
func (*AspectField_Slice) Inspect() typeinfo.T {
	return &Zt_AspectField
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_BoolField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.BoolEval
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*BoolField) Inspect() typeinfo.T {
	return &Zt_BoolField
}

// return a valid markup map, creating it if necessary.
func (op *BoolField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*BoolField)(nil)

// bool_field, a type of flow.
var Zt_BoolField = typeinfo.Flow{
	Name: "bool_field",
	Lede: "bool",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "type",
		Label:    "kind",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:     "initially",
		Label:    "initially",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
}

// holds a slice of type bool_field
// FIX: duplicates the spec decl.
type FIX_BoolField_Slice []BoolField

// implements typeinfo.Inspector
func (*BoolField_Slice) Inspect() typeinfo.T {
	return &Zt_BoolField
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CountOf struct {
	Trigger core.Trigger
	Num     rtti.NumberEval
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*CountOf) Inspect() typeinfo.T {
	return &Zt_CountOf
}

// return a valid markup map, creating it if necessary.
func (op *CountOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CountOf)(nil)

// count_of, a type of flow.
var Zt_CountOf = typeinfo.Flow{
	Name: "count_of",
	Lede: "count_of",
	Terms: []typeinfo.Term{{
		Name:  "trigger",
		Label: "_",
		Type:  &core.Zt_Trigger,
	}, {
		Name:  "num",
		Label: "num",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
	},
	Markup: map[string]any{
		"comment": []interface{}{"A guard which returns true based on a counter.", "Counters start at zero and are incremented every time the guard gets checked."},
	},
}

// holds a slice of type count_of
// FIX: duplicates the spec decl.
type FIX_CountOf_Slice []CountOf

// implements typeinfo.Inspector
func (*CountOf_Slice) Inspect() typeinfo.T {
	return &Zt_CountOf
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CycleText struct {
	Parts  rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*CycleText) Inspect() typeinfo.T {
	return &Zt_CycleText
}

// return a valid markup map, creating it if necessary.
func (op *CycleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CycleText)(nil)

// cycle_text, a type of flow.
var Zt_CycleText = typeinfo.Flow{
	Name: "cycle_text",
	Lede: "cycle_text",
	Terms: []typeinfo.Term{{
		Name:    "parts",
		Label:   "_",
		Repeats: true,
		Type:    &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "When called multiple times, returns each of its inputs in turn.",
	},
}

// holds a slice of type cycle_text
// FIX: duplicates the spec decl.
type FIX_CycleText_Slice []CycleText

// implements typeinfo.Inspector
func (*CycleText_Slice) Inspect() typeinfo.T {
	return &Zt_CycleText
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineAlias struct {
	Names    rtti.TextListEval
	NounName rtti.TextEval
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*DefineAlias) Inspect() typeinfo.T {
	return &Zt_DefineAlias
}

// return a valid markup map, creating it if necessary.
func (op *DefineAlias) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DefineAlias)(nil)
var _ StoryStatement = (*DefineAlias)(nil)

// define_alias, a type of flow.
var Zt_DefineAlias = typeinfo.Flow{
	Name: "define_alias",
	Lede: "interpret",
	Terms: []typeinfo.Term{{
		Name:  "names",
		Label: "alias",
		Type:  &rtti.Zt_TextListEval,
	}, {
		Name:  "noun_name",
		Label: "as",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
		&Zt_StoryStatement,
	},
	Markup: map[string]any{
		"comment": "allows the player to refer to a noun by one or more other terms.",
	},
}

// holds a slice of type define_alias
// FIX: duplicates the spec decl.
type FIX_DefineAlias_Slice []DefineAlias

// implements typeinfo.Inspector
func (*DefineAlias_Slice) Inspect() typeinfo.T {
	return &Zt_DefineAlias
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineLeadingGrammar struct {
	Lede   string
	Scans  grammar.ScannerMaker
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DefineLeadingGrammar) Inspect() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// return a valid markup map, creating it if necessary.
func (op *DefineLeadingGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DefineLeadingGrammar)(nil)
var _ StoryStatement = (*DefineLeadingGrammar)(nil)

// define_leading_grammar, a type of flow.
var Zt_DefineLeadingGrammar = typeinfo.Flow{
	Name: "define_leading_grammar",
	Lede: "interpret",
	Terms: []typeinfo.Term{{
		Name:    "lede",
		Label:   "_",
		Repeats: true,
		Type:    &prim.Zt_Text,
	}, {
		Name:    "scans",
		Label:   "with",
		Repeats: true,
		Type:    &grammar.Zt_ScannerMaker,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
		&Zt_StoryStatement,
	},
	Markup: map[string]any{
		"comment": "starts a parser scanner.",
	},
}

// holds a slice of type define_leading_grammar
// FIX: duplicates the spec decl.
type FIX_DefineLeadingGrammar_Slice []DefineLeadingGrammar

// implements typeinfo.Inspector
func (*DefineLeadingGrammar_Slice) Inspect() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineNamedGrammar struct {
	Name   string
	Scans  grammar.ScannerMaker
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DefineNamedGrammar) Inspect() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// return a valid markup map, creating it if necessary.
func (op *DefineNamedGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DefineNamedGrammar)(nil)
var _ StoryStatement = (*DefineNamedGrammar)(nil)

// define_named_grammar, a type of flow.
var Zt_DefineNamedGrammar = typeinfo.Flow{
	Name: "define_named_grammar",
	Lede: "interpret",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "name",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "scans",
		Label:   "with",
		Repeats: true,
		Type:    &grammar.Zt_ScannerMaker,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
		&Zt_StoryStatement,
	},
	Markup: map[string]any{
		"comment": "starts a parser scanner.",
	},
}

// holds a slice of type define_named_grammar
// FIX: duplicates the spec decl.
type FIX_DefineNamedGrammar_Slice []DefineNamedGrammar

// implements typeinfo.Inspector
func (*DefineNamedGrammar_Slice) Inspect() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefinePhrase struct {
	Phrase   rtti.TextEval
	Macro    rtti.TextEval
	Reversed rtti.BoolEval
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*DefinePhrase) Inspect() typeinfo.T {
	return &Zt_DefinePhrase
}

// return a valid markup map, creating it if necessary.
func (op *DefinePhrase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePhrase)(nil)

// define_phrase, a type of flow.
var Zt_DefinePhrase = typeinfo.Flow{
	Name: "define_phrase",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "phrase",
		Label: "phrase",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "macro",
		Label: "as_macro",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "reversed",
		Label:    "reversed",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
	},
	Markup: map[string]any{
		"comment": "Define a phrase that can be used with 'natural language' statements.",
	},
}

// holds a slice of type define_phrase
// FIX: duplicates the spec decl.
type FIX_DefinePhrase_Slice []DefinePhrase

// implements typeinfo.Inspector
func (*DefinePhrase_Slice) Inspect() typeinfo.T {
	return &Zt_DefinePhrase
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DeclareStatement struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DeclareStatement) Inspect() typeinfo.T {
	return &Zt_DeclareStatement
}

// return a valid markup map, creating it if necessary.
func (op *DeclareStatement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DeclareStatement)(nil)

// declare_statement, a type of flow.
var Zt_DeclareStatement = typeinfo.Flow{
	Name: "declare_statement",
	Lede: "declare",
	Terms: []typeinfo.Term{{
		Name:  "text",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
	},
	Markup: map[string]any{
		"comment": "Simple english like definitions of nouns, kinds, and their relatives.",
	},
}

// holds a slice of type declare_statement
// FIX: duplicates the spec decl.
type FIX_DeclareStatement_Slice []DeclareStatement

// implements typeinfo.Inspector
func (*DeclareStatement_Slice) Inspect() typeinfo.T {
	return &Zt_DeclareStatement
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineRelation struct {
	Relation    rtti.TextEval
	Kind        rtti.TextEval
	OtherKind   rtti.TextEval
	Cardinality string
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*DefineRelation) Inspect() typeinfo.T {
	return &Zt_DefineRelation
}

// return a valid markup map, creating it if necessary.
func (op *DefineRelation) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineRelation)(nil)
var _ rtti.Execute = (*DefineRelation)(nil)

// define_relation, a type of flow.
var Zt_DefineRelation = typeinfo.Flow{
	Name: "define_relation",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "relation",
		Label: "relation",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "kind",
		Label: "kind",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "other_kind",
		Label: "other_kind",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "cardinality",
		Label: "cardinality",
		Type:  &Zt_RelationCardinality,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
}

// holds a slice of type define_relation
// FIX: duplicates the spec decl.
type FIX_DefineRelation_Slice []DefineRelation

// implements typeinfo.Inspector
func (*DefineRelation_Slice) Inspect() typeinfo.T {
	return &Zt_DefineRelation
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineFields struct {
	Kind   rtti.TextEval
	Fields FieldDefinition
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DefineFields) Inspect() typeinfo.T {
	return &Zt_DefineFields
}

// return a valid markup map, creating it if necessary.
func (op *DefineFields) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineFields)(nil)
var _ rtti.Execute = (*DefineFields)(nil)

// define_fields, a type of flow.
var Zt_DefineFields = typeinfo.Flow{
	Name: "define_fields",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "kind",
		Label: "kind",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:    "fields",
		Label:   "fields",
		Repeats: true,
		Type:    &Zt_FieldDefinition,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Add properties to a kind",
	},
}

// holds a slice of type define_fields
// FIX: duplicates the spec decl.
type FIX_DefineFields_Slice []DefineFields

// implements typeinfo.Inspector
func (*DefineFields_Slice) Inspect() typeinfo.T {
	return &Zt_DefineFields
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineKinds struct {
	Kinds    rtti.TextListEval
	Ancestor rtti.TextEval
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*DefineKinds) Inspect() typeinfo.T {
	return &Zt_DefineKinds
}

// return a valid markup map, creating it if necessary.
func (op *DefineKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineKinds)(nil)
var _ rtti.Execute = (*DefineKinds)(nil)

// define_kinds, a type of flow.
var Zt_DefineKinds = typeinfo.Flow{
	Name: "define_kinds",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "kinds",
		Label: "kinds",
		Type:  &rtti.Zt_TextListEval,
	}, {
		Name:  "ancestor",
		Label: "as",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
}

// holds a slice of type define_kinds
// FIX: duplicates the spec decl.
type FIX_DefineKinds_Slice []DefineKinds

// implements typeinfo.Inspector
func (*DefineKinds_Slice) Inspect() typeinfo.T {
	return &Zt_DefineKinds
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeOpposite struct {
	Word     rtti.TextEval
	Opposite rtti.TextEval
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*MakeOpposite) Inspect() typeinfo.T {
	return &Zt_MakeOpposite
}

// return a valid markup map, creating it if necessary.
func (op *MakeOpposite) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*MakeOpposite)(nil)
var _ rtti.Execute = (*MakeOpposite)(nil)

// make_opposite, a type of flow.
var Zt_MakeOpposite = typeinfo.Flow{
	Name: "make_opposite",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "word",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "opposite",
		Label: "opposite",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "The opposite of east is west.",
	},
}

// holds a slice of type make_opposite
// FIX: duplicates the spec decl.
type FIX_MakeOpposite_Slice []MakeOpposite

// implements typeinfo.Inspector
func (*MakeOpposite_Slice) Inspect() typeinfo.T {
	return &Zt_MakeOpposite
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakePlural struct {
	Singular rtti.TextEval
	Plural   rtti.TextEval
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*MakePlural) Inspect() typeinfo.T {
	return &Zt_MakePlural
}

// return a valid markup map, creating it if necessary.
func (op *MakePlural) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*MakePlural)(nil)
var _ rtti.Execute = (*MakePlural)(nil)

// make_plural, a type of flow.
var Zt_MakePlural = typeinfo.Flow{
	Name: "make_plural",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "singular",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "plural",
		Label: "plural",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"The plural of person is people.", "The plural of person is persons."},
	},
}

// holds a slice of type make_plural
// FIX: duplicates the spec decl.
type FIX_MakePlural_Slice []MakePlural

// implements typeinfo.Inspector
func (*MakePlural_Slice) Inspect() typeinfo.T {
	return &Zt_MakePlural
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MapDeparting struct {
	RoomName      rtti.TextEval
	DoorName      rtti.TextEval
	MapConnection string
	OtherRoomName rtti.TextEval
	Markup        map[string]any
}

// implements typeinfo.Inspector
func (*MapDeparting) Inspect() typeinfo.T {
	return &Zt_MapDeparting
}

// return a valid markup map, creating it if necessary.
func (op *MapDeparting) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*MapDeparting)(nil)
var _ rtti.Execute = (*MapDeparting)(nil)

// map_departing, a type of flow.
var Zt_MapDeparting = typeinfo.Flow{
	Name: "map_departing",
	Lede: "departing",
	Terms: []typeinfo.Term{{
		Name:  "room_name",
		Label: "from",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "door_name",
		Label: "via",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "map_connection",
		Label: "and",
		Type:  &Zt_MapConnection,
	}, {
		Name:  "other_room_name",
		Label: "other_room",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Leaving a room by by going through a door ( ex. departing the house via the front door... ).",
	},
}

// holds a slice of type map_departing
// FIX: duplicates the spec decl.
type FIX_MapDeparting_Slice []MapDeparting

// implements typeinfo.Inspector
func (*MapDeparting_Slice) Inspect() typeinfo.T {
	return &Zt_MapDeparting
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MapHeading struct {
	Dir           string
	RoomName      rtti.TextEval
	DoorName      rtti.TextEval
	MapConnection string
	OtherRoomName rtti.TextEval
	Markup        map[string]any
}

// implements typeinfo.Inspector
func (*MapHeading) Inspect() typeinfo.T {
	return &Zt_MapHeading
}

// return a valid markup map, creating it if necessary.
func (op *MapHeading) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*MapHeading)(nil)
var _ rtti.Execute = (*MapHeading)(nil)

// map_heading, a type of flow.
var Zt_MapHeading = typeinfo.Flow{
	Name: "map_heading",
	Lede: "heading",
	Terms: []typeinfo.Term{{
		Name:  "dir",
		Label: "_",
		Type:  &Zt_MapDirection,
	}, {
		Name:  "room_name",
		Label: "from",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "door_name",
		Label:    "via",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:  "map_connection",
		Label: "and",
		Type:  &Zt_MapConnection,
	}, {
		Name:  "other_room_name",
		Label: "other_room",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Leaving a room by moving in a compass direction ( ex. heading east... ).",
	},
}

// holds a slice of type map_heading
// FIX: duplicates the spec decl.
type FIX_MapHeading_Slice []MapHeading

// implements typeinfo.Inspector
func (*MapHeading_Slice) Inspect() typeinfo.T {
	return &Zt_MapHeading
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineValue struct {
	FieldName rtti.TextEval
	Nouns     rtti.TextListEval
	Value     rtti.Assignment
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*DefineValue) Inspect() typeinfo.T {
	return &Zt_DefineValue
}

// return a valid markup map, creating it if necessary.
func (op *DefineValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineValue)(nil)
var _ rtti.Execute = (*DefineValue)(nil)

// define_value, a type of flow.
var Zt_DefineValue = typeinfo.Flow{
	Name: "define_value",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "field_name",
		Label: "value",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "nouns",
		Label: "of",
		Type:  &rtti.Zt_TextListEval,
	}, {
		Name:  "value",
		Label: "as",
		Type:  &rtti.Zt_Assignment,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Assign a starting value to the field of one or nouns.",
	},
}

// holds a slice of type define_value
// FIX: duplicates the spec decl.
type FIX_DefineValue_Slice []DefineValue

// implements typeinfo.Inspector
func (*DefineValue_Slice) Inspect() typeinfo.T {
	return &Zt_DefineValue
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineNouns struct {
	Nouns  rtti.TextListEval
	Kind   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DefineNouns) Inspect() typeinfo.T {
	return &Zt_DefineNouns
}

// return a valid markup map, creating it if necessary.
func (op *DefineNouns) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNouns)(nil)
var _ rtti.Execute = (*DefineNouns)(nil)

// define_nouns, a type of flow.
var Zt_DefineNouns = typeinfo.Flow{
	Name: "define_nouns",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "nouns",
		Label: "nouns",
		Type:  &rtti.Zt_TextListEval,
	}, {
		Name:  "kind",
		Label: "as",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
}

// holds a slice of type define_nouns
// FIX: duplicates the spec decl.
type FIX_DefineNouns_Slice []DefineNouns

// implements typeinfo.Inspector
func (*DefineNouns_Slice) Inspect() typeinfo.T {
	return &Zt_DefineNouns
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineNounTraits struct {
	Nouns  rtti.TextListEval
	Traits rtti.TextListEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*DefineNounTraits) Inspect() typeinfo.T {
	return &Zt_DefineNounTraits
}

// return a valid markup map, creating it if necessary.
func (op *DefineNounTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNounTraits)(nil)
var _ rtti.Execute = (*DefineNounTraits)(nil)

// define_noun_traits, a type of flow.
var Zt_DefineNounTraits = typeinfo.Flow{
	Name: "define_noun_traits",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "nouns",
		Label: "nouns",
		Type:  &rtti.Zt_TextListEval,
	}, {
		Name:  "traits",
		Label: "traits",
		Type:  &rtti.Zt_TextListEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
}

// holds a slice of type define_noun_traits
// FIX: duplicates the spec decl.
type FIX_DefineNounTraits_Slice []DefineNounTraits

// implements typeinfo.Inspector
func (*DefineNounTraits_Slice) Inspect() typeinfo.T {
	return &Zt_DefineNounTraits
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_NumListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.NumListEval
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*NumListField) Inspect() typeinfo.T {
	return &Zt_NumListField
}

// return a valid markup map, creating it if necessary.
func (op *NumListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NumListField)(nil)

// num_list_field, a type of flow.
var Zt_NumListField = typeinfo.Flow{
	Name: "num_list_field",
	Lede: "num_list",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "type",
		Label:    "kind",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:     "initially",
		Label:    "initially",
		Optional: true,
		Type:     &rtti.Zt_NumListEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
}

// holds a slice of type num_list_field
// FIX: duplicates the spec decl.
type FIX_NumListField_Slice []NumListField

// implements typeinfo.Inspector
func (*NumListField_Slice) Inspect() typeinfo.T {
	return &Zt_NumListField
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_NumberField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.NumberEval
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*NumberField) Inspect() typeinfo.T {
	return &Zt_NumberField
}

// return a valid markup map, creating it if necessary.
func (op *NumberField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NumberField)(nil)

// number_field, a type of flow.
var Zt_NumberField = typeinfo.Flow{
	Name: "number_field",
	Lede: "number",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "type",
		Label:    "kind",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:     "initially",
		Label:    "initially",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
}

// holds a slice of type number_field
// FIX: duplicates the spec decl.
type FIX_NumberField_Slice []NumberField

// implements typeinfo.Inspector
func (*NumberField_Slice) Inspect() typeinfo.T {
	return &Zt_NumberField
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_RuleProvides struct {
	PatternName rtti.TextEval
	Provides    FieldDefinition
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*RuleProvides) Inspect() typeinfo.T {
	return &Zt_RuleProvides
}

// return a valid markup map, creating it if necessary.
func (op *RuleProvides) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleProvides)(nil)
var _ rtti.Execute = (*RuleProvides)(nil)

// rule_provides, a type of flow.
var Zt_RuleProvides = typeinfo.Flow{
	Name: "rule_provides",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "pattern_name",
		Label: "rule",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:    "provides",
		Label:   "provides",
		Repeats: true,
		Type:    &Zt_FieldDefinition,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
}

// holds a slice of type rule_provides
// FIX: duplicates the spec decl.
type FIX_RuleProvides_Slice []RuleProvides

// implements typeinfo.Inspector
func (*RuleProvides_Slice) Inspect() typeinfo.T {
	return &Zt_RuleProvides
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_RuleForPattern struct {
	PatternName rtti.TextEval
	RuleName    rtti.TextEval
	Exe         rtti.Execute
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*RuleForPattern) Inspect() typeinfo.T {
	return &Zt_RuleForPattern
}

// return a valid markup map, creating it if necessary.
func (op *RuleForPattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForPattern)(nil)
var _ rtti.Execute = (*RuleForPattern)(nil)

// rule_for_pattern, a type of flow.
var Zt_RuleForPattern = typeinfo.Flow{
	Name: "rule_for_pattern",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "pattern_name",
		Label: "rule",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "rule_name",
		Label:    "named",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Change the behavior of an existing pattern.", "For events, this adds a listener that responds to the targeted object only when triggered by the player.", "By default, rules with filters continue on to the next rule automatically.", "Because event listeners have filters they continue to the next listener unless specifically stopped."},
	},
}

// holds a slice of type rule_for_pattern
// FIX: duplicates the spec decl.
type FIX_RuleForPattern_Slice []RuleForPattern

// implements typeinfo.Inspector
func (*RuleForPattern_Slice) Inspect() typeinfo.T {
	return &Zt_RuleForPattern
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_RuleForNoun struct {
	PatternName rtti.TextEval
	NounName    rtti.TextEval
	RuleName    rtti.TextEval
	Exe         rtti.Execute
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*RuleForNoun) Inspect() typeinfo.T {
	return &Zt_RuleForNoun
}

// return a valid markup map, creating it if necessary.
func (op *RuleForNoun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForNoun)(nil)
var _ rtti.Execute = (*RuleForNoun)(nil)

// rule_for_noun, a type of flow.
var Zt_RuleForNoun = typeinfo.Flow{
	Name: "rule_for_noun",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "pattern_name",
		Label: "rule",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "noun_name",
		Label: "noun",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "rule_name",
		Label:    "named",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Change the behavior of an existing pattern.", "The default behavior for events is to fall through to the next handler unless canceled or stopped."},
	},
}

// holds a slice of type rule_for_noun
// FIX: duplicates the spec decl.
type FIX_RuleForNoun_Slice []RuleForNoun

// implements typeinfo.Inspector
func (*RuleForNoun_Slice) Inspect() typeinfo.T {
	return &Zt_RuleForNoun
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_RuleForKind struct {
	PatternName rtti.TextEval
	KindName    rtti.TextEval
	Exactly     rtti.BoolEval
	RuleName    rtti.TextEval
	Exe         rtti.Execute
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*RuleForKind) Inspect() typeinfo.T {
	return &Zt_RuleForKind
}

// return a valid markup map, creating it if necessary.
func (op *RuleForKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForKind)(nil)
var _ rtti.Execute = (*RuleForKind)(nil)

// rule_for_kind, a type of flow.
var Zt_RuleForKind = typeinfo.Flow{
	Name: "rule_for_kind",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "pattern_name",
		Label: "rule",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "kind_name",
		Label: "kind",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "exactly",
		Label:    "exactly",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}, {
		Name:     "rule_name",
		Label:    "named",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Change the behavior of an existing pattern.", "The default behavior for events is to fall through to the next handler unless canceled or stopped."},
	},
}

// holds a slice of type rule_for_kind
// FIX: duplicates the spec decl.
type FIX_RuleForKind_Slice []RuleForKind

// implements typeinfo.Inspector
func (*RuleForKind_Slice) Inspect() typeinfo.T {
	return &Zt_RuleForKind
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineMacro struct {
	MacroName       rtti.TextEval
	Requires        FieldDefinition
	Provides        FieldDefinition
	MacroStatements rtti.Execute
	Markup          map[string]any
}

// implements typeinfo.Inspector
func (*DefineMacro) Inspect() typeinfo.T {
	return &Zt_DefineMacro
}

// return a valid markup map, creating it if necessary.
func (op *DefineMacro) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineMacro)(nil)
var _ rtti.Execute = (*DefineMacro)(nil)

// define_macro, a type of flow.
var Zt_DefineMacro = typeinfo.Flow{
	Name: "define_macro",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "macro_name",
		Label: "macro",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:    "requires",
		Label:   "requires",
		Repeats: true,
		Type:    &Zt_FieldDefinition,
	}, {
		Name:    "provides",
		Label:   "provides",
		Repeats: true,
		Type:    &Zt_FieldDefinition,
	}, {
		Name:    "macro_statements",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Declare a function which can produce statements about the game world.", "They are processed at import time, and they cannot call patterns", "nor can patterns -- which are processed during play -- call macros.", "Unlike patterns, they cannot be extended; the entire definition must live in one place."},
	},
}

// holds a slice of type define_macro
// FIX: duplicates the spec decl.
type FIX_DefineMacro_Slice []DefineMacro

// implements typeinfo.Inspector
func (*DefineMacro_Slice) Inspect() typeinfo.T {
	return &Zt_DefineMacro
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_CallMacro struct {
	MacroName string
	Arguments assign.Arg
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*CallMacro) Inspect() typeinfo.T {
	return &Zt_CallMacro
}

// return a valid markup map, creating it if necessary.
func (op *CallMacro) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*CallMacro)(nil)
var _ rtti.BoolEval = (*CallMacro)(nil)
var _ rtti.NumberEval = (*CallMacro)(nil)
var _ rtti.TextEval = (*CallMacro)(nil)
var _ rtti.RecordEval = (*CallMacro)(nil)
var _ rtti.NumListEval = (*CallMacro)(nil)
var _ rtti.TextListEval = (*CallMacro)(nil)
var _ rtti.RecordListEval = (*CallMacro)(nil)
var _ StoryStatement = (*CallMacro)(nil)

// call_macro, a type of flow.
var Zt_CallMacro = typeinfo.Flow{
	Name: "call_macro",
	Lede: "call",
	Terms: []typeinfo.Term{{
		Name:  "macro_name",
		Label: "macro",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "arguments",
		Label:   "args",
		Repeats: true,
		Type:    &assign.Zt_Arg,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
		&rtti.Zt_BoolEval,
		&rtti.Zt_NumberEval,
		&rtti.Zt_TextEval,
		&rtti.Zt_RecordEval,
		&rtti.Zt_NumListEval,
		&rtti.Zt_TextListEval,
		&rtti.Zt_RecordListEval,
		&Zt_StoryStatement,
	},
	Markup: map[string]any{
		"comment": "Executes a macro, and potentially returns a value.",
	},
}

// holds a slice of type call_macro
// FIX: duplicates the spec decl.
type FIX_CallMacro_Slice []CallMacro

// implements typeinfo.Inspector
func (*CallMacro_Slice) Inspect() typeinfo.T {
	return &Zt_CallMacro
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefinePattern struct {
	PatternName rtti.TextEval
	Requires    FieldDefinition
	Provides    FieldDefinition
	Exe         rtti.Execute
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*DefinePattern) Inspect() typeinfo.T {
	return &Zt_DefinePattern
}

// return a valid markup map, creating it if necessary.
func (op *DefinePattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePattern)(nil)
var _ rtti.Execute = (*DefinePattern)(nil)

// define_pattern, a type of flow.
var Zt_DefinePattern = typeinfo.Flow{
	Name: "define_pattern",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "pattern_name",
		Label: "pattern",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:    "requires",
		Label:   "requires",
		Repeats: true,
		Type:    &Zt_FieldDefinition,
	}, {
		Name:    "provides",
		Label:   "provides",
		Repeats: true,
		Type:    &Zt_FieldDefinition,
	}, {
		Name:     "exe",
		Label:    "do",
		Optional: true,
		Repeats:  true,
		Type:     &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Declare a new pattern.", "A pattern is a bundle of functions which can either change the game world or provide information about it.", "Each function in a given pattern has \"guards\" which determine whether the function applies in a particular situation."},
	},
}

// holds a slice of type define_pattern
// FIX: duplicates the spec decl.
type FIX_DefinePattern_Slice []DefinePattern

// implements typeinfo.Inspector
func (*DefinePattern_Slice) Inspect() typeinfo.T {
	return &Zt_DefinePattern
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_RecordListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.RecordListEval
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*RecordListField) Inspect() typeinfo.T {
	return &Zt_RecordListField
}

// return a valid markup map, creating it if necessary.
func (op *RecordListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*RecordListField)(nil)

// record_list_field, a type of flow.
var Zt_RecordListField = typeinfo.Flow{
	Name: "record_list_field",
	Lede: "record_list",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "type",
		Label:    "kind",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:     "initially",
		Label:    "initially",
		Optional: true,
		Type:     &rtti.Zt_RecordListEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
}

// holds a slice of type record_list_field
// FIX: duplicates the spec decl.
type FIX_RecordListField_Slice []RecordListField

// implements typeinfo.Inspector
func (*RecordListField_Slice) Inspect() typeinfo.T {
	return &Zt_RecordListField
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_RecordField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.RecordEval
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*RecordField) Inspect() typeinfo.T {
	return &Zt_RecordField
}

// return a valid markup map, creating it if necessary.
func (op *RecordField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*RecordField)(nil)

// record_field, a type of flow.
var Zt_RecordField = typeinfo.Flow{
	Name: "record_field",
	Lede: "record",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "type",
		Label:    "kind",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:     "initially",
		Label:    "initially",
		Optional: true,
		Type:     &rtti.Zt_RecordEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
}

// holds a slice of type record_field
// FIX: duplicates the spec decl.
type FIX_RecordField_Slice []RecordField

// implements typeinfo.Inspector
func (*RecordField_Slice) Inspect() typeinfo.T {
	return &Zt_RecordField
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineRelatives struct {
	Nouns      rtti.TextListEval
	Relation   rtti.TextEval
	OtherNouns rtti.TextListEval
	Markup     map[string]any
}

// implements typeinfo.Inspector
func (*DefineRelatives) Inspect() typeinfo.T {
	return &Zt_DefineRelatives
}

// return a valid markup map, creating it if necessary.
func (op *DefineRelatives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineRelatives)(nil)
var _ rtti.Execute = (*DefineRelatives)(nil)

// define_relatives, a type of flow.
var Zt_DefineRelatives = typeinfo.Flow{
	Name: "define_relatives",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "nouns",
		Label: "nouns",
		Type:  &rtti.Zt_TextListEval,
	}, {
		Name:  "relation",
		Label: "relative_to",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "other_nouns",
		Label: "other_nouns",
		Type:  &rtti.Zt_TextListEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Relate nouns to each other",
	},
}

// holds a slice of type define_relatives
// FIX: duplicates the spec decl.
type FIX_DefineRelatives_Slice []DefineRelatives

// implements typeinfo.Inspector
func (*DefineRelatives_Slice) Inspect() typeinfo.T {
	return &Zt_DefineRelatives
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_DefineOtherRelatives struct {
	Relation   rtti.TextEval
	Nouns      rtti.TextListEval
	OtherNouns rtti.TextListEval
	Markup     map[string]any
}

// implements typeinfo.Inspector
func (*DefineOtherRelatives) Inspect() typeinfo.T {
	return &Zt_DefineOtherRelatives
}

// return a valid markup map, creating it if necessary.
func (op *DefineOtherRelatives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineOtherRelatives)(nil)
var _ rtti.Execute = (*DefineOtherRelatives)(nil)

// define_other_relatives, a type of flow.
var Zt_DefineOtherRelatives = typeinfo.Flow{
	Name: "define_other_relatives",
	Lede: "define",
	Terms: []typeinfo.Term{{
		Name:  "relation",
		Label: "relative_to",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:  "nouns",
		Label: "nouns",
		Type:  &rtti.Zt_TextListEval,
	}, {
		Name:  "other_nouns",
		Label: "other_nouns",
		Type:  &rtti.Zt_TextListEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Relate nouns to each other",
	},
}

// holds a slice of type define_other_relatives
// FIX: duplicates the spec decl.
type FIX_DefineOtherRelatives_Slice []DefineOtherRelatives

// implements typeinfo.Inspector
func (*DefineOtherRelatives_Slice) Inspect() typeinfo.T {
	return &Zt_DefineOtherRelatives
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SayTemplate struct {
	Template string
	Markup   map[string]any
}

// implements typeinfo.Inspector
func (*SayTemplate) Inspect() typeinfo.T {
	return &Zt_SayTemplate
}

// return a valid markup map, creating it if necessary.
func (op *SayTemplate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*SayTemplate)(nil)
var _ rtti.TextEval = (*SayTemplate)(nil)

// say_template, a type of flow.
var Zt_SayTemplate = typeinfo.Flow{
	Name: "say_template",
	Lede: "say",
	Terms: []typeinfo.Term{{
		Name:  "template",
		Label: "_",
		Type:  &prim.Zt_Lines,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Used for displaying text to the player.", "The text can contain 'inline-templates';", "mini-commands that help to simplify printing text.", "See also: https://github.com/ionous/iffy/wiki/Templates.", "( note: this is transformed for the runtime into an unnamed 'RenderResponse'. )"},
	},
}

// holds a slice of type say_template
// FIX: duplicates the spec decl.
type FIX_SayTemplate_Slice []SayTemplate

// implements typeinfo.Inspector
func (*SayTemplate_Slice) Inspect() typeinfo.T {
	return &Zt_SayTemplate
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_SayResponse struct {
	Name   string
	Text   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*SayResponse) Inspect() typeinfo.T {
	return &Zt_SayResponse
}

// return a valid markup map, creating it if necessary.
func (op *SayResponse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*SayResponse)(nil)
var _ rtti.TextEval = (*SayResponse)(nil)

// say_response, a type of flow.
var Zt_SayResponse = typeinfo.Flow{
	Name: "say_response",
	Lede: "say",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "response",
		Type:  &prim.Zt_Text,
	}, {
		Name:  "text",
		Label: "with",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Generate text in a replaceable manner.", "( note: this is transformed for the runtime into a named 'RenderResponse'. )"},
	},
}

// holds a slice of type say_response
// FIX: duplicates the spec decl.
type FIX_SayResponse_Slice []SayResponse

// implements typeinfo.Inspector
func (*SayResponse_Slice) Inspect() typeinfo.T {
	return &Zt_SayResponse
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ShuffleText struct {
	Parts  rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ShuffleText) Inspect() typeinfo.T {
	return &Zt_ShuffleText
}

// return a valid markup map, creating it if necessary.
func (op *ShuffleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*ShuffleText)(nil)

// shuffle_text, a type of flow.
var Zt_ShuffleText = typeinfo.Flow{
	Name: "shuffle_text",
	Lede: "shuffle_text",
	Terms: []typeinfo.Term{{
		Name:    "parts",
		Label:   "_",
		Repeats: true,
		Type:    &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "When called multiple times returns its inputs at random.",
	},
}

// holds a slice of type shuffle_text
// FIX: duplicates the spec decl.
type FIX_ShuffleText_Slice []ShuffleText

// implements typeinfo.Inspector
func (*ShuffleText_Slice) Inspect() typeinfo.T {
	return &Zt_ShuffleText
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_StoppingText struct {
	Parts  rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*StoppingText) Inspect() typeinfo.T {
	return &Zt_StoppingText
}

// return a valid markup map, creating it if necessary.
func (op *StoppingText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*StoppingText)(nil)

// stopping_text, a type of flow.
var Zt_StoppingText = typeinfo.Flow{
	Name: "stopping_text",
	Lede: "stopping_text",
	Terms: []typeinfo.Term{{
		Name:    "parts",
		Label:   "_",
		Repeats: true,
		Type:    &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextEval,
	},
	Markup: map[string]any{
		"comment": "When called multiple times returns each of its inputs in turn, sticking to the last one.",
	},
}

// holds a slice of type stopping_text
// FIX: duplicates the spec decl.
type FIX_StoppingText_Slice []StoppingText

// implements typeinfo.Inspector
func (*StoppingText_Slice) Inspect() typeinfo.T {
	return &Zt_StoppingText
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_StoryBreak struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*StoryBreak) Inspect() typeinfo.T {
	return &Zt_StoryBreak
}

// return a valid markup map, creating it if necessary.
func (op *StoryBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*StoryBreak)(nil)

// story_break, a type of flow.
var Zt_StoryBreak = typeinfo.Flow{
	Name:  "story_break",
	Lede:  "--",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&Zt_StoryStatement,
	},
	Markup: map[string]any{
		"comment": []interface{}{"a command with a signature of the comment marker metadata.", "a cheat to allows nodes that have only a comment marker and no actual command.", "see also: debug.do_nothing"},
	},
}

// holds a slice of type story_break
// FIX: duplicates the spec decl.
type FIX_StoryBreak_Slice []StoryBreak

// implements typeinfo.Inspector
func (*StoryBreak_Slice) Inspect() typeinfo.T {
	return &Zt_StoryBreak
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_StoryFile struct {
	StoryStatements StoryStatement
	Markup          map[string]any
}

// implements typeinfo.Inspector
func (*StoryFile) Inspect() typeinfo.T {
	return &Zt_StoryFile
}

// return a valid markup map, creating it if necessary.
func (op *StoryFile) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// story_file, a type of flow.
var Zt_StoryFile = typeinfo.Flow{
	Name: "story_file",
	Lede: "tapestry",
	Terms: []typeinfo.Term{{
		Name:    "story_statements",
		Label:   "_",
		Repeats: true,
		Type:    &Zt_StoryStatement,
	}},
	Markup: map[string]any{
		"blockly-color": "TAP_HUE_ROOT",
		"comment":       "top level node, currently just for blockly might eventually contain story metadata  ex. author, description...",
		"mosaic-root":   true,
	},
}

// holds a slice of type story_file
// FIX: duplicates the spec decl.
type FIX_StoryFile_Slice []StoryFile

// implements typeinfo.Inspector
func (*StoryFile_Slice) Inspect() typeinfo.T {
	return &Zt_StoryFile
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TextListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.TextListEval
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*TextListField) Inspect() typeinfo.T {
	return &Zt_TextListField
}

// return a valid markup map, creating it if necessary.
func (op *TextListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*TextListField)(nil)

// text_list_field, a type of flow.
var Zt_TextListField = typeinfo.Flow{
	Name: "text_list_field",
	Lede: "text_list",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "type",
		Label:    "kind",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:     "initially",
		Label:    "initially",
		Optional: true,
		Type:     &rtti.Zt_TextListEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
}

// holds a slice of type text_list_field
// FIX: duplicates the spec decl.
type FIX_TextListField_Slice []TextListField

// implements typeinfo.Inspector
func (*TextListField_Slice) Inspect() typeinfo.T {
	return &Zt_TextListField
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TextField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.TextEval
	Markup    map[string]any
}

// implements typeinfo.Inspector
func (*TextField) Inspect() typeinfo.T {
	return &Zt_TextField
}

// return a valid markup map, creating it if necessary.
func (op *TextField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*TextField)(nil)

// text_field, a type of flow.
var Zt_TextField = typeinfo.Flow{
	Name: "text_field",
	Lede: "text",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "_",
		Type:  &rtti.Zt_TextEval,
	}, {
		Name:     "type",
		Label:    "kind",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}, {
		Name:     "initially",
		Label:    "initially",
		Optional: true,
		Type:     &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
}

// holds a slice of type text_field
// FIX: duplicates the spec decl.
type FIX_TextField_Slice []TextField

// implements typeinfo.Inspector
func (*TextField_Slice) Inspect() typeinfo.T {
	return &Zt_TextField
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_NothingField struct {
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*NothingField) Inspect() typeinfo.T {
	return &Zt_NothingField
}

// return a valid markup map, creating it if necessary.
func (op *NothingField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NothingField)(nil)

// nothing_field, a type of flow.
var Zt_NothingField = typeinfo.Flow{
	Name:  "nothing_field",
	Lede:  "nothing",
	Terms: []typeinfo.Term{},
	Slots: []*typeinfo.Slot{
		&Zt_FieldDefinition,
	},
	Markup: map[string]any{
		"comment": []interface{}{"A valueless field.", "Intended mainly for patterns which don't need to return a value."},
	},
}

// holds a slice of type nothing_field
// FIX: duplicates the spec decl.
type FIX_NothingField_Slice []NothingField

// implements typeinfo.Inspector
func (*NothingField_Slice) Inspect() typeinfo.T {
	return &Zt_NothingField
}

const (
	Zc_MapConnection_ArrivingAt   = "arriving_at"
	Zc_MapConnection_ConnectingTo = "connecting_to"
)

// map_connection, a type of str enum.
var Zt_MapConnection = typeinfo.Str{
	Name: "map_connection",
	Options: []string{
		Zc_MapConnection_ArrivingAt,
		Zc_MapConnection_ConnectingTo,
	},
	Markup: map[string]any{
		"comment": "Chooses between a one-way and a two-way connection between rooms.  Generally, this only makes sense for map headings, but it at least causes 'departing' to check that a reverse connection exists.  Note: moving from one room leads you into another somewhat generically.  Sometimes its useful to position the player on entry to a new room based on where they came from.  Using, a previous room or last used door can do the trick.",
	},
}
var Zt_MapDirection = typeinfo.Str{
	Name: "map_direction",
	Markup: map[string]any{
		"comment": "A heading for movement within the game, often connecting one room within the game to another.  The most commonly used are standard compass directions like 'north', 'east', 'south', and 'west'.",
	},
}

const (
	Zc_RelationCardinality_OneToOne   = "one_to_one"
	Zc_RelationCardinality_OneToMany  = "one_to_many"
	Zc_RelationCardinality_ManyToOne  = "many_to_one"
	Zc_RelationCardinality_ManyToMany = "many_to_many"
)

// relation_cardinality, a type of str enum.
var Zt_RelationCardinality = typeinfo.Str{
	Name: "relation_cardinality",
	Options: []string{
		Zc_RelationCardinality_OneToOne,
		Zc_RelationCardinality_OneToMany,
		Zc_RelationCardinality_ManyToOne,
		Zc_RelationCardinality_ManyToMany,
	},
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "story",
	Slot: z_slot_list,
	Flow: z_flow_list,
	Str:  z_str_list,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_FieldDefinition,
	&Zt_StoryStatement,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Comment,
	&Zt_Test,
	&Zt_DefineScene,
	&Zt_DefineAction,
	&Zt_DefineTraits,
	&Zt_AspectField,
	&Zt_BoolField,
	&Zt_CountOf,
	&Zt_CycleText,
	&Zt_DefineAlias,
	&Zt_DefineLeadingGrammar,
	&Zt_DefineNamedGrammar,
	&Zt_DefinePhrase,
	&Zt_DeclareStatement,
	&Zt_DefineRelation,
	&Zt_DefineFields,
	&Zt_DefineKinds,
	&Zt_MakeOpposite,
	&Zt_MakePlural,
	&Zt_MapDeparting,
	&Zt_MapHeading,
	&Zt_DefineValue,
	&Zt_DefineNouns,
	&Zt_DefineNounTraits,
	&Zt_NumListField,
	&Zt_NumberField,
	&Zt_RuleProvides,
	&Zt_RuleForPattern,
	&Zt_RuleForNoun,
	&Zt_RuleForKind,
	&Zt_DefineMacro,
	&Zt_CallMacro,
	&Zt_DefinePattern,
	&Zt_RecordListField,
	&Zt_RecordField,
	&Zt_DefineRelatives,
	&Zt_DefineOtherRelatives,
	&Zt_SayTemplate,
	&Zt_SayResponse,
	&Zt_ShuffleText,
	&Zt_StoppingText,
	&Zt_StoryBreak,
	&Zt_StoryFile,
	&Zt_TextListField,
	&Zt_TextField,
	&Zt_NothingField,
}

// a list of all strs in this this package
var z_str_list = []*typeinfo.Str{
	&Zt_MapConnection,
	&Zt_MapDirection,
	&Zt_RelationCardinality,
}
