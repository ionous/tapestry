// Code generated by Tapestry; edit at your own risk.
package story

import (
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/grammar"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// field_definition, a type of slot.
var Zt_FieldDefinition = typeinfo.Slot{
	Name: "field_definition",
	Markup: map[string]any{
		"comment": "Fields are used to define the members of kinds, records, patterns, and so on.",
	},
}

// holds a single slot.
type FieldDefinition_Slot struct{ Value FieldDefinition }

// implements typeinfo.Instance for a single slot.
func (*FieldDefinition_Slot) TypeInfo() typeinfo.T {
	return &Zt_FieldDefinition
}

// holds a slice of slots.
type FieldDefinition_Slots []FieldDefinition

// implements typeinfo.Instance for a series of slots.
func (*FieldDefinition_Slots) TypeInfo() typeinfo.T {
	return &Zt_FieldDefinition
}

// implements typeinfo.Repeats
func (op *FieldDefinition_Slots) Repeats() bool {
	return len(*op) > 0
}

// story_statement, a type of slot.
var Zt_StoryStatement = typeinfo.Slot{
	Name: "story_statement",
	Markup: map[string]any{
		"blockly-color": "VARIABLES_HUE",
		"blockly-stack": true,
		"comment":       "Phrase",
	},
}

// holds a single slot.
type StoryStatement_Slot struct{ Value StoryStatement }

// implements typeinfo.Instance for a single slot.
func (*StoryStatement_Slot) TypeInfo() typeinfo.T {
	return &Zt_StoryStatement
}

// holds a slice of slots.
type StoryStatement_Slots []StoryStatement

// implements typeinfo.Instance for a series of slots.
func (*StoryStatement_Slots) TypeInfo() typeinfo.T {
	return &Zt_StoryStatement
}

// implements typeinfo.Repeats
func (op *StoryStatement_Slots) Repeats() bool {
	return len(*op) > 0
}

// Add a note.
// Information about the story for you and other authors.
type Comment struct {
	Lines  string
	Markup map[string]any
}

// comment, a type of flow.
var Zt_Comment typeinfo.Flow

// implements typeinfo.Instance
func (*Comment) TypeInfo() typeinfo.T {
	return &Zt_Comment
}

// implements typeinfo.Markup
func (op *Comment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*Comment)(nil)
var _ rtti.Execute = (*Comment)(nil)

// holds a slice of type comment
type Comment_Slice []Comment

// implements typeinfo.Instance
func (*Comment_Slice) TypeInfo() typeinfo.T {
	return &Zt_Comment
}

// implements typeinfo.Repeats
func (op *Comment_Slice) Repeats() bool {
	return len(*op) > 0
}

// Create a scene
type DefineTest struct {
	TestName      string
	RequireScenes rtti.TextListEval
	Statements    []StoryStatement
	Exe           []rtti.Execute
	Markup        map[string]any
}

// define_test, a type of flow.
var Zt_DefineTest typeinfo.Flow

// implements typeinfo.Instance
func (*DefineTest) TypeInfo() typeinfo.T {
	return &Zt_DefineTest
}

// implements typeinfo.Markup
func (op *DefineTest) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineTest)(nil)

// holds a slice of type define_test
type DefineTest_Slice []DefineTest

// implements typeinfo.Instance
func (*DefineTest_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineTest
}

// implements typeinfo.Repeats
func (op *DefineTest_Slice) Repeats() bool {
	return len(*op) > 0
}

// Define a sub world.
type DefineScene struct {
	Scene         rtti.TextEval
	RequireScenes rtti.TextListEval
	Statements    []StoryStatement
	Markup        map[string]any
}

// define_scene, a type of flow.
var Zt_DefineScene typeinfo.Flow

// implements typeinfo.Instance
func (*DefineScene) TypeInfo() typeinfo.T {
	return &Zt_DefineScene
}

// implements typeinfo.Markup
func (op *DefineScene) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineScene)(nil)

// holds a slice of type define_scene
type DefineScene_Slice []DefineScene

// implements typeinfo.Instance
func (*DefineScene_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineScene
}

// implements typeinfo.Repeats
func (op *DefineScene_Slice) Repeats() bool {
	return len(*op) > 0
}

// Declare an activity: Activities help actors perform tasks: for instance, picking up or dropping items.  Activities involve either the player or an npc and possibly one or two other objects.
type DefineAction struct {
	Action   rtti.TextEval
	Requires []FieldDefinition
	Provides []FieldDefinition
	Markup   map[string]any
}

// define_action, a type of flow.
var Zt_DefineAction typeinfo.Flow

// implements typeinfo.Instance
func (*DefineAction) TypeInfo() typeinfo.T {
	return &Zt_DefineAction
}

// implements typeinfo.Markup
func (op *DefineAction) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineAction)(nil)

// holds a slice of type define_action
type DefineAction_Slice []DefineAction

// implements typeinfo.Instance
func (*DefineAction_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAction
}

// implements typeinfo.Repeats
func (op *DefineAction_Slice) Repeats() bool {
	return len(*op) > 0
}

// Declare an aspect and its traits.
// Aspects here are assumed to be singularly named.
type DefineAspect struct {
	Aspect rtti.TextEval
	Traits rtti.TextListEval
	Markup map[string]any
}

// define_aspect, a type of flow.
var Zt_DefineAspect typeinfo.Flow

// implements typeinfo.Instance
func (*DefineAspect) TypeInfo() typeinfo.T {
	return &Zt_DefineAspect
}

// implements typeinfo.Markup
func (op *DefineAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineAspect)(nil)

// holds a slice of type define_aspect
type DefineAspect_Slice []DefineAspect

// implements typeinfo.Instance
func (*DefineAspect_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAspect
}

// implements typeinfo.Repeats
func (op *DefineAspect_Slice) Repeats() bool {
	return len(*op) > 0
}

// tbd: is a separate interface required for object kinds separate from everything else?
// in theory, generic.Kind supports fields of type aspect... but i'm not sure weave handles that.
type AspectField struct {
	Aspect rtti.TextEval
	Markup map[string]any
}

// aspect_field, a type of flow.
var Zt_AspectField typeinfo.Flow

// implements typeinfo.Instance
func (*AspectField) TypeInfo() typeinfo.T {
	return &Zt_AspectField
}

// implements typeinfo.Markup
func (op *AspectField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*AspectField)(nil)

// holds a slice of type aspect_field
type AspectField_Slice []AspectField

// implements typeinfo.Instance
func (*AspectField_Slice) TypeInfo() typeinfo.T {
	return &Zt_AspectField
}

// implements typeinfo.Repeats
func (op *AspectField_Slice) Repeats() bool {
	return len(*op) > 0
}

type BoolField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.BoolEval
	Markup    map[string]any
}

// bool_field, a type of flow.
var Zt_BoolField typeinfo.Flow

// implements typeinfo.Instance
func (*BoolField) TypeInfo() typeinfo.T {
	return &Zt_BoolField
}

// implements typeinfo.Markup
func (op *BoolField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*BoolField)(nil)

// holds a slice of type bool_field
type BoolField_Slice []BoolField

// implements typeinfo.Instance
func (*BoolField_Slice) TypeInfo() typeinfo.T {
	return &Zt_BoolField
}

// implements typeinfo.Repeats
func (op *BoolField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A guard which returns true based on a counter.
// Counters start at zero and are incremented every time the guard gets checked.
type CountOf struct {
	Trigger core.Trigger
	Num     rtti.NumberEval
	Markup  map[string]any
}

// count_of, a type of flow.
var Zt_CountOf typeinfo.Flow

// implements typeinfo.Instance
func (*CountOf) TypeInfo() typeinfo.T {
	return &Zt_CountOf
}

// implements typeinfo.Markup
func (op *CountOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CountOf)(nil)

// holds a slice of type count_of
type CountOf_Slice []CountOf

// implements typeinfo.Instance
func (*CountOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_CountOf
}

// implements typeinfo.Repeats
func (op *CountOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// When called multiple times, returns each of its inputs in turn.
type CycleText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// cycle_text, a type of flow.
var Zt_CycleText typeinfo.Flow

// implements typeinfo.Instance
func (*CycleText) TypeInfo() typeinfo.T {
	return &Zt_CycleText
}

// implements typeinfo.Markup
func (op *CycleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CycleText)(nil)

// holds a slice of type cycle_text
type CycleText_Slice []CycleText

// implements typeinfo.Instance
func (*CycleText_Slice) TypeInfo() typeinfo.T {
	return &Zt_CycleText
}

// implements typeinfo.Repeats
func (op *CycleText_Slice) Repeats() bool {
	return len(*op) > 0
}

// allows the player to refer to a noun by one or more other terms.
type DefineAlias struct {
	Names    rtti.TextListEval
	NounName rtti.TextEval
	Markup   map[string]any
}

// define_alias, a type of flow.
var Zt_DefineAlias typeinfo.Flow

// implements typeinfo.Instance
func (*DefineAlias) TypeInfo() typeinfo.T {
	return &Zt_DefineAlias
}

// implements typeinfo.Markup
func (op *DefineAlias) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineAlias)(nil)

// holds a slice of type define_alias
type DefineAlias_Slice []DefineAlias

// implements typeinfo.Instance
func (*DefineAlias_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAlias
}

// implements typeinfo.Repeats
func (op *DefineAlias_Slice) Repeats() bool {
	return len(*op) > 0
}

// starts a parser scanner.
type DefineLeadingGrammar struct {
	Lede   []string
	Scans  []grammar.ScannerMaker
	Markup map[string]any
}

// define_leading_grammar, a type of flow.
var Zt_DefineLeadingGrammar typeinfo.Flow

// implements typeinfo.Instance
func (*DefineLeadingGrammar) TypeInfo() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// implements typeinfo.Markup
func (op *DefineLeadingGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineLeadingGrammar)(nil)

// holds a slice of type define_leading_grammar
type DefineLeadingGrammar_Slice []DefineLeadingGrammar

// implements typeinfo.Instance
func (*DefineLeadingGrammar_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// implements typeinfo.Repeats
func (op *DefineLeadingGrammar_Slice) Repeats() bool {
	return len(*op) > 0
}

// starts a parser scanner.
type DefineNamedGrammar struct {
	Name   string
	Scans  []grammar.ScannerMaker
	Markup map[string]any
}

// define_named_grammar, a type of flow.
var Zt_DefineNamedGrammar typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNamedGrammar) TypeInfo() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// implements typeinfo.Markup
func (op *DefineNamedGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNamedGrammar)(nil)

// holds a slice of type define_named_grammar
type DefineNamedGrammar_Slice []DefineNamedGrammar

// implements typeinfo.Instance
func (*DefineNamedGrammar_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// implements typeinfo.Repeats
func (op *DefineNamedGrammar_Slice) Repeats() bool {
	return len(*op) > 0
}

// Simple english like definitions of nouns, kinds, and their relatives.
type DeclareStatement struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// declare_statement, a type of flow.
var Zt_DeclareStatement typeinfo.Flow

// implements typeinfo.Instance
func (*DeclareStatement) TypeInfo() typeinfo.T {
	return &Zt_DeclareStatement
}

// implements typeinfo.Markup
func (op *DeclareStatement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DeclareStatement)(nil)

// holds a slice of type declare_statement
type DeclareStatement_Slice []DeclareStatement

// implements typeinfo.Instance
func (*DeclareStatement_Slice) TypeInfo() typeinfo.T {
	return &Zt_DeclareStatement
}

// implements typeinfo.Repeats
func (op *DeclareStatement_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineRelation struct {
	Relation    rtti.TextEval
	Kind        rtti.TextEval
	OtherKind   rtti.TextEval
	Cardinality RelationCardinality
	Markup      map[string]any
}

// define_relation, a type of flow.
var Zt_DefineRelation typeinfo.Flow

// implements typeinfo.Instance
func (*DefineRelation) TypeInfo() typeinfo.T {
	return &Zt_DefineRelation
}

// implements typeinfo.Markup
func (op *DefineRelation) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineRelation)(nil)

// holds a slice of type define_relation
type DefineRelation_Slice []DefineRelation

// implements typeinfo.Instance
func (*DefineRelation_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRelation
}

// implements typeinfo.Repeats
func (op *DefineRelation_Slice) Repeats() bool {
	return len(*op) > 0
}

// Add properties to a kind
type DefineFields struct {
	Kind   rtti.TextEval
	Fields []FieldDefinition
	Markup map[string]any
}

// define_fields, a type of flow.
var Zt_DefineFields typeinfo.Flow

// implements typeinfo.Instance
func (*DefineFields) TypeInfo() typeinfo.T {
	return &Zt_DefineFields
}

// implements typeinfo.Markup
func (op *DefineFields) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineFields)(nil)

// holds a slice of type define_fields
type DefineFields_Slice []DefineFields

// implements typeinfo.Instance
func (*DefineFields_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineFields
}

// implements typeinfo.Repeats
func (op *DefineFields_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineKinds struct {
	Kinds    rtti.TextListEval
	Ancestor rtti.TextEval
	Markup   map[string]any
}

// define_kinds, a type of flow.
var Zt_DefineKinds typeinfo.Flow

// implements typeinfo.Instance
func (*DefineKinds) TypeInfo() typeinfo.T {
	return &Zt_DefineKinds
}

// implements typeinfo.Markup
func (op *DefineKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineKinds)(nil)

// holds a slice of type define_kinds
type DefineKinds_Slice []DefineKinds

// implements typeinfo.Instance
func (*DefineKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineKinds
}

// implements typeinfo.Repeats
func (op *DefineKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

// Plurals are used at runtime and during weave to
// guide the interpretation of nouns and kinds.
// For example:
// "The plural of person is people."
// "The plural of person is persons."
type DefinePlural struct {
	Singular rtti.TextEval
	Plural   rtti.TextEval
	Markup   map[string]any
}

// define_plural, a type of flow.
var Zt_DefinePlural typeinfo.Flow

// implements typeinfo.Instance
func (*DefinePlural) TypeInfo() typeinfo.T {
	return &Zt_DefinePlural
}

// implements typeinfo.Markup
func (op *DefinePlural) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePlural)(nil)

// holds a slice of type define_plural
type DefinePlural_Slice []DefinePlural

// implements typeinfo.Instance
func (*DefinePlural_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePlural
}

// implements typeinfo.Repeats
func (op *DefinePlural_Slice) Repeats() bool {
	return len(*op) > 0
}

// Assign a starting value to the field of one or nouns.
type DefineValue struct {
	FieldName rtti.TextEval
	Nouns     rtti.TextListEval
	Value     rtti.Assignment
	Markup    map[string]any
}

// define_value, a type of flow.
var Zt_DefineValue typeinfo.Flow

// implements typeinfo.Instance
func (*DefineValue) TypeInfo() typeinfo.T {
	return &Zt_DefineValue
}

// implements typeinfo.Markup
func (op *DefineValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineValue)(nil)

// holds a slice of type define_value
type DefineValue_Slice []DefineValue

// implements typeinfo.Instance
func (*DefineValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineValue
}

// implements typeinfo.Repeats
func (op *DefineValue_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineNouns struct {
	Nouns  rtti.TextListEval
	Kind   rtti.TextEval
	Markup map[string]any
}

// define_nouns, a type of flow.
var Zt_DefineNouns typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNouns) TypeInfo() typeinfo.T {
	return &Zt_DefineNouns
}

// implements typeinfo.Markup
func (op *DefineNouns) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNouns)(nil)

// holds a slice of type define_nouns
type DefineNouns_Slice []DefineNouns

// implements typeinfo.Instance
func (*DefineNouns_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNouns
}

// implements typeinfo.Repeats
func (op *DefineNouns_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineNounTraits struct {
	Nouns  rtti.TextListEval
	Traits rtti.TextListEval
	Markup map[string]any
}

// define_noun_traits, a type of flow.
var Zt_DefineNounTraits typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNounTraits) TypeInfo() typeinfo.T {
	return &Zt_DefineNounTraits
}

// implements typeinfo.Markup
func (op *DefineNounTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNounTraits)(nil)

// holds a slice of type define_noun_traits
type DefineNounTraits_Slice []DefineNounTraits

// implements typeinfo.Instance
func (*DefineNounTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounTraits
}

// implements typeinfo.Repeats
func (op *DefineNounTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

type NumListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.NumListEval
	Markup    map[string]any
}

// num_list_field, a type of flow.
var Zt_NumListField typeinfo.Flow

// implements typeinfo.Instance
func (*NumListField) TypeInfo() typeinfo.T {
	return &Zt_NumListField
}

// implements typeinfo.Markup
func (op *NumListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NumListField)(nil)

// holds a slice of type num_list_field
type NumListField_Slice []NumListField

// implements typeinfo.Instance
func (*NumListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NumListField
}

// implements typeinfo.Repeats
func (op *NumListField_Slice) Repeats() bool {
	return len(*op) > 0
}

type NumberField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.NumberEval
	Markup    map[string]any
}

// number_field, a type of flow.
var Zt_NumberField typeinfo.Flow

// implements typeinfo.Instance
func (*NumberField) TypeInfo() typeinfo.T {
	return &Zt_NumberField
}

// implements typeinfo.Markup
func (op *NumberField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NumberField)(nil)

// holds a slice of type number_field
type NumberField_Slice []NumberField

// implements typeinfo.Instance
func (*NumberField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NumberField
}

// implements typeinfo.Repeats
func (op *NumberField_Slice) Repeats() bool {
	return len(*op) > 0
}

type RuleProvides struct {
	PatternName rtti.TextEval
	Provides    []FieldDefinition
	Markup      map[string]any
}

// rule_provides, a type of flow.
var Zt_RuleProvides typeinfo.Flow

// implements typeinfo.Instance
func (*RuleProvides) TypeInfo() typeinfo.T {
	return &Zt_RuleProvides
}

// implements typeinfo.Markup
func (op *RuleProvides) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleProvides)(nil)

// holds a slice of type rule_provides
type RuleProvides_Slice []RuleProvides

// implements typeinfo.Instance
func (*RuleProvides_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleProvides
}

// implements typeinfo.Repeats
func (op *RuleProvides_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change the behavior of an existing pattern.
// For events, this adds a listener that responds to the targeted object only when triggered by the player.
// By default, rules with filters continue on to the next rule automatically.
// Because event listeners have filters they continue to the next listener unless specifically stopped.
type RuleForPattern struct {
	PatternName rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_pattern, a type of flow.
var Zt_RuleForPattern typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForPattern) TypeInfo() typeinfo.T {
	return &Zt_RuleForPattern
}

// implements typeinfo.Markup
func (op *RuleForPattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForPattern)(nil)

// holds a slice of type rule_for_pattern
type RuleForPattern_Slice []RuleForPattern

// implements typeinfo.Instance
func (*RuleForPattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForPattern
}

// implements typeinfo.Repeats
func (op *RuleForPattern_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change the behavior of an existing pattern.
// The default behavior for events is to fall through to the next handler unless canceled or stopped.
type RuleForNoun struct {
	PatternName rtti.TextEval
	NounName    rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_noun, a type of flow.
var Zt_RuleForNoun typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForNoun) TypeInfo() typeinfo.T {
	return &Zt_RuleForNoun
}

// implements typeinfo.Markup
func (op *RuleForNoun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForNoun)(nil)

// holds a slice of type rule_for_noun
type RuleForNoun_Slice []RuleForNoun

// implements typeinfo.Instance
func (*RuleForNoun_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForNoun
}

// implements typeinfo.Repeats
func (op *RuleForNoun_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change the behavior of an existing pattern.
// The default behavior for events is to fall through to the next handler unless canceled or stopped.
type RuleForKind struct {
	PatternName rtti.TextEval
	KindName    rtti.TextEval
	Exactly     rtti.BoolEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_kind, a type of flow.
var Zt_RuleForKind typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForKind) TypeInfo() typeinfo.T {
	return &Zt_RuleForKind
}

// implements typeinfo.Markup
func (op *RuleForKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForKind)(nil)

// holds a slice of type rule_for_kind
type RuleForKind_Slice []RuleForKind

// implements typeinfo.Instance
func (*RuleForKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForKind
}

// implements typeinfo.Repeats
func (op *RuleForKind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Declare a new pattern.
// A pattern is a bundle of functions which can either change the game world or provide information about it.
// Each function in a given pattern has "guards" which determine whether the function applies in a particular situation.
type DefinePattern struct {
	PatternName rtti.TextEval
	Requires    []FieldDefinition
	Provides    []FieldDefinition
	Exe         []rtti.Execute
	Markup      map[string]any
}

// define_pattern, a type of flow.
var Zt_DefinePattern typeinfo.Flow

// implements typeinfo.Instance
func (*DefinePattern) TypeInfo() typeinfo.T {
	return &Zt_DefinePattern
}

// implements typeinfo.Markup
func (op *DefinePattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePattern)(nil)

// holds a slice of type define_pattern
type DefinePattern_Slice []DefinePattern

// implements typeinfo.Instance
func (*DefinePattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePattern
}

// implements typeinfo.Repeats
func (op *DefinePattern_Slice) Repeats() bool {
	return len(*op) > 0
}

type RecordListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.RecordListEval
	Markup    map[string]any
}

// record_list_field, a type of flow.
var Zt_RecordListField typeinfo.Flow

// implements typeinfo.Instance
func (*RecordListField) TypeInfo() typeinfo.T {
	return &Zt_RecordListField
}

// implements typeinfo.Markup
func (op *RecordListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*RecordListField)(nil)

// holds a slice of type record_list_field
type RecordListField_Slice []RecordListField

// implements typeinfo.Instance
func (*RecordListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordListField
}

// implements typeinfo.Repeats
func (op *RecordListField_Slice) Repeats() bool {
	return len(*op) > 0
}

type RecordField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.RecordEval
	Markup    map[string]any
}

// record_field, a type of flow.
var Zt_RecordField typeinfo.Flow

// implements typeinfo.Instance
func (*RecordField) TypeInfo() typeinfo.T {
	return &Zt_RecordField
}

// implements typeinfo.Markup
func (op *RecordField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*RecordField)(nil)

// holds a slice of type record_field
type RecordField_Slice []RecordField

// implements typeinfo.Instance
func (*RecordField_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordField
}

// implements typeinfo.Repeats
func (op *RecordField_Slice) Repeats() bool {
	return len(*op) > 0
}

// Relate nouns to each other
type DefineRelatives struct {
	Nouns      rtti.TextListEval
	Relation   rtti.TextEval
	OtherNouns rtti.TextListEval
	Markup     map[string]any
}

// define_relatives, a type of flow.
var Zt_DefineRelatives typeinfo.Flow

// implements typeinfo.Instance
func (*DefineRelatives) TypeInfo() typeinfo.T {
	return &Zt_DefineRelatives
}

// implements typeinfo.Markup
func (op *DefineRelatives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineRelatives)(nil)

// holds a slice of type define_relatives
type DefineRelatives_Slice []DefineRelatives

// implements typeinfo.Instance
func (*DefineRelatives_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRelatives
}

// implements typeinfo.Repeats
func (op *DefineRelatives_Slice) Repeats() bool {
	return len(*op) > 0
}

// Relate nouns to each other
type DefineOtherRelatives struct {
	Relation   rtti.TextEval
	Nouns      rtti.TextListEval
	OtherNouns rtti.TextListEval
	Markup     map[string]any
}

// define_other_relatives, a type of flow.
var Zt_DefineOtherRelatives typeinfo.Flow

// implements typeinfo.Instance
func (*DefineOtherRelatives) TypeInfo() typeinfo.T {
	return &Zt_DefineOtherRelatives
}

// implements typeinfo.Markup
func (op *DefineOtherRelatives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineOtherRelatives)(nil)

// holds a slice of type define_other_relatives
type DefineOtherRelatives_Slice []DefineOtherRelatives

// implements typeinfo.Instance
func (*DefineOtherRelatives_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineOtherRelatives
}

// implements typeinfo.Repeats
func (op *DefineOtherRelatives_Slice) Repeats() bool {
	return len(*op) > 0
}

// Used for displaying text to the player.
// The text can contain 'inline-templates';
// mini-commands that help to simplify printing text.
// See also: https://github.com/ionous/iffy/wiki/Templates.
// ( note: this is transformed for the runtime into an unnamed 'RenderResponse'. )
type SayTemplate struct {
	Template string
	Markup   map[string]any
}

// say_template, a type of flow.
var Zt_SayTemplate typeinfo.Flow

// implements typeinfo.Instance
func (*SayTemplate) TypeInfo() typeinfo.T {
	return &Zt_SayTemplate
}

// implements typeinfo.Markup
func (op *SayTemplate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*SayTemplate)(nil)
var _ rtti.TextEval = (*SayTemplate)(nil)

// holds a slice of type say_template
type SayTemplate_Slice []SayTemplate

// implements typeinfo.Instance
func (*SayTemplate_Slice) TypeInfo() typeinfo.T {
	return &Zt_SayTemplate
}

// implements typeinfo.Repeats
func (op *SayTemplate_Slice) Repeats() bool {
	return len(*op) > 0
}

// Generate text in a replaceable manner.
// ( note: this is transformed for the runtime into a named 'RenderResponse'. )
type SayResponse struct {
	Name   string
	Text   rtti.TextEval
	Markup map[string]any
}

// say_response, a type of flow.
var Zt_SayResponse typeinfo.Flow

// implements typeinfo.Instance
func (*SayResponse) TypeInfo() typeinfo.T {
	return &Zt_SayResponse
}

// implements typeinfo.Markup
func (op *SayResponse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*SayResponse)(nil)
var _ rtti.TextEval = (*SayResponse)(nil)

// holds a slice of type say_response
type SayResponse_Slice []SayResponse

// implements typeinfo.Instance
func (*SayResponse_Slice) TypeInfo() typeinfo.T {
	return &Zt_SayResponse
}

// implements typeinfo.Repeats
func (op *SayResponse_Slice) Repeats() bool {
	return len(*op) > 0
}

// When called multiple times returns its inputs at random.
type ShuffleText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// shuffle_text, a type of flow.
var Zt_ShuffleText typeinfo.Flow

// implements typeinfo.Instance
func (*ShuffleText) TypeInfo() typeinfo.T {
	return &Zt_ShuffleText
}

// implements typeinfo.Markup
func (op *ShuffleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*ShuffleText)(nil)

// holds a slice of type shuffle_text
type ShuffleText_Slice []ShuffleText

// implements typeinfo.Instance
func (*ShuffleText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ShuffleText
}

// implements typeinfo.Repeats
func (op *ShuffleText_Slice) Repeats() bool {
	return len(*op) > 0
}

// When called multiple times returns each of its inputs in turn, sticking to the last one.
type StoppingText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// stopping_text, a type of flow.
var Zt_StoppingText typeinfo.Flow

// implements typeinfo.Instance
func (*StoppingText) TypeInfo() typeinfo.T {
	return &Zt_StoppingText
}

// implements typeinfo.Markup
func (op *StoppingText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*StoppingText)(nil)

// holds a slice of type stopping_text
type StoppingText_Slice []StoppingText

// implements typeinfo.Instance
func (*StoppingText_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoppingText
}

// implements typeinfo.Repeats
func (op *StoppingText_Slice) Repeats() bool {
	return len(*op) > 0
}

// a command with a signature of the comment marker metadata.
// a cheat to allows nodes that have only a comment marker and no actual command.
// see also: debug.do_nothing
type StoryBreak struct {
	Markup map[string]any
}

// story_break, a type of flow.
var Zt_StoryBreak typeinfo.Flow

// implements typeinfo.Instance
func (*StoryBreak) TypeInfo() typeinfo.T {
	return &Zt_StoryBreak
}

// implements typeinfo.Markup
func (op *StoryBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*StoryBreak)(nil)

// holds a slice of type story_break
type StoryBreak_Slice []StoryBreak

// implements typeinfo.Instance
func (*StoryBreak_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoryBreak
}

// implements typeinfo.Repeats
func (op *StoryBreak_Slice) Repeats() bool {
	return len(*op) > 0
}

// top level node, currently just for blockly might eventually contain story metadata  ex. author, description...
type StoryFile struct {
	Statements []StoryStatement
	Markup     map[string]any
}

// story_file, a type of flow.
var Zt_StoryFile typeinfo.Flow

// implements typeinfo.Instance
func (*StoryFile) TypeInfo() typeinfo.T {
	return &Zt_StoryFile
}

// implements typeinfo.Markup
func (op *StoryFile) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type story_file
type StoryFile_Slice []StoryFile

// implements typeinfo.Instance
func (*StoryFile_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoryFile
}

// implements typeinfo.Repeats
func (op *StoryFile_Slice) Repeats() bool {
	return len(*op) > 0
}

type TextListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.TextListEval
	Markup    map[string]any
}

// text_list_field, a type of flow.
var Zt_TextListField typeinfo.Flow

// implements typeinfo.Instance
func (*TextListField) TypeInfo() typeinfo.T {
	return &Zt_TextListField
}

// implements typeinfo.Markup
func (op *TextListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*TextListField)(nil)

// holds a slice of type text_list_field
type TextListField_Slice []TextListField

// implements typeinfo.Instance
func (*TextListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextListField
}

// implements typeinfo.Repeats
func (op *TextListField_Slice) Repeats() bool {
	return len(*op) > 0
}

type TextField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.TextEval
	Markup    map[string]any
}

// text_field, a type of flow.
var Zt_TextField typeinfo.Flow

// implements typeinfo.Instance
func (*TextField) TypeInfo() typeinfo.T {
	return &Zt_TextField
}

// implements typeinfo.Markup
func (op *TextField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*TextField)(nil)

// holds a slice of type text_field
type TextField_Slice []TextField

// implements typeinfo.Instance
func (*TextField_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextField
}

// implements typeinfo.Repeats
func (op *TextField_Slice) Repeats() bool {
	return len(*op) > 0
}

// A valueless field.
// Intended mainly for patterns which don't need to return a value.
type NothingField struct {
	Markup map[string]any
}

// nothing_field, a type of flow.
var Zt_NothingField typeinfo.Flow

// implements typeinfo.Instance
func (*NothingField) TypeInfo() typeinfo.T {
	return &Zt_NothingField
}

// implements typeinfo.Markup
func (op *NothingField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NothingField)(nil)

// holds a slice of type nothing_field
type NothingField_Slice []NothingField

// implements typeinfo.Instance
func (*NothingField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NothingField
}

// implements typeinfo.Repeats
func (op *NothingField_Slice) Repeats() bool {
	return len(*op) > 0
}

// RelationCardinality, a type of str enum.
type RelationCardinality int

// enumerated values of RelationCardinality
const (
	C_RelationCardinality_OneToOne RelationCardinality = iota
	C_RelationCardinality_OneToMany
	C_RelationCardinality_ManyToOne
	C_RelationCardinality_ManyToMany
)

func MakeRelationCardinality(str string) (ret RelationCardinality, okay bool) {
	if i := Zt_RelationCardinality.FindOption(str); i >= 0 {
		ret, okay = RelationCardinality(i), true
	}
	return
}

func (op RelationCardinality) String() (ret string) {
	if i, opts := int(op), Zt_RelationCardinality.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid RelationCardinality(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// relation_cardinality, a type of str enum.
var Zt_RelationCardinality = typeinfo.Str{
	Name: "relation_cardinality",
	Options: []string{
		"one_to_one",
		"one_to_many",
		"many_to_one",
		"many_to_many",
	},
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "story",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_FieldDefinition,
	&Zt_StoryStatement,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Comment,
	&Zt_DefineTest,
	&Zt_DefineScene,
	&Zt_DefineAction,
	&Zt_DefineAspect,
	&Zt_AspectField,
	&Zt_BoolField,
	&Zt_CountOf,
	&Zt_CycleText,
	&Zt_DefineAlias,
	&Zt_DefineLeadingGrammar,
	&Zt_DefineNamedGrammar,
	&Zt_DeclareStatement,
	&Zt_DefineRelation,
	&Zt_DefineFields,
	&Zt_DefineKinds,
	&Zt_DefinePlural,
	&Zt_DefineValue,
	&Zt_DefineNouns,
	&Zt_DefineNounTraits,
	&Zt_NumListField,
	&Zt_NumberField,
	&Zt_RuleProvides,
	&Zt_RuleForPattern,
	&Zt_RuleForNoun,
	&Zt_RuleForKind,
	&Zt_DefinePattern,
	&Zt_RecordListField,
	&Zt_RecordField,
	&Zt_DefineRelatives,
	&Zt_DefineOtherRelatives,
	&Zt_SayTemplate,
	&Zt_SayResponse,
	&Zt_ShuffleText,
	&Zt_StoppingText,
	&Zt_StoryBreak,
	&Zt_StoryFile,
	&Zt_TextListField,
	&Zt_TextField,
	&Zt_NothingField,
}

// a list of all strs in this this package
var z_str_list = []*typeinfo.Str{
	&Zt_RelationCardinality,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	5991962903091297123:  (*StoryFile)(nil),            /* Tapestry: */
	4360765066804052293:  (*StoryBreak)(nil),           /* story_statement=-- */
	13010292396640781698: (*AspectField)(nil),          /* field_definition=Aspect: */
	12738236274201716794: (*BoolField)(nil),            /* field_definition=Bool: */
	18077675806901364237: (*BoolField)(nil),            /* field_definition=Bool:initially: */
	17184788623765734642: (*BoolField)(nil),            /* field_definition=Bool:kind: */
	124015053883609573:   (*BoolField)(nil),            /* field_definition=Bool:kind:initially: */
	3991849378064754806:  (*Comment)(nil),              /* execute=Comment: */
	16586092333187989882: (*Comment)(nil),              /* story_statement=Comment: */
	10143132576483224253: (*CountOf)(nil),              /* bool_eval=CountOf:num: */
	231398832069830353:   (*CycleText)(nil),            /* text_eval=CycleText: */
	9796202271034753943:  (*DeclareStatement)(nil),     /* story_statement=Declare: */
	14790755516297707674: (*DefineAction)(nil),         /* story_statement=Define action:requires: */
	5312053119535959994:  (*DefineAction)(nil),         /* story_statement=Define action:requires:provides: */
	4679255645834546435:  (*DefineAspect)(nil),         /* story_statement=Define aspect:traits: */
	15268150405724581221: (*DefineFields)(nil),         /* story_statement=Define kind:fields: */
	11622379079031968031: (*DefineKinds)(nil),          /* story_statement=Define kinds:as: */
	7397461044941158073:  (*DefineNouns)(nil),          /* story_statement=Define nouns:as: */
	7383237871303366677:  (*DefineRelatives)(nil),      /* story_statement=Define nouns:relativeTo:otherNouns: */
	15794171433650329114: (*DefineNounTraits)(nil),     /* story_statement=Define nouns:traits: */
	14040325709851010602: (*DefinePattern)(nil),        /* story_statement=Define pattern:requires:provides: */
	729326910659609567:   (*DefinePattern)(nil),        /* story_statement=Define pattern:requires:provides:do: */
	15951965898335032430: (*DefineRelation)(nil),       /* story_statement=Define relation:kind:otherKind:cardinality: */
	16389453623741136831: (*DefineOtherRelatives)(nil), /* story_statement=Define relativeTo:nouns:otherNouns: */
	18093984368234904277: (*RuleForPattern)(nil),       /* story_statement=Define rule:do: */
	12136992210577308757: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:do: */
	10538385905361340595: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:exactly:do: */
	11666026550766211860: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:exactly:named:do: */
	2951940010570883790:  (*RuleForKind)(nil),          /* story_statement=Define rule:kind:named:do: */
	2007307886252117326:  (*RuleForPattern)(nil),       /* story_statement=Define rule:named:do: */
	4344965134492972319:  (*RuleForNoun)(nil),          /* story_statement=Define rule:noun:do: */
	16133739979148445504: (*RuleForNoun)(nil),          /* story_statement=Define rule:noun:named:do: */
	8031356368944964156:  (*RuleProvides)(nil),         /* story_statement=Define rule:provides: */
	16728157364207612750: (*DefineScene)(nil),          /* story_statement=Define scene: */
	10681959011863226668: (*DefineScene)(nil),          /* story_statement=Define scene:requires: */
	10209709135447127962: (*DefineScene)(nil),          /* story_statement=Define scene:requires:with: */
	13479298094295759568: (*DefineScene)(nil),          /* story_statement=Define scene:with: */
	1798652288281835623:  (*DefinePlural)(nil),         /* story_statement=Define singular:plural: */
	12489141410311466071: (*DefineTest)(nil),           /* story_statement=Define test:do: */
	3712030102885900665:  (*DefineTest)(nil),           /* story_statement=Define test:requires:do: */
	16978239348269462739: (*DefineTest)(nil),           /* story_statement=Define test:requires:scene:do: */
	13333326165932249009: (*DefineTest)(nil),           /* story_statement=Define test:scene:do: */
	17805855959213202620: (*DefineValue)(nil),          /* story_statement=Define value:of:as: */
	12975771225654832812: (*DefineAlias)(nil),          /* story_statement=Interpret alias:as: */
	8001652437005351387:  (*DefineNamedGrammar)(nil),   /* story_statement=Interpret name:with: */
	6001249499689096432:  (*DefineLeadingGrammar)(nil), /* story_statement=Interpret:with: */
	14427731589588473385: (*NothingField)(nil),         /* field_definition=Nothing */
	10299801658819864730: (*NumListField)(nil),         /* field_definition=NumList: */
	12762197545337845485: (*NumListField)(nil),         /* field_definition=NumList:initially: */
	2289982379805608146:  (*NumListField)(nil),         /* field_definition=NumList:kind: */
	223049567122462661:   (*NumListField)(nil),         /* field_definition=NumList:kind:initially: */
	16579038690333872565: (*NumberField)(nil),          /* field_definition=Number: */
	7599754526096278866:  (*NumberField)(nil),          /* field_definition=Number:initially: */
	13275028962550729195: (*NumberField)(nil),          /* field_definition=Number:kind: */
	8920589511475179656:  (*NumberField)(nil),          /* field_definition=Number:kind:initially: */
	7896413305974623897:  (*RecordField)(nil),          /* field_definition=Record: */
	9030081498362006310:  (*RecordField)(nil),          /* field_definition=Record:initially: */
	7215961239288768263:  (*RecordField)(nil),          /* field_definition=Record:kind: */
	8334583613109868292:  (*RecordField)(nil),          /* field_definition=Record:kind:initially: */
	3705957996596149197:  (*RecordListField)(nil),      /* field_definition=RecordList: */
	5153309692795646250:  (*RecordListField)(nil),      /* field_definition=RecordList:initially: */
	15479801779125468947: (*RecordListField)(nil),      /* field_definition=RecordList:kind: */
	17384295137903978384: (*RecordListField)(nil),      /* field_definition=RecordList:kind:initially: */
	12945074305202371477: (*SayResponse)(nil),          /* execute=Say response:with: */
	7921553818502082370:  (*SayResponse)(nil),          /* text_eval=Say response:with: */
	9556993961571292952:  (*SayTemplate)(nil),          /* execute=Say: */
	15989777734244204735: (*SayTemplate)(nil),          /* text_eval=Say: */
	9910951906340888308:  (*ShuffleText)(nil),          /* text_eval=ShuffleText: */
	13921723804355948971: (*StoppingText)(nil),         /* text_eval=StoppingText: */
	9387832592330456403:  (*TextField)(nil),            /* field_definition=Text: */
	16637694412733787472: (*TextField)(nil),            /* field_definition=Text:initially: */
	15791809714384972761: (*TextField)(nil),            /* field_definition=Text:kind: */
	16917317465644840422: (*TextField)(nil),            /* field_definition=Text:kind:initially: */
	3830912410254339707:  (*TextListField)(nil),        /* field_definition=TextList: */
	15743255383721832504: (*TextListField)(nil),        /* field_definition=TextList:initially: */
	2011197685129757745:  (*TextListField)(nil),        /* field_definition=TextList:kind: */
	3232692879001227038:  (*TextListField)(nil),        /* field_definition=TextList:kind:initially: */
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Comment = typeinfo.Flow{
		Name: "comment",
		Lede: "comment",
		Terms: []typeinfo.Term{{
			Name: "lines",
			Type: &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Add a note.", "Information about the story for you and other authors."},
		},
	}
	Zt_DefineTest = typeinfo.Flow{
		Name: "define_test",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "test_name",
			Label: "test",
			Type:  &prim.Zt_Text,
		}, {
			Name:     "require_scenes",
			Label:    "requires",
			Optional: true,
			Type:     &rtti.Zt_TextListEval,
		}, {
			Name:     "statements",
			Label:    "scene",
			Optional: true,
			Repeats:  true,
			Type:     &Zt_StoryStatement,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Create a scene",
		},
	}
	Zt_DefineScene = typeinfo.Flow{
		Name: "define_scene",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "scene",
			Label: "scene",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "require_scenes",
			Label:    "requires",
			Optional: true,
			Type:     &rtti.Zt_TextListEval,
		}, {
			Name:     "statements",
			Label:    "with",
			Optional: true,
			Repeats:  true,
			Type:     &Zt_StoryStatement,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Define a sub world.",
		},
	}
	Zt_DefineAction = typeinfo.Flow{
		Name: "define_action",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "action",
			Label: "action",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:     "provides",
			Label:    "provides",
			Optional: true,
			Repeats:  true,
			Type:     &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Declare an activity: Activities help actors perform tasks: for instance, picking up or dropping items.  Activities involve either the player or an npc and possibly one or two other objects.",
		},
	}
	Zt_DefineAspect = typeinfo.Flow{
		Name: "define_aspect",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "aspect",
			Label: "aspect",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Declare an aspect and its traits.", "Aspects here are assumed to be singularly named."},
		},
	}
	Zt_AspectField = typeinfo.Flow{
		Name: "aspect_field",
		Lede: "aspect",
		Terms: []typeinfo.Term{{
			Name: "aspect",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"tbd: is a separate interface required for object kinds separate from everything else?", "in theory, generic.Kind supports fields of type aspect... but i'm not sure weave handles that."},
		},
	}
	Zt_BoolField = typeinfo.Flow{
		Name: "bool_field",
		Lede: "bool",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_CountOf = typeinfo.Flow{
		Name: "count_of",
		Lede: "count_of",
		Terms: []typeinfo.Term{{
			Name: "trigger",
			Type: &core.Zt_Trigger,
		}, {
			Name:  "num",
			Label: "num",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A guard which returns true based on a counter.", "Counters start at zero and are incremented every time the guard gets checked."},
		},
	}
	Zt_CycleText = typeinfo.Flow{
		Name: "cycle_text",
		Lede: "cycle_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "When called multiple times, returns each of its inputs in turn.",
		},
	}
	Zt_DefineAlias = typeinfo.Flow{
		Name: "define_alias",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "alias",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "noun_name",
			Label: "as",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "allows the player to refer to a noun by one or more other terms.",
		},
	}
	Zt_DefineLeadingGrammar = typeinfo.Flow{
		Name: "define_leading_grammar",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:    "lede",
			Repeats: true,
			Type:    &prim.Zt_Text,
		}, {
			Name:    "scans",
			Label:   "with",
			Repeats: true,
			Type:    &grammar.Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "starts a parser scanner.",
		},
	}
	Zt_DefineNamedGrammar = typeinfo.Flow{
		Name: "define_named_grammar",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "name",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "scans",
			Label:   "with",
			Repeats: true,
			Type:    &grammar.Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "starts a parser scanner.",
		},
	}
	Zt_DeclareStatement = typeinfo.Flow{
		Name: "declare_statement",
		Lede: "declare",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Simple english like definitions of nouns, kinds, and their relatives.",
		},
	}
	Zt_DefineRelation = typeinfo.Flow{
		Name: "define_relation",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "relation",
			Label: "relation",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "other_kind",
			Label: "other_kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "cardinality",
			Label: "cardinality",
			Type:  &Zt_RelationCardinality,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
	}
	Zt_DefineFields = typeinfo.Flow{
		Name: "define_fields",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "fields",
			Label:   "fields",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Add properties to a kind",
		},
	}
	Zt_DefineKinds = typeinfo.Flow{
		Name: "define_kinds",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kinds",
			Label: "kinds",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "ancestor",
			Label: "as",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
	}
	Zt_DefinePlural = typeinfo.Flow{
		Name: "define_plural",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "singular",
			Label: "singular",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "plural",
			Label: "plural",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Plurals are used at runtime and during weave to", "guide the interpretation of nouns and kinds.", "For example:", "\"The plural of person is people.\"", "\"The plural of person is persons.\""},
		},
	}
	Zt_DefineValue = typeinfo.Flow{
		Name: "define_value",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "field_name",
			Label: "value",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "nouns",
			Label: "of",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "value",
			Label: "as",
			Type:  &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Assign a starting value to the field of one or nouns.",
		},
	}
	Zt_DefineNouns = typeinfo.Flow{
		Name: "define_nouns",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "nouns",
			Label: "nouns",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "kind",
			Label: "as",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
	}
	Zt_DefineNounTraits = typeinfo.Flow{
		Name: "define_noun_traits",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "nouns",
			Label: "nouns",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
	}
	Zt_NumListField = typeinfo.Flow{
		Name: "num_list_field",
		Lede: "num_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_NumListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_NumberField = typeinfo.Flow{
		Name: "number_field",
		Lede: "number",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_RuleProvides = typeinfo.Flow{
		Name: "rule_provides",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
	}
	Zt_RuleForPattern = typeinfo.Flow{
		Name: "rule_for_pattern",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "For events, this adds a listener that responds to the targeted object only when triggered by the player.", "By default, rules with filters continue on to the next rule automatically.", "Because event listeners have filters they continue to the next listener unless specifically stopped."},
		},
	}
	Zt_RuleForNoun = typeinfo.Flow{
		Name: "rule_for_noun",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "noun_name",
			Label: "noun",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "The default behavior for events is to fall through to the next handler unless canceled or stopped."},
		},
	}
	Zt_RuleForKind = typeinfo.Flow{
		Name: "rule_for_kind",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "kind_name",
			Label: "kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "exactly",
			Label:    "exactly",
			Optional: true,
			Type:     &rtti.Zt_BoolEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "The default behavior for events is to fall through to the next handler unless canceled or stopped."},
		},
	}
	Zt_DefinePattern = typeinfo.Flow{
		Name: "define_pattern",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "pattern",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:     "exe",
			Label:    "do",
			Optional: true,
			Repeats:  true,
			Type:     &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Declare a new pattern.", "A pattern is a bundle of functions which can either change the game world or provide information about it.", "Each function in a given pattern has \"guards\" which determine whether the function applies in a particular situation."},
		},
	}
	Zt_RecordListField = typeinfo.Flow{
		Name: "record_list_field",
		Lede: "record_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_RecordListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_RecordField = typeinfo.Flow{
		Name: "record_field",
		Lede: "record",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_RecordEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_DefineRelatives = typeinfo.Flow{
		Name: "define_relatives",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "nouns",
			Label: "nouns",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "relation",
			Label: "relative_to",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "other_nouns",
			Label: "other_nouns",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Relate nouns to each other",
		},
	}
	Zt_DefineOtherRelatives = typeinfo.Flow{
		Name: "define_other_relatives",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "relation",
			Label: "relative_to",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "nouns",
			Label: "nouns",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "other_nouns",
			Label: "other_nouns",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Relate nouns to each other",
		},
	}
	Zt_SayTemplate = typeinfo.Flow{
		Name: "say_template",
		Lede: "say",
		Terms: []typeinfo.Term{{
			Name: "template",
			Type: &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Used for displaying text to the player.", "The text can contain 'inline-templates';", "mini-commands that help to simplify printing text.", "See also: https://github.com/ionous/iffy/wiki/Templates.", "( note: this is transformed for the runtime into an unnamed 'RenderResponse'. )"},
		},
	}
	Zt_SayResponse = typeinfo.Flow{
		Name: "say_response",
		Lede: "say",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "response",
			Type:  &prim.Zt_Text,
		}, {
			Name:  "text",
			Label: "with",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Generate text in a replaceable manner.", "( note: this is transformed for the runtime into a named 'RenderResponse'. )"},
		},
	}
	Zt_ShuffleText = typeinfo.Flow{
		Name: "shuffle_text",
		Lede: "shuffle_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "When called multiple times returns its inputs at random.",
		},
	}
	Zt_StoppingText = typeinfo.Flow{
		Name: "stopping_text",
		Lede: "stopping_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "When called multiple times returns each of its inputs in turn, sticking to the last one.",
		},
	}
	Zt_StoryBreak = typeinfo.Flow{
		Name:  "story_break",
		Lede:  "--",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"a command with a signature of the comment marker metadata.", "a cheat to allows nodes that have only a comment marker and no actual command.", "see also: debug.do_nothing"},
		},
	}
	Zt_StoryFile = typeinfo.Flow{
		Name: "story_file",
		Lede: "tapestry",
		Terms: []typeinfo.Term{{
			Name:    "statements",
			Repeats: true,
			Type:    &Zt_StoryStatement,
		}},
		Markup: map[string]any{
			"blockly-color": "TAP_HUE_ROOT",
			"comment":       "top level node, currently just for blockly might eventually contain story metadata  ex. author, description...",
			"mosaic-root":   true,
		},
	}
	Zt_TextListField = typeinfo.Flow{
		Name: "text_list_field",
		Lede: "text_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_TextField = typeinfo.Flow{
		Name: "text_field",
		Lede: "text",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_NothingField = typeinfo.Flow{
		Name:  "nothing_field",
		Lede:  "nothing",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A valueless field.", "Intended mainly for patterns which don't need to return a value."},
		},
	}
}
