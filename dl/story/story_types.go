// Code generated by Tapestry; edit at your own risk.
package story

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/grammar"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// field_definition, a type of slot.
var Zt_FieldDefinition = typeinfo.Slot{
	Name: "field_definition",
	Markup: map[string]any{
		"comment": "Fields are used to define the members of kinds, records, patterns, and so on.",
	},
}

// holds a single slot.
type FieldDefinition_Slot struct{ Value FieldDefinition }

// implements typeinfo.Instance for a single slot.
func (*FieldDefinition_Slot) TypeInfo() typeinfo.T {
	return &Zt_FieldDefinition
}

// holds a slice of slots.
type FieldDefinition_Slots []FieldDefinition

// implements typeinfo.Instance for a series of slots.
func (*FieldDefinition_Slots) TypeInfo() typeinfo.T {
	return &Zt_FieldDefinition
}

// implements typeinfo.Repeats
func (op *FieldDefinition_Slots) Repeats() bool {
	return len(*op) > 0
}

// story_statement, a type of slot.
var Zt_StoryStatement = typeinfo.Slot{
	Name: "story_statement",
	Markup: map[string]any{
		"blockly-color": "VARIABLES_HUE",
		"blockly-stack": true,
		"comment":       "Phrase",
	},
}

// holds a single slot.
type StoryStatement_Slot struct{ Value StoryStatement }

// implements typeinfo.Instance for a single slot.
func (*StoryStatement_Slot) TypeInfo() typeinfo.T {
	return &Zt_StoryStatement
}

// holds a slice of slots.
type StoryStatement_Slots []StoryStatement

// implements typeinfo.Instance for a series of slots.
func (*StoryStatement_Slots) TypeInfo() typeinfo.T {
	return &Zt_StoryStatement
}

// implements typeinfo.Repeats
func (op *StoryStatement_Slots) Repeats() bool {
	return len(*op) > 0
}

type Comment struct {
	Lines  string
	Markup map[string]any
}

// comment, a type of flow.
var Zt_Comment typeinfo.Flow

// implements typeinfo.Instance
func (*Comment) TypeInfo() typeinfo.T {
	return &Zt_Comment
}

// implements typeinfo.Markup
func (op *Comment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*Comment)(nil)
var _ rtti.Execute = (*Comment)(nil)

// holds a slice of type comment
type Comment_Slice []Comment

// implements typeinfo.Instance
func (*Comment_Slice) TypeInfo() typeinfo.T {
	return &Zt_Comment
}

// implements typeinfo.Repeats
func (op *Comment_Slice) Repeats() bool {
	return len(*op) > 0
}

// Create a scene
type DefineTest struct {
	TestName   string
	SceneNames rtti.TextListEval
	Statements []StoryStatement
	Exe        []rtti.Execute
	Markup     map[string]any
}

// define_test, a type of flow.
var Zt_DefineTest typeinfo.Flow

// implements typeinfo.Instance
func (*DefineTest) TypeInfo() typeinfo.T {
	return &Zt_DefineTest
}

// implements typeinfo.Markup
func (op *DefineTest) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineTest)(nil)
var _ rtti.Execute = (*DefineTest)(nil)

// holds a slice of type define_test
type DefineTest_Slice []DefineTest

// implements typeinfo.Instance
func (*DefineTest_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineTest
}

// implements typeinfo.Repeats
func (op *DefineTest_Slice) Repeats() bool {
	return len(*op) > 0
}

// Define a sub world.
type DefineScene struct {
	Scene      rtti.TextEval
	SceneNames rtti.TextListEval
	With       []StoryStatement
	Markup     map[string]any
}

// define_scene, a type of flow.
var Zt_DefineScene typeinfo.Flow

// implements typeinfo.Instance
func (*DefineScene) TypeInfo() typeinfo.T {
	return &Zt_DefineScene
}

// implements typeinfo.Markup
func (op *DefineScene) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineScene)(nil)

// holds a slice of type define_scene
type DefineScene_Slice []DefineScene

// implements typeinfo.Instance
func (*DefineScene_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineScene
}

// implements typeinfo.Repeats
func (op *DefineScene_Slice) Repeats() bool {
	return len(*op) > 0
}

// Declare an activity: Activities help actors perform tasks: for instance, picking up or dropping items.  Activities involve either the player or an npc and possibly one or two other objects.
type DefineAction struct {
	Action   rtti.TextEval
	Requires []FieldDefinition
	Provides []FieldDefinition
	Markup   map[string]any
}

// define_action, a type of flow.
var Zt_DefineAction typeinfo.Flow

// implements typeinfo.Instance
func (*DefineAction) TypeInfo() typeinfo.T {
	return &Zt_DefineAction
}

// implements typeinfo.Markup
func (op *DefineAction) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineAction)(nil)
var _ rtti.Execute = (*DefineAction)(nil)

// holds a slice of type define_action
type DefineAction_Slice []DefineAction

// implements typeinfo.Instance
func (*DefineAction_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAction
}

// implements typeinfo.Repeats
func (op *DefineAction_Slice) Repeats() bool {
	return len(*op) > 0
}

// Add traits to an aspect
type DefineAspect struct {
	Aspect rtti.TextEval
	Traits rtti.TextListEval
	Markup map[string]any
}

// define_aspect, a type of flow.
var Zt_DefineAspect typeinfo.Flow

// implements typeinfo.Instance
func (*DefineAspect) TypeInfo() typeinfo.T {
	return &Zt_DefineAspect
}

// implements typeinfo.Markup
func (op *DefineAspect) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineAspect)(nil)
var _ rtti.Execute = (*DefineAspect)(nil)

// holds a slice of type define_aspect
type DefineAspect_Slice []DefineAspect

// implements typeinfo.Instance
func (*DefineAspect_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAspect
}

// implements typeinfo.Repeats
func (op *DefineAspect_Slice) Repeats() bool {
	return len(*op) > 0
}

type AspectField struct {
	Aspect rtti.TextEval
	Markup map[string]any
}

// aspect_field, a type of flow.
var Zt_AspectField typeinfo.Flow

// implements typeinfo.Instance
func (*AspectField) TypeInfo() typeinfo.T {
	return &Zt_AspectField
}

// implements typeinfo.Markup
func (op *AspectField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*AspectField)(nil)

// holds a slice of type aspect_field
type AspectField_Slice []AspectField

// implements typeinfo.Instance
func (*AspectField_Slice) TypeInfo() typeinfo.T {
	return &Zt_AspectField
}

// implements typeinfo.Repeats
func (op *AspectField_Slice) Repeats() bool {
	return len(*op) > 0
}

type BoolField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.BoolEval
	Markup    map[string]any
}

// bool_field, a type of flow.
var Zt_BoolField typeinfo.Flow

// implements typeinfo.Instance
func (*BoolField) TypeInfo() typeinfo.T {
	return &Zt_BoolField
}

// implements typeinfo.Markup
func (op *BoolField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*BoolField)(nil)

// holds a slice of type bool_field
type BoolField_Slice []BoolField

// implements typeinfo.Instance
func (*BoolField_Slice) TypeInfo() typeinfo.T {
	return &Zt_BoolField
}

// implements typeinfo.Repeats
func (op *BoolField_Slice) Repeats() bool {
	return len(*op) > 0
}

type CountOf struct {
	Trigger core.Trigger
	Num     rtti.NumberEval
	Markup  map[string]any
}

// count_of, a type of flow.
var Zt_CountOf typeinfo.Flow

// implements typeinfo.Instance
func (*CountOf) TypeInfo() typeinfo.T {
	return &Zt_CountOf
}

// implements typeinfo.Markup
func (op *CountOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*CountOf)(nil)

// holds a slice of type count_of
type CountOf_Slice []CountOf

// implements typeinfo.Instance
func (*CountOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_CountOf
}

// implements typeinfo.Repeats
func (op *CountOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// When called multiple times, returns each of its inputs in turn.
type CycleText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// cycle_text, a type of flow.
var Zt_CycleText typeinfo.Flow

// implements typeinfo.Instance
func (*CycleText) TypeInfo() typeinfo.T {
	return &Zt_CycleText
}

// implements typeinfo.Markup
func (op *CycleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*CycleText)(nil)

// holds a slice of type cycle_text
type CycleText_Slice []CycleText

// implements typeinfo.Instance
func (*CycleText_Slice) TypeInfo() typeinfo.T {
	return &Zt_CycleText
}

// implements typeinfo.Repeats
func (op *CycleText_Slice) Repeats() bool {
	return len(*op) > 0
}

// allows the player to refer to a noun by one or more other terms.
type DefineAlias struct {
	Names    rtti.TextListEval
	NounName rtti.TextEval
	Markup   map[string]any
}

// define_alias, a type of flow.
var Zt_DefineAlias typeinfo.Flow

// implements typeinfo.Instance
func (*DefineAlias) TypeInfo() typeinfo.T {
	return &Zt_DefineAlias
}

// implements typeinfo.Markup
func (op *DefineAlias) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DefineAlias)(nil)
var _ StoryStatement = (*DefineAlias)(nil)

// holds a slice of type define_alias
type DefineAlias_Slice []DefineAlias

// implements typeinfo.Instance
func (*DefineAlias_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineAlias
}

// implements typeinfo.Repeats
func (op *DefineAlias_Slice) Repeats() bool {
	return len(*op) > 0
}

// starts a parser scanner.
type DefineLeadingGrammar struct {
	Lede   []string
	Scans  []grammar.ScannerMaker
	Markup map[string]any
}

// define_leading_grammar, a type of flow.
var Zt_DefineLeadingGrammar typeinfo.Flow

// implements typeinfo.Instance
func (*DefineLeadingGrammar) TypeInfo() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// implements typeinfo.Markup
func (op *DefineLeadingGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DefineLeadingGrammar)(nil)
var _ StoryStatement = (*DefineLeadingGrammar)(nil)

// holds a slice of type define_leading_grammar
type DefineLeadingGrammar_Slice []DefineLeadingGrammar

// implements typeinfo.Instance
func (*DefineLeadingGrammar_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineLeadingGrammar
}

// implements typeinfo.Repeats
func (op *DefineLeadingGrammar_Slice) Repeats() bool {
	return len(*op) > 0
}

// starts a parser scanner.
type DefineNamedGrammar struct {
	Name   string
	Scans  []grammar.ScannerMaker
	Markup map[string]any
}

// define_named_grammar, a type of flow.
var Zt_DefineNamedGrammar typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNamedGrammar) TypeInfo() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// implements typeinfo.Markup
func (op *DefineNamedGrammar) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*DefineNamedGrammar)(nil)
var _ StoryStatement = (*DefineNamedGrammar)(nil)

// holds a slice of type define_named_grammar
type DefineNamedGrammar_Slice []DefineNamedGrammar

// implements typeinfo.Instance
func (*DefineNamedGrammar_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNamedGrammar
}

// implements typeinfo.Repeats
func (op *DefineNamedGrammar_Slice) Repeats() bool {
	return len(*op) > 0
}

// Define a phrase that can be used with 'natural language' statements.
type DefinePhrase struct {
	Phrase   rtti.TextEval
	Macro    rtti.TextEval
	Reversed rtti.BoolEval
	Markup   map[string]any
}

// define_phrase, a type of flow.
var Zt_DefinePhrase typeinfo.Flow

// implements typeinfo.Instance
func (*DefinePhrase) TypeInfo() typeinfo.T {
	return &Zt_DefinePhrase
}

// implements typeinfo.Markup
func (op *DefinePhrase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePhrase)(nil)

// holds a slice of type define_phrase
type DefinePhrase_Slice []DefinePhrase

// implements typeinfo.Instance
func (*DefinePhrase_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePhrase
}

// implements typeinfo.Repeats
func (op *DefinePhrase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Simple english like definitions of nouns, kinds, and their relatives.
type DeclareStatement struct {
	Text   rtti.TextEval
	Markup map[string]any
}

// declare_statement, a type of flow.
var Zt_DeclareStatement typeinfo.Flow

// implements typeinfo.Instance
func (*DeclareStatement) TypeInfo() typeinfo.T {
	return &Zt_DeclareStatement
}

// implements typeinfo.Markup
func (op *DeclareStatement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DeclareStatement)(nil)

// holds a slice of type declare_statement
type DeclareStatement_Slice []DeclareStatement

// implements typeinfo.Instance
func (*DeclareStatement_Slice) TypeInfo() typeinfo.T {
	return &Zt_DeclareStatement
}

// implements typeinfo.Repeats
func (op *DeclareStatement_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineRelation struct {
	Relation    rtti.TextEval
	Kind        rtti.TextEval
	OtherKind   rtti.TextEval
	Cardinality RelationCardinality
	Markup      map[string]any
}

// define_relation, a type of flow.
var Zt_DefineRelation typeinfo.Flow

// implements typeinfo.Instance
func (*DefineRelation) TypeInfo() typeinfo.T {
	return &Zt_DefineRelation
}

// implements typeinfo.Markup
func (op *DefineRelation) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineRelation)(nil)
var _ rtti.Execute = (*DefineRelation)(nil)

// holds a slice of type define_relation
type DefineRelation_Slice []DefineRelation

// implements typeinfo.Instance
func (*DefineRelation_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRelation
}

// implements typeinfo.Repeats
func (op *DefineRelation_Slice) Repeats() bool {
	return len(*op) > 0
}

// Add properties to a kind
type DefineFields struct {
	Kind   rtti.TextEval
	Fields []FieldDefinition
	Markup map[string]any
}

// define_fields, a type of flow.
var Zt_DefineFields typeinfo.Flow

// implements typeinfo.Instance
func (*DefineFields) TypeInfo() typeinfo.T {
	return &Zt_DefineFields
}

// implements typeinfo.Markup
func (op *DefineFields) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineFields)(nil)
var _ rtti.Execute = (*DefineFields)(nil)

// holds a slice of type define_fields
type DefineFields_Slice []DefineFields

// implements typeinfo.Instance
func (*DefineFields_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineFields
}

// implements typeinfo.Repeats
func (op *DefineFields_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineKinds struct {
	Kinds    rtti.TextListEval
	Ancestor rtti.TextEval
	Markup   map[string]any
}

// define_kinds, a type of flow.
var Zt_DefineKinds typeinfo.Flow

// implements typeinfo.Instance
func (*DefineKinds) TypeInfo() typeinfo.T {
	return &Zt_DefineKinds
}

// implements typeinfo.Markup
func (op *DefineKinds) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineKinds)(nil)
var _ rtti.Execute = (*DefineKinds)(nil)

// holds a slice of type define_kinds
type DefineKinds_Slice []DefineKinds

// implements typeinfo.Instance
func (*DefineKinds_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineKinds
}

// implements typeinfo.Repeats
func (op *DefineKinds_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineOpposite struct {
	Opposite rtti.TextEval
	Word     rtti.TextEval
	Markup   map[string]any
}

// define_opposite, a type of flow.
var Zt_DefineOpposite typeinfo.Flow

// implements typeinfo.Instance
func (*DefineOpposite) TypeInfo() typeinfo.T {
	return &Zt_DefineOpposite
}

// implements typeinfo.Markup
func (op *DefineOpposite) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineOpposite)(nil)
var _ rtti.Execute = (*DefineOpposite)(nil)

// holds a slice of type define_opposite
type DefineOpposite_Slice []DefineOpposite

// implements typeinfo.Instance
func (*DefineOpposite_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineOpposite
}

// implements typeinfo.Repeats
func (op *DefineOpposite_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefinePlural struct {
	Singular rtti.TextEval
	Plural   rtti.TextEval
	Markup   map[string]any
}

// define_plural, a type of flow.
var Zt_DefinePlural typeinfo.Flow

// implements typeinfo.Instance
func (*DefinePlural) TypeInfo() typeinfo.T {
	return &Zt_DefinePlural
}

// implements typeinfo.Markup
func (op *DefinePlural) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePlural)(nil)
var _ rtti.Execute = (*DefinePlural)(nil)

// holds a slice of type define_plural
type DefinePlural_Slice []DefinePlural

// implements typeinfo.Instance
func (*DefinePlural_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePlural
}

// implements typeinfo.Repeats
func (op *DefinePlural_Slice) Repeats() bool {
	return len(*op) > 0
}

// Leaving a room by by going through a door ( ex. departing the house via the front door... ).
type MapDeparting struct {
	RoomName      rtti.TextEval
	DoorName      rtti.TextEval
	MapConnection MapConnection
	OtherRoomName rtti.TextEval
	Markup        map[string]any
}

// map_departing, a type of flow.
var Zt_MapDeparting typeinfo.Flow

// implements typeinfo.Instance
func (*MapDeparting) TypeInfo() typeinfo.T {
	return &Zt_MapDeparting
}

// implements typeinfo.Markup
func (op *MapDeparting) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*MapDeparting)(nil)
var _ rtti.Execute = (*MapDeparting)(nil)

// holds a slice of type map_departing
type MapDeparting_Slice []MapDeparting

// implements typeinfo.Instance
func (*MapDeparting_Slice) TypeInfo() typeinfo.T {
	return &Zt_MapDeparting
}

// implements typeinfo.Repeats
func (op *MapDeparting_Slice) Repeats() bool {
	return len(*op) > 0
}

// Leaving a room by moving in a compass direction ( ex. heading east... ).
type MapHeading struct {
	Dir           string
	RoomName      rtti.TextEval
	DoorName      rtti.TextEval
	MapConnection MapConnection
	OtherRoomName rtti.TextEval
	Markup        map[string]any
}

// map_heading, a type of flow.
var Zt_MapHeading typeinfo.Flow

// implements typeinfo.Instance
func (*MapHeading) TypeInfo() typeinfo.T {
	return &Zt_MapHeading
}

// implements typeinfo.Markup
func (op *MapHeading) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*MapHeading)(nil)
var _ rtti.Execute = (*MapHeading)(nil)

// holds a slice of type map_heading
type MapHeading_Slice []MapHeading

// implements typeinfo.Instance
func (*MapHeading_Slice) TypeInfo() typeinfo.T {
	return &Zt_MapHeading
}

// implements typeinfo.Repeats
func (op *MapHeading_Slice) Repeats() bool {
	return len(*op) > 0
}

// Assign a starting value to the field of one or nouns.
type DefineValue struct {
	FieldName rtti.TextEval
	Nouns     rtti.TextListEval
	Value     rtti.Assignment
	Markup    map[string]any
}

// define_value, a type of flow.
var Zt_DefineValue typeinfo.Flow

// implements typeinfo.Instance
func (*DefineValue) TypeInfo() typeinfo.T {
	return &Zt_DefineValue
}

// implements typeinfo.Markup
func (op *DefineValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineValue)(nil)
var _ rtti.Execute = (*DefineValue)(nil)

// holds a slice of type define_value
type DefineValue_Slice []DefineValue

// implements typeinfo.Instance
func (*DefineValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineValue
}

// implements typeinfo.Repeats
func (op *DefineValue_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineNouns struct {
	Nouns  rtti.TextListEval
	Kind   rtti.TextEval
	Markup map[string]any
}

// define_nouns, a type of flow.
var Zt_DefineNouns typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNouns) TypeInfo() typeinfo.T {
	return &Zt_DefineNouns
}

// implements typeinfo.Markup
func (op *DefineNouns) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNouns)(nil)
var _ rtti.Execute = (*DefineNouns)(nil)

// holds a slice of type define_nouns
type DefineNouns_Slice []DefineNouns

// implements typeinfo.Instance
func (*DefineNouns_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNouns
}

// implements typeinfo.Repeats
func (op *DefineNouns_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineNounTraits struct {
	Nouns  rtti.TextListEval
	Traits rtti.TextListEval
	Markup map[string]any
}

// define_noun_traits, a type of flow.
var Zt_DefineNounTraits typeinfo.Flow

// implements typeinfo.Instance
func (*DefineNounTraits) TypeInfo() typeinfo.T {
	return &Zt_DefineNounTraits
}

// implements typeinfo.Markup
func (op *DefineNounTraits) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineNounTraits)(nil)
var _ rtti.Execute = (*DefineNounTraits)(nil)

// holds a slice of type define_noun_traits
type DefineNounTraits_Slice []DefineNounTraits

// implements typeinfo.Instance
func (*DefineNounTraits_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineNounTraits
}

// implements typeinfo.Repeats
func (op *DefineNounTraits_Slice) Repeats() bool {
	return len(*op) > 0
}

type NumListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.NumListEval
	Markup    map[string]any
}

// num_list_field, a type of flow.
var Zt_NumListField typeinfo.Flow

// implements typeinfo.Instance
func (*NumListField) TypeInfo() typeinfo.T {
	return &Zt_NumListField
}

// implements typeinfo.Markup
func (op *NumListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NumListField)(nil)

// holds a slice of type num_list_field
type NumListField_Slice []NumListField

// implements typeinfo.Instance
func (*NumListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NumListField
}

// implements typeinfo.Repeats
func (op *NumListField_Slice) Repeats() bool {
	return len(*op) > 0
}

type NumberField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.NumberEval
	Markup    map[string]any
}

// number_field, a type of flow.
var Zt_NumberField typeinfo.Flow

// implements typeinfo.Instance
func (*NumberField) TypeInfo() typeinfo.T {
	return &Zt_NumberField
}

// implements typeinfo.Markup
func (op *NumberField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NumberField)(nil)

// holds a slice of type number_field
type NumberField_Slice []NumberField

// implements typeinfo.Instance
func (*NumberField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NumberField
}

// implements typeinfo.Repeats
func (op *NumberField_Slice) Repeats() bool {
	return len(*op) > 0
}

type RuleProvides struct {
	PatternName rtti.TextEval
	Provides    []FieldDefinition
	Markup      map[string]any
}

// rule_provides, a type of flow.
var Zt_RuleProvides typeinfo.Flow

// implements typeinfo.Instance
func (*RuleProvides) TypeInfo() typeinfo.T {
	return &Zt_RuleProvides
}

// implements typeinfo.Markup
func (op *RuleProvides) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleProvides)(nil)
var _ rtti.Execute = (*RuleProvides)(nil)

// holds a slice of type rule_provides
type RuleProvides_Slice []RuleProvides

// implements typeinfo.Instance
func (*RuleProvides_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleProvides
}

// implements typeinfo.Repeats
func (op *RuleProvides_Slice) Repeats() bool {
	return len(*op) > 0
}

type RuleForPattern struct {
	PatternName rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_pattern, a type of flow.
var Zt_RuleForPattern typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForPattern) TypeInfo() typeinfo.T {
	return &Zt_RuleForPattern
}

// implements typeinfo.Markup
func (op *RuleForPattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForPattern)(nil)
var _ rtti.Execute = (*RuleForPattern)(nil)

// holds a slice of type rule_for_pattern
type RuleForPattern_Slice []RuleForPattern

// implements typeinfo.Instance
func (*RuleForPattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForPattern
}

// implements typeinfo.Repeats
func (op *RuleForPattern_Slice) Repeats() bool {
	return len(*op) > 0
}

type RuleForNoun struct {
	PatternName rtti.TextEval
	NounName    rtti.TextEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_noun, a type of flow.
var Zt_RuleForNoun typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForNoun) TypeInfo() typeinfo.T {
	return &Zt_RuleForNoun
}

// implements typeinfo.Markup
func (op *RuleForNoun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForNoun)(nil)
var _ rtti.Execute = (*RuleForNoun)(nil)

// holds a slice of type rule_for_noun
type RuleForNoun_Slice []RuleForNoun

// implements typeinfo.Instance
func (*RuleForNoun_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForNoun
}

// implements typeinfo.Repeats
func (op *RuleForNoun_Slice) Repeats() bool {
	return len(*op) > 0
}

type RuleForKind struct {
	PatternName rtti.TextEval
	KindName    rtti.TextEval
	Exactly     rtti.BoolEval
	RuleName    rtti.TextEval
	Exe         []rtti.Execute
	Markup      map[string]any
}

// rule_for_kind, a type of flow.
var Zt_RuleForKind typeinfo.Flow

// implements typeinfo.Instance
func (*RuleForKind) TypeInfo() typeinfo.T {
	return &Zt_RuleForKind
}

// implements typeinfo.Markup
func (op *RuleForKind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*RuleForKind)(nil)
var _ rtti.Execute = (*RuleForKind)(nil)

// holds a slice of type rule_for_kind
type RuleForKind_Slice []RuleForKind

// implements typeinfo.Instance
func (*RuleForKind_Slice) TypeInfo() typeinfo.T {
	return &Zt_RuleForKind
}

// implements typeinfo.Repeats
func (op *RuleForKind_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefineMacro struct {
	MacroName       rtti.TextEval
	Requires        []FieldDefinition
	Provides        []FieldDefinition
	MacroStatements []rtti.Execute
	Markup          map[string]any
}

// define_macro, a type of flow.
var Zt_DefineMacro typeinfo.Flow

// implements typeinfo.Instance
func (*DefineMacro) TypeInfo() typeinfo.T {
	return &Zt_DefineMacro
}

// implements typeinfo.Markup
func (op *DefineMacro) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineMacro)(nil)
var _ rtti.Execute = (*DefineMacro)(nil)

// holds a slice of type define_macro
type DefineMacro_Slice []DefineMacro

// implements typeinfo.Instance
func (*DefineMacro_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineMacro
}

// implements typeinfo.Repeats
func (op *DefineMacro_Slice) Repeats() bool {
	return len(*op) > 0
}

// Executes a macro, and potentially returns a value.
type CallMacro struct {
	MacroName string
	Arguments []assign.Arg
	Markup    map[string]any
}

// call_macro, a type of flow.
var Zt_CallMacro typeinfo.Flow

// implements typeinfo.Instance
func (*CallMacro) TypeInfo() typeinfo.T {
	return &Zt_CallMacro
}

// implements typeinfo.Markup
func (op *CallMacro) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*CallMacro)(nil)
var _ rtti.BoolEval = (*CallMacro)(nil)
var _ rtti.NumberEval = (*CallMacro)(nil)
var _ rtti.TextEval = (*CallMacro)(nil)
var _ rtti.RecordEval = (*CallMacro)(nil)
var _ rtti.NumListEval = (*CallMacro)(nil)
var _ rtti.TextListEval = (*CallMacro)(nil)
var _ rtti.RecordListEval = (*CallMacro)(nil)
var _ StoryStatement = (*CallMacro)(nil)

// holds a slice of type call_macro
type CallMacro_Slice []CallMacro

// implements typeinfo.Instance
func (*CallMacro_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallMacro
}

// implements typeinfo.Repeats
func (op *CallMacro_Slice) Repeats() bool {
	return len(*op) > 0
}

type DefinePattern struct {
	PatternName rtti.TextEval
	Requires    []FieldDefinition
	Provides    []FieldDefinition
	Exe         []rtti.Execute
	Markup      map[string]any
}

// define_pattern, a type of flow.
var Zt_DefinePattern typeinfo.Flow

// implements typeinfo.Instance
func (*DefinePattern) TypeInfo() typeinfo.T {
	return &Zt_DefinePattern
}

// implements typeinfo.Markup
func (op *DefinePattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefinePattern)(nil)
var _ rtti.Execute = (*DefinePattern)(nil)

// holds a slice of type define_pattern
type DefinePattern_Slice []DefinePattern

// implements typeinfo.Instance
func (*DefinePattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefinePattern
}

// implements typeinfo.Repeats
func (op *DefinePattern_Slice) Repeats() bool {
	return len(*op) > 0
}

type RecordListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.RecordListEval
	Markup    map[string]any
}

// record_list_field, a type of flow.
var Zt_RecordListField typeinfo.Flow

// implements typeinfo.Instance
func (*RecordListField) TypeInfo() typeinfo.T {
	return &Zt_RecordListField
}

// implements typeinfo.Markup
func (op *RecordListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*RecordListField)(nil)

// holds a slice of type record_list_field
type RecordListField_Slice []RecordListField

// implements typeinfo.Instance
func (*RecordListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordListField
}

// implements typeinfo.Repeats
func (op *RecordListField_Slice) Repeats() bool {
	return len(*op) > 0
}

type RecordField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.RecordEval
	Markup    map[string]any
}

// record_field, a type of flow.
var Zt_RecordField typeinfo.Flow

// implements typeinfo.Instance
func (*RecordField) TypeInfo() typeinfo.T {
	return &Zt_RecordField
}

// implements typeinfo.Markup
func (op *RecordField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*RecordField)(nil)

// holds a slice of type record_field
type RecordField_Slice []RecordField

// implements typeinfo.Instance
func (*RecordField_Slice) TypeInfo() typeinfo.T {
	return &Zt_RecordField
}

// implements typeinfo.Repeats
func (op *RecordField_Slice) Repeats() bool {
	return len(*op) > 0
}

// Relate nouns to each other
type DefineRelatives struct {
	Nouns      rtti.TextListEval
	Relation   rtti.TextEval
	OtherNouns rtti.TextListEval
	Markup     map[string]any
}

// define_relatives, a type of flow.
var Zt_DefineRelatives typeinfo.Flow

// implements typeinfo.Instance
func (*DefineRelatives) TypeInfo() typeinfo.T {
	return &Zt_DefineRelatives
}

// implements typeinfo.Markup
func (op *DefineRelatives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineRelatives)(nil)
var _ rtti.Execute = (*DefineRelatives)(nil)

// holds a slice of type define_relatives
type DefineRelatives_Slice []DefineRelatives

// implements typeinfo.Instance
func (*DefineRelatives_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineRelatives
}

// implements typeinfo.Repeats
func (op *DefineRelatives_Slice) Repeats() bool {
	return len(*op) > 0
}

// Relate nouns to each other
type DefineOtherRelatives struct {
	Relation   rtti.TextEval
	Nouns      rtti.TextListEval
	OtherNouns rtti.TextListEval
	Markup     map[string]any
}

// define_other_relatives, a type of flow.
var Zt_DefineOtherRelatives typeinfo.Flow

// implements typeinfo.Instance
func (*DefineOtherRelatives) TypeInfo() typeinfo.T {
	return &Zt_DefineOtherRelatives
}

// implements typeinfo.Markup
func (op *DefineOtherRelatives) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*DefineOtherRelatives)(nil)
var _ rtti.Execute = (*DefineOtherRelatives)(nil)

// holds a slice of type define_other_relatives
type DefineOtherRelatives_Slice []DefineOtherRelatives

// implements typeinfo.Instance
func (*DefineOtherRelatives_Slice) TypeInfo() typeinfo.T {
	return &Zt_DefineOtherRelatives
}

// implements typeinfo.Repeats
func (op *DefineOtherRelatives_Slice) Repeats() bool {
	return len(*op) > 0
}

type SayTemplate struct {
	Template string
	Markup   map[string]any
}

// say_template, a type of flow.
var Zt_SayTemplate typeinfo.Flow

// implements typeinfo.Instance
func (*SayTemplate) TypeInfo() typeinfo.T {
	return &Zt_SayTemplate
}

// implements typeinfo.Markup
func (op *SayTemplate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*SayTemplate)(nil)
var _ rtti.TextEval = (*SayTemplate)(nil)

// holds a slice of type say_template
type SayTemplate_Slice []SayTemplate

// implements typeinfo.Instance
func (*SayTemplate_Slice) TypeInfo() typeinfo.T {
	return &Zt_SayTemplate
}

// implements typeinfo.Repeats
func (op *SayTemplate_Slice) Repeats() bool {
	return len(*op) > 0
}

type SayResponse struct {
	Name   string
	Text   rtti.TextEval
	Markup map[string]any
}

// say_response, a type of flow.
var Zt_SayResponse typeinfo.Flow

// implements typeinfo.Instance
func (*SayResponse) TypeInfo() typeinfo.T {
	return &Zt_SayResponse
}

// implements typeinfo.Markup
func (op *SayResponse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*SayResponse)(nil)
var _ rtti.TextEval = (*SayResponse)(nil)

// holds a slice of type say_response
type SayResponse_Slice []SayResponse

// implements typeinfo.Instance
func (*SayResponse_Slice) TypeInfo() typeinfo.T {
	return &Zt_SayResponse
}

// implements typeinfo.Repeats
func (op *SayResponse_Slice) Repeats() bool {
	return len(*op) > 0
}

// When called multiple times returns its inputs at random.
type ShuffleText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// shuffle_text, a type of flow.
var Zt_ShuffleText typeinfo.Flow

// implements typeinfo.Instance
func (*ShuffleText) TypeInfo() typeinfo.T {
	return &Zt_ShuffleText
}

// implements typeinfo.Markup
func (op *ShuffleText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*ShuffleText)(nil)

// holds a slice of type shuffle_text
type ShuffleText_Slice []ShuffleText

// implements typeinfo.Instance
func (*ShuffleText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ShuffleText
}

// implements typeinfo.Repeats
func (op *ShuffleText_Slice) Repeats() bool {
	return len(*op) > 0
}

// When called multiple times returns each of its inputs in turn, sticking to the last one.
type StoppingText struct {
	Parts  []rtti.TextEval
	Markup map[string]any
}

// stopping_text, a type of flow.
var Zt_StoppingText typeinfo.Flow

// implements typeinfo.Instance
func (*StoppingText) TypeInfo() typeinfo.T {
	return &Zt_StoppingText
}

// implements typeinfo.Markup
func (op *StoppingText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*StoppingText)(nil)

// holds a slice of type stopping_text
type StoppingText_Slice []StoppingText

// implements typeinfo.Instance
func (*StoppingText_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoppingText
}

// implements typeinfo.Repeats
func (op *StoppingText_Slice) Repeats() bool {
	return len(*op) > 0
}

type StoryBreak struct {
	Markup map[string]any
}

// story_break, a type of flow.
var Zt_StoryBreak typeinfo.Flow

// implements typeinfo.Instance
func (*StoryBreak) TypeInfo() typeinfo.T {
	return &Zt_StoryBreak
}

// implements typeinfo.Markup
func (op *StoryBreak) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ StoryStatement = (*StoryBreak)(nil)

// holds a slice of type story_break
type StoryBreak_Slice []StoryBreak

// implements typeinfo.Instance
func (*StoryBreak_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoryBreak
}

// implements typeinfo.Repeats
func (op *StoryBreak_Slice) Repeats() bool {
	return len(*op) > 0
}

// top level node, currently just for blockly might eventually contain story metadata  ex. author, description...
type StoryFile struct {
	StoryStatements []StoryStatement
	Markup          map[string]any
}

// story_file, a type of flow.
var Zt_StoryFile typeinfo.Flow

// implements typeinfo.Instance
func (*StoryFile) TypeInfo() typeinfo.T {
	return &Zt_StoryFile
}

// implements typeinfo.Markup
func (op *StoryFile) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// holds a slice of type story_file
type StoryFile_Slice []StoryFile

// implements typeinfo.Instance
func (*StoryFile_Slice) TypeInfo() typeinfo.T {
	return &Zt_StoryFile
}

// implements typeinfo.Repeats
func (op *StoryFile_Slice) Repeats() bool {
	return len(*op) > 0
}

type TextListField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.TextListEval
	Markup    map[string]any
}

// text_list_field, a type of flow.
var Zt_TextListField typeinfo.Flow

// implements typeinfo.Instance
func (*TextListField) TypeInfo() typeinfo.T {
	return &Zt_TextListField
}

// implements typeinfo.Markup
func (op *TextListField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*TextListField)(nil)

// holds a slice of type text_list_field
type TextListField_Slice []TextListField

// implements typeinfo.Instance
func (*TextListField_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextListField
}

// implements typeinfo.Repeats
func (op *TextListField_Slice) Repeats() bool {
	return len(*op) > 0
}

type TextField struct {
	Name      rtti.TextEval
	Type      rtti.TextEval
	Initially rtti.TextEval
	Markup    map[string]any
}

// text_field, a type of flow.
var Zt_TextField typeinfo.Flow

// implements typeinfo.Instance
func (*TextField) TypeInfo() typeinfo.T {
	return &Zt_TextField
}

// implements typeinfo.Markup
func (op *TextField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*TextField)(nil)

// holds a slice of type text_field
type TextField_Slice []TextField

// implements typeinfo.Instance
func (*TextField_Slice) TypeInfo() typeinfo.T {
	return &Zt_TextField
}

// implements typeinfo.Repeats
func (op *TextField_Slice) Repeats() bool {
	return len(*op) > 0
}

type NothingField struct {
	Markup map[string]any
}

// nothing_field, a type of flow.
var Zt_NothingField typeinfo.Flow

// implements typeinfo.Instance
func (*NothingField) TypeInfo() typeinfo.T {
	return &Zt_NothingField
}

// implements typeinfo.Markup
func (op *NothingField) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ FieldDefinition = (*NothingField)(nil)

// holds a slice of type nothing_field
type NothingField_Slice []NothingField

// implements typeinfo.Instance
func (*NothingField_Slice) TypeInfo() typeinfo.T {
	return &Zt_NothingField
}

// implements typeinfo.Repeats
func (op *NothingField_Slice) Repeats() bool {
	return len(*op) > 0
}

// MapConnection, a type of str enum.
type MapConnection int

// enumerated values of MapConnection
const (
	C_MapConnection_ArrivingAt MapConnection = iota
	C_MapConnection_ConnectingTo
)

func MakeMapConnection(str string) (ret MapConnection, okay bool) {
	if i := Zt_MapConnection.FindOption(str); i >= 0 {
		ret, okay = MapConnection(i), true
	}
	return
}

func (op MapConnection) String() (ret string) {
	if i, opts := int(op), Zt_MapConnection.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid MapConnection(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// map_connection, a type of str enum.
var Zt_MapConnection = typeinfo.Str{
	Name: "map_connection",
	Options: []string{
		"arriving_at",
		"connecting_to",
	},
	Markup: map[string]any{
		"comment": "Chooses between a one-way and a two-way connection between rooms.  Generally, this only makes sense for map headings, but it at least causes 'departing' to check that a reverse connection exists.  Note: moving from one room leads you into another somewhat generically.  Sometimes its useful to position the player on entry to a new room based on where they came from.  Using, a previous room or last used door can do the trick.",
	},
}
var Zt_MapDirection = typeinfo.Str{
	Name: "map_direction",
	Markup: map[string]any{
		"comment": "A heading for movement within the game, often connecting one room within the game to another.  The most commonly used are standard compass directions like 'north', 'east', 'south', and 'west'.",
	},
}

// RelationCardinality, a type of str enum.
type RelationCardinality int

// enumerated values of RelationCardinality
const (
	C_RelationCardinality_OneToOne RelationCardinality = iota
	C_RelationCardinality_OneToMany
	C_RelationCardinality_ManyToOne
	C_RelationCardinality_ManyToMany
)

func MakeRelationCardinality(str string) (ret RelationCardinality, okay bool) {
	if i := Zt_RelationCardinality.FindOption(str); i >= 0 {
		ret, okay = RelationCardinality(i), true
	}
	return
}

func (op RelationCardinality) String() (ret string) {
	if i, opts := int(op), Zt_RelationCardinality.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid RelationCardinality(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// relation_cardinality, a type of str enum.
var Zt_RelationCardinality = typeinfo.Str{
	Name: "relation_cardinality",
	Options: []string{
		"one_to_one",
		"one_to_many",
		"many_to_one",
		"many_to_many",
	},
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "story",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_FieldDefinition,
	&Zt_StoryStatement,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Comment,
	&Zt_DefineTest,
	&Zt_DefineScene,
	&Zt_DefineAction,
	&Zt_DefineAspect,
	&Zt_AspectField,
	&Zt_BoolField,
	&Zt_CountOf,
	&Zt_CycleText,
	&Zt_DefineAlias,
	&Zt_DefineLeadingGrammar,
	&Zt_DefineNamedGrammar,
	&Zt_DefinePhrase,
	&Zt_DeclareStatement,
	&Zt_DefineRelation,
	&Zt_DefineFields,
	&Zt_DefineKinds,
	&Zt_DefineOpposite,
	&Zt_DefinePlural,
	&Zt_MapDeparting,
	&Zt_MapHeading,
	&Zt_DefineValue,
	&Zt_DefineNouns,
	&Zt_DefineNounTraits,
	&Zt_NumListField,
	&Zt_NumberField,
	&Zt_RuleProvides,
	&Zt_RuleForPattern,
	&Zt_RuleForNoun,
	&Zt_RuleForKind,
	&Zt_DefineMacro,
	&Zt_CallMacro,
	&Zt_DefinePattern,
	&Zt_RecordListField,
	&Zt_RecordField,
	&Zt_DefineRelatives,
	&Zt_DefineOtherRelatives,
	&Zt_SayTemplate,
	&Zt_SayResponse,
	&Zt_ShuffleText,
	&Zt_StoppingText,
	&Zt_StoryBreak,
	&Zt_StoryFile,
	&Zt_TextListField,
	&Zt_TextField,
	&Zt_NothingField,
}

// a list of all strs in this this package
var z_str_list = []*typeinfo.Str{
	&Zt_MapConnection,
	&Zt_MapDirection,
	&Zt_RelationCardinality,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	5991962903091297123:  (*StoryFile)(nil),            /* Tapestry: */
	4360765066804052293:  (*StoryBreak)(nil),           /* story_statement=-- */
	13010292396640781698: (*AspectField)(nil),          /* field_definition=Aspect: */
	12738236274201716794: (*BoolField)(nil),            /* field_definition=Bool: */
	18077675806901364237: (*BoolField)(nil),            /* field_definition=Bool:initially: */
	17184788623765734642: (*BoolField)(nil),            /* field_definition=Bool:kind: */
	124015053883609573:   (*BoolField)(nil),            /* field_definition=Bool:kind:initially: */
	4843373105631259652:  (*CallMacro)(nil),            /* bool_eval=Call macro:args: */
	10236024639985130132: (*CallMacro)(nil),            /* execute=Call macro:args: */
	5651581957203069121:  (*CallMacro)(nil),            /* num_list_eval=Call macro:args: */
	11693923858603804101: (*CallMacro)(nil),            /* number_eval=Call macro:args: */
	1853884795003797121:  (*CallMacro)(nil),            /* record_eval=Call macro:args: */
	12142382415765691372: (*CallMacro)(nil),            /* record_list_eval=Call macro:args: */
	15275988251373739424: (*CallMacro)(nil),            /* story_statement=Call macro:args: */
	14675240953305539039: (*CallMacro)(nil),            /* text_eval=Call macro:args: */
	7066713272892250094:  (*CallMacro)(nil),            /* text_list_eval=Call macro:args: */
	3991849378064754806:  (*Comment)(nil),              /* execute=Comment: */
	16586092333187989882: (*Comment)(nil),              /* story_statement=Comment: */
	10143132576483224253: (*CountOf)(nil),              /* bool_eval=CountOf:num: */
	231398832069830353:   (*CycleText)(nil),            /* text_eval=CycleText: */
	9796202271034753943:  (*DeclareStatement)(nil),     /* story_statement=Declare: */
	10109890763294157270: (*DefineAction)(nil),         /* execute=Define action:requires: */
	14790755516297707674: (*DefineAction)(nil),         /* story_statement=Define action:requires: */
	14322897916789725742: (*DefineAction)(nil),         /* execute=Define action:requires:provides: */
	5312053119535959994:  (*DefineAction)(nil),         /* story_statement=Define action:requires:provides: */
	14770055621982936367: (*DefineAspect)(nil),         /* execute=Define aspect:traits: */
	4679255645834546435:  (*DefineAspect)(nil),         /* story_statement=Define aspect:traits: */
	2600953883978299185:  (*DefineFields)(nil),         /* execute=Define kind:fields: */
	15268150405724581221: (*DefineFields)(nil),         /* story_statement=Define kind:fields: */
	17025532743550436003: (*DefineKinds)(nil),          /* execute=Define kinds:as: */
	11622379079031968031: (*DefineKinds)(nil),          /* story_statement=Define kinds:as: */
	18413110137608794005: (*DefineMacro)(nil),          /* execute=Define macro:requires:provides:do: */
	17004191702311840201: (*DefineMacro)(nil),          /* story_statement=Define macro:requires:provides:do: */
	4708575879451717005:  (*DefineNouns)(nil),          /* execute=Define nouns:as: */
	7397461044941158073:  (*DefineNouns)(nil),          /* story_statement=Define nouns:as: */
	9839172640820177073:  (*DefineRelatives)(nil),      /* execute=Define nouns:relativeTo:otherNouns: */
	7383237871303366677:  (*DefineRelatives)(nil),      /* story_statement=Define nouns:relativeTo:otherNouns: */
	9505217264701509662:  (*DefineNounTraits)(nil),     /* execute=Define nouns:traits: */
	15794171433650329114: (*DefineNounTraits)(nil),     /* story_statement=Define nouns:traits: */
	13749527262166011841: (*DefineOpposite)(nil),       /* execute=Define opposite:word: */
	17694415259589147741: (*DefineOpposite)(nil),       /* story_statement=Define opposite:word: */
	811338311732531998:   (*DefinePattern)(nil),        /* execute=Define pattern:requires:provides: */
	14040325709851010602: (*DefinePattern)(nil),        /* story_statement=Define pattern:requires:provides: */
	2917659442779702699:  (*DefinePattern)(nil),        /* execute=Define pattern:requires:provides:do: */
	729326910659609567:   (*DefinePattern)(nil),        /* story_statement=Define pattern:requires:provides:do: */
	4650767708903763835:  (*DefinePhrase)(nil),         /* story_statement=Define phrase:asMacro: */
	89301097593785617:    (*DefinePhrase)(nil),         /* story_statement=Define phrase:asMacro:reversed: */
	10034565430437798858: (*DefineRelation)(nil),       /* execute=Define relation:kind:otherKind:cardinality: */
	15951965898335032430: (*DefineRelation)(nil),       /* story_statement=Define relation:kind:otherKind:cardinality: */
	2570506749320892411:  (*DefineOtherRelatives)(nil), /* execute=Define relativeTo:nouns:otherNouns: */
	16389453623741136831: (*DefineOtherRelatives)(nil), /* story_statement=Define relativeTo:nouns:otherNouns: */
	10393873004445566457: (*RuleForPattern)(nil),       /* execute=Define rule:do: */
	18093984368234904277: (*RuleForPattern)(nil),       /* story_statement=Define rule:do: */
	6144114745580995665:  (*RuleForKind)(nil),          /* execute=Define rule:kind:do: */
	12136992210577308757: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:do: */
	12497780268362777975: (*RuleForKind)(nil),          /* execute=Define rule:kind:exactly:do: */
	10538385905361340595: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:exactly:do: */
	10044089009426244136: (*RuleForKind)(nil),          /* execute=Define rule:kind:exactly:named:do: */
	11666026550766211860: (*RuleForKind)(nil),          /* story_statement=Define rule:kind:exactly:named:do: */
	14253827009100247466: (*RuleForKind)(nil),          /* execute=Define rule:kind:named:do: */
	2951940010570883790:  (*RuleForKind)(nil),          /* story_statement=Define rule:kind:named:do: */
	589486870138010946:   (*RuleForPattern)(nil),       /* execute=Define rule:named:do: */
	2007307886252117326:  (*RuleForPattern)(nil),       /* story_statement=Define rule:named:do: */
	5341208345720564107:  (*RuleForNoun)(nil),          /* execute=Define rule:noun:do: */
	4344965134492972319:  (*RuleForNoun)(nil),          /* story_statement=Define rule:noun:do: */
	12048342630397883580: (*RuleForNoun)(nil),          /* execute=Define rule:noun:named:do: */
	16133739979148445504: (*RuleForNoun)(nil),          /* story_statement=Define rule:noun:named:do: */
	16815703800760921520: (*RuleProvides)(nil),         /* execute=Define rule:provides: */
	8031356368944964156:  (*RuleProvides)(nil),         /* story_statement=Define rule:provides: */
	10209709135447127962: (*DefineScene)(nil),          /* story_statement=Define scene:requires:with: */
	13479298094295759568: (*DefineScene)(nil),          /* story_statement=Define scene:with: */
	14046702858409070523: (*DefinePlural)(nil),         /* execute=Define singular:plural: */
	1798652288281835623:  (*DefinePlural)(nil),         /* story_statement=Define singular:plural: */
	9186540469433423003:  (*DefineTest)(nil),           /* execute=Define test:do: */
	12489141410311466071: (*DefineTest)(nil),           /* story_statement=Define test:do: */
	1317505351252968509:  (*DefineTest)(nil),           /* execute=Define test:requires:do: */
	3712030102885900665:  (*DefineTest)(nil),           /* story_statement=Define test:requires:do: */
	4534084067371425967:  (*DefineTest)(nil),           /* execute=Define test:requires:scene:do: */
	16978239348269462739: (*DefineTest)(nil),           /* story_statement=Define test:requires:scene:do: */
	2982226642886528461:  (*DefineTest)(nil),           /* execute=Define test:scene:do: */
	13333326165932249009: (*DefineTest)(nil),           /* story_statement=Define test:scene:do: */
	1692806160663601784:  (*DefineValue)(nil),          /* execute=Define value:of:as: */
	17805855959213202620: (*DefineValue)(nil),          /* story_statement=Define value:of:as: */
	5241959995092605683:  (*MapDeparting)(nil),         /* execute=Departing from:via:and:otherRoom: */
	12862689211056047959: (*MapDeparting)(nil),         /* story_statement=Departing from:via:and:otherRoom: */
	12883151399789323215: (*MapHeading)(nil),           /* execute=Heading:from:and:otherRoom: */
	2625420806444094675:  (*MapHeading)(nil),           /* story_statement=Heading:from:and:otherRoom: */
	5055073108490323709:  (*MapHeading)(nil),           /* execute=Heading:from:via:and:otherRoom: */
	9997819433665596617:  (*MapHeading)(nil),           /* story_statement=Heading:from:via:and:otherRoom: */
	10612153415886771360: (*DefineAlias)(nil),          /* execute=Interpret alias:as: */
	12975771225654832812: (*DefineAlias)(nil),          /* story_statement=Interpret alias:as: */
	16304045397725596887: (*DefineNamedGrammar)(nil),   /* execute=Interpret name:with: */
	8001652437005351387:  (*DefineNamedGrammar)(nil),   /* story_statement=Interpret name:with: */
	2895546536328156972:  (*DefineLeadingGrammar)(nil), /* execute=Interpret:with: */
	6001249499689096432:  (*DefineLeadingGrammar)(nil), /* story_statement=Interpret:with: */
	14427731589588473385: (*NothingField)(nil),         /* field_definition=Nothing */
	10299801658819864730: (*NumListField)(nil),         /* field_definition=NumList: */
	12762197545337845485: (*NumListField)(nil),         /* field_definition=NumList:initially: */
	2289982379805608146:  (*NumListField)(nil),         /* field_definition=NumList:kind: */
	223049567122462661:   (*NumListField)(nil),         /* field_definition=NumList:kind:initially: */
	16579038690333872565: (*NumberField)(nil),          /* field_definition=Number: */
	7599754526096278866:  (*NumberField)(nil),          /* field_definition=Number:initially: */
	13275028962550729195: (*NumberField)(nil),          /* field_definition=Number:kind: */
	8920589511475179656:  (*NumberField)(nil),          /* field_definition=Number:kind:initially: */
	7896413305974623897:  (*RecordField)(nil),          /* field_definition=Record: */
	9030081498362006310:  (*RecordField)(nil),          /* field_definition=Record:initially: */
	7215961239288768263:  (*RecordField)(nil),          /* field_definition=Record:kind: */
	8334583613109868292:  (*RecordField)(nil),          /* field_definition=Record:kind:initially: */
	3705957996596149197:  (*RecordListField)(nil),      /* field_definition=RecordList: */
	5153309692795646250:  (*RecordListField)(nil),      /* field_definition=RecordList:initially: */
	15479801779125468947: (*RecordListField)(nil),      /* field_definition=RecordList:kind: */
	17384295137903978384: (*RecordListField)(nil),      /* field_definition=RecordList:kind:initially: */
	12945074305202371477: (*SayResponse)(nil),          /* execute=Say response:with: */
	7921553818502082370:  (*SayResponse)(nil),          /* text_eval=Say response:with: */
	9556993961571292952:  (*SayTemplate)(nil),          /* execute=Say: */
	15989777734244204735: (*SayTemplate)(nil),          /* text_eval=Say: */
	9910951906340888308:  (*ShuffleText)(nil),          /* text_eval=ShuffleText: */
	13921723804355948971: (*StoppingText)(nil),         /* text_eval=StoppingText: */
	9387832592330456403:  (*TextField)(nil),            /* field_definition=Text: */
	16637694412733787472: (*TextField)(nil),            /* field_definition=Text:initially: */
	15791809714384972761: (*TextField)(nil),            /* field_definition=Text:kind: */
	16917317465644840422: (*TextField)(nil),            /* field_definition=Text:kind:initially: */
	3830912410254339707:  (*TextListField)(nil),        /* field_definition=TextList: */
	15743255383721832504: (*TextListField)(nil),        /* field_definition=TextList:initially: */
	2011197685129757745:  (*TextListField)(nil),        /* field_definition=TextList:kind: */
	3232692879001227038:  (*TextListField)(nil),        /* field_definition=TextList:kind:initially: */
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Comment = typeinfo.Flow{
		Name: "comment",
		Lede: "comment",
		Terms: []typeinfo.Term{{
			Name: "lines",
			Type: &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Add a note.", "Information about the story for you and other authors."},
		},
	}
	Zt_DefineTest = typeinfo.Flow{
		Name: "define_test",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "test_name",
			Label: "test",
			Type:  &prim.Zt_Text,
		}, {
			Name:     "scene_names",
			Label:    "requires",
			Optional: true,
			Type:     &rtti.Zt_TextListEval,
		}, {
			Name:     "statements",
			Label:    "scene",
			Optional: true,
			Repeats:  true,
			Type:     &Zt_StoryStatement,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Create a scene",
		},
	}
	Zt_DefineScene = typeinfo.Flow{
		Name: "define_scene",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "scene",
			Label: "scene",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "scene_names",
			Label:    "requires",
			Optional: true,
			Type:     &rtti.Zt_TextListEval,
		}, {
			Name:    "with",
			Label:   "with",
			Repeats: true,
			Type:    &Zt_StoryStatement,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Define a sub world.",
		},
	}
	Zt_DefineAction = typeinfo.Flow{
		Name: "define_action",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "action",
			Label: "action",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:     "provides",
			Label:    "provides",
			Optional: true,
			Repeats:  true,
			Type:     &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Declare an activity: Activities help actors perform tasks: for instance, picking up or dropping items.  Activities involve either the player or an npc and possibly one or two other objects.",
		},
	}
	Zt_DefineAspect = typeinfo.Flow{
		Name: "define_aspect",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "aspect",
			Label: "aspect",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Add traits to an aspect",
		},
	}
	Zt_AspectField = typeinfo.Flow{
		Name: "aspect_field",
		Lede: "aspect",
		Terms: []typeinfo.Term{{
			Name: "aspect",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"tbd: is a separate interface required for object kinds separate from everything else?", "in theory, generic.Kind supports fields of type aspect... but i'm not sure weave handles that."},
		},
	}
	Zt_BoolField = typeinfo.Flow{
		Name: "bool_field",
		Lede: "bool",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_CountOf = typeinfo.Flow{
		Name: "count_of",
		Lede: "count_of",
		Terms: []typeinfo.Term{{
			Name: "trigger",
			Type: &core.Zt_Trigger,
		}, {
			Name:  "num",
			Label: "num",
			Type:  &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A guard which returns true based on a counter.", "Counters start at zero and are incremented every time the guard gets checked."},
		},
	}
	Zt_CycleText = typeinfo.Flow{
		Name: "cycle_text",
		Lede: "cycle_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "When called multiple times, returns each of its inputs in turn.",
		},
	}
	Zt_DefineAlias = typeinfo.Flow{
		Name: "define_alias",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "names",
			Label: "alias",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "noun_name",
			Label: "as",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "allows the player to refer to a noun by one or more other terms.",
		},
	}
	Zt_DefineLeadingGrammar = typeinfo.Flow{
		Name: "define_leading_grammar",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:    "lede",
			Repeats: true,
			Type:    &prim.Zt_Text,
		}, {
			Name:    "scans",
			Label:   "with",
			Repeats: true,
			Type:    &grammar.Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "starts a parser scanner.",
		},
	}
	Zt_DefineNamedGrammar = typeinfo.Flow{
		Name: "define_named_grammar",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "name",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "scans",
			Label:   "with",
			Repeats: true,
			Type:    &grammar.Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "starts a parser scanner.",
		},
	}
	Zt_DefinePhrase = typeinfo.Flow{
		Name: "define_phrase",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "phrase",
			Label: "phrase",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "macro",
			Label: "as_macro",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "reversed",
			Label:    "reversed",
			Optional: true,
			Type:     &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Define a phrase that can be used with 'natural language' statements.",
		},
	}
	Zt_DeclareStatement = typeinfo.Flow{
		Name: "declare_statement",
		Lede: "declare",
		Terms: []typeinfo.Term{{
			Name: "text",
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Simple english like definitions of nouns, kinds, and their relatives.",
		},
	}
	Zt_DefineRelation = typeinfo.Flow{
		Name: "define_relation",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "relation",
			Label: "relation",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "kind",
			Label: "kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "other_kind",
			Label: "other_kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "cardinality",
			Label: "cardinality",
			Type:  &Zt_RelationCardinality,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
	}
	Zt_DefineFields = typeinfo.Flow{
		Name: "define_fields",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "fields",
			Label:   "fields",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Add properties to a kind",
		},
	}
	Zt_DefineKinds = typeinfo.Flow{
		Name: "define_kinds",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "kinds",
			Label: "kinds",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "ancestor",
			Label: "as",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
	}
	Zt_DefineOpposite = typeinfo.Flow{
		Name: "define_opposite",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "opposite",
			Label: "opposite",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "word",
			Label: "word",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Opposites are used at runtime and during weave to", "interpret traits, directions, and other terms.", "For example:", "\"The opposite of east is west.\""},
		},
	}
	Zt_DefinePlural = typeinfo.Flow{
		Name: "define_plural",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "singular",
			Label: "singular",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "plural",
			Label: "plural",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Plurals are used at runtime and during weave to", "guide the interpretation of nouns and kinds.", "For example:", "\"The plural of person is people.\"", "\"The plural of person is persons.\""},
		},
	}
	Zt_MapDeparting = typeinfo.Flow{
		Name: "map_departing",
		Lede: "departing",
		Terms: []typeinfo.Term{{
			Name:  "room_name",
			Label: "from",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "door_name",
			Label: "via",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "map_connection",
			Label: "and",
			Type:  &Zt_MapConnection,
		}, {
			Name:  "other_room_name",
			Label: "other_room",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Leaving a room by by going through a door ( ex. departing the house via the front door... ).",
		},
	}
	Zt_MapHeading = typeinfo.Flow{
		Name: "map_heading",
		Lede: "heading",
		Terms: []typeinfo.Term{{
			Name: "dir",
			Type: &Zt_MapDirection,
		}, {
			Name:  "room_name",
			Label: "from",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "door_name",
			Label:    "via",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:  "map_connection",
			Label: "and",
			Type:  &Zt_MapConnection,
		}, {
			Name:  "other_room_name",
			Label: "other_room",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Leaving a room by moving in a compass direction ( ex. heading east... ).",
		},
	}
	Zt_DefineValue = typeinfo.Flow{
		Name: "define_value",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "field_name",
			Label: "value",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "nouns",
			Label: "of",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "value",
			Label: "as",
			Type:  &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Assign a starting value to the field of one or nouns.",
		},
	}
	Zt_DefineNouns = typeinfo.Flow{
		Name: "define_nouns",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "nouns",
			Label: "nouns",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "kind",
			Label: "as",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
	}
	Zt_DefineNounTraits = typeinfo.Flow{
		Name: "define_noun_traits",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "nouns",
			Label: "nouns",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "traits",
			Label: "traits",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
	}
	Zt_NumListField = typeinfo.Flow{
		Name: "num_list_field",
		Lede: "num_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_NumListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_NumberField = typeinfo.Flow{
		Name: "number_field",
		Lede: "number",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_NumberEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_RuleProvides = typeinfo.Flow{
		Name: "rule_provides",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
	}
	Zt_RuleForPattern = typeinfo.Flow{
		Name: "rule_for_pattern",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "For events, this adds a listener that responds to the targeted object only when triggered by the player.", "By default, rules with filters continue on to the next rule automatically.", "Because event listeners have filters they continue to the next listener unless specifically stopped."},
		},
	}
	Zt_RuleForNoun = typeinfo.Flow{
		Name: "rule_for_noun",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "noun_name",
			Label: "noun",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "The default behavior for events is to fall through to the next handler unless canceled or stopped."},
		},
	}
	Zt_RuleForKind = typeinfo.Flow{
		Name: "rule_for_kind",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "rule",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "kind_name",
			Label: "kind",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:     "exactly",
			Label:    "exactly",
			Optional: true,
			Type:     &rtti.Zt_BoolEval,
		}, {
			Name:     "rule_name",
			Label:    "named",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Change the behavior of an existing pattern.", "The default behavior for events is to fall through to the next handler unless canceled or stopped."},
		},
	}
	Zt_DefineMacro = typeinfo.Flow{
		Name: "define_macro",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "macro_name",
			Label: "macro",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:    "macro_statements",
			Label:   "do",
			Repeats: true,
			Type:    &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Declare a function which can produce statements about the game world.", "They are processed at import time, and they cannot call patterns", "nor can patterns -- which are processed during play -- call macros.", "Unlike patterns, they cannot be extended; the entire definition must live in one place."},
		},
	}
	Zt_CallMacro = typeinfo.Flow{
		Name: "call_macro",
		Lede: "call",
		Terms: []typeinfo.Term{{
			Name:  "macro_name",
			Label: "macro",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "arguments",
			Label:   "args",
			Repeats: true,
			Type:    &assign.Zt_Arg,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumberEval,
			&rtti.Zt_TextEval,
			&rtti.Zt_RecordEval,
			&rtti.Zt_NumListEval,
			&rtti.Zt_TextListEval,
			&rtti.Zt_RecordListEval,
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": "Executes a macro, and potentially returns a value.",
		},
	}
	Zt_DefinePattern = typeinfo.Flow{
		Name: "define_pattern",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "pattern",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:    "requires",
			Label:   "requires",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:    "provides",
			Label:   "provides",
			Repeats: true,
			Type:    &Zt_FieldDefinition,
		}, {
			Name:     "exe",
			Label:    "do",
			Optional: true,
			Repeats:  true,
			Type:     &rtti.Zt_Execute,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Declare a new pattern.", "A pattern is a bundle of functions which can either change the game world or provide information about it.", "Each function in a given pattern has \"guards\" which determine whether the function applies in a particular situation."},
		},
	}
	Zt_RecordListField = typeinfo.Flow{
		Name: "record_list_field",
		Lede: "record_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_RecordListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_RecordField = typeinfo.Flow{
		Name: "record_field",
		Lede: "record",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_RecordEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_DefineRelatives = typeinfo.Flow{
		Name: "define_relatives",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "nouns",
			Label: "nouns",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "relation",
			Label: "relative_to",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "other_nouns",
			Label: "other_nouns",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Relate nouns to each other",
		},
	}
	Zt_DefineOtherRelatives = typeinfo.Flow{
		Name: "define_other_relatives",
		Lede: "define",
		Terms: []typeinfo.Term{{
			Name:  "relation",
			Label: "relative_to",
			Type:  &rtti.Zt_TextEval,
		}, {
			Name:  "nouns",
			Label: "nouns",
			Type:  &rtti.Zt_TextListEval,
		}, {
			Name:  "other_nouns",
			Label: "other_nouns",
			Type:  &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Relate nouns to each other",
		},
	}
	Zt_SayTemplate = typeinfo.Flow{
		Name: "say_template",
		Lede: "say",
		Terms: []typeinfo.Term{{
			Name: "template",
			Type: &prim.Zt_Lines,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Used for displaying text to the player.", "The text can contain 'inline-templates';", "mini-commands that help to simplify printing text.", "See also: https://github.com/ionous/iffy/wiki/Templates.", "( note: this is transformed for the runtime into an unnamed 'RenderResponse'. )"},
		},
	}
	Zt_SayResponse = typeinfo.Flow{
		Name: "say_response",
		Lede: "say",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "response",
			Type:  &prim.Zt_Text,
		}, {
			Name:  "text",
			Label: "with",
			Type:  &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Generate text in a replaceable manner.", "( note: this is transformed for the runtime into a named 'RenderResponse'. )"},
		},
	}
	Zt_ShuffleText = typeinfo.Flow{
		Name: "shuffle_text",
		Lede: "shuffle_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "When called multiple times returns its inputs at random.",
		},
	}
	Zt_StoppingText = typeinfo.Flow{
		Name: "stopping_text",
		Lede: "stopping_text",
		Terms: []typeinfo.Term{{
			Name:    "parts",
			Repeats: true,
			Type:    &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": "When called multiple times returns each of its inputs in turn, sticking to the last one.",
		},
	}
	Zt_StoryBreak = typeinfo.Flow{
		Name:  "story_break",
		Lede:  "--",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_StoryStatement,
		},
		Markup: map[string]any{
			"comment": []interface{}{"a command with a signature of the comment marker metadata.", "a cheat to allows nodes that have only a comment marker and no actual command.", "see also: debug.do_nothing"},
		},
	}
	Zt_StoryFile = typeinfo.Flow{
		Name: "story_file",
		Lede: "tapestry",
		Terms: []typeinfo.Term{{
			Name:    "story_statements",
			Repeats: true,
			Type:    &Zt_StoryStatement,
		}},
		Markup: map[string]any{
			"blockly-color": "TAP_HUE_ROOT",
			"comment":       "top level node, currently just for blockly might eventually contain story metadata  ex. author, description...",
			"mosaic-root":   true,
		},
	}
	Zt_TextListField = typeinfo.Flow{
		Name: "text_list_field",
		Lede: "text_list",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_TextListEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_TextField = typeinfo.Flow{
		Name: "text_field",
		Lede: "text",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "type",
			Label:    "kind",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}, {
			Name:     "initially",
			Label:    "initially",
			Optional: true,
			Type:     &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
	}
	Zt_NothingField = typeinfo.Flow{
		Name:  "nothing_field",
		Lede:  "nothing",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_FieldDefinition,
		},
		Markup: map[string]any{
			"comment": []interface{}{"A valueless field.", "Intended mainly for patterns which don't need to return a value."},
		},
	}
}
