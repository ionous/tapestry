// Interrogate and manipulate object relationships at runtime.
package rel

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// Return the relative of a noun.
// For example: the right-hand noun in a one-to-one pairing.
type RelativeOf struct {
	RelationName rtti.TextEval
	NounName     rtti.TextEval
	Markup       map[string]any `json:",omitempty"`
}

// relative_of, a type of flow.
var Zt_RelativeOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RelativeOf) TypeInfo() typeinfo.T {
	return &Zt_RelativeOf
}

// Implements [typeinfo.Markup]
func (op *RelativeOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*RelativeOf)(nil)

// Holds a slice of type RelativeOf.
type RelativeOf_Slice []RelativeOf

// Implements [typeinfo.Instance] for a slice of RelativeOf.
func (*RelativeOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_RelativeOf
}

// Implements [typeinfo.Repeats] for a slice of RelativeOf.
func (op *RelativeOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return the relatives of a noun as a list of names.
// For example: the right-hand nouns in a set of one-to-many pairing.
type RelativesOf struct {
	RelationName rtti.TextEval
	NounName     rtti.TextEval
	Markup       map[string]any `json:",omitempty"`
}

// relatives_of, a type of flow.
var Zt_RelativesOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*RelativesOf) TypeInfo() typeinfo.T {
	return &Zt_RelativesOf
}

// Implements [typeinfo.Markup]
func (op *RelativesOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*RelativesOf)(nil)

// Holds a slice of type RelativesOf.
type RelativesOf_Slice []RelativesOf

// Implements [typeinfo.Instance] for a slice of RelativesOf.
func (*RelativesOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_RelativesOf
}

// Implements [typeinfo.Repeats] for a slice of RelativesOf.
func (op *RelativesOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return the implied relative of a noun.
// For example: the left-hand noun in a one-to-many relation.
type ReciprocalOf struct {
	RelationName rtti.TextEval
	NounName     rtti.TextEval
	Markup       map[string]any `json:",omitempty"`
}

// reciprocal_of, a type of flow.
var Zt_ReciprocalOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ReciprocalOf) TypeInfo() typeinfo.T {
	return &Zt_ReciprocalOf
}

// Implements [typeinfo.Markup]
func (op *ReciprocalOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*ReciprocalOf)(nil)

// Holds a slice of type ReciprocalOf.
type ReciprocalOf_Slice []ReciprocalOf

// Implements [typeinfo.Instance] for a slice of ReciprocalOf.
func (*ReciprocalOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_ReciprocalOf
}

// Implements [typeinfo.Repeats] for a slice of ReciprocalOf.
func (op *ReciprocalOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Return the implied relatives of a noun.
// For example: the left-hand nouns in a set of one-to-many pairing.
type ReciprocalsOf struct {
	RelationName rtti.TextEval
	NounName     rtti.TextEval
	Markup       map[string]any `json:",omitempty"`
}

// reciprocals_of, a type of flow.
var Zt_ReciprocalsOf typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ReciprocalsOf) TypeInfo() typeinfo.T {
	return &Zt_ReciprocalsOf
}

// Implements [typeinfo.Markup]
func (op *ReciprocalsOf) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*ReciprocalsOf)(nil)

// Holds a slice of type ReciprocalsOf.
type ReciprocalsOf_Slice []ReciprocalsOf

// Implements [typeinfo.Instance] for a slice of ReciprocalsOf.
func (*ReciprocalsOf_Slice) TypeInfo() typeinfo.T {
	return &Zt_ReciprocalsOf
}

// Implements [typeinfo.Repeats] for a slice of ReciprocalsOf.
func (op *ReciprocalsOf_Slice) Repeats() bool {
	return len(*op) > 0
}

// Relate two nouns.
// Removes any previous pairings that might conflict with this one.
type Relate struct {
	NounName      rtti.TextEval
	OtherNounName rtti.TextEval
	RelationName  rtti.TextEval
	Markup        map[string]any `json:",omitempty"`
}

// relate, a type of flow.
var Zt_Relate typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Relate) TypeInfo() typeinfo.T {
	return &Zt_Relate
}

// Implements [typeinfo.Markup]
func (op *Relate) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*Relate)(nil)

// Holds a slice of type Relate.
type Relate_Slice []Relate

// Implements [typeinfo.Instance] for a slice of Relate.
func (*Relate_Slice) TypeInfo() typeinfo.T {
	return &Zt_Relate
}

// Implements [typeinfo.Repeats] for a slice of Relate.
func (op *Relate_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_RelativeOf = typeinfo.Flow{
		Name: "relative_of",
		Lede: "relative",
		Terms: []typeinfo.Term{{
			Name: "relation_name",
			Markup: map[string]any{
				"comment": "Name of the relation in question.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "noun_name",
			Label: "object",
			Markup: map[string]any{
				"comment": "Name of the left-side noun.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []string{"Return the relative of a noun.", "For example: the right-hand noun in a one-to-one pairing."},
		},
	}
	Zt_RelativesOf = typeinfo.Flow{
		Name: "relatives_of",
		Lede: "relatives",
		Terms: []typeinfo.Term{{
			Name: "relation_name",
			Markup: map[string]any{
				"comment": "Name of the relation in question.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "noun_name",
			Label: "object",
			Markup: map[string]any{
				"comment": "Name of the left-side noun.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"comment": []string{"Return the relatives of a noun as a list of names.", "For example: the right-hand nouns in a set of one-to-many pairing."},
		},
	}
	Zt_ReciprocalOf = typeinfo.Flow{
		Name: "reciprocal_of",
		Lede: "reciprocal",
		Terms: []typeinfo.Term{{
			Name: "relation_name",
			Markup: map[string]any{
				"comment": "Name of the relation in question.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "noun_name",
			Label: "object",
			Markup: map[string]any{
				"comment": "Name of the right-side noun.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"comment": []string{"Return the implied relative of a noun.", "For example: the left-hand noun in a one-to-many relation."},
		},
	}
	Zt_ReciprocalsOf = typeinfo.Flow{
		Name: "reciprocals_of",
		Lede: "reciprocals",
		Terms: []typeinfo.Term{{
			Name: "relation_name",
			Markup: map[string]any{
				"comment": "Name of the relation in question.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "noun_name",
			Label: "object",
			Markup: map[string]any{
				"comment": "Name of the right-side noun.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"comment": []string{"Return the implied relatives of a noun.", "For example: the left-hand nouns in a set of one-to-many pairing."},
		},
	}
	Zt_Relate = typeinfo.Flow{
		Name: "relate",
		Lede: "relate",
		Terms: []typeinfo.Term{{
			Name: "noun_name",
			Markup: map[string]any{
				"comment": "Name of the left-hand noun in the new pairing.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "other_noun_name",
			Label: "to",
			Markup: map[string]any{
				"comment": "Name of the right-hand noun in the new pairing.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "relation_name",
			Label: "via",
			Markup: map[string]any{
				"comment": "Name of the relation in question.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": []string{"Relate two nouns.", "Removes any previous pairings that might conflict with this one."},
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "rel",
	Comment: []string{
		"Interrogate and manipulate object relationships at runtime.",
	},

	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_RelativeOf,
	&Zt_RelativesOf,
	&Zt_ReciprocalOf,
	&Zt_ReciprocalsOf,
	&Zt_Relate,
}

// gob like registration
func Register(reg func(any)) {
	reg((*RelativeOf)(nil))
	reg((*RelativesOf)(nil))
	reg((*ReciprocalOf)(nil))
	reg((*ReciprocalsOf)(nil))
	reg((*Relate)(nil))
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	6987621383789599381:  (*ReciprocalOf)(nil),  /* text_eval=Reciprocal:object: */
	16170704865359856399: (*ReciprocalsOf)(nil), /* text_list_eval=Reciprocals:object: */
	15160920709871392391: (*Relate)(nil),        /* execute=Relate:to:via: */
	14535552277213572673: (*RelativeOf)(nil),    /* text_eval=Relative:object: */
	13180339401044333799: (*RelativesOf)(nil),   /* text_list_eval=Relatives:object: */
}
