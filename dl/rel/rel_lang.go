// Code generated by "makeops"; edit at your own risk.
package rel

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
)

// ReciprocalOf Returns the implied relative of a noun (ex. the source in a one-to-many relation.)
type ReciprocalOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*ReciprocalOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ReciprocalOf,
		Uses: "flow",
		Lede: "reciprocal",
	}
}

var Type_ReciprocalOf = "reciprocal_of"

func (op *ReciprocalOf) MarshalJSON() (ret []byte, err error) {
	if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ReciprocalOf,
			Value: map[string]json.RawMessage{
				"$VIA":    jsonVia,
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *ReciprocalOf) MarshalJSONVia() (ret []byte, err error) {
	ret, err = op.Via.MarshalJSON()
	return
}

func (op *ReciprocalOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// ReciprocalsOf Returns the implied relative of a noun (ex. the sources of a many-to-many relation.)
type ReciprocalsOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*ReciprocalsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ReciprocalsOf,
		Uses: "flow",
		Lede: "reciprocals",
	}
}

var Type_ReciprocalsOf = "reciprocals_of"

func (op *ReciprocalsOf) MarshalJSON() (ret []byte, err error) {
	if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ReciprocalsOf,
			Value: map[string]json.RawMessage{
				"$VIA":    jsonVia,
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *ReciprocalsOf) MarshalJSONVia() (ret []byte, err error) {
	ret, err = op.Via.MarshalJSON()
	return
}

func (op *ReciprocalsOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// Relate Relate two nouns.
type Relate struct {
	Object   rt.TextEval        `if:"label=_"`
	ToObject rt.TextEval        `if:"label=to"`
	Via      value.RelationName `if:"label=via"`
}

func (*Relate) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Relate,
		Uses: "flow",
	}
}

var Type_Relate = "relate"

func (op *Relate) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonToObject, e := op.MarshalJSONToObject(); e != nil {
		err = e
	} else if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Relate,
			Value: map[string]json.RawMessage{
				"$OBJECT":    jsonObject,
				"$TO_OBJECT": jsonToObject,
				"$VIA":       jsonVia,
			},
		})
	}
	return
}

func (op *Relate) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *Relate) MarshalJSONToObject() (ret []byte, err error) {
	if v, e := op.ToObject.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

func (op *Relate) MarshalJSONVia() (ret []byte, err error) {
	ret, err = op.Via.MarshalJSON()
	return
}

// RelativeOf Returns the relative of a noun (ex. the target of a one-to-one relation.)
type RelativeOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*RelativeOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RelativeOf,
		Uses: "flow",
		Lede: "relative",
	}
}

var Type_RelativeOf = "relative_of"

func (op *RelativeOf) MarshalJSON() (ret []byte, err error) {
	if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RelativeOf,
			Value: map[string]json.RawMessage{
				"$VIA":    jsonVia,
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *RelativeOf) MarshalJSONVia() (ret []byte, err error) {
	ret, err = op.Via.MarshalJSON()
	return
}

func (op *RelativeOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

// RelativesOf Returns the relatives of a noun as a list of names (ex. the targets of one-to-many relation).
type RelativesOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*RelativesOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RelativesOf,
		Uses: "flow",
		Lede: "relatives",
	}
}

var Type_RelativesOf = "relatives_of"

func (op *RelativesOf) MarshalJSON() (ret []byte, err error) {
	if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RelativesOf,
			Value: map[string]json.RawMessage{
				"$VIA":    jsonVia,
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *RelativesOf) MarshalJSONVia() (ret []byte, err error) {
	ret, err = op.Via.MarshalJSON()
	return
}

func (op *RelativesOf) MarshalJSONObject() (ret []byte, err error) {
	if v, e := op.Object.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextEval,
			Value: v,
		})
	}
	return
}

var Slats = []composer.Composer{
	(*ReciprocalOf)(nil),
	(*ReciprocalsOf)(nil),
	(*Relate)(nil),
	(*RelativeOf)(nil),
	(*RelativesOf)(nil),
}
