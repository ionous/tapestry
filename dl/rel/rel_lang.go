// Code generated by "makeops"; edit at your own risk.
package rel

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// ReciprocalOf Returns the implied relative of a noun (ex. the source in a one-to-many relation.)
type ReciprocalOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*ReciprocalOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "reciprocal_of",
		Uses: "flow",
		Lede: "reciprocal",
	}
}

func (op *ReciprocalOf) MarshalJSON() (ret []byte, err error) {
	if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "reciprocal_of",
			"value": map[string]json.RawMessage{
				"$VIA":    jsonVia,
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *ReciprocalOf) MarshalJSONVia() ([]byte, error) {
	return op.Via.MarshalJSON()
}

func (op *ReciprocalOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// ReciprocalsOf Returns the implied relative of a noun (ex. the sources of a many-to-many relation.)
type ReciprocalsOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*ReciprocalsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "reciprocals_of",
		Uses: "flow",
		Lede: "reciprocals",
	}
}

func (op *ReciprocalsOf) MarshalJSON() (ret []byte, err error) {
	if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "reciprocals_of",
			"value": map[string]json.RawMessage{
				"$VIA":    jsonVia,
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *ReciprocalsOf) MarshalJSONVia() ([]byte, error) {
	return op.Via.MarshalJSON()
}

func (op *ReciprocalsOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// Relate Relate two nouns.
type Relate struct {
	Object   rt.TextEval        `if:"label=_"`
	ToObject rt.TextEval        `if:"label=to"`
	Via      value.RelationName `if:"label=via"`
}

func (*Relate) Compose() composer.Spec {
	return composer.Spec{
		Name: "relate",
		Uses: "flow",
	}
}

func (op *Relate) MarshalJSON() (ret []byte, err error) {
	if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else if jsonToObject, e := op.MarshalJSONToObject(); e != nil {
		err = e
	} else if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "relate",
			"value": map[string]json.RawMessage{
				"$OBJECT":    jsonObject,
				"$TO_OBJECT": jsonToObject,
				"$VIA":       jsonVia,
			},
		})
	}
	return
}

func (op *Relate) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *Relate) MarshalJSONToObject() ([]byte, error) {
	m := op.ToObject.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *Relate) MarshalJSONVia() ([]byte, error) {
	return op.Via.MarshalJSON()
}

// RelativeOf Returns the relative of a noun (ex. the target of a one-to-one relation.)
type RelativeOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*RelativeOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "relative_of",
		Uses: "flow",
		Lede: "relative",
	}
}

func (op *RelativeOf) MarshalJSON() (ret []byte, err error) {
	if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "relative_of",
			"value": map[string]json.RawMessage{
				"$VIA":    jsonVia,
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *RelativeOf) MarshalJSONVia() ([]byte, error) {
	return op.Via.MarshalJSON()
}

func (op *RelativeOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

// RelativesOf Returns the relatives of a noun as a list of names (ex. the targets of one-to-many relation).
type RelativesOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*RelativesOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "relatives_of",
		Uses: "flow",
		Lede: "relatives",
	}
}

func (op *RelativesOf) MarshalJSON() (ret []byte, err error) {
	if jsonVia, e := op.MarshalJSONVia(); e != nil {
		err = e
	} else if jsonObject, e := op.MarshalJSONObject(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "relatives_of",
			"value": map[string]json.RawMessage{
				"$VIA":    jsonVia,
				"$OBJECT": jsonObject,
			},
		})
	}
	return
}

func (op *RelativesOf) MarshalJSONVia() ([]byte, error) {
	return op.Via.MarshalJSON()
}

func (op *RelativesOf) MarshalJSONObject() ([]byte, error) {
	m := op.Object.(json.Marshaler)
	return m.MarshalJSON()
}

var Slats = []composer.Composer{
	(*ReciprocalOf)(nil),
	(*ReciprocalsOf)(nil),
	(*Relate)(nil),
	(*RelativeOf)(nil),
	(*RelativesOf)(nil),
}
