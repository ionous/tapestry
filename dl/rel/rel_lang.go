// Code generated by "makeops"; edit at your own risk.
package rel

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/jsn"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// ReciprocalOf Returns the implied relative of a noun (ex. the source in a one-to-many relation.)
// User implements: TextEval.
type ReciprocalOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*ReciprocalOf) Compose() composer.Spec {
	return composer.Spec{
		Name: ReciprocalOf_Type,
		Uses: composer.Type_Flow,
		Lede: "reciprocal",
	}
}

const ReciprocalOf_Type = "reciprocal_of"

const ReciprocalOf_Field_Via = "$VIA"
const ReciprocalOf_Field_Object = "$OBJECT"

func (op *ReciprocalOf) Marshal(m jsn.Marshaler) error {
	return ReciprocalOf_Marshal(m, op)
}

type ReciprocalOf_Slice []ReciprocalOf

func (op *ReciprocalOf_Slice) GetType() string {
	return ReciprocalOf_Type
}

func (op *ReciprocalOf_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ReciprocalOf_Slice) SetSize(cnt int) {
	var els []ReciprocalOf
	if cnt >= 0 {
		els = make(ReciprocalOf_Slice, cnt)
	}
	(*op) = els
}

func (op *ReciprocalOf_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ReciprocalOf_Marshal(m, &(*op)[i])
}

func ReciprocalOf_Repeats_Marshal(m jsn.Marshaler, vals *[]ReciprocalOf) error {
	return jsn.RepeatBlock(m, (*ReciprocalOf_Slice)(vals))
}

func ReciprocalOf_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ReciprocalOf) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ReciprocalOf_Repeats_Marshal(m, pv)
	}
	return
}

func ReciprocalOf_Optional_Marshal(m jsn.Marshaler, pv **ReciprocalOf) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ReciprocalOf_Marshal(m, *pv)
	} else if !enc {
		var v ReciprocalOf
		if err = ReciprocalOf_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ReciprocalOf_Marshal(m jsn.Marshaler, val *ReciprocalOf) (err error) {
	if err = m.MarshalBlock(jsn.MakeFlow("reciprocal", ReciprocalOf_Type, val)); err == nil {
		e0 := m.MarshalKey("", ReciprocalOf_Field_Via)
		if e0 == nil {
			e0 = value.RelationName_Marshal(m, &val.Via)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ReciprocalOf_Field_Via))
		}
		e1 := m.MarshalKey("object", ReciprocalOf_Field_Object)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Object)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ReciprocalOf_Field_Object))
		}
		m.EndBlock()
	}
	return
}

// ReciprocalsOf Returns the implied relative of a noun (ex. the sources of a many-to-many relation.)
// User implements: TextListEval.
type ReciprocalsOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*ReciprocalsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: ReciprocalsOf_Type,
		Uses: composer.Type_Flow,
		Lede: "reciprocals",
	}
}

const ReciprocalsOf_Type = "reciprocals_of"

const ReciprocalsOf_Field_Via = "$VIA"
const ReciprocalsOf_Field_Object = "$OBJECT"

func (op *ReciprocalsOf) Marshal(m jsn.Marshaler) error {
	return ReciprocalsOf_Marshal(m, op)
}

type ReciprocalsOf_Slice []ReciprocalsOf

func (op *ReciprocalsOf_Slice) GetType() string {
	return ReciprocalsOf_Type
}

func (op *ReciprocalsOf_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ReciprocalsOf_Slice) SetSize(cnt int) {
	var els []ReciprocalsOf
	if cnt >= 0 {
		els = make(ReciprocalsOf_Slice, cnt)
	}
	(*op) = els
}

func (op *ReciprocalsOf_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ReciprocalsOf_Marshal(m, &(*op)[i])
}

func ReciprocalsOf_Repeats_Marshal(m jsn.Marshaler, vals *[]ReciprocalsOf) error {
	return jsn.RepeatBlock(m, (*ReciprocalsOf_Slice)(vals))
}

func ReciprocalsOf_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ReciprocalsOf) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ReciprocalsOf_Repeats_Marshal(m, pv)
	}
	return
}

func ReciprocalsOf_Optional_Marshal(m jsn.Marshaler, pv **ReciprocalsOf) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ReciprocalsOf_Marshal(m, *pv)
	} else if !enc {
		var v ReciprocalsOf
		if err = ReciprocalsOf_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ReciprocalsOf_Marshal(m jsn.Marshaler, val *ReciprocalsOf) (err error) {
	if err = m.MarshalBlock(jsn.MakeFlow("reciprocals", ReciprocalsOf_Type, val)); err == nil {
		e0 := m.MarshalKey("", ReciprocalsOf_Field_Via)
		if e0 == nil {
			e0 = value.RelationName_Marshal(m, &val.Via)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ReciprocalsOf_Field_Via))
		}
		e1 := m.MarshalKey("object", ReciprocalsOf_Field_Object)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Object)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ReciprocalsOf_Field_Object))
		}
		m.EndBlock()
	}
	return
}

// Relate Relate two nouns.
// User implements: Execute.
type Relate struct {
	Object   rt.TextEval        `if:"label=_"`
	ToObject rt.TextEval        `if:"label=to"`
	Via      value.RelationName `if:"label=via"`
}

func (*Relate) Compose() composer.Spec {
	return composer.Spec{
		Name: Relate_Type,
		Uses: composer.Type_Flow,
	}
}

const Relate_Type = "relate"

const Relate_Field_Object = "$OBJECT"
const Relate_Field_ToObject = "$TO_OBJECT"
const Relate_Field_Via = "$VIA"

func (op *Relate) Marshal(m jsn.Marshaler) error {
	return Relate_Marshal(m, op)
}

type Relate_Slice []Relate

func (op *Relate_Slice) GetType() string {
	return Relate_Type
}

func (op *Relate_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Relate_Slice) SetSize(cnt int) {
	var els []Relate
	if cnt >= 0 {
		els = make(Relate_Slice, cnt)
	}
	(*op) = els
}

func (op *Relate_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Relate_Marshal(m, &(*op)[i])
}

func Relate_Repeats_Marshal(m jsn.Marshaler, vals *[]Relate) error {
	return jsn.RepeatBlock(m, (*Relate_Slice)(vals))
}

func Relate_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Relate) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = Relate_Repeats_Marshal(m, pv)
	}
	return
}

func Relate_Optional_Marshal(m jsn.Marshaler, pv **Relate) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Relate_Marshal(m, *pv)
	} else if !enc {
		var v Relate
		if err = Relate_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Relate_Marshal(m jsn.Marshaler, val *Relate) (err error) {
	if err = m.MarshalBlock(jsn.MakeFlow(Relate_Type, Relate_Type, val)); err == nil {
		e0 := m.MarshalKey("", Relate_Field_Object)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Object)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Relate_Field_Object))
		}
		e1 := m.MarshalKey("to", Relate_Field_ToObject)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.ToObject)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Relate_Field_ToObject))
		}
		e2 := m.MarshalKey("via", Relate_Field_Via)
		if e2 == nil {
			e2 = value.RelationName_Marshal(m, &val.Via)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Relate_Field_Via))
		}
		m.EndBlock()
	}
	return
}

// RelativeOf Returns the relative of a noun (ex. the target of a one-to-one relation.)
// User implements: TextEval.
type RelativeOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*RelativeOf) Compose() composer.Spec {
	return composer.Spec{
		Name: RelativeOf_Type,
		Uses: composer.Type_Flow,
		Lede: "relative",
	}
}

const RelativeOf_Type = "relative_of"

const RelativeOf_Field_Via = "$VIA"
const RelativeOf_Field_Object = "$OBJECT"

func (op *RelativeOf) Marshal(m jsn.Marshaler) error {
	return RelativeOf_Marshal(m, op)
}

type RelativeOf_Slice []RelativeOf

func (op *RelativeOf_Slice) GetType() string {
	return RelativeOf_Type
}

func (op *RelativeOf_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *RelativeOf_Slice) SetSize(cnt int) {
	var els []RelativeOf
	if cnt >= 0 {
		els = make(RelativeOf_Slice, cnt)
	}
	(*op) = els
}

func (op *RelativeOf_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return RelativeOf_Marshal(m, &(*op)[i])
}

func RelativeOf_Repeats_Marshal(m jsn.Marshaler, vals *[]RelativeOf) error {
	return jsn.RepeatBlock(m, (*RelativeOf_Slice)(vals))
}

func RelativeOf_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]RelativeOf) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = RelativeOf_Repeats_Marshal(m, pv)
	}
	return
}

func RelativeOf_Optional_Marshal(m jsn.Marshaler, pv **RelativeOf) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = RelativeOf_Marshal(m, *pv)
	} else if !enc {
		var v RelativeOf
		if err = RelativeOf_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func RelativeOf_Marshal(m jsn.Marshaler, val *RelativeOf) (err error) {
	if err = m.MarshalBlock(jsn.MakeFlow("relative", RelativeOf_Type, val)); err == nil {
		e0 := m.MarshalKey("", RelativeOf_Field_Via)
		if e0 == nil {
			e0 = value.RelationName_Marshal(m, &val.Via)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", RelativeOf_Field_Via))
		}
		e1 := m.MarshalKey("object", RelativeOf_Field_Object)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Object)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", RelativeOf_Field_Object))
		}
		m.EndBlock()
	}
	return
}

// RelativesOf Returns the relatives of a noun as a list of names (ex. the targets of one-to-many relation).
// User implements: TextListEval.
type RelativesOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*RelativesOf) Compose() composer.Spec {
	return composer.Spec{
		Name: RelativesOf_Type,
		Uses: composer.Type_Flow,
		Lede: "relatives",
	}
}

const RelativesOf_Type = "relatives_of"

const RelativesOf_Field_Via = "$VIA"
const RelativesOf_Field_Object = "$OBJECT"

func (op *RelativesOf) Marshal(m jsn.Marshaler) error {
	return RelativesOf_Marshal(m, op)
}

type RelativesOf_Slice []RelativesOf

func (op *RelativesOf_Slice) GetType() string {
	return RelativesOf_Type
}

func (op *RelativesOf_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *RelativesOf_Slice) SetSize(cnt int) {
	var els []RelativesOf
	if cnt >= 0 {
		els = make(RelativesOf_Slice, cnt)
	}
	(*op) = els
}

func (op *RelativesOf_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return RelativesOf_Marshal(m, &(*op)[i])
}

func RelativesOf_Repeats_Marshal(m jsn.Marshaler, vals *[]RelativesOf) error {
	return jsn.RepeatBlock(m, (*RelativesOf_Slice)(vals))
}

func RelativesOf_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]RelativesOf) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = RelativesOf_Repeats_Marshal(m, pv)
	}
	return
}

func RelativesOf_Optional_Marshal(m jsn.Marshaler, pv **RelativesOf) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = RelativesOf_Marshal(m, *pv)
	} else if !enc {
		var v RelativesOf
		if err = RelativesOf_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func RelativesOf_Marshal(m jsn.Marshaler, val *RelativesOf) (err error) {
	if err = m.MarshalBlock(jsn.MakeFlow("relatives", RelativesOf_Type, val)); err == nil {
		e0 := m.MarshalKey("", RelativesOf_Field_Via)
		if e0 == nil {
			e0 = value.RelationName_Marshal(m, &val.Via)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", RelativesOf_Field_Via))
		}
		e1 := m.MarshalKey("object", RelativesOf_Field_Object)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Object)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", RelativesOf_Field_Object))
		}
		m.EndBlock()
	}
	return
}

var Slats = []composer.Composer{
	(*ReciprocalOf)(nil),
	(*ReciprocalsOf)(nil),
	(*Relate)(nil),
	(*RelativeOf)(nil),
	(*RelativesOf)(nil),
}

var Signatures = map[uint64]interface{}{
	9593459146430787736:  (*ReciprocalOf)(nil),  /* Reciprocal:object: */
	8613133962478128719:  (*ReciprocalsOf)(nil), /* Reciprocals:object: */
	13617100648357099813: (*Relate)(nil),        /* Relate:to:via: */
	15662328102744254368: (*RelativeOf)(nil),    /* Relative:object: */
	3656291671001137447:  (*RelativesOf)(nil),   /* Relatives:object: */
}
