// Code generated by "makeops"; edit at your own risk.
package rel

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// ReciprocalOf Returns the implied relative of a noun (ex. the source in a one-to-many relation.)
type ReciprocalOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*ReciprocalOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ReciprocalOf,
		Uses: composer.Type_Flow,
		Lede: "reciprocal",
	}
}

const Type_ReciprocalOf = "reciprocal_of"
const ReciprocalOf_Via = "$VIA"
const ReciprocalOf_Object = "$OBJECT"

func (op *ReciprocalOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ReciprocalOf_Detailed_Marshal(n, op)
}
func (op *ReciprocalOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ReciprocalOf_Detailed_Unmarshal(n, b, op)
}

func ReciprocalOf_Detailed_Marshal(n jsonexp.Context, val *ReciprocalOf) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.RelationName_Detailed_Marshal(n, &val.Via); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ReciprocalOf_Via] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ReciprocalOf_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ReciprocalOf,
			Fields: fields,
		})
	}
	return
}

func ReciprocalOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ReciprocalOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ReciprocalOf, "-", e)
	} else if e := value.RelationName_Detailed_Unmarshal(n, msg.Fields[ReciprocalOf_Via], &out.Via); e != nil {
		err = errutil.New(Type_ReciprocalOf+"."+ReciprocalOf_Via, "-", e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[ReciprocalOf_Object], &out.Object); e != nil {
		err = errutil.New(Type_ReciprocalOf+"."+ReciprocalOf_Object, "-", e)
	}
	return
}

func ReciprocalOf_Detailed_Optional_Marshal(n jsonexp.Context, val **ReciprocalOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ReciprocalOf_Detailed_Marshal(n, ptr)
	}
	return
}
func ReciprocalOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ReciprocalOf) (err error) {
	if len(b) > 0 {
		var el ReciprocalOf
		if e := ReciprocalOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_ReciprocalOf, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// ReciprocalsOf Returns the implied relative of a noun (ex. the sources of a many-to-many relation.)
type ReciprocalsOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*ReciprocalsOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ReciprocalsOf,
		Uses: composer.Type_Flow,
		Lede: "reciprocals",
	}
}

const Type_ReciprocalsOf = "reciprocals_of"
const ReciprocalsOf_Via = "$VIA"
const ReciprocalsOf_Object = "$OBJECT"

func (op *ReciprocalsOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ReciprocalsOf_Detailed_Marshal(n, op)
}
func (op *ReciprocalsOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ReciprocalsOf_Detailed_Unmarshal(n, b, op)
}

func ReciprocalsOf_Detailed_Marshal(n jsonexp.Context, val *ReciprocalsOf) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.RelationName_Detailed_Marshal(n, &val.Via); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ReciprocalsOf_Via] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ReciprocalsOf_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ReciprocalsOf,
			Fields: fields,
		})
	}
	return
}

func ReciprocalsOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ReciprocalsOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ReciprocalsOf, "-", e)
	} else if e := value.RelationName_Detailed_Unmarshal(n, msg.Fields[ReciprocalsOf_Via], &out.Via); e != nil {
		err = errutil.New(Type_ReciprocalsOf+"."+ReciprocalsOf_Via, "-", e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[ReciprocalsOf_Object], &out.Object); e != nil {
		err = errutil.New(Type_ReciprocalsOf+"."+ReciprocalsOf_Object, "-", e)
	}
	return
}

func ReciprocalsOf_Detailed_Optional_Marshal(n jsonexp.Context, val **ReciprocalsOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ReciprocalsOf_Detailed_Marshal(n, ptr)
	}
	return
}
func ReciprocalsOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ReciprocalsOf) (err error) {
	if len(b) > 0 {
		var el ReciprocalsOf
		if e := ReciprocalsOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_ReciprocalsOf, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Relate Relate two nouns.
type Relate struct {
	Object   rt.TextEval        `if:"label=_"`
	ToObject rt.TextEval        `if:"label=to"`
	Via      value.RelationName `if:"label=via"`
}

func (*Relate) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Relate,
		Uses: composer.Type_Flow,
	}
}

const Type_Relate = "relate"
const Relate_Object = "$OBJECT"
const Relate_ToObject = "$TO_OBJECT"
const Relate_Via = "$VIA"

func (op *Relate) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Relate_Detailed_Marshal(n, op)
}
func (op *Relate) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Relate_Detailed_Unmarshal(n, b, op)
}

func Relate_Detailed_Marshal(n jsonexp.Context, val *Relate) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Relate_Object] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.ToObject); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Relate_ToObject] = b
	}
	if b, e := value.RelationName_Detailed_Marshal(n, &val.Via); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Relate_Via] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Relate,
			Fields: fields,
		})
	}
	return
}

func Relate_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Relate) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Relate, "-", e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Relate_Object], &out.Object); e != nil {
		err = errutil.New(Type_Relate+"."+Relate_Object, "-", e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[Relate_ToObject], &out.ToObject); e != nil {
		err = errutil.New(Type_Relate+"."+Relate_ToObject, "-", e)
	} else if e := value.RelationName_Detailed_Unmarshal(n, msg.Fields[Relate_Via], &out.Via); e != nil {
		err = errutil.New(Type_Relate+"."+Relate_Via, "-", e)
	}
	return
}

func Relate_Detailed_Optional_Marshal(n jsonexp.Context, val **Relate) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Relate_Detailed_Marshal(n, ptr)
	}
	return
}
func Relate_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Relate) (err error) {
	if len(b) > 0 {
		var el Relate
		if e := Relate_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Relate, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// RelativeOf Returns the relative of a noun (ex. the target of a one-to-one relation.)
type RelativeOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*RelativeOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RelativeOf,
		Uses: composer.Type_Flow,
		Lede: "relative",
	}
}

const Type_RelativeOf = "relative_of"
const RelativeOf_Via = "$VIA"
const RelativeOf_Object = "$OBJECT"

func (op *RelativeOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RelativeOf_Detailed_Marshal(n, op)
}
func (op *RelativeOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RelativeOf_Detailed_Unmarshal(n, b, op)
}

func RelativeOf_Detailed_Marshal(n jsonexp.Context, val *RelativeOf) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.RelationName_Detailed_Marshal(n, &val.Via); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RelativeOf_Via] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RelativeOf_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_RelativeOf,
			Fields: fields,
		})
	}
	return
}

func RelativeOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RelativeOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RelativeOf, "-", e)
	} else if e := value.RelationName_Detailed_Unmarshal(n, msg.Fields[RelativeOf_Via], &out.Via); e != nil {
		err = errutil.New(Type_RelativeOf+"."+RelativeOf_Via, "-", e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[RelativeOf_Object], &out.Object); e != nil {
		err = errutil.New(Type_RelativeOf+"."+RelativeOf_Object, "-", e)
	}
	return
}

func RelativeOf_Detailed_Optional_Marshal(n jsonexp.Context, val **RelativeOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = RelativeOf_Detailed_Marshal(n, ptr)
	}
	return
}
func RelativeOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **RelativeOf) (err error) {
	if len(b) > 0 {
		var el RelativeOf
		if e := RelativeOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_RelativeOf, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// RelativesOf Returns the relatives of a noun as a list of names (ex. the targets of one-to-many relation).
type RelativesOf struct {
	Via    value.RelationName `if:"label=_"`
	Object rt.TextEval        `if:"label=object"`
}

func (*RelativesOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RelativesOf,
		Uses: composer.Type_Flow,
		Lede: "relatives",
	}
}

const Type_RelativesOf = "relatives_of"
const RelativesOf_Via = "$VIA"
const RelativesOf_Object = "$OBJECT"

func (op *RelativesOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RelativesOf_Detailed_Marshal(n, op)
}
func (op *RelativesOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RelativesOf_Detailed_Unmarshal(n, b, op)
}

func RelativesOf_Detailed_Marshal(n jsonexp.Context, val *RelativesOf) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.RelationName_Detailed_Marshal(n, &val.Via); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RelativesOf_Via] = b
	}
	if b, e := rt.TextEval_Detailed_Marshal(n, &val.Object); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RelativesOf_Object] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_RelativesOf,
			Fields: fields,
		})
	}
	return
}

func RelativesOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RelativesOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RelativesOf, "-", e)
	} else if e := value.RelationName_Detailed_Unmarshal(n, msg.Fields[RelativesOf_Via], &out.Via); e != nil {
		err = errutil.New(Type_RelativesOf+"."+RelativesOf_Via, "-", e)
	} else if e := rt.TextEval_Detailed_Unmarshal(n, msg.Fields[RelativesOf_Object], &out.Object); e != nil {
		err = errutil.New(Type_RelativesOf+"."+RelativesOf_Object, "-", e)
	}
	return
}

func RelativesOf_Detailed_Optional_Marshal(n jsonexp.Context, val **RelativesOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = RelativesOf_Detailed_Marshal(n, ptr)
	}
	return
}
func RelativesOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **RelativesOf) (err error) {
	if len(b) > 0 {
		var el RelativesOf
		if e := RelativesOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_RelativesOf, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

var Slats = []composer.Composer{
	(*ReciprocalOf)(nil),
	(*ReciprocalsOf)(nil),
	(*Relate)(nil),
	(*RelativeOf)(nil),
	(*RelativesOf)(nil),
}
