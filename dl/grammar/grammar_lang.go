// Code generated by "makeops"; edit at your own risk.
package grammar

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"github.com/ionous/errutil"
)

// Action makes a parser scanner producing a script defined action.
type Action struct {
	Action string `if:"label=_,type=text"`
}

func (*Action) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Action,
		Uses: composer.Type_Flow,
		Lede: "as",
	}
}

const Type_Action = "action"
const Action_Action = "$ACTION"

func (op *Action) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Action_Detailed_Marshal(n, op)
}
func (op *Action) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Action_Detailed_Unmarshal(n, b, op)
}

func Action_Detailed_Marshal(n jsonexp.Context, val *Action) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Action); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Action_Action] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Action,
			Fields: fields,
		})
	}
	return
}

func Action_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Action) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Action, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Action_Action], &out.Action); e != nil {
		err = errutil.New(Type_Action+"."+Action_Action, "-", e)
	}
	return
}

func Action_Detailed_Optional_Marshal(n jsonexp.Context, val **Action) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Action_Detailed_Marshal(n, ptr)
	}
	return
}
func Action_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Action) (err error) {
	if len(b) > 0 {
		var el Action
		if e := Action_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Action, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Alias allows the user to refer to a noun by one or more other terms.
type Alias struct {
	Names  []string `if:"label=_,type=text"`
	AsNoun string   `if:"label=as_noun,type=text"`
}

func (*Alias) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Alias,
		Uses: composer.Type_Flow,
	}
}

const Type_Alias = "alias"
const Alias_Names = "$NAMES"
const Alias_AsNoun = "$AS_NOUN"

func (op *Alias) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Alias_Detailed_Marshal(n, op)
}
func (op *Alias) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Alias_Detailed_Unmarshal(n, b, op)
}

func Alias_Detailed_Marshal(n jsonexp.Context, val *Alias) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Repeats_Marshal(n, &val.Names); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Alias_Names] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.AsNoun); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Alias_AsNoun] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Alias,
			Fields: fields,
		})
	}
	return
}

func Alias_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Alias) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Alias, "-", e)
	} else if e := value.Text_Detailed_Override_Repeats_Unmarshal(n, msg.Fields[Alias_Names], &out.Names); e != nil {
		err = errutil.New(Type_Alias+"."+Alias_Names, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Alias_AsNoun], &out.AsNoun); e != nil {
		err = errutil.New(Type_Alias+"."+Alias_AsNoun, "-", e)
	}
	return
}

func Alias_Detailed_Optional_Marshal(n jsonexp.Context, val **Alias) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Alias_Detailed_Marshal(n, ptr)
	}
	return
}
func Alias_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Alias) (err error) {
	if len(b) > 0 {
		var el Alias
		if e := Alias_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Alias, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// AllOf makes a parser scanner
type AllOf struct {
	Series []ScannerMaker `if:"label=_"`
}

func (*AllOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AllOf,
		Uses: composer.Type_Flow,
	}
}

const Type_AllOf = "all_of"
const AllOf_Series = "$SERIES"

func (op *AllOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AllOf_Detailed_Marshal(n, op)
}
func (op *AllOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AllOf_Detailed_Unmarshal(n, b, op)
}

func AllOf_Detailed_Marshal(n jsonexp.Context, val *AllOf) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ScannerMaker_Detailed_Repeats_Marshal(n, &val.Series); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AllOf_Series] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AllOf,
			Fields: fields,
		})
	}
	return
}

func AllOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AllOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_AllOf, "-", e)
	} else if e := ScannerMaker_Detailed_Repeats_Unmarshal(n, msg.Fields[AllOf_Series], &out.Series); e != nil {
		err = errutil.New(Type_AllOf+"."+AllOf_Series, "-", e)
	}
	return
}

func AllOf_Detailed_Optional_Marshal(n jsonexp.Context, val **AllOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = AllOf_Detailed_Marshal(n, ptr)
	}
	return
}
func AllOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AllOf) (err error) {
	if len(b) > 0 {
		var el AllOf
		if e := AllOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_AllOf, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// AnyOf makes a parser scanner
type AnyOf struct {
	Options []ScannerMaker `if:"label=_"`
}

func (*AnyOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AnyOf,
		Uses: composer.Type_Flow,
	}
}

const Type_AnyOf = "any_of"
const AnyOf_Options = "$OPTIONS"

func (op *AnyOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AnyOf_Detailed_Marshal(n, op)
}
func (op *AnyOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AnyOf_Detailed_Unmarshal(n, b, op)
}

func AnyOf_Detailed_Marshal(n jsonexp.Context, val *AnyOf) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ScannerMaker_Detailed_Repeats_Marshal(n, &val.Options); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AnyOf_Options] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AnyOf,
			Fields: fields,
		})
	}
	return
}

func AnyOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AnyOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_AnyOf, "-", e)
	} else if e := ScannerMaker_Detailed_Repeats_Unmarshal(n, msg.Fields[AnyOf_Options], &out.Options); e != nil {
		err = errutil.New(Type_AnyOf+"."+AnyOf_Options, "-", e)
	}
	return
}

func AnyOf_Detailed_Optional_Marshal(n jsonexp.Context, val **AnyOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = AnyOf_Detailed_Marshal(n, ptr)
	}
	return
}
func AnyOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AnyOf) (err error) {
	if len(b) > 0 {
		var el AnyOf
		if e := AnyOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_AnyOf, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Directive starts a parser scanner
type Directive struct {
	Lede  []string       `if:"label=_,type=text"`
	Scans []ScannerMaker `if:"label=scans"`
}

func (*Directive) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Directive,
		Uses: composer.Type_Flow,
	}
}

const Type_Directive = "directive"
const Directive_Lede = "$LEDE"
const Directive_Scans = "$SCANS"

func (op *Directive) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Directive_Detailed_Marshal(n, op)
}
func (op *Directive) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Directive_Detailed_Unmarshal(n, b, op)
}

func Directive_Detailed_Marshal(n jsonexp.Context, val *Directive) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Repeats_Marshal(n, &val.Lede); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Directive_Lede] = b
	}
	if b, e := ScannerMaker_Detailed_Repeats_Marshal(n, &val.Scans); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Directive_Scans] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Directive,
			Fields: fields,
		})
	}
	return
}

func Directive_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Directive) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Directive, "-", e)
	} else if e := value.Text_Detailed_Override_Repeats_Unmarshal(n, msg.Fields[Directive_Lede], &out.Lede); e != nil {
		err = errutil.New(Type_Directive+"."+Directive_Lede, "-", e)
	} else if e := ScannerMaker_Detailed_Repeats_Unmarshal(n, msg.Fields[Directive_Scans], &out.Scans); e != nil {
		err = errutil.New(Type_Directive+"."+Directive_Scans, "-", e)
	}
	return
}

func Directive_Detailed_Optional_Marshal(n jsonexp.Context, val **Directive) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Directive_Detailed_Marshal(n, ptr)
	}
	return
}
func Directive_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Directive) (err error) {
	if len(b) > 0 {
		var el Directive
		if e := Directive_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Directive, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Grammar Read what the player types and turn it into actions.
type Grammar struct {
	Grammar GrammarMaker `if:"label=_"`
}

func (*Grammar) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Grammar,
		Uses: composer.Type_Flow,
	}
}

const Type_Grammar = "grammar"
const Grammar_Grammar = "$GRAMMAR"

func (op *Grammar) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Grammar_Detailed_Marshal(n, op)
}
func (op *Grammar) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Grammar_Detailed_Unmarshal(n, b, op)
}

func Grammar_Detailed_Marshal(n jsonexp.Context, val *Grammar) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := GrammarMaker_Detailed_Marshal(n, &val.Grammar); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Grammar_Grammar] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Grammar,
			Fields: fields,
		})
	}
	return
}

func Grammar_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Grammar) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Grammar, "-", e)
	} else if e := GrammarMaker_Detailed_Unmarshal(n, msg.Fields[Grammar_Grammar], &out.Grammar); e != nil {
		err = errutil.New(Type_Grammar+"."+Grammar_Grammar, "-", e)
	}
	return
}

func Grammar_Detailed_Optional_Marshal(n jsonexp.Context, val **Grammar) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Grammar_Detailed_Marshal(n, ptr)
	}
	return
}
func Grammar_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Grammar) (err error) {
	if len(b) > 0 {
		var el Grammar
		if e := Grammar_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Grammar, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_GrammarMaker = "grammar_maker"

func GrammarMaker_Detailed_Marshal(n jsonexp.Context, ptr *GrammarMaker) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_GrammarMaker,
			Value: b,
		})
	}
	return
}

func GrammarMaker_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *GrammarMaker) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(GrammarMaker); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_GrammarMaker)
	} else {
		(*out) = store
	}
	return
}

// Noun makes a parser scanner
type Noun struct {
	Kind string `if:"label=_,type=text"`
}

func (*Noun) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Noun,
		Uses: composer.Type_Flow,
	}
}

const Type_Noun = "noun"
const Noun_Kind = "$KIND"

func (op *Noun) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Noun_Detailed_Marshal(n, op)
}
func (op *Noun) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Noun_Detailed_Unmarshal(n, b, op)
}

func Noun_Detailed_Marshal(n jsonexp.Context, val *Noun) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Noun_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Noun,
			Fields: fields,
		})
	}
	return
}

func Noun_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Noun) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Noun, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Noun_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_Noun+"."+Noun_Kind, "-", e)
	}
	return
}

func Noun_Detailed_Optional_Marshal(n jsonexp.Context, val **Noun) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Noun_Detailed_Marshal(n, ptr)
	}
	return
}
func Noun_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Noun) (err error) {
	if len(b) > 0 {
		var el Noun
		if e := Noun_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Noun, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Retarget makes a parser scanner
type Retarget struct {
	Span []ScannerMaker `if:"label=_"`
}

func (*Retarget) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Retarget,
		Uses: composer.Type_Flow,
	}
}

const Type_Retarget = "retarget"
const Retarget_Span = "$SPAN"

func (op *Retarget) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Retarget_Detailed_Marshal(n, op)
}
func (op *Retarget) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Retarget_Detailed_Unmarshal(n, b, op)
}

func Retarget_Detailed_Marshal(n jsonexp.Context, val *Retarget) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ScannerMaker_Detailed_Repeats_Marshal(n, &val.Span); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Retarget_Span] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Retarget,
			Fields: fields,
		})
	}
	return
}

func Retarget_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Retarget) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Retarget, "-", e)
	} else if e := ScannerMaker_Detailed_Repeats_Unmarshal(n, msg.Fields[Retarget_Span], &out.Span); e != nil {
		err = errutil.New(Type_Retarget+"."+Retarget_Span, "-", e)
	}
	return
}

func Retarget_Detailed_Optional_Marshal(n jsonexp.Context, val **Retarget) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Retarget_Detailed_Marshal(n, ptr)
	}
	return
}
func Retarget_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Retarget) (err error) {
	if len(b) > 0 {
		var el Retarget
		if e := Retarget_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Retarget, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Reverse makes a parser scanner
type Reverse struct {
	Reverses []ScannerMaker `if:"label=_"`
}

func (*Reverse) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Reverse,
		Uses: composer.Type_Flow,
	}
}

const Type_Reverse = "reverse"
const Reverse_Reverses = "$REVERSES"

func (op *Reverse) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Reverse_Detailed_Marshal(n, op)
}
func (op *Reverse) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Reverse_Detailed_Unmarshal(n, b, op)
}

func Reverse_Detailed_Marshal(n jsonexp.Context, val *Reverse) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ScannerMaker_Detailed_Repeats_Marshal(n, &val.Reverses); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Reverse_Reverses] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Reverse,
			Fields: fields,
		})
	}
	return
}

func Reverse_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Reverse) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Reverse, "-", e)
	} else if e := ScannerMaker_Detailed_Repeats_Unmarshal(n, msg.Fields[Reverse_Reverses], &out.Reverses); e != nil {
		err = errutil.New(Type_Reverse+"."+Reverse_Reverses, "-", e)
	}
	return
}

func Reverse_Detailed_Optional_Marshal(n jsonexp.Context, val **Reverse) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Reverse_Detailed_Marshal(n, ptr)
	}
	return
}
func Reverse_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Reverse) (err error) {
	if len(b) > 0 {
		var el Reverse
		if e := Reverse_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Reverse, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_ScannerMaker = "scanner_maker"

func ScannerMaker_Detailed_Marshal(n jsonexp.Context, ptr *ScannerMaker) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_ScannerMaker,
			Value: b,
		})
	}
	return
}

func ScannerMaker_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ScannerMaker) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ScannerMaker); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_ScannerMaker)
	} else {
		(*out) = store
	}
	return
}

func ScannerMaker_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ScannerMaker) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := ScannerMaker_Detailed_Marshal(n, &el); e != nil {
				err = errutil.New(Type_ScannerMaker, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ScannerMaker_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ScannerMaker) (err error) {
	var vals []ScannerMaker
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_ScannerMaker, "-", e)
		} else {
			vals = make([]ScannerMaker, len(msgs))
			for i, msg := range msgs {
				if e := ScannerMaker_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_ScannerMaker, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

// Self makes a parser scanner which matches the player. ( the player string is just to make the composer happy. )
type Self struct {
	Player string `if:"label=_,type=text"`
}

func (*Self) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Self,
		Uses: composer.Type_Flow,
	}
}

const Type_Self = "self"
const Self_Player = "$PLAYER"

func (op *Self) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Self_Detailed_Marshal(n, op)
}
func (op *Self) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Self_Detailed_Unmarshal(n, b, op)
}

func Self_Detailed_Marshal(n jsonexp.Context, val *Self) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Player); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Self_Player] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Self,
			Fields: fields,
		})
	}
	return
}

func Self_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Self) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Self, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Self_Player], &out.Player); e != nil {
		err = errutil.New(Type_Self+"."+Self_Player, "-", e)
	}
	return
}

func Self_Detailed_Optional_Marshal(n jsonexp.Context, val **Self) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Self_Detailed_Marshal(n, ptr)
	}
	return
}
func Self_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Self) (err error) {
	if len(b) > 0 {
		var el Self
		if e := Self_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Self, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Words makes a parser scanner
type Words struct {
	Words []string `if:"label=_,type=text"`
}

func (*Words) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Words,
		Uses: composer.Type_Flow,
	}
}

const Type_Words = "words"
const Words_Words = "$WORDS"

func (op *Words) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Words_Detailed_Marshal(n, op)
}
func (op *Words) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Words_Detailed_Unmarshal(n, b, op)
}

func Words_Detailed_Marshal(n jsonexp.Context, val *Words) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Repeats_Marshal(n, &val.Words); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Words_Words] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Words,
			Fields: fields,
		})
	}
	return
}

func Words_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Words) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Words, "-", e)
	} else if e := value.Text_Detailed_Override_Repeats_Unmarshal(n, msg.Fields[Words_Words], &out.Words); e != nil {
		err = errutil.New(Type_Words+"."+Words_Words, "-", e)
	}
	return
}

func Words_Detailed_Optional_Marshal(n jsonexp.Context, val **Words) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Words_Detailed_Marshal(n, ptr)
	}
	return
}
func Words_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Words) (err error) {
	if len(b) > 0 {
		var el Words
		if e := Words_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Words, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

var Slots = []interface{}{
	(*GrammarMaker)(nil),
	(*ScannerMaker)(nil),
}

var Slats = []composer.Composer{
	(*Action)(nil),
	(*Alias)(nil),
	(*AllOf)(nil),
	(*AnyOf)(nil),
	(*Directive)(nil),
	(*Grammar)(nil),
	(*Noun)(nil),
	(*Retarget)(nil),
	(*Reverse)(nil),
	(*Self)(nil),
	(*Words)(nil),
}
