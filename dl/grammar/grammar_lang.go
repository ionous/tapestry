// Code generated by "makeops"; edit at your own risk.
package grammar

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/jsn"
	"github.com/ionous/errutil"
)

// Action makes a parser scanner producing a script defined action.
// User implements: ScannerMaker.
type Action struct {
	Action string `if:"label=_,type=text"`
}

func (*Action) Compose() composer.Spec {
	return composer.Spec{
		Name: Action_Type,
		Uses: composer.Type_Flow,
		Lede: "as",
	}
}

const Action_Type = "action"

const Action_Field_Action = "$ACTION"

func (op *Action) Marshal(m jsn.Marshaler) error {
	return Action_Marshal(m, op)
}

type Action_Slice []Action

func (op *Action_Slice) GetType() string { return Action_Type }
func (op *Action_Slice) GetSize() int    { return len(*op) }
func (op *Action_Slice) SetSize(cnt int) { (*op) = make(Action_Slice, cnt) }

func Action_Repeats_Marshal(m jsn.Marshaler, vals *[]Action) (err error) {
	if err = m.MarshalBlock((*Action_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Action_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Action_Optional_Marshal(m jsn.Marshaler, pv **Action) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Action_Marshal(m, *pv)
	} else if !enc {
		var v Action
		if err = Action_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Action_Marshal(m jsn.Marshaler, val *Action) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("as", Action_Type)); err == nil {
		e0 := m.MarshalKey("", Action_Field_Action)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Action)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Action_Field_Action))
		}
		m.EndBlock()
	}
	return
}

// Alias allows the user to refer to a noun by one or more other terms.
// User implements: GrammarMaker.
type Alias struct {
	Names  []string `if:"label=_,type=text"`
	AsNoun string   `if:"label=as_noun,type=text"`
}

func (*Alias) Compose() composer.Spec {
	return composer.Spec{
		Name: Alias_Type,
		Uses: composer.Type_Flow,
	}
}

const Alias_Type = "alias"

const Alias_Field_Names = "$NAMES"
const Alias_Field_AsNoun = "$AS_NOUN"

func (op *Alias) Marshal(m jsn.Marshaler) error {
	return Alias_Marshal(m, op)
}

type Alias_Slice []Alias

func (op *Alias_Slice) GetType() string { return Alias_Type }
func (op *Alias_Slice) GetSize() int    { return len(*op) }
func (op *Alias_Slice) SetSize(cnt int) { (*op) = make(Alias_Slice, cnt) }

func Alias_Repeats_Marshal(m jsn.Marshaler, vals *[]Alias) (err error) {
	if err = m.MarshalBlock((*Alias_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Alias_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Alias_Optional_Marshal(m jsn.Marshaler, pv **Alias) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Alias_Marshal(m, *pv)
	} else if !enc {
		var v Alias
		if err = Alias_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Alias_Marshal(m jsn.Marshaler, val *Alias) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Alias_Type, Alias_Type)); err == nil {
		e0 := m.MarshalKey("", Alias_Field_Names)
		if e0 == nil {
			e0 = value.Text_Unboxed_Repeats_Marshal(m, &val.Names)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Alias_Field_Names))
		}
		e1 := m.MarshalKey("as_noun", Alias_Field_AsNoun)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.AsNoun)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Alias_Field_AsNoun))
		}
		m.EndBlock()
	}
	return
}

// AllOf makes a parser scanner
// User implements: ScannerMaker.
type AllOf struct {
	Series []ScannerMaker `if:"label=_"`
}

func (*AllOf) Compose() composer.Spec {
	return composer.Spec{
		Name: AllOf_Type,
		Uses: composer.Type_Flow,
	}
}

const AllOf_Type = "all_of"

const AllOf_Field_Series = "$SERIES"

func (op *AllOf) Marshal(m jsn.Marshaler) error {
	return AllOf_Marshal(m, op)
}

type AllOf_Slice []AllOf

func (op *AllOf_Slice) GetType() string { return AllOf_Type }
func (op *AllOf_Slice) GetSize() int    { return len(*op) }
func (op *AllOf_Slice) SetSize(cnt int) { (*op) = make(AllOf_Slice, cnt) }

func AllOf_Repeats_Marshal(m jsn.Marshaler, vals *[]AllOf) (err error) {
	if err = m.MarshalBlock((*AllOf_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := AllOf_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func AllOf_Optional_Marshal(m jsn.Marshaler, pv **AllOf) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AllOf_Marshal(m, *pv)
	} else if !enc {
		var v AllOf
		if err = AllOf_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AllOf_Marshal(m jsn.Marshaler, val *AllOf) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(AllOf_Type, AllOf_Type)); err == nil {
		e0 := m.MarshalKey("", AllOf_Field_Series)
		if e0 == nil {
			e0 = ScannerMaker_Repeats_Marshal(m, &val.Series)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AllOf_Field_Series))
		}
		m.EndBlock()
	}
	return
}

// AnyOf makes a parser scanner
// User implements: ScannerMaker.
type AnyOf struct {
	Options []ScannerMaker `if:"label=_"`
}

func (*AnyOf) Compose() composer.Spec {
	return composer.Spec{
		Name: AnyOf_Type,
		Uses: composer.Type_Flow,
	}
}

const AnyOf_Type = "any_of"

const AnyOf_Field_Options = "$OPTIONS"

func (op *AnyOf) Marshal(m jsn.Marshaler) error {
	return AnyOf_Marshal(m, op)
}

type AnyOf_Slice []AnyOf

func (op *AnyOf_Slice) GetType() string { return AnyOf_Type }
func (op *AnyOf_Slice) GetSize() int    { return len(*op) }
func (op *AnyOf_Slice) SetSize(cnt int) { (*op) = make(AnyOf_Slice, cnt) }

func AnyOf_Repeats_Marshal(m jsn.Marshaler, vals *[]AnyOf) (err error) {
	if err = m.MarshalBlock((*AnyOf_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := AnyOf_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func AnyOf_Optional_Marshal(m jsn.Marshaler, pv **AnyOf) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AnyOf_Marshal(m, *pv)
	} else if !enc {
		var v AnyOf
		if err = AnyOf_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AnyOf_Marshal(m jsn.Marshaler, val *AnyOf) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(AnyOf_Type, AnyOf_Type)); err == nil {
		e0 := m.MarshalKey("", AnyOf_Field_Options)
		if e0 == nil {
			e0 = ScannerMaker_Repeats_Marshal(m, &val.Options)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AnyOf_Field_Options))
		}
		m.EndBlock()
	}
	return
}

// Directive starts a parser scanner
// User implements: GrammarMaker.
type Directive struct {
	Lede  []string       `if:"label=_,type=text"`
	Scans []ScannerMaker `if:"label=scans"`
}

func (*Directive) Compose() composer.Spec {
	return composer.Spec{
		Name: Directive_Type,
		Uses: composer.Type_Flow,
	}
}

const Directive_Type = "directive"

const Directive_Field_Lede = "$LEDE"
const Directive_Field_Scans = "$SCANS"

func (op *Directive) Marshal(m jsn.Marshaler) error {
	return Directive_Marshal(m, op)
}

type Directive_Slice []Directive

func (op *Directive_Slice) GetType() string { return Directive_Type }
func (op *Directive_Slice) GetSize() int    { return len(*op) }
func (op *Directive_Slice) SetSize(cnt int) { (*op) = make(Directive_Slice, cnt) }

func Directive_Repeats_Marshal(m jsn.Marshaler, vals *[]Directive) (err error) {
	if err = m.MarshalBlock((*Directive_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Directive_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Directive_Optional_Marshal(m jsn.Marshaler, pv **Directive) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Directive_Marshal(m, *pv)
	} else if !enc {
		var v Directive
		if err = Directive_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Directive_Marshal(m jsn.Marshaler, val *Directive) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Directive_Type, Directive_Type)); err == nil {
		e0 := m.MarshalKey("", Directive_Field_Lede)
		if e0 == nil {
			e0 = value.Text_Unboxed_Repeats_Marshal(m, &val.Lede)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Directive_Field_Lede))
		}
		e1 := m.MarshalKey("scans", Directive_Field_Scans)
		if e1 == nil {
			e1 = ScannerMaker_Repeats_Marshal(m, &val.Scans)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Directive_Field_Scans))
		}
		m.EndBlock()
	}
	return
}

// Grammar Read what the player types and turn it into actions.
type Grammar struct {
	Grammar GrammarMaker `if:"label=_"`
}

func (*Grammar) Compose() composer.Spec {
	return composer.Spec{
		Name: Grammar_Type,
		Uses: composer.Type_Flow,
	}
}

const Grammar_Type = "grammar"

const Grammar_Field_Grammar = "$GRAMMAR"

func (op *Grammar) Marshal(m jsn.Marshaler) error {
	return Grammar_Marshal(m, op)
}

type Grammar_Slice []Grammar

func (op *Grammar_Slice) GetType() string { return Grammar_Type }
func (op *Grammar_Slice) GetSize() int    { return len(*op) }
func (op *Grammar_Slice) SetSize(cnt int) { (*op) = make(Grammar_Slice, cnt) }

func Grammar_Repeats_Marshal(m jsn.Marshaler, vals *[]Grammar) (err error) {
	if err = m.MarshalBlock((*Grammar_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Grammar_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Grammar_Optional_Marshal(m jsn.Marshaler, pv **Grammar) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Grammar_Marshal(m, *pv)
	} else if !enc {
		var v Grammar
		if err = Grammar_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Grammar_Marshal(m jsn.Marshaler, val *Grammar) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Grammar_Type, Grammar_Type)); err == nil {
		e0 := m.MarshalKey("", Grammar_Field_Grammar)
		if e0 == nil {
			e0 = GrammarMaker_Marshal(m, &val.Grammar)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Grammar_Field_Grammar))
		}
		m.EndBlock()
	}
	return
}

const GrammarMaker_Type = "grammar_maker"

var GrammarMaker_Optional_Marshal = GrammarMaker_Marshal

type GrammarMaker_Slot struct{ ptr *GrammarMaker }

func (At GrammarMaker_Slot) GetType() string { return GrammarMaker_Type }
func (at GrammarMaker_Slot) HasSlot() bool   { return at.ptr != nil }
func (at GrammarMaker_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(GrammarMaker)
	return
}

func GrammarMaker_Marshal(m jsn.Marshaler, ptr *GrammarMaker) (err error) {
	if err = m.MarshalBlock(GrammarMaker_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type GrammarMaker_Slice []GrammarMaker

func (op *GrammarMaker_Slice) GetType() string { return GrammarMaker_Type }
func (op *GrammarMaker_Slice) GetSize() int    { return len(*op) }
func (op *GrammarMaker_Slice) SetSize(cnt int) { (*op) = make(GrammarMaker_Slice, cnt) }

func GrammarMaker_Repeats_Marshal(m jsn.Marshaler, vals *[]GrammarMaker) (err error) {
	if err = m.MarshalBlock((*GrammarMaker_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := GrammarMaker_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

// Noun makes a parser scanner
// User implements: ScannerMaker.
type Noun struct {
	Kind string `if:"label=_,type=text"`
}

func (*Noun) Compose() composer.Spec {
	return composer.Spec{
		Name: Noun_Type,
		Uses: composer.Type_Flow,
	}
}

const Noun_Type = "noun"

const Noun_Field_Kind = "$KIND"

func (op *Noun) Marshal(m jsn.Marshaler) error {
	return Noun_Marshal(m, op)
}

type Noun_Slice []Noun

func (op *Noun_Slice) GetType() string { return Noun_Type }
func (op *Noun_Slice) GetSize() int    { return len(*op) }
func (op *Noun_Slice) SetSize(cnt int) { (*op) = make(Noun_Slice, cnt) }

func Noun_Repeats_Marshal(m jsn.Marshaler, vals *[]Noun) (err error) {
	if err = m.MarshalBlock((*Noun_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Noun_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Noun_Optional_Marshal(m jsn.Marshaler, pv **Noun) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Noun_Marshal(m, *pv)
	} else if !enc {
		var v Noun
		if err = Noun_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Noun_Marshal(m jsn.Marshaler, val *Noun) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Noun_Type, Noun_Type)); err == nil {
		e0 := m.MarshalKey("", Noun_Field_Kind)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Kind)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Noun_Field_Kind))
		}
		m.EndBlock()
	}
	return
}

// Retarget makes a parser scanner
// User implements: ScannerMaker.
type Retarget struct {
	Span []ScannerMaker `if:"label=_"`
}

func (*Retarget) Compose() composer.Spec {
	return composer.Spec{
		Name: Retarget_Type,
		Uses: composer.Type_Flow,
	}
}

const Retarget_Type = "retarget"

const Retarget_Field_Span = "$SPAN"

func (op *Retarget) Marshal(m jsn.Marshaler) error {
	return Retarget_Marshal(m, op)
}

type Retarget_Slice []Retarget

func (op *Retarget_Slice) GetType() string { return Retarget_Type }
func (op *Retarget_Slice) GetSize() int    { return len(*op) }
func (op *Retarget_Slice) SetSize(cnt int) { (*op) = make(Retarget_Slice, cnt) }

func Retarget_Repeats_Marshal(m jsn.Marshaler, vals *[]Retarget) (err error) {
	if err = m.MarshalBlock((*Retarget_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Retarget_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Retarget_Optional_Marshal(m jsn.Marshaler, pv **Retarget) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Retarget_Marshal(m, *pv)
	} else if !enc {
		var v Retarget
		if err = Retarget_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Retarget_Marshal(m jsn.Marshaler, val *Retarget) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Retarget_Type, Retarget_Type)); err == nil {
		e0 := m.MarshalKey("", Retarget_Field_Span)
		if e0 == nil {
			e0 = ScannerMaker_Repeats_Marshal(m, &val.Span)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Retarget_Field_Span))
		}
		m.EndBlock()
	}
	return
}

// Reverse makes a parser scanner
// User implements: ScannerMaker.
type Reverse struct {
	Reverses []ScannerMaker `if:"label=_"`
}

func (*Reverse) Compose() composer.Spec {
	return composer.Spec{
		Name: Reverse_Type,
		Uses: composer.Type_Flow,
	}
}

const Reverse_Type = "reverse"

const Reverse_Field_Reverses = "$REVERSES"

func (op *Reverse) Marshal(m jsn.Marshaler) error {
	return Reverse_Marshal(m, op)
}

type Reverse_Slice []Reverse

func (op *Reverse_Slice) GetType() string { return Reverse_Type }
func (op *Reverse_Slice) GetSize() int    { return len(*op) }
func (op *Reverse_Slice) SetSize(cnt int) { (*op) = make(Reverse_Slice, cnt) }

func Reverse_Repeats_Marshal(m jsn.Marshaler, vals *[]Reverse) (err error) {
	if err = m.MarshalBlock((*Reverse_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Reverse_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Reverse_Optional_Marshal(m jsn.Marshaler, pv **Reverse) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Reverse_Marshal(m, *pv)
	} else if !enc {
		var v Reverse
		if err = Reverse_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Reverse_Marshal(m jsn.Marshaler, val *Reverse) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Reverse_Type, Reverse_Type)); err == nil {
		e0 := m.MarshalKey("", Reverse_Field_Reverses)
		if e0 == nil {
			e0 = ScannerMaker_Repeats_Marshal(m, &val.Reverses)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Reverse_Field_Reverses))
		}
		m.EndBlock()
	}
	return
}

const ScannerMaker_Type = "scanner_maker"

var ScannerMaker_Optional_Marshal = ScannerMaker_Marshal

type ScannerMaker_Slot struct{ ptr *ScannerMaker }

func (At ScannerMaker_Slot) GetType() string { return ScannerMaker_Type }
func (at ScannerMaker_Slot) HasSlot() bool   { return at.ptr != nil }
func (at ScannerMaker_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(ScannerMaker)
	return
}

func ScannerMaker_Marshal(m jsn.Marshaler, ptr *ScannerMaker) (err error) {
	if err = m.MarshalBlock(ScannerMaker_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type ScannerMaker_Slice []ScannerMaker

func (op *ScannerMaker_Slice) GetType() string { return ScannerMaker_Type }
func (op *ScannerMaker_Slice) GetSize() int    { return len(*op) }
func (op *ScannerMaker_Slice) SetSize(cnt int) { (*op) = make(ScannerMaker_Slice, cnt) }

func ScannerMaker_Repeats_Marshal(m jsn.Marshaler, vals *[]ScannerMaker) (err error) {
	if err = m.MarshalBlock((*ScannerMaker_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ScannerMaker_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

// Self makes a parser scanner which matches the player. ( the player string is just to make the composer happy. )
// User implements: ScannerMaker.
type Self struct {
	Player string `if:"label=_,type=text"`
}

func (*Self) Compose() composer.Spec {
	return composer.Spec{
		Name: Self_Type,
		Uses: composer.Type_Flow,
	}
}

const Self_Type = "self"

const Self_Field_Player = "$PLAYER"

func (op *Self) Marshal(m jsn.Marshaler) error {
	return Self_Marshal(m, op)
}

type Self_Slice []Self

func (op *Self_Slice) GetType() string { return Self_Type }
func (op *Self_Slice) GetSize() int    { return len(*op) }
func (op *Self_Slice) SetSize(cnt int) { (*op) = make(Self_Slice, cnt) }

func Self_Repeats_Marshal(m jsn.Marshaler, vals *[]Self) (err error) {
	if err = m.MarshalBlock((*Self_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Self_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Self_Optional_Marshal(m jsn.Marshaler, pv **Self) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Self_Marshal(m, *pv)
	} else if !enc {
		var v Self
		if err = Self_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Self_Marshal(m jsn.Marshaler, val *Self) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Self_Type, Self_Type)); err == nil {
		e0 := m.MarshalKey("", Self_Field_Player)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.Player)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Self_Field_Player))
		}
		m.EndBlock()
	}
	return
}

// Words makes a parser scanner
// User implements: ScannerMaker.
type Words struct {
	Words []string `if:"label=_,type=text"`
}

func (*Words) Compose() composer.Spec {
	return composer.Spec{
		Name: Words_Type,
		Uses: composer.Type_Flow,
	}
}

const Words_Type = "words"

const Words_Field_Words = "$WORDS"

func (op *Words) Marshal(m jsn.Marshaler) error {
	return Words_Marshal(m, op)
}

type Words_Slice []Words

func (op *Words_Slice) GetType() string { return Words_Type }
func (op *Words_Slice) GetSize() int    { return len(*op) }
func (op *Words_Slice) SetSize(cnt int) { (*op) = make(Words_Slice, cnt) }

func Words_Repeats_Marshal(m jsn.Marshaler, vals *[]Words) (err error) {
	if err = m.MarshalBlock((*Words_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Words_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Words_Optional_Marshal(m jsn.Marshaler, pv **Words) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Words_Marshal(m, *pv)
	} else if !enc {
		var v Words
		if err = Words_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Words_Marshal(m jsn.Marshaler, val *Words) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Words_Type, Words_Type)); err == nil {
		e0 := m.MarshalKey("", Words_Field_Words)
		if e0 == nil {
			e0 = value.Text_Unboxed_Repeats_Marshal(m, &val.Words)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Words_Field_Words))
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*GrammarMaker)(nil),
	(*ScannerMaker)(nil),
}

var Slats = []composer.Composer{
	(*Action)(nil),
	(*Alias)(nil),
	(*AllOf)(nil),
	(*AnyOf)(nil),
	(*Directive)(nil),
	(*Grammar)(nil),
	(*Noun)(nil),
	(*Retarget)(nil),
	(*Reverse)(nil),
	(*Self)(nil),
	(*Words)(nil),
}

var Signatures = map[uint64]interface{}{
	18013434347847705365: (*Action)(nil),    /* As: */
	12970384957739247299: (*Alias)(nil),     /* Alias:asNoun: */
	12299258133038749149: (*AllOf)(nil),     /* AllOf: */
	5638555781748976558:  (*AnyOf)(nil),     /* AnyOf: */
	13009220793665599564: (*Directive)(nil), /* Directive:scans: */
	15013060695242199180: (*Grammar)(nil),   /* Grammar: */
	571163134278291657:   (*Noun)(nil),      /* Noun: */
	9105733481983959033:  (*Retarget)(nil),  /* Retarget: */
	11708077258721206605: (*Reverse)(nil),   /* Reverse: */
	7416511141403176695:  (*Self)(nil),      /* Self: */
	1154838578286238320:  (*Words)(nil),     /* Words: */
}
