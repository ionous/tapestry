// Code generated by "makeops"; edit at your own risk.
package grammar

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
)

// Action makes a parser scanner producing a script defined action.
type Action struct {
	Action string `if:"label=_,type=text"`
}

func (*Action) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Action,
		Uses: "flow",
		Lede: "as",
	}
}

var Type_Action = "action"

func (op *Action) MarshalJSON() (ret []byte, err error) {
	if jsonAction, e := op.MarshalJSONAction(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Action,
			Value: map[string]json.RawMessage{
				"$ACTION": jsonAction,
			},
		})
	}
	return
}

func (op *Action) MarshalJSONAction() (ret []byte, err error) {
	// type override
	m := value.Text{op.Action}
	ret, err = m.MarshalJSON()
	return
}

// Alias allows the user to refer to a noun by one or more other terms.
type Alias struct {
	Names  []string `if:"label=_,type=text"`
	AsNoun string   `if:"label=as_noun,type=text"`
}

func (*Alias) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Alias,
		Uses: "flow",
	}
}

var Type_Alias = "alias"

func (op *Alias) MarshalJSON() (ret []byte, err error) {
	if jsonNames, e := op.MarshalJSONNames(); e != nil {
		err = e
	} else if jsonAsNoun, e := op.MarshalJSONAsNoun(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Alias,
			Value: map[string]json.RawMessage{
				"$NAMES":   jsonNames,
				"$AS_NOUN": jsonAsNoun,
			},
		})
	}
	return
}

func (op *Alias) MarshalJSONNames() (ret []byte, err error) {
	ret, err = json.Marshal(op.Names)
	return
}

func (op *Alias) MarshalJSONAsNoun() (ret []byte, err error) {
	// type override
	m := value.Text{op.AsNoun}
	ret, err = m.MarshalJSON()
	return
}

// AllOf makes a parser scanner
type AllOf struct {
	Series []ScannerMaker `if:"label=_"`
}

func (*AllOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AllOf,
		Uses: "flow",
	}
}

var Type_AllOf = "all_of"

func (op *AllOf) MarshalJSON() (ret []byte, err error) {
	if jsonSeries, e := op.MarshalJSONSeries(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_AllOf,
			Value: map[string]json.RawMessage{
				"$SERIES": jsonSeries,
			},
		})
	}
	return
}

func (op *AllOf) MarshalJSONSeries() (ret []byte, err error) {
	ret, err = json.Marshal(op.Series)
	return
}

// AnyOf makes a parser scanner
type AnyOf struct {
	Options []ScannerMaker `if:"label=_"`
}

func (*AnyOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AnyOf,
		Uses: "flow",
	}
}

var Type_AnyOf = "any_of"

func (op *AnyOf) MarshalJSON() (ret []byte, err error) {
	if jsonOptions, e := op.MarshalJSONOptions(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_AnyOf,
			Value: map[string]json.RawMessage{
				"$OPTIONS": jsonOptions,
			},
		})
	}
	return
}

func (op *AnyOf) MarshalJSONOptions() (ret []byte, err error) {
	ret, err = json.Marshal(op.Options)
	return
}

// Directive starts a parser scanner
type Directive struct {
	Lede  []string       `if:"label=_,type=text"`
	Scans []ScannerMaker `if:"label=scans"`
}

func (*Directive) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Directive,
		Uses: "flow",
	}
}

var Type_Directive = "directive"

func (op *Directive) MarshalJSON() (ret []byte, err error) {
	if jsonLede, e := op.MarshalJSONLede(); e != nil {
		err = e
	} else if jsonScans, e := op.MarshalJSONScans(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Directive,
			Value: map[string]json.RawMessage{
				"$LEDE":  jsonLede,
				"$SCANS": jsonScans,
			},
		})
	}
	return
}

func (op *Directive) MarshalJSONLede() (ret []byte, err error) {
	ret, err = json.Marshal(op.Lede)
	return
}

func (op *Directive) MarshalJSONScans() (ret []byte, err error) {
	ret, err = json.Marshal(op.Scans)
	return
}

// Grammar Read what the player types and turn it into actions.
type Grammar struct {
	Grammar GrammarMaker `if:"label=_"`
}

func (*Grammar) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Grammar,
		Uses: "flow",
	}
}

var Type_Grammar = "grammar"

func (op *Grammar) MarshalJSON() (ret []byte, err error) {
	if jsonGrammar, e := op.MarshalJSONGrammar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Grammar,
			Value: map[string]json.RawMessage{
				"$GRAMMAR": jsonGrammar,
			},
		})
	}
	return
}

func (op *Grammar) MarshalJSONGrammar() (ret []byte, err error) {
	if v, e := op.Grammar.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_GrammarMaker,
			Value: v,
		})
	}
	return
}

const Type_GrammarMaker = "grammar_maker"

// Noun makes a parser scanner
type Noun struct {
	Kind string `if:"label=_,type=text"`
}

func (*Noun) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Noun,
		Uses: "flow",
	}
}

var Type_Noun = "noun"

func (op *Noun) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Noun,
			Value: map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *Noun) MarshalJSONKind() (ret []byte, err error) {
	// type override
	m := value.Text{op.Kind}
	ret, err = m.MarshalJSON()
	return
}

// Retarget makes a parser scanner
type Retarget struct {
	Span []ScannerMaker `if:"label=_"`
}

func (*Retarget) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Retarget,
		Uses: "flow",
	}
}

var Type_Retarget = "retarget"

func (op *Retarget) MarshalJSON() (ret []byte, err error) {
	if jsonSpan, e := op.MarshalJSONSpan(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Retarget,
			Value: map[string]json.RawMessage{
				"$SPAN": jsonSpan,
			},
		})
	}
	return
}

func (op *Retarget) MarshalJSONSpan() (ret []byte, err error) {
	ret, err = json.Marshal(op.Span)
	return
}

// Reverse makes a parser scanner
type Reverse struct {
	Reverses []ScannerMaker `if:"label=_"`
}

func (*Reverse) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Reverse,
		Uses: "flow",
	}
}

var Type_Reverse = "reverse"

func (op *Reverse) MarshalJSON() (ret []byte, err error) {
	if jsonReverses, e := op.MarshalJSONReverses(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Reverse,
			Value: map[string]json.RawMessage{
				"$REVERSES": jsonReverses,
			},
		})
	}
	return
}

func (op *Reverse) MarshalJSONReverses() (ret []byte, err error) {
	ret, err = json.Marshal(op.Reverses)
	return
}

const Type_ScannerMaker = "scanner_maker"

// Self makes a parser scanner which matches the player. ( the player string is just to make the composer happy. )
type Self struct {
	Player string `if:"label=_,type=text"`
}

func (*Self) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Self,
		Uses: "flow",
	}
}

var Type_Self = "self"

func (op *Self) MarshalJSON() (ret []byte, err error) {
	if jsonPlayer, e := op.MarshalJSONPlayer(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Self,
			Value: map[string]json.RawMessage{
				"$PLAYER": jsonPlayer,
			},
		})
	}
	return
}

func (op *Self) MarshalJSONPlayer() (ret []byte, err error) {
	// type override
	m := value.Text{op.Player}
	ret, err = m.MarshalJSON()
	return
}

// Words makes a parser scanner
type Words struct {
	Words []string `if:"label=_,type=text"`
}

func (*Words) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Words,
		Uses: "flow",
	}
}

var Type_Words = "words"

func (op *Words) MarshalJSON() (ret []byte, err error) {
	if jsonWords, e := op.MarshalJSONWords(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Words,
			Value: map[string]json.RawMessage{
				"$WORDS": jsonWords,
			},
		})
	}
	return
}

func (op *Words) MarshalJSONWords() (ret []byte, err error) {
	ret, err = json.Marshal(op.Words)
	return
}

var Slots = []interface{}{
	(*GrammarMaker)(nil),
	(*ScannerMaker)(nil),
}

var Slats = []composer.Composer{
	(*Action)(nil),
	(*Alias)(nil),
	(*AllOf)(nil),
	(*AnyOf)(nil),
	(*Directive)(nil),
	(*Grammar)(nil),
	(*Noun)(nil),
	(*Retarget)(nil),
	(*Reverse)(nil),
	(*Self)(nil),
	(*Words)(nil),
}
