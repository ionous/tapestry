// Code generated by "makeops"; edit at your own risk.
package grammar

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/value"
)

// Action makes a parser scanner producing a script defined action.
type Action struct {
	Action string `if:"label=_,type=text"`
}

func (*Action) Compose() composer.Spec {
	return composer.Spec{
		Name: "action",
		Uses: "flow",
		Lede: "as",
	}
}

func (op *Action) MarshalJSON() (ret []byte, err error) {
	if jsonAction, e := op.MarshalJSONAction(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "action",
			"value": map[string]json.RawMessage{
				"$ACTION": jsonAction,
			},
		})
	}
	return
}

func (op *Action) MarshalJSONAction() ([]byte, error) {
	// type override
	m := value.Text{op.Action}
	return m.MarshalJSON()
}

// Alias allows the user to refer to a noun by one or more other terms.
type Alias struct {
	Names  []string `if:"label=_,type=text"`
	AsNoun string   `if:"label=as_noun,type=text"`
}

func (*Alias) Compose() composer.Spec {
	return composer.Spec{
		Name: "alias",
		Uses: "flow",
	}
}

func (op *Alias) MarshalJSON() (ret []byte, err error) {
	if jsonNames, e := op.MarshalJSONNames(); e != nil {
		err = e
	} else if jsonAsNoun, e := op.MarshalJSONAsNoun(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "alias",
			"value": map[string]json.RawMessage{
				"$NAMES":   jsonNames,
				"$AS_NOUN": jsonAsNoun,
			},
		})
	}
	return
}

func (op *Alias) MarshalJSONNames() ([]byte, error) {
	return json.Marshal(op.Names)
}

func (op *Alias) MarshalJSONAsNoun() ([]byte, error) {
	// type override
	m := value.Text{op.AsNoun}
	return m.MarshalJSON()
}

// AllOf makes a parser scanner
type AllOf struct {
	Series []ScannerMaker `if:"label=_"`
}

func (*AllOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "all_of",
		Uses: "flow",
	}
}

func (op *AllOf) MarshalJSON() (ret []byte, err error) {
	if jsonSeries, e := op.MarshalJSONSeries(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "all_of",
			"value": map[string]json.RawMessage{
				"$SERIES": jsonSeries,
			},
		})
	}
	return
}

func (op *AllOf) MarshalJSONSeries() ([]byte, error) {
	return json.Marshal(op.Series)
}

// AnyOf makes a parser scanner
type AnyOf struct {
	Options []ScannerMaker `if:"label=_"`
}

func (*AnyOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "any_of",
		Uses: "flow",
	}
}

func (op *AnyOf) MarshalJSON() (ret []byte, err error) {
	if jsonOptions, e := op.MarshalJSONOptions(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "any_of",
			"value": map[string]json.RawMessage{
				"$OPTIONS": jsonOptions,
			},
		})
	}
	return
}

func (op *AnyOf) MarshalJSONOptions() ([]byte, error) {
	return json.Marshal(op.Options)
}

// Directive starts a parser scanner
type Directive struct {
	Lede  []string       `if:"label=_,type=text"`
	Scans []ScannerMaker `if:"label=scans"`
}

func (*Directive) Compose() composer.Spec {
	return composer.Spec{
		Name: "directive",
		Uses: "flow",
	}
}

func (op *Directive) MarshalJSON() (ret []byte, err error) {
	if jsonLede, e := op.MarshalJSONLede(); e != nil {
		err = e
	} else if jsonScans, e := op.MarshalJSONScans(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "directive",
			"value": map[string]json.RawMessage{
				"$LEDE":  jsonLede,
				"$SCANS": jsonScans,
			},
		})
	}
	return
}

func (op *Directive) MarshalJSONLede() ([]byte, error) {
	return json.Marshal(op.Lede)
}

func (op *Directive) MarshalJSONScans() ([]byte, error) {
	return json.Marshal(op.Scans)
}

// Grammar Read what the player types and turn it into actions.
type Grammar struct {
	Grammar GrammarMaker `if:"label=_"`
}

func (*Grammar) Compose() composer.Spec {
	return composer.Spec{
		Name: "grammar",
		Uses: "flow",
	}
}

func (op *Grammar) MarshalJSON() (ret []byte, err error) {
	if jsonGrammar, e := op.MarshalJSONGrammar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "grammar",
			"value": map[string]json.RawMessage{
				"$GRAMMAR": jsonGrammar,
			},
		})
	}
	return
}

func (op *Grammar) MarshalJSONGrammar() ([]byte, error) {
	m := op.Grammar.(json.Marshaler)
	return m.MarshalJSON()
}

// Noun makes a parser scanner
type Noun struct {
	Kind string `if:"label=_,type=text"`
}

func (*Noun) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun",
		Uses: "flow",
	}
}

func (op *Noun) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "noun",
			"value": map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *Noun) MarshalJSONKind() ([]byte, error) {
	// type override
	m := value.Text{op.Kind}
	return m.MarshalJSON()
}

// Retarget makes a parser scanner
type Retarget struct {
	Span []ScannerMaker `if:"label=_"`
}

func (*Retarget) Compose() composer.Spec {
	return composer.Spec{
		Name: "retarget",
		Uses: "flow",
	}
}

func (op *Retarget) MarshalJSON() (ret []byte, err error) {
	if jsonSpan, e := op.MarshalJSONSpan(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "retarget",
			"value": map[string]json.RawMessage{
				"$SPAN": jsonSpan,
			},
		})
	}
	return
}

func (op *Retarget) MarshalJSONSpan() ([]byte, error) {
	return json.Marshal(op.Span)
}

// Reverse makes a parser scanner
type Reverse struct {
	Reverses []ScannerMaker `if:"label=_"`
}

func (*Reverse) Compose() composer.Spec {
	return composer.Spec{
		Name: "reverse",
		Uses: "flow",
	}
}

func (op *Reverse) MarshalJSON() (ret []byte, err error) {
	if jsonReverses, e := op.MarshalJSONReverses(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "reverse",
			"value": map[string]json.RawMessage{
				"$REVERSES": jsonReverses,
			},
		})
	}
	return
}

func (op *Reverse) MarshalJSONReverses() ([]byte, error) {
	return json.Marshal(op.Reverses)
}

// Self makes a parser scanner which matches the player. ( the player string is just to make the composer happy. )
type Self struct {
	Player string `if:"label=_,type=text"`
}

func (*Self) Compose() composer.Spec {
	return composer.Spec{
		Name: "self",
		Uses: "flow",
	}
}

func (op *Self) MarshalJSON() (ret []byte, err error) {
	if jsonPlayer, e := op.MarshalJSONPlayer(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "self",
			"value": map[string]json.RawMessage{
				"$PLAYER": jsonPlayer,
			},
		})
	}
	return
}

func (op *Self) MarshalJSONPlayer() ([]byte, error) {
	// type override
	m := value.Text{op.Player}
	return m.MarshalJSON()
}

// Words makes a parser scanner
type Words struct {
	Words []string `if:"label=_,type=text"`
}

func (*Words) Compose() composer.Spec {
	return composer.Spec{
		Name: "words",
		Uses: "flow",
	}
}

func (op *Words) MarshalJSON() (ret []byte, err error) {
	if jsonWords, e := op.MarshalJSONWords(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "words",
			"value": map[string]json.RawMessage{
				"$WORDS": jsonWords,
			},
		})
	}
	return
}

func (op *Words) MarshalJSONWords() ([]byte, error) {
	return json.Marshal(op.Words)
}

var Slots = []interface{}{
	(*GrammarMaker)(nil),
	(*ScannerMaker)(nil),
}
var Slats = []composer.Composer{
	(*Action)(nil),
	(*Alias)(nil),
	(*AllOf)(nil),
	(*AnyOf)(nil),
	(*Directive)(nil),
	(*Grammar)(nil),
	(*Noun)(nil),
	(*Retarget)(nil),
	(*Reverse)(nil),
	(*Self)(nil),
	(*Words)(nil),
}
