// Code generated by Tapestry; edit at your own risk.
package grammar

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// grammar_maker, a type of slot.
var Zt_GrammarMaker = typeinfo.Slot{
	Name: "grammar_maker",
	Markup: map[string]any{
		"comment": "Helper for defining parser grammars.",
	},
}

// holds a single slot.
type GrammarMaker_Slot struct{ Value GrammarMaker }

// implements typeinfo.Instance for a single slot.
func (*GrammarMaker_Slot) TypeInfo() typeinfo.T {
	return &Zt_GrammarMaker
}

// holds a slice of slots.
type GrammarMaker_Slots []GrammarMaker

// implements typeinfo.Instance for a series of slots.
func (*GrammarMaker_Slots) TypeInfo() typeinfo.T {
	return &Zt_GrammarMaker
}

// implements typeinfo.Repeats
func (op *GrammarMaker_Slots) Repeats() bool {
	return len(*op) > 0
}

// scanner_maker, a type of slot.
var Zt_ScannerMaker = typeinfo.Slot{
	Name: "scanner_maker",
	Markup: map[string]any{
		"comment": "Helper for defining input scanners.",
	},
}

// holds a single slot.
type ScannerMaker_Slot struct{ Value ScannerMaker }

// implements typeinfo.Instance for a single slot.
func (*ScannerMaker_Slot) TypeInfo() typeinfo.T {
	return &Zt_ScannerMaker
}

// holds a slice of slots.
type ScannerMaker_Slots []ScannerMaker

// implements typeinfo.Instance for a series of slots.
func (*ScannerMaker_Slots) TypeInfo() typeinfo.T {
	return &Zt_ScannerMaker
}

// implements typeinfo.Repeats
func (op *ScannerMaker_Slots) Repeats() bool {
	return len(*op) > 0
}

type Action struct {
	Action    string
	Arguments []assign.Arg
	Markup    map[string]any
}

// implements typeinfo.Instance
func (*Action) TypeInfo() typeinfo.T {
	return &Zt_Action
}

// return a valid markup map, creating it if necessary.
func (op *Action) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ ScannerMaker = (*Action)(nil)

// action, a type of flow.
var Zt_Action = typeinfo.Flow{
	Name: "action",
	Lede: "action",
	Terms: []typeinfo.Term{{
		Name: "action",
		Type: &prim.Zt_Text,
	}, {
		Name:     "arguments",
		Label:    "args",
		Optional: true,
		Repeats:  true,
		Type:     &assign.Zt_Arg,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_ScannerMaker,
	},
	Markup: map[string]any{
		"comment": "makes a parser scanner producing a script defined action.",
	},
}

// holds a slice of type action
type Action_Slice []Action

// implements typeinfo.Instance
func (*Action_Slice) TypeInfo() typeinfo.T {
	return &Zt_Action
}

// implements typeinfo.Repeats
func (op *Action_Slice) Repeats() bool {
	return len(*op) > 0
}

type Sequence struct {
	Series []ScannerMaker
	Markup map[string]any
}

// implements typeinfo.Instance
func (*Sequence) TypeInfo() typeinfo.T {
	return &Zt_Sequence
}

// return a valid markup map, creating it if necessary.
func (op *Sequence) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ ScannerMaker = (*Sequence)(nil)

// sequence, a type of flow.
var Zt_Sequence = typeinfo.Flow{
	Name: "sequence",
	Lede: "sequence",
	Terms: []typeinfo.Term{{
		Name:    "series",
		Repeats: true,
		Type:    &Zt_ScannerMaker,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_ScannerMaker,
	},
	Markup: map[string]any{
		"comment": "makes a parser scanner.",
	},
}

// holds a slice of type sequence
type Sequence_Slice []Sequence

// implements typeinfo.Instance
func (*Sequence_Slice) TypeInfo() typeinfo.T {
	return &Zt_Sequence
}

// implements typeinfo.Repeats
func (op *Sequence_Slice) Repeats() bool {
	return len(*op) > 0
}

type ChooseOne struct {
	Options []ScannerMaker
	Markup  map[string]any
}

// implements typeinfo.Instance
func (*ChooseOne) TypeInfo() typeinfo.T {
	return &Zt_ChooseOne
}

// return a valid markup map, creating it if necessary.
func (op *ChooseOne) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ ScannerMaker = (*ChooseOne)(nil)

// choose_one, a type of flow.
var Zt_ChooseOne = typeinfo.Flow{
	Name: "choose_one",
	Lede: "one",
	Terms: []typeinfo.Term{{
		Name:    "options",
		Label:   "of",
		Repeats: true,
		Type:    &Zt_ScannerMaker,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_ScannerMaker,
	},
	Markup: map[string]any{
		"comment": "makes a parser scanner.",
	},
}

// holds a slice of type choose_one
type ChooseOne_Slice []ChooseOne

// implements typeinfo.Instance
func (*ChooseOne_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseOne
}

// implements typeinfo.Repeats
func (op *ChooseOne_Slice) Repeats() bool {
	return len(*op) > 0
}

type Directive struct {
	Name   string
	Series []ScannerMaker
	Markup map[string]any
}

// implements typeinfo.Instance
func (*Directive) TypeInfo() typeinfo.T {
	return &Zt_Directive
}

// return a valid markup map, creating it if necessary.
func (op *Directive) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ GrammarMaker = (*Directive)(nil)

// directive, a type of flow.
var Zt_Directive = typeinfo.Flow{
	Name: "directive",
	Lede: "interpret",
	Terms: []typeinfo.Term{{
		Name:  "name",
		Label: "name",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "series",
		Label:   "with",
		Repeats: true,
		Type:    &Zt_ScannerMaker,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_GrammarMaker,
	},
	Markup: map[string]any{
		"comment": "starts a parser scanner.",
	},
}

// holds a slice of type directive
type Directive_Slice []Directive

// implements typeinfo.Instance
func (*Directive_Slice) TypeInfo() typeinfo.T {
	return &Zt_Directive
}

// implements typeinfo.Repeats
func (op *Directive_Slice) Repeats() bool {
	return len(*op) > 0
}

type Noun struct {
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Instance
func (*Noun) TypeInfo() typeinfo.T {
	return &Zt_Noun
}

// return a valid markup map, creating it if necessary.
func (op *Noun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ ScannerMaker = (*Noun)(nil)

// noun, a type of flow.
var Zt_Noun = typeinfo.Flow{
	Name: "noun",
	Lede: "one",
	Terms: []typeinfo.Term{{
		Name:  "kind",
		Label: "noun",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_ScannerMaker,
	},
	Markup: map[string]any{
		"comment": "makes a parser scanner.",
	},
}

// holds a slice of type noun
type Noun_Slice []Noun

// implements typeinfo.Instance
func (*Noun_Slice) TypeInfo() typeinfo.T {
	return &Zt_Noun
}

// implements typeinfo.Repeats
func (op *Noun_Slice) Repeats() bool {
	return len(*op) > 0
}

type Refine struct {
	Series []ScannerMaker
	Markup map[string]any
}

// implements typeinfo.Instance
func (*Refine) TypeInfo() typeinfo.T {
	return &Zt_Refine
}

// return a valid markup map, creating it if necessary.
func (op *Refine) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ ScannerMaker = (*Refine)(nil)

// refine, a type of flow.
var Zt_Refine = typeinfo.Flow{
	Name: "refine",
	Lede: "refine",
	Terms: []typeinfo.Term{{
		Name:    "series",
		Label:   "sequence",
		Repeats: true,
		Type:    &Zt_ScannerMaker,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_ScannerMaker,
	},
	Markup: map[string]any{
		"comment": "Change to the bounds of the most recent result.",
	},
}

// holds a slice of type refine
type Refine_Slice []Refine

// implements typeinfo.Instance
func (*Refine_Slice) TypeInfo() typeinfo.T {
	return &Zt_Refine
}

// implements typeinfo.Repeats
func (op *Refine_Slice) Repeats() bool {
	return len(*op) > 0
}

type Reverse struct {
	Reverses []ScannerMaker
	Markup   map[string]any
}

// implements typeinfo.Instance
func (*Reverse) TypeInfo() typeinfo.T {
	return &Zt_Reverse
}

// return a valid markup map, creating it if necessary.
func (op *Reverse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ ScannerMaker = (*Reverse)(nil)

// reverse, a type of flow.
var Zt_Reverse = typeinfo.Flow{
	Name: "reverse",
	Lede: "reverse",
	Terms: []typeinfo.Term{{
		Name:    "reverses",
		Repeats: true,
		Type:    &Zt_ScannerMaker,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_ScannerMaker,
	},
	Markup: map[string]any{
		"comment": "Swap the first and last matching results.",
	},
}

// holds a slice of type reverse
type Reverse_Slice []Reverse

// implements typeinfo.Instance
func (*Reverse_Slice) TypeInfo() typeinfo.T {
	return &Zt_Reverse
}

// implements typeinfo.Repeats
func (op *Reverse_Slice) Repeats() bool {
	return len(*op) > 0
}

type Focus struct {
	Player string
	Series []ScannerMaker
	Markup map[string]any
}

// implements typeinfo.Instance
func (*Focus) TypeInfo() typeinfo.T {
	return &Zt_Focus
}

// return a valid markup map, creating it if necessary.
func (op *Focus) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ ScannerMaker = (*Focus)(nil)

// focus, a type of flow.
var Zt_Focus = typeinfo.Flow{
	Name: "focus",
	Lede: "focus",
	Terms: []typeinfo.Term{{
		Name: "player",
		Type: &prim.Zt_Text,
	}, {
		Name:    "series",
		Label:   "sequence",
		Repeats: true,
		Type:    &Zt_ScannerMaker,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_ScannerMaker,
	},
	Markup: map[string]any{
		"comment": "Select a specific set of bounds for the scanner.",
	},
}

// holds a slice of type focus
type Focus_Slice []Focus

// implements typeinfo.Instance
func (*Focus_Slice) TypeInfo() typeinfo.T {
	return &Zt_Focus
}

// implements typeinfo.Repeats
func (op *Focus_Slice) Repeats() bool {
	return len(*op) > 0
}

type Words struct {
	Words  []string
	Markup map[string]any
}

// implements typeinfo.Instance
func (*Words) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// return a valid markup map, creating it if necessary.
func (op *Words) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ ScannerMaker = (*Words)(nil)

// words, a type of flow.
var Zt_Words = typeinfo.Flow{
	Name: "words",
	Lede: "one",
	Terms: []typeinfo.Term{{
		Name:    "words",
		Label:   "word",
		Repeats: true,
		Type:    &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&Zt_ScannerMaker,
	},
	Markup: map[string]any{
		"comment": "makes a parser scanner.",
	},
}

// holds a slice of type words
type Words_Slice []Words

// implements typeinfo.Instance
func (*Words_Slice) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// implements typeinfo.Repeats
func (op *Words_Slice) Repeats() bool {
	return len(*op) > 0
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "grammar",
	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_GrammarMaker,
	&Zt_ScannerMaker,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Action,
	&Zt_Sequence,
	&Zt_ChooseOne,
	&Zt_Directive,
	&Zt_Noun,
	&Zt_Refine,
	&Zt_Reverse,
	&Zt_Focus,
	&Zt_Words,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	12048905879374467271: (*Action)(nil),    /* scanner_maker=Action: */
	967998274944030280:   (*Action)(nil),    /* scanner_maker=Action:args: */
	1756442538083378424:  (*Focus)(nil),     /* scanner_maker=Focus:sequence: */
	6454124700650096920:  (*Directive)(nil), /* grammar_maker=Interpret name:with: */
	10964817074887037945: (*Noun)(nil),      /* scanner_maker=One noun: */
	16418039705711067622: (*ChooseOne)(nil), /* scanner_maker=One of: */
	16180319172078511701: (*Words)(nil),     /* scanner_maker=One word: */
	11402479949132197621: (*Refine)(nil),    /* scanner_maker=Refine sequence: */
	15857934419606450901: (*Reverse)(nil),   /* scanner_maker=Reverse: */
	10728359537834940094: (*Sequence)(nil),  /* scanner_maker=Sequence: */
}
