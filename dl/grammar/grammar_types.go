// Player input parsing.
package grammar

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/call"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// scanner_maker, a type of slot.
var Zt_ScannerMaker = typeinfo.Slot{
	Name: "scanner_maker",
	Markup: map[string]any{
		"comment": "Helper for defining input scanners.",
	},
}

// Holds a single slot.
type ScannerMaker_Slot struct{ Value ScannerMaker }

// Implements [typeinfo.Instance] for a single slot.
func (*ScannerMaker_Slot) TypeInfo() typeinfo.T {
	return &Zt_ScannerMaker
}

// Holds a slice of slots.
type ScannerMaker_Slots []ScannerMaker

// Implements [typeinfo.Instance] for a slice of slots.
func (*ScannerMaker_Slots) TypeInfo() typeinfo.T {
	return &Zt_ScannerMaker
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *ScannerMaker_Slots) Repeats() bool {
	return len(*op) > 0
}

// starts a parser scanner.
// this is generated by story statement "DefineNamedGrammar"
// so that grammar doesn't have to import weave.
type Directive struct {
	Name   string
	Series []ScannerMaker
	Markup map[string]any
}

// directive, a type of flow.
var Zt_Directive typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Directive) TypeInfo() typeinfo.T {
	return &Zt_Directive
}

// Implements [typeinfo.Markup]
func (op *Directive) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Holds a slice of type Directive.
type Directive_Slice []Directive

// Implements [typeinfo.Instance] for a slice of Directive.
func (*Directive_Slice) TypeInfo() typeinfo.T {
	return &Zt_Directive
}

// Implements [typeinfo.Repeats] for a slice of Directive.
func (op *Directive_Slice) Repeats() bool {
	return len(*op) > 0
}

// makes a parser scanner producing a script defined action.
type Action struct {
	Action    string
	Arguments []call.Arg
	Markup    map[string]any
}

// action, a type of flow.
var Zt_Action typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Action) TypeInfo() typeinfo.T {
	return &Zt_Action
}

// Implements [typeinfo.Markup]
func (op *Action) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ ScannerMaker = (*Action)(nil)

// Holds a slice of type Action.
type Action_Slice []Action

// Implements [typeinfo.Instance] for a slice of Action.
func (*Action_Slice) TypeInfo() typeinfo.T {
	return &Zt_Action
}

// Implements [typeinfo.Repeats] for a slice of Action.
func (op *Action_Slice) Repeats() bool {
	return len(*op) > 0
}

// makes a parser scanner.
type Sequence struct {
	Series []ScannerMaker
	Markup map[string]any
}

// sequence, a type of flow.
var Zt_Sequence typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Sequence) TypeInfo() typeinfo.T {
	return &Zt_Sequence
}

// Implements [typeinfo.Markup]
func (op *Sequence) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ ScannerMaker = (*Sequence)(nil)

// Holds a slice of type Sequence.
type Sequence_Slice []Sequence

// Implements [typeinfo.Instance] for a slice of Sequence.
func (*Sequence_Slice) TypeInfo() typeinfo.T {
	return &Zt_Sequence
}

// Implements [typeinfo.Repeats] for a slice of Sequence.
func (op *Sequence_Slice) Repeats() bool {
	return len(*op) > 0
}

// makes a parser scanner.
type ChooseOne struct {
	Options []ScannerMaker
	Markup  map[string]any
}

// choose_one, a type of flow.
var Zt_ChooseOne typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ChooseOne) TypeInfo() typeinfo.T {
	return &Zt_ChooseOne
}

// Implements [typeinfo.Markup]
func (op *ChooseOne) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ ScannerMaker = (*ChooseOne)(nil)

// Holds a slice of type ChooseOne.
type ChooseOne_Slice []ChooseOne

// Implements [typeinfo.Instance] for a slice of ChooseOne.
func (*ChooseOne_Slice) TypeInfo() typeinfo.T {
	return &Zt_ChooseOne
}

// Implements [typeinfo.Repeats] for a slice of ChooseOne.
func (op *ChooseOne_Slice) Repeats() bool {
	return len(*op) > 0
}

// makes a parser scanner.
type Noun struct {
	Kind   string
	Markup map[string]any
}

// noun, a type of flow.
var Zt_Noun typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Noun) TypeInfo() typeinfo.T {
	return &Zt_Noun
}

// Implements [typeinfo.Markup]
func (op *Noun) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ ScannerMaker = (*Noun)(nil)

// Holds a slice of type Noun.
type Noun_Slice []Noun

// Implements [typeinfo.Instance] for a slice of Noun.
func (*Noun_Slice) TypeInfo() typeinfo.T {
	return &Zt_Noun
}

// Implements [typeinfo.Repeats] for a slice of Noun.
func (op *Noun_Slice) Repeats() bool {
	return len(*op) > 0
}

// Change to the bounds of the most recent result.
type Refine struct {
	Series []ScannerMaker
	Markup map[string]any
}

// refine, a type of flow.
var Zt_Refine typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Refine) TypeInfo() typeinfo.T {
	return &Zt_Refine
}

// Implements [typeinfo.Markup]
func (op *Refine) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ ScannerMaker = (*Refine)(nil)

// Holds a slice of type Refine.
type Refine_Slice []Refine

// Implements [typeinfo.Instance] for a slice of Refine.
func (*Refine_Slice) TypeInfo() typeinfo.T {
	return &Zt_Refine
}

// Implements [typeinfo.Repeats] for a slice of Refine.
func (op *Refine_Slice) Repeats() bool {
	return len(*op) > 0
}

// Swap the first and last matching results.
type Reverse struct {
	Reverses []ScannerMaker
	Markup   map[string]any
}

// reverse, a type of flow.
var Zt_Reverse typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Reverse) TypeInfo() typeinfo.T {
	return &Zt_Reverse
}

// Implements [typeinfo.Markup]
func (op *Reverse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ ScannerMaker = (*Reverse)(nil)

// Holds a slice of type Reverse.
type Reverse_Slice []Reverse

// Implements [typeinfo.Instance] for a slice of Reverse.
func (*Reverse_Slice) TypeInfo() typeinfo.T {
	return &Zt_Reverse
}

// Implements [typeinfo.Repeats] for a slice of Reverse.
func (op *Reverse_Slice) Repeats() bool {
	return len(*op) > 0
}

// Select a specific set of bounds for the scanner.
type Focus struct {
	Player string
	Series []ScannerMaker
	Markup map[string]any
}

// focus, a type of flow.
var Zt_Focus typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Focus) TypeInfo() typeinfo.T {
	return &Zt_Focus
}

// Implements [typeinfo.Markup]
func (op *Focus) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ ScannerMaker = (*Focus)(nil)

// Holds a slice of type Focus.
type Focus_Slice []Focus

// Implements [typeinfo.Instance] for a slice of Focus.
func (*Focus_Slice) TypeInfo() typeinfo.T {
	return &Zt_Focus
}

// Implements [typeinfo.Repeats] for a slice of Focus.
func (op *Focus_Slice) Repeats() bool {
	return len(*op) > 0
}

// makes a parser scanner.
type Words struct {
	Words  []string
	Markup map[string]any
}

// words, a type of flow.
var Zt_Words typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Words) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// Implements [typeinfo.Markup]
func (op *Words) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ ScannerMaker = (*Words)(nil)

// Holds a slice of type Words.
type Words_Slice []Words

// Implements [typeinfo.Instance] for a slice of Words.
func (*Words_Slice) TypeInfo() typeinfo.T {
	return &Zt_Words
}

// Implements [typeinfo.Repeats] for a slice of Words.
func (op *Words_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_Directive = typeinfo.Flow{
		Name: "directive",
		Lede: "interpret",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "name",
			Type:  &prim.Zt_Text,
		}, {
			Name:    "series",
			Label:   "with",
			Repeats: true,
			Type:    &Zt_ScannerMaker,
		}},
		Markup: map[string]any{
			"comment":  []interface{}{"starts a parser scanner.", "this is generated by story statement \"DefineNamedGrammar\"", "so that grammar doesn't have to import weave."},
			"internal": true,
		},
	}
	Zt_Action = typeinfo.Flow{
		Name: "action",
		Lede: "action",
		Terms: []typeinfo.Term{{
			Name: "action",
			Type: &prim.Zt_Text,
		}, {
			Name:     "arguments",
			Label:    "args",
			Optional: true,
			Repeats:  true,
			Type:     &call.Zt_Arg,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_ScannerMaker,
		},
		Markup: map[string]any{
			"comment": "makes a parser scanner producing a script defined action.",
		},
	}
	Zt_Sequence = typeinfo.Flow{
		Name: "sequence",
		Lede: "sequence",
		Terms: []typeinfo.Term{{
			Name:    "series",
			Repeats: true,
			Type:    &Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_ScannerMaker,
		},
		Markup: map[string]any{
			"comment": "makes a parser scanner.",
		},
	}
	Zt_ChooseOne = typeinfo.Flow{
		Name: "choose_one",
		Lede: "one",
		Terms: []typeinfo.Term{{
			Name:    "options",
			Label:   "of",
			Repeats: true,
			Type:    &Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_ScannerMaker,
		},
		Markup: map[string]any{
			"comment": "makes a parser scanner.",
		},
	}
	Zt_Noun = typeinfo.Flow{
		Name: "noun",
		Lede: "one",
		Terms: []typeinfo.Term{{
			Name:  "kind",
			Label: "noun",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_ScannerMaker,
		},
		Markup: map[string]any{
			"comment": "makes a parser scanner.",
		},
	}
	Zt_Refine = typeinfo.Flow{
		Name: "refine",
		Lede: "refine",
		Terms: []typeinfo.Term{{
			Name:    "series",
			Label:   "sequence",
			Repeats: true,
			Type:    &Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_ScannerMaker,
		},
		Markup: map[string]any{
			"comment": "Change to the bounds of the most recent result.",
		},
	}
	Zt_Reverse = typeinfo.Flow{
		Name: "reverse",
		Lede: "reverse",
		Terms: []typeinfo.Term{{
			Name:    "reverses",
			Repeats: true,
			Type:    &Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_ScannerMaker,
		},
		Markup: map[string]any{
			"comment": "Swap the first and last matching results.",
		},
	}
	Zt_Focus = typeinfo.Flow{
		Name: "focus",
		Lede: "focus",
		Terms: []typeinfo.Term{{
			Name: "player",
			Type: &prim.Zt_Text,
		}, {
			Name:    "series",
			Label:   "sequence",
			Repeats: true,
			Type:    &Zt_ScannerMaker,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_ScannerMaker,
		},
		Markup: map[string]any{
			"comment": "Select a specific set of bounds for the scanner.",
		},
	}
	Zt_Words = typeinfo.Flow{
		Name: "words",
		Lede: "one",
		Terms: []typeinfo.Term{{
			Name:    "words",
			Label:   "word",
			Repeats: true,
			Type:    &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&Zt_ScannerMaker,
		},
		Markup: map[string]any{
			"comment": "makes a parser scanner.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "grammar",
	Comment: []string{
		"Player input parsing.",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_ScannerMaker,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_Directive,
	&Zt_Action,
	&Zt_Sequence,
	&Zt_ChooseOne,
	&Zt_Noun,
	&Zt_Refine,
	&Zt_Reverse,
	&Zt_Focus,
	&Zt_Words,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	17030018957559107353: (*Directive)(nil), /* Interpret name:with: */
	12048905879374467271: (*Action)(nil),    /* scanner_maker=Action: */
	967998274944030280:   (*Action)(nil),    /* scanner_maker=Action:args: */
	1756442538083378424:  (*Focus)(nil),     /* scanner_maker=Focus:sequence: */
	10964817074887037945: (*Noun)(nil),      /* scanner_maker=One noun: */
	16418039705711067622: (*ChooseOne)(nil), /* scanner_maker=One of: */
	16180319172078511701: (*Words)(nil),     /* scanner_maker=One word: */
	11402479949132197621: (*Refine)(nil),    /* scanner_maker=Refine sequence: */
	15857934419606450901: (*Reverse)(nil),   /* scanner_maker=Reverse: */
	10728359537834940094: (*Sequence)(nil),  /* scanner_maker=Sequence: */
}
