package call

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// trigger, a type of slot.
var Zt_Trigger = typeinfo.Slot{
	Name: "trigger",
	Markup: map[string]any{
		"comment":  "Helper for counting values.",
		"internal": true,
	},
}

// Holds a single slot.
type Trigger_Slot struct{ Value Trigger }

// Implements [typeinfo.Instance] for a single slot.
func (*Trigger_Slot) TypeInfo() typeinfo.T {
	return &Zt_Trigger
}

// Holds a slice of slots.
type Trigger_Slots []Trigger

// Implements [typeinfo.Instance] for a slice of slots.
func (*Trigger_Slots) TypeInfo() typeinfo.T {
	return &Zt_Trigger
}

// Implements [typeinfo.Repeats] for a slice of slots.
func (op *Trigger_Slots) Repeats() bool {
	return len(*op) > 0
}

type ActiveScene struct {
	Name   string
	Markup map[string]any
}

// active_scene, a type of flow.
var Zt_ActiveScene typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ActiveScene) TypeInfo() typeinfo.T {
	return &Zt_ActiveScene
}

// Implements [typeinfo.Markup]
func (op *ActiveScene) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*ActiveScene)(nil)

// Holds a slice of type ActiveScene.
type ActiveScene_Slice []ActiveScene

// Implements [typeinfo.Instance] for a slice of ActiveScene.
func (*ActiveScene_Slice) TypeInfo() typeinfo.T {
	return &Zt_ActiveScene
}

// Implements [typeinfo.Repeats] for a slice of ActiveScene.
func (op *ActiveScene_Slice) Repeats() bool {
	return len(*op) > 0
}

// Decide whether a pattern is running.
type ActivePattern struct {
	PatternName string
	Markup      map[string]any
}

// active_pattern, a type of flow.
var Zt_ActivePattern typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ActivePattern) TypeInfo() typeinfo.T {
	return &Zt_ActivePattern
}

// Implements [typeinfo.Markup]
func (op *ActivePattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*ActivePattern)(nil)
var _ rtti.NumEval = (*ActivePattern)(nil)

// Holds a slice of type ActivePattern.
type ActivePattern_Slice []ActivePattern

// Implements [typeinfo.Instance] for a slice of ActivePattern.
func (*ActivePattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_ActivePattern
}

// Implements [typeinfo.Repeats] for a slice of ActivePattern.
func (op *ActivePattern_Slice) Repeats() bool {
	return len(*op) > 0
}

// Run a pattern, returning its result (if any).
// Tell files support calling patterns directly, so this is only needed by authors using the blockly editor.
// Because some patterns can return a value,this implements all of the possible rtti evaluations.
type CallPattern struct {
	PatternName string
	Arguments   []assign.Arg
	Markup      map[string]any
}

// call_pattern, a type of flow.
var Zt_CallPattern typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallPattern) TypeInfo() typeinfo.T {
	return &Zt_CallPattern
}

// Implements [typeinfo.Markup]
func (op *CallPattern) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*CallPattern)(nil)
var _ rtti.BoolEval = (*CallPattern)(nil)
var _ rtti.NumEval = (*CallPattern)(nil)
var _ rtti.TextEval = (*CallPattern)(nil)
var _ rtti.RecordEval = (*CallPattern)(nil)
var _ rtti.NumListEval = (*CallPattern)(nil)
var _ rtti.TextListEval = (*CallPattern)(nil)
var _ rtti.RecordListEval = (*CallPattern)(nil)

// Holds a slice of type CallPattern.
type CallPattern_Slice []CallPattern

// Implements [typeinfo.Instance] for a slice of CallPattern.
func (*CallPattern_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallPattern
}

// Implements [typeinfo.Repeats] for a slice of CallPattern.
func (op *CallPattern_Slice) Repeats() bool {
	return len(*op) > 0
}

// Runtime version of count_of.
// A guard which returns true based on a counter.
type CallTrigger struct {
	Name    string
	Trigger Trigger
	Num     rtti.NumEval
	Markup  map[string]any
}

// call_trigger, a type of flow.
var Zt_CallTrigger typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CallTrigger) TypeInfo() typeinfo.T {
	return &Zt_CallTrigger
}

// Implements [typeinfo.Markup]
func (op *CallTrigger) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CallTrigger)(nil)

// Holds a slice of type CallTrigger.
type CallTrigger_Slice []CallTrigger

// Implements [typeinfo.Instance] for a slice of CallTrigger.
func (*CallTrigger_Slice) TypeInfo() typeinfo.T {
	return &Zt_CallTrigger
}

// Implements [typeinfo.Repeats] for a slice of CallTrigger.
func (op *CallTrigger_Slice) Repeats() bool {
	return len(*op) > 0
}

// call_trigger
type TriggerCycle struct {
	Markup map[string]any
}

// trigger_cycle, a type of flow.
var Zt_TriggerCycle typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TriggerCycle) TypeInfo() typeinfo.T {
	return &Zt_TriggerCycle
}

// Implements [typeinfo.Markup]
func (op *TriggerCycle) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Trigger = (*TriggerCycle)(nil)

// Holds a slice of type TriggerCycle.
type TriggerCycle_Slice []TriggerCycle

// Implements [typeinfo.Instance] for a slice of TriggerCycle.
func (*TriggerCycle_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerCycle
}

// Implements [typeinfo.Repeats] for a slice of TriggerCycle.
func (op *TriggerCycle_Slice) Repeats() bool {
	return len(*op) > 0
}

// call_trigger
type TriggerOnce struct {
	Markup map[string]any
}

// trigger_once, a type of flow.
var Zt_TriggerOnce typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TriggerOnce) TypeInfo() typeinfo.T {
	return &Zt_TriggerOnce
}

// Implements [typeinfo.Markup]
func (op *TriggerOnce) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Trigger = (*TriggerOnce)(nil)

// Holds a slice of type TriggerOnce.
type TriggerOnce_Slice []TriggerOnce

// Implements [typeinfo.Instance] for a slice of TriggerOnce.
func (*TriggerOnce_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerOnce
}

// Implements [typeinfo.Repeats] for a slice of TriggerOnce.
func (op *TriggerOnce_Slice) Repeats() bool {
	return len(*op) > 0
}

// call_trigger
type TriggerSwitch struct {
	Markup map[string]any
}

// trigger_switch, a type of flow.
var Zt_TriggerSwitch typeinfo.Flow

// Implements [typeinfo.Instance]
func (*TriggerSwitch) TypeInfo() typeinfo.T {
	return &Zt_TriggerSwitch
}

// Implements [typeinfo.Markup]
func (op *TriggerSwitch) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ Trigger = (*TriggerSwitch)(nil)

// Holds a slice of type TriggerSwitch.
type TriggerSwitch_Slice []TriggerSwitch

// Implements [typeinfo.Instance] for a slice of TriggerSwitch.
func (*TriggerSwitch_Slice) TypeInfo() typeinfo.T {
	return &Zt_TriggerSwitch
}

// Implements [typeinfo.Repeats] for a slice of TriggerSwitch.
func (op *TriggerSwitch_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_ActiveScene = typeinfo.Flow{
		Name: "active_scene",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "name",
			Label: "scene",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
	}
	Zt_ActivePattern = typeinfo.Flow{
		Name: "active_pattern",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "pattern_name",
			Label: "pattern",
			Type:  &prim.Zt_Text,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Decide whether a pattern is running.",
		},
	}
	Zt_CallPattern = typeinfo.Flow{
		Name: "call_pattern",
		Lede: "determine",
		Terms: []typeinfo.Term{{
			Name: "pattern_name",
			Markup: map[string]any{
				"comment": "The name of the pattern to run.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "arguments",
			Label:   "args",
			Repeats: true,
			Markup: map[string]any{
				"comment": []interface{}{"Arguments to pass to the pattern.", "Any unnamed arguments must proceed all named arguments. Unnamed arguments are assigned to parameters in the order the parameters were declared. It's considered an error to assign the same parameter multiple times."},
			},
			Type: &assign.Zt_Arg,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
			&rtti.Zt_TextEval,
			&rtti.Zt_RecordEval,
			&rtti.Zt_NumListEval,
			&rtti.Zt_TextListEval,
			&rtti.Zt_RecordListEval,
		},
		Markup: map[string]any{
			"comment": []interface{}{"Run a pattern, returning its result (if any).", "Tell files support calling patterns directly, so this is only needed by authors using the blockly editor.", "Because some patterns can return a value,this implements all of the possible rtti evaluations."},
		},
	}
	Zt_CallTrigger = typeinfo.Flow{
		Name: "call_trigger",
		Lede: "trigger",
		Terms: []typeinfo.Term{{
			Name: "name",
			Type: &prim.Zt_Text,
		}, {
			Name:  "trigger",
			Label: "on",
			Type:  &Zt_Trigger,
		}, {
			Name:  "num",
			Label: "num",
			Type:  &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment":  []interface{}{"Runtime version of count_of.", "A guard which returns true based on a counter."},
			"internal": true,
		},
	}
	Zt_TriggerCycle = typeinfo.Flow{
		Name:  "trigger_cycle",
		Lede:  "every",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
		Markup: map[string]any{
			"comment":  "call_trigger",
			"internal": true,
		},
	}
	Zt_TriggerOnce = typeinfo.Flow{
		Name:  "trigger_once",
		Lede:  "at",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
		Markup: map[string]any{
			"comment":  "call_trigger",
			"internal": true,
		},
	}
	Zt_TriggerSwitch = typeinfo.Flow{
		Name:  "trigger_switch",
		Lede:  "after",
		Terms: []typeinfo.Term{},
		Slots: []*typeinfo.Slot{
			&Zt_Trigger,
		},
		Markup: map[string]any{
			"comment":  "call_trigger",
			"internal": true,
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "call",
	Comment: []string{
		"",
	},

	Slot:       z_slot_list,
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all slots in this this package.
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Zt_Trigger,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_ActiveScene,
	&Zt_ActivePattern,
	&Zt_CallPattern,
	&Zt_CallTrigger,
	&Zt_TriggerCycle,
	&Zt_TriggerOnce,
	&Zt_TriggerSwitch,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	9392469773844077696:  (*TriggerSwitch)(nil), /* trigger=After */
	2233111806717201007:  (*TriggerOnce)(nil),   /* trigger=At */
	5430006510328108403:  (*CallPattern)(nil),   /* bool_eval=Determine:args: */
	11666175118824200195: (*CallPattern)(nil),   /* execute=Determine:args: */
	9675109928599400849:  (*CallPattern)(nil),   /* num_eval=Determine:args: */
	16219448703619493492: (*CallPattern)(nil),   /* num_list_eval=Determine:args: */
	13992013847750998452: (*CallPattern)(nil),   /* record_eval=Determine:args: */
	352268441608212603:   (*CallPattern)(nil),   /* record_list_eval=Determine:args: */
	5079530186593846942:  (*CallPattern)(nil),   /* text_eval=Determine:args: */
	13938609641525654217: (*CallPattern)(nil),   /* text_list_eval=Determine:args: */
	1457631626735043065:  (*TriggerCycle)(nil),  /* trigger=Every */
	10847423070654993213: (*ActivePattern)(nil), /* bool_eval=Is pattern: */
	15097434718788250679: (*ActivePattern)(nil), /* num_eval=Is pattern: */
	2257319580031922583:  (*ActiveScene)(nil),   /* bool_eval=Is scene: */
	2711869841453509536:  (*CallTrigger)(nil),   /* bool_eval=Trigger:on:num: */
}
