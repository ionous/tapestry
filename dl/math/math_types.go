// Common mathematical operations.
package math

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
	"strconv"
)

// Add two numbers and return the result.
type AddValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// add_value, a type of flow.
var Zt_AddValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AddValue) TypeInfo() typeinfo.T {
	return &Zt_AddValue
}

// Implements [typeinfo.Markup]
func (op *AddValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*AddValue)(nil)

// Holds a slice of type AddValue.
type AddValue_Slice []AddValue

// Implements [typeinfo.Instance] for a slice of AddValue.
func (*AddValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AddValue
}

// Implements [typeinfo.Repeats] for a slice of AddValue.
func (op *AddValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Subtract two numbers and return the result.
type SubtractValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// subtract_value, a type of flow.
var Zt_SubtractValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*SubtractValue) TypeInfo() typeinfo.T {
	return &Zt_SubtractValue
}

// Implements [typeinfo.Markup]
func (op *SubtractValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*SubtractValue)(nil)

// Holds a slice of type SubtractValue.
type SubtractValue_Slice []SubtractValue

// Implements [typeinfo.Instance] for a slice of SubtractValue.
func (*SubtractValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_SubtractValue
}

// Implements [typeinfo.Repeats] for a slice of SubtractValue.
func (op *SubtractValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Multiply two numbers and return the result.
type MultiplyValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// multiply_value, a type of flow.
var Zt_MultiplyValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MultiplyValue) TypeInfo() typeinfo.T {
	return &Zt_MultiplyValue
}

// Implements [typeinfo.Markup]
func (op *MultiplyValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*MultiplyValue)(nil)

// Holds a slice of type MultiplyValue.
type MultiplyValue_Slice []MultiplyValue

// Implements [typeinfo.Instance] for a slice of MultiplyValue.
func (*MultiplyValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_MultiplyValue
}

// Implements [typeinfo.Repeats] for a slice of MultiplyValue.
func (op *MultiplyValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Divide one number by another and return the result.
type DivideValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// divide_value, a type of flow.
var Zt_DivideValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*DivideValue) TypeInfo() typeinfo.T {
	return &Zt_DivideValue
}

// Implements [typeinfo.Markup]
func (op *DivideValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*DivideValue)(nil)

// Holds a slice of type DivideValue.
type DivideValue_Slice []DivideValue

// Implements [typeinfo.Instance] for a slice of DivideValue.
func (*DivideValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_DivideValue
}

// Implements [typeinfo.Repeats] for a slice of DivideValue.
func (op *DivideValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Divide one number by another and return the remainder.
type ModValue struct {
	A      rtti.NumEval
	B      rtti.NumEval
	Markup map[string]any
}

// mod_value, a type of flow.
var Zt_ModValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ModValue) TypeInfo() typeinfo.T {
	return &Zt_ModValue
}

// Implements [typeinfo.Markup]
func (op *ModValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*ModValue)(nil)

// Holds a slice of type ModValue.
type ModValue_Slice []ModValue

// Implements [typeinfo.Instance] for a slice of ModValue.
func (*ModValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_ModValue
}

// Implements [typeinfo.Repeats] for a slice of ModValue.
func (op *ModValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Remove the sign from a value and return its positive value.
type AbsValue struct {
	Value  rtti.NumEval
	Markup map[string]any
}

// abs_value, a type of flow.
var Zt_AbsValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*AbsValue) TypeInfo() typeinfo.T {
	return &Zt_AbsValue
}

// Implements [typeinfo.Markup]
func (op *AbsValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*AbsValue)(nil)

// Holds a slice of type AbsValue.
type AbsValue_Slice []AbsValue

// Implements [typeinfo.Instance] for a slice of AbsValue.
func (*AbsValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_AbsValue
}

// Implements [typeinfo.Repeats] for a slice of AbsValue.
func (op *AbsValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Increase a stored value and, optionally, return the new value.
type Increment struct {
	Target rtti.Address
	Step   rtti.NumEval
	Markup map[string]any
}

// increment, a type of flow.
var Zt_Increment typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Increment) TypeInfo() typeinfo.T {
	return &Zt_Increment
}

// Implements [typeinfo.Markup]
func (op *Increment) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*Increment)(nil)
var _ rtti.Execute = (*Increment)(nil)

// Holds a slice of type Increment.
type Increment_Slice []Increment

// Implements [typeinfo.Instance] for a slice of Increment.
func (*Increment_Slice) TypeInfo() typeinfo.T {
	return &Zt_Increment
}

// Implements [typeinfo.Repeats] for a slice of Increment.
func (op *Increment_Slice) Repeats() bool {
	return len(*op) > 0
}

// Decrease a stored value and, optionally, return the new value.
type Decrement struct {
	Target rtti.Address
	Step   rtti.NumEval
	Markup map[string]any
}

// decrement, a type of flow.
var Zt_Decrement typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Decrement) TypeInfo() typeinfo.T {
	return &Zt_Decrement
}

// Implements [typeinfo.Markup]
func (op *Decrement) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*Decrement)(nil)
var _ rtti.Execute = (*Decrement)(nil)

// Holds a slice of type Decrement.
type Decrement_Slice []Decrement

// Implements [typeinfo.Instance] for a slice of Decrement.
func (*Decrement_Slice) TypeInfo() typeinfo.T {
	return &Zt_Decrement
}

// Implements [typeinfo.Repeats] for a slice of Decrement.
func (op *Decrement_Slice) Repeats() bool {
	return len(*op) > 0
}

// Compare two values.
// If the two values are of different types, this will attempt -- in a limited way -- to coerce the second value to match the type of the first value before comparing them.
//
// Any value can be coerced to bool ( following the truthiness rules for [IsValue] ), and bool and num values can be coerced into text.
// Otherwise, the types of the values must match exactly.
//
// Numbers are compared using an internally determined default tolerance.
// To control the tolerance between numbers, use [CompareNum].
type CompareValue struct {
	A       rtti.Assignment
	Compare Comparison
	B       rtti.Assignment
	Markup  map[string]any
}

// compare_value, a type of flow.
var Zt_CompareValue typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CompareValue) TypeInfo() typeinfo.T {
	return &Zt_CompareValue
}

// Implements [typeinfo.Markup]
func (op *CompareValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CompareValue)(nil)

// Holds a slice of type CompareValue.
type CompareValue_Slice []CompareValue

// Implements [typeinfo.Instance] for a slice of CompareValue.
func (*CompareValue_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareValue
}

// Implements [typeinfo.Repeats] for a slice of CompareValue.
func (op *CompareValue_Slice) Repeats() bool {
	return len(*op) > 0
}

// Compare two numbers.
type CompareNum struct {
	A         rtti.NumEval
	Compare   Comparison
	B         rtti.NumEval
	Tolerance float64
	Markup    map[string]any
}

// compare_num, a type of flow.
var Zt_CompareNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CompareNum) TypeInfo() typeinfo.T {
	return &Zt_CompareNum
}

// Implements [typeinfo.Markup]
func (op *CompareNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CompareNum)(nil)

// Holds a slice of type CompareNum.
type CompareNum_Slice []CompareNum

// Implements [typeinfo.Instance] for a slice of CompareNum.
func (*CompareNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareNum
}

// Implements [typeinfo.Repeats] for a slice of CompareNum.
func (op *CompareNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Compare two text values in "lexical" ( alphabetical ) order.
type CompareText struct {
	A       rtti.TextEval
	Compare Comparison
	B       rtti.TextEval
	Markup  map[string]any
}

// compare_text, a type of flow.
var Zt_CompareText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*CompareText) TypeInfo() typeinfo.T {
	return &Zt_CompareText
}

// Implements [typeinfo.Markup]
func (op *CompareText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*CompareText)(nil)

// Holds a slice of type CompareText.
type CompareText_Slice []CompareText

// Implements [typeinfo.Instance] for a slice of CompareText.
func (*CompareText_Slice) TypeInfo() typeinfo.T {
	return &Zt_CompareText
}

// Implements [typeinfo.Repeats] for a slice of CompareText.
func (op *CompareText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Used when comparing values.
type Comparison int

// The enumerated values of Comparison.
const (
	C_Comparison_EqualTo Comparison = iota
	C_Comparison_OtherThan
	C_Comparison_GreaterThan
	C_Comparison_LessThan
	C_Comparison_AtLeast
	C_Comparison_AtMost
)

func MakeComparison(str string) (ret Comparison, okay bool) {
	if i := Zt_Comparison.FindOption(str); i >= 0 {
		ret, okay = Comparison(i), true
	}
	return
}

func (op Comparison) String() (ret string) {
	if i, opts := int(op), Zt_Comparison.Options; i >= 0 && i < len(opts) {
		ret = opts[i]
	} else {
		ret = "Invalid Comparison(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return
}

// comparison, a type of str enum.
var Zt_Comparison = typeinfo.Str{
	Name: "comparison",
	Options: []string{
		"equal_to",
		"other_than",
		"greater_than",
		"less_than",
		"at_least",
		"at_most",
	},
	Markup: map[string]any{
		"comment": "Used when comparing values.",
	},
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_AddValue = typeinfo.Flow{
		Name: "add_value",
		Lede: "add",
		Terms: []typeinfo.Term{{
			Name: "a",
			Markup: map[string]any{
				"comment": "The augend.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Markup: map[string]any{
				"comment": "The addend.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Add two numbers and return the result.",
		},
	}
	Zt_SubtractValue = typeinfo.Flow{
		Name: "subtract_value",
		Lede: "subtract",
		Terms: []typeinfo.Term{{
			Name: "a",
			Markup: map[string]any{
				"comment": "The minuend.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Markup: map[string]any{
				"comment": "The subtrahend.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Subtract two numbers and return the result.",
		},
	}
	Zt_MultiplyValue = typeinfo.Flow{
		Name: "multiply_value",
		Lede: "multiply",
		Terms: []typeinfo.Term{{
			Name: "a",
			Markup: map[string]any{
				"comment": "The multiplier.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Markup: map[string]any{
				"comment": "The multiplicand.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Multiply two numbers and return the result.",
		},
	}
	Zt_DivideValue = typeinfo.Flow{
		Name: "divide_value",
		Lede: "divide",
		Terms: []typeinfo.Term{{
			Name: "a",
			Markup: map[string]any{
				"comment": "The numerator.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Markup: map[string]any{
				"comment": "The divisor.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Divide one number by another and return the result.",
		},
	}
	Zt_ModValue = typeinfo.Flow{
		Name: "mod_value",
		Lede: "mod",
		Terms: []typeinfo.Term{{
			Name: "a",
			Markup: map[string]any{
				"comment": "The dividend.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "b",
			Label: "value",
			Markup: map[string]any{
				"comment": "The divisor.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Divide one number by another and return the remainder.",
		},
	}
	Zt_AbsValue = typeinfo.Flow{
		Name: "abs_value",
		Lede: "absolute",
		Terms: []typeinfo.Term{{
			Name:  "value",
			Label: "value",
			Markup: map[string]any{
				"comment": "The value to normalize.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"comment": "Remove the sign from a value and return its positive value.",
		},
	}
	Zt_Increment = typeinfo.Flow{
		Name: "increment",
		Lede: "increase",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"comment": []string{"A reference to the value to increase.", "This reads and writes to that value."},
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "If not specified, increments by 1.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Increase a stored value and, optionally, return the new value.",
		},
	}
	Zt_Decrement = typeinfo.Flow{
		Name: "decrement",
		Lede: "decrease",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"comment": []string{"A reference to the value to decrease.", "This reads and writes to that value."},
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"comment": "if not specified, decrements by 1.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"comment": "Decrease a stored value and, optionally, return the new value.",
		},
	}
	Zt_CompareValue = typeinfo.Flow{
		Name: "compare_value",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Markup: map[string]any{
				"comment": []string{"The first value.", "If needed, the second value will coerced to match the type of the first."},
			},
			Type: &rtti.Zt_Assignment,
		}, {
			Name:  "compare",
			Label: "matching",
			Markup: map[string]any{
				"comment": "The specific way to compare the two values.",
			},
			Type: &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "value",
			Markup: map[string]any{
				"comment": []string{"The first value.", "If needed, this value will coerced to match the type of the first value."},
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": []string{"Compare two values.", "If the two values are of different types, this will attempt -- in a limited way -- to coerce the second value to match the type of the first value before comparing them.", "", "Any value can be coerced to bool ( following the truthiness rules for [IsValue] ), and bool and num values can be coerced into text.", "Otherwise, the types of the values must match exactly.", "", "Numbers are compared using an internally determined default tolerance.", "To control the tolerance between numbers, use [CompareNum]."},
		},
	}
	Zt_CompareNum = typeinfo.Flow{
		Name: "compare_num",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Markup: map[string]any{
				"comment": "The first number.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "compare",
			Label: "matching",
			Markup: map[string]any{
				"comment": "The specific way to compare the two numbers.",
			},
			Type: &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "num",
			Markup: map[string]any{
				"comment": "The second number.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "tolerance",
			Label:    "within",
			Optional: true,
			Markup: map[string]any{
				"comment": "A positive value to indicate how close the two numbers can be.",
			},
			Type: &prim.Zt_Num,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Compare two numbers.",
		},
	}
	Zt_CompareText = typeinfo.Flow{
		Name: "compare_text",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name: "a",
			Markup: map[string]any{
				"comment": "The first text value.",
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:  "compare",
			Label: "matching",
			Markup: map[string]any{
				"comment": "The specific way to compare the two text values.",
			},
			Type: &Zt_Comparison,
		}, {
			Name:  "b",
			Label: "text",
			Markup: map[string]any{
				"comment": "The second text value.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"comment": "Compare two text values in \"lexical\" ( alphabetical ) order.",
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "math",
	Comment: []string{
		"Common mathematical operations.",
	},

	Flow:       z_flow_list,
	Str:        z_str_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_AddValue,
	&Zt_SubtractValue,
	&Zt_MultiplyValue,
	&Zt_DivideValue,
	&Zt_ModValue,
	&Zt_AbsValue,
	&Zt_Increment,
	&Zt_Decrement,
	&Zt_CompareValue,
	&Zt_CompareNum,
	&Zt_CompareText,
}

// A list of all strs in this this package.
var z_str_list = []*typeinfo.Str{
	&Zt_Comparison,
}

// gob like registration
func Register(reg func(any)) {
	reg(AddValue{})
	reg(SubtractValue{})
	reg(MultiplyValue{})
	reg(DivideValue{})
	reg(ModValue{})
	reg(AbsValue{})
	reg(Increment{})
	reg(Decrement{})
	reg(CompareValue{})
	reg(CompareNum{})
	reg(CompareText{})
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	1399610288338666093:  (*AbsValue)(nil),      /* num_eval=Absolute value: */
	5038997598380008995:  (*AddValue)(nil),      /* num_eval=Add:value: */
	1765941604351725175:  (*Decrement)(nil),     /* execute=Decrease: */
	2127914973580247945:  (*Decrement)(nil),     /* num_eval=Decrease: */
	906537561468635208:   (*Decrement)(nil),     /* execute=Decrease:by: */
	10626433780618545830: (*Decrement)(nil),     /* num_eval=Decrease:by: */
	878353350484094823:   (*DivideValue)(nil),   /* num_eval=Divide:value: */
	3419326304120453839:  (*Increment)(nil),     /* execute=Increase: */
	4329501782528502333:  (*Increment)(nil),     /* num_eval=Increase: */
	9916665856596995152:  (*Increment)(nil),     /* execute=Increase:by: */
	17764432315137014386: (*Increment)(nil),     /* num_eval=Increase:by: */
	4986574662941955696:  (*CompareNum)(nil),    /* bool_eval=Is:matching:num: */
	6471221873898876231:  (*CompareNum)(nil),    /* bool_eval=Is:matching:num:within: */
	2616749751052919401:  (*CompareText)(nil),   /* bool_eval=Is:matching:text: */
	7216474174347601443:  (*CompareValue)(nil),  /* bool_eval=Is:matching:value: */
	6501544922110637214:  (*ModValue)(nil),      /* num_eval=Mod:value: */
	1256349697579623184:  (*MultiplyValue)(nil), /* num_eval=Multiply:value: */
	17065007156382311204: (*SubtractValue)(nil), /* num_eval=Subtract:value: */
}
