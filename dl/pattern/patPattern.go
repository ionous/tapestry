package pattern

import (
	"strconv"

	"git.sr.ht/~ionous/iffy/affine"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/rt"
	g "git.sr.ht/~ionous/iffy/rt/generic"
	"git.sr.ht/~ionous/iffy/rt/safe"
	"github.com/ionous/errutil"
)

type Pattern struct {
	Name   string
	Return string            // name of return field; empty if none ( could be an index but slightly safer this way )
	Labels []string          // one label for every parameter
	Locals []core.Assignment // usually equal to the number of locals; or nil for testing.
	Fields []g.Field         // flat list of params and locals and an optional return
	Rules  []*Rule
}

// track the number of times a particular field gets successfully written to.
type resultsWatcher struct {
	rt.Scope
	watch string
	sets  int
}

func (rw *resultsWatcher) SetFieldByName(field string, val g.Value) (err error) {
	if e := rw.Scope.SetFieldByName(field, val); e != nil {
		err = e
	} else if field == rw.watch {
		rw.sets++
		// we could also store the last value set,
		// and use that for our result --
		// but if nothing is set, it feels better to use the default record value production
		// generated by record.GetNamedField
	}
	return
}

func (pat *Pattern) Run(run rt.Runtime, args []*core.Argument, aff affine.Affinity) (ret g.Value, err error) {
	// create a container to hold results of args, locals, and the pending return value
	rec := g.NewAnonymousRecord(run, pat.Fields)
	// args run in the scope of their parent context
	// they write to the record that will become the new context
	if e := pat.determineArgs(run, rec, args); e != nil {
		err = e
	} else {
		// initializers ( and the pattern itself ) run in the scope of the pattern
		// ( with access to all locals and args)
		watcher := &resultsWatcher{
			Scope: g.RecordOf(rec),
			watch: pat.Return,
		}
		oldScope := run.ReplaceScope(watcher)
		// locals ( by definition ) write to the record context
		if e := pat.initializeLocals(run, rec); e != nil {
			err = e
		} else if e := pat.executePattern(run, watcher); e != nil {
			err = e
		} else if res, e := pat.getResult(rec, aff); e != nil {
			err = e
		} else {
			ret = res
		}
		//
		run.ReplaceScope(oldScope)
	}
	return
}

func (pat *Pattern) determineArgs(run rt.Runtime, rec *g.Record, args []*core.Argument) (err error) {
	// future: args matching is predetermined in reading / parsing
	// note: templates (ex. print_article) dont always specify all the parameters...
	if paramCnt, argCnt := len(pat.Labels), len(args); paramCnt < argCnt {
		err = errutil.New("expected", paramCnt, "parameters(s), have", argCnt, "arguments")
	} else {
		// note: set indexed field assigns without copying
		for i, a := range args {
			if n, l := a.Name, pat.Labels[i]; n != l && n != argIndex(i) {
				err = errutil.New("has mismatched arg.", i, "expected", l, "have", n)
				break
			} else if val, e := core.GetAssignedValue(run, a.From); e != nil {
				err = errutil.New("error determining arg", i, n, e)
				break
			} else if v, e := filterText(run, pat.Fields[i], val); e != nil {
				err = errutil.New("error narrowing arg", i, n, e)
				break
			} else if e := rec.SetIndexedField(i, v); e != nil {
				err = errutil.New("error setting arg", i, n, e)
				break
			}
		}
	}
	return
}

// fix? allows callers to use positional arguments
// for lists could have a special RunWithVarArgs that uses a custom determineArgs
// or, allow blank names to match any arg --
// note: templates currently use positional args too.
func argIndex(i int) string {
	return "$" + strconv.Itoa(i+1)
}

func (pat *Pattern) initializeLocals(run rt.Runtime, rec *g.Record) (err error) {
	lin, fin, lcnt := 0, len(pat.Labels), len(pat.Locals) // locals start after labels
	for lin < lcnt {
		if field, init := pat.Fields[fin], pat.Locals[lin]; init != nil {
			if v, e := init.GetAssignedValue(run); e != nil {
				err = errutil.New(pat.Name, "error determining local", lin, field.Name, e)
				break
			} else if e := rec.SetIndexedField(fin, v); e != nil {
				err = errutil.New(pat.Name, "error setting local", lin, field.Name, e)
				break
			}
		}
		lin++
		fin++
	}
	return
}

// RunWithScope - note: assumes whatever scope is needed to run the pattern has already been setup.
func (pat *Pattern) executePattern(run rt.Runtime, rw *resultsWatcher) (err error) {
	if inds, e := sortRules(run, pat.Rules); e != nil {
		err = e // this cant happen currently
	} else {
		for _, i := range inds {
			rule := pat.Rules[i]
			if ok, e := safe.GetOptionalBool(run, rule.Filter, true); e != nil {
				err = e
			} else if ok.Bool() { // the rule returns false if it didnt apply
				if e := safe.Run(run, rule.Execute); e != nil {
					err = e
					break
				} else if rw.sets > 0 || len(rw.watch) == 0 {
					// ... and we're done.
					break
				}
				// NOTE: if we need to differentiate between "no errors" and "no rules matched",
				// the latter could become an error.
			}
		}
	}
	return
}

func (pat *Pattern) getResult(rec *g.Record, aff affine.Affinity) (ret g.Value, err error) {
	// labels=parameters, inits=locals, the rest ( no more than 1 ) is the return.
	if res := pat.Return; len(res) > 0 {
		// get the value and check its result
		if res, e := rec.GetNamedField(res); e != nil {
			err = errutil.New("error trying to get return value", e)
		} else if e := safe.Check(res, aff); e != nil {
			err = errutil.New("error trying to get return value", e)
		} else if len(aff) == 0 {
			// the caller expects nothing but we have a return value.
			if res.Affinity() == affine.Text {
				core.HackTillTemplatesCanEvaluatePatternTypes = res.String()
			}
			// other than passing data back to templates in a hack...
			// we dont treat this as an error -- we allow patterns to be run for side effects.
		} else {
			ret = res
		}
	} else if len(aff) != 0 {
		err = errutil.New("caller expected", aff, "returned nothing")
	}
	return
}
