package pattern

import (
	"strconv"

	"git.sr.ht/~ionous/iffy/affine"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/rt"
	g "git.sr.ht/~ionous/iffy/rt/generic"
	"git.sr.ht/~ionous/iffy/rt/safe"
	"github.com/ionous/errutil"
)

type Pattern struct {
	Name   string
	Return string            // name of return field; empty if none ( could be an index but slightly safer this way )
	Labels []string          // one label for every parameter
	Locals []core.Assignment // usually equal to the number of locals; or nil for testing.
	Fields []g.Field         // flat list of params and locals and an optional return
	Rules  []*Rule
}

// track the number of times a particular field gets successfully written to.
type resultsWatcher struct {
	rt.Scope
	watch string
	sets  int
}

func (rw *resultsWatcher) SetFieldByName(field string, val g.Value) (err error) {
	if e := rw.Scope.SetFieldByName(field, val); e != nil {
		err = e
	} else if field == rw.watch {
		rw.sets++
		// we could also store the last value set,
		// and use that for our result --
		// but if nothing is set, it feels better to use the default record value production
		// generated by record.GetNamedField
	}
	return
}

func (pat *Pattern) Run(run rt.Runtime, args []*core.Argument, aff affine.Affinity) (ret g.Value, err error) {
	// create a container to hold results of args, locals, and the pending return value
	rec := g.NewAnonymousRecord(run, pat.Fields)
	// args run in the scope of their parent context
	// they write to the record that will become the new context
	if e := pat.determineArgs(run, rec, args); e != nil {
		err = e
	} else {
		// initializers ( and the pattern itself ) run in the scope of the pattern
		// ( with access to all locals and args)
		watcher := &resultsWatcher{
			Scope: g.RecordOf(rec),
			watch: pat.Return,
		}
		oldScope := run.ReplaceScope(watcher)
		// locals ( by definition ) write to the record context
		if e := pat.initializeLocals(run, rec); e != nil {
			err = e
		} else if e := pat.executePattern(run, watcher); e != nil {
			err = e
		} else if res, e := pat.getResult(rec, aff); e != nil {
			err = e
		} else {
			ret = res
		}
		//
		run.ReplaceScope(oldScope)
	}
	return
}

func (pat *Pattern) determineArgs(run rt.Runtime, rec *g.Record, args []*core.Argument) (err error) {
	// note: set indexed field assigns without copying
	var labelIndex int
	var fieldIndex int
	for i, a := range args {
		n := a.Name
		// search for a matching label.
		if len(n) == 0 {
			err = errutil.New("unnamed arg at", i)
		} else if n[0] == '$' {
			// validate positional arguments make sense
			if argIndex(labelIndex) != n {
				break
			}
			fieldIndex, labelIndex = labelIndex, labelIndex+1
		} else {
			// search in increasing order for the next label that matches the specified argument
			// this is our soft way of allowing patterns to participate in fluid like specs.
			if i := pat.findLabel(n, labelIndex); i < 0 {
				err = errutil.New("has mismatched arg.", i, n)
				break
			} else {
				fieldIndex, labelIndex = i, i+1
			}
		}
		//
		field := pat.Fields[fieldIndex]
		if val, e := core.GetAssignedValue(run, a.From); e != nil {
			err = errutil.New("error determining arg", i, n, e)
			break
		} else if v, e := filterText(run, field, val); e != nil {
			err = errutil.New("error narrowing arg", i, n, e)
			break
		} else if e := rec.SetIndexedField(fieldIndex, v); e != nil {
			err = errutil.New("error setting arg", i, n, e)
			break
		}
	}
	return
}

// returns -1 if not found
func (pat *Pattern) findLabel(name string, startingAt int) (ret int) {
	ret = -1 // provisionally
	for i, cnt := startingAt, len(pat.Labels); i < cnt; i++ {
		if l := pat.Labels[i]; l == name {
			ret = i
			break
		}
	}
	return
}

// fix? allows callers to use positional arguments
// for lists could have a special RunWithVarArgs that uses a custom determineArgs
// or, allow blank names to match any arg --
// note: templates currently use positional args too.
func argIndex(i int) string {
	return "$" + strconv.Itoa(i+1)
}

func (pat *Pattern) initializeLocals(run rt.Runtime, rec *g.Record) (err error) {
	lin, fin, lcnt := 0, len(pat.Labels), len(pat.Locals) // locals start after labels
	for lin < lcnt {
		if field, init := pat.Fields[fin], pat.Locals[lin]; init != nil {
			if v, e := init.GetAssignedValue(run); e != nil {
				err = errutil.New(pat.Name, "error determining local", lin, field.Name, e)
				break
			} else if e := rec.SetIndexedField(fin, v); e != nil {
				err = errutil.New(pat.Name, "error setting local", lin, field.Name, e)
				break
			}
		}
		lin++
		fin++
	}
	return
}

// RunWithScope - note: assumes whatever scope is needed to run the pattern has already been setup.
func (pat *Pattern) executePattern(run rt.Runtime, rw *resultsWatcher) (err error) {
	sets := rw.sets
	inds, allFlags := sortRules(pat.Rules)
	for j, cnt := 0, len(inds); j < cnt && allFlags != 0; j++ {
		i := inds[j]
		if ranFlag, e := pat.Rules[i].ApplyRule(run, allFlags); e != nil {
			err = e
		} else if ranFlag != 0 {
			didSomething := (rw.sets > sets)
			sets = rw.sets
			// if we ran a prefix or a post fix rule and it did something, we are done.
			if didSomething && ranFlag != Infix {
				break
			}
			// otherwise, if an infix rule did something
			// check the other kinds of rules
			// ditto if we dont expect the pattern to return anything:
			// in that case we just want to do the first of each rule type.
			if didSomething || len(rw.watch) == 0 {
				allFlags = allFlags &^ ranFlag
			}
		}
	}
	return
}

func (pat *Pattern) getResult(rec *g.Record, aff affine.Affinity) (ret g.Value, err error) {
	// labels=parameters, inits=locals, the rest ( no more than 1 ) is the return.
	if res := pat.Return; len(res) > 0 {
		// get the value and check its result
		if res, e := rec.GetNamedField(res); e != nil {
			err = errutil.New("error trying to get return value", e)
		} else if e := safe.Check(res, aff); e != nil {
			err = errutil.New("error trying to get return value", e)
		} else if len(aff) == 0 {
			// the caller expects nothing but we have a return value.
			if res.Affinity() == affine.Text {
				core.HackTillTemplatesCanEvaluatePatternTypes = res.String()
			}
			// other than passing data back to templates in a hack...
			// we dont treat this as an error -- we allow patterns to be run for side effects.
		} else {
			ret = res
		}
	} else if len(aff) != 0 {
		err = errutil.New("caller expected", aff, "returned nothing")
	}
	return
}
