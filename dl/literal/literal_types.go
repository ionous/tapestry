// Code generated by Tapestry; edit at your own risk.
package literal

import (
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// literal_value, a type of slot.
const Z_LiteralValue_Name = "literal_value"

var Z_LiteralValue_T = typeinfo.Slot{
	Name: Z_LiteralValue_Name,
	Markup: map[string]any{
		"blockly-color": "MATH_HUE",
		"comment":       "Slot for constant values.",
	},
}

// holds a single slot
// FIX: currently provided by the spec
type FIX_LiteralValue_Slot struct{ Value LiteralValue }

// implements typeinfo.Inspector for a single slot.
func (*FIX_LiteralValue_Slot) Inspect() typeinfo.T {
	return &Z_LiteralValue_T
}

// holds a slice of slots
type LiteralValue_Slots []LiteralValue

// implements typeinfo.Inspector for a series of slots.
func (*LiteralValue_Slots) Inspect() typeinfo.T {
	return &Z_LiteralValue_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_BoolValue struct {
	Value  bool
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*BoolValue) Inspect() typeinfo.T {
	return &Z_BoolValue_T
}

// return a valid markup map, creating it if necessary.
func (op *BoolValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// bool_value, a type of flow.
const Z_BoolValue_Name = "bool_value"

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*BoolValue)(nil)
var _ LiteralValue = (*BoolValue)(nil)

var Z_BoolValue_T = typeinfo.Flow{
	Name: Z_BoolValue_Name,
	Lede: "bool",
	Terms: []typeinfo.Term{{
		Name:  "value",
		Label: "value",
		Type:  &prim.Z_Bool_T,
	}, {
		Name:     "kind",
		Label:    "kind",
		Optional: true,
		Type:     &prim.Z_Text_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_BoolEval_T,
		&Z_LiteralValue_T,
	},
	Markup: map[string]any{
		"comment": "Specify an explicit true or false.",
	},
}

// holds a slice of type bool_value
// FIX: duplicates the spec decl.
type FIX_BoolValue_Slice []BoolValue

// implements typeinfo.Inspector
func (*BoolValue_Slice) Inspect() typeinfo.T {
	return &Z_BoolValue_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_FieldValue struct {
	Field  string
	Value  LiteralValue
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*FieldValue) Inspect() typeinfo.T {
	return &Z_FieldValue_T
}

// return a valid markup map, creating it if necessary.
func (op *FieldValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// field_value, a type of flow.
const Z_FieldValue_Name = "field_value"

var Z_FieldValue_T = typeinfo.Flow{
	Name: Z_FieldValue_Name,
	Lede: "field",
	Terms: []typeinfo.Term{{
		Name:  "field",
		Label: "_",
		Type:  &prim.Z_Text_T,
	}, {
		Name:  "value",
		Label: "value",
		Type:  &Z_LiteralValue_T,
	}},
	Markup: map[string]any{
		"comment": "A fixed value of a record.",
	},
}

// holds a slice of type field_value
// FIX: duplicates the spec decl.
type FIX_FieldValue_Slice []FieldValue

// implements typeinfo.Inspector
func (*FieldValue_Slice) Inspect() typeinfo.T {
	return &Z_FieldValue_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_FieldList struct {
	Fields FieldValue
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*FieldList) Inspect() typeinfo.T {
	return &Z_FieldList_T
}

// return a valid markup map, creating it if necessary.
func (op *FieldList) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// field_list, a type of flow.
const Z_FieldList_Name = "field_list"

// ensure the command implements its specified slots:
var _ LiteralValue = (*FieldList)(nil)

var Z_FieldList_T = typeinfo.Flow{
	Name: Z_FieldList_Name,
	Lede: "field_list",
	Terms: []typeinfo.Term{{
		Name:    "fields",
		Label:   "_",
		Repeats: true,
		Type:    &Z_FieldValue_T,
	}},
	Slots: []*typeinfo.Slot{
		&Z_LiteralValue_T,
	},
	Markup: map[string]any{
		"comment": []interface{}{"A series of values all for the same record.", "While it can be specified wherever a literal value can, it only has meaning when the record type is known."},
	},
}

// holds a slice of type field_list
// FIX: duplicates the spec decl.
type FIX_FieldList_Slice []FieldList

// implements typeinfo.Inspector
func (*FieldList_Slice) Inspect() typeinfo.T {
	return &Z_FieldList_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_NumValue struct {
	Value  float64
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*NumValue) Inspect() typeinfo.T {
	return &Z_NumValue_T
}

// return a valid markup map, creating it if necessary.
func (op *NumValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// num_value, a type of flow.
const Z_NumValue_Name = "num_value"

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*NumValue)(nil)
var _ LiteralValue = (*NumValue)(nil)

var Z_NumValue_T = typeinfo.Flow{
	Name: Z_NumValue_Name,
	Lede: "num",
	Terms: []typeinfo.Term{{
		Name:  "value",
		Label: "value",
		Type:  &prim.Z_Number_T,
	}, {
		Name:     "kind",
		Label:    "kind",
		Optional: true,
		Type:     &prim.Z_Text_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_NumberEval_T,
		&Z_LiteralValue_T,
	},
	Markup: map[string]any{
		"comment": "Specify a particular number.",
	},
}

// holds a slice of type num_value
// FIX: duplicates the spec decl.
type FIX_NumValue_Slice []NumValue

// implements typeinfo.Inspector
func (*NumValue_Slice) Inspect() typeinfo.T {
	return &Z_NumValue_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_NumValues struct {
	Values float64
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*NumValues) Inspect() typeinfo.T {
	return &Z_NumValues_T
}

// return a valid markup map, creating it if necessary.
func (op *NumValues) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// num_values, a type of flow.
const Z_NumValues_Name = "num_values"

// ensure the command implements its specified slots:
var _ rtti.NumListEval = (*NumValues)(nil)
var _ LiteralValue = (*NumValues)(nil)

var Z_NumValues_T = typeinfo.Flow{
	Name: Z_NumValues_Name,
	Lede: "num",
	Terms: []typeinfo.Term{{
		Name:    "values",
		Label:   "values",
		Repeats: true,
		Type:    &prim.Z_Number_T,
	}, {
		Name:     "kind",
		Label:    "kind",
		Optional: true,
		Type:     &prim.Z_Text_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_NumListEval_T,
		&Z_LiteralValue_T,
	},
	Markup: map[string]any{
		"comment": "Number List: Specify a list of numbers.",
	},
}

// holds a slice of type num_values
// FIX: duplicates the spec decl.
type FIX_NumValues_Slice []NumValues

// implements typeinfo.Inspector
func (*NumValues_Slice) Inspect() typeinfo.T {
	return &Z_NumValues_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_RecordValue struct {
	Kind   string
	Fields FieldValue
	Cache  RecordCache
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*RecordValue) Inspect() typeinfo.T {
	return &Z_RecordValue_T
}

// return a valid markup map, creating it if necessary.
func (op *RecordValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// record_value, a type of flow.
const Z_RecordValue_Name = "record_value"

// ensure the command implements its specified slots:
var _ rtti.RecordEval = (*RecordValue)(nil)
var _ LiteralValue = (*RecordValue)(nil)

var Z_RecordValue_T = typeinfo.Flow{
	Name: Z_RecordValue_Name,
	Lede: "record",
	Terms: []typeinfo.Term{{
		Name:  "kind",
		Label: "_",
		Type:  &prim.Z_Text_T,
	}, {
		Name:    "fields",
		Label:   "fields",
		Repeats: true,
		Type:    &Z_FieldValue_T,
	}, {
		Name:    "cache",
		Label:   "cache",
		Private: true,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_RecordEval_T,
		&Z_LiteralValue_T,
	},
	Markup: map[string]any{
		"comment": "Specify a record composed of literal values.",
	},
}

// holds a slice of type record_value
// FIX: duplicates the spec decl.
type FIX_RecordValue_Slice []RecordValue

// implements typeinfo.Inspector
func (*RecordValue_Slice) Inspect() typeinfo.T {
	return &Z_RecordValue_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_RecordList struct {
	Kind    string
	Records FieldList
	Cache   RecordsCache
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*RecordList) Inspect() typeinfo.T {
	return &Z_RecordList_T
}

// return a valid markup map, creating it if necessary.
func (op *RecordList) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// record_list, a type of flow.
const Z_RecordList_Name = "record_list"

// ensure the command implements its specified slots:
var _ rtti.RecordListEval = (*RecordList)(nil)
var _ LiteralValue = (*RecordList)(nil)

var Z_RecordList_T = typeinfo.Flow{
	Name: Z_RecordList_Name,
	Lede: "record",
	Terms: []typeinfo.Term{{
		Name:  "kind",
		Label: "_",
		Type:  &prim.Z_Text_T,
	}, {
		Name:    "records",
		Label:   "values",
		Repeats: true,
		Type:    &Z_FieldList_T,
	}, {
		Name:    "cache",
		Label:   "cache",
		Private: true,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_RecordListEval_T,
		&Z_LiteralValue_T,
	},
	Markup: map[string]any{
		"comment": "Specify a series of records, all of the same kind.",
	},
}

// holds a slice of type record_list
// FIX: duplicates the spec decl.
type FIX_RecordList_Slice []RecordList

// implements typeinfo.Inspector
func (*RecordList_Slice) Inspect() typeinfo.T {
	return &Z_RecordList_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TextValue struct {
	Value  string
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*TextValue) Inspect() typeinfo.T {
	return &Z_TextValue_T
}

// return a valid markup map, creating it if necessary.
func (op *TextValue) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// text_value, a type of flow.
const Z_TextValue_Name = "text_value"

// ensure the command implements its specified slots:
var _ rtti.TextEval = (*TextValue)(nil)
var _ LiteralValue = (*TextValue)(nil)

var Z_TextValue_T = typeinfo.Flow{
	Name: Z_TextValue_Name,
	Lede: "text",
	Terms: []typeinfo.Term{{
		Name:  "value",
		Label: "value",
		Type:  &prim.Z_Text_T,
	}, {
		Name:     "kind",
		Label:    "kind",
		Optional: true,
		Type:     &prim.Z_Text_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_TextEval_T,
		&Z_LiteralValue_T,
	},
	Markup: map[string]any{
		"comment": "Specify a small bit of text.",
	},
}

// holds a slice of type text_value
// FIX: duplicates the spec decl.
type FIX_TextValue_Slice []TextValue

// implements typeinfo.Inspector
func (*TextValue_Slice) Inspect() typeinfo.T {
	return &Z_TextValue_T
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_TextValues struct {
	Values string
	Kind   string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*TextValues) Inspect() typeinfo.T {
	return &Z_TextValues_T
}

// return a valid markup map, creating it if necessary.
func (op *TextValues) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// text_values, a type of flow.
const Z_TextValues_Name = "text_values"

// ensure the command implements its specified slots:
var _ rtti.TextListEval = (*TextValues)(nil)
var _ LiteralValue = (*TextValues)(nil)

var Z_TextValues_T = typeinfo.Flow{
	Name: Z_TextValues_Name,
	Lede: "text",
	Terms: []typeinfo.Term{{
		Name:    "values",
		Label:   "values",
		Repeats: true,
		Type:    &prim.Z_Text_T,
	}, {
		Name:     "kind",
		Label:    "kind",
		Optional: true,
		Type:     &prim.Z_Text_T,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Z_TextListEval_T,
		&Z_LiteralValue_T,
	},
	Markup: map[string]any{
		"comment": "Text List: Specifies a set of text values.",
	},
}

// holds a slice of type text_values
// FIX: duplicates the spec decl.
type FIX_TextValues_Slice []TextValues

// implements typeinfo.Inspector
func (*TextValues_Slice) Inspect() typeinfo.T {
	return &Z_TextValues_T
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "literal",
	Slot: z_slot_list,
	Flow: z_flow_list,
}

// a list of all slots in this this package
// ( ex. for generating blockly shapes )
var z_slot_list = []*typeinfo.Slot{
	&Z_LiteralValue_T,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Z_BoolValue_T,
	&Z_FieldValue_T,
	&Z_FieldList_T,
	&Z_NumValue_T,
	&Z_NumValues_T,
	&Z_RecordValue_T,
	&Z_RecordList_T,
	&Z_TextValue_T,
	&Z_TextValues_T,
}
