package literal

import (
	"git.sr.ht/~ionous/tapestry/rt"
	g "git.sr.ht/~ionous/tapestry/rt/generic"
	"github.com/ionous/errutil"
)

// actually, record literals should already be encodedable right?
// its just that the compact encoder doesnt have a *special* handler.
// Name  string       `if:"label=name,type=text"`
// Value LiteralValue `if:"label=value"`

type RecordCache struct {
	rec *g.Record // it might be more accurate to store this at an arbitrary string key in the runtime
	// that way, if multiple runtimes are used within the same process ( ex. tests )
	// each can be isolated from the other.
}

type RecordsCache struct {
	recs []*g.Record
}

func (rc *RecordCache) GetRecord(run rt.Runtime, kind string, fields []FieldValue) (ret g.Value, err error) {
	if rc.rec == nil {
		if k, e := run.GetKindByName(kind); e != nil {
			err = e
		} else if v, e := buildRecord(run, k, fields); e != nil {
			err = e
		} else {
			rc.rec = v
		}
	}
	if err == nil {
		ret = g.RecordOf(rc.rec)
	}
	return
}

func (rc *RecordsCache) GetRecords(run rt.Runtime, kind string, els []FieldValues) (ret g.Value, err error) {
	if rc.recs == nil {
		if k, e := run.GetKindByName(kind); e != nil {
			err = e
		} else if vs, e := buildRecords(run, k, els); e != nil {
			err = e
		} else {
			rc.recs = vs
		}
	}
	if err == nil {
		ret = g.RecordsFrom(rc.recs, kind)
	}
	return
}

func buildRecords(run rt.Runtime, k *g.Kind, els []FieldValues) (ret []*g.Record, err error) {
	var out []*g.Record
	for _, el := range els {
		if v, e := buildRecord(run, k, el.Values); e != nil {
			err = e
			break
		} else {
			out = append(out, v)
		}
	}
	if err == nil {
		ret = out
	}
	return
}

// create a new record
// note: this doesnt translate traits to aspects under the theory there should be only one of each field in list of fields
func buildRecord(run rt.Runtime, k *g.Kind, fields []FieldValue) (ret *g.Record, err error) {
	out := k.NewRecord()
	// fix? it might? make more sense to be able to create record with FieldValue(s) directly
	// to avoid the extra allocation -- to handle the slice conversion -- since you cant cast slices of types in go:
	// 1. have generic depend on an autogenerated type
	// 2. allow external types to be referenced by the autogeneration
	// 2. pass some sort of an iterator nextField() (string, g.Value) (
	set := make([]bool, k.NumField())
	// fields of name, literal value
	for _, f := range fields {
		if idx := k.FieldIndex(f.Field); idx < 0 {
			err = errutil.Fmt("unknown field %q in kind %q", f.Field, k.Name())
			break
		} else if set[idx] {
			err = errutil.New("duplicate fields set by literal", f.Field)
		} else if v, e := f.Value.GetAssignedValue(run); e != nil {
			err = e
			break
		} else if e := out.SetIndexedField(idx, v); e != nil {
			err = e
			break
		} else {
			set[idx] = true
		}
	}
	if err == nil {
		ret = out
	}
	return
}
