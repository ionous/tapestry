// Code generated by Tapestry; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_EraseEdge struct {
	Target assign.Address
	AtEdge rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*EraseEdge) Inspect() (typeinfo.T, bool) {
	return &Zt_EraseEdge, false
}

// return a valid markup map, creating it if necessary.
func (op *EraseEdge) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*EraseEdge)(nil)

// erase_edge, a type of flow.
var Zt_EraseEdge = typeinfo.Flow{
	Name: "erase_edge",
	Lede: "erase",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:     "at_edge",
		Label:    "at_front",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Erase at edge: Remove one or more values from a list.",
	},
}

// holds a slice of type erase_edge
// FIX: duplicates the spec decl.
type FIX_EraseEdge_Slice []EraseEdge

// implements typeinfo.Inspector
func (*EraseEdge_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_EraseEdge, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_EraseIndex struct {
	Count   rtti.NumberEval
	Target  assign.Address
	AtIndex rtti.NumberEval
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*EraseIndex) Inspect() (typeinfo.T, bool) {
	return &Zt_EraseIndex, false
}

// return a valid markup map, creating it if necessary.
func (op *EraseIndex) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*EraseIndex)(nil)

// erase_index, a type of flow.
var Zt_EraseIndex = typeinfo.Flow{
	Name: "erase_index",
	Lede: "erase",
	Terms: []typeinfo.Term{{
		Name:  "count",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "target",
		Label: "from",
		Type:  &assign.Zt_Address,
	}, {
		Name:  "at_index",
		Label: "at_index",
		Type:  &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Erase at index: Remove one or more values from a list.",
	},
}

// holds a slice of type erase_index
// FIX: duplicates the spec decl.
type FIX_EraseIndex_Slice []EraseIndex

// implements typeinfo.Inspector
func (*EraseIndex_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_EraseIndex, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Erasing struct {
	Count   rtti.NumberEval
	Target  assign.Address
	AtIndex rtti.NumberEval
	As      string
	Exe     rtti.Execute
	Markup  map[string]any
}

// implements typeinfo.Inspector
func (*Erasing) Inspect() (typeinfo.T, bool) {
	return &Zt_Erasing, false
}

// return a valid markup map, creating it if necessary.
func (op *Erasing) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*Erasing)(nil)

// erasing, a type of flow.
var Zt_Erasing = typeinfo.Flow{
	Name: "erasing",
	Lede: "erasing",
	Terms: []typeinfo.Term{{
		Name:  "count",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "target",
		Label: "from",
		Type:  &assign.Zt_Address,
	}, {
		Name:  "at_index",
		Label: "at_index",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "as",
		Label: "as",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Erase elements from the front or back of a list.", "Runs a pattern with a list containing the erased values.", "If nothing was erased, the pattern will be called with an empty list."},
	},
}

// holds a slice of type erasing
// FIX: duplicates the spec decl.
type FIX_Erasing_Slice []Erasing

// implements typeinfo.Inspector
func (*Erasing_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Erasing, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ErasingEdge struct {
	Target assign.Address
	AtEdge rtti.BoolEval
	As     string
	Exe    rtti.Execute
	Else   core.Brancher
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ErasingEdge) Inspect() (typeinfo.T, bool) {
	return &Zt_ErasingEdge, false
}

// return a valid markup map, creating it if necessary.
func (op *ErasingEdge) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ErasingEdge)(nil)

// erasing_edge, a type of flow.
var Zt_ErasingEdge = typeinfo.Flow{
	Name: "erasing_edge",
	Lede: "erasing",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:     "at_edge",
		Label:    "at_front",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}, {
		Name:  "as",
		Label: "as",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}, {
		Name:     "else",
		Label:    "else",
		Optional: true,
		Type:     &core.Zt_Brancher,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.",
	},
}

// holds a slice of type erasing_edge
// FIX: duplicates the spec decl.
type FIX_ErasingEdge_Slice []ErasingEdge

// implements typeinfo.Inspector
func (*ErasingEdge_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ErasingEdge, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListEach struct {
	List   rtti.Assignment
	As     string
	Exe    rtti.Execute
	Else   core.Brancher
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ListEach) Inspect() (typeinfo.T, bool) {
	return &Zt_ListEach, false
}

// return a valid markup map, creating it if necessary.
func (op *ListEach) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ListEach)(nil)

// list_each, a type of flow.
var Zt_ListEach = typeinfo.Flow{
	Name: "list_each",
	Lede: "repeating",
	Terms: []typeinfo.Term{{
		Name:  "list",
		Label: "across",
		Type:  &rtti.Zt_Assignment,
	}, {
		Name:  "as",
		Label: "as",
		Type:  &prim.Zt_Text,
	}, {
		Name:    "exe",
		Label:   "do",
		Repeats: true,
		Type:    &rtti.Zt_Execute,
	}, {
		Name:     "else",
		Label:    "else",
		Optional: true,
		Type:     &core.Zt_Brancher,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Loops over the elements in the passed list, or runs the 'else' activity if empty.",
	},
}

// holds a slice of type list_each
// FIX: duplicates the spec decl.
type FIX_ListEach_Slice []ListEach

// implements typeinfo.Inspector
func (*ListEach_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListEach, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListFind struct {
	Value  rtti.Assignment
	List   rtti.Assignment
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ListFind) Inspect() (typeinfo.T, bool) {
	return &Zt_ListFind, false
}

// return a valid markup map, creating it if necessary.
func (op *ListFind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.BoolEval = (*ListFind)(nil)
var _ rtti.NumberEval = (*ListFind)(nil)

// list_find, a type of flow.
var Zt_ListFind = typeinfo.Flow{
	Name: "list_find",
	Lede: "find",
	Terms: []typeinfo.Term{{
		Name:  "value",
		Label: "_",
		Type:  &rtti.Zt_Assignment,
	}, {
		Name:  "list",
		Label: "in_list",
		Type:  &rtti.Zt_Assignment,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_BoolEval,
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Search a list for a specific value.",
	},
}

// holds a slice of type list_find
// FIX: duplicates the spec decl.
type FIX_ListFind_Slice []ListFind

// implements typeinfo.Inspector
func (*ListFind_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListFind, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListGather struct {
	Target assign.Address
	From   rtti.Assignment
	Using  string
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ListGather) Inspect() (typeinfo.T, bool) {
	return &Zt_ListGather, false
}

// return a valid markup map, creating it if necessary.
func (op *ListGather) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// list_gather, a type of flow.
var Zt_ListGather = typeinfo.Flow{
	Name: "list_gather",
	Lede: "gather",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:  "from",
		Label: "from",
		Type:  &rtti.Zt_Assignment,
	}, {
		Name:  "using",
		Label: "using",
		Type:  &prim.Zt_Text,
	}},
	Markup: map[string]any{
		"comment": []interface{}{"Transform the values from a list.", "The named pattern gets with with two parameters for each value in the list:", "'in' as each value from the list, and 'out' as the var passed to the gather."},
	},
}

// holds a slice of type list_gather
// FIX: duplicates the spec decl.
type FIX_ListGather_Slice []ListGather

// implements typeinfo.Inspector
func (*ListGather_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListGather, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListLen struct {
	List   rtti.Assignment
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ListLen) Inspect() (typeinfo.T, bool) {
	return &Zt_ListLen, false
}

// return a valid markup map, creating it if necessary.
func (op *ListLen) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumberEval = (*ListLen)(nil)

// list_len, a type of flow.
var Zt_ListLen = typeinfo.Flow{
	Name: "list_len",
	Lede: "len",
	Terms: []typeinfo.Term{{
		Name:  "list",
		Label: "_",
		Type:  &rtti.Zt_Assignment,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumberEval,
	},
	Markup: map[string]any{
		"comment": "Determines the number of values in a list.",
	},
}

// holds a slice of type list_len
// FIX: duplicates the spec decl.
type FIX_ListLen_Slice []ListLen

// implements typeinfo.Inspector
func (*ListLen_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListLen, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeTextList struct {
	Values rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeTextList) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeTextList, false
}

// return a valid markup map, creating it if necessary.
func (op *MakeTextList) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.TextListEval = (*MakeTextList)(nil)

// make_text_list, a type of flow.
var Zt_MakeTextList = typeinfo.Flow{
	Name: "make_text_list",
	Lede: "list",
	Terms: []typeinfo.Term{{
		Name:    "values",
		Label:   "of_text",
		Repeats: true,
		Type:    &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_TextListEval,
	},
}

// holds a slice of type make_text_list
// FIX: duplicates the spec decl.
type FIX_MakeTextList_Slice []MakeTextList

// implements typeinfo.Inspector
func (*MakeTextList_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeTextList, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeNumList struct {
	Values rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeNumList) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeNumList, false
}

// return a valid markup map, creating it if necessary.
func (op *MakeNumList) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumListEval = (*MakeNumList)(nil)

// make_num_list, a type of flow.
var Zt_MakeNumList = typeinfo.Flow{
	Name: "make_num_list",
	Lede: "list",
	Terms: []typeinfo.Term{{
		Name:    "values",
		Label:   "of_numbers",
		Repeats: true,
		Type:    &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumListEval,
	},
}

// holds a slice of type make_num_list
// FIX: duplicates the spec decl.
type FIX_MakeNumList_Slice []MakeNumList

// implements typeinfo.Inspector
func (*MakeNumList_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeNumList, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_MakeRecordList struct {
	Values rtti.RecordEval
	Kind   rtti.TextEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*MakeRecordList) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeRecordList, false
}

// return a valid markup map, creating it if necessary.
func (op *MakeRecordList) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.RecordListEval = (*MakeRecordList)(nil)

// make_record_list, a type of flow.
var Zt_MakeRecordList = typeinfo.Flow{
	Name: "make_record_list",
	Lede: "list",
	Terms: []typeinfo.Term{{
		Name:    "values",
		Label:   "of_records",
		Repeats: true,
		Type:    &rtti.Zt_RecordEval,
	}, {
		Name:  "kind",
		Label: "of_type",
		Type:  &rtti.Zt_TextEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_RecordListEval,
	},
}

// holds a slice of type make_record_list
// FIX: duplicates the spec decl.
type FIX_MakeRecordList_Slice []MakeRecordList

// implements typeinfo.Inspector
func (*MakeRecordList_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_MakeRecordList, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListMap struct {
	Target      assign.Address
	List        rtti.Assignment
	PatternName string
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*ListMap) Inspect() (typeinfo.T, bool) {
	return &Zt_ListMap, false
}

// return a valid markup map, creating it if necessary.
func (op *ListMap) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ListMap)(nil)

// list_map, a type of flow.
var Zt_ListMap = typeinfo.Flow{
	Name: "list_map",
	Lede: "map",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:  "list",
		Label: "from_list",
		Type:  &rtti.Zt_Assignment,
	}, {
		Name:  "pattern_name",
		Label: "using",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Transform the values from one list and place the results in another list.", "The designated pattern is called with each value from the 'from list', one value at a time."},
	},
}

// holds a slice of type list_map
// FIX: duplicates the spec decl.
type FIX_ListMap_Slice []ListMap

// implements typeinfo.Inspector
func (*ListMap_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListMap, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListReduce struct {
	Target      assign.Address
	List        rtti.Assignment
	PatternName string
	Markup      map[string]any
}

// implements typeinfo.Inspector
func (*ListReduce) Inspect() (typeinfo.T, bool) {
	return &Zt_ListReduce, false
}

// return a valid markup map, creating it if necessary.
func (op *ListReduce) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ListReduce)(nil)

// list_reduce, a type of flow.
var Zt_ListReduce = typeinfo.Flow{
	Name: "list_reduce",
	Lede: "reduce",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "into",
		Type:  &assign.Zt_Address,
	}, {
		Name:  "list",
		Label: "from_list",
		Type:  &rtti.Zt_Assignment,
	}, {
		Name:  "pattern_name",
		Label: "using",
		Type:  &prim.Zt_Text,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Combine all of the values in a list into a single value.", "The designated pattern is called with two parameters:", "  1. each element of the list; and,", "  2. the value being combined.", "And, that pattern is expected to return the newly updated value."},
	},
}

// holds a slice of type list_reduce
// FIX: duplicates the spec decl.
type FIX_ListReduce_Slice []ListReduce

// implements typeinfo.Inspector
func (*ListReduce_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListReduce, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListReverse struct {
	Target assign.Address
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ListReverse) Inspect() (typeinfo.T, bool) {
	return &Zt_ListReverse, false
}

// return a valid markup map, creating it if necessary.
func (op *ListReverse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ListReverse)(nil)

// list_reverse, a type of flow.
var Zt_ListReverse = typeinfo.Flow{
	Name: "list_reverse",
	Lede: "reverse",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "list",
		Type:  &assign.Zt_Address,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Reverse a list.",
	},
}

// holds a slice of type list_reverse
// FIX: duplicates the spec decl.
type FIX_ListReverse_Slice []ListReverse

// implements typeinfo.Inspector
func (*ListReverse_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListReverse, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListSlice struct {
	List   rtti.Assignment
	Start  rtti.NumberEval
	End    rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ListSlice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListSlice, false
}

// return a valid markup map, creating it if necessary.
func (op *ListSlice) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumListEval = (*ListSlice)(nil)
var _ rtti.TextListEval = (*ListSlice)(nil)
var _ rtti.RecordListEval = (*ListSlice)(nil)

// list_slice, a type of flow.
var Zt_ListSlice = typeinfo.Flow{
	Name: "list_slice",
	Lede: "slice",
	Terms: []typeinfo.Term{{
		Name:  "list",
		Label: "_",
		Type:  &rtti.Zt_Assignment,
	}, {
		Name:     "start",
		Label:    "start",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}, {
		Name:     "end",
		Label:    "end",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumListEval,
		&rtti.Zt_TextListEval,
		&rtti.Zt_RecordListEval,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Create a new list from a section of another list.", "Start is optional, if omitted slice starts at the first element.", "If start is greater the length, an empty array is returned.", "Slice doesnt include the ending index.", "Negatives indices indicates an offset from the end.", "When end is omitted, copy up to and including the last element;", "and do the same if the end is greater than the length"},
	},
}

// holds a slice of type list_slice
// FIX: duplicates the spec decl.
type FIX_ListSlice_Slice []ListSlice

// implements typeinfo.Inspector
func (*ListSlice_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListSlice, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListSortNumbers struct {
	Target     assign.Address
	ByField    string
	Descending rtti.BoolEval
	Markup     map[string]any
}

// implements typeinfo.Inspector
func (*ListSortNumbers) Inspect() (typeinfo.T, bool) {
	return &Zt_ListSortNumbers, false
}

// return a valid markup map, creating it if necessary.
func (op *ListSortNumbers) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ListSortNumbers)(nil)

// list_sort_numbers, a type of flow.
var Zt_ListSortNumbers = typeinfo.Flow{
	Name: "list_sort_numbers",
	Lede: "sort_numbers",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:  "by_field",
		Label: "by_field",
		Type:  &prim.Zt_Text,
	}, {
		Name:     "descending",
		Label:    "descending",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
}

// holds a slice of type list_sort_numbers
// FIX: duplicates the spec decl.
type FIX_ListSortNumbers_Slice []ListSortNumbers

// implements typeinfo.Inspector
func (*ListSortNumbers_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListSortNumbers, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListSortText struct {
	Target     assign.Address
	ByField    string
	Descending rtti.BoolEval
	UsingCase  rtti.BoolEval
	Markup     map[string]any
}

// implements typeinfo.Inspector
func (*ListSortText) Inspect() (typeinfo.T, bool) {
	return &Zt_ListSortText, false
}

// return a valid markup map, creating it if necessary.
func (op *ListSortText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ListSortText)(nil)

// list_sort_text, a type of flow.
var Zt_ListSortText = typeinfo.Flow{
	Name: "list_sort_text",
	Lede: "sort_texts",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:  "by_field",
		Label: "by_field",
		Type:  &prim.Zt_Text,
	}, {
		Name:     "descending",
		Label:    "descending",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}, {
		Name:     "using_case",
		Label:    "using_case",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Rearrange the elements in the named list by using the designated pattern to test pairs of elements.",
	},
}

// holds a slice of type list_sort_text
// FIX: duplicates the spec decl.
type FIX_ListSortText_Slice []ListSortText

// implements typeinfo.Inspector
func (*ListSortText_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListSortText, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListSplice struct {
	Target assign.Address
	Start  rtti.NumberEval
	Remove rtti.NumberEval
	Insert rtti.Assignment
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ListSplice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListSplice, false
}

// return a valid markup map, creating it if necessary.
func (op *ListSplice) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ListSplice)(nil)
var _ rtti.NumListEval = (*ListSplice)(nil)
var _ rtti.TextListEval = (*ListSplice)(nil)
var _ rtti.RecordListEval = (*ListSplice)(nil)

// list_splice, a type of flow.
var Zt_ListSplice = typeinfo.Flow{
	Name: "list_splice",
	Lede: "splice",
	Terms: []typeinfo.Term{{
		Name:  "target",
		Label: "_",
		Type:  &assign.Zt_Address,
	}, {
		Name:  "start",
		Label: "start",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "remove",
		Label: "remove",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:  "insert",
		Label: "insert",
		Type:  &rtti.Zt_Assignment,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
		&rtti.Zt_NumListEval,
		&rtti.Zt_TextListEval,
		&rtti.Zt_RecordListEval,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Modify a list by adding and removing elements.", "The type of the elements being added must match the type of the list.", "Text cant be added to a list of numbers, numbers cant be added to a list of text.", "If the starting index is negative, this begins that many elements from the end of the array;", "if list's length plus the start is less than zero, this begins from index zero.", "If the remove count is missing, this removes all elements from the start to the end;", "if the remove count is zero or negative, no elements are removed."},
	},
}

// holds a slice of type list_splice
// FIX: duplicates the spec decl.
type FIX_ListSplice_Slice []ListSplice

// implements typeinfo.Inspector
func (*ListSplice_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListSplice, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_ListPush struct {
	Value  rtti.Assignment
	Target assign.Address
	AtEdge rtti.BoolEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*ListPush) Inspect() (typeinfo.T, bool) {
	return &Zt_ListPush, false
}

// return a valid markup map, creating it if necessary.
func (op *ListPush) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.Execute = (*ListPush)(nil)

// list_push, a type of flow.
var Zt_ListPush = typeinfo.Flow{
	Name: "list_push",
	Lede: "push",
	Terms: []typeinfo.Term{{
		Name:  "value",
		Label: "_",
		Type:  &rtti.Zt_Assignment,
	}, {
		Name:  "target",
		Label: "into",
		Type:  &assign.Zt_Address,
	}, {
		Name:     "at_edge",
		Label:    "at_front",
		Optional: true,
		Type:     &rtti.Zt_BoolEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_Execute,
	},
	Markup: map[string]any{
		"comment": "Add a value to a list.",
	},
}

// holds a slice of type list_push
// FIX: duplicates the spec decl.
type FIX_ListPush_Slice []ListPush

// implements typeinfo.Inspector
func (*ListPush_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_ListPush, true
}

// FIX: for now we are generating side by side with the old definitions
// also should have user comment here
type FIX_Range struct {
	To     rtti.NumberEval
	From   rtti.NumberEval
	ByStep rtti.NumberEval
	Markup map[string]any
}

// implements typeinfo.Inspector
func (*Range) Inspect() (typeinfo.T, bool) {
	return &Zt_Range, false
}

// return a valid markup map, creating it if necessary.
func (op *Range) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// ensure the command implements its specified slots:
var _ rtti.NumListEval = (*Range)(nil)

// range, a type of flow.
var Zt_Range = typeinfo.Flow{
	Name: "range",
	Lede: "range",
	Terms: []typeinfo.Term{{
		Name:  "to",
		Label: "_",
		Type:  &rtti.Zt_NumberEval,
	}, {
		Name:     "from",
		Label:    "from",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}, {
		Name:     "by_step",
		Label:    "by_step",
		Optional: true,
		Type:     &rtti.Zt_NumberEval,
	}},
	Slots: []*typeinfo.Slot{
		&rtti.Zt_NumListEval,
	},
	Markup: map[string]any{
		"comment": []interface{}{"Generates a series of numbers r[i] = (start + step*i) where i>=0.", "Start and step default to 1, stop defaults to start;", "the inputs are truncated to produce whole numbers;", "a zero step returns an error.", "A positive step ends the series when the returned value would exceed stop", "while a negative step ends before generating a value less than stop."},
	},
}

// holds a slice of type range
// FIX: duplicates the spec decl.
type FIX_Range_Slice []Range

// implements typeinfo.Inspector
func (*Range_Slice) Inspect() (typeinfo.T, bool) {
	return &Zt_Range, true
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name:       "list",
	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// a list of all flows in this this package
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_EraseEdge,
	&Zt_EraseIndex,
	&Zt_Erasing,
	&Zt_ErasingEdge,
	&Zt_ListEach,
	&Zt_ListFind,
	&Zt_ListGather,
	&Zt_ListLen,
	&Zt_MakeTextList,
	&Zt_MakeNumList,
	&Zt_MakeRecordList,
	&Zt_ListMap,
	&Zt_ListReduce,
	&Zt_ListReverse,
	&Zt_ListSlice,
	&Zt_ListSortNumbers,
	&Zt_ListSortText,
	&Zt_ListSplice,
	&Zt_ListPush,
	&Zt_Range,
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]any{
	6334415563934548256:  (*ListGather)(nil),      /* Gather:from:using: */
	17857642077015906043: (*EraseEdge)(nil),       /* execute=Erase: */
	4911242881414594201:  (*EraseEdge)(nil),       /* execute=Erase:atFront: */
	13326390992756169124: (*EraseIndex)(nil),      /* execute=Erase:from:atIndex: */
	15309883842271607141: (*ErasingEdge)(nil),     /* execute=Erasing:as:do: */
	2341467540630172606:  (*ErasingEdge)(nil),     /* execute=Erasing:as:do:else: */
	7006351070379896671:  (*ErasingEdge)(nil),     /* execute=Erasing:atFront:as:do: */
	12034742036302137452: (*ErasingEdge)(nil),     /* execute=Erasing:atFront:as:do:else: */
	1044384912965145788:  (*Erasing)(nil),         /* execute=Erasing:from:atIndex:as:do: */
	8547752949201735569:  (*ListFind)(nil),        /* bool_eval=Find:inList: */
	16815906459082105780: (*ListFind)(nil),        /* number_eval=Find:inList: */
	3478260273963207965:  (*ListLen)(nil),         /* number_eval=Len: */
	11141869806069158915: (*MakeNumList)(nil),     /* num_list_eval=List ofNumbers: */
	10609280349940760977: (*MakeRecordList)(nil),  /* record_list_eval=List ofRecords:ofType: */
	15650595833095485421: (*MakeTextList)(nil),    /* text_list_eval=List ofText: */
	8449127989109999373:  (*ListMap)(nil),         /* execute=Map:fromList:using: */
	14590825769568398889: (*ListPush)(nil),        /* execute=Push:into: */
	17497959320325918107: (*ListPush)(nil),        /* execute=Push:into:atFront: */
	120416590109430143:   (*Range)(nil),           /* num_list_eval=Range: */
	15503705420922978310: (*Range)(nil),           /* num_list_eval=Range:byStep: */
	16618866959380663563: (*Range)(nil),           /* num_list_eval=Range:from: */
	14227857065891717050: (*Range)(nil),           /* num_list_eval=Range:from:byStep: */
	18245549119758376391: (*ListReduce)(nil),      /* execute=Reduce into:fromList:using: */
	7084717997213120806:  (*ListEach)(nil),        /* execute=Repeating across:as:do: */
	12445157229684471803: (*ListEach)(nil),        /* execute=Repeating across:as:do:else: */
	177314099445105829:   (*ListReverse)(nil),     /* execute=Reverse list: */
	4235921801420235638:  (*ListSlice)(nil),       /* num_list_eval=Slice: */
	13273073049578089927: (*ListSlice)(nil),       /* record_list_eval=Slice: */
	18323981472330239313: (*ListSlice)(nil),       /* text_list_eval=Slice: */
	3713929053224137387:  (*ListSlice)(nil),       /* num_list_eval=Slice:end: */
	326673439235441194:   (*ListSlice)(nil),       /* record_list_eval=Slice:end: */
	8469880138850798532:  (*ListSlice)(nil),       /* text_list_eval=Slice:end: */
	6763121597476813124:  (*ListSlice)(nil),       /* num_list_eval=Slice:start: */
	10126987075066562677: (*ListSlice)(nil),       /* record_list_eval=Slice:start: */
	2045310658543284955:  (*ListSlice)(nil),       /* text_list_eval=Slice:start: */
	14495675636779114361: (*ListSlice)(nil),       /* num_list_eval=Slice:start:end: */
	3241896595896148736:  (*ListSlice)(nil),       /* record_list_eval=Slice:start:end: */
	8901512565003460886:  (*ListSlice)(nil),       /* text_list_eval=Slice:start:end: */
	2873147130324862012:  (*ListSortNumbers)(nil), /* execute=SortNumbers:byField: */
	16697045456605499852: (*ListSortNumbers)(nil), /* execute=SortNumbers:byField:descending: */
	16004888373963195994: (*ListSortText)(nil),    /* execute=SortTexts:byField: */
	10015011362106184366: (*ListSortText)(nil),    /* execute=SortTexts:byField:descending: */
	10595238214248400404: (*ListSortText)(nil),    /* execute=SortTexts:byField:descending:usingCase: */
	10680774202307610784: (*ListSortText)(nil),    /* execute=SortTexts:byField:usingCase: */
	13203130291219794646: (*ListSplice)(nil),      /* execute=Splice:start:remove:insert: */
	6201472222981604265:  (*ListSplice)(nil),      /* num_list_eval=Splice:start:remove:insert: */
	15778591428898251294: (*ListSplice)(nil),      /* record_list_eval=Splice:start:remove:insert: */
	11160578659475180120: (*ListSplice)(nil),      /* text_list_eval=Splice:start:remove:insert: */
}
