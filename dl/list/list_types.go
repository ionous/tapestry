// List queries, transformations, etc.
// Lists are a series of zero or more values, all of the same fundamental type.
// There can be lists of numbers, text, or records.
// Lists of boolean values are not supported.
// The first value of a list is at index 1 (one).
package list

//
// Code generated by Tapestry; edit at your own risk.
//

import (
	"git.sr.ht/~ionous/tapestry/dl/logic"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/dl/rtti"
	"git.sr.ht/~ionous/tapestry/lang/typeinfo"
)

// Read a text value from a list of text values.
type ListTextAt struct {
	List   rtti.TextListEval
	Index  rtti.NumEval
	Markup map[string]any `json:",omitempty"`
}

// list_text_at, a type of flow.
var Zt_ListTextAt typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListTextAt) TypeInfo() typeinfo.T {
	return &Zt_ListTextAt
}

// Implements [typeinfo.Markup]
func (op *ListTextAt) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*ListTextAt)(nil)

// Holds a slice of type ListTextAt.
type ListTextAt_Slice []ListTextAt

// Implements [typeinfo.Instance] for a slice of ListTextAt.
func (*ListTextAt_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListTextAt
}

// Implements [typeinfo.Repeats] for a slice of ListTextAt.
func (op *ListTextAt_Slice) Repeats() bool {
	return len(*op) > 0
}

// Read a number from a list of numbers.
type ListNumAt struct {
	List   rtti.NumListEval
	Index  rtti.NumEval
	Markup map[string]any `json:",omitempty"`
}

// list_num_at, a type of flow.
var Zt_ListNumAt typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListNumAt) TypeInfo() typeinfo.T {
	return &Zt_ListNumAt
}

// Implements [typeinfo.Markup]
func (op *ListNumAt) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*ListNumAt)(nil)

// Holds a slice of type ListNumAt.
type ListNumAt_Slice []ListNumAt

// Implements [typeinfo.Instance] for a slice of ListNumAt.
func (*ListNumAt_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListNumAt
}

// Implements [typeinfo.Repeats] for a slice of ListNumAt.
func (op *ListNumAt_Slice) Repeats() bool {
	return len(*op) > 0
}

// Remove a text value from the end ( or the start ) of a list.
type ListPopText struct {
	Target rtti.Address
	Edge   rtti.BoolEval
	Markup map[string]any `json:",omitempty"`
}

// list_pop_text, a type of flow.
var Zt_ListPopText typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListPopText) TypeInfo() typeinfo.T {
	return &Zt_ListPopText
}

// Implements [typeinfo.Markup]
func (op *ListPopText) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextEval = (*ListPopText)(nil)
var _ rtti.Execute = (*ListPopText)(nil)

// Holds a slice of type ListPopText.
type ListPopText_Slice []ListPopText

// Implements [typeinfo.Instance] for a slice of ListPopText.
func (*ListPopText_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListPopText
}

// Implements [typeinfo.Repeats] for a slice of ListPopText.
func (op *ListPopText_Slice) Repeats() bool {
	return len(*op) > 0
}

// Remove a num value from the end ( or the start ) of a list.
type ListPopNum struct {
	Target rtti.Address
	Edge   rtti.BoolEval
	Markup map[string]any `json:",omitempty"`
}

// list_pop_num, a type of flow.
var Zt_ListPopNum typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListPopNum) TypeInfo() typeinfo.T {
	return &Zt_ListPopNum
}

// Implements [typeinfo.Markup]
func (op *ListPopNum) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*ListPopNum)(nil)
var _ rtti.Execute = (*ListPopNum)(nil)

// Holds a slice of type ListPopNum.
type ListPopNum_Slice []ListPopNum

// Implements [typeinfo.Instance] for a slice of ListPopNum.
func (*ListPopNum_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListPopNum
}

// Implements [typeinfo.Repeats] for a slice of ListPopNum.
func (op *ListPopNum_Slice) Repeats() bool {
	return len(*op) > 0
}

// Remove a record value from the end ( or the start ) of a list.
type ListPopRecord struct {
	Target rtti.Address
	Edge   rtti.BoolEval
	Markup map[string]any `json:",omitempty"`
}

// list_pop_record, a type of flow.
var Zt_ListPopRecord typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListPopRecord) TypeInfo() typeinfo.T {
	return &Zt_ListPopRecord
}

// Implements [typeinfo.Markup]
func (op *ListPopRecord) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.RecordEval = (*ListPopRecord)(nil)
var _ rtti.Execute = (*ListPopRecord)(nil)

// Holds a slice of type ListPopRecord.
type ListPopRecord_Slice []ListPopRecord

// Implements [typeinfo.Instance] for a slice of ListPopRecord.
func (*ListPopRecord_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListPopRecord
}

// Implements [typeinfo.Repeats] for a slice of ListPopRecord.
func (op *ListPopRecord_Slice) Repeats() bool {
	return len(*op) > 0
}

// Remove one or more values from a list.
type ListErase struct {
	Target rtti.Address
	Start  rtti.NumEval
	Count  rtti.NumEval
	Markup map[string]any `json:",omitempty"`
}

// list_erase, a type of flow.
var Zt_ListErase typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListErase) TypeInfo() typeinfo.T {
	return &Zt_ListErase
}

// Implements [typeinfo.Markup]
func (op *ListErase) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListErase)(nil)

// Holds a slice of type ListErase.
type ListErase_Slice []ListErase

// Implements [typeinfo.Instance] for a slice of ListErase.
func (*ListErase_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListErase
}

// Implements [typeinfo.Repeats] for a slice of ListErase.
func (op *ListErase_Slice) Repeats() bool {
	return len(*op) > 0
}

// Remove a number of values from a list starting at a specified index.
// Run a series of statements, giving them a new local variable
// containing a list of removed values.
type ListErasing struct {
	Target rtti.Address
	Start  rtti.NumEval
	Count  rtti.NumEval
	As     string
	Exe    []rtti.Execute
	Else   logic.Brancher
	Markup map[string]any `json:",omitempty"`
}

// list_erasing, a type of flow.
var Zt_ListErasing typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListErasing) TypeInfo() typeinfo.T {
	return &Zt_ListErasing
}

// Implements [typeinfo.Markup]
func (op *ListErasing) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListErasing)(nil)

// Holds a slice of type ListErasing.
type ListErasing_Slice []ListErasing

// Implements [typeinfo.Instance] for a slice of ListErasing.
func (*ListErasing_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListErasing
}

// Implements [typeinfo.Repeats] for a slice of ListErasing.
func (op *ListErasing_Slice) Repeats() bool {
	return len(*op) > 0
}

// Remove a value from the end ( or the start ) of a list.
// Run a series of statements, giving them a new local variable
// containing the removed value.
type ListPopping struct {
	Target rtti.Address
	Edge   rtti.BoolEval
	As     string
	Exe    []rtti.Execute
	Else   logic.Brancher
	Markup map[string]any `json:",omitempty"`
}

// list_popping, a type of flow.
var Zt_ListPopping typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListPopping) TypeInfo() typeinfo.T {
	return &Zt_ListPopping
}

// Implements [typeinfo.Markup]
func (op *ListPopping) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListPopping)(nil)

// Holds a slice of type ListPopping.
type ListPopping_Slice []ListPopping

// Implements [typeinfo.Instance] for a slice of ListPopping.
func (*ListPopping_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListPopping
}

// Implements [typeinfo.Repeats] for a slice of ListPopping.
func (op *ListPopping_Slice) Repeats() bool {
	return len(*op) > 0
}

// Run a series of statements for each value in a list.
// Several local variables are available to those statements:
//  1. the value in the list, named as specified.
//  2. "index", the one-based index of the current value in the list.
//  3. "first", a boolean indicating if this is the first value
//  4. "last", a boolean indicating if this is the last value.
//
// If the list was empty, this runs the else branch instead.
type ListRepeat struct {
	List   rtti.Assignment
	As     string
	Exe    []rtti.Execute
	Else   logic.Brancher
	Markup map[string]any `json:",omitempty"`
}

// list_repeat, a type of flow.
var Zt_ListRepeat typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListRepeat) TypeInfo() typeinfo.T {
	return &Zt_ListRepeat
}

// Implements [typeinfo.Markup]
func (op *ListRepeat) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListRepeat)(nil)

// Holds a slice of type ListRepeat.
type ListRepeat_Slice []ListRepeat

// Implements [typeinfo.Instance] for a slice of ListRepeat.
func (*ListRepeat_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListRepeat
}

// Implements [typeinfo.Repeats] for a slice of ListRepeat.
func (op *ListRepeat_Slice) Repeats() bool {
	return len(*op) > 0
}

// Search a list for a specific value.
//
// The [rt.NumEval] version returns the index of the value in the list.
type ListFind struct {
	List   rtti.Assignment
	Value  rtti.Assignment
	Markup map[string]any `json:",omitempty"`
}

// list_find, a type of flow.
var Zt_ListFind typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListFind) TypeInfo() typeinfo.T {
	return &Zt_ListFind
}

// Implements [typeinfo.Markup]
func (op *ListFind) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*ListFind)(nil)
var _ rtti.NumEval = (*ListFind)(nil)

// Holds a slice of type ListFind.
type ListFind_Slice []ListFind

// Implements [typeinfo.Instance] for a slice of ListFind.
func (*ListFind_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListFind
}

// Implements [typeinfo.Repeats] for a slice of ListFind.
func (op *ListFind_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine the number of values in a list.
type ListLength struct {
	List   rtti.Assignment
	Markup map[string]any `json:",omitempty"`
}

// list_length, a type of flow.
var Zt_ListLength typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListLength) TypeInfo() typeinfo.T {
	return &Zt_ListLength
}

// Implements [typeinfo.Markup]
func (op *ListLength) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumEval = (*ListLength)(nil)

// Holds a slice of type ListLength.
type ListLength_Slice []ListLength

// Implements [typeinfo.Instance] for a slice of ListLength.
func (*ListLength_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListLength
}

// Implements [typeinfo.Repeats] for a slice of ListLength.
func (op *ListLength_Slice) Repeats() bool {
	return len(*op) > 0
}

// Determine if the length of the list is zero.
type ListEmpty struct {
	List   rtti.Assignment
	Markup map[string]any `json:",omitempty"`
}

// list_empty, a type of flow.
var Zt_ListEmpty typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListEmpty) TypeInfo() typeinfo.T {
	return &Zt_ListEmpty
}

// Implements [typeinfo.Markup]
func (op *ListEmpty) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.BoolEval = (*ListEmpty)(nil)

// Holds a slice of type ListEmpty.
type ListEmpty_Slice []ListEmpty

// Implements [typeinfo.Instance] for a slice of ListEmpty.
func (*ListEmpty_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListEmpty
}

// Implements [typeinfo.Repeats] for a slice of ListEmpty.
func (op *ListEmpty_Slice) Repeats() bool {
	return len(*op) > 0
}

// Collect one or more text values into a list.
type MakeTextList struct {
	Values []rtti.TextEval
	Markup map[string]any `json:",omitempty"`
}

// make_text_list, a type of flow.
var Zt_MakeTextList typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeTextList) TypeInfo() typeinfo.T {
	return &Zt_MakeTextList
}

// Implements [typeinfo.Markup]
func (op *MakeTextList) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.TextListEval = (*MakeTextList)(nil)

// Holds a slice of type MakeTextList.
type MakeTextList_Slice []MakeTextList

// Implements [typeinfo.Instance] for a slice of MakeTextList.
func (*MakeTextList_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeTextList
}

// Implements [typeinfo.Repeats] for a slice of MakeTextList.
func (op *MakeTextList_Slice) Repeats() bool {
	return len(*op) > 0
}

// Collect one or more numbers into a list.
type MakeNumList struct {
	Values []rtti.NumEval
	Markup map[string]any `json:",omitempty"`
}

// make_num_list, a type of flow.
var Zt_MakeNumList typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeNumList) TypeInfo() typeinfo.T {
	return &Zt_MakeNumList
}

// Implements [typeinfo.Markup]
func (op *MakeNumList) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumListEval = (*MakeNumList)(nil)

// Holds a slice of type MakeNumList.
type MakeNumList_Slice []MakeNumList

// Implements [typeinfo.Instance] for a slice of MakeNumList.
func (*MakeNumList_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeNumList
}

// Implements [typeinfo.Repeats] for a slice of MakeNumList.
func (op *MakeNumList_Slice) Repeats() bool {
	return len(*op) > 0
}

// Collect one or more records into a list.
// All of the records must be of the same type.
type MakeRecordList struct {
	List   []rtti.RecordEval
	Markup map[string]any `json:",omitempty"`
}

// make_record_list, a type of flow.
var Zt_MakeRecordList typeinfo.Flow

// Implements [typeinfo.Instance]
func (*MakeRecordList) TypeInfo() typeinfo.T {
	return &Zt_MakeRecordList
}

// Implements [typeinfo.Markup]
func (op *MakeRecordList) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.RecordListEval = (*MakeRecordList)(nil)

// Holds a slice of type MakeRecordList.
type MakeRecordList_Slice []MakeRecordList

// Implements [typeinfo.Instance] for a slice of MakeRecordList.
func (*MakeRecordList_Slice) TypeInfo() typeinfo.T {
	return &Zt_MakeRecordList
}

// Implements [typeinfo.Repeats] for a slice of MakeRecordList.
func (op *MakeRecordList_Slice) Repeats() bool {
	return len(*op) > 0
}

// Transform the values from one list and append the results to another.
// The designated pattern is called with each value, one value at a time.
type ListMap struct {
	Target      rtti.Address
	PatternName string
	List        rtti.Assignment
	Markup      map[string]any `json:",omitempty"`
}

// list_map, a type of flow.
var Zt_ListMap typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListMap) TypeInfo() typeinfo.T {
	return &Zt_ListMap
}

// Implements [typeinfo.Markup]
func (op *ListMap) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListMap)(nil)

// Holds a slice of type ListMap.
type ListMap_Slice []ListMap

// Implements [typeinfo.Instance] for a slice of ListMap.
func (*ListMap_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListMap
}

// Implements [typeinfo.Repeats] for a slice of ListMap.
func (op *ListMap_Slice) Repeats() bool {
	return len(*op) > 0
}

// Pack the values of a list down into a single value.
// The designated pattern is called with a pair of parameters for each value in the list:
//  1. the current value from the list;
//  2. the value being packed.
//
// The pattern is expected to combine the two parameters and return the newly updated value.
type ListReduce struct {
	Target      rtti.Address
	PatternName string
	List        rtti.Assignment
	Markup      map[string]any `json:",omitempty"`
}

// list_reduce, a type of flow.
var Zt_ListReduce typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListReduce) TypeInfo() typeinfo.T {
	return &Zt_ListReduce
}

// Implements [typeinfo.Markup]
func (op *ListReduce) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListReduce)(nil)

// Holds a slice of type ListReduce.
type ListReduce_Slice []ListReduce

// Implements [typeinfo.Instance] for a slice of ListReduce.
func (*ListReduce_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListReduce
}

// Implements [typeinfo.Repeats] for a slice of ListReduce.
func (op *ListReduce_Slice) Repeats() bool {
	return len(*op) > 0
}

// Reverse the order of the values in a list.
// The first becomes last, the weak become strong, the list gets reversed,
// all that.
type ListReverse struct {
	Target rtti.Address
	Markup map[string]any `json:",omitempty"`
}

// list_reverse, a type of flow.
var Zt_ListReverse typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListReverse) TypeInfo() typeinfo.T {
	return &Zt_ListReverse
}

// Implements [typeinfo.Markup]
func (op *ListReverse) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListReverse)(nil)

// Holds a slice of type ListReverse.
type ListReverse_Slice []ListReverse

// Implements [typeinfo.Instance] for a slice of ListReverse.
func (*ListReverse_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListReverse
}

// Implements [typeinfo.Repeats] for a slice of ListReverse.
func (op *ListReverse_Slice) Repeats() bool {
	return len(*op) > 0
}

// Create a new list from part of another list.
// Start is optional, if omitted slice starts at the beginning.
// If start is greater the length, an empty array is returned.
// Slice doesn't include the ending index.
// Negatives indices indicates an offset from the end.
// When end is omitted, or if its greater than the the length of the list,
// the slice will include everything from start up to and including the last value.
type ListSlice struct {
	List   rtti.Assignment
	Start  rtti.NumEval
	End    rtti.NumEval
	Markup map[string]any `json:",omitempty"`
}

// list_slice, a type of flow.
var Zt_ListSlice typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListSlice) TypeInfo() typeinfo.T {
	return &Zt_ListSlice
}

// Implements [typeinfo.Markup]
func (op *ListSlice) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumListEval = (*ListSlice)(nil)
var _ rtti.TextListEval = (*ListSlice)(nil)
var _ rtti.RecordListEval = (*ListSlice)(nil)

// Holds a slice of type ListSlice.
type ListSlice_Slice []ListSlice

// Implements [typeinfo.Instance] for a slice of ListSlice.
func (*ListSlice_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListSlice
}

// Implements [typeinfo.Repeats] for a slice of ListSlice.
func (op *ListSlice_Slice) Repeats() bool {
	return len(*op) > 0
}

// Rearrange the values in a list.
// This can sort lists of numbers and text,
// as well as lists of records and object names given a sorting field.
type ListSort struct {
	Target     rtti.Address
	KindName   rtti.TextEval
	FieldName  rtti.TextEval
	Descending rtti.BoolEval
	Case       rtti.BoolEval
	Markup     map[string]any `json:",omitempty"`
}

// list_sort, a type of flow.
var Zt_ListSort typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListSort) TypeInfo() typeinfo.T {
	return &Zt_ListSort
}

// Implements [typeinfo.Markup]
func (op *ListSort) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListSort)(nil)

// Holds a slice of type ListSort.
type ListSort_Slice []ListSort

// Implements [typeinfo.Instance] for a slice of ListSort.
func (*ListSort_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListSort
}

// Implements [typeinfo.Repeats] for a slice of ListSort.
func (op *ListSort_Slice) Repeats() bool {
	return len(*op) > 0
}

// Modify a list by adding and removing values.
// If the starting index is negative, this begins that many values from the end of the list
// ( clipped to the first element if that distance is more than the total list length. )
// If the remove count is missing, this removes all values from the start to the end of the list.
// if the remove count is zero or negative, no values are removed.
// The type of the values being added must match the type of the list.
// ( ex. Text can only be added to a list of text. )
type ListSplice struct {
	Target rtti.Address
	Start  rtti.NumEval
	Count  rtti.NumEval
	Insert rtti.Assignment
	Markup map[string]any `json:",omitempty"`
}

// list_splice, a type of flow.
var Zt_ListSplice typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListSplice) TypeInfo() typeinfo.T {
	return &Zt_ListSplice
}

// Implements [typeinfo.Markup]
func (op *ListSplice) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListSplice)(nil)
var _ rtti.NumListEval = (*ListSplice)(nil)
var _ rtti.TextListEval = (*ListSplice)(nil)
var _ rtti.RecordListEval = (*ListSplice)(nil)

// Holds a slice of type ListSplice.
type ListSplice_Slice []ListSplice

// Implements [typeinfo.Instance] for a slice of ListSplice.
func (*ListSplice_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListSplice
}

// Implements [typeinfo.Repeats] for a slice of ListSplice.
func (op *ListSplice_Slice) Repeats() bool {
	return len(*op) > 0
}

// Add a value to the end ( or the beginning ) of a list.
type ListPush struct {
	Target rtti.Address
	Value  rtti.Assignment
	Edge   rtti.BoolEval
	Markup map[string]any `json:",omitempty"`
}

// list_push, a type of flow.
var Zt_ListPush typeinfo.Flow

// Implements [typeinfo.Instance]
func (*ListPush) TypeInfo() typeinfo.T {
	return &Zt_ListPush
}

// Implements [typeinfo.Markup]
func (op *ListPush) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.Execute = (*ListPush)(nil)

// Holds a slice of type ListPush.
type ListPush_Slice []ListPush

// Implements [typeinfo.Instance] for a slice of ListPush.
func (*ListPush_Slice) TypeInfo() typeinfo.T {
	return &Zt_ListPush
}

// Implements [typeinfo.Repeats] for a slice of ListPush.
func (op *ListPush_Slice) Repeats() bool {
	return len(*op) > 0
}

// Generate a list of numbers r[i] = (start + step*i) where i>=0.
// Inputs are truncated to produce whole numbers.
// A positive step ends the series when the returned value would exceed stop.
// A negative step ends before generating a value less than stop.
type Range struct {
	To     rtti.NumEval
	Start  rtti.NumEval
	Step   rtti.NumEval
	Markup map[string]any `json:",omitempty"`
}

// range, a type of flow.
var Zt_Range typeinfo.Flow

// Implements [typeinfo.Instance]
func (*Range) TypeInfo() typeinfo.T {
	return &Zt_Range
}

// Implements [typeinfo.Markup]
func (op *Range) GetMarkup(ensure bool) map[string]any {
	if ensure && op.Markup == nil {
		op.Markup = make(map[string]any)
	}
	return op.Markup
}

// Ensures the command implements its specified slots.
var _ rtti.NumListEval = (*Range)(nil)

// Holds a slice of type Range.
type Range_Slice []Range

// Implements [typeinfo.Instance] for a slice of Range.
func (*Range_Slice) TypeInfo() typeinfo.T {
	return &Zt_Range
}

// Implements [typeinfo.Repeats] for a slice of Range.
func (op *Range_Slice) Repeats() bool {
	return len(*op) > 0
}

// init the terms of all flows in init
// so that they can refer to each other when needed.
func init() {
	Zt_ListTextAt = typeinfo.Flow{
		Name: "list_text_at",
		Lede: "text",
		Terms: []typeinfo.Term{{
			Name:  "list",
			Label: "list",
			Markup: map[string]any{
				"--": "The list to read from.",
			},
			Type: &rtti.Zt_TextListEval,
		}, {
			Name:  "index",
			Label: "at",
			Markup: map[string]any{
				"--": "The one-based index within the list to read.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
		},
		Markup: map[string]any{
			"--": "Read a text value from a list of text values.",
		},
	}
	Zt_ListNumAt = typeinfo.Flow{
		Name: "list_num_at",
		Lede: "num",
		Terms: []typeinfo.Term{{
			Name:  "list",
			Label: "list",
			Markup: map[string]any{
				"--": "The list to read from.",
			},
			Type: &rtti.Zt_NumListEval,
		}, {
			Name:  "index",
			Label: "at",
			Markup: map[string]any{
				"--": "The one-based index within the list to read.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"--": "Read a number from a list of numbers.",
		},
	}
	Zt_ListPopText = typeinfo.Flow{
		Name: "list_pop_text",
		Lede: "pop",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "text",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "edge",
			Label:    "front",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Whether to remove from the front or the back of the list.", "If not specified, removes from the back."},
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": "Remove a text value from the end ( or the start ) of a list.",
		},
	}
	Zt_ListPopNum = typeinfo.Flow{
		Name: "list_pop_num",
		Lede: "pop",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "num",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "edge",
			Label:    "front",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Whether to remove from the front or the back of the list.", "If not specified, removes from the back."},
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": "Remove a num value from the end ( or the start ) of a list.",
		},
	}
	Zt_ListPopRecord = typeinfo.Flow{
		Name: "list_pop_record",
		Lede: "pop",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "record",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "edge",
			Label:    "front",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Whether to remove from the front or the back of the list.", "If not specified, removes from the back."},
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_RecordEval,
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": "Remove a record value from the end ( or the start ) of a list.",
		},
	}
	Zt_ListErase = typeinfo.Flow{
		Name: "list_erase",
		Lede: "erase",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "start",
			Label:    "start",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"The one-based index at which to start removing values.", "If zero or not specified, starts with the first value.", "Otherwise, follows the rules of splice. "},
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "count",
			Label:    "count",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"The number of values to remove.", "If not specified, removes as many as it can.", "If zero or negative, no values are removed."},
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": "Remove one or more values from a list.",
		},
	}
	Zt_ListErasing = typeinfo.Flow{
		Name: "list_erasing",
		Lede: "erase",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "start",
			Label:    "start",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"The one-based index at which to start removing values.", "If zero or not specified, starts with the first value.", "Otherwise, follows the rules of splice. "},
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "count",
			Label:    "count",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"The number of values to remove.", "If not specified, removes as many as it can.", "If zero or negative, no values are removed."},
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:  "as",
			Label: "as",
			Markup: map[string]any{
				"--": "The new local variable which contains the erased values.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"--": []string{"The statements to call with the erased values.", "If no \"else\" branch is specified, and no values were removed,", "this will be called with an empty list."},
			},
			Type: &rtti.Zt_Execute,
		}, {
			Name:     "else",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"--": "Optional statements to run if no values were removed.",
			},
			Type: &logic.Zt_Brancher,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Remove a number of values from a list starting at a specified index.", "Run a series of statements, giving them a new local variable", "containing a list of removed values."},
		},
	}
	Zt_ListPopping = typeinfo.Flow{
		Name: "list_popping",
		Lede: "pop",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "edge",
			Label:    "front",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Control whether to remove from the front or the back of the list.", "If not specified, removes from the back."},
			},
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:  "as",
			Label: "as",
			Markup: map[string]any{
				"--": []string{"The name of a new local variable to receive the removed value.", "The variable is only in scope for the duration of the \"do\" statements."},
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"--": "A series of statements to run if a value was removed.",
			},
			Type: &rtti.Zt_Execute,
		}, {
			Name:     "else",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Optional statements to run if the specified list was empty.", "There are no special local variables defined when this is called."},
			},
			Type: &logic.Zt_Brancher,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Remove a value from the end ( or the start ) of a list.", "Run a series of statements, giving them a new local variable", "containing the removed value."},
		},
	}
	Zt_ListRepeat = typeinfo.Flow{
		Name: "list_repeat",
		Lede: "repeat",
		Terms: []typeinfo.Term{{
			Name:  "list",
			Label: "across",
			Markup: map[string]any{
				"--": "The list to read values from.",
			},
			Type: &rtti.Zt_Assignment,
		}, {
			Name:  "as",
			Label: "as",
			Markup: map[string]any{
				"--": []string{"The name of a (new) variable, given to the \"do\" statements,", "filled with the values from the list, one at a time."},
			},
			Type: &prim.Zt_Text,
		}, {
			Name:    "exe",
			Label:   "do",
			Repeats: true,
			Markup: map[string]any{
				"--": "A series of statements to run.",
			},
			Type: &rtti.Zt_Execute,
		}, {
			Name:     "else",
			Label:    "else",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Optional statements to run if the specified list was empty.", "There are no special local variables defined when this is called."},
			},
			Type: &logic.Zt_Brancher,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Run a series of statements for each value in a list.", "Several local variables are available to those statements:", "  1. the value in the list, named as specified.", "  2. \"index\", the one-based index of the current value in the list.", "  3. \"first\", a boolean indicating if this is the first value", "  4. \"last\", a boolean indicating if this is the last value.", "If the list was empty, this runs the else branch instead."},
		},
	}
	Zt_ListFind = typeinfo.Flow{
		Name: "list_find",
		Lede: "find",
		Terms: []typeinfo.Term{{
			Name: "list",
			Markup: map[string]any{
				"--": "The list to search.",
			},
			Type: &rtti.Zt_Assignment,
		}, {
			Name:  "value",
			Label: "value",
			Markup: map[string]any{
				"--": "The value to find.",
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"--": []string{"Search a list for a specific value.", "", "The [rt.NumEval] version returns the index of the value in the list."},
		},
	}
	Zt_ListLength = typeinfo.Flow{
		Name: "list_length",
		Lede: "list",
		Terms: []typeinfo.Term{{
			Name:  "list",
			Label: "length",
			Markup: map[string]any{
				"--": "The list to measure.",
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumEval,
		},
		Markup: map[string]any{
			"--": "Determine the number of values in a list.",
		},
	}
	Zt_ListEmpty = typeinfo.Flow{
		Name: "list_empty",
		Lede: "is",
		Terms: []typeinfo.Term{{
			Name:  "list",
			Label: "empty",
			Markup: map[string]any{
				"--": "The list to measure.",
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_BoolEval,
		},
		Markup: map[string]any{
			"--": "Determine if the length of the list is zero.",
		},
	}
	Zt_MakeTextList = typeinfo.Flow{
		Name: "make_text_list",
		Lede: "text",
		Terms: []typeinfo.Term{{
			Name:    "values",
			Label:   "list",
			Repeats: true,
			Markup: map[string]any{
				"--": "One or more text statements to evaluate.",
			},
			Type: &rtti.Zt_TextEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_TextListEval,
		},
		Markup: map[string]any{
			"--": "Collect one or more text values into a list.",
		},
	}
	Zt_MakeNumList = typeinfo.Flow{
		Name: "make_num_list",
		Lede: "num",
		Terms: []typeinfo.Term{{
			Name:    "values",
			Label:   "list",
			Repeats: true,
			Markup: map[string]any{
				"--": "One or more number values to evaluate.",
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumListEval,
		},
		Markup: map[string]any{
			"--": "Collect one or more numbers into a list.",
		},
	}
	Zt_MakeRecordList = typeinfo.Flow{
		Name: "make_record_list",
		Lede: "record",
		Terms: []typeinfo.Term{{
			Name:    "list",
			Label:   "list",
			Repeats: true,
			Markup: map[string]any{
				"--": "One or more record values to evaluate.",
			},
			Type: &rtti.Zt_RecordEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_RecordListEval,
		},
		Markup: map[string]any{
			"--": []string{"Collect one or more records into a list.", "All of the records must be of the same type."},
		},
	}
	Zt_ListMap = typeinfo.Flow{
		Name: "list_map",
		Lede: "map",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": []string{"The list to push new values into.", "The type of this list needs to match the type of the list being evaluated."},
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "pattern_name",
			Label: "using",
			Markup: map[string]any{
				"--": "The pattern to call for every value in the list being evaluated.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:  "list",
			Label: "list",
			Markup: map[string]any{
				"--": []string{"The list being evaluated. Every value in this list will be sent to the mapping pattern.", "The type of this list needs to match the type of the list being written to."},
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Transform the values from one list and append the results to another.", "The designated pattern is called with each value, one value at a time."},
		},
	}
	Zt_ListReduce = typeinfo.Flow{
		Name: "list_reduce",
		Lede: "reduce",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The value the list is getting packed into.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "pattern_name",
			Label: "using",
			Markup: map[string]any{
				"--": "The pattern to call for every value in the list being reduced.",
			},
			Type: &prim.Zt_Text,
		}, {
			Name:  "list",
			Label: "list",
			Markup: map[string]any{
				"--": "The list being reduced.",
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Pack the values of a list down into a single value.", "The designated pattern is called with a pair of parameters for each value in the list:", "  1. the current value from the list;", "  2. the value being packed.", "The pattern is expected to combine the two parameters and return the newly updated value."},
		},
	}
	Zt_ListReverse = typeinfo.Flow{
		Name: "list_reverse",
		Lede: "reverse",
		Terms: []typeinfo.Term{{
			Name:  "target",
			Label: "list",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Reverse the order of the values in a list.", "The first becomes last, the weak become strong, the list gets reversed,", "all that."},
		},
	}
	Zt_ListSlice = typeinfo.Flow{
		Name: "list_slice",
		Lede: "slice",
		Terms: []typeinfo.Term{{
			Name: "list",
			Markup: map[string]any{
				"--": "The list to copy values from.",
			},
			Type: &rtti.Zt_Assignment,
		}, {
			Name:     "start",
			Label:    "start",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"The one-based index to start copying from.", "See the command documentation for full details."},
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "end",
			Label:    "end",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"The one-based index of the last value to copy.", "See the command documentation for full details."},
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumListEval,
			&rtti.Zt_TextListEval,
			&rtti.Zt_RecordListEval,
		},
		Markup: map[string]any{
			"--": []string{"Create a new list from part of another list.", "Start is optional, if omitted slice starts at the beginning.", "If start is greater the length, an empty array is returned.", "Slice doesn't include the ending index.", "Negatives indices indicates an offset from the end.", "When end is omitted, or if its greater than the the length of the list,", "the slice will include everything from start up to and including the last value."},
		},
	}
	Zt_ListSort = typeinfo.Flow{
		Name: "list_sort",
		Lede: "sort",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "kind_name",
			Label:    "kind",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Treat a list of text as objects of the specified kind.", "( Ignored when sorting other lists. )"},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "field_name",
			Label:    "field",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Extract a value from the specified field and use that value when sorting.", "Specifying a field name only makes sense for lists containing records or objects, and its required for the former. "},
			},
			Type: &rtti.Zt_TextEval,
		}, {
			Name:     "descending",
			Label:    "descending",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"When true, reorder the list by decreasing value: largest value first.", "Otherwise, reorder the list by increasing value: smallest value first."},
			},
			Type: &rtti.Zt_BoolEval,
		}, {
			Name:     "case",
			Label:    "case",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"When sorting text this indicates whether the lower case letters should be considered different than upper case letters.", "By default, they are considered the same.", "( This uses ascii comparisons, so uppercase 'A' is considered less than lowercase 'a' )"},
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": []string{"Rearrange the values in a list.", "This can sort lists of numbers and text,", "as well as lists of records and object names given a sorting field."},
		},
	}
	Zt_ListSplice = typeinfo.Flow{
		Name: "list_splice",
		Lede: "splice",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:     "start",
			Label:    "start",
			Optional: true,
			Markup: map[string]any{
				"--": "The first one-based index to remove.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "count",
			Label:    "count",
			Optional: true,
			Markup: map[string]any{
				"--": "The total number of values to remove.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "insert",
			Label:    "insert",
			Optional: true,
			Markup: map[string]any{
				"--": "New values to inject into the area that was just removed.",
			},
			Type: &rtti.Zt_Assignment,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
			&rtti.Zt_NumListEval,
			&rtti.Zt_TextListEval,
			&rtti.Zt_RecordListEval,
		},
		Markup: map[string]any{
			"--": []string{"Modify a list by adding and removing values.", "If the starting index is negative, this begins that many values from the end of the list", "( clipped to the first element if that distance is more than the total list length. )", "If the remove count is missing, this removes all values from the start to the end of the list.", "if the remove count is zero or negative, no values are removed.", "The type of the values being added must match the type of the list.", "( ex. Text can only be added to a list of text. )"},
		},
	}
	Zt_ListPush = typeinfo.Flow{
		Name: "list_push",
		Lede: "push",
		Terms: []typeinfo.Term{{
			Name: "target",
			Markup: map[string]any{
				"--": "The list to modify.",
			},
			Type: &rtti.Zt_Address,
		}, {
			Name:  "value",
			Label: "value",
			Markup: map[string]any{
				"--": "The value to add to the list.",
			},
			Type: &rtti.Zt_Assignment,
		}, {
			Name:     "edge",
			Label:    "front",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"Control whether to add the new value to the front or to the back of the list.", "If not specified, adds to the back."},
			},
			Type: &rtti.Zt_BoolEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_Execute,
		},
		Markup: map[string]any{
			"--": "Add a value to the end ( or the beginning ) of a list.",
		},
	}
	Zt_Range = typeinfo.Flow{
		Name: "range",
		Lede: "range",
		Terms: []typeinfo.Term{{
			Name: "to",
			Markup: map[string]any{
				"--": "The last number to generate.",
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "start",
			Label:    "start",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"The first number generated.", "Defaults to one(1) if not specified."},
			},
			Type: &rtti.Zt_NumEval,
		}, {
			Name:     "step",
			Label:    "by",
			Optional: true,
			Markup: map[string]any{
				"--": []string{"The step to reach the next number.", "Defaults to one(1), errors if zero."},
			},
			Type: &rtti.Zt_NumEval,
		}},
		Slots: []*typeinfo.Slot{
			&rtti.Zt_NumListEval,
		},
		Markup: map[string]any{
			"--": []string{"Generate a list of numbers r[i] = (start + step*i) where i>=0.", "Inputs are truncated to produce whole numbers.", "A positive step ends the series when the returned value would exceed stop.", "A negative step ends before generating a value less than stop."},
		},
	}
}

// package listing of type data
var Z_Types = typeinfo.TypeSet{
	Name: "list",
	Comment: []string{
		"List queries, transformations, etc.",
		"Lists are a series of zero or more values, all of the same fundamental type.",
		"There can be lists of numbers, text, or records.",
		"Lists of boolean values are not supported.",
		"The first value of a list is at index 1 (one).",
	},

	Flow:       z_flow_list,
	Signatures: z_signatures,
}

// A list of all flows in this this package.
// ( ex. for reading blockly blocks )
var z_flow_list = []*typeinfo.Flow{
	&Zt_ListTextAt,
	&Zt_ListNumAt,
	&Zt_ListPopText,
	&Zt_ListPopNum,
	&Zt_ListPopRecord,
	&Zt_ListErase,
	&Zt_ListErasing,
	&Zt_ListPopping,
	&Zt_ListRepeat,
	&Zt_ListFind,
	&Zt_ListLength,
	&Zt_ListEmpty,
	&Zt_MakeTextList,
	&Zt_MakeNumList,
	&Zt_MakeRecordList,
	&Zt_ListMap,
	&Zt_ListReduce,
	&Zt_ListReverse,
	&Zt_ListSlice,
	&Zt_ListSort,
	&Zt_ListSplice,
	&Zt_ListPush,
	&Zt_Range,
}

// gob like registration
func Register(reg func(any)) {
	reg((*ListTextAt)(nil))
	reg((*ListNumAt)(nil))
	reg((*ListPopText)(nil))
	reg((*ListPopNum)(nil))
	reg((*ListPopRecord)(nil))
	reg((*ListErase)(nil))
	reg((*ListErasing)(nil))
	reg((*ListPopping)(nil))
	reg((*ListRepeat)(nil))
	reg((*ListFind)(nil))
	reg((*ListLength)(nil))
	reg((*ListEmpty)(nil))
	reg((*MakeTextList)(nil))
	reg((*MakeNumList)(nil))
	reg((*MakeRecordList)(nil))
	reg((*ListMap)(nil))
	reg((*ListReduce)(nil))
	reg((*ListReverse)(nil))
	reg((*ListSlice)(nil))
	reg((*ListSort)(nil))
	reg((*ListSplice)(nil))
	reg((*ListPush)(nil))
	reg((*Range)(nil))
}

// a list of all command signatures
// ( for processing and verifying story files )
var z_signatures = map[uint64]typeinfo.Instance{
	17857642077015906043: (*ListErase)(nil),      /* execute=Erase: */
	784745542984506088:   (*ListErasing)(nil),    /* execute=Erase:as:do: */
	2762177355174722473:  (*ListErasing)(nil),    /* execute=Erase:as:do:else: */
	4935186310301037552:  (*ListErase)(nil),      /* execute=Erase:count: */
	5630304856645386123:  (*ListErasing)(nil),    /* execute=Erase:count:as:do: */
	10246968512856977800: (*ListErasing)(nil),    /* execute=Erase:count:as:do:else: */
	17180173614285184697: (*ListErase)(nil),      /* execute=Erase:start: */
	332264396687396446:   (*ListErasing)(nil),    /* execute=Erase:start:as:do: */
	16537774391214658019: (*ListErasing)(nil),    /* execute=Erase:start:as:do:else: */
	5822664654624245166:  (*ListErase)(nil),      /* execute=Erase:start:count: */
	15625294835730398089: (*ListErasing)(nil),    /* execute=Erase:start:count:as:do: */
	12268716552163826:    (*ListErasing)(nil),    /* execute=Erase:start:count:as:do:else: */
	18153283510173426603: (*ListFind)(nil),       /* bool_eval=Find:value: */
	1621463986020822393:  (*ListFind)(nil),       /* num_eval=Find:value: */
	10867951538760575464: (*ListEmpty)(nil),      /* bool_eval=Is empty: */
	17357997793114147131: (*ListLength)(nil),     /* num_eval=List length: */
	17885543535270178165: (*ListMap)(nil),        /* execute=Map:using:list: */
	4715091378117636320:  (*MakeNumList)(nil),    /* num_list_eval=Num list: */
	2225093038246604534:  (*ListNumAt)(nil),      /* num_eval=Num list:at: */
	12837368085835684620: (*ListPopNum)(nil),     /* execute=Pop num: */
	1340064070914031398:  (*ListPopNum)(nil),     /* num_eval=Pop num: */
	13935052606176581267: (*ListPopNum)(nil),     /* execute=Pop num:front: */
	3022579111471336417:  (*ListPopNum)(nil),     /* num_eval=Pop num:front: */
	7407186149208922123:  (*ListPopRecord)(nil),  /* execute=Pop record: */
	8898233259920505192:  (*ListPopRecord)(nil),  /* record_eval=Pop record: */
	15074334201585036752: (*ListPopRecord)(nil),  /* execute=Pop record:front: */
	11713700458575689791: (*ListPopRecord)(nil),  /* record_eval=Pop record:front: */
	1325609760003207437:  (*ListPopText)(nil),    /* execute=Pop text: */
	12837710781058255384: (*ListPopText)(nil),    /* text_eval=Pop text: */
	8202516233675301246:  (*ListPopText)(nil),    /* execute=Pop text:front: */
	6884973490915362575:  (*ListPopText)(nil),    /* text_eval=Pop text:front: */
	2834274314643341603:  (*ListPopping)(nil),    /* execute=Pop:as:do: */
	17936996789180811568: (*ListPopping)(nil),    /* execute=Pop:as:do:else: */
	4282442249803169980:  (*ListPopping)(nil),    /* execute=Pop:front:as:do: */
	8093836208928123645:  (*ListPopping)(nil),    /* execute=Pop:front:as:do:else: */
	16025703306596342142: (*ListPush)(nil),       /* execute=Push:value: */
	7915107507681503145:  (*ListPush)(nil),       /* execute=Push:value:front: */
	120416590109430143:   (*Range)(nil),          /* num_list_eval=Range: */
	2236588310720217632:  (*Range)(nil),          /* num_list_eval=Range:by: */
	7123730411191192861:  (*Range)(nil),          /* num_list_eval=Range:start: */
	7214538784671803346:  (*Range)(nil),          /* num_list_eval=Range:start:by: */
	12427805269139636644: (*MakeRecordList)(nil), /* record_list_eval=Record list: */
	11259699506898424267: (*ListReduce)(nil),     /* execute=Reduce:using:list: */
	4974307639961863486:  (*ListRepeat)(nil),     /* execute=Repeat across:as:do: */
	2783644050959378755:  (*ListRepeat)(nil),     /* execute=Repeat across:as:do:else: */
	177314099445105829:   (*ListReverse)(nil),    /* execute=Reverse list: */
	4235921801420235638:  (*ListSlice)(nil),      /* num_list_eval=Slice: */
	13273073049578089927: (*ListSlice)(nil),      /* record_list_eval=Slice: */
	18323981472330239313: (*ListSlice)(nil),      /* text_list_eval=Slice: */
	3713929053224137387:  (*ListSlice)(nil),      /* num_list_eval=Slice:end: */
	326673439235441194:   (*ListSlice)(nil),      /* record_list_eval=Slice:end: */
	8469880138850798532:  (*ListSlice)(nil),      /* text_list_eval=Slice:end: */
	6763121597476813124:  (*ListSlice)(nil),      /* num_list_eval=Slice:start: */
	10126987075066562677: (*ListSlice)(nil),      /* record_list_eval=Slice:start: */
	2045310658543284955:  (*ListSlice)(nil),      /* text_list_eval=Slice:start: */
	14495675636779114361: (*ListSlice)(nil),      /* num_list_eval=Slice:start:end: */
	3241896595896148736:  (*ListSlice)(nil),      /* record_list_eval=Slice:start:end: */
	8901512565003460886:  (*ListSlice)(nil),      /* text_list_eval=Slice:start:end: */
	15310952775217209943: (*ListSort)(nil),       /* execute=Sort: */
	11733235953597335987: (*ListSort)(nil),       /* execute=Sort:case: */
	12077733642166162089: (*ListSort)(nil),       /* execute=Sort:descending: */
	1844634886929349397:  (*ListSort)(nil),       /* execute=Sort:descending:case: */
	13938387162070793577: (*ListSort)(nil),       /* execute=Sort:field: */
	5490427700489040725:  (*ListSort)(nil),       /* execute=Sort:field:case: */
	1904845790482056663:  (*ListSort)(nil),       /* execute=Sort:field:descending: */
	2661691058664653875:  (*ListSort)(nil),       /* execute=Sort:field:descending:case: */
	9216353230674034149:  (*ListSort)(nil),       /* execute=Sort:kind: */
	8718627259396578449:  (*ListSort)(nil),       /* execute=Sort:kind:case: */
	1512328177516435795:  (*ListSort)(nil),       /* execute=Sort:kind:descending: */
	14706940026810305167: (*ListSort)(nil),       /* execute=Sort:kind:descending:case: */
	11007262525127222823: (*ListSort)(nil),       /* execute=Sort:kind:field: */
	11609137863971794851: (*ListSort)(nil),       /* execute=Sort:kind:field:case: */
	10317693201609685849: (*ListSort)(nil),       /* execute=Sort:kind:field:descending: */
	13878566001245722405: (*ListSort)(nil),       /* execute=Sort:kind:field:descending:case: */
	830852984930243991:   (*ListSplice)(nil),     /* execute=Splice: */
	14996467539506847192: (*ListSplice)(nil),     /* num_list_eval=Splice: */
	15790718770209085807: (*ListSplice)(nil),     /* record_list_eval=Splice: */
	14713059036094121053: (*ListSplice)(nil),     /* text_list_eval=Splice: */
	9069307464764884188:  (*ListSplice)(nil),     /* execute=Splice:count: */
	8889435582902531223:  (*ListSplice)(nil),     /* num_list_eval=Splice:count: */
	12469425248796850532: (*ListSplice)(nil),     /* record_list_eval=Splice:count: */
	6236907930845087602:  (*ListSplice)(nil),     /* text_list_eval=Splice:count: */
	7298546818866246169:  (*ListSplice)(nil),     /* execute=Splice:count:insert: */
	6689373590177181116:  (*ListSplice)(nil),     /* num_list_eval=Splice:count:insert: */
	3875826895756143489:  (*ListSplice)(nil),     /* record_list_eval=Splice:count:insert: */
	3430534626190894179:  (*ListSplice)(nil),     /* text_list_eval=Splice:count:insert: */
	6640497675509475516:  (*ListSplice)(nil),     /* execute=Splice:insert: */
	13256315750750348133: (*ListSplice)(nil),     /* num_list_eval=Splice:insert: */
	14765517878353221876: (*ListSplice)(nil),     /* record_list_eval=Splice:insert: */
	13922682397160322158: (*ListSplice)(nil),     /* text_list_eval=Splice:insert: */
	1595466157422190565:  (*ListSplice)(nil),     /* execute=Splice:start: */
	4930323232739708026:  (*ListSplice)(nil),     /* num_list_eval=Splice:start: */
	11334819419689988141: (*ListSplice)(nil),     /* record_list_eval=Splice:start: */
	17985612090629933063: (*ListSplice)(nil),     /* text_list_eval=Splice:start: */
	247244827521210570:   (*ListSplice)(nil),     /* execute=Splice:start:count: */
	1083062712159043345:  (*ListSplice)(nil),     /* num_list_eval=Splice:start:count: */
	13284930835261196130: (*ListSplice)(nil),     /* record_list_eval=Splice:start:count: */
	10827960883157756204: (*ListSplice)(nil),     /* text_list_eval=Splice:start:count: */
	9276462553244657083:  (*ListSplice)(nil),     /* execute=Splice:start:count:insert: */
	18160978942174447810: (*ListSplice)(nil),     /* num_list_eval=Splice:start:count:insert: */
	10514846058463240179: (*ListSplice)(nil),     /* record_list_eval=Splice:start:count:insert: */
	1882471329656059529:  (*ListSplice)(nil),     /* text_list_eval=Splice:start:count:insert: */
	1560349396073927638:  (*ListSplice)(nil),     /* execute=Splice:start:insert: */
	3475348168623658059:  (*ListSplice)(nil),     /* num_list_eval=Splice:start:insert: */
	15742117235756185822: (*ListSplice)(nil),     /* record_list_eval=Splice:start:insert: */
	8889360521765815116:  (*ListSplice)(nil),     /* text_list_eval=Splice:start:insert: */
	3361062536970077668:  (*MakeTextList)(nil),   /* text_list_eval=Text list: */
	10637178953455693166: (*ListTextAt)(nil),     /* text_eval=Text list:at: */
}
