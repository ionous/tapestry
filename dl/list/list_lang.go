// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsn"
	"git.sr.ht/~ionous/iffy/rt"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: AsNum_Type,
		Uses: composer.Type_Flow,
		Lede: "num",
	}
}

const AsNum_Type = "as_num"

const AsNum_Field_Var = "$VAR"

func (op *AsNum) Marshal(n jsn.Marshaler) {
	AsNum_Marshal(n, op)
}

func AsNum_Repeats_Marshal(n jsn.Marshaler, vals *[]AsNum) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			AsNum_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func AsNum_Optional_Marshal(n jsn.Marshaler, val **AsNum) {
	if *val != nil {
		AsNum_Marshal(n, *val)
	}
}

func AsNum_Marshal(n jsn.Marshaler, val *AsNum) {
	n.MapValues("num", AsNum_Type)
	n.MapKey("", AsNum_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: AsRec_Type,
		Uses: composer.Type_Flow,
		Lede: "rec",
	}
}

const AsRec_Type = "as_rec"

const AsRec_Field_Var = "$VAR"

func (op *AsRec) Marshal(n jsn.Marshaler) {
	AsRec_Marshal(n, op)
}

func AsRec_Repeats_Marshal(n jsn.Marshaler, vals *[]AsRec) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			AsRec_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func AsRec_Optional_Marshal(n jsn.Marshaler, val **AsRec) {
	if *val != nil {
		AsRec_Marshal(n, *val)
	}
}

func AsRec_Marshal(n jsn.Marshaler, val *AsRec) {
	n.MapValues("rec", AsRec_Type)
	n.MapKey("", AsRec_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: AsTxt_Type,
		Uses: composer.Type_Flow,
		Lede: "txt",
	}
}

const AsTxt_Type = "as_txt"

const AsTxt_Field_Var = "$VAR"

func (op *AsTxt) Marshal(n jsn.Marshaler) {
	AsTxt_Marshal(n, op)
}

func AsTxt_Repeats_Marshal(n jsn.Marshaler, vals *[]AsTxt) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			AsTxt_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func AsTxt_Optional_Marshal(n jsn.Marshaler, val **AsTxt) {
	if *val != nil {
		AsTxt_Marshal(n, *val)
	}
}

func AsTxt_Marshal(n jsn.Marshaler, val *AsTxt) {
	n.MapValues("txt", AsTxt_Type)
	n.MapKey("", AsTxt_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// EraseEdge Erase at edge: Remove one or more values from a list
type EraseEdge struct {
	From   ListSource  `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
}

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseEdge_Type = "erase_edge"

const EraseEdge_Field_From = "$FROM"
const EraseEdge_Field_AtEdge = "$AT_EDGE"

func (op *EraseEdge) Marshal(n jsn.Marshaler) {
	EraseEdge_Marshal(n, op)
}

func EraseEdge_Repeats_Marshal(n jsn.Marshaler, vals *[]EraseEdge) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			EraseEdge_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func EraseEdge_Optional_Marshal(n jsn.Marshaler, val **EraseEdge) {
	if *val != nil {
		EraseEdge_Marshal(n, *val)
	}
}

func EraseEdge_Marshal(n jsn.Marshaler, val *EraseEdge) {
	n.MapValues("erase", EraseEdge_Type)
	n.MapKey("", EraseEdge_Field_From)
	/* */ ListSource_Marshal(n, &val.From)
	n.MapKey("at_front", EraseEdge_Field_AtEdge)
	/* */ rt.BoolEval_Optional_Marshal(n, &val.AtEdge)
	n.EndValues()
	return
}

// EraseIndex Erase at index: Remove one or more values from a list
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseIndex_Type = "erase_index"

const EraseIndex_Field_Count = "$COUNT"
const EraseIndex_Field_From = "$FROM"
const EraseIndex_Field_AtIndex = "$AT_INDEX"

func (op *EraseIndex) Marshal(n jsn.Marshaler) {
	EraseIndex_Marshal(n, op)
}

func EraseIndex_Repeats_Marshal(n jsn.Marshaler, vals *[]EraseIndex) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			EraseIndex_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func EraseIndex_Optional_Marshal(n jsn.Marshaler, val **EraseIndex) {
	if *val != nil {
		EraseIndex_Marshal(n, *val)
	}
}

func EraseIndex_Marshal(n jsn.Marshaler, val *EraseIndex) {
	n.MapValues("erase", EraseIndex_Type)
	n.MapKey("", EraseIndex_Field_Count)
	/* */ rt.NumberEval_Marshal(n, &val.Count)
	n.MapKey("from", EraseIndex_Field_From)
	/* */ ListSource_Marshal(n, &val.From)
	n.MapKey("at_index", EraseIndex_Field_AtIndex)
	/* */ rt.NumberEval_Marshal(n, &val.AtIndex)
	n.EndValues()
	return
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Do      core.Activity `if:"label=do"`
}

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Erasing_Type,
		Uses: composer.Type_Flow,
	}
}

const Erasing_Type = "erasing"

const Erasing_Field_Count = "$COUNT"
const Erasing_Field_From = "$FROM"
const Erasing_Field_AtIndex = "$AT_INDEX"
const Erasing_Field_As = "$AS"
const Erasing_Field_Do = "$DO"

func (op *Erasing) Marshal(n jsn.Marshaler) {
	Erasing_Marshal(n, op)
}

func Erasing_Repeats_Marshal(n jsn.Marshaler, vals *[]Erasing) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			Erasing_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func Erasing_Optional_Marshal(n jsn.Marshaler, val **Erasing) {
	if *val != nil {
		Erasing_Marshal(n, *val)
	}
}

func Erasing_Marshal(n jsn.Marshaler, val *Erasing) {
	n.MapValues(Erasing_Type, Erasing_Type)
	n.MapKey("", Erasing_Field_Count)
	/* */ rt.NumberEval_Marshal(n, &val.Count)
	n.MapKey("from", Erasing_Field_From)
	/* */ ListSource_Marshal(n, &val.From)
	n.MapKey("at_index", Erasing_Field_AtIndex)
	/* */ rt.NumberEval_Marshal(n, &val.AtIndex)
	n.MapKey("as", Erasing_Field_As)
	/* */ value.Text_Override_Marshal(n, &val.As)
	n.MapKey("do", Erasing_Field_Do)
	/* */ core.Activity_Marshal(n, &val.Do)
	n.EndValues()
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From   ListSource    `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Do     core.Activity `if:"label=do"`
	Else   core.Brancher `if:"label=else,optional"`
}

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: ErasingEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const ErasingEdge_Type = "erasing_edge"

const ErasingEdge_Field_From = "$FROM"
const ErasingEdge_Field_AtEdge = "$AT_EDGE"
const ErasingEdge_Field_As = "$AS"
const ErasingEdge_Field_Do = "$DO"
const ErasingEdge_Field_Else = "$ELSE"

func (op *ErasingEdge) Marshal(n jsn.Marshaler) {
	ErasingEdge_Marshal(n, op)
}

func ErasingEdge_Repeats_Marshal(n jsn.Marshaler, vals *[]ErasingEdge) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ErasingEdge_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ErasingEdge_Optional_Marshal(n jsn.Marshaler, val **ErasingEdge) {
	if *val != nil {
		ErasingEdge_Marshal(n, *val)
	}
}

func ErasingEdge_Marshal(n jsn.Marshaler, val *ErasingEdge) {
	n.MapValues("erasing", ErasingEdge_Type)
	n.MapKey("", ErasingEdge_Field_From)
	/* */ ListSource_Marshal(n, &val.From)
	n.MapKey("at_front", ErasingEdge_Field_AtEdge)
	/* */ rt.BoolEval_Optional_Marshal(n, &val.AtEdge)
	n.MapKey("as", ErasingEdge_Field_As)
	/* */ value.Text_Override_Marshal(n, &val.As)
	n.MapKey("do", ErasingEdge_Field_Do)
	/* */ core.Activity_Marshal(n, &val.Do)
	n.MapKey("else", ErasingEdge_Field_Else)
	/* */ core.Brancher_Optional_Marshal(n, &val.Else)
	n.EndValues()
	return
}

// FromNumList Uses a list of numbers
type FromNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const FromNumList_Type = "from_num_list"

const FromNumList_Field_Var = "$VAR"

func (op *FromNumList) Marshal(n jsn.Marshaler) {
	FromNumList_Marshal(n, op)
}

func FromNumList_Repeats_Marshal(n jsn.Marshaler, vals *[]FromNumList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			FromNumList_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func FromNumList_Optional_Marshal(n jsn.Marshaler, val **FromNumList) {
	if *val != nil {
		FromNumList_Marshal(n, *val)
	}
}

func FromNumList_Marshal(n jsn.Marshaler, val *FromNumList) {
	n.MapValues("nums", FromNumList_Type)
	n.MapKey("", FromNumList_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// FromRecList Uses a list of records
type FromRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "recs",
	}
}

const FromRecList_Type = "from_rec_list"

const FromRecList_Field_Var = "$VAR"

func (op *FromRecList) Marshal(n jsn.Marshaler) {
	FromRecList_Marshal(n, op)
}

func FromRecList_Repeats_Marshal(n jsn.Marshaler, vals *[]FromRecList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			FromRecList_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func FromRecList_Optional_Marshal(n jsn.Marshaler, val **FromRecList) {
	if *val != nil {
		FromRecList_Marshal(n, *val)
	}
}

func FromRecList_Marshal(n jsn.Marshaler, val *FromRecList) {
	n.MapValues("recs", FromRecList_Type)
	n.MapKey("", FromRecList_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// FromTxtList Uses a list of text
type FromTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const FromTxtList_Type = "from_txt_list"

const FromTxtList_Field_Var = "$VAR"

func (op *FromTxtList) Marshal(n jsn.Marshaler) {
	FromTxtList_Marshal(n, op)
}

func FromTxtList_Repeats_Marshal(n jsn.Marshaler, vals *[]FromTxtList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			FromTxtList_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func FromTxtList_Optional_Marshal(n jsn.Marshaler, val **FromTxtList) {
	if *val != nil {
		FromTxtList_Marshal(n, *val)
	}
}

func FromTxtList_Marshal(n jsn.Marshaler, val *FromTxtList) {
	n.MapValues("txts", FromTxtList_Type)
	n.MapKey("", FromTxtList_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// IntoNumList Targets a list of numbers
type IntoNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const IntoNumList_Type = "into_num_list"

const IntoNumList_Field_Var = "$VAR"

func (op *IntoNumList) Marshal(n jsn.Marshaler) {
	IntoNumList_Marshal(n, op)
}

func IntoNumList_Repeats_Marshal(n jsn.Marshaler, vals *[]IntoNumList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			IntoNumList_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func IntoNumList_Optional_Marshal(n jsn.Marshaler, val **IntoNumList) {
	if *val != nil {
		IntoNumList_Marshal(n, *val)
	}
}

func IntoNumList_Marshal(n jsn.Marshaler, val *IntoNumList) {
	n.MapValues("nums", IntoNumList_Type)
	n.MapKey("", IntoNumList_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// IntoRecList Targets a list of records
type IntoRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "recs",
	}
}

const IntoRecList_Type = "into_rec_list"

const IntoRecList_Field_Var = "$VAR"

func (op *IntoRecList) Marshal(n jsn.Marshaler) {
	IntoRecList_Marshal(n, op)
}

func IntoRecList_Repeats_Marshal(n jsn.Marshaler, vals *[]IntoRecList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			IntoRecList_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func IntoRecList_Optional_Marshal(n jsn.Marshaler, val **IntoRecList) {
	if *val != nil {
		IntoRecList_Marshal(n, *val)
	}
}

func IntoRecList_Marshal(n jsn.Marshaler, val *IntoRecList) {
	n.MapValues("recs", IntoRecList_Type)
	n.MapKey("", IntoRecList_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// IntoTxtList Targets a list of text
type IntoTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const IntoTxtList_Type = "into_txt_list"

const IntoTxtList_Field_Var = "$VAR"

func (op *IntoTxtList) Marshal(n jsn.Marshaler) {
	IntoTxtList_Marshal(n, op)
}

func IntoTxtList_Repeats_Marshal(n jsn.Marshaler, vals *[]IntoTxtList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			IntoTxtList_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func IntoTxtList_Optional_Marshal(n jsn.Marshaler, val **IntoTxtList) {
	if *val != nil {
		IntoTxtList_Marshal(n, *val)
	}
}

func IntoTxtList_Marshal(n jsn.Marshaler, val *IntoTxtList) {
	n.MapValues("txts", IntoTxtList_Type)
	n.MapKey("", IntoTxtList_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.EndValues()
	return
}

// ListAt Get a value from a list. The first element is is index 1.
type ListAt struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: ListAt_Type,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const ListAt_Type = "list_at"

const ListAt_Field_List = "$LIST"
const ListAt_Field_Index = "$INDEX"

func (op *ListAt) Marshal(n jsn.Marshaler) {
	ListAt_Marshal(n, op)
}

func ListAt_Repeats_Marshal(n jsn.Marshaler, vals *[]ListAt) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListAt_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListAt_Optional_Marshal(n jsn.Marshaler, val **ListAt) {
	if *val != nil {
		ListAt_Marshal(n, *val)
	}
}

func ListAt_Marshal(n jsn.Marshaler, val *ListAt) {
	n.MapValues("get", ListAt_Type)
	n.MapKey("", ListAt_Field_List)
	/* */ rt.Assignment_Marshal(n, &val.List)
	n.MapKey("index", ListAt_Field_Index)
	/* */ rt.NumberEval_Marshal(n, &val.Index)
	n.EndValues()
	return
}

// ListEach Loops over the elements in the passed list, or runs the &#x27;else&#x27; activity if empty.
type ListEach struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: ListEach_Type,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const ListEach_Type = "list_each"

const ListEach_Field_List = "$LIST"
const ListEach_Field_As = "$AS"
const ListEach_Field_Do = "$DO"
const ListEach_Field_Else = "$ELSE"

func (op *ListEach) Marshal(n jsn.Marshaler) {
	ListEach_Marshal(n, op)
}

func ListEach_Repeats_Marshal(n jsn.Marshaler, vals *[]ListEach) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListEach_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListEach_Optional_Marshal(n jsn.Marshaler, val **ListEach) {
	if *val != nil {
		ListEach_Marshal(n, *val)
	}
}

func ListEach_Marshal(n jsn.Marshaler, val *ListEach) {
	n.MapValues("repeating", ListEach_Type)
	n.MapKey("across", ListEach_Field_List)
	/* */ rt.Assignment_Marshal(n, &val.List)
	n.MapKey("as", ListEach_Field_As)
	/* */ ListIterator_Marshal(n, &val.As)
	n.MapKey("do", ListEach_Field_Do)
	/* */ core.Activity_Marshal(n, &val.Do)
	n.MapKey("else", ListEach_Field_Else)
	/* */ core.Brancher_Optional_Marshal(n, &val.Else)
	n.EndValues()
	return
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFind_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFind_Type = "list_find"

const ListFind_Field_Value = "$VALUE"
const ListFind_Field_List = "$LIST"

func (op *ListFind) Marshal(n jsn.Marshaler) {
	ListFind_Marshal(n, op)
}

func ListFind_Repeats_Marshal(n jsn.Marshaler, vals *[]ListFind) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListFind_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListFind_Optional_Marshal(n jsn.Marshaler, val **ListFind) {
	if *val != nil {
		ListFind_Marshal(n, *val)
	}
}

func ListFind_Marshal(n jsn.Marshaler, val *ListFind) {
	n.MapValues("find", ListFind_Type)
	n.MapKey("", ListFind_Field_Value)
	/* */ rt.Assignment_Marshal(n, &val.Value)
	n.MapKey("list", ListFind_Field_List)
	/* */ rt.Assignment_Marshal(n, &val.List)
	n.EndValues()
	return
}

// ListGather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: &#x27;in&#x27; as each value from the list, and &#x27;out&#x27; as the var passed to the gather.
type ListGather struct {
	Var   value.VariableName `if:"label=_"`
	From  ListSource         `if:"label=from"`
	Using string             `if:"label=_,type=text"`
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: ListGather_Type,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const ListGather_Type = "list_gather"

const ListGather_Field_Var = "$VAR"
const ListGather_Field_From = "$FROM"
const ListGather_Field_Using = "$USING"

func (op *ListGather) Marshal(n jsn.Marshaler) {
	ListGather_Marshal(n, op)
}

func ListGather_Repeats_Marshal(n jsn.Marshaler, vals *[]ListGather) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListGather_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListGather_Optional_Marshal(n jsn.Marshaler, val **ListGather) {
	if *val != nil {
		ListGather_Marshal(n, *val)
	}
}

func ListGather_Marshal(n jsn.Marshaler, val *ListGather) {
	n.MapValues("gather", ListGather_Type)
	n.MapKey("", ListGather_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.MapKey("from", ListGather_Field_From)
	/* */ ListSource_Marshal(n, &val.From)
	n.MapKey("", ListGather_Field_Using)
	/* */ value.Text_Override_Marshal(n, &val.Using)
	n.EndValues()
	return
}

const ListIterator_Type = "list_iterator"

var ListIterator_Optional_Marshal = ListIterator_Marshal

func ListIterator_Marshal(n jsn.Marshaler, ptr *ListIterator) {
	if slat := *ptr; slat != nil {
		slat.(jsn.Marshalee).Marshal(n)
	}
	return
}

func ListIterator_Repeats_Marshal(n jsn.Marshaler, vals *[]ListIterator) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListIterator_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List rt.Assignment `if:"label=_"`
}

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: ListLen_Type,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const ListLen_Type = "list_len"

const ListLen_Field_List = "$LIST"

func (op *ListLen) Marshal(n jsn.Marshaler) {
	ListLen_Marshal(n, op)
}

func ListLen_Repeats_Marshal(n jsn.Marshaler, vals *[]ListLen) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListLen_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListLen_Optional_Marshal(n jsn.Marshaler, val **ListLen) {
	if *val != nil {
		ListLen_Marshal(n, *val)
	}
}

func ListLen_Marshal(n jsn.Marshaler, val *ListLen) {
	n.MapValues("len", ListLen_Type)
	n.MapKey("", ListLen_Field_List)
	/* */ rt.Assignment_Marshal(n, &val.List)
	n.EndValues()
	return
}

// ListMap Transform the values from one list and place the results in another list. The designated pattern is called with each value from the &#x27;from list&#x27;, one value at a time.
type ListMap struct {
	ToList       string        `if:"label=_,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: ListMap_Type,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const ListMap_Type = "list_map"

const ListMap_Field_ToList = "$TO_LIST"
const ListMap_Field_FromList = "$FROM_LIST"
const ListMap_Field_UsingPattern = "$USING_PATTERN"

func (op *ListMap) Marshal(n jsn.Marshaler) {
	ListMap_Marshal(n, op)
}

func ListMap_Repeats_Marshal(n jsn.Marshaler, vals *[]ListMap) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListMap_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListMap_Optional_Marshal(n jsn.Marshaler, val **ListMap) {
	if *val != nil {
		ListMap_Marshal(n, *val)
	}
}

func ListMap_Marshal(n jsn.Marshaler, val *ListMap) {
	n.MapValues("map", ListMap_Type)
	n.MapKey("", ListMap_Field_ToList)
	/* */ value.Text_Override_Marshal(n, &val.ToList)
	n.MapKey("from_list", ListMap_Field_FromList)
	/* */ rt.Assignment_Marshal(n, &val.FromList)
	n.MapKey("using", ListMap_Field_UsingPattern)
	/* */ value.Text_Override_Marshal(n, &val.UsingPattern)
	n.EndValues()
	return
}

// ListReduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: &#x27;in&#x27; ( each element of the list ) and &#x27;out&#x27; ( ex. a record ).
type ListReduce struct {
	IntoValue    string        `if:"label=into,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReduce_Type,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const ListReduce_Type = "list_reduce"

const ListReduce_Field_IntoValue = "$INTO_VALUE"
const ListReduce_Field_FromList = "$FROM_LIST"
const ListReduce_Field_UsingPattern = "$USING_PATTERN"

func (op *ListReduce) Marshal(n jsn.Marshaler) {
	ListReduce_Marshal(n, op)
}

func ListReduce_Repeats_Marshal(n jsn.Marshaler, vals *[]ListReduce) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListReduce_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListReduce_Optional_Marshal(n jsn.Marshaler, val **ListReduce) {
	if *val != nil {
		ListReduce_Marshal(n, *val)
	}
}

func ListReduce_Marshal(n jsn.Marshaler, val *ListReduce) {
	n.MapValues("reduce", ListReduce_Type)
	n.MapKey("into", ListReduce_Field_IntoValue)
	/* */ value.Text_Override_Marshal(n, &val.IntoValue)
	n.MapKey("from_list", ListReduce_Field_FromList)
	/* */ rt.Assignment_Marshal(n, &val.FromList)
	n.MapKey("using", ListReduce_Field_UsingPattern)
	/* */ value.Text_Override_Marshal(n, &val.UsingPattern)
	n.EndValues()
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	List ListSource `if:"label=_"`
}

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReverse_Type,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const ListReverse_Type = "list_reverse"

const ListReverse_Field_List = "$LIST"

func (op *ListReverse) Marshal(n jsn.Marshaler) {
	ListReverse_Marshal(n, op)
}

func ListReverse_Repeats_Marshal(n jsn.Marshaler, vals *[]ListReverse) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListReverse_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListReverse_Optional_Marshal(n jsn.Marshaler, val **ListReverse) {
	if *val != nil {
		ListReverse_Marshal(n, *val)
	}
}

func ListReverse_Marshal(n jsn.Marshaler, val *ListReverse) {
	n.MapValues("reverse", ListReverse_Type)
	n.MapKey("", ListReverse_Field_List)
	/* */ ListSource_Marshal(n, &val.List)
	n.EndValues()
	return
}

// ListSet Overwrite an existing value in a list.
type ListSet struct {
	List  string        `if:"label=_,type=text"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSet_Type,
		Uses: composer.Type_Flow,
		Lede: "set",
	}
}

const ListSet_Type = "list_set"

const ListSet_Field_List = "$LIST"
const ListSet_Field_Index = "$INDEX"
const ListSet_Field_From = "$FROM"

func (op *ListSet) Marshal(n jsn.Marshaler) {
	ListSet_Marshal(n, op)
}

func ListSet_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSet) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListSet_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListSet_Optional_Marshal(n jsn.Marshaler, val **ListSet) {
	if *val != nil {
		ListSet_Marshal(n, *val)
	}
}

func ListSet_Marshal(n jsn.Marshaler, val *ListSet) {
	n.MapValues("set", ListSet_Type)
	n.MapKey("", ListSet_Field_List)
	/* */ value.Text_Override_Marshal(n, &val.List)
	n.MapKey("index", ListSet_Field_Index)
	/* */ rt.NumberEval_Marshal(n, &val.Index)
	n.MapKey("from", ListSet_Field_From)
	/* */ rt.Assignment_Marshal(n, &val.From)
	n.EndValues()
	return
}

// ListSlice Create a new list from a section of another list.,Start is optional, if omitted slice starts at the first element.,If start is greater the length, an empty array is returned.,Slice doesnt include the ending index.,Negatives indices indicates an offset from the end.,When end is omitted, copy up to and including the last element;,and do the same if the end is greater than the length
type ListSlice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSlice_Type,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const ListSlice_Type = "list_slice"

const ListSlice_Field_List = "$LIST"
const ListSlice_Field_Start = "$START"
const ListSlice_Field_End = "$END"

func (op *ListSlice) Marshal(n jsn.Marshaler) {
	ListSlice_Marshal(n, op)
}

func ListSlice_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSlice) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListSlice_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListSlice_Optional_Marshal(n jsn.Marshaler, val **ListSlice) {
	if *val != nil {
		ListSlice_Marshal(n, *val)
	}
}

func ListSlice_Marshal(n jsn.Marshaler, val *ListSlice) {
	n.MapValues("slice", ListSlice_Type)
	n.MapKey("", ListSlice_Field_List)
	/* */ rt.Assignment_Marshal(n, &val.List)
	n.MapKey("start", ListSlice_Field_Start)
	/* */ rt.NumberEval_Optional_Marshal(n, &val.Start)
	n.MapKey("end", ListSlice_Field_End)
	/* */ rt.NumberEval_Optional_Marshal(n, &val.End)
	n.EndValues()
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
}

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortNumbers_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortNumbers_Type = "list_sort_numbers"

const ListSortNumbers_Field_Var = "$VAR"
const ListSortNumbers_Field_ByField = "$BY_FIELD"
const ListSortNumbers_Field_Descending = "$DESCENDING"

func (op *ListSortNumbers) Marshal(n jsn.Marshaler) {
	ListSortNumbers_Marshal(n, op)
}

func ListSortNumbers_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSortNumbers) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListSortNumbers_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListSortNumbers_Optional_Marshal(n jsn.Marshaler, val **ListSortNumbers) {
	if *val != nil {
		ListSortNumbers_Marshal(n, *val)
	}
}

func ListSortNumbers_Marshal(n jsn.Marshaler, val *ListSortNumbers) {
	n.MapValues("sort", ListSortNumbers_Type)
	n.MapKey("", ListSortNumbers_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.MapKey("by_field", ListSortNumbers_Field_ByField)
	/* */ value.Text_Override_Marshal(n, &val.ByField)
	n.MapKey("descending", ListSortNumbers_Field_Descending)
	/* */ rt.BoolEval_Optional_Marshal(n, &val.Descending)
	n.EndValues()
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
	UsingCase  rt.BoolEval        `if:"label=using_case,optional"`
}

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortText_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortText_Type = "list_sort_text"

const ListSortText_Field_Var = "$VAR"
const ListSortText_Field_ByField = "$BY_FIELD"
const ListSortText_Field_Descending = "$DESCENDING"
const ListSortText_Field_UsingCase = "$USING_CASE"

func (op *ListSortText) Marshal(n jsn.Marshaler) {
	ListSortText_Marshal(n, op)
}

func ListSortText_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSortText) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListSortText_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListSortText_Optional_Marshal(n jsn.Marshaler, val **ListSortText) {
	if *val != nil {
		ListSortText_Marshal(n, *val)
	}
}

func ListSortText_Marshal(n jsn.Marshaler, val *ListSortText) {
	n.MapValues("sort", ListSortText_Type)
	n.MapKey("", ListSortText_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.MapKey("by_field", ListSortText_Field_ByField)
	/* */ value.Text_Override_Marshal(n, &val.ByField)
	n.MapKey("descending", ListSortText_Field_Descending)
	/* */ rt.BoolEval_Optional_Marshal(n, &val.Descending)
	n.MapKey("using_case", ListSortText_Field_UsingCase)
	/* */ rt.BoolEval_Optional_Marshal(n, &val.UsingCase)
	n.EndValues()
	return
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortUsing struct {
	Var   value.VariableName `if:"label=_"`
	Using string             `if:"label=using,type=text"`
}

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortUsing_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortUsing_Type = "list_sort_using"

const ListSortUsing_Field_Var = "$VAR"
const ListSortUsing_Field_Using = "$USING"

func (op *ListSortUsing) Marshal(n jsn.Marshaler) {
	ListSortUsing_Marshal(n, op)
}

func ListSortUsing_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSortUsing) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListSortUsing_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListSortUsing_Optional_Marshal(n jsn.Marshaler, val **ListSortUsing) {
	if *val != nil {
		ListSortUsing_Marshal(n, *val)
	}
}

func ListSortUsing_Marshal(n jsn.Marshaler, val *ListSortUsing) {
	n.MapValues("sort", ListSortUsing_Type)
	n.MapKey("", ListSortUsing_Field_Var)
	/* */ value.VariableName_Marshal(n, &val.Var)
	n.MapKey("using", ListSortUsing_Field_Using)
	/* */ value.Text_Override_Marshal(n, &val.Using)
	n.EndValues()
	return
}

const ListSource_Type = "list_source"

var ListSource_Optional_Marshal = ListSource_Marshal

func ListSource_Marshal(n jsn.Marshaler, ptr *ListSource) {
	if slat := *ptr; slat != nil {
		slat.(jsn.Marshalee).Marshal(n)
	}
	return
}

func ListSource_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSource) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListSource_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

// ListSplice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list&#x27;s length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
type ListSplice struct {
	List   string        `if:"label=_,type=text"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSplice_Type,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const ListSplice_Type = "list_splice"

const ListSplice_Field_List = "$LIST"
const ListSplice_Field_Start = "$START"
const ListSplice_Field_Remove = "$REMOVE"
const ListSplice_Field_Insert = "$INSERT"

func (op *ListSplice) Marshal(n jsn.Marshaler) {
	ListSplice_Marshal(n, op)
}

func ListSplice_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSplice) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListSplice_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func ListSplice_Optional_Marshal(n jsn.Marshaler, val **ListSplice) {
	if *val != nil {
		ListSplice_Marshal(n, *val)
	}
}

func ListSplice_Marshal(n jsn.Marshaler, val *ListSplice) {
	n.MapValues("splice", ListSplice_Type)
	n.MapKey("", ListSplice_Field_List)
	/* */ value.Text_Override_Marshal(n, &val.List)
	n.MapKey("start", ListSplice_Field_Start)
	/* */ rt.NumberEval_Marshal(n, &val.Start)
	n.MapKey("remove", ListSplice_Field_Remove)
	/* */ rt.NumberEval_Marshal(n, &val.Remove)
	n.MapKey("insert", ListSplice_Field_Insert)
	/* */ rt.Assignment_Marshal(n, &val.Insert)
	n.EndValues()
	return
}

const ListTarget_Type = "list_target"

var ListTarget_Optional_Marshal = ListTarget_Marshal

func ListTarget_Marshal(n jsn.Marshaler, ptr *ListTarget) {
	if slat := *ptr; slat != nil {
		slat.(jsn.Marshalee).Marshal(n)
	}
	return
}

func ListTarget_Repeats_Marshal(n jsn.Marshaler, vals *[]ListTarget) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			ListTarget_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

// PutEdge Add a value to a list
type PutEdge struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
}

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: PutEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutEdge_Type = "put_edge"

const PutEdge_Field_From = "$FROM"
const PutEdge_Field_Into = "$INTO"
const PutEdge_Field_AtEdge = "$AT_EDGE"

func (op *PutEdge) Marshal(n jsn.Marshaler) {
	PutEdge_Marshal(n, op)
}

func PutEdge_Repeats_Marshal(n jsn.Marshaler, vals *[]PutEdge) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			PutEdge_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func PutEdge_Optional_Marshal(n jsn.Marshaler, val **PutEdge) {
	if *val != nil {
		PutEdge_Marshal(n, *val)
	}
}

func PutEdge_Marshal(n jsn.Marshaler, val *PutEdge) {
	n.MapValues("put", PutEdge_Type)
	n.MapKey("", PutEdge_Field_From)
	/* */ rt.Assignment_Marshal(n, &val.From)
	n.MapKey("into", PutEdge_Field_Into)
	/* */ ListTarget_Marshal(n, &val.Into)
	n.MapKey("at_front", PutEdge_Field_AtEdge)
	/* */ rt.BoolEval_Optional_Marshal(n, &val.AtEdge)
	n.EndValues()
	return
}

// PutIndex Replace one value in a list with another
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: PutIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutIndex_Type = "put_index"

const PutIndex_Field_From = "$FROM"
const PutIndex_Field_Into = "$INTO"
const PutIndex_Field_AtIndex = "$AT_INDEX"

func (op *PutIndex) Marshal(n jsn.Marshaler) {
	PutIndex_Marshal(n, op)
}

func PutIndex_Repeats_Marshal(n jsn.Marshaler, vals *[]PutIndex) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			PutIndex_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func PutIndex_Optional_Marshal(n jsn.Marshaler, val **PutIndex) {
	if *val != nil {
		PutIndex_Marshal(n, *val)
	}
}

func PutIndex_Marshal(n jsn.Marshaler, val *PutIndex) {
	n.MapValues("put", PutIndex_Type)
	n.MapKey("", PutIndex_Field_From)
	/* */ rt.Assignment_Marshal(n, &val.From)
	n.MapKey("into", PutIndex_Field_Into)
	/* */ ListTarget_Marshal(n, &val.Into)
	n.MapKey("at_index", PutIndex_Field_AtIndex)
	/* */ rt.NumberEval_Marshal(n, &val.AtIndex)
	n.EndValues()
	return
}

// Range Generates a series of numbers r[i] &#x3D; (start + step*i) where i&gt;&#x3D;0.,Start and step default to 1, stop defaults to start;,the inputs are truncated to produce whole numbers;,a zero step returns an error.,A positive step ends the series when the returned value would exceed stop,while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Range_Type,
		Uses: composer.Type_Flow,
	}
}

const Range_Type = "range"

const Range_Field_To = "$TO"
const Range_Field_From = "$FROM"
const Range_Field_ByStep = "$BY_STEP"

func (op *Range) Marshal(n jsn.Marshaler) {
	Range_Marshal(n, op)
}

func Range_Repeats_Marshal(n jsn.Marshaler, vals *[]Range) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		n.RepeatValues(cnt)
		for _, el := range *vals {
			Range_Marshal(n, &el)
		}
		n.EndValues()
	}
	return
}

func Range_Optional_Marshal(n jsn.Marshaler, val **Range) {
	if *val != nil {
		Range_Marshal(n, *val)
	}
}

func Range_Marshal(n jsn.Marshaler, val *Range) {
	n.MapValues(Range_Type, Range_Type)
	n.MapKey("", Range_Field_To)
	/* */ rt.NumberEval_Marshal(n, &val.To)
	n.MapKey("from", Range_Field_From)
	/* */ rt.NumberEval_Optional_Marshal(n, &val.From)
	n.MapKey("by_step", Range_Field_ByStep)
	/* */ rt.NumberEval_Optional_Marshal(n, &val.ByStep)
	n.EndValues()
	return
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}

var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
}
