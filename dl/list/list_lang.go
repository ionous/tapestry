// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/literal"
	"git.sr.ht/~ionous/tapestry/jsn"
	"git.sr.ht/~ionous/tapestry/rt"
	"github.com/ionous/errutil"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListIterator = (*AsNum)(nil)

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: AsNum_Type,
		Uses: composer.Type_Flow,
	}
}

const AsNum_Type = "as_num"
const AsNum_Field_Var = "$VAR"

func (op *AsNum) Marshal(m jsn.Marshaler) error {
	return AsNum_Marshal(m, op)
}

type AsNum_Slice []AsNum

func (op *AsNum_Slice) GetType() string { return AsNum_Type }

func (op *AsNum_Slice) Marshal(m jsn.Marshaler) error {
	return AsNum_Repeats_Marshal(m, (*[]AsNum)(op))
}

func (op *AsNum_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *AsNum_Slice) SetSize(cnt int) {
	var els []AsNum
	if cnt >= 0 {
		els = make(AsNum_Slice, cnt)
	}
	(*op) = els
}

func (op *AsNum_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return AsNum_Marshal(m, &(*op)[i])
}

func AsNum_Repeats_Marshal(m jsn.Marshaler, vals *[]AsNum) error {
	return jsn.RepeatBlock(m, (*AsNum_Slice)(vals))
}

func AsNum_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]AsNum) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = AsNum_Repeats_Marshal(m, pv)
	}
	return
}

type AsNum_Flow struct{ ptr *AsNum }

func (n AsNum_Flow) GetType() string      { return AsNum_Type }
func (n AsNum_Flow) GetLede() string      { return AsNum_Type }
func (n AsNum_Flow) GetFlow() interface{} { return n.ptr }
func (n AsNum_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*AsNum); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func AsNum_Optional_Marshal(m jsn.Marshaler, pv **AsNum) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsNum_Marshal(m, *pv)
	} else if !enc {
		var v AsNum
		if err = AsNum_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsNum_Marshal(m jsn.Marshaler, val *AsNum) (err error) {
	if err = m.MarshalBlock(AsNum_Flow{val}); err == nil {
		e0 := m.MarshalKey("", AsNum_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsNum_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListIterator = (*AsRec)(nil)

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: AsRec_Type,
		Uses: composer.Type_Flow,
	}
}

const AsRec_Type = "as_rec"
const AsRec_Field_Var = "$VAR"

func (op *AsRec) Marshal(m jsn.Marshaler) error {
	return AsRec_Marshal(m, op)
}

type AsRec_Slice []AsRec

func (op *AsRec_Slice) GetType() string { return AsRec_Type }

func (op *AsRec_Slice) Marshal(m jsn.Marshaler) error {
	return AsRec_Repeats_Marshal(m, (*[]AsRec)(op))
}

func (op *AsRec_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *AsRec_Slice) SetSize(cnt int) {
	var els []AsRec
	if cnt >= 0 {
		els = make(AsRec_Slice, cnt)
	}
	(*op) = els
}

func (op *AsRec_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return AsRec_Marshal(m, &(*op)[i])
}

func AsRec_Repeats_Marshal(m jsn.Marshaler, vals *[]AsRec) error {
	return jsn.RepeatBlock(m, (*AsRec_Slice)(vals))
}

func AsRec_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]AsRec) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = AsRec_Repeats_Marshal(m, pv)
	}
	return
}

type AsRec_Flow struct{ ptr *AsRec }

func (n AsRec_Flow) GetType() string      { return AsRec_Type }
func (n AsRec_Flow) GetLede() string      { return AsRec_Type }
func (n AsRec_Flow) GetFlow() interface{} { return n.ptr }
func (n AsRec_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*AsRec); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func AsRec_Optional_Marshal(m jsn.Marshaler, pv **AsRec) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsRec_Marshal(m, *pv)
	} else if !enc {
		var v AsRec
		if err = AsRec_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsRec_Marshal(m jsn.Marshaler, val *AsRec) (err error) {
	if err = m.MarshalBlock(AsRec_Flow{val}); err == nil {
		e0 := m.MarshalKey("", AsRec_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsRec_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListIterator = (*AsTxt)(nil)

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: AsTxt_Type,
		Uses: composer.Type_Flow,
	}
}

const AsTxt_Type = "as_txt"
const AsTxt_Field_Var = "$VAR"

func (op *AsTxt) Marshal(m jsn.Marshaler) error {
	return AsTxt_Marshal(m, op)
}

type AsTxt_Slice []AsTxt

func (op *AsTxt_Slice) GetType() string { return AsTxt_Type }

func (op *AsTxt_Slice) Marshal(m jsn.Marshaler) error {
	return AsTxt_Repeats_Marshal(m, (*[]AsTxt)(op))
}

func (op *AsTxt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *AsTxt_Slice) SetSize(cnt int) {
	var els []AsTxt
	if cnt >= 0 {
		els = make(AsTxt_Slice, cnt)
	}
	(*op) = els
}

func (op *AsTxt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return AsTxt_Marshal(m, &(*op)[i])
}

func AsTxt_Repeats_Marshal(m jsn.Marshaler, vals *[]AsTxt) error {
	return jsn.RepeatBlock(m, (*AsTxt_Slice)(vals))
}

func AsTxt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]AsTxt) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = AsTxt_Repeats_Marshal(m, pv)
	}
	return
}

type AsTxt_Flow struct{ ptr *AsTxt }

func (n AsTxt_Flow) GetType() string      { return AsTxt_Type }
func (n AsTxt_Flow) GetLede() string      { return AsTxt_Type }
func (n AsTxt_Flow) GetFlow() interface{} { return n.ptr }
func (n AsTxt_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*AsTxt); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func AsTxt_Optional_Marshal(m jsn.Marshaler, pv **AsTxt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsTxt_Marshal(m, *pv)
	} else if !enc {
		var v AsTxt
		if err = AsTxt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsTxt_Marshal(m jsn.Marshaler, val *AsTxt) (err error) {
	if err = m.MarshalBlock(AsTxt_Flow{val}); err == nil {
		e0 := m.MarshalKey("", AsTxt_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsTxt_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// EraseEdge Erase at edge: Remove one or more values from a list
type EraseEdge struct {
	From   ListSource  `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
}

// User implemented slots:
var _ rt.Execute = (*EraseEdge)(nil)

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseEdge_Type = "erase_edge"
const EraseEdge_Field_From = "$FROM"
const EraseEdge_Field_AtEdge = "$AT_EDGE"

func (op *EraseEdge) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Marshal(m, op)
}

type EraseEdge_Slice []EraseEdge

func (op *EraseEdge_Slice) GetType() string { return EraseEdge_Type }

func (op *EraseEdge_Slice) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Repeats_Marshal(m, (*[]EraseEdge)(op))
}

func (op *EraseEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EraseEdge_Slice) SetSize(cnt int) {
	var els []EraseEdge
	if cnt >= 0 {
		els = make(EraseEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *EraseEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EraseEdge_Marshal(m, &(*op)[i])
}

func EraseEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseEdge) error {
	return jsn.RepeatBlock(m, (*EraseEdge_Slice)(vals))
}

func EraseEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EraseEdge) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EraseEdge_Repeats_Marshal(m, pv)
	}
	return
}

type EraseEdge_Flow struct{ ptr *EraseEdge }

func (n EraseEdge_Flow) GetType() string      { return EraseEdge_Type }
func (n EraseEdge_Flow) GetLede() string      { return "erase" }
func (n EraseEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n EraseEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EraseEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EraseEdge_Optional_Marshal(m jsn.Marshaler, pv **EraseEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseEdge_Marshal(m, *pv)
	} else if !enc {
		var v EraseEdge
		if err = EraseEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseEdge_Marshal(m jsn.Marshaler, val *EraseEdge) (err error) {
	if err = m.MarshalBlock(EraseEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EraseEdge_Field_From)
		if e0 == nil {
			e0 = ListSource_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseEdge_Field_From))
		}
		e1 := m.MarshalKey("at_front", EraseEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseEdge_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

// User implemented slots:
var _ rt.Execute = (*EraseIndex)(nil)

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseIndex_Type = "erase_index"
const EraseIndex_Field_Count = "$COUNT"
const EraseIndex_Field_From = "$FROM"
const EraseIndex_Field_AtIndex = "$AT_INDEX"

func (op *EraseIndex) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Marshal(m, op)
}

type EraseIndex_Slice []EraseIndex

func (op *EraseIndex_Slice) GetType() string { return EraseIndex_Type }

func (op *EraseIndex_Slice) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Repeats_Marshal(m, (*[]EraseIndex)(op))
}

func (op *EraseIndex_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EraseIndex_Slice) SetSize(cnt int) {
	var els []EraseIndex
	if cnt >= 0 {
		els = make(EraseIndex_Slice, cnt)
	}
	(*op) = els
}

func (op *EraseIndex_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EraseIndex_Marshal(m, &(*op)[i])
}

func EraseIndex_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseIndex) error {
	return jsn.RepeatBlock(m, (*EraseIndex_Slice)(vals))
}

func EraseIndex_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EraseIndex) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = EraseIndex_Repeats_Marshal(m, pv)
	}
	return
}

type EraseIndex_Flow struct{ ptr *EraseIndex }

func (n EraseIndex_Flow) GetType() string      { return EraseIndex_Type }
func (n EraseIndex_Flow) GetLede() string      { return "erase" }
func (n EraseIndex_Flow) GetFlow() interface{} { return n.ptr }
func (n EraseIndex_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EraseIndex); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EraseIndex_Optional_Marshal(m jsn.Marshaler, pv **EraseIndex) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseIndex_Marshal(m, *pv)
	} else if !enc {
		var v EraseIndex
		if err = EraseIndex_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseIndex_Marshal(m jsn.Marshaler, val *EraseIndex) (err error) {
	if err = m.MarshalBlock(EraseIndex_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EraseIndex_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseIndex_Field_Count))
		}
		e1 := m.MarshalKey("from", EraseIndex_Field_From)
		if e1 == nil {
			e1 = ListSource_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseIndex_Field_From))
		}
		e2 := m.MarshalKey("at_index", EraseIndex_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EraseIndex_Field_AtIndex))
		}
		m.EndBlock()
	}
	return
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Do      core.Activity `if:"label=do"`
}

// User implemented slots:
var _ rt.Execute = (*Erasing)(nil)

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Erasing_Type,
		Uses: composer.Type_Flow,
	}
}

const Erasing_Type = "erasing"
const Erasing_Field_Count = "$COUNT"
const Erasing_Field_From = "$FROM"
const Erasing_Field_AtIndex = "$AT_INDEX"
const Erasing_Field_As = "$AS"
const Erasing_Field_Do = "$DO"

func (op *Erasing) Marshal(m jsn.Marshaler) error {
	return Erasing_Marshal(m, op)
}

type Erasing_Slice []Erasing

func (op *Erasing_Slice) GetType() string { return Erasing_Type }

func (op *Erasing_Slice) Marshal(m jsn.Marshaler) error {
	return Erasing_Repeats_Marshal(m, (*[]Erasing)(op))
}

func (op *Erasing_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Erasing_Slice) SetSize(cnt int) {
	var els []Erasing
	if cnt >= 0 {
		els = make(Erasing_Slice, cnt)
	}
	(*op) = els
}

func (op *Erasing_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Erasing_Marshal(m, &(*op)[i])
}

func Erasing_Repeats_Marshal(m jsn.Marshaler, vals *[]Erasing) error {
	return jsn.RepeatBlock(m, (*Erasing_Slice)(vals))
}

func Erasing_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Erasing) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = Erasing_Repeats_Marshal(m, pv)
	}
	return
}

type Erasing_Flow struct{ ptr *Erasing }

func (n Erasing_Flow) GetType() string      { return Erasing_Type }
func (n Erasing_Flow) GetLede() string      { return Erasing_Type }
func (n Erasing_Flow) GetFlow() interface{} { return n.ptr }
func (n Erasing_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Erasing); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Erasing_Optional_Marshal(m jsn.Marshaler, pv **Erasing) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Erasing_Marshal(m, *pv)
	} else if !enc {
		var v Erasing
		if err = Erasing_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Erasing_Marshal(m jsn.Marshaler, val *Erasing) (err error) {
	if err = m.MarshalBlock(Erasing_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Erasing_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Erasing_Field_Count))
		}
		e1 := m.MarshalKey("from", Erasing_Field_From)
		if e1 == nil {
			e1 = ListSource_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Erasing_Field_From))
		}
		e2 := m.MarshalKey("at_index", Erasing_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Erasing_Field_AtIndex))
		}
		e3 := m.MarshalKey("as", Erasing_Field_As)
		if e3 == nil {
			e3 = literal.Text_Unboxed_Marshal(m, &val.As)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", Erasing_Field_As))
		}
		e4 := m.MarshalKey("do", Erasing_Field_Do)
		if e4 == nil {
			e4 = core.Activity_Marshal(m, &val.Do)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", Erasing_Field_Do))
		}
		m.EndBlock()
	}
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From   ListSource    `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Do     core.Activity `if:"label=do"`
	Else   core.Brancher `if:"label=else,optional"`
}

// User implemented slots:
var _ rt.Execute = (*ErasingEdge)(nil)

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: ErasingEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const ErasingEdge_Type = "erasing_edge"
const ErasingEdge_Field_From = "$FROM"
const ErasingEdge_Field_AtEdge = "$AT_EDGE"
const ErasingEdge_Field_As = "$AS"
const ErasingEdge_Field_Do = "$DO"
const ErasingEdge_Field_Else = "$ELSE"

func (op *ErasingEdge) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Marshal(m, op)
}

type ErasingEdge_Slice []ErasingEdge

func (op *ErasingEdge_Slice) GetType() string { return ErasingEdge_Type }

func (op *ErasingEdge_Slice) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Repeats_Marshal(m, (*[]ErasingEdge)(op))
}

func (op *ErasingEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ErasingEdge_Slice) SetSize(cnt int) {
	var els []ErasingEdge
	if cnt >= 0 {
		els = make(ErasingEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *ErasingEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ErasingEdge_Marshal(m, &(*op)[i])
}

func ErasingEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]ErasingEdge) error {
	return jsn.RepeatBlock(m, (*ErasingEdge_Slice)(vals))
}

func ErasingEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ErasingEdge) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ErasingEdge_Repeats_Marshal(m, pv)
	}
	return
}

type ErasingEdge_Flow struct{ ptr *ErasingEdge }

func (n ErasingEdge_Flow) GetType() string      { return ErasingEdge_Type }
func (n ErasingEdge_Flow) GetLede() string      { return "erasing" }
func (n ErasingEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n ErasingEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ErasingEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ErasingEdge_Optional_Marshal(m jsn.Marshaler, pv **ErasingEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ErasingEdge_Marshal(m, *pv)
	} else if !enc {
		var v ErasingEdge
		if err = ErasingEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ErasingEdge_Marshal(m jsn.Marshaler, val *ErasingEdge) (err error) {
	if err = m.MarshalBlock(ErasingEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ErasingEdge_Field_From)
		if e0 == nil {
			e0 = ListSource_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ErasingEdge_Field_From))
		}
		e1 := m.MarshalKey("at_front", ErasingEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ErasingEdge_Field_AtEdge))
		}
		e2 := m.MarshalKey("as", ErasingEdge_Field_As)
		if e2 == nil {
			e2 = literal.Text_Unboxed_Marshal(m, &val.As)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ErasingEdge_Field_As))
		}
		e3 := m.MarshalKey("do", ErasingEdge_Field_Do)
		if e3 == nil {
			e3 = core.Activity_Marshal(m, &val.Do)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ErasingEdge_Field_Do))
		}
		e4 := m.MarshalKey("else", ErasingEdge_Field_Else)
		if e4 == nil {
			e4 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", ErasingEdge_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// FromNumList Uses a list of numbers
type FromNumList struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListSource = (*FromNumList)(nil)

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_nums",
	}
}

const FromNumList_Type = "from_num_list"
const FromNumList_Field_Var = "$VAR"

func (op *FromNumList) Marshal(m jsn.Marshaler) error {
	return FromNumList_Marshal(m, op)
}

type FromNumList_Slice []FromNumList

func (op *FromNumList_Slice) GetType() string { return FromNumList_Type }

func (op *FromNumList_Slice) Marshal(m jsn.Marshaler) error {
	return FromNumList_Repeats_Marshal(m, (*[]FromNumList)(op))
}

func (op *FromNumList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *FromNumList_Slice) SetSize(cnt int) {
	var els []FromNumList
	if cnt >= 0 {
		els = make(FromNumList_Slice, cnt)
	}
	(*op) = els
}

func (op *FromNumList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return FromNumList_Marshal(m, &(*op)[i])
}

func FromNumList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromNumList) error {
	return jsn.RepeatBlock(m, (*FromNumList_Slice)(vals))
}

func FromNumList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]FromNumList) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = FromNumList_Repeats_Marshal(m, pv)
	}
	return
}

type FromNumList_Flow struct{ ptr *FromNumList }

func (n FromNumList_Flow) GetType() string      { return FromNumList_Type }
func (n FromNumList_Flow) GetLede() string      { return "var_of_nums" }
func (n FromNumList_Flow) GetFlow() interface{} { return n.ptr }
func (n FromNumList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*FromNumList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func FromNumList_Optional_Marshal(m jsn.Marshaler, pv **FromNumList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromNumList_Marshal(m, *pv)
	} else if !enc {
		var v FromNumList
		if err = FromNumList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromNumList_Marshal(m jsn.Marshaler, val *FromNumList) (err error) {
	if err = m.MarshalBlock(FromNumList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", FromNumList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromNumList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// FromRecList Uses a list of records
type FromRecList struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListSource = (*FromRecList)(nil)

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_recs",
	}
}

const FromRecList_Type = "from_rec_list"
const FromRecList_Field_Var = "$VAR"

func (op *FromRecList) Marshal(m jsn.Marshaler) error {
	return FromRecList_Marshal(m, op)
}

type FromRecList_Slice []FromRecList

func (op *FromRecList_Slice) GetType() string { return FromRecList_Type }

func (op *FromRecList_Slice) Marshal(m jsn.Marshaler) error {
	return FromRecList_Repeats_Marshal(m, (*[]FromRecList)(op))
}

func (op *FromRecList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *FromRecList_Slice) SetSize(cnt int) {
	var els []FromRecList
	if cnt >= 0 {
		els = make(FromRecList_Slice, cnt)
	}
	(*op) = els
}

func (op *FromRecList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return FromRecList_Marshal(m, &(*op)[i])
}

func FromRecList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromRecList) error {
	return jsn.RepeatBlock(m, (*FromRecList_Slice)(vals))
}

func FromRecList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]FromRecList) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = FromRecList_Repeats_Marshal(m, pv)
	}
	return
}

type FromRecList_Flow struct{ ptr *FromRecList }

func (n FromRecList_Flow) GetType() string      { return FromRecList_Type }
func (n FromRecList_Flow) GetLede() string      { return "var_of_recs" }
func (n FromRecList_Flow) GetFlow() interface{} { return n.ptr }
func (n FromRecList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*FromRecList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func FromRecList_Optional_Marshal(m jsn.Marshaler, pv **FromRecList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromRecList_Marshal(m, *pv)
	} else if !enc {
		var v FromRecList
		if err = FromRecList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromRecList_Marshal(m jsn.Marshaler, val *FromRecList) (err error) {
	if err = m.MarshalBlock(FromRecList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", FromRecList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromRecList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// FromTxtList Uses a list of text
type FromTxtList struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListSource = (*FromTxtList)(nil)

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_txts",
	}
}

const FromTxtList_Type = "from_txt_list"
const FromTxtList_Field_Var = "$VAR"

func (op *FromTxtList) Marshal(m jsn.Marshaler) error {
	return FromTxtList_Marshal(m, op)
}

type FromTxtList_Slice []FromTxtList

func (op *FromTxtList_Slice) GetType() string { return FromTxtList_Type }

func (op *FromTxtList_Slice) Marshal(m jsn.Marshaler) error {
	return FromTxtList_Repeats_Marshal(m, (*[]FromTxtList)(op))
}

func (op *FromTxtList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *FromTxtList_Slice) SetSize(cnt int) {
	var els []FromTxtList
	if cnt >= 0 {
		els = make(FromTxtList_Slice, cnt)
	}
	(*op) = els
}

func (op *FromTxtList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return FromTxtList_Marshal(m, &(*op)[i])
}

func FromTxtList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromTxtList) error {
	return jsn.RepeatBlock(m, (*FromTxtList_Slice)(vals))
}

func FromTxtList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]FromTxtList) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = FromTxtList_Repeats_Marshal(m, pv)
	}
	return
}

type FromTxtList_Flow struct{ ptr *FromTxtList }

func (n FromTxtList_Flow) GetType() string      { return FromTxtList_Type }
func (n FromTxtList_Flow) GetLede() string      { return "var_of_txts" }
func (n FromTxtList_Flow) GetFlow() interface{} { return n.ptr }
func (n FromTxtList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*FromTxtList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func FromTxtList_Optional_Marshal(m jsn.Marshaler, pv **FromTxtList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromTxtList_Marshal(m, *pv)
	} else if !enc {
		var v FromTxtList
		if err = FromTxtList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromTxtList_Marshal(m jsn.Marshaler, val *FromTxtList) (err error) {
	if err = m.MarshalBlock(FromTxtList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", FromTxtList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromTxtList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoNumList Targets a list of numbers
type IntoNumList struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListTarget = (*IntoNumList)(nil)

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_nums",
	}
}

const IntoNumList_Type = "into_num_list"
const IntoNumList_Field_Var = "$VAR"

func (op *IntoNumList) Marshal(m jsn.Marshaler) error {
	return IntoNumList_Marshal(m, op)
}

type IntoNumList_Slice []IntoNumList

func (op *IntoNumList_Slice) GetType() string { return IntoNumList_Type }

func (op *IntoNumList_Slice) Marshal(m jsn.Marshaler) error {
	return IntoNumList_Repeats_Marshal(m, (*[]IntoNumList)(op))
}

func (op *IntoNumList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *IntoNumList_Slice) SetSize(cnt int) {
	var els []IntoNumList
	if cnt >= 0 {
		els = make(IntoNumList_Slice, cnt)
	}
	(*op) = els
}

func (op *IntoNumList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return IntoNumList_Marshal(m, &(*op)[i])
}

func IntoNumList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoNumList) error {
	return jsn.RepeatBlock(m, (*IntoNumList_Slice)(vals))
}

func IntoNumList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]IntoNumList) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = IntoNumList_Repeats_Marshal(m, pv)
	}
	return
}

type IntoNumList_Flow struct{ ptr *IntoNumList }

func (n IntoNumList_Flow) GetType() string      { return IntoNumList_Type }
func (n IntoNumList_Flow) GetLede() string      { return "into_nums" }
func (n IntoNumList_Flow) GetFlow() interface{} { return n.ptr }
func (n IntoNumList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*IntoNumList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func IntoNumList_Optional_Marshal(m jsn.Marshaler, pv **IntoNumList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoNumList_Marshal(m, *pv)
	} else if !enc {
		var v IntoNumList
		if err = IntoNumList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoNumList_Marshal(m jsn.Marshaler, val *IntoNumList) (err error) {
	if err = m.MarshalBlock(IntoNumList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", IntoNumList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoNumList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoRecList Targets a list of records
type IntoRecList struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListTarget = (*IntoRecList)(nil)

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_recs",
	}
}

const IntoRecList_Type = "into_rec_list"
const IntoRecList_Field_Var = "$VAR"

func (op *IntoRecList) Marshal(m jsn.Marshaler) error {
	return IntoRecList_Marshal(m, op)
}

type IntoRecList_Slice []IntoRecList

func (op *IntoRecList_Slice) GetType() string { return IntoRecList_Type }

func (op *IntoRecList_Slice) Marshal(m jsn.Marshaler) error {
	return IntoRecList_Repeats_Marshal(m, (*[]IntoRecList)(op))
}

func (op *IntoRecList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *IntoRecList_Slice) SetSize(cnt int) {
	var els []IntoRecList
	if cnt >= 0 {
		els = make(IntoRecList_Slice, cnt)
	}
	(*op) = els
}

func (op *IntoRecList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return IntoRecList_Marshal(m, &(*op)[i])
}

func IntoRecList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoRecList) error {
	return jsn.RepeatBlock(m, (*IntoRecList_Slice)(vals))
}

func IntoRecList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]IntoRecList) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = IntoRecList_Repeats_Marshal(m, pv)
	}
	return
}

type IntoRecList_Flow struct{ ptr *IntoRecList }

func (n IntoRecList_Flow) GetType() string      { return IntoRecList_Type }
func (n IntoRecList_Flow) GetLede() string      { return "into_recs" }
func (n IntoRecList_Flow) GetFlow() interface{} { return n.ptr }
func (n IntoRecList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*IntoRecList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func IntoRecList_Optional_Marshal(m jsn.Marshaler, pv **IntoRecList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoRecList_Marshal(m, *pv)
	} else if !enc {
		var v IntoRecList
		if err = IntoRecList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoRecList_Marshal(m jsn.Marshaler, val *IntoRecList) (err error) {
	if err = m.MarshalBlock(IntoRecList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", IntoRecList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoRecList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoTxtList Targets a list of text
type IntoTxtList struct {
	Var core.VariableName `if:"label=_"`
}

// User implemented slots:
var _ ListTarget = (*IntoTxtList)(nil)

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_txts",
	}
}

const IntoTxtList_Type = "into_txt_list"
const IntoTxtList_Field_Var = "$VAR"

func (op *IntoTxtList) Marshal(m jsn.Marshaler) error {
	return IntoTxtList_Marshal(m, op)
}

type IntoTxtList_Slice []IntoTxtList

func (op *IntoTxtList_Slice) GetType() string { return IntoTxtList_Type }

func (op *IntoTxtList_Slice) Marshal(m jsn.Marshaler) error {
	return IntoTxtList_Repeats_Marshal(m, (*[]IntoTxtList)(op))
}

func (op *IntoTxtList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *IntoTxtList_Slice) SetSize(cnt int) {
	var els []IntoTxtList
	if cnt >= 0 {
		els = make(IntoTxtList_Slice, cnt)
	}
	(*op) = els
}

func (op *IntoTxtList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return IntoTxtList_Marshal(m, &(*op)[i])
}

func IntoTxtList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoTxtList) error {
	return jsn.RepeatBlock(m, (*IntoTxtList_Slice)(vals))
}

func IntoTxtList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]IntoTxtList) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = IntoTxtList_Repeats_Marshal(m, pv)
	}
	return
}

type IntoTxtList_Flow struct{ ptr *IntoTxtList }

func (n IntoTxtList_Flow) GetType() string      { return IntoTxtList_Type }
func (n IntoTxtList_Flow) GetLede() string      { return "into_txts" }
func (n IntoTxtList_Flow) GetFlow() interface{} { return n.ptr }
func (n IntoTxtList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*IntoTxtList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func IntoTxtList_Optional_Marshal(m jsn.Marshaler, pv **IntoTxtList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoTxtList_Marshal(m, *pv)
	} else if !enc {
		var v IntoTxtList
		if err = IntoTxtList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoTxtList_Marshal(m jsn.Marshaler, val *IntoTxtList) (err error) {
	if err = m.MarshalBlock(IntoTxtList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", IntoTxtList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoTxtList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// ListAt Get a value from a list. The first element is is index 1.
type ListAt struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

// User implemented slots:
var _ rt.NumberEval = (*ListAt)(nil)
var _ rt.TextEval = (*ListAt)(nil)
var _ rt.RecordEval = (*ListAt)(nil)

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: ListAt_Type,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const ListAt_Type = "list_at"
const ListAt_Field_List = "$LIST"
const ListAt_Field_Index = "$INDEX"

func (op *ListAt) Marshal(m jsn.Marshaler) error {
	return ListAt_Marshal(m, op)
}

type ListAt_Slice []ListAt

func (op *ListAt_Slice) GetType() string { return ListAt_Type }

func (op *ListAt_Slice) Marshal(m jsn.Marshaler) error {
	return ListAt_Repeats_Marshal(m, (*[]ListAt)(op))
}

func (op *ListAt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListAt_Slice) SetSize(cnt int) {
	var els []ListAt
	if cnt >= 0 {
		els = make(ListAt_Slice, cnt)
	}
	(*op) = els
}

func (op *ListAt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListAt_Marshal(m, &(*op)[i])
}

func ListAt_Repeats_Marshal(m jsn.Marshaler, vals *[]ListAt) error {
	return jsn.RepeatBlock(m, (*ListAt_Slice)(vals))
}

func ListAt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListAt) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListAt_Repeats_Marshal(m, pv)
	}
	return
}

type ListAt_Flow struct{ ptr *ListAt }

func (n ListAt_Flow) GetType() string      { return ListAt_Type }
func (n ListAt_Flow) GetLede() string      { return "get" }
func (n ListAt_Flow) GetFlow() interface{} { return n.ptr }
func (n ListAt_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListAt); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListAt_Optional_Marshal(m jsn.Marshaler, pv **ListAt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListAt_Marshal(m, *pv)
	} else if !enc {
		var v ListAt
		if err = ListAt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListAt_Marshal(m jsn.Marshaler, val *ListAt) (err error) {
	if err = m.MarshalBlock(ListAt_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListAt_Field_List)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListAt_Field_List))
		}
		e1 := m.MarshalKey("index", ListAt_Field_Index)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Index)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListAt_Field_Index))
		}
		m.EndBlock()
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the 'else' activity if empty.
type ListEach struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

// User implemented slots:
var _ rt.Execute = (*ListEach)(nil)

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: ListEach_Type,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const ListEach_Type = "list_each"
const ListEach_Field_List = "$LIST"
const ListEach_Field_As = "$AS"
const ListEach_Field_Do = "$DO"
const ListEach_Field_Else = "$ELSE"

func (op *ListEach) Marshal(m jsn.Marshaler) error {
	return ListEach_Marshal(m, op)
}

type ListEach_Slice []ListEach

func (op *ListEach_Slice) GetType() string { return ListEach_Type }

func (op *ListEach_Slice) Marshal(m jsn.Marshaler) error {
	return ListEach_Repeats_Marshal(m, (*[]ListEach)(op))
}

func (op *ListEach_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListEach_Slice) SetSize(cnt int) {
	var els []ListEach
	if cnt >= 0 {
		els = make(ListEach_Slice, cnt)
	}
	(*op) = els
}

func (op *ListEach_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListEach_Marshal(m, &(*op)[i])
}

func ListEach_Repeats_Marshal(m jsn.Marshaler, vals *[]ListEach) error {
	return jsn.RepeatBlock(m, (*ListEach_Slice)(vals))
}

func ListEach_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListEach) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListEach_Repeats_Marshal(m, pv)
	}
	return
}

type ListEach_Flow struct{ ptr *ListEach }

func (n ListEach_Flow) GetType() string      { return ListEach_Type }
func (n ListEach_Flow) GetLede() string      { return "repeating" }
func (n ListEach_Flow) GetFlow() interface{} { return n.ptr }
func (n ListEach_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListEach); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListEach_Optional_Marshal(m jsn.Marshaler, pv **ListEach) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListEach_Marshal(m, *pv)
	} else if !enc {
		var v ListEach
		if err = ListEach_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListEach_Marshal(m jsn.Marshaler, val *ListEach) (err error) {
	if err = m.MarshalBlock(ListEach_Flow{val}); err == nil {
		e0 := m.MarshalKey("across", ListEach_Field_List)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListEach_Field_List))
		}
		e1 := m.MarshalKey("as", ListEach_Field_As)
		if e1 == nil {
			e1 = ListIterator_Marshal(m, &val.As)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListEach_Field_As))
		}
		e2 := m.MarshalKey("do", ListEach_Field_Do)
		if e2 == nil {
			e2 = core.Activity_Marshal(m, &val.Do)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListEach_Field_Do))
		}
		e3 := m.MarshalKey("else", ListEach_Field_Else)
		if e3 == nil {
			e3 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListEach_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

// User implemented slots:
var _ rt.BoolEval = (*ListFind)(nil)
var _ rt.NumberEval = (*ListFind)(nil)

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFind_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFind_Type = "list_find"
const ListFind_Field_Value = "$VALUE"
const ListFind_Field_List = "$LIST"

func (op *ListFind) Marshal(m jsn.Marshaler) error {
	return ListFind_Marshal(m, op)
}

type ListFind_Slice []ListFind

func (op *ListFind_Slice) GetType() string { return ListFind_Type }

func (op *ListFind_Slice) Marshal(m jsn.Marshaler) error {
	return ListFind_Repeats_Marshal(m, (*[]ListFind)(op))
}

func (op *ListFind_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListFind_Slice) SetSize(cnt int) {
	var els []ListFind
	if cnt >= 0 {
		els = make(ListFind_Slice, cnt)
	}
	(*op) = els
}

func (op *ListFind_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListFind_Marshal(m, &(*op)[i])
}

func ListFind_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFind) error {
	return jsn.RepeatBlock(m, (*ListFind_Slice)(vals))
}

func ListFind_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListFind) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListFind_Repeats_Marshal(m, pv)
	}
	return
}

type ListFind_Flow struct{ ptr *ListFind }

func (n ListFind_Flow) GetType() string      { return ListFind_Type }
func (n ListFind_Flow) GetLede() string      { return "find" }
func (n ListFind_Flow) GetFlow() interface{} { return n.ptr }
func (n ListFind_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListFind); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListFind_Optional_Marshal(m jsn.Marshaler, pv **ListFind) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFind_Marshal(m, *pv)
	} else if !enc {
		var v ListFind
		if err = ListFind_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFind_Marshal(m jsn.Marshaler, val *ListFind) (err error) {
	if err = m.MarshalBlock(ListFind_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListFind_Field_Value)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.Value)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFind_Field_Value))
		}
		e1 := m.MarshalKey("list", ListFind_Field_List)
		if e1 == nil {
			e1 = rt.Assignment_Marshal(m, &val.List)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFind_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListGather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: 'in' as each value from the list, and 'out' as the var passed to the gather.
type ListGather struct {
	Var   core.VariableName `if:"label=_"`
	From  ListSource        `if:"label=from"`
	Using string            `if:"label=using,type=text"`
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: ListGather_Type,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const ListGather_Type = "list_gather"
const ListGather_Field_Var = "$VAR"
const ListGather_Field_From = "$FROM"
const ListGather_Field_Using = "$USING"

func (op *ListGather) Marshal(m jsn.Marshaler) error {
	return ListGather_Marshal(m, op)
}

type ListGather_Slice []ListGather

func (op *ListGather_Slice) GetType() string { return ListGather_Type }

func (op *ListGather_Slice) Marshal(m jsn.Marshaler) error {
	return ListGather_Repeats_Marshal(m, (*[]ListGather)(op))
}

func (op *ListGather_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListGather_Slice) SetSize(cnt int) {
	var els []ListGather
	if cnt >= 0 {
		els = make(ListGather_Slice, cnt)
	}
	(*op) = els
}

func (op *ListGather_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListGather_Marshal(m, &(*op)[i])
}

func ListGather_Repeats_Marshal(m jsn.Marshaler, vals *[]ListGather) error {
	return jsn.RepeatBlock(m, (*ListGather_Slice)(vals))
}

func ListGather_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListGather) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListGather_Repeats_Marshal(m, pv)
	}
	return
}

type ListGather_Flow struct{ ptr *ListGather }

func (n ListGather_Flow) GetType() string      { return ListGather_Type }
func (n ListGather_Flow) GetLede() string      { return "gather" }
func (n ListGather_Flow) GetFlow() interface{} { return n.ptr }
func (n ListGather_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListGather); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListGather_Optional_Marshal(m jsn.Marshaler, pv **ListGather) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListGather_Marshal(m, *pv)
	} else if !enc {
		var v ListGather
		if err = ListGather_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListGather_Marshal(m jsn.Marshaler, val *ListGather) (err error) {
	if err = m.MarshalBlock(ListGather_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListGather_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListGather_Field_Var))
		}
		e1 := m.MarshalKey("from", ListGather_Field_From)
		if e1 == nil {
			e1 = ListSource_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListGather_Field_From))
		}
		e2 := m.MarshalKey("using", ListGather_Field_Using)
		if e2 == nil {
			e2 = literal.Text_Unboxed_Marshal(m, &val.Using)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListGather_Field_Using))
		}
		m.EndBlock()
	}
	return
}

const ListIterator_Type = "list_iterator"

var ListIterator_Optional_Marshal = ListIterator_Marshal

type ListIterator_Slot struct{ Value *ListIterator }

func (at ListIterator_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at ListIterator_Slot) GetType() string              { return ListIterator_Type }
func (at ListIterator_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at ListIterator_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(ListIterator)
	return
}

func ListIterator_Marshal(m jsn.Marshaler, ptr *ListIterator) (err error) {
	slot := ListIterator_Slot{ptr}
	return slot.Marshal(m)
}

type ListIterator_Slice []ListIterator

func (op *ListIterator_Slice) GetType() string { return ListIterator_Type }

func (op *ListIterator_Slice) Marshal(m jsn.Marshaler) error {
	return ListIterator_Repeats_Marshal(m, (*[]ListIterator)(op))
}

func (op *ListIterator_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListIterator_Slice) SetSize(cnt int) {
	var els []ListIterator
	if cnt >= 0 {
		els = make(ListIterator_Slice, cnt)
	}
	(*op) = els
}

func (op *ListIterator_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListIterator_Marshal(m, &(*op)[i])
}

func ListIterator_Repeats_Marshal(m jsn.Marshaler, vals *[]ListIterator) error {
	return jsn.RepeatBlock(m, (*ListIterator_Slice)(vals))
}

func ListIterator_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListIterator) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListIterator_Repeats_Marshal(m, pv)
	}
	return
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List rt.Assignment `if:"label=_"`
}

// User implemented slots:
var _ rt.NumberEval = (*ListLen)(nil)

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: ListLen_Type,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const ListLen_Type = "list_len"
const ListLen_Field_List = "$LIST"

func (op *ListLen) Marshal(m jsn.Marshaler) error {
	return ListLen_Marshal(m, op)
}

type ListLen_Slice []ListLen

func (op *ListLen_Slice) GetType() string { return ListLen_Type }

func (op *ListLen_Slice) Marshal(m jsn.Marshaler) error {
	return ListLen_Repeats_Marshal(m, (*[]ListLen)(op))
}

func (op *ListLen_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListLen_Slice) SetSize(cnt int) {
	var els []ListLen
	if cnt >= 0 {
		els = make(ListLen_Slice, cnt)
	}
	(*op) = els
}

func (op *ListLen_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListLen_Marshal(m, &(*op)[i])
}

func ListLen_Repeats_Marshal(m jsn.Marshaler, vals *[]ListLen) error {
	return jsn.RepeatBlock(m, (*ListLen_Slice)(vals))
}

func ListLen_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListLen) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListLen_Repeats_Marshal(m, pv)
	}
	return
}

type ListLen_Flow struct{ ptr *ListLen }

func (n ListLen_Flow) GetType() string      { return ListLen_Type }
func (n ListLen_Flow) GetLede() string      { return "len" }
func (n ListLen_Flow) GetFlow() interface{} { return n.ptr }
func (n ListLen_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListLen); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListLen_Optional_Marshal(m jsn.Marshaler, pv **ListLen) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListLen_Marshal(m, *pv)
	} else if !enc {
		var v ListLen
		if err = ListLen_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListLen_Marshal(m jsn.Marshaler, val *ListLen) (err error) {
	if err = m.MarshalBlock(ListLen_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListLen_Field_List)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListLen_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListMap Transform the values from one list and place the results in another list. The designated pattern is called with each value from the 'from list', one value at a time.
type ListMap struct {
	ToList       string        `if:"label=_,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

// User implemented slots:
var _ rt.Execute = (*ListMap)(nil)

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: ListMap_Type,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const ListMap_Type = "list_map"
const ListMap_Field_ToList = "$TO_LIST"
const ListMap_Field_FromList = "$FROM_LIST"
const ListMap_Field_UsingPattern = "$USING_PATTERN"

func (op *ListMap) Marshal(m jsn.Marshaler) error {
	return ListMap_Marshal(m, op)
}

type ListMap_Slice []ListMap

func (op *ListMap_Slice) GetType() string { return ListMap_Type }

func (op *ListMap_Slice) Marshal(m jsn.Marshaler) error {
	return ListMap_Repeats_Marshal(m, (*[]ListMap)(op))
}

func (op *ListMap_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListMap_Slice) SetSize(cnt int) {
	var els []ListMap
	if cnt >= 0 {
		els = make(ListMap_Slice, cnt)
	}
	(*op) = els
}

func (op *ListMap_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListMap_Marshal(m, &(*op)[i])
}

func ListMap_Repeats_Marshal(m jsn.Marshaler, vals *[]ListMap) error {
	return jsn.RepeatBlock(m, (*ListMap_Slice)(vals))
}

func ListMap_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListMap) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListMap_Repeats_Marshal(m, pv)
	}
	return
}

type ListMap_Flow struct{ ptr *ListMap }

func (n ListMap_Flow) GetType() string      { return ListMap_Type }
func (n ListMap_Flow) GetLede() string      { return "map" }
func (n ListMap_Flow) GetFlow() interface{} { return n.ptr }
func (n ListMap_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListMap); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListMap_Optional_Marshal(m jsn.Marshaler, pv **ListMap) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListMap_Marshal(m, *pv)
	} else if !enc {
		var v ListMap
		if err = ListMap_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListMap_Marshal(m jsn.Marshaler, val *ListMap) (err error) {
	if err = m.MarshalBlock(ListMap_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListMap_Field_ToList)
		if e0 == nil {
			e0 = literal.Text_Unboxed_Marshal(m, &val.ToList)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListMap_Field_ToList))
		}
		e1 := m.MarshalKey("from_list", ListMap_Field_FromList)
		if e1 == nil {
			e1 = rt.Assignment_Marshal(m, &val.FromList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListMap_Field_FromList))
		}
		e2 := m.MarshalKey("using", ListMap_Field_UsingPattern)
		if e2 == nil {
			e2 = literal.Text_Unboxed_Marshal(m, &val.UsingPattern)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListMap_Field_UsingPattern))
		}
		m.EndBlock()
	}
	return
}

// ListReduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: 'in' ( each element of the list ) and 'out' ( ex. a record ).
type ListReduce struct {
	IntoValue    string        `if:"label=into,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

// User implemented slots:
var _ rt.Execute = (*ListReduce)(nil)

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReduce_Type,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const ListReduce_Type = "list_reduce"
const ListReduce_Field_IntoValue = "$INTO_VALUE"
const ListReduce_Field_FromList = "$FROM_LIST"
const ListReduce_Field_UsingPattern = "$USING_PATTERN"

func (op *ListReduce) Marshal(m jsn.Marshaler) error {
	return ListReduce_Marshal(m, op)
}

type ListReduce_Slice []ListReduce

func (op *ListReduce_Slice) GetType() string { return ListReduce_Type }

func (op *ListReduce_Slice) Marshal(m jsn.Marshaler) error {
	return ListReduce_Repeats_Marshal(m, (*[]ListReduce)(op))
}

func (op *ListReduce_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListReduce_Slice) SetSize(cnt int) {
	var els []ListReduce
	if cnt >= 0 {
		els = make(ListReduce_Slice, cnt)
	}
	(*op) = els
}

func (op *ListReduce_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListReduce_Marshal(m, &(*op)[i])
}

func ListReduce_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReduce) error {
	return jsn.RepeatBlock(m, (*ListReduce_Slice)(vals))
}

func ListReduce_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListReduce) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListReduce_Repeats_Marshal(m, pv)
	}
	return
}

type ListReduce_Flow struct{ ptr *ListReduce }

func (n ListReduce_Flow) GetType() string      { return ListReduce_Type }
func (n ListReduce_Flow) GetLede() string      { return "reduce" }
func (n ListReduce_Flow) GetFlow() interface{} { return n.ptr }
func (n ListReduce_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListReduce); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListReduce_Optional_Marshal(m jsn.Marshaler, pv **ListReduce) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReduce_Marshal(m, *pv)
	} else if !enc {
		var v ListReduce
		if err = ListReduce_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReduce_Marshal(m jsn.Marshaler, val *ListReduce) (err error) {
	if err = m.MarshalBlock(ListReduce_Flow{val}); err == nil {
		e0 := m.MarshalKey("into", ListReduce_Field_IntoValue)
		if e0 == nil {
			e0 = literal.Text_Unboxed_Marshal(m, &val.IntoValue)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReduce_Field_IntoValue))
		}
		e1 := m.MarshalKey("from_list", ListReduce_Field_FromList)
		if e1 == nil {
			e1 = rt.Assignment_Marshal(m, &val.FromList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListReduce_Field_FromList))
		}
		e2 := m.MarshalKey("using", ListReduce_Field_UsingPattern)
		if e2 == nil {
			e2 = literal.Text_Unboxed_Marshal(m, &val.UsingPattern)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListReduce_Field_UsingPattern))
		}
		m.EndBlock()
	}
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	List ListSource `if:"label=list"`
}

// User implemented slots:
var _ rt.Execute = (*ListReverse)(nil)

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReverse_Type,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const ListReverse_Type = "list_reverse"
const ListReverse_Field_List = "$LIST"

func (op *ListReverse) Marshal(m jsn.Marshaler) error {
	return ListReverse_Marshal(m, op)
}

type ListReverse_Slice []ListReverse

func (op *ListReverse_Slice) GetType() string { return ListReverse_Type }

func (op *ListReverse_Slice) Marshal(m jsn.Marshaler) error {
	return ListReverse_Repeats_Marshal(m, (*[]ListReverse)(op))
}

func (op *ListReverse_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListReverse_Slice) SetSize(cnt int) {
	var els []ListReverse
	if cnt >= 0 {
		els = make(ListReverse_Slice, cnt)
	}
	(*op) = els
}

func (op *ListReverse_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListReverse_Marshal(m, &(*op)[i])
}

func ListReverse_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReverse) error {
	return jsn.RepeatBlock(m, (*ListReverse_Slice)(vals))
}

func ListReverse_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListReverse) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListReverse_Repeats_Marshal(m, pv)
	}
	return
}

type ListReverse_Flow struct{ ptr *ListReverse }

func (n ListReverse_Flow) GetType() string      { return ListReverse_Type }
func (n ListReverse_Flow) GetLede() string      { return "reverse" }
func (n ListReverse_Flow) GetFlow() interface{} { return n.ptr }
func (n ListReverse_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListReverse); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListReverse_Optional_Marshal(m jsn.Marshaler, pv **ListReverse) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReverse_Marshal(m, *pv)
	} else if !enc {
		var v ListReverse
		if err = ListReverse_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReverse_Marshal(m jsn.Marshaler, val *ListReverse) (err error) {
	if err = m.MarshalBlock(ListReverse_Flow{val}); err == nil {
		e0 := m.MarshalKey("list", ListReverse_Field_List)
		if e0 == nil {
			e0 = ListSource_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReverse_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListSet Overwrite an existing value in a list.
type ListSet struct {
	List  string        `if:"label=_,type=text"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

// User implemented slots:
var _ rt.Execute = (*ListSet)(nil)

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSet_Type,
		Uses: composer.Type_Flow,
		Lede: "set",
	}
}

const ListSet_Type = "list_set"
const ListSet_Field_List = "$LIST"
const ListSet_Field_Index = "$INDEX"
const ListSet_Field_From = "$FROM"

func (op *ListSet) Marshal(m jsn.Marshaler) error {
	return ListSet_Marshal(m, op)
}

type ListSet_Slice []ListSet

func (op *ListSet_Slice) GetType() string { return ListSet_Type }

func (op *ListSet_Slice) Marshal(m jsn.Marshaler) error {
	return ListSet_Repeats_Marshal(m, (*[]ListSet)(op))
}

func (op *ListSet_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSet_Slice) SetSize(cnt int) {
	var els []ListSet
	if cnt >= 0 {
		els = make(ListSet_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSet_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSet_Marshal(m, &(*op)[i])
}

func ListSet_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSet) error {
	return jsn.RepeatBlock(m, (*ListSet_Slice)(vals))
}

func ListSet_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSet) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListSet_Repeats_Marshal(m, pv)
	}
	return
}

type ListSet_Flow struct{ ptr *ListSet }

func (n ListSet_Flow) GetType() string      { return ListSet_Type }
func (n ListSet_Flow) GetLede() string      { return "set" }
func (n ListSet_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSet_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSet); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSet_Optional_Marshal(m jsn.Marshaler, pv **ListSet) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSet_Marshal(m, *pv)
	} else if !enc {
		var v ListSet
		if err = ListSet_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSet_Marshal(m jsn.Marshaler, val *ListSet) (err error) {
	if err = m.MarshalBlock(ListSet_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSet_Field_List)
		if e0 == nil {
			e0 = literal.Text_Unboxed_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSet_Field_List))
		}
		e1 := m.MarshalKey("index", ListSet_Field_Index)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Index)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSet_Field_Index))
		}
		e2 := m.MarshalKey("from", ListSet_Field_From)
		if e2 == nil {
			e2 = rt.Assignment_Marshal(m, &val.From)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSet_Field_From))
		}
		m.EndBlock()
	}
	return
}

// ListSlice Create a new list from a section of another list.
// Start is optional, if omitted slice starts at the first element.
// If start is greater the length, an empty array is returned.
// Slice doesnt include the ending index.
// Negatives indices indicates an offset from the end.
// When end is omitted, copy up to and including the last element;
// and do the same if the end is greater than the length
type ListSlice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

// User implemented slots:
var _ rt.NumListEval = (*ListSlice)(nil)
var _ rt.TextListEval = (*ListSlice)(nil)
var _ rt.RecordListEval = (*ListSlice)(nil)

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSlice_Type,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const ListSlice_Type = "list_slice"
const ListSlice_Field_List = "$LIST"
const ListSlice_Field_Start = "$START"
const ListSlice_Field_End = "$END"

func (op *ListSlice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Marshal(m, op)
}

type ListSlice_Slice []ListSlice

func (op *ListSlice_Slice) GetType() string { return ListSlice_Type }

func (op *ListSlice_Slice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Repeats_Marshal(m, (*[]ListSlice)(op))
}

func (op *ListSlice_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSlice_Slice) SetSize(cnt int) {
	var els []ListSlice
	if cnt >= 0 {
		els = make(ListSlice_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSlice_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSlice_Marshal(m, &(*op)[i])
}

func ListSlice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSlice) error {
	return jsn.RepeatBlock(m, (*ListSlice_Slice)(vals))
}

func ListSlice_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSlice) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListSlice_Repeats_Marshal(m, pv)
	}
	return
}

type ListSlice_Flow struct{ ptr *ListSlice }

func (n ListSlice_Flow) GetType() string      { return ListSlice_Type }
func (n ListSlice_Flow) GetLede() string      { return "slice" }
func (n ListSlice_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSlice_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSlice); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSlice_Optional_Marshal(m jsn.Marshaler, pv **ListSlice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSlice_Marshal(m, *pv)
	} else if !enc {
		var v ListSlice
		if err = ListSlice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSlice_Marshal(m jsn.Marshaler, val *ListSlice) (err error) {
	if err = m.MarshalBlock(ListSlice_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSlice_Field_List)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSlice_Field_List))
		}
		e1 := m.MarshalKey("start", ListSlice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSlice_Field_Start))
		}
		e2 := m.MarshalKey("end", ListSlice_Field_End)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.End)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSlice_Field_End))
		}
		m.EndBlock()
	}
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Var        core.VariableName `if:"label=_"`
	ByField    string            `if:"label=by_field,type=text"`
	Descending rt.BoolEval       `if:"label=descending,optional"`
}

// User implemented slots:
var _ rt.Execute = (*ListSortNumbers)(nil)

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortNumbers_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_numbers",
	}
}

const ListSortNumbers_Type = "list_sort_numbers"
const ListSortNumbers_Field_Var = "$VAR"
const ListSortNumbers_Field_ByField = "$BY_FIELD"
const ListSortNumbers_Field_Descending = "$DESCENDING"

func (op *ListSortNumbers) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Marshal(m, op)
}

type ListSortNumbers_Slice []ListSortNumbers

func (op *ListSortNumbers_Slice) GetType() string { return ListSortNumbers_Type }

func (op *ListSortNumbers_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Repeats_Marshal(m, (*[]ListSortNumbers)(op))
}

func (op *ListSortNumbers_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortNumbers_Slice) SetSize(cnt int) {
	var els []ListSortNumbers
	if cnt >= 0 {
		els = make(ListSortNumbers_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortNumbers_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortNumbers_Marshal(m, &(*op)[i])
}

func ListSortNumbers_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortNumbers) error {
	return jsn.RepeatBlock(m, (*ListSortNumbers_Slice)(vals))
}

func ListSortNumbers_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortNumbers) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListSortNumbers_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortNumbers_Flow struct{ ptr *ListSortNumbers }

func (n ListSortNumbers_Flow) GetType() string      { return ListSortNumbers_Type }
func (n ListSortNumbers_Flow) GetLede() string      { return "sort_numbers" }
func (n ListSortNumbers_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortNumbers_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortNumbers); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortNumbers_Optional_Marshal(m jsn.Marshaler, pv **ListSortNumbers) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortNumbers_Marshal(m, *pv)
	} else if !enc {
		var v ListSortNumbers
		if err = ListSortNumbers_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortNumbers_Marshal(m jsn.Marshaler, val *ListSortNumbers) (err error) {
	if err = m.MarshalBlock(ListSortNumbers_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortNumbers_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortNumbers_Field_Var))
		}
		e1 := m.MarshalKey("by_field", ListSortNumbers_Field_ByField)
		if e1 == nil {
			e1 = literal.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortNumbers_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortNumbers_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortNumbers_Field_Descending))
		}
		m.EndBlock()
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Var        core.VariableName `if:"label=_"`
	ByField    string            `if:"label=by_field,type=text"`
	Descending rt.BoolEval       `if:"label=descending,optional"`
	UsingCase  rt.BoolEval       `if:"label=using_case,optional"`
}

// User implemented slots:
var _ rt.Execute = (*ListSortText)(nil)

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortText_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_texts",
	}
}

const ListSortText_Type = "list_sort_text"
const ListSortText_Field_Var = "$VAR"
const ListSortText_Field_ByField = "$BY_FIELD"
const ListSortText_Field_Descending = "$DESCENDING"
const ListSortText_Field_UsingCase = "$USING_CASE"

func (op *ListSortText) Marshal(m jsn.Marshaler) error {
	return ListSortText_Marshal(m, op)
}

type ListSortText_Slice []ListSortText

func (op *ListSortText_Slice) GetType() string { return ListSortText_Type }

func (op *ListSortText_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortText_Repeats_Marshal(m, (*[]ListSortText)(op))
}

func (op *ListSortText_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortText_Slice) SetSize(cnt int) {
	var els []ListSortText
	if cnt >= 0 {
		els = make(ListSortText_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortText_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortText_Marshal(m, &(*op)[i])
}

func ListSortText_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortText) error {
	return jsn.RepeatBlock(m, (*ListSortText_Slice)(vals))
}

func ListSortText_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortText) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListSortText_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortText_Flow struct{ ptr *ListSortText }

func (n ListSortText_Flow) GetType() string      { return ListSortText_Type }
func (n ListSortText_Flow) GetLede() string      { return "sort_texts" }
func (n ListSortText_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortText_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortText); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortText_Optional_Marshal(m jsn.Marshaler, pv **ListSortText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortText_Marshal(m, *pv)
	} else if !enc {
		var v ListSortText
		if err = ListSortText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortText_Marshal(m jsn.Marshaler, val *ListSortText) (err error) {
	if err = m.MarshalBlock(ListSortText_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortText_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortText_Field_Var))
		}
		e1 := m.MarshalKey("by_field", ListSortText_Field_ByField)
		if e1 == nil {
			e1 = literal.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortText_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortText_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortText_Field_Descending))
		}
		e3 := m.MarshalKey("using_case", ListSortText_Field_UsingCase)
		if e3 == nil {
			e3 = rt.BoolEval_Optional_Marshal(m, &val.UsingCase)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSortText_Field_UsingCase))
		}
		m.EndBlock()
	}
	return
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortUsing struct {
	Var   core.VariableName `if:"label=_"`
	Using string            `if:"label=using,type=text"`
}

// User implemented slots:
var _ rt.Execute = (*ListSortUsing)(nil)

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortUsing_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortUsing_Type = "list_sort_using"
const ListSortUsing_Field_Var = "$VAR"
const ListSortUsing_Field_Using = "$USING"

func (op *ListSortUsing) Marshal(m jsn.Marshaler) error {
	return ListSortUsing_Marshal(m, op)
}

type ListSortUsing_Slice []ListSortUsing

func (op *ListSortUsing_Slice) GetType() string { return ListSortUsing_Type }

func (op *ListSortUsing_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortUsing_Repeats_Marshal(m, (*[]ListSortUsing)(op))
}

func (op *ListSortUsing_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortUsing_Slice) SetSize(cnt int) {
	var els []ListSortUsing
	if cnt >= 0 {
		els = make(ListSortUsing_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortUsing_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortUsing_Marshal(m, &(*op)[i])
}

func ListSortUsing_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortUsing) error {
	return jsn.RepeatBlock(m, (*ListSortUsing_Slice)(vals))
}

func ListSortUsing_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortUsing) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListSortUsing_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortUsing_Flow struct{ ptr *ListSortUsing }

func (n ListSortUsing_Flow) GetType() string      { return ListSortUsing_Type }
func (n ListSortUsing_Flow) GetLede() string      { return "sort" }
func (n ListSortUsing_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortUsing_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortUsing); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortUsing_Optional_Marshal(m jsn.Marshaler, pv **ListSortUsing) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortUsing_Marshal(m, *pv)
	} else if !enc {
		var v ListSortUsing
		if err = ListSortUsing_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortUsing_Marshal(m jsn.Marshaler, val *ListSortUsing) (err error) {
	if err = m.MarshalBlock(ListSortUsing_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortUsing_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortUsing_Field_Var))
		}
		e1 := m.MarshalKey("using", ListSortUsing_Field_Using)
		if e1 == nil {
			e1 = literal.Text_Unboxed_Marshal(m, &val.Using)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortUsing_Field_Using))
		}
		m.EndBlock()
	}
	return
}

const ListSource_Type = "list_source"

var ListSource_Optional_Marshal = ListSource_Marshal

type ListSource_Slot struct{ Value *ListSource }

func (at ListSource_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at ListSource_Slot) GetType() string              { return ListSource_Type }
func (at ListSource_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at ListSource_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(ListSource)
	return
}

func ListSource_Marshal(m jsn.Marshaler, ptr *ListSource) (err error) {
	slot := ListSource_Slot{ptr}
	return slot.Marshal(m)
}

type ListSource_Slice []ListSource

func (op *ListSource_Slice) GetType() string { return ListSource_Type }

func (op *ListSource_Slice) Marshal(m jsn.Marshaler) error {
	return ListSource_Repeats_Marshal(m, (*[]ListSource)(op))
}

func (op *ListSource_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSource_Slice) SetSize(cnt int) {
	var els []ListSource
	if cnt >= 0 {
		els = make(ListSource_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSource_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSource_Marshal(m, &(*op)[i])
}

func ListSource_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSource) error {
	return jsn.RepeatBlock(m, (*ListSource_Slice)(vals))
}

func ListSource_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSource) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListSource_Repeats_Marshal(m, pv)
	}
	return
}

// ListSplice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list's length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
type ListSplice struct {
	List   string        `if:"label=_,type=text"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

// User implemented slots:
var _ rt.Execute = (*ListSplice)(nil)
var _ rt.NumListEval = (*ListSplice)(nil)
var _ rt.TextListEval = (*ListSplice)(nil)
var _ rt.RecordListEval = (*ListSplice)(nil)

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSplice_Type,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const ListSplice_Type = "list_splice"
const ListSplice_Field_List = "$LIST"
const ListSplice_Field_Start = "$START"
const ListSplice_Field_Remove = "$REMOVE"
const ListSplice_Field_Insert = "$INSERT"

func (op *ListSplice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Marshal(m, op)
}

type ListSplice_Slice []ListSplice

func (op *ListSplice_Slice) GetType() string { return ListSplice_Type }

func (op *ListSplice_Slice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Repeats_Marshal(m, (*[]ListSplice)(op))
}

func (op *ListSplice_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSplice_Slice) SetSize(cnt int) {
	var els []ListSplice
	if cnt >= 0 {
		els = make(ListSplice_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSplice_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSplice_Marshal(m, &(*op)[i])
}

func ListSplice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSplice) error {
	return jsn.RepeatBlock(m, (*ListSplice_Slice)(vals))
}

func ListSplice_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSplice) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListSplice_Repeats_Marshal(m, pv)
	}
	return
}

type ListSplice_Flow struct{ ptr *ListSplice }

func (n ListSplice_Flow) GetType() string      { return ListSplice_Type }
func (n ListSplice_Flow) GetLede() string      { return "splice" }
func (n ListSplice_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSplice_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSplice); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSplice_Optional_Marshal(m jsn.Marshaler, pv **ListSplice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSplice_Marshal(m, *pv)
	} else if !enc {
		var v ListSplice
		if err = ListSplice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSplice_Marshal(m jsn.Marshaler, val *ListSplice) (err error) {
	if err = m.MarshalBlock(ListSplice_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSplice_Field_List)
		if e0 == nil {
			e0 = literal.Text_Unboxed_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSplice_Field_List))
		}
		e1 := m.MarshalKey("start", ListSplice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSplice_Field_Start))
		}
		e2 := m.MarshalKey("remove", ListSplice_Field_Remove)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.Remove)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSplice_Field_Remove))
		}
		e3 := m.MarshalKey("insert", ListSplice_Field_Insert)
		if e3 == nil {
			e3 = rt.Assignment_Marshal(m, &val.Insert)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSplice_Field_Insert))
		}
		m.EndBlock()
	}
	return
}

const ListTarget_Type = "list_target"

var ListTarget_Optional_Marshal = ListTarget_Marshal

type ListTarget_Slot struct{ Value *ListTarget }

func (at ListTarget_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at ListTarget_Slot) GetType() string              { return ListTarget_Type }
func (at ListTarget_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at ListTarget_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(ListTarget)
	return
}

func ListTarget_Marshal(m jsn.Marshaler, ptr *ListTarget) (err error) {
	slot := ListTarget_Slot{ptr}
	return slot.Marshal(m)
}

type ListTarget_Slice []ListTarget

func (op *ListTarget_Slice) GetType() string { return ListTarget_Type }

func (op *ListTarget_Slice) Marshal(m jsn.Marshaler) error {
	return ListTarget_Repeats_Marshal(m, (*[]ListTarget)(op))
}

func (op *ListTarget_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListTarget_Slice) SetSize(cnt int) {
	var els []ListTarget
	if cnt >= 0 {
		els = make(ListTarget_Slice, cnt)
	}
	(*op) = els
}

func (op *ListTarget_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListTarget_Marshal(m, &(*op)[i])
}

func ListTarget_Repeats_Marshal(m jsn.Marshaler, vals *[]ListTarget) error {
	return jsn.RepeatBlock(m, (*ListTarget_Slice)(vals))
}

func ListTarget_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListTarget) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = ListTarget_Repeats_Marshal(m, pv)
	}
	return
}

// PutEdge Add a value to a list
type PutEdge struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
}

// User implemented slots:
var _ rt.Execute = (*PutEdge)(nil)

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: PutEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutEdge_Type = "put_edge"
const PutEdge_Field_From = "$FROM"
const PutEdge_Field_Into = "$INTO"
const PutEdge_Field_AtEdge = "$AT_EDGE"

func (op *PutEdge) Marshal(m jsn.Marshaler) error {
	return PutEdge_Marshal(m, op)
}

type PutEdge_Slice []PutEdge

func (op *PutEdge_Slice) GetType() string { return PutEdge_Type }

func (op *PutEdge_Slice) Marshal(m jsn.Marshaler) error {
	return PutEdge_Repeats_Marshal(m, (*[]PutEdge)(op))
}

func (op *PutEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *PutEdge_Slice) SetSize(cnt int) {
	var els []PutEdge
	if cnt >= 0 {
		els = make(PutEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *PutEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return PutEdge_Marshal(m, &(*op)[i])
}

func PutEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]PutEdge) error {
	return jsn.RepeatBlock(m, (*PutEdge_Slice)(vals))
}

func PutEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]PutEdge) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = PutEdge_Repeats_Marshal(m, pv)
	}
	return
}

type PutEdge_Flow struct{ ptr *PutEdge }

func (n PutEdge_Flow) GetType() string      { return PutEdge_Type }
func (n PutEdge_Flow) GetLede() string      { return "put" }
func (n PutEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n PutEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*PutEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func PutEdge_Optional_Marshal(m jsn.Marshaler, pv **PutEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = PutEdge_Marshal(m, *pv)
	} else if !enc {
		var v PutEdge
		if err = PutEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func PutEdge_Marshal(m jsn.Marshaler, val *PutEdge) (err error) {
	if err = m.MarshalBlock(PutEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", PutEdge_Field_From)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", PutEdge_Field_From))
		}
		e1 := m.MarshalKey("into", PutEdge_Field_Into)
		if e1 == nil {
			e1 = ListTarget_Marshal(m, &val.Into)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", PutEdge_Field_Into))
		}
		e2 := m.MarshalKey("at_front", PutEdge_Field_AtEdge)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", PutEdge_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// PutIndex Replace one value in a list with another
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

// User implemented slots:
var _ rt.Execute = (*PutIndex)(nil)

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: PutIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutIndex_Type = "put_index"
const PutIndex_Field_From = "$FROM"
const PutIndex_Field_Into = "$INTO"
const PutIndex_Field_AtIndex = "$AT_INDEX"

func (op *PutIndex) Marshal(m jsn.Marshaler) error {
	return PutIndex_Marshal(m, op)
}

type PutIndex_Slice []PutIndex

func (op *PutIndex_Slice) GetType() string { return PutIndex_Type }

func (op *PutIndex_Slice) Marshal(m jsn.Marshaler) error {
	return PutIndex_Repeats_Marshal(m, (*[]PutIndex)(op))
}

func (op *PutIndex_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *PutIndex_Slice) SetSize(cnt int) {
	var els []PutIndex
	if cnt >= 0 {
		els = make(PutIndex_Slice, cnt)
	}
	(*op) = els
}

func (op *PutIndex_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return PutIndex_Marshal(m, &(*op)[i])
}

func PutIndex_Repeats_Marshal(m jsn.Marshaler, vals *[]PutIndex) error {
	return jsn.RepeatBlock(m, (*PutIndex_Slice)(vals))
}

func PutIndex_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]PutIndex) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = PutIndex_Repeats_Marshal(m, pv)
	}
	return
}

type PutIndex_Flow struct{ ptr *PutIndex }

func (n PutIndex_Flow) GetType() string      { return PutIndex_Type }
func (n PutIndex_Flow) GetLede() string      { return "put" }
func (n PutIndex_Flow) GetFlow() interface{} { return n.ptr }
func (n PutIndex_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*PutIndex); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func PutIndex_Optional_Marshal(m jsn.Marshaler, pv **PutIndex) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = PutIndex_Marshal(m, *pv)
	} else if !enc {
		var v PutIndex
		if err = PutIndex_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func PutIndex_Marshal(m jsn.Marshaler, val *PutIndex) (err error) {
	if err = m.MarshalBlock(PutIndex_Flow{val}); err == nil {
		e0 := m.MarshalKey("", PutIndex_Field_From)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", PutIndex_Field_From))
		}
		e1 := m.MarshalKey("into", PutIndex_Field_Into)
		if e1 == nil {
			e1 = ListTarget_Marshal(m, &val.Into)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", PutIndex_Field_Into))
		}
		e2 := m.MarshalKey("at_index", PutIndex_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", PutIndex_Field_AtIndex))
		}
		m.EndBlock()
	}
	return
}

// Range Generates a series of numbers r[i] = (start + step*i) where i>=0.
// Start and step default to 1, stop defaults to start;
// the inputs are truncated to produce whole numbers;
// a zero step returns an error.
// A positive step ends the series when the returned value would exceed stop
// while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

// User implemented slots:
var _ rt.NumListEval = (*Range)(nil)

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Range_Type,
		Uses: composer.Type_Flow,
	}
}

const Range_Type = "range"
const Range_Field_To = "$TO"
const Range_Field_From = "$FROM"
const Range_Field_ByStep = "$BY_STEP"

func (op *Range) Marshal(m jsn.Marshaler) error {
	return Range_Marshal(m, op)
}

type Range_Slice []Range

func (op *Range_Slice) GetType() string { return Range_Type }

func (op *Range_Slice) Marshal(m jsn.Marshaler) error {
	return Range_Repeats_Marshal(m, (*[]Range)(op))
}

func (op *Range_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Range_Slice) SetSize(cnt int) {
	var els []Range
	if cnt >= 0 {
		els = make(Range_Slice, cnt)
	}
	(*op) = els
}

func (op *Range_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Range_Marshal(m, &(*op)[i])
}

func Range_Repeats_Marshal(m jsn.Marshaler, vals *[]Range) error {
	return jsn.RepeatBlock(m, (*Range_Slice)(vals))
}

func Range_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Range) (err error) {
	if *pv != nil || !m.IsEncoding() {
		err = Range_Repeats_Marshal(m, pv)
	}
	return
}

type Range_Flow struct{ ptr *Range }

func (n Range_Flow) GetType() string      { return Range_Type }
func (n Range_Flow) GetLede() string      { return Range_Type }
func (n Range_Flow) GetFlow() interface{} { return n.ptr }
func (n Range_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Range); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Range_Optional_Marshal(m jsn.Marshaler, pv **Range) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Range_Marshal(m, *pv)
	} else if !enc {
		var v Range
		if err = Range_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Range_Marshal(m jsn.Marshaler, val *Range) (err error) {
	if err = m.MarshalBlock(Range_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Range_Field_To)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.To)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Range_Field_To))
		}
		e1 := m.MarshalKey("from", Range_Field_From)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Range_Field_From))
		}
		e2 := m.MarshalKey("by_step", Range_Field_ByStep)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.ByStep)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Range_Field_ByStep))
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}

var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
}

var Signatures = map[uint64]interface{}{
	12988276311577525315: (*AsNum)(nil),           /* AsNum: */
	5538742983703937313:  (*AsRec)(nil),           /* AsRec: */
	4514588378517715255:  (*AsTxt)(nil),           /* AsTxt: */
	602674204343183133:   (*EraseEdge)(nil),       /* Erase: */
	2379140516691405863:  (*EraseEdge)(nil),       /* Erase:atFront: */
	18068640065349035914: (*EraseIndex)(nil),      /* Erase:from:atIndex: */
	15022408731321198722: (*Erasing)(nil),         /* Erasing:from:atIndex:as:do: */
	10199179765059749783: (*ErasingEdge)(nil),     /* Erasing:as:do: */
	4059879572017637653:  (*ErasingEdge)(nil),     /* Erasing:atFront:as:do: */
	2253244220008480180:  (*ErasingEdge)(nil),     /* Erasing:as:do:else: */
	4832054959845425038:  (*ErasingEdge)(nil),     /* Erasing:atFront:as:do:else: */
	11643102106272323440: (*FromNumList)(nil),     /* VarOfNums: */
	11748429228606086474: (*FromRecList)(nil),     /* VarOfRecs: */
	9860873969452403008:  (*FromTxtList)(nil),     /* VarOfTxts: */
	15891010564373014004: (*IntoNumList)(nil),     /* IntoNums: */
	12459647556401208318: (*IntoRecList)(nil),     /* IntoRecs: */
	8659259889251239468:  (*IntoTxtList)(nil),     /* IntoTxts: */
	486700160484864869:   (*ListAt)(nil),          /* Get:index: */
	5893619730181277740:  (*ListEach)(nil),        /* Repeating across:as:do: */
	4018832586238090637:  (*ListEach)(nil),        /* Repeating across:as:do:else: */
	10285751875873889942: (*ListFind)(nil),        /* Find:list: */
	6334415563934548256:  (*ListGather)(nil),      /* Gather:from:using: */
	11936860857815714018: (*ListLen)(nil),         /* Len: */
	5185210125302469743:  (*ListMap)(nil),         /* Map:fromList:using: */
	14826188473242626433: (*ListReduce)(nil),      /* Reduce into:fromList:using: */
	13627278328240309351: (*ListReverse)(nil),     /* Reverse list: */
	15586923045386932713: (*ListSet)(nil),         /* Set:index:from: */
	16656583749567367441: (*ListSlice)(nil),       /* Slice: */
	8205818265699527963:  (*ListSlice)(nil),       /* Slice:start: */
	11293812622311872004: (*ListSlice)(nil),       /* Slice:end: */
	1592674698280817110:  (*ListSlice)(nil),       /* Slice:start:end: */
	5767454846835881814:  (*ListSortNumbers)(nil), /* SortNumbers:byField: */
	11765588999597320458: (*ListSortNumbers)(nil), /* SortNumbers:byField:descending: */
	16820765327929145512: (*ListSortText)(nil),    /* SortTexts:byField: */
	7928660393625494104:  (*ListSortText)(nil),    /* SortTexts:byField:descending: */
	14523039554491862046: (*ListSortText)(nil),    /* SortTexts:byField:usingCase: */
	13718565834155724622: (*ListSortText)(nil),    /* SortTexts:byField:descending:usingCase: */
	17242083762994141003: (*ListSortUsing)(nil),   /* Sort:using: */
	10934695318884901016: (*ListSplice)(nil),      /* Splice:start:remove:insert: */
	17042054112571797420: (*PutEdge)(nil),         /* Put:into: */
	14857107863114820154: (*PutEdge)(nil),         /* Put:into:atFront: */
	8899481094314089999:  (*PutIndex)(nil),        /* Put:into:atIndex: */
	9793113837890674936:  (*Range)(nil),           /* Range: */
	12654734042076112886: (*Range)(nil),           /* Range:from: */
	4890710300640402911:  (*Range)(nil),           /* Range:byStep: */
	17061865887297909749: (*Range)(nil),           /* Range:from:byStep: */
}
