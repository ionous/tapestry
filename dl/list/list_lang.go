// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/jsn"
	"git.sr.ht/~ionous/iffy/rt"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: AsNum_Type,
		Uses: composer.Type_Flow,
		Lede: "num",
	}
}

const AsNum_Type = "as_num"

const AsNum_Field_Var = "$VAR"

func (op *AsNum) Marshal(n jsn.Marshaler) {
	AsNum_Marshal(n, op)
}

type AsNum_Slice []AsNum

func (op *AsNum_Slice) GetSize() int    { return len(*op) }
func (op *AsNum_Slice) SetSize(cnt int) { (*op) = make(AsNum_Slice, cnt) }

func AsNum_Repeats_Marshal(n jsn.Marshaler, vals *[]AsNum) {
	if n.RepeatValues(AsNum_Type, (*AsNum_Slice)(vals)) {
		for i := range *vals {
			AsNum_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func AsNum_Optional_Marshal(n jsn.Marshaler, pv **AsNum) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		AsNum_Marshal(n, *pv)
	} else if !enc {
		var v AsNum
		if AsNum_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func AsNum_Marshal(n jsn.Marshaler, val *AsNum) (okay bool) {
	if okay = n.MapValues("num", AsNum_Type); okay {
		if n.MapKey("", AsNum_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: AsRec_Type,
		Uses: composer.Type_Flow,
		Lede: "rec",
	}
}

const AsRec_Type = "as_rec"

const AsRec_Field_Var = "$VAR"

func (op *AsRec) Marshal(n jsn.Marshaler) {
	AsRec_Marshal(n, op)
}

type AsRec_Slice []AsRec

func (op *AsRec_Slice) GetSize() int    { return len(*op) }
func (op *AsRec_Slice) SetSize(cnt int) { (*op) = make(AsRec_Slice, cnt) }

func AsRec_Repeats_Marshal(n jsn.Marshaler, vals *[]AsRec) {
	if n.RepeatValues(AsRec_Type, (*AsRec_Slice)(vals)) {
		for i := range *vals {
			AsRec_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func AsRec_Optional_Marshal(n jsn.Marshaler, pv **AsRec) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		AsRec_Marshal(n, *pv)
	} else if !enc {
		var v AsRec
		if AsRec_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func AsRec_Marshal(n jsn.Marshaler, val *AsRec) (okay bool) {
	if okay = n.MapValues("rec", AsRec_Type); okay {
		if n.MapKey("", AsRec_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: AsTxt_Type,
		Uses: composer.Type_Flow,
		Lede: "txt",
	}
}

const AsTxt_Type = "as_txt"

const AsTxt_Field_Var = "$VAR"

func (op *AsTxt) Marshal(n jsn.Marshaler) {
	AsTxt_Marshal(n, op)
}

type AsTxt_Slice []AsTxt

func (op *AsTxt_Slice) GetSize() int    { return len(*op) }
func (op *AsTxt_Slice) SetSize(cnt int) { (*op) = make(AsTxt_Slice, cnt) }

func AsTxt_Repeats_Marshal(n jsn.Marshaler, vals *[]AsTxt) {
	if n.RepeatValues(AsTxt_Type, (*AsTxt_Slice)(vals)) {
		for i := range *vals {
			AsTxt_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func AsTxt_Optional_Marshal(n jsn.Marshaler, pv **AsTxt) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		AsTxt_Marshal(n, *pv)
	} else if !enc {
		var v AsTxt
		if AsTxt_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func AsTxt_Marshal(n jsn.Marshaler, val *AsTxt) (okay bool) {
	if okay = n.MapValues("txt", AsTxt_Type); okay {
		if n.MapKey("", AsTxt_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// EraseEdge Erase at edge: Remove one or more values from a list
type EraseEdge struct {
	From   ListSource  `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
}

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseEdge_Type = "erase_edge"

const EraseEdge_Field_From = "$FROM"
const EraseEdge_Field_AtEdge = "$AT_EDGE"

func (op *EraseEdge) Marshal(n jsn.Marshaler) {
	EraseEdge_Marshal(n, op)
}

type EraseEdge_Slice []EraseEdge

func (op *EraseEdge_Slice) GetSize() int    { return len(*op) }
func (op *EraseEdge_Slice) SetSize(cnt int) { (*op) = make(EraseEdge_Slice, cnt) }

func EraseEdge_Repeats_Marshal(n jsn.Marshaler, vals *[]EraseEdge) {
	if n.RepeatValues(EraseEdge_Type, (*EraseEdge_Slice)(vals)) {
		for i := range *vals {
			EraseEdge_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func EraseEdge_Optional_Marshal(n jsn.Marshaler, pv **EraseEdge) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		EraseEdge_Marshal(n, *pv)
	} else if !enc {
		var v EraseEdge
		if EraseEdge_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func EraseEdge_Marshal(n jsn.Marshaler, val *EraseEdge) (okay bool) {
	if okay = n.MapValues("erase", EraseEdge_Type); okay {
		if n.MapKey("", EraseEdge_Field_From) {
			ListSource_Marshal(n, &val.From)
		}
		if n.MapKey("at_front", EraseEdge_Field_AtEdge) {
			rt.BoolEval_Optional_Marshal(n, &val.AtEdge)
		}
		n.EndValues()
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseIndex_Type = "erase_index"

const EraseIndex_Field_Count = "$COUNT"
const EraseIndex_Field_From = "$FROM"
const EraseIndex_Field_AtIndex = "$AT_INDEX"

func (op *EraseIndex) Marshal(n jsn.Marshaler) {
	EraseIndex_Marshal(n, op)
}

type EraseIndex_Slice []EraseIndex

func (op *EraseIndex_Slice) GetSize() int    { return len(*op) }
func (op *EraseIndex_Slice) SetSize(cnt int) { (*op) = make(EraseIndex_Slice, cnt) }

func EraseIndex_Repeats_Marshal(n jsn.Marshaler, vals *[]EraseIndex) {
	if n.RepeatValues(EraseIndex_Type, (*EraseIndex_Slice)(vals)) {
		for i := range *vals {
			EraseIndex_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func EraseIndex_Optional_Marshal(n jsn.Marshaler, pv **EraseIndex) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		EraseIndex_Marshal(n, *pv)
	} else if !enc {
		var v EraseIndex
		if EraseIndex_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func EraseIndex_Marshal(n jsn.Marshaler, val *EraseIndex) (okay bool) {
	if okay = n.MapValues("erase", EraseIndex_Type); okay {
		if n.MapKey("", EraseIndex_Field_Count) {
			rt.NumberEval_Marshal(n, &val.Count)
		}
		if n.MapKey("from", EraseIndex_Field_From) {
			ListSource_Marshal(n, &val.From)
		}
		if n.MapKey("at_index", EraseIndex_Field_AtIndex) {
			rt.NumberEval_Marshal(n, &val.AtIndex)
		}
		n.EndValues()
	}
	return
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Do      core.Activity `if:"label=do"`
}

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Erasing_Type,
		Uses: composer.Type_Flow,
	}
}

const Erasing_Type = "erasing"

const Erasing_Field_Count = "$COUNT"
const Erasing_Field_From = "$FROM"
const Erasing_Field_AtIndex = "$AT_INDEX"
const Erasing_Field_As = "$AS"
const Erasing_Field_Do = "$DO"

func (op *Erasing) Marshal(n jsn.Marshaler) {
	Erasing_Marshal(n, op)
}

type Erasing_Slice []Erasing

func (op *Erasing_Slice) GetSize() int    { return len(*op) }
func (op *Erasing_Slice) SetSize(cnt int) { (*op) = make(Erasing_Slice, cnt) }

func Erasing_Repeats_Marshal(n jsn.Marshaler, vals *[]Erasing) {
	if n.RepeatValues(Erasing_Type, (*Erasing_Slice)(vals)) {
		for i := range *vals {
			Erasing_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func Erasing_Optional_Marshal(n jsn.Marshaler, pv **Erasing) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Erasing_Marshal(n, *pv)
	} else if !enc {
		var v Erasing
		if Erasing_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Erasing_Marshal(n jsn.Marshaler, val *Erasing) (okay bool) {
	if okay = n.MapValues(Erasing_Type, Erasing_Type); okay {
		if n.MapKey("", Erasing_Field_Count) {
			rt.NumberEval_Marshal(n, &val.Count)
		}
		if n.MapKey("from", Erasing_Field_From) {
			ListSource_Marshal(n, &val.From)
		}
		if n.MapKey("at_index", Erasing_Field_AtIndex) {
			rt.NumberEval_Marshal(n, &val.AtIndex)
		}
		if n.MapKey("as", Erasing_Field_As) {
			value.Text_Unboxed_Marshal(n, &val.As)
		}
		if n.MapKey("do", Erasing_Field_Do) {
			core.Activity_Marshal(n, &val.Do)
		}
		n.EndValues()
	}
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From   ListSource    `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Do     core.Activity `if:"label=do"`
	Else   core.Brancher `if:"label=else,optional"`
}

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: ErasingEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const ErasingEdge_Type = "erasing_edge"

const ErasingEdge_Field_From = "$FROM"
const ErasingEdge_Field_AtEdge = "$AT_EDGE"
const ErasingEdge_Field_As = "$AS"
const ErasingEdge_Field_Do = "$DO"
const ErasingEdge_Field_Else = "$ELSE"

func (op *ErasingEdge) Marshal(n jsn.Marshaler) {
	ErasingEdge_Marshal(n, op)
}

type ErasingEdge_Slice []ErasingEdge

func (op *ErasingEdge_Slice) GetSize() int    { return len(*op) }
func (op *ErasingEdge_Slice) SetSize(cnt int) { (*op) = make(ErasingEdge_Slice, cnt) }

func ErasingEdge_Repeats_Marshal(n jsn.Marshaler, vals *[]ErasingEdge) {
	if n.RepeatValues(ErasingEdge_Type, (*ErasingEdge_Slice)(vals)) {
		for i := range *vals {
			ErasingEdge_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ErasingEdge_Optional_Marshal(n jsn.Marshaler, pv **ErasingEdge) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ErasingEdge_Marshal(n, *pv)
	} else if !enc {
		var v ErasingEdge
		if ErasingEdge_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ErasingEdge_Marshal(n jsn.Marshaler, val *ErasingEdge) (okay bool) {
	if okay = n.MapValues("erasing", ErasingEdge_Type); okay {
		if n.MapKey("", ErasingEdge_Field_From) {
			ListSource_Marshal(n, &val.From)
		}
		if n.MapKey("at_front", ErasingEdge_Field_AtEdge) {
			rt.BoolEval_Optional_Marshal(n, &val.AtEdge)
		}
		if n.MapKey("as", ErasingEdge_Field_As) {
			value.Text_Unboxed_Marshal(n, &val.As)
		}
		if n.MapKey("do", ErasingEdge_Field_Do) {
			core.Activity_Marshal(n, &val.Do)
		}
		if n.MapKey("else", ErasingEdge_Field_Else) {
			core.Brancher_Optional_Marshal(n, &val.Else)
		}
		n.EndValues()
	}
	return
}

// FromNumList Uses a list of numbers
type FromNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const FromNumList_Type = "from_num_list"

const FromNumList_Field_Var = "$VAR"

func (op *FromNumList) Marshal(n jsn.Marshaler) {
	FromNumList_Marshal(n, op)
}

type FromNumList_Slice []FromNumList

func (op *FromNumList_Slice) GetSize() int    { return len(*op) }
func (op *FromNumList_Slice) SetSize(cnt int) { (*op) = make(FromNumList_Slice, cnt) }

func FromNumList_Repeats_Marshal(n jsn.Marshaler, vals *[]FromNumList) {
	if n.RepeatValues(FromNumList_Type, (*FromNumList_Slice)(vals)) {
		for i := range *vals {
			FromNumList_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func FromNumList_Optional_Marshal(n jsn.Marshaler, pv **FromNumList) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		FromNumList_Marshal(n, *pv)
	} else if !enc {
		var v FromNumList
		if FromNumList_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func FromNumList_Marshal(n jsn.Marshaler, val *FromNumList) (okay bool) {
	if okay = n.MapValues("nums", FromNumList_Type); okay {
		if n.MapKey("", FromNumList_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// FromRecList Uses a list of records
type FromRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "recs",
	}
}

const FromRecList_Type = "from_rec_list"

const FromRecList_Field_Var = "$VAR"

func (op *FromRecList) Marshal(n jsn.Marshaler) {
	FromRecList_Marshal(n, op)
}

type FromRecList_Slice []FromRecList

func (op *FromRecList_Slice) GetSize() int    { return len(*op) }
func (op *FromRecList_Slice) SetSize(cnt int) { (*op) = make(FromRecList_Slice, cnt) }

func FromRecList_Repeats_Marshal(n jsn.Marshaler, vals *[]FromRecList) {
	if n.RepeatValues(FromRecList_Type, (*FromRecList_Slice)(vals)) {
		for i := range *vals {
			FromRecList_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func FromRecList_Optional_Marshal(n jsn.Marshaler, pv **FromRecList) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		FromRecList_Marshal(n, *pv)
	} else if !enc {
		var v FromRecList
		if FromRecList_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func FromRecList_Marshal(n jsn.Marshaler, val *FromRecList) (okay bool) {
	if okay = n.MapValues("recs", FromRecList_Type); okay {
		if n.MapKey("", FromRecList_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// FromTxtList Uses a list of text
type FromTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const FromTxtList_Type = "from_txt_list"

const FromTxtList_Field_Var = "$VAR"

func (op *FromTxtList) Marshal(n jsn.Marshaler) {
	FromTxtList_Marshal(n, op)
}

type FromTxtList_Slice []FromTxtList

func (op *FromTxtList_Slice) GetSize() int    { return len(*op) }
func (op *FromTxtList_Slice) SetSize(cnt int) { (*op) = make(FromTxtList_Slice, cnt) }

func FromTxtList_Repeats_Marshal(n jsn.Marshaler, vals *[]FromTxtList) {
	if n.RepeatValues(FromTxtList_Type, (*FromTxtList_Slice)(vals)) {
		for i := range *vals {
			FromTxtList_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func FromTxtList_Optional_Marshal(n jsn.Marshaler, pv **FromTxtList) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		FromTxtList_Marshal(n, *pv)
	} else if !enc {
		var v FromTxtList
		if FromTxtList_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func FromTxtList_Marshal(n jsn.Marshaler, val *FromTxtList) (okay bool) {
	if okay = n.MapValues("txts", FromTxtList_Type); okay {
		if n.MapKey("", FromTxtList_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// IntoNumList Targets a list of numbers
type IntoNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const IntoNumList_Type = "into_num_list"

const IntoNumList_Field_Var = "$VAR"

func (op *IntoNumList) Marshal(n jsn.Marshaler) {
	IntoNumList_Marshal(n, op)
}

type IntoNumList_Slice []IntoNumList

func (op *IntoNumList_Slice) GetSize() int    { return len(*op) }
func (op *IntoNumList_Slice) SetSize(cnt int) { (*op) = make(IntoNumList_Slice, cnt) }

func IntoNumList_Repeats_Marshal(n jsn.Marshaler, vals *[]IntoNumList) {
	if n.RepeatValues(IntoNumList_Type, (*IntoNumList_Slice)(vals)) {
		for i := range *vals {
			IntoNumList_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func IntoNumList_Optional_Marshal(n jsn.Marshaler, pv **IntoNumList) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		IntoNumList_Marshal(n, *pv)
	} else if !enc {
		var v IntoNumList
		if IntoNumList_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func IntoNumList_Marshal(n jsn.Marshaler, val *IntoNumList) (okay bool) {
	if okay = n.MapValues("nums", IntoNumList_Type); okay {
		if n.MapKey("", IntoNumList_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// IntoRecList Targets a list of records
type IntoRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "recs",
	}
}

const IntoRecList_Type = "into_rec_list"

const IntoRecList_Field_Var = "$VAR"

func (op *IntoRecList) Marshal(n jsn.Marshaler) {
	IntoRecList_Marshal(n, op)
}

type IntoRecList_Slice []IntoRecList

func (op *IntoRecList_Slice) GetSize() int    { return len(*op) }
func (op *IntoRecList_Slice) SetSize(cnt int) { (*op) = make(IntoRecList_Slice, cnt) }

func IntoRecList_Repeats_Marshal(n jsn.Marshaler, vals *[]IntoRecList) {
	if n.RepeatValues(IntoRecList_Type, (*IntoRecList_Slice)(vals)) {
		for i := range *vals {
			IntoRecList_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func IntoRecList_Optional_Marshal(n jsn.Marshaler, pv **IntoRecList) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		IntoRecList_Marshal(n, *pv)
	} else if !enc {
		var v IntoRecList
		if IntoRecList_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func IntoRecList_Marshal(n jsn.Marshaler, val *IntoRecList) (okay bool) {
	if okay = n.MapValues("recs", IntoRecList_Type); okay {
		if n.MapKey("", IntoRecList_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// IntoTxtList Targets a list of text
type IntoTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const IntoTxtList_Type = "into_txt_list"

const IntoTxtList_Field_Var = "$VAR"

func (op *IntoTxtList) Marshal(n jsn.Marshaler) {
	IntoTxtList_Marshal(n, op)
}

type IntoTxtList_Slice []IntoTxtList

func (op *IntoTxtList_Slice) GetSize() int    { return len(*op) }
func (op *IntoTxtList_Slice) SetSize(cnt int) { (*op) = make(IntoTxtList_Slice, cnt) }

func IntoTxtList_Repeats_Marshal(n jsn.Marshaler, vals *[]IntoTxtList) {
	if n.RepeatValues(IntoTxtList_Type, (*IntoTxtList_Slice)(vals)) {
		for i := range *vals {
			IntoTxtList_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func IntoTxtList_Optional_Marshal(n jsn.Marshaler, pv **IntoTxtList) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		IntoTxtList_Marshal(n, *pv)
	} else if !enc {
		var v IntoTxtList
		if IntoTxtList_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func IntoTxtList_Marshal(n jsn.Marshaler, val *IntoTxtList) (okay bool) {
	if okay = n.MapValues("txts", IntoTxtList_Type); okay {
		if n.MapKey("", IntoTxtList_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		n.EndValues()
	}
	return
}

// ListAt Get a value from a list. The first element is is index 1.
type ListAt struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: ListAt_Type,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const ListAt_Type = "list_at"

const ListAt_Field_List = "$LIST"
const ListAt_Field_Index = "$INDEX"

func (op *ListAt) Marshal(n jsn.Marshaler) {
	ListAt_Marshal(n, op)
}

type ListAt_Slice []ListAt

func (op *ListAt_Slice) GetSize() int    { return len(*op) }
func (op *ListAt_Slice) SetSize(cnt int) { (*op) = make(ListAt_Slice, cnt) }

func ListAt_Repeats_Marshal(n jsn.Marshaler, vals *[]ListAt) {
	if n.RepeatValues(ListAt_Type, (*ListAt_Slice)(vals)) {
		for i := range *vals {
			ListAt_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListAt_Optional_Marshal(n jsn.Marshaler, pv **ListAt) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListAt_Marshal(n, *pv)
	} else if !enc {
		var v ListAt
		if ListAt_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListAt_Marshal(n jsn.Marshaler, val *ListAt) (okay bool) {
	if okay = n.MapValues("get", ListAt_Type); okay {
		if n.MapKey("", ListAt_Field_List) {
			rt.Assignment_Marshal(n, &val.List)
		}
		if n.MapKey("index", ListAt_Field_Index) {
			rt.NumberEval_Marshal(n, &val.Index)
		}
		n.EndValues()
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the &#x27;else&#x27; activity if empty.
type ListEach struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: ListEach_Type,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const ListEach_Type = "list_each"

const ListEach_Field_List = "$LIST"
const ListEach_Field_As = "$AS"
const ListEach_Field_Do = "$DO"
const ListEach_Field_Else = "$ELSE"

func (op *ListEach) Marshal(n jsn.Marshaler) {
	ListEach_Marshal(n, op)
}

type ListEach_Slice []ListEach

func (op *ListEach_Slice) GetSize() int    { return len(*op) }
func (op *ListEach_Slice) SetSize(cnt int) { (*op) = make(ListEach_Slice, cnt) }

func ListEach_Repeats_Marshal(n jsn.Marshaler, vals *[]ListEach) {
	if n.RepeatValues(ListEach_Type, (*ListEach_Slice)(vals)) {
		for i := range *vals {
			ListEach_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListEach_Optional_Marshal(n jsn.Marshaler, pv **ListEach) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListEach_Marshal(n, *pv)
	} else if !enc {
		var v ListEach
		if ListEach_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListEach_Marshal(n jsn.Marshaler, val *ListEach) (okay bool) {
	if okay = n.MapValues("repeating", ListEach_Type); okay {
		if n.MapKey("across", ListEach_Field_List) {
			rt.Assignment_Marshal(n, &val.List)
		}
		if n.MapKey("as", ListEach_Field_As) {
			ListIterator_Marshal(n, &val.As)
		}
		if n.MapKey("do", ListEach_Field_Do) {
			core.Activity_Marshal(n, &val.Do)
		}
		if n.MapKey("else", ListEach_Field_Else) {
			core.Brancher_Optional_Marshal(n, &val.Else)
		}
		n.EndValues()
	}
	return
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFind_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFind_Type = "list_find"

const ListFind_Field_Value = "$VALUE"
const ListFind_Field_List = "$LIST"

func (op *ListFind) Marshal(n jsn.Marshaler) {
	ListFind_Marshal(n, op)
}

type ListFind_Slice []ListFind

func (op *ListFind_Slice) GetSize() int    { return len(*op) }
func (op *ListFind_Slice) SetSize(cnt int) { (*op) = make(ListFind_Slice, cnt) }

func ListFind_Repeats_Marshal(n jsn.Marshaler, vals *[]ListFind) {
	if n.RepeatValues(ListFind_Type, (*ListFind_Slice)(vals)) {
		for i := range *vals {
			ListFind_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListFind_Optional_Marshal(n jsn.Marshaler, pv **ListFind) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListFind_Marshal(n, *pv)
	} else if !enc {
		var v ListFind
		if ListFind_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListFind_Marshal(n jsn.Marshaler, val *ListFind) (okay bool) {
	if okay = n.MapValues("find", ListFind_Type); okay {
		if n.MapKey("", ListFind_Field_Value) {
			rt.Assignment_Marshal(n, &val.Value)
		}
		if n.MapKey("list", ListFind_Field_List) {
			rt.Assignment_Marshal(n, &val.List)
		}
		n.EndValues()
	}
	return
}

// ListGather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: &#x27;in&#x27; as each value from the list, and &#x27;out&#x27; as the var passed to the gather.
type ListGather struct {
	Var   value.VariableName `if:"label=_"`
	From  ListSource         `if:"label=from"`
	Using string             `if:"label=_,type=text"`
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: ListGather_Type,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const ListGather_Type = "list_gather"

const ListGather_Field_Var = "$VAR"
const ListGather_Field_From = "$FROM"
const ListGather_Field_Using = "$USING"

func (op *ListGather) Marshal(n jsn.Marshaler) {
	ListGather_Marshal(n, op)
}

type ListGather_Slice []ListGather

func (op *ListGather_Slice) GetSize() int    { return len(*op) }
func (op *ListGather_Slice) SetSize(cnt int) { (*op) = make(ListGather_Slice, cnt) }

func ListGather_Repeats_Marshal(n jsn.Marshaler, vals *[]ListGather) {
	if n.RepeatValues(ListGather_Type, (*ListGather_Slice)(vals)) {
		for i := range *vals {
			ListGather_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListGather_Optional_Marshal(n jsn.Marshaler, pv **ListGather) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListGather_Marshal(n, *pv)
	} else if !enc {
		var v ListGather
		if ListGather_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListGather_Marshal(n jsn.Marshaler, val *ListGather) (okay bool) {
	if okay = n.MapValues("gather", ListGather_Type); okay {
		if n.MapKey("", ListGather_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		if n.MapKey("from", ListGather_Field_From) {
			ListSource_Marshal(n, &val.From)
		}
		if n.MapKey("", ListGather_Field_Using) {
			value.Text_Unboxed_Marshal(n, &val.Using)
		}
		n.EndValues()
	}
	return
}

const ListIterator_Type = "list_iterator"

var ListIterator_Optional_Marshal = ListIterator_Marshal

type ListIterator_Slot struct{ ptr *ListIterator }

func (at ListIterator_Slot) HasSlot() bool { return at.ptr != nil }
func (at ListIterator_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(ListIterator)
	return
}

func ListIterator_Marshal(n jsn.Marshaler, ptr *ListIterator) {
	if ok := n.SlotValues(ListIterator_Type, ListIterator_Slot{ptr}); ok {
		(*ptr).(jsn.Marshalee).Marshal(n)
		n.EndValues()
	}
	return
}

type ListIterator_Slice []ListIterator

func (op *ListIterator_Slice) GetSize() int    { return len(*op) }
func (op *ListIterator_Slice) SetSize(cnt int) { (*op) = make(ListIterator_Slice, cnt) }

func ListIterator_Repeats_Marshal(n jsn.Marshaler, vals *[]ListIterator) {
	if n.RepeatValues(ListIterator_Type, (*ListIterator_Slice)(vals)) {
		for i := range *vals {
			ListIterator_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List rt.Assignment `if:"label=_"`
}

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: ListLen_Type,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const ListLen_Type = "list_len"

const ListLen_Field_List = "$LIST"

func (op *ListLen) Marshal(n jsn.Marshaler) {
	ListLen_Marshal(n, op)
}

type ListLen_Slice []ListLen

func (op *ListLen_Slice) GetSize() int    { return len(*op) }
func (op *ListLen_Slice) SetSize(cnt int) { (*op) = make(ListLen_Slice, cnt) }

func ListLen_Repeats_Marshal(n jsn.Marshaler, vals *[]ListLen) {
	if n.RepeatValues(ListLen_Type, (*ListLen_Slice)(vals)) {
		for i := range *vals {
			ListLen_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListLen_Optional_Marshal(n jsn.Marshaler, pv **ListLen) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListLen_Marshal(n, *pv)
	} else if !enc {
		var v ListLen
		if ListLen_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListLen_Marshal(n jsn.Marshaler, val *ListLen) (okay bool) {
	if okay = n.MapValues("len", ListLen_Type); okay {
		if n.MapKey("", ListLen_Field_List) {
			rt.Assignment_Marshal(n, &val.List)
		}
		n.EndValues()
	}
	return
}

// ListMap Transform the values from one list and place the results in another list. The designated pattern is called with each value from the &#x27;from list&#x27;, one value at a time.
type ListMap struct {
	ToList       string        `if:"label=_,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: ListMap_Type,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const ListMap_Type = "list_map"

const ListMap_Field_ToList = "$TO_LIST"
const ListMap_Field_FromList = "$FROM_LIST"
const ListMap_Field_UsingPattern = "$USING_PATTERN"

func (op *ListMap) Marshal(n jsn.Marshaler) {
	ListMap_Marshal(n, op)
}

type ListMap_Slice []ListMap

func (op *ListMap_Slice) GetSize() int    { return len(*op) }
func (op *ListMap_Slice) SetSize(cnt int) { (*op) = make(ListMap_Slice, cnt) }

func ListMap_Repeats_Marshal(n jsn.Marshaler, vals *[]ListMap) {
	if n.RepeatValues(ListMap_Type, (*ListMap_Slice)(vals)) {
		for i := range *vals {
			ListMap_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListMap_Optional_Marshal(n jsn.Marshaler, pv **ListMap) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListMap_Marshal(n, *pv)
	} else if !enc {
		var v ListMap
		if ListMap_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListMap_Marshal(n jsn.Marshaler, val *ListMap) (okay bool) {
	if okay = n.MapValues("map", ListMap_Type); okay {
		if n.MapKey("", ListMap_Field_ToList) {
			value.Text_Unboxed_Marshal(n, &val.ToList)
		}
		if n.MapKey("from_list", ListMap_Field_FromList) {
			rt.Assignment_Marshal(n, &val.FromList)
		}
		if n.MapKey("using", ListMap_Field_UsingPattern) {
			value.Text_Unboxed_Marshal(n, &val.UsingPattern)
		}
		n.EndValues()
	}
	return
}

// ListReduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: &#x27;in&#x27; ( each element of the list ) and &#x27;out&#x27; ( ex. a record ).
type ListReduce struct {
	IntoValue    string        `if:"label=into,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReduce_Type,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const ListReduce_Type = "list_reduce"

const ListReduce_Field_IntoValue = "$INTO_VALUE"
const ListReduce_Field_FromList = "$FROM_LIST"
const ListReduce_Field_UsingPattern = "$USING_PATTERN"

func (op *ListReduce) Marshal(n jsn.Marshaler) {
	ListReduce_Marshal(n, op)
}

type ListReduce_Slice []ListReduce

func (op *ListReduce_Slice) GetSize() int    { return len(*op) }
func (op *ListReduce_Slice) SetSize(cnt int) { (*op) = make(ListReduce_Slice, cnt) }

func ListReduce_Repeats_Marshal(n jsn.Marshaler, vals *[]ListReduce) {
	if n.RepeatValues(ListReduce_Type, (*ListReduce_Slice)(vals)) {
		for i := range *vals {
			ListReduce_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListReduce_Optional_Marshal(n jsn.Marshaler, pv **ListReduce) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListReduce_Marshal(n, *pv)
	} else if !enc {
		var v ListReduce
		if ListReduce_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListReduce_Marshal(n jsn.Marshaler, val *ListReduce) (okay bool) {
	if okay = n.MapValues("reduce", ListReduce_Type); okay {
		if n.MapKey("into", ListReduce_Field_IntoValue) {
			value.Text_Unboxed_Marshal(n, &val.IntoValue)
		}
		if n.MapKey("from_list", ListReduce_Field_FromList) {
			rt.Assignment_Marshal(n, &val.FromList)
		}
		if n.MapKey("using", ListReduce_Field_UsingPattern) {
			value.Text_Unboxed_Marshal(n, &val.UsingPattern)
		}
		n.EndValues()
	}
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	List ListSource `if:"label=_"`
}

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReverse_Type,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const ListReverse_Type = "list_reverse"

const ListReverse_Field_List = "$LIST"

func (op *ListReverse) Marshal(n jsn.Marshaler) {
	ListReverse_Marshal(n, op)
}

type ListReverse_Slice []ListReverse

func (op *ListReverse_Slice) GetSize() int    { return len(*op) }
func (op *ListReverse_Slice) SetSize(cnt int) { (*op) = make(ListReverse_Slice, cnt) }

func ListReverse_Repeats_Marshal(n jsn.Marshaler, vals *[]ListReverse) {
	if n.RepeatValues(ListReverse_Type, (*ListReverse_Slice)(vals)) {
		for i := range *vals {
			ListReverse_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListReverse_Optional_Marshal(n jsn.Marshaler, pv **ListReverse) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListReverse_Marshal(n, *pv)
	} else if !enc {
		var v ListReverse
		if ListReverse_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListReverse_Marshal(n jsn.Marshaler, val *ListReverse) (okay bool) {
	if okay = n.MapValues("reverse", ListReverse_Type); okay {
		if n.MapKey("", ListReverse_Field_List) {
			ListSource_Marshal(n, &val.List)
		}
		n.EndValues()
	}
	return
}

// ListSet Overwrite an existing value in a list.
type ListSet struct {
	List  string        `if:"label=_,type=text"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSet_Type,
		Uses: composer.Type_Flow,
		Lede: "set",
	}
}

const ListSet_Type = "list_set"

const ListSet_Field_List = "$LIST"
const ListSet_Field_Index = "$INDEX"
const ListSet_Field_From = "$FROM"

func (op *ListSet) Marshal(n jsn.Marshaler) {
	ListSet_Marshal(n, op)
}

type ListSet_Slice []ListSet

func (op *ListSet_Slice) GetSize() int    { return len(*op) }
func (op *ListSet_Slice) SetSize(cnt int) { (*op) = make(ListSet_Slice, cnt) }

func ListSet_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSet) {
	if n.RepeatValues(ListSet_Type, (*ListSet_Slice)(vals)) {
		for i := range *vals {
			ListSet_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListSet_Optional_Marshal(n jsn.Marshaler, pv **ListSet) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListSet_Marshal(n, *pv)
	} else if !enc {
		var v ListSet
		if ListSet_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListSet_Marshal(n jsn.Marshaler, val *ListSet) (okay bool) {
	if okay = n.MapValues("set", ListSet_Type); okay {
		if n.MapKey("", ListSet_Field_List) {
			value.Text_Unboxed_Marshal(n, &val.List)
		}
		if n.MapKey("index", ListSet_Field_Index) {
			rt.NumberEval_Marshal(n, &val.Index)
		}
		if n.MapKey("from", ListSet_Field_From) {
			rt.Assignment_Marshal(n, &val.From)
		}
		n.EndValues()
	}
	return
}

// ListSlice Create a new list from a section of another list.,Start is optional, if omitted slice starts at the first element.,If start is greater the length, an empty array is returned.,Slice doesnt include the ending index.,Negatives indices indicates an offset from the end.,When end is omitted, copy up to and including the last element;,and do the same if the end is greater than the length
type ListSlice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSlice_Type,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const ListSlice_Type = "list_slice"

const ListSlice_Field_List = "$LIST"
const ListSlice_Field_Start = "$START"
const ListSlice_Field_End = "$END"

func (op *ListSlice) Marshal(n jsn.Marshaler) {
	ListSlice_Marshal(n, op)
}

type ListSlice_Slice []ListSlice

func (op *ListSlice_Slice) GetSize() int    { return len(*op) }
func (op *ListSlice_Slice) SetSize(cnt int) { (*op) = make(ListSlice_Slice, cnt) }

func ListSlice_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSlice) {
	if n.RepeatValues(ListSlice_Type, (*ListSlice_Slice)(vals)) {
		for i := range *vals {
			ListSlice_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListSlice_Optional_Marshal(n jsn.Marshaler, pv **ListSlice) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListSlice_Marshal(n, *pv)
	} else if !enc {
		var v ListSlice
		if ListSlice_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListSlice_Marshal(n jsn.Marshaler, val *ListSlice) (okay bool) {
	if okay = n.MapValues("slice", ListSlice_Type); okay {
		if n.MapKey("", ListSlice_Field_List) {
			rt.Assignment_Marshal(n, &val.List)
		}
		if n.MapKey("start", ListSlice_Field_Start) {
			rt.NumberEval_Optional_Marshal(n, &val.Start)
		}
		if n.MapKey("end", ListSlice_Field_End) {
			rt.NumberEval_Optional_Marshal(n, &val.End)
		}
		n.EndValues()
	}
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
}

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortNumbers_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortNumbers_Type = "list_sort_numbers"

const ListSortNumbers_Field_Var = "$VAR"
const ListSortNumbers_Field_ByField = "$BY_FIELD"
const ListSortNumbers_Field_Descending = "$DESCENDING"

func (op *ListSortNumbers) Marshal(n jsn.Marshaler) {
	ListSortNumbers_Marshal(n, op)
}

type ListSortNumbers_Slice []ListSortNumbers

func (op *ListSortNumbers_Slice) GetSize() int    { return len(*op) }
func (op *ListSortNumbers_Slice) SetSize(cnt int) { (*op) = make(ListSortNumbers_Slice, cnt) }

func ListSortNumbers_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSortNumbers) {
	if n.RepeatValues(ListSortNumbers_Type, (*ListSortNumbers_Slice)(vals)) {
		for i := range *vals {
			ListSortNumbers_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListSortNumbers_Optional_Marshal(n jsn.Marshaler, pv **ListSortNumbers) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListSortNumbers_Marshal(n, *pv)
	} else if !enc {
		var v ListSortNumbers
		if ListSortNumbers_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListSortNumbers_Marshal(n jsn.Marshaler, val *ListSortNumbers) (okay bool) {
	if okay = n.MapValues("sort", ListSortNumbers_Type); okay {
		if n.MapKey("", ListSortNumbers_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		if n.MapKey("by_field", ListSortNumbers_Field_ByField) {
			value.Text_Unboxed_Marshal(n, &val.ByField)
		}
		if n.MapKey("descending", ListSortNumbers_Field_Descending) {
			rt.BoolEval_Optional_Marshal(n, &val.Descending)
		}
		n.EndValues()
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
	UsingCase  rt.BoolEval        `if:"label=using_case,optional"`
}

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortText_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortText_Type = "list_sort_text"

const ListSortText_Field_Var = "$VAR"
const ListSortText_Field_ByField = "$BY_FIELD"
const ListSortText_Field_Descending = "$DESCENDING"
const ListSortText_Field_UsingCase = "$USING_CASE"

func (op *ListSortText) Marshal(n jsn.Marshaler) {
	ListSortText_Marshal(n, op)
}

type ListSortText_Slice []ListSortText

func (op *ListSortText_Slice) GetSize() int    { return len(*op) }
func (op *ListSortText_Slice) SetSize(cnt int) { (*op) = make(ListSortText_Slice, cnt) }

func ListSortText_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSortText) {
	if n.RepeatValues(ListSortText_Type, (*ListSortText_Slice)(vals)) {
		for i := range *vals {
			ListSortText_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListSortText_Optional_Marshal(n jsn.Marshaler, pv **ListSortText) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListSortText_Marshal(n, *pv)
	} else if !enc {
		var v ListSortText
		if ListSortText_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListSortText_Marshal(n jsn.Marshaler, val *ListSortText) (okay bool) {
	if okay = n.MapValues("sort", ListSortText_Type); okay {
		if n.MapKey("", ListSortText_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		if n.MapKey("by_field", ListSortText_Field_ByField) {
			value.Text_Unboxed_Marshal(n, &val.ByField)
		}
		if n.MapKey("descending", ListSortText_Field_Descending) {
			rt.BoolEval_Optional_Marshal(n, &val.Descending)
		}
		if n.MapKey("using_case", ListSortText_Field_UsingCase) {
			rt.BoolEval_Optional_Marshal(n, &val.UsingCase)
		}
		n.EndValues()
	}
	return
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortUsing struct {
	Var   value.VariableName `if:"label=_"`
	Using string             `if:"label=using,type=text"`
}

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortUsing_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortUsing_Type = "list_sort_using"

const ListSortUsing_Field_Var = "$VAR"
const ListSortUsing_Field_Using = "$USING"

func (op *ListSortUsing) Marshal(n jsn.Marshaler) {
	ListSortUsing_Marshal(n, op)
}

type ListSortUsing_Slice []ListSortUsing

func (op *ListSortUsing_Slice) GetSize() int    { return len(*op) }
func (op *ListSortUsing_Slice) SetSize(cnt int) { (*op) = make(ListSortUsing_Slice, cnt) }

func ListSortUsing_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSortUsing) {
	if n.RepeatValues(ListSortUsing_Type, (*ListSortUsing_Slice)(vals)) {
		for i := range *vals {
			ListSortUsing_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListSortUsing_Optional_Marshal(n jsn.Marshaler, pv **ListSortUsing) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListSortUsing_Marshal(n, *pv)
	} else if !enc {
		var v ListSortUsing
		if ListSortUsing_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListSortUsing_Marshal(n jsn.Marshaler, val *ListSortUsing) (okay bool) {
	if okay = n.MapValues("sort", ListSortUsing_Type); okay {
		if n.MapKey("", ListSortUsing_Field_Var) {
			value.VariableName_Marshal(n, &val.Var)
		}
		if n.MapKey("using", ListSortUsing_Field_Using) {
			value.Text_Unboxed_Marshal(n, &val.Using)
		}
		n.EndValues()
	}
	return
}

const ListSource_Type = "list_source"

var ListSource_Optional_Marshal = ListSource_Marshal

type ListSource_Slot struct{ ptr *ListSource }

func (at ListSource_Slot) HasSlot() bool { return at.ptr != nil }
func (at ListSource_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(ListSource)
	return
}

func ListSource_Marshal(n jsn.Marshaler, ptr *ListSource) {
	if ok := n.SlotValues(ListSource_Type, ListSource_Slot{ptr}); ok {
		(*ptr).(jsn.Marshalee).Marshal(n)
		n.EndValues()
	}
	return
}

type ListSource_Slice []ListSource

func (op *ListSource_Slice) GetSize() int    { return len(*op) }
func (op *ListSource_Slice) SetSize(cnt int) { (*op) = make(ListSource_Slice, cnt) }

func ListSource_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSource) {
	if n.RepeatValues(ListSource_Type, (*ListSource_Slice)(vals)) {
		for i := range *vals {
			ListSource_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

// ListSplice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list&#x27;s length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
type ListSplice struct {
	List   string        `if:"label=_,type=text"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSplice_Type,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const ListSplice_Type = "list_splice"

const ListSplice_Field_List = "$LIST"
const ListSplice_Field_Start = "$START"
const ListSplice_Field_Remove = "$REMOVE"
const ListSplice_Field_Insert = "$INSERT"

func (op *ListSplice) Marshal(n jsn.Marshaler) {
	ListSplice_Marshal(n, op)
}

type ListSplice_Slice []ListSplice

func (op *ListSplice_Slice) GetSize() int    { return len(*op) }
func (op *ListSplice_Slice) SetSize(cnt int) { (*op) = make(ListSplice_Slice, cnt) }

func ListSplice_Repeats_Marshal(n jsn.Marshaler, vals *[]ListSplice) {
	if n.RepeatValues(ListSplice_Type, (*ListSplice_Slice)(vals)) {
		for i := range *vals {
			ListSplice_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func ListSplice_Optional_Marshal(n jsn.Marshaler, pv **ListSplice) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ListSplice_Marshal(n, *pv)
	} else if !enc {
		var v ListSplice
		if ListSplice_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ListSplice_Marshal(n jsn.Marshaler, val *ListSplice) (okay bool) {
	if okay = n.MapValues("splice", ListSplice_Type); okay {
		if n.MapKey("", ListSplice_Field_List) {
			value.Text_Unboxed_Marshal(n, &val.List)
		}
		if n.MapKey("start", ListSplice_Field_Start) {
			rt.NumberEval_Marshal(n, &val.Start)
		}
		if n.MapKey("remove", ListSplice_Field_Remove) {
			rt.NumberEval_Marshal(n, &val.Remove)
		}
		if n.MapKey("insert", ListSplice_Field_Insert) {
			rt.Assignment_Marshal(n, &val.Insert)
		}
		n.EndValues()
	}
	return
}

const ListTarget_Type = "list_target"

var ListTarget_Optional_Marshal = ListTarget_Marshal

type ListTarget_Slot struct{ ptr *ListTarget }

func (at ListTarget_Slot) HasSlot() bool { return at.ptr != nil }
func (at ListTarget_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(ListTarget)
	return
}

func ListTarget_Marshal(n jsn.Marshaler, ptr *ListTarget) {
	if ok := n.SlotValues(ListTarget_Type, ListTarget_Slot{ptr}); ok {
		(*ptr).(jsn.Marshalee).Marshal(n)
		n.EndValues()
	}
	return
}

type ListTarget_Slice []ListTarget

func (op *ListTarget_Slice) GetSize() int    { return len(*op) }
func (op *ListTarget_Slice) SetSize(cnt int) { (*op) = make(ListTarget_Slice, cnt) }

func ListTarget_Repeats_Marshal(n jsn.Marshaler, vals *[]ListTarget) {
	if n.RepeatValues(ListTarget_Type, (*ListTarget_Slice)(vals)) {
		for i := range *vals {
			ListTarget_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

// PutEdge Add a value to a list
type PutEdge struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
}

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: PutEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutEdge_Type = "put_edge"

const PutEdge_Field_From = "$FROM"
const PutEdge_Field_Into = "$INTO"
const PutEdge_Field_AtEdge = "$AT_EDGE"

func (op *PutEdge) Marshal(n jsn.Marshaler) {
	PutEdge_Marshal(n, op)
}

type PutEdge_Slice []PutEdge

func (op *PutEdge_Slice) GetSize() int    { return len(*op) }
func (op *PutEdge_Slice) SetSize(cnt int) { (*op) = make(PutEdge_Slice, cnt) }

func PutEdge_Repeats_Marshal(n jsn.Marshaler, vals *[]PutEdge) {
	if n.RepeatValues(PutEdge_Type, (*PutEdge_Slice)(vals)) {
		for i := range *vals {
			PutEdge_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func PutEdge_Optional_Marshal(n jsn.Marshaler, pv **PutEdge) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PutEdge_Marshal(n, *pv)
	} else if !enc {
		var v PutEdge
		if PutEdge_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PutEdge_Marshal(n jsn.Marshaler, val *PutEdge) (okay bool) {
	if okay = n.MapValues("put", PutEdge_Type); okay {
		if n.MapKey("", PutEdge_Field_From) {
			rt.Assignment_Marshal(n, &val.From)
		}
		if n.MapKey("into", PutEdge_Field_Into) {
			ListTarget_Marshal(n, &val.Into)
		}
		if n.MapKey("at_front", PutEdge_Field_AtEdge) {
			rt.BoolEval_Optional_Marshal(n, &val.AtEdge)
		}
		n.EndValues()
	}
	return
}

// PutIndex Replace one value in a list with another
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: PutIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutIndex_Type = "put_index"

const PutIndex_Field_From = "$FROM"
const PutIndex_Field_Into = "$INTO"
const PutIndex_Field_AtIndex = "$AT_INDEX"

func (op *PutIndex) Marshal(n jsn.Marshaler) {
	PutIndex_Marshal(n, op)
}

type PutIndex_Slice []PutIndex

func (op *PutIndex_Slice) GetSize() int    { return len(*op) }
func (op *PutIndex_Slice) SetSize(cnt int) { (*op) = make(PutIndex_Slice, cnt) }

func PutIndex_Repeats_Marshal(n jsn.Marshaler, vals *[]PutIndex) {
	if n.RepeatValues(PutIndex_Type, (*PutIndex_Slice)(vals)) {
		for i := range *vals {
			PutIndex_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func PutIndex_Optional_Marshal(n jsn.Marshaler, pv **PutIndex) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PutIndex_Marshal(n, *pv)
	} else if !enc {
		var v PutIndex
		if PutIndex_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PutIndex_Marshal(n jsn.Marshaler, val *PutIndex) (okay bool) {
	if okay = n.MapValues("put", PutIndex_Type); okay {
		if n.MapKey("", PutIndex_Field_From) {
			rt.Assignment_Marshal(n, &val.From)
		}
		if n.MapKey("into", PutIndex_Field_Into) {
			ListTarget_Marshal(n, &val.Into)
		}
		if n.MapKey("at_index", PutIndex_Field_AtIndex) {
			rt.NumberEval_Marshal(n, &val.AtIndex)
		}
		n.EndValues()
	}
	return
}

// Range Generates a series of numbers r[i] &#x3D; (start + step*i) where i&gt;&#x3D;0.,Start and step default to 1, stop defaults to start;,the inputs are truncated to produce whole numbers;,a zero step returns an error.,A positive step ends the series when the returned value would exceed stop,while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Range_Type,
		Uses: composer.Type_Flow,
	}
}

const Range_Type = "range"

const Range_Field_To = "$TO"
const Range_Field_From = "$FROM"
const Range_Field_ByStep = "$BY_STEP"

func (op *Range) Marshal(n jsn.Marshaler) {
	Range_Marshal(n, op)
}

type Range_Slice []Range

func (op *Range_Slice) GetSize() int    { return len(*op) }
func (op *Range_Slice) SetSize(cnt int) { (*op) = make(Range_Slice, cnt) }

func Range_Repeats_Marshal(n jsn.Marshaler, vals *[]Range) {
	if n.RepeatValues(Range_Type, (*Range_Slice)(vals)) {
		for i := range *vals {
			Range_Marshal(n, &(*vals)[i])
		}
		n.EndValues()
	}
	return
}

func Range_Optional_Marshal(n jsn.Marshaler, pv **Range) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Range_Marshal(n, *pv)
	} else if !enc {
		var v Range
		if Range_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Range_Marshal(n jsn.Marshaler, val *Range) (okay bool) {
	if okay = n.MapValues(Range_Type, Range_Type); okay {
		if n.MapKey("", Range_Field_To) {
			rt.NumberEval_Marshal(n, &val.To)
		}
		if n.MapKey("from", Range_Field_From) {
			rt.NumberEval_Optional_Marshal(n, &val.From)
		}
		if n.MapKey("by_step", Range_Field_ByStep) {
			rt.NumberEval_Optional_Marshal(n, &val.ByStep)
		}
		n.EndValues()
	}
	return
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}

var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
}
