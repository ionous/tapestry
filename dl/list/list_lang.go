// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/jsn"
	"git.sr.ht/~ionous/tapestry/rt"
	"github.com/ionous/errutil"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ ListIterator = (*AsNum)(nil)

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: AsNum_Type,
		Uses: composer.Type_Flow,
	}
}

const AsNum_Type = "as_num"
const AsNum_Field_Var = "$VAR"

func (op *AsNum) Marshal(m jsn.Marshaler) error {
	return AsNum_Marshal(m, op)
}

type AsNum_Slice []AsNum

func (op *AsNum_Slice) GetType() string { return AsNum_Type }

func (op *AsNum_Slice) Marshal(m jsn.Marshaler) error {
	return AsNum_Repeats_Marshal(m, (*[]AsNum)(op))
}

func (op *AsNum_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *AsNum_Slice) SetSize(cnt int) {
	var els []AsNum
	if cnt >= 0 {
		els = make(AsNum_Slice, cnt)
	}
	(*op) = els
}

func (op *AsNum_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return AsNum_Marshal(m, &(*op)[i])
}

func AsNum_Repeats_Marshal(m jsn.Marshaler, vals *[]AsNum) error {
	return jsn.RepeatBlock(m, (*AsNum_Slice)(vals))
}

func AsNum_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]AsNum) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = AsNum_Repeats_Marshal(m, pv)
	}
	return
}

type AsNum_Flow struct{ ptr *AsNum }

func (n AsNum_Flow) GetType() string      { return AsNum_Type }
func (n AsNum_Flow) GetLede() string      { return AsNum_Type }
func (n AsNum_Flow) GetFlow() interface{} { return n.ptr }
func (n AsNum_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*AsNum); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func AsNum_Optional_Marshal(m jsn.Marshaler, pv **AsNum) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsNum_Marshal(m, *pv)
	} else if !enc {
		var v AsNum
		if err = AsNum_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsNum_Marshal(m jsn.Marshaler, val *AsNum) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(AsNum_Flow{val}); err == nil {
		e0 := m.MarshalKey("", AsNum_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsNum_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ ListIterator = (*AsRec)(nil)

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: AsRec_Type,
		Uses: composer.Type_Flow,
	}
}

const AsRec_Type = "as_rec"
const AsRec_Field_Var = "$VAR"

func (op *AsRec) Marshal(m jsn.Marshaler) error {
	return AsRec_Marshal(m, op)
}

type AsRec_Slice []AsRec

func (op *AsRec_Slice) GetType() string { return AsRec_Type }

func (op *AsRec_Slice) Marshal(m jsn.Marshaler) error {
	return AsRec_Repeats_Marshal(m, (*[]AsRec)(op))
}

func (op *AsRec_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *AsRec_Slice) SetSize(cnt int) {
	var els []AsRec
	if cnt >= 0 {
		els = make(AsRec_Slice, cnt)
	}
	(*op) = els
}

func (op *AsRec_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return AsRec_Marshal(m, &(*op)[i])
}

func AsRec_Repeats_Marshal(m jsn.Marshaler, vals *[]AsRec) error {
	return jsn.RepeatBlock(m, (*AsRec_Slice)(vals))
}

func AsRec_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]AsRec) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = AsRec_Repeats_Marshal(m, pv)
	}
	return
}

type AsRec_Flow struct{ ptr *AsRec }

func (n AsRec_Flow) GetType() string      { return AsRec_Type }
func (n AsRec_Flow) GetLede() string      { return AsRec_Type }
func (n AsRec_Flow) GetFlow() interface{} { return n.ptr }
func (n AsRec_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*AsRec); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func AsRec_Optional_Marshal(m jsn.Marshaler, pv **AsRec) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsRec_Marshal(m, *pv)
	} else if !enc {
		var v AsRec
		if err = AsRec_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsRec_Marshal(m jsn.Marshaler, val *AsRec) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(AsRec_Flow{val}); err == nil {
		e0 := m.MarshalKey("", AsRec_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsRec_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ ListIterator = (*AsTxt)(nil)

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: AsTxt_Type,
		Uses: composer.Type_Flow,
	}
}

const AsTxt_Type = "as_txt"
const AsTxt_Field_Var = "$VAR"

func (op *AsTxt) Marshal(m jsn.Marshaler) error {
	return AsTxt_Marshal(m, op)
}

type AsTxt_Slice []AsTxt

func (op *AsTxt_Slice) GetType() string { return AsTxt_Type }

func (op *AsTxt_Slice) Marshal(m jsn.Marshaler) error {
	return AsTxt_Repeats_Marshal(m, (*[]AsTxt)(op))
}

func (op *AsTxt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *AsTxt_Slice) SetSize(cnt int) {
	var els []AsTxt
	if cnt >= 0 {
		els = make(AsTxt_Slice, cnt)
	}
	(*op) = els
}

func (op *AsTxt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return AsTxt_Marshal(m, &(*op)[i])
}

func AsTxt_Repeats_Marshal(m jsn.Marshaler, vals *[]AsTxt) error {
	return jsn.RepeatBlock(m, (*AsTxt_Slice)(vals))
}

func AsTxt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]AsTxt) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = AsTxt_Repeats_Marshal(m, pv)
	}
	return
}

type AsTxt_Flow struct{ ptr *AsTxt }

func (n AsTxt_Flow) GetType() string      { return AsTxt_Type }
func (n AsTxt_Flow) GetLede() string      { return AsTxt_Type }
func (n AsTxt_Flow) GetFlow() interface{} { return n.ptr }
func (n AsTxt_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*AsTxt); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func AsTxt_Optional_Marshal(m jsn.Marshaler, pv **AsTxt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsTxt_Marshal(m, *pv)
	} else if !enc {
		var v AsTxt
		if err = AsTxt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsTxt_Marshal(m jsn.Marshaler, val *AsTxt) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(AsTxt_Flow{val}); err == nil {
		e0 := m.MarshalKey("", AsTxt_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsTxt_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// EraseEdge Erase at edge: Remove one or more values from a list.
type EraseEdge struct {
	From   rt.ListEval `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*EraseEdge)(nil)

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseEdge_Type = "erase_edge"
const EraseEdge_Field_From = "$FROM"
const EraseEdge_Field_AtEdge = "$AT_EDGE"

func (op *EraseEdge) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Marshal(m, op)
}

type EraseEdge_Slice []EraseEdge

func (op *EraseEdge_Slice) GetType() string { return EraseEdge_Type }

func (op *EraseEdge_Slice) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Repeats_Marshal(m, (*[]EraseEdge)(op))
}

func (op *EraseEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EraseEdge_Slice) SetSize(cnt int) {
	var els []EraseEdge
	if cnt >= 0 {
		els = make(EraseEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *EraseEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EraseEdge_Marshal(m, &(*op)[i])
}

func EraseEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseEdge) error {
	return jsn.RepeatBlock(m, (*EraseEdge_Slice)(vals))
}

func EraseEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EraseEdge) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EraseEdge_Repeats_Marshal(m, pv)
	}
	return
}

type EraseEdge_Flow struct{ ptr *EraseEdge }

func (n EraseEdge_Flow) GetType() string      { return EraseEdge_Type }
func (n EraseEdge_Flow) GetLede() string      { return "erase" }
func (n EraseEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n EraseEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EraseEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EraseEdge_Optional_Marshal(m jsn.Marshaler, pv **EraseEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseEdge_Marshal(m, *pv)
	} else if !enc {
		var v EraseEdge
		if err = EraseEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseEdge_Marshal(m jsn.Marshaler, val *EraseEdge) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EraseEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EraseEdge_Field_From)
		if e0 == nil {
			e0 = rt.ListEval_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseEdge_Field_From))
		}
		e1 := m.MarshalKey("at_front", EraseEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseEdge_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list.
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    rt.ListEval   `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	Markup  map[string]any
}

// User implemented slots:
var _ rt.Execute = (*EraseIndex)(nil)

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseIndex_Type = "erase_index"
const EraseIndex_Field_Count = "$COUNT"
const EraseIndex_Field_From = "$FROM"
const EraseIndex_Field_AtIndex = "$AT_INDEX"

func (op *EraseIndex) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Marshal(m, op)
}

type EraseIndex_Slice []EraseIndex

func (op *EraseIndex_Slice) GetType() string { return EraseIndex_Type }

func (op *EraseIndex_Slice) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Repeats_Marshal(m, (*[]EraseIndex)(op))
}

func (op *EraseIndex_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EraseIndex_Slice) SetSize(cnt int) {
	var els []EraseIndex
	if cnt >= 0 {
		els = make(EraseIndex_Slice, cnt)
	}
	(*op) = els
}

func (op *EraseIndex_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EraseIndex_Marshal(m, &(*op)[i])
}

func EraseIndex_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseIndex) error {
	return jsn.RepeatBlock(m, (*EraseIndex_Slice)(vals))
}

func EraseIndex_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EraseIndex) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EraseIndex_Repeats_Marshal(m, pv)
	}
	return
}

type EraseIndex_Flow struct{ ptr *EraseIndex }

func (n EraseIndex_Flow) GetType() string      { return EraseIndex_Type }
func (n EraseIndex_Flow) GetLede() string      { return "erase" }
func (n EraseIndex_Flow) GetFlow() interface{} { return n.ptr }
func (n EraseIndex_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EraseIndex); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EraseIndex_Optional_Marshal(m jsn.Marshaler, pv **EraseIndex) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseIndex_Marshal(m, *pv)
	} else if !enc {
		var v EraseIndex
		if err = EraseIndex_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseIndex_Marshal(m jsn.Marshaler, val *EraseIndex) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EraseIndex_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EraseIndex_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseIndex_Field_Count))
		}
		e1 := m.MarshalKey("from", EraseIndex_Field_From)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseIndex_Field_From))
		}
		e2 := m.MarshalKey("at_index", EraseIndex_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EraseIndex_Field_AtIndex))
		}
		m.EndBlock()
	}
	return
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    rt.ListEval   `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Does    []rt.Execute  `if:"label=does"`
	Markup  map[string]any
}

// User implemented slots:
var _ rt.Execute = (*Erasing)(nil)

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Erasing_Type,
		Uses: composer.Type_Flow,
	}
}

const Erasing_Type = "erasing"
const Erasing_Field_Count = "$COUNT"
const Erasing_Field_From = "$FROM"
const Erasing_Field_AtIndex = "$AT_INDEX"
const Erasing_Field_As = "$AS"
const Erasing_Field_Does = "$DOES"

func (op *Erasing) Marshal(m jsn.Marshaler) error {
	return Erasing_Marshal(m, op)
}

type Erasing_Slice []Erasing

func (op *Erasing_Slice) GetType() string { return Erasing_Type }

func (op *Erasing_Slice) Marshal(m jsn.Marshaler) error {
	return Erasing_Repeats_Marshal(m, (*[]Erasing)(op))
}

func (op *Erasing_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Erasing_Slice) SetSize(cnt int) {
	var els []Erasing
	if cnt >= 0 {
		els = make(Erasing_Slice, cnt)
	}
	(*op) = els
}

func (op *Erasing_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Erasing_Marshal(m, &(*op)[i])
}

func Erasing_Repeats_Marshal(m jsn.Marshaler, vals *[]Erasing) error {
	return jsn.RepeatBlock(m, (*Erasing_Slice)(vals))
}

func Erasing_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Erasing) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Erasing_Repeats_Marshal(m, pv)
	}
	return
}

type Erasing_Flow struct{ ptr *Erasing }

func (n Erasing_Flow) GetType() string      { return Erasing_Type }
func (n Erasing_Flow) GetLede() string      { return Erasing_Type }
func (n Erasing_Flow) GetFlow() interface{} { return n.ptr }
func (n Erasing_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Erasing); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Erasing_Optional_Marshal(m jsn.Marshaler, pv **Erasing) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Erasing_Marshal(m, *pv)
	} else if !enc {
		var v Erasing
		if err = Erasing_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Erasing_Marshal(m jsn.Marshaler, val *Erasing) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Erasing_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Erasing_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Erasing_Field_Count))
		}
		e1 := m.MarshalKey("from", Erasing_Field_From)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Erasing_Field_From))
		}
		e2 := m.MarshalKey("at_index", Erasing_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Erasing_Field_AtIndex))
		}
		e3 := m.MarshalKey("as", Erasing_Field_As)
		if e3 == nil {
			e3 = prim.Text_Unboxed_Marshal(m, &val.As)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", Erasing_Field_As))
		}
		e4 := m.MarshalKey("does", Erasing_Field_Does)
		if e4 == nil {
			e4 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", Erasing_Field_Does))
		}
		m.EndBlock()
	}
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From   rt.ListEval   `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Does   []rt.Execute  `if:"label=does"`
	Else   core.Brancher `if:"label=else,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ErasingEdge)(nil)

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: ErasingEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const ErasingEdge_Type = "erasing_edge"
const ErasingEdge_Field_From = "$FROM"
const ErasingEdge_Field_AtEdge = "$AT_EDGE"
const ErasingEdge_Field_As = "$AS"
const ErasingEdge_Field_Does = "$DOES"
const ErasingEdge_Field_Else = "$ELSE"

func (op *ErasingEdge) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Marshal(m, op)
}

type ErasingEdge_Slice []ErasingEdge

func (op *ErasingEdge_Slice) GetType() string { return ErasingEdge_Type }

func (op *ErasingEdge_Slice) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Repeats_Marshal(m, (*[]ErasingEdge)(op))
}

func (op *ErasingEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ErasingEdge_Slice) SetSize(cnt int) {
	var els []ErasingEdge
	if cnt >= 0 {
		els = make(ErasingEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *ErasingEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ErasingEdge_Marshal(m, &(*op)[i])
}

func ErasingEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]ErasingEdge) error {
	return jsn.RepeatBlock(m, (*ErasingEdge_Slice)(vals))
}

func ErasingEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ErasingEdge) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ErasingEdge_Repeats_Marshal(m, pv)
	}
	return
}

type ErasingEdge_Flow struct{ ptr *ErasingEdge }

func (n ErasingEdge_Flow) GetType() string      { return ErasingEdge_Type }
func (n ErasingEdge_Flow) GetLede() string      { return "erasing" }
func (n ErasingEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n ErasingEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ErasingEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ErasingEdge_Optional_Marshal(m jsn.Marshaler, pv **ErasingEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ErasingEdge_Marshal(m, *pv)
	} else if !enc {
		var v ErasingEdge
		if err = ErasingEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ErasingEdge_Marshal(m jsn.Marshaler, val *ErasingEdge) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ErasingEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ErasingEdge_Field_From)
		if e0 == nil {
			e0 = rt.ListEval_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ErasingEdge_Field_From))
		}
		e1 := m.MarshalKey("at_front", ErasingEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ErasingEdge_Field_AtEdge))
		}
		e2 := m.MarshalKey("as", ErasingEdge_Field_As)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.As)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ErasingEdge_Field_As))
		}
		e3 := m.MarshalKey("does", ErasingEdge_Field_Does)
		if e3 == nil {
			e3 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ErasingEdge_Field_Does))
		}
		e4 := m.MarshalKey("else", ErasingEdge_Field_Else)
		if e4 == nil {
			e4 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", ErasingEdge_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// FromNumList Uses a list of numbers.
type FromNumList struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.ListEval = (*FromNumList)(nil)

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_nums",
	}
}

const FromNumList_Type = "from_num_list"
const FromNumList_Field_Var = "$VAR"

func (op *FromNumList) Marshal(m jsn.Marshaler) error {
	return FromNumList_Marshal(m, op)
}

type FromNumList_Slice []FromNumList

func (op *FromNumList_Slice) GetType() string { return FromNumList_Type }

func (op *FromNumList_Slice) Marshal(m jsn.Marshaler) error {
	return FromNumList_Repeats_Marshal(m, (*[]FromNumList)(op))
}

func (op *FromNumList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *FromNumList_Slice) SetSize(cnt int) {
	var els []FromNumList
	if cnt >= 0 {
		els = make(FromNumList_Slice, cnt)
	}
	(*op) = els
}

func (op *FromNumList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return FromNumList_Marshal(m, &(*op)[i])
}

func FromNumList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromNumList) error {
	return jsn.RepeatBlock(m, (*FromNumList_Slice)(vals))
}

func FromNumList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]FromNumList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = FromNumList_Repeats_Marshal(m, pv)
	}
	return
}

type FromNumList_Flow struct{ ptr *FromNumList }

func (n FromNumList_Flow) GetType() string      { return FromNumList_Type }
func (n FromNumList_Flow) GetLede() string      { return "var_of_nums" }
func (n FromNumList_Flow) GetFlow() interface{} { return n.ptr }
func (n FromNumList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*FromNumList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func FromNumList_Optional_Marshal(m jsn.Marshaler, pv **FromNumList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromNumList_Marshal(m, *pv)
	} else if !enc {
		var v FromNumList
		if err = FromNumList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromNumList_Marshal(m jsn.Marshaler, val *FromNumList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(FromNumList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", FromNumList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromNumList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// FromRecList Uses a list of records.
type FromRecList struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.ListEval = (*FromRecList)(nil)

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_recs",
	}
}

const FromRecList_Type = "from_rec_list"
const FromRecList_Field_Var = "$VAR"

func (op *FromRecList) Marshal(m jsn.Marshaler) error {
	return FromRecList_Marshal(m, op)
}

type FromRecList_Slice []FromRecList

func (op *FromRecList_Slice) GetType() string { return FromRecList_Type }

func (op *FromRecList_Slice) Marshal(m jsn.Marshaler) error {
	return FromRecList_Repeats_Marshal(m, (*[]FromRecList)(op))
}

func (op *FromRecList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *FromRecList_Slice) SetSize(cnt int) {
	var els []FromRecList
	if cnt >= 0 {
		els = make(FromRecList_Slice, cnt)
	}
	(*op) = els
}

func (op *FromRecList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return FromRecList_Marshal(m, &(*op)[i])
}

func FromRecList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromRecList) error {
	return jsn.RepeatBlock(m, (*FromRecList_Slice)(vals))
}

func FromRecList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]FromRecList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = FromRecList_Repeats_Marshal(m, pv)
	}
	return
}

type FromRecList_Flow struct{ ptr *FromRecList }

func (n FromRecList_Flow) GetType() string      { return FromRecList_Type }
func (n FromRecList_Flow) GetLede() string      { return "var_of_recs" }
func (n FromRecList_Flow) GetFlow() interface{} { return n.ptr }
func (n FromRecList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*FromRecList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func FromRecList_Optional_Marshal(m jsn.Marshaler, pv **FromRecList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromRecList_Marshal(m, *pv)
	} else if !enc {
		var v FromRecList
		if err = FromRecList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromRecList_Marshal(m jsn.Marshaler, val *FromRecList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(FromRecList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", FromRecList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromRecList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// FromTxtList Uses a list of text.
type FromTxtList struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.ListEval = (*FromTxtList)(nil)

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_txts",
	}
}

const FromTxtList_Type = "from_txt_list"
const FromTxtList_Field_Var = "$VAR"

func (op *FromTxtList) Marshal(m jsn.Marshaler) error {
	return FromTxtList_Marshal(m, op)
}

type FromTxtList_Slice []FromTxtList

func (op *FromTxtList_Slice) GetType() string { return FromTxtList_Type }

func (op *FromTxtList_Slice) Marshal(m jsn.Marshaler) error {
	return FromTxtList_Repeats_Marshal(m, (*[]FromTxtList)(op))
}

func (op *FromTxtList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *FromTxtList_Slice) SetSize(cnt int) {
	var els []FromTxtList
	if cnt >= 0 {
		els = make(FromTxtList_Slice, cnt)
	}
	(*op) = els
}

func (op *FromTxtList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return FromTxtList_Marshal(m, &(*op)[i])
}

func FromTxtList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromTxtList) error {
	return jsn.RepeatBlock(m, (*FromTxtList_Slice)(vals))
}

func FromTxtList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]FromTxtList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = FromTxtList_Repeats_Marshal(m, pv)
	}
	return
}

type FromTxtList_Flow struct{ ptr *FromTxtList }

func (n FromTxtList_Flow) GetType() string      { return FromTxtList_Type }
func (n FromTxtList_Flow) GetLede() string      { return "var_of_txts" }
func (n FromTxtList_Flow) GetFlow() interface{} { return n.ptr }
func (n FromTxtList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*FromTxtList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func FromTxtList_Optional_Marshal(m jsn.Marshaler, pv **FromTxtList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromTxtList_Marshal(m, *pv)
	} else if !enc {
		var v FromTxtList
		if err = FromTxtList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromTxtList_Marshal(m jsn.Marshaler, val *FromTxtList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(FromTxtList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", FromTxtList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromTxtList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoNumList Targets a list of numbers.
type IntoNumList struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ ListTarget = (*IntoNumList)(nil)

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_nums",
	}
}

const IntoNumList_Type = "into_num_list"
const IntoNumList_Field_Var = "$VAR"

func (op *IntoNumList) Marshal(m jsn.Marshaler) error {
	return IntoNumList_Marshal(m, op)
}

type IntoNumList_Slice []IntoNumList

func (op *IntoNumList_Slice) GetType() string { return IntoNumList_Type }

func (op *IntoNumList_Slice) Marshal(m jsn.Marshaler) error {
	return IntoNumList_Repeats_Marshal(m, (*[]IntoNumList)(op))
}

func (op *IntoNumList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *IntoNumList_Slice) SetSize(cnt int) {
	var els []IntoNumList
	if cnt >= 0 {
		els = make(IntoNumList_Slice, cnt)
	}
	(*op) = els
}

func (op *IntoNumList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return IntoNumList_Marshal(m, &(*op)[i])
}

func IntoNumList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoNumList) error {
	return jsn.RepeatBlock(m, (*IntoNumList_Slice)(vals))
}

func IntoNumList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]IntoNumList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = IntoNumList_Repeats_Marshal(m, pv)
	}
	return
}

type IntoNumList_Flow struct{ ptr *IntoNumList }

func (n IntoNumList_Flow) GetType() string      { return IntoNumList_Type }
func (n IntoNumList_Flow) GetLede() string      { return "into_nums" }
func (n IntoNumList_Flow) GetFlow() interface{} { return n.ptr }
func (n IntoNumList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*IntoNumList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func IntoNumList_Optional_Marshal(m jsn.Marshaler, pv **IntoNumList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoNumList_Marshal(m, *pv)
	} else if !enc {
		var v IntoNumList
		if err = IntoNumList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoNumList_Marshal(m jsn.Marshaler, val *IntoNumList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(IntoNumList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", IntoNumList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoNumList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoRecList Targets a list of records.
type IntoRecList struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ ListTarget = (*IntoRecList)(nil)

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_recs",
	}
}

const IntoRecList_Type = "into_rec_list"
const IntoRecList_Field_Var = "$VAR"

func (op *IntoRecList) Marshal(m jsn.Marshaler) error {
	return IntoRecList_Marshal(m, op)
}

type IntoRecList_Slice []IntoRecList

func (op *IntoRecList_Slice) GetType() string { return IntoRecList_Type }

func (op *IntoRecList_Slice) Marshal(m jsn.Marshaler) error {
	return IntoRecList_Repeats_Marshal(m, (*[]IntoRecList)(op))
}

func (op *IntoRecList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *IntoRecList_Slice) SetSize(cnt int) {
	var els []IntoRecList
	if cnt >= 0 {
		els = make(IntoRecList_Slice, cnt)
	}
	(*op) = els
}

func (op *IntoRecList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return IntoRecList_Marshal(m, &(*op)[i])
}

func IntoRecList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoRecList) error {
	return jsn.RepeatBlock(m, (*IntoRecList_Slice)(vals))
}

func IntoRecList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]IntoRecList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = IntoRecList_Repeats_Marshal(m, pv)
	}
	return
}

type IntoRecList_Flow struct{ ptr *IntoRecList }

func (n IntoRecList_Flow) GetType() string      { return IntoRecList_Type }
func (n IntoRecList_Flow) GetLede() string      { return "into_recs" }
func (n IntoRecList_Flow) GetFlow() interface{} { return n.ptr }
func (n IntoRecList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*IntoRecList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func IntoRecList_Optional_Marshal(m jsn.Marshaler, pv **IntoRecList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoRecList_Marshal(m, *pv)
	} else if !enc {
		var v IntoRecList
		if err = IntoRecList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoRecList_Marshal(m jsn.Marshaler, val *IntoRecList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(IntoRecList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", IntoRecList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoRecList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoTxtList Targets a list of text.
type IntoTxtList struct {
	Var    core.VariableName `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ ListTarget = (*IntoTxtList)(nil)

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_txts",
	}
}

const IntoTxtList_Type = "into_txt_list"
const IntoTxtList_Field_Var = "$VAR"

func (op *IntoTxtList) Marshal(m jsn.Marshaler) error {
	return IntoTxtList_Marshal(m, op)
}

type IntoTxtList_Slice []IntoTxtList

func (op *IntoTxtList_Slice) GetType() string { return IntoTxtList_Type }

func (op *IntoTxtList_Slice) Marshal(m jsn.Marshaler) error {
	return IntoTxtList_Repeats_Marshal(m, (*[]IntoTxtList)(op))
}

func (op *IntoTxtList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *IntoTxtList_Slice) SetSize(cnt int) {
	var els []IntoTxtList
	if cnt >= 0 {
		els = make(IntoTxtList_Slice, cnt)
	}
	(*op) = els
}

func (op *IntoTxtList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return IntoTxtList_Marshal(m, &(*op)[i])
}

func IntoTxtList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoTxtList) error {
	return jsn.RepeatBlock(m, (*IntoTxtList_Slice)(vals))
}

func IntoTxtList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]IntoTxtList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = IntoTxtList_Repeats_Marshal(m, pv)
	}
	return
}

type IntoTxtList_Flow struct{ ptr *IntoTxtList }

func (n IntoTxtList_Flow) GetType() string      { return IntoTxtList_Type }
func (n IntoTxtList_Flow) GetLede() string      { return "into_txts" }
func (n IntoTxtList_Flow) GetFlow() interface{} { return n.ptr }
func (n IntoTxtList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*IntoTxtList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func IntoTxtList_Optional_Marshal(m jsn.Marshaler, pv **IntoTxtList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoTxtList_Marshal(m, *pv)
	} else if !enc {
		var v IntoTxtList
		if err = IntoTxtList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoTxtList_Marshal(m jsn.Marshaler, val *IntoTxtList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(IntoTxtList_Flow{val}); err == nil {
		e0 := m.MarshalKey("", IntoTxtList_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoTxtList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// ListAt Get a value from a list. The first element is is index 1.
type ListAt struct {
	List   rt.ListEval   `if:"label=_"`
	Index  rt.NumberEval `if:"label=index"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumberEval = (*ListAt)(nil)
var _ rt.TextEval = (*ListAt)(nil)
var _ rt.RecordEval = (*ListAt)(nil)

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: ListAt_Type,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const ListAt_Type = "list_at"
const ListAt_Field_List = "$LIST"
const ListAt_Field_Index = "$INDEX"

func (op *ListAt) Marshal(m jsn.Marshaler) error {
	return ListAt_Marshal(m, op)
}

type ListAt_Slice []ListAt

func (op *ListAt_Slice) GetType() string { return ListAt_Type }

func (op *ListAt_Slice) Marshal(m jsn.Marshaler) error {
	return ListAt_Repeats_Marshal(m, (*[]ListAt)(op))
}

func (op *ListAt_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListAt_Slice) SetSize(cnt int) {
	var els []ListAt
	if cnt >= 0 {
		els = make(ListAt_Slice, cnt)
	}
	(*op) = els
}

func (op *ListAt_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListAt_Marshal(m, &(*op)[i])
}

func ListAt_Repeats_Marshal(m jsn.Marshaler, vals *[]ListAt) error {
	return jsn.RepeatBlock(m, (*ListAt_Slice)(vals))
}

func ListAt_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListAt) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListAt_Repeats_Marshal(m, pv)
	}
	return
}

type ListAt_Flow struct{ ptr *ListAt }

func (n ListAt_Flow) GetType() string      { return ListAt_Type }
func (n ListAt_Flow) GetLede() string      { return "get" }
func (n ListAt_Flow) GetFlow() interface{} { return n.ptr }
func (n ListAt_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListAt); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListAt_Optional_Marshal(m jsn.Marshaler, pv **ListAt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListAt_Marshal(m, *pv)
	} else if !enc {
		var v ListAt
		if err = ListAt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListAt_Marshal(m jsn.Marshaler, val *ListAt) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListAt_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListAt_Field_List)
		if e0 == nil {
			e0 = rt.ListEval_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListAt_Field_List))
		}
		e1 := m.MarshalKey("index", ListAt_Field_Index)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Index)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListAt_Field_Index))
		}
		m.EndBlock()
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the 'else' activity if empty.
type ListEach struct {
	List   rt.ListEval   `if:"label=across"`
	As     ListIterator  `if:"label=as"`
	Does   []rt.Execute  `if:"label=does"`
	Else   core.Brancher `if:"label=else,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListEach)(nil)

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: ListEach_Type,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const ListEach_Type = "list_each"
const ListEach_Field_List = "$LIST"
const ListEach_Field_As = "$AS"
const ListEach_Field_Does = "$DOES"
const ListEach_Field_Else = "$ELSE"

func (op *ListEach) Marshal(m jsn.Marshaler) error {
	return ListEach_Marshal(m, op)
}

type ListEach_Slice []ListEach

func (op *ListEach_Slice) GetType() string { return ListEach_Type }

func (op *ListEach_Slice) Marshal(m jsn.Marshaler) error {
	return ListEach_Repeats_Marshal(m, (*[]ListEach)(op))
}

func (op *ListEach_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListEach_Slice) SetSize(cnt int) {
	var els []ListEach
	if cnt >= 0 {
		els = make(ListEach_Slice, cnt)
	}
	(*op) = els
}

func (op *ListEach_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListEach_Marshal(m, &(*op)[i])
}

func ListEach_Repeats_Marshal(m jsn.Marshaler, vals *[]ListEach) error {
	return jsn.RepeatBlock(m, (*ListEach_Slice)(vals))
}

func ListEach_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListEach) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListEach_Repeats_Marshal(m, pv)
	}
	return
}

type ListEach_Flow struct{ ptr *ListEach }

func (n ListEach_Flow) GetType() string      { return ListEach_Type }
func (n ListEach_Flow) GetLede() string      { return "repeating" }
func (n ListEach_Flow) GetFlow() interface{} { return n.ptr }
func (n ListEach_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListEach); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListEach_Optional_Marshal(m jsn.Marshaler, pv **ListEach) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListEach_Marshal(m, *pv)
	} else if !enc {
		var v ListEach
		if err = ListEach_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListEach_Marshal(m jsn.Marshaler, val *ListEach) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListEach_Flow{val}); err == nil {
		e0 := m.MarshalKey("across", ListEach_Field_List)
		if e0 == nil {
			e0 = rt.ListEval_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListEach_Field_List))
		}
		e1 := m.MarshalKey("as", ListEach_Field_As)
		if e1 == nil {
			e1 = ListIterator_Marshal(m, &val.As)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListEach_Field_As))
		}
		e2 := m.MarshalKey("does", ListEach_Field_Does)
		if e2 == nil {
			e2 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListEach_Field_Does))
		}
		e3 := m.MarshalKey("else", ListEach_Field_Else)
		if e3 == nil {
			e3 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListEach_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// ListFindBool Search a list for a specific value.
type ListFindBool struct {
	Bool   rt.BoolEval `if:"label=bool"`
	InList rt.ListEval `if:"label=in_list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.BoolEval = (*ListFindBool)(nil)
var _ rt.NumberEval = (*ListFindBool)(nil)

func (*ListFindBool) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFindBool_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFindBool_Type = "list_find_bool"
const ListFindBool_Field_Bool = "$BOOL"
const ListFindBool_Field_InList = "$IN_LIST"

func (op *ListFindBool) Marshal(m jsn.Marshaler) error {
	return ListFindBool_Marshal(m, op)
}

type ListFindBool_Slice []ListFindBool

func (op *ListFindBool_Slice) GetType() string { return ListFindBool_Type }

func (op *ListFindBool_Slice) Marshal(m jsn.Marshaler) error {
	return ListFindBool_Repeats_Marshal(m, (*[]ListFindBool)(op))
}

func (op *ListFindBool_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListFindBool_Slice) SetSize(cnt int) {
	var els []ListFindBool
	if cnt >= 0 {
		els = make(ListFindBool_Slice, cnt)
	}
	(*op) = els
}

func (op *ListFindBool_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListFindBool_Marshal(m, &(*op)[i])
}

func ListFindBool_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFindBool) error {
	return jsn.RepeatBlock(m, (*ListFindBool_Slice)(vals))
}

func ListFindBool_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListFindBool) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListFindBool_Repeats_Marshal(m, pv)
	}
	return
}

type ListFindBool_Flow struct{ ptr *ListFindBool }

func (n ListFindBool_Flow) GetType() string      { return ListFindBool_Type }
func (n ListFindBool_Flow) GetLede() string      { return "find" }
func (n ListFindBool_Flow) GetFlow() interface{} { return n.ptr }
func (n ListFindBool_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListFindBool); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListFindBool_Optional_Marshal(m jsn.Marshaler, pv **ListFindBool) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFindBool_Marshal(m, *pv)
	} else if !enc {
		var v ListFindBool
		if err = ListFindBool_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFindBool_Marshal(m jsn.Marshaler, val *ListFindBool) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListFindBool_Flow{val}); err == nil {
		e0 := m.MarshalKey("bool", ListFindBool_Field_Bool)
		if e0 == nil {
			e0 = rt.BoolEval_Marshal(m, &val.Bool)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFindBool_Field_Bool))
		}
		e1 := m.MarshalKey("in_list", ListFindBool_Field_InList)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.InList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFindBool_Field_InList))
		}
		m.EndBlock()
	}
	return
}

// ListFindList Search a list for a specific value.
type ListFindList struct {
	List   rt.ListEval `if:"label=list"`
	InList rt.ListEval `if:"label=in_list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.BoolEval = (*ListFindList)(nil)
var _ rt.NumberEval = (*ListFindList)(nil)

func (*ListFindList) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFindList_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFindList_Type = "list_find_list"
const ListFindList_Field_List = "$LIST"
const ListFindList_Field_InList = "$IN_LIST"

func (op *ListFindList) Marshal(m jsn.Marshaler) error {
	return ListFindList_Marshal(m, op)
}

type ListFindList_Slice []ListFindList

func (op *ListFindList_Slice) GetType() string { return ListFindList_Type }

func (op *ListFindList_Slice) Marshal(m jsn.Marshaler) error {
	return ListFindList_Repeats_Marshal(m, (*[]ListFindList)(op))
}

func (op *ListFindList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListFindList_Slice) SetSize(cnt int) {
	var els []ListFindList
	if cnt >= 0 {
		els = make(ListFindList_Slice, cnt)
	}
	(*op) = els
}

func (op *ListFindList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListFindList_Marshal(m, &(*op)[i])
}

func ListFindList_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFindList) error {
	return jsn.RepeatBlock(m, (*ListFindList_Slice)(vals))
}

func ListFindList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListFindList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListFindList_Repeats_Marshal(m, pv)
	}
	return
}

type ListFindList_Flow struct{ ptr *ListFindList }

func (n ListFindList_Flow) GetType() string      { return ListFindList_Type }
func (n ListFindList_Flow) GetLede() string      { return "find" }
func (n ListFindList_Flow) GetFlow() interface{} { return n.ptr }
func (n ListFindList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListFindList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListFindList_Optional_Marshal(m jsn.Marshaler, pv **ListFindList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFindList_Marshal(m, *pv)
	} else if !enc {
		var v ListFindList
		if err = ListFindList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFindList_Marshal(m jsn.Marshaler, val *ListFindList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListFindList_Flow{val}); err == nil {
		e0 := m.MarshalKey("list", ListFindList_Field_List)
		if e0 == nil {
			e0 = rt.ListEval_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFindList_Field_List))
		}
		e1 := m.MarshalKey("in_list", ListFindList_Field_InList)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.InList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFindList_Field_InList))
		}
		m.EndBlock()
	}
	return
}

// ListFindNumber Search a list for a specific value.
type ListFindNumber struct {
	Number rt.NumberEval `if:"label=number"`
	InList rt.ListEval   `if:"label=in_list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.BoolEval = (*ListFindNumber)(nil)
var _ rt.NumberEval = (*ListFindNumber)(nil)

func (*ListFindNumber) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFindNumber_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFindNumber_Type = "list_find_number"
const ListFindNumber_Field_Number = "$NUMBER"
const ListFindNumber_Field_InList = "$IN_LIST"

func (op *ListFindNumber) Marshal(m jsn.Marshaler) error {
	return ListFindNumber_Marshal(m, op)
}

type ListFindNumber_Slice []ListFindNumber

func (op *ListFindNumber_Slice) GetType() string { return ListFindNumber_Type }

func (op *ListFindNumber_Slice) Marshal(m jsn.Marshaler) error {
	return ListFindNumber_Repeats_Marshal(m, (*[]ListFindNumber)(op))
}

func (op *ListFindNumber_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListFindNumber_Slice) SetSize(cnt int) {
	var els []ListFindNumber
	if cnt >= 0 {
		els = make(ListFindNumber_Slice, cnt)
	}
	(*op) = els
}

func (op *ListFindNumber_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListFindNumber_Marshal(m, &(*op)[i])
}

func ListFindNumber_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFindNumber) error {
	return jsn.RepeatBlock(m, (*ListFindNumber_Slice)(vals))
}

func ListFindNumber_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListFindNumber) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListFindNumber_Repeats_Marshal(m, pv)
	}
	return
}

type ListFindNumber_Flow struct{ ptr *ListFindNumber }

func (n ListFindNumber_Flow) GetType() string      { return ListFindNumber_Type }
func (n ListFindNumber_Flow) GetLede() string      { return "find" }
func (n ListFindNumber_Flow) GetFlow() interface{} { return n.ptr }
func (n ListFindNumber_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListFindNumber); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListFindNumber_Optional_Marshal(m jsn.Marshaler, pv **ListFindNumber) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFindNumber_Marshal(m, *pv)
	} else if !enc {
		var v ListFindNumber
		if err = ListFindNumber_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFindNumber_Marshal(m jsn.Marshaler, val *ListFindNumber) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListFindNumber_Flow{val}); err == nil {
		e0 := m.MarshalKey("number", ListFindNumber_Field_Number)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Number)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFindNumber_Field_Number))
		}
		e1 := m.MarshalKey("in_list", ListFindNumber_Field_InList)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.InList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFindNumber_Field_InList))
		}
		m.EndBlock()
	}
	return
}

// ListFindRecord Search a list for a specific value.
type ListFindRecord struct {
	Record rt.RecordEval `if:"label=record"`
	InList rt.ListEval   `if:"label=in_list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.BoolEval = (*ListFindRecord)(nil)
var _ rt.NumberEval = (*ListFindRecord)(nil)

func (*ListFindRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFindRecord_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFindRecord_Type = "list_find_record"
const ListFindRecord_Field_Record = "$RECORD"
const ListFindRecord_Field_InList = "$IN_LIST"

func (op *ListFindRecord) Marshal(m jsn.Marshaler) error {
	return ListFindRecord_Marshal(m, op)
}

type ListFindRecord_Slice []ListFindRecord

func (op *ListFindRecord_Slice) GetType() string { return ListFindRecord_Type }

func (op *ListFindRecord_Slice) Marshal(m jsn.Marshaler) error {
	return ListFindRecord_Repeats_Marshal(m, (*[]ListFindRecord)(op))
}

func (op *ListFindRecord_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListFindRecord_Slice) SetSize(cnt int) {
	var els []ListFindRecord
	if cnt >= 0 {
		els = make(ListFindRecord_Slice, cnt)
	}
	(*op) = els
}

func (op *ListFindRecord_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListFindRecord_Marshal(m, &(*op)[i])
}

func ListFindRecord_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFindRecord) error {
	return jsn.RepeatBlock(m, (*ListFindRecord_Slice)(vals))
}

func ListFindRecord_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListFindRecord) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListFindRecord_Repeats_Marshal(m, pv)
	}
	return
}

type ListFindRecord_Flow struct{ ptr *ListFindRecord }

func (n ListFindRecord_Flow) GetType() string      { return ListFindRecord_Type }
func (n ListFindRecord_Flow) GetLede() string      { return "find" }
func (n ListFindRecord_Flow) GetFlow() interface{} { return n.ptr }
func (n ListFindRecord_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListFindRecord); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListFindRecord_Optional_Marshal(m jsn.Marshaler, pv **ListFindRecord) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFindRecord_Marshal(m, *pv)
	} else if !enc {
		var v ListFindRecord
		if err = ListFindRecord_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFindRecord_Marshal(m jsn.Marshaler, val *ListFindRecord) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListFindRecord_Flow{val}); err == nil {
		e0 := m.MarshalKey("record", ListFindRecord_Field_Record)
		if e0 == nil {
			e0 = rt.RecordEval_Marshal(m, &val.Record)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFindRecord_Field_Record))
		}
		e1 := m.MarshalKey("in_list", ListFindRecord_Field_InList)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.InList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFindRecord_Field_InList))
		}
		m.EndBlock()
	}
	return
}

// ListFindText Search a list for a specific value.
type ListFindText struct {
	Text   rt.TextEval `if:"label=text"`
	InList rt.ListEval `if:"label=in_list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.BoolEval = (*ListFindText)(nil)
var _ rt.NumberEval = (*ListFindText)(nil)

func (*ListFindText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFindText_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFindText_Type = "list_find_text"
const ListFindText_Field_Text = "$TEXT"
const ListFindText_Field_InList = "$IN_LIST"

func (op *ListFindText) Marshal(m jsn.Marshaler) error {
	return ListFindText_Marshal(m, op)
}

type ListFindText_Slice []ListFindText

func (op *ListFindText_Slice) GetType() string { return ListFindText_Type }

func (op *ListFindText_Slice) Marshal(m jsn.Marshaler) error {
	return ListFindText_Repeats_Marshal(m, (*[]ListFindText)(op))
}

func (op *ListFindText_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListFindText_Slice) SetSize(cnt int) {
	var els []ListFindText
	if cnt >= 0 {
		els = make(ListFindText_Slice, cnt)
	}
	(*op) = els
}

func (op *ListFindText_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListFindText_Marshal(m, &(*op)[i])
}

func ListFindText_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFindText) error {
	return jsn.RepeatBlock(m, (*ListFindText_Slice)(vals))
}

func ListFindText_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListFindText) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListFindText_Repeats_Marshal(m, pv)
	}
	return
}

type ListFindText_Flow struct{ ptr *ListFindText }

func (n ListFindText_Flow) GetType() string      { return ListFindText_Type }
func (n ListFindText_Flow) GetLede() string      { return "find" }
func (n ListFindText_Flow) GetFlow() interface{} { return n.ptr }
func (n ListFindText_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListFindText); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListFindText_Optional_Marshal(m jsn.Marshaler, pv **ListFindText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFindText_Marshal(m, *pv)
	} else if !enc {
		var v ListFindText
		if err = ListFindText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFindText_Marshal(m jsn.Marshaler, val *ListFindText) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListFindText_Flow{val}); err == nil {
		e0 := m.MarshalKey("text", ListFindText_Field_Text)
		if e0 == nil {
			e0 = rt.TextEval_Marshal(m, &val.Text)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFindText_Field_Text))
		}
		e1 := m.MarshalKey("in_list", ListFindText_Field_InList)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.InList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFindText_Field_InList))
		}
		m.EndBlock()
	}
	return
}

// ListGather Transform the values from a list.
// The named pattern gets called once for each value in the list.
// It get called with two parameters: 'in' as each value from the list, and 'out' as the var passed to the gather.
type ListGather struct {
	Var    core.VariableName `if:"label=_"`
	From   rt.ListEval       `if:"label=from"`
	Using  string            `if:"label=using,type=text"`
	Markup map[string]any
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: ListGather_Type,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const ListGather_Type = "list_gather"
const ListGather_Field_Var = "$VAR"
const ListGather_Field_From = "$FROM"
const ListGather_Field_Using = "$USING"

func (op *ListGather) Marshal(m jsn.Marshaler) error {
	return ListGather_Marshal(m, op)
}

type ListGather_Slice []ListGather

func (op *ListGather_Slice) GetType() string { return ListGather_Type }

func (op *ListGather_Slice) Marshal(m jsn.Marshaler) error {
	return ListGather_Repeats_Marshal(m, (*[]ListGather)(op))
}

func (op *ListGather_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListGather_Slice) SetSize(cnt int) {
	var els []ListGather
	if cnt >= 0 {
		els = make(ListGather_Slice, cnt)
	}
	(*op) = els
}

func (op *ListGather_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListGather_Marshal(m, &(*op)[i])
}

func ListGather_Repeats_Marshal(m jsn.Marshaler, vals *[]ListGather) error {
	return jsn.RepeatBlock(m, (*ListGather_Slice)(vals))
}

func ListGather_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListGather) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListGather_Repeats_Marshal(m, pv)
	}
	return
}

type ListGather_Flow struct{ ptr *ListGather }

func (n ListGather_Flow) GetType() string      { return ListGather_Type }
func (n ListGather_Flow) GetLede() string      { return "gather" }
func (n ListGather_Flow) GetFlow() interface{} { return n.ptr }
func (n ListGather_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListGather); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListGather_Optional_Marshal(m jsn.Marshaler, pv **ListGather) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListGather_Marshal(m, *pv)
	} else if !enc {
		var v ListGather
		if err = ListGather_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListGather_Marshal(m jsn.Marshaler, val *ListGather) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListGather_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListGather_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListGather_Field_Var))
		}
		e1 := m.MarshalKey("from", ListGather_Field_From)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListGather_Field_From))
		}
		e2 := m.MarshalKey("using", ListGather_Field_Using)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.Using)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListGather_Field_Using))
		}
		m.EndBlock()
	}
	return
}

const ListIterator_Type = "list_iterator"

var ListIterator_Optional_Marshal = ListIterator_Marshal

type ListIterator_Slot struct{ Value *ListIterator }

func (at ListIterator_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at ListIterator_Slot) GetType() string              { return ListIterator_Type }
func (at ListIterator_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at ListIterator_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(ListIterator)
	return
}

func ListIterator_Marshal(m jsn.Marshaler, ptr *ListIterator) (err error) {
	slot := ListIterator_Slot{ptr}
	return slot.Marshal(m)
}

type ListIterator_Slice []ListIterator

func (op *ListIterator_Slice) GetType() string { return ListIterator_Type }

func (op *ListIterator_Slice) Marshal(m jsn.Marshaler) error {
	return ListIterator_Repeats_Marshal(m, (*[]ListIterator)(op))
}

func (op *ListIterator_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListIterator_Slice) SetSize(cnt int) {
	var els []ListIterator
	if cnt >= 0 {
		els = make(ListIterator_Slice, cnt)
	}
	(*op) = els
}

func (op *ListIterator_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListIterator_Marshal(m, &(*op)[i])
}

func ListIterator_Repeats_Marshal(m jsn.Marshaler, vals *[]ListIterator) error {
	return jsn.RepeatBlock(m, (*ListIterator_Slice)(vals))
}

func ListIterator_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListIterator) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListIterator_Repeats_Marshal(m, pv)
	}
	return
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List   rt.ListEval `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumberEval = (*ListLen)(nil)

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: ListLen_Type,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const ListLen_Type = "list_len"
const ListLen_Field_List = "$LIST"

func (op *ListLen) Marshal(m jsn.Marshaler) error {
	return ListLen_Marshal(m, op)
}

type ListLen_Slice []ListLen

func (op *ListLen_Slice) GetType() string { return ListLen_Type }

func (op *ListLen_Slice) Marshal(m jsn.Marshaler) error {
	return ListLen_Repeats_Marshal(m, (*[]ListLen)(op))
}

func (op *ListLen_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListLen_Slice) SetSize(cnt int) {
	var els []ListLen
	if cnt >= 0 {
		els = make(ListLen_Slice, cnt)
	}
	(*op) = els
}

func (op *ListLen_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListLen_Marshal(m, &(*op)[i])
}

func ListLen_Repeats_Marshal(m jsn.Marshaler, vals *[]ListLen) error {
	return jsn.RepeatBlock(m, (*ListLen_Slice)(vals))
}

func ListLen_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListLen) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListLen_Repeats_Marshal(m, pv)
	}
	return
}

type ListLen_Flow struct{ ptr *ListLen }

func (n ListLen_Flow) GetType() string      { return ListLen_Type }
func (n ListLen_Flow) GetLede() string      { return "len" }
func (n ListLen_Flow) GetFlow() interface{} { return n.ptr }
func (n ListLen_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListLen); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListLen_Optional_Marshal(m jsn.Marshaler, pv **ListLen) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListLen_Marshal(m, *pv)
	} else if !enc {
		var v ListLen
		if err = ListLen_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListLen_Marshal(m jsn.Marshaler, val *ListLen) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListLen_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListLen_Field_List)
		if e0 == nil {
			e0 = rt.ListEval_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListLen_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListMap Transform the values from one list and place the results in another list.
// The designated pattern is called with each value from the 'from list', one value at a time.
type ListMap struct {
	ToList       string      `if:"label=_,type=text"`
	FromList     rt.ListEval `if:"label=from_list"`
	UsingPattern string      `if:"label=using,type=text"`
	Markup       map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListMap)(nil)

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: ListMap_Type,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const ListMap_Type = "list_map"
const ListMap_Field_ToList = "$TO_LIST"
const ListMap_Field_FromList = "$FROM_LIST"
const ListMap_Field_UsingPattern = "$USING_PATTERN"

func (op *ListMap) Marshal(m jsn.Marshaler) error {
	return ListMap_Marshal(m, op)
}

type ListMap_Slice []ListMap

func (op *ListMap_Slice) GetType() string { return ListMap_Type }

func (op *ListMap_Slice) Marshal(m jsn.Marshaler) error {
	return ListMap_Repeats_Marshal(m, (*[]ListMap)(op))
}

func (op *ListMap_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListMap_Slice) SetSize(cnt int) {
	var els []ListMap
	if cnt >= 0 {
		els = make(ListMap_Slice, cnt)
	}
	(*op) = els
}

func (op *ListMap_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListMap_Marshal(m, &(*op)[i])
}

func ListMap_Repeats_Marshal(m jsn.Marshaler, vals *[]ListMap) error {
	return jsn.RepeatBlock(m, (*ListMap_Slice)(vals))
}

func ListMap_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListMap) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListMap_Repeats_Marshal(m, pv)
	}
	return
}

type ListMap_Flow struct{ ptr *ListMap }

func (n ListMap_Flow) GetType() string      { return ListMap_Type }
func (n ListMap_Flow) GetLede() string      { return "map" }
func (n ListMap_Flow) GetFlow() interface{} { return n.ptr }
func (n ListMap_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListMap); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListMap_Optional_Marshal(m jsn.Marshaler, pv **ListMap) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListMap_Marshal(m, *pv)
	} else if !enc {
		var v ListMap
		if err = ListMap_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListMap_Marshal(m jsn.Marshaler, val *ListMap) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListMap_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListMap_Field_ToList)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.ToList)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListMap_Field_ToList))
		}
		e1 := m.MarshalKey("from_list", ListMap_Field_FromList)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.FromList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListMap_Field_FromList))
		}
		e2 := m.MarshalKey("using", ListMap_Field_UsingPattern)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.UsingPattern)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListMap_Field_UsingPattern))
		}
		m.EndBlock()
	}
	return
}

// ListPush Add a value to a list.
type ListPush struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListPush)(nil)

func (*ListPush) Compose() composer.Spec {
	return composer.Spec{
		Name: ListPush_Type,
		Uses: composer.Type_Flow,
		Lede: "push",
	}
}

const ListPush_Type = "list_push"
const ListPush_Field_From = "$FROM"
const ListPush_Field_Into = "$INTO"
const ListPush_Field_AtEdge = "$AT_EDGE"

func (op *ListPush) Marshal(m jsn.Marshaler) error {
	return ListPush_Marshal(m, op)
}

type ListPush_Slice []ListPush

func (op *ListPush_Slice) GetType() string { return ListPush_Type }

func (op *ListPush_Slice) Marshal(m jsn.Marshaler) error {
	return ListPush_Repeats_Marshal(m, (*[]ListPush)(op))
}

func (op *ListPush_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListPush_Slice) SetSize(cnt int) {
	var els []ListPush
	if cnt >= 0 {
		els = make(ListPush_Slice, cnt)
	}
	(*op) = els
}

func (op *ListPush_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListPush_Marshal(m, &(*op)[i])
}

func ListPush_Repeats_Marshal(m jsn.Marshaler, vals *[]ListPush) error {
	return jsn.RepeatBlock(m, (*ListPush_Slice)(vals))
}

func ListPush_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListPush) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListPush_Repeats_Marshal(m, pv)
	}
	return
}

type ListPush_Flow struct{ ptr *ListPush }

func (n ListPush_Flow) GetType() string      { return ListPush_Type }
func (n ListPush_Flow) GetLede() string      { return "push" }
func (n ListPush_Flow) GetFlow() interface{} { return n.ptr }
func (n ListPush_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListPush); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListPush_Optional_Marshal(m jsn.Marshaler, pv **ListPush) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListPush_Marshal(m, *pv)
	} else if !enc {
		var v ListPush
		if err = ListPush_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListPush_Marshal(m jsn.Marshaler, val *ListPush) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListPush_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListPush_Field_From)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListPush_Field_From))
		}
		e1 := m.MarshalKey("into", ListPush_Field_Into)
		if e1 == nil {
			e1 = ListTarget_Marshal(m, &val.Into)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListPush_Field_Into))
		}
		e2 := m.MarshalKey("at_front", ListPush_Field_AtEdge)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListPush_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// ListReduce Combine all of the values in a list, and store the result in a variable.
// The named pattern is called with two parameters: 'in' ( each element of the list ) and 'out' ( ex. a record ).
type ListReduce struct {
	IntoValue    string      `if:"label=into,type=text"`
	FromList     rt.ListEval `if:"label=from_list"`
	UsingPattern string      `if:"label=using,type=text"`
	Markup       map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListReduce)(nil)

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReduce_Type,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const ListReduce_Type = "list_reduce"
const ListReduce_Field_IntoValue = "$INTO_VALUE"
const ListReduce_Field_FromList = "$FROM_LIST"
const ListReduce_Field_UsingPattern = "$USING_PATTERN"

func (op *ListReduce) Marshal(m jsn.Marshaler) error {
	return ListReduce_Marshal(m, op)
}

type ListReduce_Slice []ListReduce

func (op *ListReduce_Slice) GetType() string { return ListReduce_Type }

func (op *ListReduce_Slice) Marshal(m jsn.Marshaler) error {
	return ListReduce_Repeats_Marshal(m, (*[]ListReduce)(op))
}

func (op *ListReduce_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListReduce_Slice) SetSize(cnt int) {
	var els []ListReduce
	if cnt >= 0 {
		els = make(ListReduce_Slice, cnt)
	}
	(*op) = els
}

func (op *ListReduce_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListReduce_Marshal(m, &(*op)[i])
}

func ListReduce_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReduce) error {
	return jsn.RepeatBlock(m, (*ListReduce_Slice)(vals))
}

func ListReduce_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListReduce) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListReduce_Repeats_Marshal(m, pv)
	}
	return
}

type ListReduce_Flow struct{ ptr *ListReduce }

func (n ListReduce_Flow) GetType() string      { return ListReduce_Type }
func (n ListReduce_Flow) GetLede() string      { return "reduce" }
func (n ListReduce_Flow) GetFlow() interface{} { return n.ptr }
func (n ListReduce_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListReduce); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListReduce_Optional_Marshal(m jsn.Marshaler, pv **ListReduce) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReduce_Marshal(m, *pv)
	} else if !enc {
		var v ListReduce
		if err = ListReduce_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReduce_Marshal(m jsn.Marshaler, val *ListReduce) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListReduce_Flow{val}); err == nil {
		e0 := m.MarshalKey("into", ListReduce_Field_IntoValue)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.IntoValue)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReduce_Field_IntoValue))
		}
		e1 := m.MarshalKey("from_list", ListReduce_Field_FromList)
		if e1 == nil {
			e1 = rt.ListEval_Marshal(m, &val.FromList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListReduce_Field_FromList))
		}
		e2 := m.MarshalKey("using", ListReduce_Field_UsingPattern)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.UsingPattern)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListReduce_Field_UsingPattern))
		}
		m.EndBlock()
	}
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	List   rt.ListEval `if:"label=list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListReverse)(nil)

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReverse_Type,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const ListReverse_Type = "list_reverse"
const ListReverse_Field_List = "$LIST"

func (op *ListReverse) Marshal(m jsn.Marshaler) error {
	return ListReverse_Marshal(m, op)
}

type ListReverse_Slice []ListReverse

func (op *ListReverse_Slice) GetType() string { return ListReverse_Type }

func (op *ListReverse_Slice) Marshal(m jsn.Marshaler) error {
	return ListReverse_Repeats_Marshal(m, (*[]ListReverse)(op))
}

func (op *ListReverse_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListReverse_Slice) SetSize(cnt int) {
	var els []ListReverse
	if cnt >= 0 {
		els = make(ListReverse_Slice, cnt)
	}
	(*op) = els
}

func (op *ListReverse_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListReverse_Marshal(m, &(*op)[i])
}

func ListReverse_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReverse) error {
	return jsn.RepeatBlock(m, (*ListReverse_Slice)(vals))
}

func ListReverse_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListReverse) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListReverse_Repeats_Marshal(m, pv)
	}
	return
}

type ListReverse_Flow struct{ ptr *ListReverse }

func (n ListReverse_Flow) GetType() string      { return ListReverse_Type }
func (n ListReverse_Flow) GetLede() string      { return "reverse" }
func (n ListReverse_Flow) GetFlow() interface{} { return n.ptr }
func (n ListReverse_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListReverse); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListReverse_Optional_Marshal(m jsn.Marshaler, pv **ListReverse) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReverse_Marshal(m, *pv)
	} else if !enc {
		var v ListReverse
		if err = ListReverse_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReverse_Marshal(m jsn.Marshaler, val *ListReverse) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListReverse_Flow{val}); err == nil {
		e0 := m.MarshalKey("list", ListReverse_Field_List)
		if e0 == nil {
			e0 = rt.ListEval_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReverse_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListSet Overwrite an existing value in a list.
type ListSet struct {
	List   string        `if:"label=_,type=text"`
	Index  rt.NumberEval `if:"label=index"`
	From   rt.Assignment `if:"label=from"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSet)(nil)

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSet_Type,
		Uses: composer.Type_Flow,
		Lede: "set",
	}
}

const ListSet_Type = "list_set"
const ListSet_Field_List = "$LIST"
const ListSet_Field_Index = "$INDEX"
const ListSet_Field_From = "$FROM"

func (op *ListSet) Marshal(m jsn.Marshaler) error {
	return ListSet_Marshal(m, op)
}

type ListSet_Slice []ListSet

func (op *ListSet_Slice) GetType() string { return ListSet_Type }

func (op *ListSet_Slice) Marshal(m jsn.Marshaler) error {
	return ListSet_Repeats_Marshal(m, (*[]ListSet)(op))
}

func (op *ListSet_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSet_Slice) SetSize(cnt int) {
	var els []ListSet
	if cnt >= 0 {
		els = make(ListSet_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSet_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSet_Marshal(m, &(*op)[i])
}

func ListSet_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSet) error {
	return jsn.RepeatBlock(m, (*ListSet_Slice)(vals))
}

func ListSet_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSet) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSet_Repeats_Marshal(m, pv)
	}
	return
}

type ListSet_Flow struct{ ptr *ListSet }

func (n ListSet_Flow) GetType() string      { return ListSet_Type }
func (n ListSet_Flow) GetLede() string      { return "set" }
func (n ListSet_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSet_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSet); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSet_Optional_Marshal(m jsn.Marshaler, pv **ListSet) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSet_Marshal(m, *pv)
	} else if !enc {
		var v ListSet
		if err = ListSet_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSet_Marshal(m jsn.Marshaler, val *ListSet) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSet_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSet_Field_List)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSet_Field_List))
		}
		e1 := m.MarshalKey("index", ListSet_Field_Index)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Index)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSet_Field_Index))
		}
		e2 := m.MarshalKey("from", ListSet_Field_From)
		if e2 == nil {
			e2 = rt.Assignment_Marshal(m, &val.From)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSet_Field_From))
		}
		m.EndBlock()
	}
	return
}

// ListSlice Create a new list from a section of another list.
// Start is optional, if omitted slice starts at the first element.
// If start is greater the length, an empty array is returned.
// Slice doesnt include the ending index.
// Negatives indices indicates an offset from the end.
// When end is omitted, copy up to and including the last element;
// and do the same if the end is greater than the length
type ListSlice struct {
	List   rt.ListEval   `if:"label=_"`
	Start  rt.NumberEval `if:"label=start,optional"`
	End    rt.NumberEval `if:"label=end,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumListEval = (*ListSlice)(nil)
var _ rt.TextListEval = (*ListSlice)(nil)
var _ rt.RecordListEval = (*ListSlice)(nil)

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSlice_Type,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const ListSlice_Type = "list_slice"
const ListSlice_Field_List = "$LIST"
const ListSlice_Field_Start = "$START"
const ListSlice_Field_End = "$END"

func (op *ListSlice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Marshal(m, op)
}

type ListSlice_Slice []ListSlice

func (op *ListSlice_Slice) GetType() string { return ListSlice_Type }

func (op *ListSlice_Slice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Repeats_Marshal(m, (*[]ListSlice)(op))
}

func (op *ListSlice_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSlice_Slice) SetSize(cnt int) {
	var els []ListSlice
	if cnt >= 0 {
		els = make(ListSlice_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSlice_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSlice_Marshal(m, &(*op)[i])
}

func ListSlice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSlice) error {
	return jsn.RepeatBlock(m, (*ListSlice_Slice)(vals))
}

func ListSlice_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSlice) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSlice_Repeats_Marshal(m, pv)
	}
	return
}

type ListSlice_Flow struct{ ptr *ListSlice }

func (n ListSlice_Flow) GetType() string      { return ListSlice_Type }
func (n ListSlice_Flow) GetLede() string      { return "slice" }
func (n ListSlice_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSlice_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSlice); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSlice_Optional_Marshal(m jsn.Marshaler, pv **ListSlice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSlice_Marshal(m, *pv)
	} else if !enc {
		var v ListSlice
		if err = ListSlice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSlice_Marshal(m jsn.Marshaler, val *ListSlice) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSlice_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSlice_Field_List)
		if e0 == nil {
			e0 = rt.ListEval_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSlice_Field_List))
		}
		e1 := m.MarshalKey("start", ListSlice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSlice_Field_Start))
		}
		e2 := m.MarshalKey("end", ListSlice_Field_End)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.End)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSlice_Field_End))
		}
		m.EndBlock()
	}
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Var        core.VariableName `if:"label=_"`
	ByField    string            `if:"label=by_field,type=text"`
	Descending rt.BoolEval       `if:"label=descending,optional"`
	Markup     map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSortNumbers)(nil)

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortNumbers_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_numbers",
	}
}

const ListSortNumbers_Type = "list_sort_numbers"
const ListSortNumbers_Field_Var = "$VAR"
const ListSortNumbers_Field_ByField = "$BY_FIELD"
const ListSortNumbers_Field_Descending = "$DESCENDING"

func (op *ListSortNumbers) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Marshal(m, op)
}

type ListSortNumbers_Slice []ListSortNumbers

func (op *ListSortNumbers_Slice) GetType() string { return ListSortNumbers_Type }

func (op *ListSortNumbers_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Repeats_Marshal(m, (*[]ListSortNumbers)(op))
}

func (op *ListSortNumbers_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortNumbers_Slice) SetSize(cnt int) {
	var els []ListSortNumbers
	if cnt >= 0 {
		els = make(ListSortNumbers_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortNumbers_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortNumbers_Marshal(m, &(*op)[i])
}

func ListSortNumbers_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortNumbers) error {
	return jsn.RepeatBlock(m, (*ListSortNumbers_Slice)(vals))
}

func ListSortNumbers_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortNumbers) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSortNumbers_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortNumbers_Flow struct{ ptr *ListSortNumbers }

func (n ListSortNumbers_Flow) GetType() string      { return ListSortNumbers_Type }
func (n ListSortNumbers_Flow) GetLede() string      { return "sort_numbers" }
func (n ListSortNumbers_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortNumbers_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortNumbers); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortNumbers_Optional_Marshal(m jsn.Marshaler, pv **ListSortNumbers) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortNumbers_Marshal(m, *pv)
	} else if !enc {
		var v ListSortNumbers
		if err = ListSortNumbers_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortNumbers_Marshal(m jsn.Marshaler, val *ListSortNumbers) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSortNumbers_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortNumbers_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortNumbers_Field_Var))
		}
		e1 := m.MarshalKey("by_field", ListSortNumbers_Field_ByField)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortNumbers_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortNumbers_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortNumbers_Field_Descending))
		}
		m.EndBlock()
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Var        core.VariableName `if:"label=_"`
	ByField    string            `if:"label=by_field,type=text"`
	Descending rt.BoolEval       `if:"label=descending,optional"`
	UsingCase  rt.BoolEval       `if:"label=using_case,optional"`
	Markup     map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSortText)(nil)

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortText_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_texts",
	}
}

const ListSortText_Type = "list_sort_text"
const ListSortText_Field_Var = "$VAR"
const ListSortText_Field_ByField = "$BY_FIELD"
const ListSortText_Field_Descending = "$DESCENDING"
const ListSortText_Field_UsingCase = "$USING_CASE"

func (op *ListSortText) Marshal(m jsn.Marshaler) error {
	return ListSortText_Marshal(m, op)
}

type ListSortText_Slice []ListSortText

func (op *ListSortText_Slice) GetType() string { return ListSortText_Type }

func (op *ListSortText_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortText_Repeats_Marshal(m, (*[]ListSortText)(op))
}

func (op *ListSortText_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortText_Slice) SetSize(cnt int) {
	var els []ListSortText
	if cnt >= 0 {
		els = make(ListSortText_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortText_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortText_Marshal(m, &(*op)[i])
}

func ListSortText_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortText) error {
	return jsn.RepeatBlock(m, (*ListSortText_Slice)(vals))
}

func ListSortText_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortText) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSortText_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortText_Flow struct{ ptr *ListSortText }

func (n ListSortText_Flow) GetType() string      { return ListSortText_Type }
func (n ListSortText_Flow) GetLede() string      { return "sort_texts" }
func (n ListSortText_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortText_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortText); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortText_Optional_Marshal(m jsn.Marshaler, pv **ListSortText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortText_Marshal(m, *pv)
	} else if !enc {
		var v ListSortText
		if err = ListSortText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortText_Marshal(m jsn.Marshaler, val *ListSortText) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSortText_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortText_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortText_Field_Var))
		}
		e1 := m.MarshalKey("by_field", ListSortText_Field_ByField)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortText_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortText_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortText_Field_Descending))
		}
		e3 := m.MarshalKey("using_case", ListSortText_Field_UsingCase)
		if e3 == nil {
			e3 = rt.BoolEval_Optional_Marshal(m, &val.UsingCase)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSortText_Field_UsingCase))
		}
		m.EndBlock()
	}
	return
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortUsing struct {
	Var    core.VariableName `if:"label=_"`
	Using  string            `if:"label=using,type=text"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSortUsing)(nil)

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortUsing_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortUsing_Type = "list_sort_using"
const ListSortUsing_Field_Var = "$VAR"
const ListSortUsing_Field_Using = "$USING"

func (op *ListSortUsing) Marshal(m jsn.Marshaler) error {
	return ListSortUsing_Marshal(m, op)
}

type ListSortUsing_Slice []ListSortUsing

func (op *ListSortUsing_Slice) GetType() string { return ListSortUsing_Type }

func (op *ListSortUsing_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortUsing_Repeats_Marshal(m, (*[]ListSortUsing)(op))
}

func (op *ListSortUsing_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortUsing_Slice) SetSize(cnt int) {
	var els []ListSortUsing
	if cnt >= 0 {
		els = make(ListSortUsing_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortUsing_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortUsing_Marshal(m, &(*op)[i])
}

func ListSortUsing_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortUsing) error {
	return jsn.RepeatBlock(m, (*ListSortUsing_Slice)(vals))
}

func ListSortUsing_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortUsing) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSortUsing_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortUsing_Flow struct{ ptr *ListSortUsing }

func (n ListSortUsing_Flow) GetType() string      { return ListSortUsing_Type }
func (n ListSortUsing_Flow) GetLede() string      { return "sort" }
func (n ListSortUsing_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortUsing_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortUsing); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortUsing_Optional_Marshal(m jsn.Marshaler, pv **ListSortUsing) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortUsing_Marshal(m, *pv)
	} else if !enc {
		var v ListSortUsing
		if err = ListSortUsing_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortUsing_Marshal(m jsn.Marshaler, val *ListSortUsing) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSortUsing_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortUsing_Field_Var)
		if e0 == nil {
			e0 = core.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortUsing_Field_Var))
		}
		e1 := m.MarshalKey("using", ListSortUsing_Field_Using)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.Using)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortUsing_Field_Using))
		}
		m.EndBlock()
	}
	return
}

// ListSplice Modify a list by adding and removing elements.
// The type of the elements being added must match the type of the list.
// Text cant be added to a list of numbers, numbers cant be added to a list of text.
// If the starting index is negative, this begins that many elements from the end of the array;
// if list's length plus the start is less than zero, this begins from index zero.
// If the remove count is missing, this removes all elements from the start to the end;
// if the remove count is zero or negative, no elements are removed.
type ListSplice struct {
	List   string        `if:"label=_,type=text"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSplice)(nil)
var _ rt.NumListEval = (*ListSplice)(nil)
var _ rt.TextListEval = (*ListSplice)(nil)
var _ rt.RecordListEval = (*ListSplice)(nil)

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSplice_Type,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const ListSplice_Type = "list_splice"
const ListSplice_Field_List = "$LIST"
const ListSplice_Field_Start = "$START"
const ListSplice_Field_Remove = "$REMOVE"
const ListSplice_Field_Insert = "$INSERT"

func (op *ListSplice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Marshal(m, op)
}

type ListSplice_Slice []ListSplice

func (op *ListSplice_Slice) GetType() string { return ListSplice_Type }

func (op *ListSplice_Slice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Repeats_Marshal(m, (*[]ListSplice)(op))
}

func (op *ListSplice_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSplice_Slice) SetSize(cnt int) {
	var els []ListSplice
	if cnt >= 0 {
		els = make(ListSplice_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSplice_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSplice_Marshal(m, &(*op)[i])
}

func ListSplice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSplice) error {
	return jsn.RepeatBlock(m, (*ListSplice_Slice)(vals))
}

func ListSplice_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSplice) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSplice_Repeats_Marshal(m, pv)
	}
	return
}

type ListSplice_Flow struct{ ptr *ListSplice }

func (n ListSplice_Flow) GetType() string      { return ListSplice_Type }
func (n ListSplice_Flow) GetLede() string      { return "splice" }
func (n ListSplice_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSplice_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSplice); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSplice_Optional_Marshal(m jsn.Marshaler, pv **ListSplice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSplice_Marshal(m, *pv)
	} else if !enc {
		var v ListSplice
		if err = ListSplice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSplice_Marshal(m jsn.Marshaler, val *ListSplice) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSplice_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSplice_Field_List)
		if e0 == nil {
			e0 = prim.Text_Unboxed_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSplice_Field_List))
		}
		e1 := m.MarshalKey("start", ListSplice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSplice_Field_Start))
		}
		e2 := m.MarshalKey("remove", ListSplice_Field_Remove)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.Remove)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSplice_Field_Remove))
		}
		e3 := m.MarshalKey("insert", ListSplice_Field_Insert)
		if e3 == nil {
			e3 = rt.Assignment_Marshal(m, &val.Insert)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSplice_Field_Insert))
		}
		m.EndBlock()
	}
	return
}

const ListTarget_Type = "list_target"

var ListTarget_Optional_Marshal = ListTarget_Marshal

type ListTarget_Slot struct{ Value *ListTarget }

func (at ListTarget_Slot) Marshal(m jsn.Marshaler) (err error) {
	if err = m.MarshalBlock(at); err == nil {
		if a, ok := at.GetSlot(); ok {
			if e := a.(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
				m.Error(e)
			}
		}
		m.EndBlock()
	}
	return
}
func (at ListTarget_Slot) GetType() string              { return ListTarget_Type }
func (at ListTarget_Slot) GetSlot() (interface{}, bool) { return *at.Value, *at.Value != nil }
func (at ListTarget_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.Value), okay = v.(ListTarget)
	return
}

func ListTarget_Marshal(m jsn.Marshaler, ptr *ListTarget) (err error) {
	slot := ListTarget_Slot{ptr}
	return slot.Marshal(m)
}

type ListTarget_Slice []ListTarget

func (op *ListTarget_Slice) GetType() string { return ListTarget_Type }

func (op *ListTarget_Slice) Marshal(m jsn.Marshaler) error {
	return ListTarget_Repeats_Marshal(m, (*[]ListTarget)(op))
}

func (op *ListTarget_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListTarget_Slice) SetSize(cnt int) {
	var els []ListTarget
	if cnt >= 0 {
		els = make(ListTarget_Slice, cnt)
	}
	(*op) = els
}

func (op *ListTarget_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListTarget_Marshal(m, &(*op)[i])
}

func ListTarget_Repeats_Marshal(m jsn.Marshaler, vals *[]ListTarget) error {
	return jsn.RepeatBlock(m, (*ListTarget_Slice)(vals))
}

func ListTarget_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListTarget) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListTarget_Repeats_Marshal(m, pv)
	}
	return
}

// Range Generates a series of numbers r[i] = (start + step*i) where i>=0.
// Start and step default to 1, stop defaults to start;
// the inputs are truncated to produce whole numbers;
// a zero step returns an error.
// A positive step ends the series when the returned value would exceed stop
// while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumListEval = (*Range)(nil)

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Range_Type,
		Uses: composer.Type_Flow,
	}
}

const Range_Type = "range"
const Range_Field_To = "$TO"
const Range_Field_From = "$FROM"
const Range_Field_ByStep = "$BY_STEP"

func (op *Range) Marshal(m jsn.Marshaler) error {
	return Range_Marshal(m, op)
}

type Range_Slice []Range

func (op *Range_Slice) GetType() string { return Range_Type }

func (op *Range_Slice) Marshal(m jsn.Marshaler) error {
	return Range_Repeats_Marshal(m, (*[]Range)(op))
}

func (op *Range_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Range_Slice) SetSize(cnt int) {
	var els []Range
	if cnt >= 0 {
		els = make(Range_Slice, cnt)
	}
	(*op) = els
}

func (op *Range_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Range_Marshal(m, &(*op)[i])
}

func Range_Repeats_Marshal(m jsn.Marshaler, vals *[]Range) error {
	return jsn.RepeatBlock(m, (*Range_Slice)(vals))
}

func Range_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Range) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Range_Repeats_Marshal(m, pv)
	}
	return
}

type Range_Flow struct{ ptr *Range }

func (n Range_Flow) GetType() string      { return Range_Type }
func (n Range_Flow) GetLede() string      { return Range_Type }
func (n Range_Flow) GetFlow() interface{} { return n.ptr }
func (n Range_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Range); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Range_Optional_Marshal(m jsn.Marshaler, pv **Range) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Range_Marshal(m, *pv)
	} else if !enc {
		var v Range
		if err = Range_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Range_Marshal(m jsn.Marshaler, val *Range) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Range_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Range_Field_To)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.To)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Range_Field_To))
		}
		e1 := m.MarshalKey("from", Range_Field_From)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Range_Field_From))
		}
		e2 := m.MarshalKey("by_step", Range_Field_ByStep)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.ByStep)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Range_Field_ByStep))
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListTarget)(nil),
}

var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFindBool)(nil),
	(*ListFindList)(nil),
	(*ListFindNumber)(nil),
	(*ListFindRecord)(nil),
	(*ListFindText)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListPush)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*Range)(nil),
}

var Signatures = map[uint64]interface{}{
	6334415563934548256:  (*ListGather)(nil),      /* Gather:from:using: */
	17577768627337399713: (*AsNum)(nil),           /* list_iterator=AsNum: */
	6572817319640344459:  (*AsRec)(nil),           /* list_iterator=AsRec: */
	8904662885358797385:  (*AsTxt)(nil),           /* list_iterator=AsTxt: */
	17857642077015906043: (*EraseEdge)(nil),       /* execute=Erase: */
	4911242881414594201:  (*EraseEdge)(nil),       /* execute=Erase:atFront: */
	13326390992756169124: (*EraseIndex)(nil),      /* execute=Erase:from:atIndex: */
	16587893764566352449: (*ErasingEdge)(nil),     /* execute=Erasing:as:does: */
	1771685988622306554:  (*ErasingEdge)(nil),     /* execute=Erasing:as:does:else: */
	12709950044197813063: (*ErasingEdge)(nil),     /* execute=Erasing:atFront:as:does: */
	307909849155983812:   (*ErasingEdge)(nil),     /* execute=Erasing:atFront:as:does:else: */
	1558163885147286548:  (*Erasing)(nil),         /* execute=Erasing:from:atIndex:as:does: */
	9348234569197795361:  (*ListFindBool)(nil),    /* bool_eval=Find bool:inList: */
	9472366438635241650:  (*ListFindBool)(nil),    /* number_eval=Find bool:inList: */
	16884621558083069345: (*ListFindList)(nil),    /* bool_eval=Find list:inList: */
	10538020407467602126: (*ListFindList)(nil),    /* number_eval=Find list:inList: */
	15503953861458579584: (*ListFindNumber)(nil),  /* bool_eval=Find number:inList: */
	12149184653109026231: (*ListFindNumber)(nil),  /* number_eval=Find number:inList: */
	14476013798329214116: (*ListFindRecord)(nil),  /* bool_eval=Find record:inList: */
	15040017068275408375: (*ListFindRecord)(nil),  /* number_eval=Find record:inList: */
	17001742413226094070: (*ListFindText)(nil),    /* bool_eval=Find text:inList: */
	16757669338039889689: (*ListFindText)(nil),    /* number_eval=Find text:inList: */
	17398975598795870578: (*ListAt)(nil),          /* number_eval=Get:index: */
	787317922352878550:   (*ListAt)(nil),          /* record_eval=Get:index: */
	7596656253168052952:  (*ListAt)(nil),          /* text_eval=Get:index: */
	15036602113576414357: (*IntoNumList)(nil),     /* list_target=IntoNums: */
	16834697660106297299: (*IntoRecList)(nil),     /* list_target=IntoRecs: */
	3948826211612626645:  (*IntoTxtList)(nil),     /* list_target=IntoTxts: */
	3478260273963207965:  (*ListLen)(nil),         /* number_eval=Len: */
	8449127989109999373:  (*ListMap)(nil),         /* execute=Map:fromList:using: */
	14590825769568398889: (*ListPush)(nil),        /* execute=Push:into: */
	17497959320325918107: (*ListPush)(nil),        /* execute=Push:into:atFront: */
	120416590109430143:   (*Range)(nil),           /* num_list_eval=Range: */
	15503705420922978310: (*Range)(nil),           /* num_list_eval=Range:byStep: */
	16618866959380663563: (*Range)(nil),           /* num_list_eval=Range:from: */
	14227857065891717050: (*Range)(nil),           /* num_list_eval=Range:from:byStep: */
	18245549119758376391: (*ListReduce)(nil),      /* execute=Reduce into:fromList:using: */
	8451005089688158034:  (*ListEach)(nil),        /* execute=Repeating across:as:does: */
	7170937308629588871:  (*ListEach)(nil),        /* execute=Repeating across:as:does:else: */
	177314099445105829:   (*ListReverse)(nil),     /* execute=Reverse list: */
	6510320425987392359:  (*ListSet)(nil),         /* execute=Set:index:from: */
	4235921801420235638:  (*ListSlice)(nil),       /* num_list_eval=Slice: */
	13273073049578089927: (*ListSlice)(nil),       /* record_list_eval=Slice: */
	18323981472330239313: (*ListSlice)(nil),       /* text_list_eval=Slice: */
	3713929053224137387:  (*ListSlice)(nil),       /* num_list_eval=Slice:end: */
	326673439235441194:   (*ListSlice)(nil),       /* record_list_eval=Slice:end: */
	8469880138850798532:  (*ListSlice)(nil),       /* text_list_eval=Slice:end: */
	6763121597476813124:  (*ListSlice)(nil),       /* num_list_eval=Slice:start: */
	10126987075066562677: (*ListSlice)(nil),       /* record_list_eval=Slice:start: */
	2045310658543284955:  (*ListSlice)(nil),       /* text_list_eval=Slice:start: */
	14495675636779114361: (*ListSlice)(nil),       /* num_list_eval=Slice:start:end: */
	3241896595896148736:  (*ListSlice)(nil),       /* record_list_eval=Slice:start:end: */
	8901512565003460886:  (*ListSlice)(nil),       /* text_list_eval=Slice:start:end: */
	7368886897948327017:  (*ListSortUsing)(nil),   /* execute=Sort:using: */
	2873147130324862012:  (*ListSortNumbers)(nil), /* execute=SortNumbers:byField: */
	16697045456605499852: (*ListSortNumbers)(nil), /* execute=SortNumbers:byField:descending: */
	16004888373963195994: (*ListSortText)(nil),    /* execute=SortTexts:byField: */
	10015011362106184366: (*ListSortText)(nil),    /* execute=SortTexts:byField:descending: */
	10595238214248400404: (*ListSortText)(nil),    /* execute=SortTexts:byField:descending:usingCase: */
	10680774202307610784: (*ListSortText)(nil),    /* execute=SortTexts:byField:usingCase: */
	13203130291219794646: (*ListSplice)(nil),      /* execute=Splice:start:remove:insert: */
	6201472222981604265:  (*ListSplice)(nil),      /* num_list_eval=Splice:start:remove:insert: */
	15778591428898251294: (*ListSplice)(nil),      /* record_list_eval=Splice:start:remove:insert: */
	11160578659475180120: (*ListSplice)(nil),      /* text_list_eval=Splice:start:remove:insert: */
	17540955258181747066: (*FromNumList)(nil),     /* list_eval=VarOfNums: */
	10887272926454556312: (*FromRecList)(nil),     /* list_eval=VarOfRecs: */
	8452904206638198942:  (*FromTxtList)(nil),     /* list_eval=VarOfTxts: */
}
