// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/jsn"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// AsNum Define the name of a number variable.
// User implements: ListIterator.
type AsNum struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: AsNum_Type,
		Uses: composer.Type_Flow,
	}
}

const AsNum_Type = "as_num"

const AsNum_Field_Var = "$VAR"

func (op *AsNum) Marshal(m jsn.Marshaler) error {
	return AsNum_Marshal(m, op)
}

type AsNum_Slice []AsNum

func (op *AsNum_Slice) GetType() string { return AsNum_Type }
func (op *AsNum_Slice) GetSize() int    { return len(*op) }
func (op *AsNum_Slice) SetSize(cnt int) { (*op) = make(AsNum_Slice, cnt) }

func AsNum_Repeats_Marshal(m jsn.Marshaler, vals *[]AsNum) (err error) {
	if err = m.MarshalBlock((*AsNum_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := AsNum_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func AsNum_Optional_Marshal(m jsn.Marshaler, pv **AsNum) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsNum_Marshal(m, *pv)
	} else if !enc {
		var v AsNum
		if err = AsNum_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsNum_Marshal(m jsn.Marshaler, val *AsNum) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(AsNum_Type, AsNum_Type)); err == nil {
		e0 := m.MarshalKey("", AsNum_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsNum_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// AsRec Define the name of a record variable.
// User implements: ListIterator.
type AsRec struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: AsRec_Type,
		Uses: composer.Type_Flow,
	}
}

const AsRec_Type = "as_rec"

const AsRec_Field_Var = "$VAR"

func (op *AsRec) Marshal(m jsn.Marshaler) error {
	return AsRec_Marshal(m, op)
}

type AsRec_Slice []AsRec

func (op *AsRec_Slice) GetType() string { return AsRec_Type }
func (op *AsRec_Slice) GetSize() int    { return len(*op) }
func (op *AsRec_Slice) SetSize(cnt int) { (*op) = make(AsRec_Slice, cnt) }

func AsRec_Repeats_Marshal(m jsn.Marshaler, vals *[]AsRec) (err error) {
	if err = m.MarshalBlock((*AsRec_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := AsRec_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func AsRec_Optional_Marshal(m jsn.Marshaler, pv **AsRec) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsRec_Marshal(m, *pv)
	} else if !enc {
		var v AsRec
		if err = AsRec_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsRec_Marshal(m jsn.Marshaler, val *AsRec) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(AsRec_Type, AsRec_Type)); err == nil {
		e0 := m.MarshalKey("", AsRec_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsRec_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// AsTxt Define the name of a text variable.
// User implements: ListIterator.
type AsTxt struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: AsTxt_Type,
		Uses: composer.Type_Flow,
	}
}

const AsTxt_Type = "as_txt"

const AsTxt_Field_Var = "$VAR"

func (op *AsTxt) Marshal(m jsn.Marshaler) error {
	return AsTxt_Marshal(m, op)
}

type AsTxt_Slice []AsTxt

func (op *AsTxt_Slice) GetType() string { return AsTxt_Type }
func (op *AsTxt_Slice) GetSize() int    { return len(*op) }
func (op *AsTxt_Slice) SetSize(cnt int) { (*op) = make(AsTxt_Slice, cnt) }

func AsTxt_Repeats_Marshal(m jsn.Marshaler, vals *[]AsTxt) (err error) {
	if err = m.MarshalBlock((*AsTxt_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := AsTxt_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func AsTxt_Optional_Marshal(m jsn.Marshaler, pv **AsTxt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = AsTxt_Marshal(m, *pv)
	} else if !enc {
		var v AsTxt
		if err = AsTxt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func AsTxt_Marshal(m jsn.Marshaler, val *AsTxt) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(AsTxt_Type, AsTxt_Type)); err == nil {
		e0 := m.MarshalKey("", AsTxt_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", AsTxt_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// EraseEdge Erase at edge: Remove one or more values from a list
// User implements: Execute.
type EraseEdge struct {
	From   ListSource  `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
}

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseEdge_Type = "erase_edge"

const EraseEdge_Field_From = "$FROM"
const EraseEdge_Field_AtEdge = "$AT_EDGE"

func (op *EraseEdge) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Marshal(m, op)
}

type EraseEdge_Slice []EraseEdge

func (op *EraseEdge_Slice) GetType() string { return EraseEdge_Type }
func (op *EraseEdge_Slice) GetSize() int    { return len(*op) }
func (op *EraseEdge_Slice) SetSize(cnt int) { (*op) = make(EraseEdge_Slice, cnt) }

func EraseEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseEdge) (err error) {
	if err = m.MarshalBlock((*EraseEdge_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := EraseEdge_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func EraseEdge_Optional_Marshal(m jsn.Marshaler, pv **EraseEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseEdge_Marshal(m, *pv)
	} else if !enc {
		var v EraseEdge
		if err = EraseEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseEdge_Marshal(m jsn.Marshaler, val *EraseEdge) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("erase", EraseEdge_Type)); err == nil {
		e0 := m.MarshalKey("", EraseEdge_Field_From)
		if e0 == nil {
			e0 = ListSource_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseEdge_Field_From))
		}
		e1 := m.MarshalKey("at_front", EraseEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseEdge_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list
// User implements: Execute.
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseIndex_Type = "erase_index"

const EraseIndex_Field_Count = "$COUNT"
const EraseIndex_Field_From = "$FROM"
const EraseIndex_Field_AtIndex = "$AT_INDEX"

func (op *EraseIndex) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Marshal(m, op)
}

type EraseIndex_Slice []EraseIndex

func (op *EraseIndex_Slice) GetType() string { return EraseIndex_Type }
func (op *EraseIndex_Slice) GetSize() int    { return len(*op) }
func (op *EraseIndex_Slice) SetSize(cnt int) { (*op) = make(EraseIndex_Slice, cnt) }

func EraseIndex_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseIndex) (err error) {
	if err = m.MarshalBlock((*EraseIndex_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := EraseIndex_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func EraseIndex_Optional_Marshal(m jsn.Marshaler, pv **EraseIndex) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseIndex_Marshal(m, *pv)
	} else if !enc {
		var v EraseIndex
		if err = EraseIndex_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseIndex_Marshal(m jsn.Marshaler, val *EraseIndex) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("erase", EraseIndex_Type)); err == nil {
		e0 := m.MarshalKey("", EraseIndex_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseIndex_Field_Count))
		}
		e1 := m.MarshalKey("from", EraseIndex_Field_From)
		if e1 == nil {
			e1 = ListSource_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseIndex_Field_From))
		}
		e2 := m.MarshalKey("at_index", EraseIndex_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EraseIndex_Field_AtIndex))
		}
		m.EndBlock()
	}
	return
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
// User implements: Execute.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Do      core.Activity `if:"label=do"`
}

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Erasing_Type,
		Uses: composer.Type_Flow,
	}
}

const Erasing_Type = "erasing"

const Erasing_Field_Count = "$COUNT"
const Erasing_Field_From = "$FROM"
const Erasing_Field_AtIndex = "$AT_INDEX"
const Erasing_Field_As = "$AS"
const Erasing_Field_Do = "$DO"

func (op *Erasing) Marshal(m jsn.Marshaler) error {
	return Erasing_Marshal(m, op)
}

type Erasing_Slice []Erasing

func (op *Erasing_Slice) GetType() string { return Erasing_Type }
func (op *Erasing_Slice) GetSize() int    { return len(*op) }
func (op *Erasing_Slice) SetSize(cnt int) { (*op) = make(Erasing_Slice, cnt) }

func Erasing_Repeats_Marshal(m jsn.Marshaler, vals *[]Erasing) (err error) {
	if err = m.MarshalBlock((*Erasing_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Erasing_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Erasing_Optional_Marshal(m jsn.Marshaler, pv **Erasing) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Erasing_Marshal(m, *pv)
	} else if !enc {
		var v Erasing
		if err = Erasing_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Erasing_Marshal(m jsn.Marshaler, val *Erasing) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Erasing_Type, Erasing_Type)); err == nil {
		e0 := m.MarshalKey("", Erasing_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Erasing_Field_Count))
		}
		e1 := m.MarshalKey("from", Erasing_Field_From)
		if e1 == nil {
			e1 = ListSource_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Erasing_Field_From))
		}
		e2 := m.MarshalKey("at_index", Erasing_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Erasing_Field_AtIndex))
		}
		e3 := m.MarshalKey("as", Erasing_Field_As)
		if e3 == nil {
			e3 = value.Text_Unboxed_Marshal(m, &val.As)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", Erasing_Field_As))
		}
		e4 := m.MarshalKey("do", Erasing_Field_Do)
		if e4 == nil {
			e4 = core.Activity_Marshal(m, &val.Do)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", Erasing_Field_Do))
		}
		m.EndBlock()
	}
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
// User implements: Execute.
type ErasingEdge struct {
	From   ListSource    `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Do     core.Activity `if:"label=do"`
	Else   core.Brancher `if:"label=else,optional"`
}

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: ErasingEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const ErasingEdge_Type = "erasing_edge"

const ErasingEdge_Field_From = "$FROM"
const ErasingEdge_Field_AtEdge = "$AT_EDGE"
const ErasingEdge_Field_As = "$AS"
const ErasingEdge_Field_Do = "$DO"
const ErasingEdge_Field_Else = "$ELSE"

func (op *ErasingEdge) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Marshal(m, op)
}

type ErasingEdge_Slice []ErasingEdge

func (op *ErasingEdge_Slice) GetType() string { return ErasingEdge_Type }
func (op *ErasingEdge_Slice) GetSize() int    { return len(*op) }
func (op *ErasingEdge_Slice) SetSize(cnt int) { (*op) = make(ErasingEdge_Slice, cnt) }

func ErasingEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]ErasingEdge) (err error) {
	if err = m.MarshalBlock((*ErasingEdge_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ErasingEdge_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ErasingEdge_Optional_Marshal(m jsn.Marshaler, pv **ErasingEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ErasingEdge_Marshal(m, *pv)
	} else if !enc {
		var v ErasingEdge
		if err = ErasingEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ErasingEdge_Marshal(m jsn.Marshaler, val *ErasingEdge) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("erasing", ErasingEdge_Type)); err == nil {
		e0 := m.MarshalKey("", ErasingEdge_Field_From)
		if e0 == nil {
			e0 = ListSource_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ErasingEdge_Field_From))
		}
		e1 := m.MarshalKey("at_front", ErasingEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ErasingEdge_Field_AtEdge))
		}
		e2 := m.MarshalKey("as", ErasingEdge_Field_As)
		if e2 == nil {
			e2 = value.Text_Unboxed_Marshal(m, &val.As)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ErasingEdge_Field_As))
		}
		e3 := m.MarshalKey("do", ErasingEdge_Field_Do)
		if e3 == nil {
			e3 = core.Activity_Marshal(m, &val.Do)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ErasingEdge_Field_Do))
		}
		e4 := m.MarshalKey("else", ErasingEdge_Field_Else)
		if e4 == nil {
			e4 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", ErasingEdge_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// FromNumList Uses a list of numbers
// User implements: ListSource.
type FromNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_nums",
	}
}

const FromNumList_Type = "from_num_list"

const FromNumList_Field_Var = "$VAR"

func (op *FromNumList) Marshal(m jsn.Marshaler) error {
	return FromNumList_Marshal(m, op)
}

type FromNumList_Slice []FromNumList

func (op *FromNumList_Slice) GetType() string { return FromNumList_Type }
func (op *FromNumList_Slice) GetSize() int    { return len(*op) }
func (op *FromNumList_Slice) SetSize(cnt int) { (*op) = make(FromNumList_Slice, cnt) }

func FromNumList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromNumList) (err error) {
	if err = m.MarshalBlock((*FromNumList_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := FromNumList_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func FromNumList_Optional_Marshal(m jsn.Marshaler, pv **FromNumList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromNumList_Marshal(m, *pv)
	} else if !enc {
		var v FromNumList
		if err = FromNumList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromNumList_Marshal(m jsn.Marshaler, val *FromNumList) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("var_of_nums", FromNumList_Type)); err == nil {
		e0 := m.MarshalKey("", FromNumList_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromNumList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// FromRecList Uses a list of records
// User implements: ListSource.
type FromRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_recs",
	}
}

const FromRecList_Type = "from_rec_list"

const FromRecList_Field_Var = "$VAR"

func (op *FromRecList) Marshal(m jsn.Marshaler) error {
	return FromRecList_Marshal(m, op)
}

type FromRecList_Slice []FromRecList

func (op *FromRecList_Slice) GetType() string { return FromRecList_Type }
func (op *FromRecList_Slice) GetSize() int    { return len(*op) }
func (op *FromRecList_Slice) SetSize(cnt int) { (*op) = make(FromRecList_Slice, cnt) }

func FromRecList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromRecList) (err error) {
	if err = m.MarshalBlock((*FromRecList_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := FromRecList_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func FromRecList_Optional_Marshal(m jsn.Marshaler, pv **FromRecList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromRecList_Marshal(m, *pv)
	} else if !enc {
		var v FromRecList
		if err = FromRecList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromRecList_Marshal(m jsn.Marshaler, val *FromRecList) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("var_of_recs", FromRecList_Type)); err == nil {
		e0 := m.MarshalKey("", FromRecList_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromRecList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// FromTxtList Uses a list of text
// User implements: ListSource.
type FromTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "var_of_txts",
	}
}

const FromTxtList_Type = "from_txt_list"

const FromTxtList_Field_Var = "$VAR"

func (op *FromTxtList) Marshal(m jsn.Marshaler) error {
	return FromTxtList_Marshal(m, op)
}

type FromTxtList_Slice []FromTxtList

func (op *FromTxtList_Slice) GetType() string { return FromTxtList_Type }
func (op *FromTxtList_Slice) GetSize() int    { return len(*op) }
func (op *FromTxtList_Slice) SetSize(cnt int) { (*op) = make(FromTxtList_Slice, cnt) }

func FromTxtList_Repeats_Marshal(m jsn.Marshaler, vals *[]FromTxtList) (err error) {
	if err = m.MarshalBlock((*FromTxtList_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := FromTxtList_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func FromTxtList_Optional_Marshal(m jsn.Marshaler, pv **FromTxtList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = FromTxtList_Marshal(m, *pv)
	} else if !enc {
		var v FromTxtList
		if err = FromTxtList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func FromTxtList_Marshal(m jsn.Marshaler, val *FromTxtList) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("var_of_txts", FromTxtList_Type)); err == nil {
		e0 := m.MarshalKey("", FromTxtList_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", FromTxtList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoNumList Targets a list of numbers
// User implements: ListTarget.
type IntoNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_nums",
	}
}

const IntoNumList_Type = "into_num_list"

const IntoNumList_Field_Var = "$VAR"

func (op *IntoNumList) Marshal(m jsn.Marshaler) error {
	return IntoNumList_Marshal(m, op)
}

type IntoNumList_Slice []IntoNumList

func (op *IntoNumList_Slice) GetType() string { return IntoNumList_Type }
func (op *IntoNumList_Slice) GetSize() int    { return len(*op) }
func (op *IntoNumList_Slice) SetSize(cnt int) { (*op) = make(IntoNumList_Slice, cnt) }

func IntoNumList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoNumList) (err error) {
	if err = m.MarshalBlock((*IntoNumList_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := IntoNumList_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func IntoNumList_Optional_Marshal(m jsn.Marshaler, pv **IntoNumList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoNumList_Marshal(m, *pv)
	} else if !enc {
		var v IntoNumList
		if err = IntoNumList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoNumList_Marshal(m jsn.Marshaler, val *IntoNumList) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("into_nums", IntoNumList_Type)); err == nil {
		e0 := m.MarshalKey("", IntoNumList_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoNumList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoRecList Targets a list of records
// User implements: ListTarget.
type IntoRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_recs",
	}
}

const IntoRecList_Type = "into_rec_list"

const IntoRecList_Field_Var = "$VAR"

func (op *IntoRecList) Marshal(m jsn.Marshaler) error {
	return IntoRecList_Marshal(m, op)
}

type IntoRecList_Slice []IntoRecList

func (op *IntoRecList_Slice) GetType() string { return IntoRecList_Type }
func (op *IntoRecList_Slice) GetSize() int    { return len(*op) }
func (op *IntoRecList_Slice) SetSize(cnt int) { (*op) = make(IntoRecList_Slice, cnt) }

func IntoRecList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoRecList) (err error) {
	if err = m.MarshalBlock((*IntoRecList_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := IntoRecList_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func IntoRecList_Optional_Marshal(m jsn.Marshaler, pv **IntoRecList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoRecList_Marshal(m, *pv)
	} else if !enc {
		var v IntoRecList
		if err = IntoRecList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoRecList_Marshal(m jsn.Marshaler, val *IntoRecList) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("into_recs", IntoRecList_Type)); err == nil {
		e0 := m.MarshalKey("", IntoRecList_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoRecList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// IntoTxtList Targets a list of text
// User implements: ListTarget.
type IntoTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "into_txts",
	}
}

const IntoTxtList_Type = "into_txt_list"

const IntoTxtList_Field_Var = "$VAR"

func (op *IntoTxtList) Marshal(m jsn.Marshaler) error {
	return IntoTxtList_Marshal(m, op)
}

type IntoTxtList_Slice []IntoTxtList

func (op *IntoTxtList_Slice) GetType() string { return IntoTxtList_Type }
func (op *IntoTxtList_Slice) GetSize() int    { return len(*op) }
func (op *IntoTxtList_Slice) SetSize(cnt int) { (*op) = make(IntoTxtList_Slice, cnt) }

func IntoTxtList_Repeats_Marshal(m jsn.Marshaler, vals *[]IntoTxtList) (err error) {
	if err = m.MarshalBlock((*IntoTxtList_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := IntoTxtList_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func IntoTxtList_Optional_Marshal(m jsn.Marshaler, pv **IntoTxtList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = IntoTxtList_Marshal(m, *pv)
	} else if !enc {
		var v IntoTxtList
		if err = IntoTxtList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func IntoTxtList_Marshal(m jsn.Marshaler, val *IntoTxtList) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("into_txts", IntoTxtList_Type)); err == nil {
		e0 := m.MarshalKey("", IntoTxtList_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", IntoTxtList_Field_Var))
		}
		m.EndBlock()
	}
	return
}

// ListAt Get a value from a list. The first element is is index 1.
// User implements: NumberEval, TextEval, RecordEval.
type ListAt struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: ListAt_Type,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const ListAt_Type = "list_at"

const ListAt_Field_List = "$LIST"
const ListAt_Field_Index = "$INDEX"

func (op *ListAt) Marshal(m jsn.Marshaler) error {
	return ListAt_Marshal(m, op)
}

type ListAt_Slice []ListAt

func (op *ListAt_Slice) GetType() string { return ListAt_Type }
func (op *ListAt_Slice) GetSize() int    { return len(*op) }
func (op *ListAt_Slice) SetSize(cnt int) { (*op) = make(ListAt_Slice, cnt) }

func ListAt_Repeats_Marshal(m jsn.Marshaler, vals *[]ListAt) (err error) {
	if err = m.MarshalBlock((*ListAt_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListAt_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListAt_Optional_Marshal(m jsn.Marshaler, pv **ListAt) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListAt_Marshal(m, *pv)
	} else if !enc {
		var v ListAt
		if err = ListAt_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListAt_Marshal(m jsn.Marshaler, val *ListAt) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("get", ListAt_Type)); err == nil {
		e0 := m.MarshalKey("", ListAt_Field_List)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListAt_Field_List))
		}
		e1 := m.MarshalKey("index", ListAt_Field_Index)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Index)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListAt_Field_Index))
		}
		m.EndBlock()
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the &#x27;else&#x27; activity if empty.
// User implements: Execute.
type ListEach struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: ListEach_Type,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const ListEach_Type = "list_each"

const ListEach_Field_List = "$LIST"
const ListEach_Field_As = "$AS"
const ListEach_Field_Do = "$DO"
const ListEach_Field_Else = "$ELSE"

func (op *ListEach) Marshal(m jsn.Marshaler) error {
	return ListEach_Marshal(m, op)
}

type ListEach_Slice []ListEach

func (op *ListEach_Slice) GetType() string { return ListEach_Type }
func (op *ListEach_Slice) GetSize() int    { return len(*op) }
func (op *ListEach_Slice) SetSize(cnt int) { (*op) = make(ListEach_Slice, cnt) }

func ListEach_Repeats_Marshal(m jsn.Marshaler, vals *[]ListEach) (err error) {
	if err = m.MarshalBlock((*ListEach_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListEach_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListEach_Optional_Marshal(m jsn.Marshaler, pv **ListEach) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListEach_Marshal(m, *pv)
	} else if !enc {
		var v ListEach
		if err = ListEach_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListEach_Marshal(m jsn.Marshaler, val *ListEach) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("repeating", ListEach_Type)); err == nil {
		e0 := m.MarshalKey("across", ListEach_Field_List)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListEach_Field_List))
		}
		e1 := m.MarshalKey("as", ListEach_Field_As)
		if e1 == nil {
			e1 = ListIterator_Marshal(m, &val.As)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListEach_Field_As))
		}
		e2 := m.MarshalKey("do", ListEach_Field_Do)
		if e2 == nil {
			e2 = core.Activity_Marshal(m, &val.Do)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListEach_Field_Do))
		}
		e3 := m.MarshalKey("else", ListEach_Field_Else)
		if e3 == nil {
			e3 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListEach_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// ListFind Search a list for a specific value.
// User implements: BoolEval, NumberEval.
type ListFind struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFind_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFind_Type = "list_find"

const ListFind_Field_Value = "$VALUE"
const ListFind_Field_List = "$LIST"

func (op *ListFind) Marshal(m jsn.Marshaler) error {
	return ListFind_Marshal(m, op)
}

type ListFind_Slice []ListFind

func (op *ListFind_Slice) GetType() string { return ListFind_Type }
func (op *ListFind_Slice) GetSize() int    { return len(*op) }
func (op *ListFind_Slice) SetSize(cnt int) { (*op) = make(ListFind_Slice, cnt) }

func ListFind_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFind) (err error) {
	if err = m.MarshalBlock((*ListFind_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListFind_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListFind_Optional_Marshal(m jsn.Marshaler, pv **ListFind) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFind_Marshal(m, *pv)
	} else if !enc {
		var v ListFind
		if err = ListFind_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFind_Marshal(m jsn.Marshaler, val *ListFind) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("find", ListFind_Type)); err == nil {
		e0 := m.MarshalKey("", ListFind_Field_Value)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.Value)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFind_Field_Value))
		}
		e1 := m.MarshalKey("list", ListFind_Field_List)
		if e1 == nil {
			e1 = rt.Assignment_Marshal(m, &val.List)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFind_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListGather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: &#x27;in&#x27; as each value from the list, and &#x27;out&#x27; as the var passed to the gather.
type ListGather struct {
	Var   value.VariableName `if:"label=_"`
	From  ListSource         `if:"label=from"`
	Using string             `if:"label=_,type=text"`
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: ListGather_Type,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const ListGather_Type = "list_gather"

const ListGather_Field_Var = "$VAR"
const ListGather_Field_From = "$FROM"
const ListGather_Field_Using = "$USING"

func (op *ListGather) Marshal(m jsn.Marshaler) error {
	return ListGather_Marshal(m, op)
}

type ListGather_Slice []ListGather

func (op *ListGather_Slice) GetType() string { return ListGather_Type }
func (op *ListGather_Slice) GetSize() int    { return len(*op) }
func (op *ListGather_Slice) SetSize(cnt int) { (*op) = make(ListGather_Slice, cnt) }

func ListGather_Repeats_Marshal(m jsn.Marshaler, vals *[]ListGather) (err error) {
	if err = m.MarshalBlock((*ListGather_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListGather_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListGather_Optional_Marshal(m jsn.Marshaler, pv **ListGather) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListGather_Marshal(m, *pv)
	} else if !enc {
		var v ListGather
		if err = ListGather_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListGather_Marshal(m jsn.Marshaler, val *ListGather) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("gather", ListGather_Type)); err == nil {
		e0 := m.MarshalKey("", ListGather_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListGather_Field_Var))
		}
		e1 := m.MarshalKey("from", ListGather_Field_From)
		if e1 == nil {
			e1 = ListSource_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListGather_Field_From))
		}
		e2 := m.MarshalKey("", ListGather_Field_Using)
		if e2 == nil {
			e2 = value.Text_Unboxed_Marshal(m, &val.Using)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListGather_Field_Using))
		}
		m.EndBlock()
	}
	return
}

const ListIterator_Type = "list_iterator"

var ListIterator_Optional_Marshal = ListIterator_Marshal

type ListIterator_Slot struct{ ptr *ListIterator }

func (At ListIterator_Slot) GetType() string { return ListIterator_Type }
func (at ListIterator_Slot) HasSlot() bool   { return at.ptr != nil }
func (at ListIterator_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(ListIterator)
	return
}

func ListIterator_Marshal(m jsn.Marshaler, ptr *ListIterator) (err error) {
	if err = m.MarshalBlock(ListIterator_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type ListIterator_Slice []ListIterator

func (op *ListIterator_Slice) GetType() string { return ListIterator_Type }
func (op *ListIterator_Slice) GetSize() int    { return len(*op) }
func (op *ListIterator_Slice) SetSize(cnt int) { (*op) = make(ListIterator_Slice, cnt) }

func ListIterator_Repeats_Marshal(m jsn.Marshaler, vals *[]ListIterator) (err error) {
	if err = m.MarshalBlock((*ListIterator_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListIterator_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

// ListLen Determines the number of values in a list.
// User implements: NumberEval.
type ListLen struct {
	List rt.Assignment `if:"label=_"`
}

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: ListLen_Type,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const ListLen_Type = "list_len"

const ListLen_Field_List = "$LIST"

func (op *ListLen) Marshal(m jsn.Marshaler) error {
	return ListLen_Marshal(m, op)
}

type ListLen_Slice []ListLen

func (op *ListLen_Slice) GetType() string { return ListLen_Type }
func (op *ListLen_Slice) GetSize() int    { return len(*op) }
func (op *ListLen_Slice) SetSize(cnt int) { (*op) = make(ListLen_Slice, cnt) }

func ListLen_Repeats_Marshal(m jsn.Marshaler, vals *[]ListLen) (err error) {
	if err = m.MarshalBlock((*ListLen_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListLen_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListLen_Optional_Marshal(m jsn.Marshaler, pv **ListLen) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListLen_Marshal(m, *pv)
	} else if !enc {
		var v ListLen
		if err = ListLen_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListLen_Marshal(m jsn.Marshaler, val *ListLen) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("len", ListLen_Type)); err == nil {
		e0 := m.MarshalKey("", ListLen_Field_List)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListLen_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListMap Transform the values from one list and place the results in another list. The designated pattern is called with each value from the &#x27;from list&#x27;, one value at a time.
// User implements: Execute.
type ListMap struct {
	ToList       string        `if:"label=_,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: ListMap_Type,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const ListMap_Type = "list_map"

const ListMap_Field_ToList = "$TO_LIST"
const ListMap_Field_FromList = "$FROM_LIST"
const ListMap_Field_UsingPattern = "$USING_PATTERN"

func (op *ListMap) Marshal(m jsn.Marshaler) error {
	return ListMap_Marshal(m, op)
}

type ListMap_Slice []ListMap

func (op *ListMap_Slice) GetType() string { return ListMap_Type }
func (op *ListMap_Slice) GetSize() int    { return len(*op) }
func (op *ListMap_Slice) SetSize(cnt int) { (*op) = make(ListMap_Slice, cnt) }

func ListMap_Repeats_Marshal(m jsn.Marshaler, vals *[]ListMap) (err error) {
	if err = m.MarshalBlock((*ListMap_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListMap_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListMap_Optional_Marshal(m jsn.Marshaler, pv **ListMap) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListMap_Marshal(m, *pv)
	} else if !enc {
		var v ListMap
		if err = ListMap_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListMap_Marshal(m jsn.Marshaler, val *ListMap) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("map", ListMap_Type)); err == nil {
		e0 := m.MarshalKey("", ListMap_Field_ToList)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.ToList)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListMap_Field_ToList))
		}
		e1 := m.MarshalKey("from_list", ListMap_Field_FromList)
		if e1 == nil {
			e1 = rt.Assignment_Marshal(m, &val.FromList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListMap_Field_FromList))
		}
		e2 := m.MarshalKey("using", ListMap_Field_UsingPattern)
		if e2 == nil {
			e2 = value.Text_Unboxed_Marshal(m, &val.UsingPattern)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListMap_Field_UsingPattern))
		}
		m.EndBlock()
	}
	return
}

// ListReduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: &#x27;in&#x27; ( each element of the list ) and &#x27;out&#x27; ( ex. a record ).
// User implements: Execute.
type ListReduce struct {
	IntoValue    string        `if:"label=into,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReduce_Type,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const ListReduce_Type = "list_reduce"

const ListReduce_Field_IntoValue = "$INTO_VALUE"
const ListReduce_Field_FromList = "$FROM_LIST"
const ListReduce_Field_UsingPattern = "$USING_PATTERN"

func (op *ListReduce) Marshal(m jsn.Marshaler) error {
	return ListReduce_Marshal(m, op)
}

type ListReduce_Slice []ListReduce

func (op *ListReduce_Slice) GetType() string { return ListReduce_Type }
func (op *ListReduce_Slice) GetSize() int    { return len(*op) }
func (op *ListReduce_Slice) SetSize(cnt int) { (*op) = make(ListReduce_Slice, cnt) }

func ListReduce_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReduce) (err error) {
	if err = m.MarshalBlock((*ListReduce_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListReduce_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListReduce_Optional_Marshal(m jsn.Marshaler, pv **ListReduce) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReduce_Marshal(m, *pv)
	} else if !enc {
		var v ListReduce
		if err = ListReduce_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReduce_Marshal(m jsn.Marshaler, val *ListReduce) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("reduce", ListReduce_Type)); err == nil {
		e0 := m.MarshalKey("into", ListReduce_Field_IntoValue)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.IntoValue)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReduce_Field_IntoValue))
		}
		e1 := m.MarshalKey("from_list", ListReduce_Field_FromList)
		if e1 == nil {
			e1 = rt.Assignment_Marshal(m, &val.FromList)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListReduce_Field_FromList))
		}
		e2 := m.MarshalKey("using", ListReduce_Field_UsingPattern)
		if e2 == nil {
			e2 = value.Text_Unboxed_Marshal(m, &val.UsingPattern)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListReduce_Field_UsingPattern))
		}
		m.EndBlock()
	}
	return
}

// ListReverse Reverse a list.
// User implements: Execute.
type ListReverse struct {
	List ListSource `if:"label=list"`
}

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReverse_Type,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const ListReverse_Type = "list_reverse"

const ListReverse_Field_List = "$LIST"

func (op *ListReverse) Marshal(m jsn.Marshaler) error {
	return ListReverse_Marshal(m, op)
}

type ListReverse_Slice []ListReverse

func (op *ListReverse_Slice) GetType() string { return ListReverse_Type }
func (op *ListReverse_Slice) GetSize() int    { return len(*op) }
func (op *ListReverse_Slice) SetSize(cnt int) { (*op) = make(ListReverse_Slice, cnt) }

func ListReverse_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReverse) (err error) {
	if err = m.MarshalBlock((*ListReverse_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListReverse_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListReverse_Optional_Marshal(m jsn.Marshaler, pv **ListReverse) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReverse_Marshal(m, *pv)
	} else if !enc {
		var v ListReverse
		if err = ListReverse_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReverse_Marshal(m jsn.Marshaler, val *ListReverse) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("reverse", ListReverse_Type)); err == nil {
		e0 := m.MarshalKey("list", ListReverse_Field_List)
		if e0 == nil {
			e0 = ListSource_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReverse_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListSet Overwrite an existing value in a list.
// User implements: Execute.
type ListSet struct {
	List  string        `if:"label=_,type=text"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSet_Type,
		Uses: composer.Type_Flow,
		Lede: "set",
	}
}

const ListSet_Type = "list_set"

const ListSet_Field_List = "$LIST"
const ListSet_Field_Index = "$INDEX"
const ListSet_Field_From = "$FROM"

func (op *ListSet) Marshal(m jsn.Marshaler) error {
	return ListSet_Marshal(m, op)
}

type ListSet_Slice []ListSet

func (op *ListSet_Slice) GetType() string { return ListSet_Type }
func (op *ListSet_Slice) GetSize() int    { return len(*op) }
func (op *ListSet_Slice) SetSize(cnt int) { (*op) = make(ListSet_Slice, cnt) }

func ListSet_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSet) (err error) {
	if err = m.MarshalBlock((*ListSet_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListSet_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListSet_Optional_Marshal(m jsn.Marshaler, pv **ListSet) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSet_Marshal(m, *pv)
	} else if !enc {
		var v ListSet
		if err = ListSet_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSet_Marshal(m jsn.Marshaler, val *ListSet) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("set", ListSet_Type)); err == nil {
		e0 := m.MarshalKey("", ListSet_Field_List)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSet_Field_List))
		}
		e1 := m.MarshalKey("index", ListSet_Field_Index)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Index)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSet_Field_Index))
		}
		e2 := m.MarshalKey("from", ListSet_Field_From)
		if e2 == nil {
			e2 = rt.Assignment_Marshal(m, &val.From)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSet_Field_From))
		}
		m.EndBlock()
	}
	return
}

// ListSlice Create a new list from a section of another list.,Start is optional, if omitted slice starts at the first element.,If start is greater the length, an empty array is returned.,Slice doesnt include the ending index.,Negatives indices indicates an offset from the end.,When end is omitted, copy up to and including the last element;,and do the same if the end is greater than the length
// User implements: NumListEval, TextListEval, RecordListEval.
type ListSlice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSlice_Type,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const ListSlice_Type = "list_slice"

const ListSlice_Field_List = "$LIST"
const ListSlice_Field_Start = "$START"
const ListSlice_Field_End = "$END"

func (op *ListSlice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Marshal(m, op)
}

type ListSlice_Slice []ListSlice

func (op *ListSlice_Slice) GetType() string { return ListSlice_Type }
func (op *ListSlice_Slice) GetSize() int    { return len(*op) }
func (op *ListSlice_Slice) SetSize(cnt int) { (*op) = make(ListSlice_Slice, cnt) }

func ListSlice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSlice) (err error) {
	if err = m.MarshalBlock((*ListSlice_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListSlice_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListSlice_Optional_Marshal(m jsn.Marshaler, pv **ListSlice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSlice_Marshal(m, *pv)
	} else if !enc {
		var v ListSlice
		if err = ListSlice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSlice_Marshal(m jsn.Marshaler, val *ListSlice) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("slice", ListSlice_Type)); err == nil {
		e0 := m.MarshalKey("", ListSlice_Field_List)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSlice_Field_List))
		}
		e1 := m.MarshalKey("start", ListSlice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSlice_Field_Start))
		}
		e2 := m.MarshalKey("end", ListSlice_Field_End)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.End)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSlice_Field_End))
		}
		m.EndBlock()
	}
	return
}

// ListSortNumbers
// User implements: Execute.
type ListSortNumbers struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
}

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortNumbers_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_numbers",
	}
}

const ListSortNumbers_Type = "list_sort_numbers"

const ListSortNumbers_Field_Var = "$VAR"
const ListSortNumbers_Field_ByField = "$BY_FIELD"
const ListSortNumbers_Field_Descending = "$DESCENDING"

func (op *ListSortNumbers) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Marshal(m, op)
}

type ListSortNumbers_Slice []ListSortNumbers

func (op *ListSortNumbers_Slice) GetType() string { return ListSortNumbers_Type }
func (op *ListSortNumbers_Slice) GetSize() int    { return len(*op) }
func (op *ListSortNumbers_Slice) SetSize(cnt int) { (*op) = make(ListSortNumbers_Slice, cnt) }

func ListSortNumbers_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortNumbers) (err error) {
	if err = m.MarshalBlock((*ListSortNumbers_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListSortNumbers_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListSortNumbers_Optional_Marshal(m jsn.Marshaler, pv **ListSortNumbers) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortNumbers_Marshal(m, *pv)
	} else if !enc {
		var v ListSortNumbers
		if err = ListSortNumbers_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortNumbers_Marshal(m jsn.Marshaler, val *ListSortNumbers) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("sort_numbers", ListSortNumbers_Type)); err == nil {
		e0 := m.MarshalKey("", ListSortNumbers_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortNumbers_Field_Var))
		}
		e1 := m.MarshalKey("by_field", ListSortNumbers_Field_ByField)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortNumbers_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortNumbers_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortNumbers_Field_Descending))
		}
		m.EndBlock()
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
// User implements: Execute.
type ListSortText struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
	UsingCase  rt.BoolEval        `if:"label=using_case,optional"`
}

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortText_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_texts",
	}
}

const ListSortText_Type = "list_sort_text"

const ListSortText_Field_Var = "$VAR"
const ListSortText_Field_ByField = "$BY_FIELD"
const ListSortText_Field_Descending = "$DESCENDING"
const ListSortText_Field_UsingCase = "$USING_CASE"

func (op *ListSortText) Marshal(m jsn.Marshaler) error {
	return ListSortText_Marshal(m, op)
}

type ListSortText_Slice []ListSortText

func (op *ListSortText_Slice) GetType() string { return ListSortText_Type }
func (op *ListSortText_Slice) GetSize() int    { return len(*op) }
func (op *ListSortText_Slice) SetSize(cnt int) { (*op) = make(ListSortText_Slice, cnt) }

func ListSortText_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortText) (err error) {
	if err = m.MarshalBlock((*ListSortText_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListSortText_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListSortText_Optional_Marshal(m jsn.Marshaler, pv **ListSortText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortText_Marshal(m, *pv)
	} else if !enc {
		var v ListSortText
		if err = ListSortText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortText_Marshal(m jsn.Marshaler, val *ListSortText) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("sort_texts", ListSortText_Type)); err == nil {
		e0 := m.MarshalKey("", ListSortText_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortText_Field_Var))
		}
		e1 := m.MarshalKey("by_field", ListSortText_Field_ByField)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortText_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortText_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortText_Field_Descending))
		}
		e3 := m.MarshalKey("using_case", ListSortText_Field_UsingCase)
		if e3 == nil {
			e3 = rt.BoolEval_Optional_Marshal(m, &val.UsingCase)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSortText_Field_UsingCase))
		}
		m.EndBlock()
	}
	return
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
// User implements: Execute.
type ListSortUsing struct {
	Var   value.VariableName `if:"label=_"`
	Using string             `if:"label=using,type=text"`
}

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortUsing_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortUsing_Type = "list_sort_using"

const ListSortUsing_Field_Var = "$VAR"
const ListSortUsing_Field_Using = "$USING"

func (op *ListSortUsing) Marshal(m jsn.Marshaler) error {
	return ListSortUsing_Marshal(m, op)
}

type ListSortUsing_Slice []ListSortUsing

func (op *ListSortUsing_Slice) GetType() string { return ListSortUsing_Type }
func (op *ListSortUsing_Slice) GetSize() int    { return len(*op) }
func (op *ListSortUsing_Slice) SetSize(cnt int) { (*op) = make(ListSortUsing_Slice, cnt) }

func ListSortUsing_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortUsing) (err error) {
	if err = m.MarshalBlock((*ListSortUsing_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListSortUsing_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListSortUsing_Optional_Marshal(m jsn.Marshaler, pv **ListSortUsing) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortUsing_Marshal(m, *pv)
	} else if !enc {
		var v ListSortUsing
		if err = ListSortUsing_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortUsing_Marshal(m jsn.Marshaler, val *ListSortUsing) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("sort", ListSortUsing_Type)); err == nil {
		e0 := m.MarshalKey("", ListSortUsing_Field_Var)
		if e0 == nil {
			e0 = value.VariableName_Marshal(m, &val.Var)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortUsing_Field_Var))
		}
		e1 := m.MarshalKey("using", ListSortUsing_Field_Using)
		if e1 == nil {
			e1 = value.Text_Unboxed_Marshal(m, &val.Using)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortUsing_Field_Using))
		}
		m.EndBlock()
	}
	return
}

const ListSource_Type = "list_source"

var ListSource_Optional_Marshal = ListSource_Marshal

type ListSource_Slot struct{ ptr *ListSource }

func (At ListSource_Slot) GetType() string { return ListSource_Type }
func (at ListSource_Slot) HasSlot() bool   { return at.ptr != nil }
func (at ListSource_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(ListSource)
	return
}

func ListSource_Marshal(m jsn.Marshaler, ptr *ListSource) (err error) {
	if err = m.MarshalBlock(ListSource_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type ListSource_Slice []ListSource

func (op *ListSource_Slice) GetType() string { return ListSource_Type }
func (op *ListSource_Slice) GetSize() int    { return len(*op) }
func (op *ListSource_Slice) SetSize(cnt int) { (*op) = make(ListSource_Slice, cnt) }

func ListSource_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSource) (err error) {
	if err = m.MarshalBlock((*ListSource_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListSource_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

// ListSplice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list&#x27;s length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
// User implements: Execute, NumListEval, TextListEval, RecordListEval.
type ListSplice struct {
	List   string        `if:"label=_,type=text"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSplice_Type,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const ListSplice_Type = "list_splice"

const ListSplice_Field_List = "$LIST"
const ListSplice_Field_Start = "$START"
const ListSplice_Field_Remove = "$REMOVE"
const ListSplice_Field_Insert = "$INSERT"

func (op *ListSplice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Marshal(m, op)
}

type ListSplice_Slice []ListSplice

func (op *ListSplice_Slice) GetType() string { return ListSplice_Type }
func (op *ListSplice_Slice) GetSize() int    { return len(*op) }
func (op *ListSplice_Slice) SetSize(cnt int) { (*op) = make(ListSplice_Slice, cnt) }

func ListSplice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSplice) (err error) {
	if err = m.MarshalBlock((*ListSplice_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListSplice_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func ListSplice_Optional_Marshal(m jsn.Marshaler, pv **ListSplice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSplice_Marshal(m, *pv)
	} else if !enc {
		var v ListSplice
		if err = ListSplice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSplice_Marshal(m jsn.Marshaler, val *ListSplice) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("splice", ListSplice_Type)); err == nil {
		e0 := m.MarshalKey("", ListSplice_Field_List)
		if e0 == nil {
			e0 = value.Text_Unboxed_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSplice_Field_List))
		}
		e1 := m.MarshalKey("start", ListSplice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSplice_Field_Start))
		}
		e2 := m.MarshalKey("remove", ListSplice_Field_Remove)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.Remove)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSplice_Field_Remove))
		}
		e3 := m.MarshalKey("insert", ListSplice_Field_Insert)
		if e3 == nil {
			e3 = rt.Assignment_Marshal(m, &val.Insert)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSplice_Field_Insert))
		}
		m.EndBlock()
	}
	return
}

const ListTarget_Type = "list_target"

var ListTarget_Optional_Marshal = ListTarget_Marshal

type ListTarget_Slot struct{ ptr *ListTarget }

func (At ListTarget_Slot) GetType() string { return ListTarget_Type }
func (at ListTarget_Slot) HasSlot() bool   { return at.ptr != nil }
func (at ListTarget_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(ListTarget)
	return
}

func ListTarget_Marshal(m jsn.Marshaler, ptr *ListTarget) (err error) {
	if err = m.MarshalBlock(ListTarget_Slot{ptr}); err == nil {
		if e := (*ptr).(jsn.Marshalee).Marshal(m); e != nil && e != jsn.Missing {
			m.Error(e)
		}
		m.EndBlock()
	}
	return
}

type ListTarget_Slice []ListTarget

func (op *ListTarget_Slice) GetType() string { return ListTarget_Type }
func (op *ListTarget_Slice) GetSize() int    { return len(*op) }
func (op *ListTarget_Slice) SetSize(cnt int) { (*op) = make(ListTarget_Slice, cnt) }

func ListTarget_Repeats_Marshal(m jsn.Marshaler, vals *[]ListTarget) (err error) {
	if err = m.MarshalBlock((*ListTarget_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := ListTarget_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

// PutEdge Add a value to a list
// User implements: Execute.
type PutEdge struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
}

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: PutEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutEdge_Type = "put_edge"

const PutEdge_Field_From = "$FROM"
const PutEdge_Field_Into = "$INTO"
const PutEdge_Field_AtEdge = "$AT_EDGE"

func (op *PutEdge) Marshal(m jsn.Marshaler) error {
	return PutEdge_Marshal(m, op)
}

type PutEdge_Slice []PutEdge

func (op *PutEdge_Slice) GetType() string { return PutEdge_Type }
func (op *PutEdge_Slice) GetSize() int    { return len(*op) }
func (op *PutEdge_Slice) SetSize(cnt int) { (*op) = make(PutEdge_Slice, cnt) }

func PutEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]PutEdge) (err error) {
	if err = m.MarshalBlock((*PutEdge_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := PutEdge_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func PutEdge_Optional_Marshal(m jsn.Marshaler, pv **PutEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = PutEdge_Marshal(m, *pv)
	} else if !enc {
		var v PutEdge
		if err = PutEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func PutEdge_Marshal(m jsn.Marshaler, val *PutEdge) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("put", PutEdge_Type)); err == nil {
		e0 := m.MarshalKey("", PutEdge_Field_From)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", PutEdge_Field_From))
		}
		e1 := m.MarshalKey("into", PutEdge_Field_Into)
		if e1 == nil {
			e1 = ListTarget_Marshal(m, &val.Into)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", PutEdge_Field_Into))
		}
		e2 := m.MarshalKey("at_front", PutEdge_Field_AtEdge)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", PutEdge_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// PutIndex Replace one value in a list with another
// User implements: Execute.
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: PutIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutIndex_Type = "put_index"

const PutIndex_Field_From = "$FROM"
const PutIndex_Field_Into = "$INTO"
const PutIndex_Field_AtIndex = "$AT_INDEX"

func (op *PutIndex) Marshal(m jsn.Marshaler) error {
	return PutIndex_Marshal(m, op)
}

type PutIndex_Slice []PutIndex

func (op *PutIndex_Slice) GetType() string { return PutIndex_Type }
func (op *PutIndex_Slice) GetSize() int    { return len(*op) }
func (op *PutIndex_Slice) SetSize(cnt int) { (*op) = make(PutIndex_Slice, cnt) }

func PutIndex_Repeats_Marshal(m jsn.Marshaler, vals *[]PutIndex) (err error) {
	if err = m.MarshalBlock((*PutIndex_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := PutIndex_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func PutIndex_Optional_Marshal(m jsn.Marshaler, pv **PutIndex) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = PutIndex_Marshal(m, *pv)
	} else if !enc {
		var v PutIndex
		if err = PutIndex_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func PutIndex_Marshal(m jsn.Marshaler, val *PutIndex) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow("put", PutIndex_Type)); err == nil {
		e0 := m.MarshalKey("", PutIndex_Field_From)
		if e0 == nil {
			e0 = rt.Assignment_Marshal(m, &val.From)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", PutIndex_Field_From))
		}
		e1 := m.MarshalKey("into", PutIndex_Field_Into)
		if e1 == nil {
			e1 = ListTarget_Marshal(m, &val.Into)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", PutIndex_Field_Into))
		}
		e2 := m.MarshalKey("at_index", PutIndex_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", PutIndex_Field_AtIndex))
		}
		m.EndBlock()
	}
	return
}

// Range Generates a series of numbers r[i] &#x3D; (start + step*i) where i&gt;&#x3D;0.,Start and step default to 1, stop defaults to start;,the inputs are truncated to produce whole numbers;,a zero step returns an error.,A positive step ends the series when the returned value would exceed stop,while a negative step ends before generating a value less than stop.
// User implements: NumListEval.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Range_Type,
		Uses: composer.Type_Flow,
	}
}

const Range_Type = "range"

const Range_Field_To = "$TO"
const Range_Field_From = "$FROM"
const Range_Field_ByStep = "$BY_STEP"

func (op *Range) Marshal(m jsn.Marshaler) error {
	return Range_Marshal(m, op)
}

type Range_Slice []Range

func (op *Range_Slice) GetType() string { return Range_Type }
func (op *Range_Slice) GetSize() int    { return len(*op) }
func (op *Range_Slice) SetSize(cnt int) { (*op) = make(Range_Slice, cnt) }

func Range_Repeats_Marshal(m jsn.Marshaler, vals *[]Range) (err error) {
	if err = m.MarshalBlock((*Range_Slice)(vals)); err == nil {
		for i := range *vals {
			if e := Range_Marshal(m, &(*vals)[i]); e != nil && e != jsn.Missing {
				m.Error(errutil.New(e, "in slice at", i))
			}
		}
		m.EndBlock()
	}
	return
}

func Range_Optional_Marshal(m jsn.Marshaler, pv **Range) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Range_Marshal(m, *pv)
	} else if !enc {
		var v Range
		if err = Range_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Range_Marshal(m jsn.Marshaler, val *Range) (err error) {
	if err = m.MarshalBlock(jsn.MarkFlow(Range_Type, Range_Type)); err == nil {
		e0 := m.MarshalKey("", Range_Field_To)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.To)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Range_Field_To))
		}
		e1 := m.MarshalKey("from", Range_Field_From)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Range_Field_From))
		}
		e2 := m.MarshalKey("by_step", Range_Field_ByStep)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.ByStep)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Range_Field_ByStep))
		}
		m.EndBlock()
	}
	return
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}

var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
}

var Signatures = map[uint64]interface{}{
	12988276311577525315: (*AsNum)(nil),           /* AsNum: */
	5538742983703937313:  (*AsRec)(nil),           /* AsRec: */
	4514588378517715255:  (*AsTxt)(nil),           /* AsTxt: */
	602674204343183133:   (*EraseEdge)(nil),       /* Erase: */
	2379140516691405863:  (*EraseEdge)(nil),       /* Erase:atFront: */
	18068640065349035914: (*EraseIndex)(nil),      /* Erase:from:atIndex: */
	15022408731321198722: (*Erasing)(nil),         /* Erasing:from:atIndex:as:do: */
	10199179765059749783: (*ErasingEdge)(nil),     /* Erasing:as:do: */
	4059879572017637653:  (*ErasingEdge)(nil),     /* Erasing:atFront:as:do: */
	2253244220008480180:  (*ErasingEdge)(nil),     /* Erasing:as:do:else: */
	4832054959845425038:  (*ErasingEdge)(nil),     /* Erasing:atFront:as:do:else: */
	11643102106272323440: (*FromNumList)(nil),     /* VarOfNums: */
	11748429228606086474: (*FromRecList)(nil),     /* VarOfRecs: */
	9860873969452403008:  (*FromTxtList)(nil),     /* VarOfTxts: */
	15891010564373014004: (*IntoNumList)(nil),     /* IntoNums: */
	12459647556401208318: (*IntoRecList)(nil),     /* IntoRecs: */
	8659259889251239468:  (*IntoTxtList)(nil),     /* IntoTxts: */
	486700160484864869:   (*ListAt)(nil),          /* Get:index: */
	5893619730181277740:  (*ListEach)(nil),        /* Repeating across:as:do: */
	4018832586238090637:  (*ListEach)(nil),        /* Repeating across:as:do:else: */
	10285751875873889942: (*ListFind)(nil),        /* Find:list: */
	523806146137244572:   (*ListGather)(nil),      /* Gather:from:: */
	11936860857815714018: (*ListLen)(nil),         /* Len: */
	5185210125302469743:  (*ListMap)(nil),         /* Map:fromList:using: */
	14826188473242626433: (*ListReduce)(nil),      /* Reduce into:fromList:using: */
	13627278328240309351: (*ListReverse)(nil),     /* Reverse list: */
	15586923045386932713: (*ListSet)(nil),         /* Set:index:from: */
	16656583749567367441: (*ListSlice)(nil),       /* Slice: */
	8205818265699527963:  (*ListSlice)(nil),       /* Slice:start: */
	11293812622311872004: (*ListSlice)(nil),       /* Slice:end: */
	1592674698280817110:  (*ListSlice)(nil),       /* Slice:start:end: */
	5767454846835881814:  (*ListSortNumbers)(nil), /* SortNumbers:byField: */
	11765588999597320458: (*ListSortNumbers)(nil), /* SortNumbers:byField:descending: */
	16820765327929145512: (*ListSortText)(nil),    /* SortTexts:byField: */
	7928660393625494104:  (*ListSortText)(nil),    /* SortTexts:byField:descending: */
	14523039554491862046: (*ListSortText)(nil),    /* SortTexts:byField:usingCase: */
	13718565834155724622: (*ListSortText)(nil),    /* SortTexts:byField:descending:usingCase: */
	17242083762994141003: (*ListSortUsing)(nil),   /* Sort:using: */
	10934695318884901016: (*ListSplice)(nil),      /* Splice:start:remove:insert: */
	17042054112571797420: (*PutEdge)(nil),         /* Put:into: */
	14857107863114820154: (*PutEdge)(nil),         /* Put:into:atFront: */
	8899481094314089999:  (*PutIndex)(nil),        /* Put:into:atIndex: */
	9793113837890674936:  (*Range)(nil),           /* Range: */
	12654734042076112886: (*Range)(nil),           /* Range:from: */
	4890710300640402911:  (*Range)(nil),           /* Range:byStep: */
	17061865887297909749: (*Range)(nil),           /* Range:from:byStep: */
}
