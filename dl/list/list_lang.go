// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var string `if:"label=_"`
}

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "as_num",
		Lede: "num",
	}
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var string `if:"label=_"`
}

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: "as_rec",
		Lede: "rec",
	}
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var string `if:"label=_"`
}

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: "as_txt",
		Lede: "txt",
	}
}

// At Get a value from a list. The first element is is index 1.
type At struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

func (*At) Compose() composer.Spec {
	return composer.Spec{
		Name: "at",
		Lede: "get",
	}
}

// Each Loops over the elements in the passed list, or runs the &#x27;else&#x27; activity if empty.
type Each struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

func (*Each) Compose() composer.Spec {
	return composer.Spec{
		Name: "each",
		Lede: "repeating",
	}
}

// EraseEdge Remove one or more values from a list
type EraseEdge struct {
	From    ListSource  `if:"label=_"`
	AtFront rt.BoolEval `if:"label=at_front,optional"`
}

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: "erase_edge",
		Lede: "erase",
	}
}

// EraseIndex Remove one or more values from a list
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: "erase_index",
		Lede: "erase",
	}
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      value.Text    `if:"label=as"`
	Do      core.Activity `if:"label=do"`
}

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: "erasing",
	}
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From    ListSource    `if:"label=_"`
	AtFront rt.BoolEval   `if:"label=at_front,optional"`
	As      value.Text    `if:"label=as"`
	Do      core.Activity `if:"label=do"`
	Else    core.Brancher `if:"label=else,optional"`
}

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: "erasing_edge",
		Lede: "erasing",
	}
}

// Find Search a list for a specific value.
type Find struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

func (*Find) Compose() composer.Spec {
	return composer.Spec{
		Name: "find",
	}
}

// FromNumList Uses a list of numbers
type FromNumList struct {
	Var string `if:"label=_"`
}

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_num_list",
		Lede: "nums",
	}
}

// FromRecList Uses a list of records
type FromRecList struct {
	Var string `if:"label=_"`
}

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_rec_list",
		Lede: "recs",
	}
}

// FromTxtList Uses a list of text
type FromTxtList struct {
	Var string `if:"label=_"`
}

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_txt_list",
		Lede: "txts",
	}
}

// Gather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: &#x27;in&#x27; as each value from the list, and &#x27;out&#x27; as the var passed to the gather.
type Gather struct {
	Var     string     `if:"label=_"`
	From    ListSource `if:"label=from"`
	Pattern value.Text `if:"label=_"`
}

func (*Gather) Compose() composer.Spec {
	return composer.Spec{
		Name: "gather",
	}
}

// IntoNumList Targets a list of numbers
type IntoNumList struct {
	Var string `if:"label=_"`
}

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_num_list",
		Lede: "nums",
	}
}

// IntoRecList Targets a list of records
type IntoRecList struct {
	Var string `if:"label=_"`
}

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_rec_list",
		Lede: "recs",
	}
}

// IntoTxtList Targets a list of text
type IntoTxtList struct {
	Var string `if:"label=_"`
}

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_txt_list",
		Lede: "txts",
	}
}

// Len Determines the number of values in a list.
type Len struct {
	List rt.Assignment `if:"label=_"`
}

func (*Len) Compose() composer.Spec {
	return composer.Spec{
		Name: "len",
	}
}

// Map Transform the values from one list and place the results in another list. The designated pattern is called with each value from the &#x27;from list&#x27;, one value at a time.
type Map struct {
	ToList       value.Text    `if:"label=_"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using"`
}

func (*Map) Compose() composer.Spec {
	return composer.Spec{
		Name: "map",
	}
}

// PutEdge Add a value to a list
type PutEdge struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtFront rt.BoolEval   `if:"label=at_front,optional"`
}

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: "put_edge",
		Lede: "put",
	}
}

// PutIndex Replace one value in a list with another
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: "put_index",
		Lede: "put",
	}
}

// Range Generates a series of numbers r[i] &#x3D; (start + step*i) where i&gt;&#x3D;0.,Start and step default to 1, stop defaults to start;,the inputs are truncated to produce whole numbers;,a zero step returns an error.,A positive step ends the series when the returned value would exceed stop,while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: "range",
	}
}

// Reduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: &#x27;in&#x27; ( each element of the list ) and &#x27;out&#x27; ( ex. a record ).
type Reduce struct {
	IntoValue    value.Text    `if:"label=into"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using"`
}

func (*Reduce) Compose() composer.Spec {
	return composer.Spec{
		Name: "reduce",
		Lede: "list_reduce",
	}
}

// ReverseList Reverse a list.
type ReverseList struct {
	List ListSource `if:"label=_"`
}

func (*ReverseList) Compose() composer.Spec {
	return composer.Spec{
		Name: "reverse_list",
		Lede: "list_reverse",
	}
}

// Set Overwrite an existing value in a list.
type Set struct {
	List  value.Text    `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

func (*Set) Compose() composer.Spec {
	return composer.Spec{
		Name: "set",
		Lede: "list_set",
	}
}

// Slice Create a new list from a section of another list.,Start is optional, if omitted slice starts at the first element.,If start is greater the length, an empty array is returned.,Slice doesnt include the ending index.,Negatives indices indicates an offset from the end.,When end is omitted, copy up to and including the last element;,and do the same if the end is greater than the length
type Slice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

func (*Slice) Compose() composer.Spec {
	return composer.Spec{
		Name: "slice",
	}
}

// SortNumbers
type SortNumbers struct {
	Var        string      `if:"label=_"`
	ByField    string      `if:"label=by_field"`
	Descending rt.BoolEval `if:"label=descending,optional"`
}

func (*SortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: "sort_numbers",
		Lede: "sort",
	}
}

// SortRecords Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type SortRecords struct {
	Var   string `if:"label=_"`
	Using string `if:"label=using"`
}

func (*SortRecords) Compose() composer.Spec {
	return composer.Spec{
		Name: "sort_records",
		Lede: "sort",
	}
}

// SortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type SortText struct {
	Var        string      `if:"label=_"`
	ByField    string      `if:"label=by_field"`
	Descending rt.BoolEval `if:"label=descending,optional"`
	UsingCase  rt.BoolEval `if:"label=using_case,optional"`
}

func (*SortText) Compose() composer.Spec {
	return composer.Spec{
		Name: "sort_text",
		Lede: "sort",
	}
}

// Splice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list&#x27;s length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
type Splice struct {
	Var    string        `if:"label=_"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

func (*Splice) Compose() composer.Spec {
	return composer.Spec{
		Name: "splice",
	}
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}
var Slats = []interface{}{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*At)(nil),
	(*Each)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*Find)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*Gather)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*Len)(nil),
	(*Map)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
	(*Reduce)(nil),
	(*ReverseList)(nil),
	(*Set)(nil),
	(*Slice)(nil),
	(*SortNumbers)(nil),
	(*SortRecords)(nil),
	(*SortText)(nil),
	(*Splice)(nil),
}
