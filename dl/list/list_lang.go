// Code generated by "makeops"; edit at your own risk.
package list

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AsNum,
		Uses: composer.Type_Flow,
		Lede: "num",
	}
}

const Type_AsNum = "as_num"
const AsNum_Var = "$VAR"

func (op *AsNum) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AsNum_Detailed_Marshal(n, op)
}
func (op *AsNum) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AsNum_Detailed_Unmarshal(n, b, op)
}

func AsNum_Detailed_Marshal(n jsonexp.Context, val *AsNum) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AsNum_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AsNum,
			Fields: fields,
		})
	}
	return
}

func AsNum_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AsNum) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_AsNum, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[AsNum_Var], &out.Var); e != nil {
		err = errutil.New(Type_AsNum+"."+AsNum_Var, "-", e)
	}
	return
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AsRec,
		Uses: composer.Type_Flow,
		Lede: "rec",
	}
}

const Type_AsRec = "as_rec"
const AsRec_Var = "$VAR"

func (op *AsRec) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AsRec_Detailed_Marshal(n, op)
}
func (op *AsRec) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AsRec_Detailed_Unmarshal(n, b, op)
}

func AsRec_Detailed_Marshal(n jsonexp.Context, val *AsRec) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AsRec_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AsRec,
			Fields: fields,
		})
	}
	return
}

func AsRec_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AsRec) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_AsRec, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[AsRec_Var], &out.Var); e != nil {
		err = errutil.New(Type_AsRec+"."+AsRec_Var, "-", e)
	}
	return
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AsTxt,
		Uses: composer.Type_Flow,
		Lede: "txt",
	}
}

const Type_AsTxt = "as_txt"
const AsTxt_Var = "$VAR"

func (op *AsTxt) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AsTxt_Detailed_Marshal(n, op)
}
func (op *AsTxt) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AsTxt_Detailed_Unmarshal(n, b, op)
}

func AsTxt_Detailed_Marshal(n jsonexp.Context, val *AsTxt) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AsTxt_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AsTxt,
			Fields: fields,
		})
	}
	return
}

func AsTxt_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AsTxt) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_AsTxt, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[AsTxt_Var], &out.Var); e != nil {
		err = errutil.New(Type_AsTxt+"."+AsTxt_Var, "-", e)
	}
	return
}

// EraseEdge Erase at edge: Remove one or more values from a list
type EraseEdge struct {
	From   ListSource  `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
}

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EraseEdge,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const Type_EraseEdge = "erase_edge"
const EraseEdge_From = "$FROM"
const EraseEdge_AtEdge = "$AT_EDGE"

func (op *EraseEdge) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EraseEdge_Detailed_Marshal(n, op)
}
func (op *EraseEdge) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EraseEdge_Detailed_Unmarshal(n, b, op)
}

func EraseEdge_Detailed_Marshal(n jsonexp.Context, val *EraseEdge) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EraseEdge_From] = b
	}
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EraseEdge_AtEdge] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_EraseEdge,
			Fields: fields,
		})
	}
	return
}

func EraseEdge_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EraseEdge) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_EraseEdge, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[EraseEdge_From], &out.From); e != nil {
		err = errutil.New(Type_EraseEdge+"."+EraseEdge_From, "-", e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[EraseEdge_AtEdge], &out.AtEdge); e != nil {
		err = errutil.New(Type_EraseEdge+"."+EraseEdge_AtEdge, "-", e)
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EraseIndex,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const Type_EraseIndex = "erase_index"
const EraseIndex_Count = "$COUNT"
const EraseIndex_From = "$FROM"
const EraseIndex_AtIndex = "$AT_INDEX"

func (op *EraseIndex) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EraseIndex_Detailed_Marshal(n, op)
}
func (op *EraseIndex) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EraseIndex_Detailed_Unmarshal(n, b, op)
}

func EraseIndex_Detailed_Marshal(n jsonexp.Context, val *EraseIndex) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Count); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EraseIndex_Count] = b
	}
	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EraseIndex_From] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EraseIndex_AtIndex] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_EraseIndex,
			Fields: fields,
		})
	}
	return
}

func EraseIndex_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EraseIndex) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_EraseIndex, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[EraseIndex_Count], &out.Count); e != nil {
		err = errutil.New(Type_EraseIndex+"."+EraseIndex_Count, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[EraseIndex_From], &out.From); e != nil {
		err = errutil.New(Type_EraseIndex+"."+EraseIndex_From, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[EraseIndex_AtIndex], &out.AtIndex); e != nil {
		err = errutil.New(Type_EraseIndex+"."+EraseIndex_AtIndex, "-", e)
	}
	return
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Do      core.Activity `if:"label=do"`
}

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Erasing,
		Uses: composer.Type_Flow,
	}
}

const Type_Erasing = "erasing"
const Erasing_Count = "$COUNT"
const Erasing_From = "$FROM"
const Erasing_AtIndex = "$AT_INDEX"
const Erasing_As = "$AS"
const Erasing_Do = "$DO"

func (op *Erasing) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Erasing_Detailed_Marshal(n, op)
}
func (op *Erasing) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Erasing_Detailed_Unmarshal(n, b, op)
}

func Erasing_Detailed_Marshal(n jsonexp.Context, val *Erasing) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Count); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Erasing_Count] = b
	}
	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Erasing_From] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Erasing_AtIndex] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Erasing_As] = b
	}
	if b, e := core.Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Erasing_Do] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Erasing,
			Fields: fields,
		})
	}
	return
}

func Erasing_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Erasing) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Erasing, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[Erasing_Count], &out.Count); e != nil {
		err = errutil.New(Type_Erasing+"."+Erasing_Count, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[Erasing_From], &out.From); e != nil {
		err = errutil.New(Type_Erasing+"."+Erasing_From, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[Erasing_AtIndex], &out.AtIndex); e != nil {
		err = errutil.New(Type_Erasing+"."+Erasing_AtIndex, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Erasing_As], &out.As); e != nil {
		err = errutil.New(Type_Erasing+"."+Erasing_As, "-", e)
	} else if e := core.Activity_Detailed_Unmarshal(n, msg.Fields[Erasing_Do], &out.Do); e != nil {
		err = errutil.New(Type_Erasing+"."+Erasing_Do, "-", e)
	}
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From   ListSource    `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Do     core.Activity `if:"label=do"`
	Else   core.Brancher `if:"label=else,optional"`
}

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ErasingEdge,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const Type_ErasingEdge = "erasing_edge"
const ErasingEdge_From = "$FROM"
const ErasingEdge_AtEdge = "$AT_EDGE"
const ErasingEdge_As = "$AS"
const ErasingEdge_Do = "$DO"
const ErasingEdge_Else = "$ELSE"

func (op *ErasingEdge) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ErasingEdge_Detailed_Marshal(n, op)
}
func (op *ErasingEdge) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ErasingEdge_Detailed_Unmarshal(n, b, op)
}

func ErasingEdge_Detailed_Marshal(n jsonexp.Context, val *ErasingEdge) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ErasingEdge_From] = b
	}
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ErasingEdge_AtEdge] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ErasingEdge_As] = b
	}
	if b, e := core.Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ErasingEdge_Do] = b
	}
	if b, e := core.Brancher_Detailed_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ErasingEdge_Else] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ErasingEdge,
			Fields: fields,
		})
	}
	return
}

func ErasingEdge_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ErasingEdge) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ErasingEdge, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[ErasingEdge_From], &out.From); e != nil {
		err = errutil.New(Type_ErasingEdge+"."+ErasingEdge_From, "-", e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ErasingEdge_AtEdge], &out.AtEdge); e != nil {
		err = errutil.New(Type_ErasingEdge+"."+ErasingEdge_AtEdge, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ErasingEdge_As], &out.As); e != nil {
		err = errutil.New(Type_ErasingEdge+"."+ErasingEdge_As, "-", e)
	} else if e := core.Activity_Detailed_Unmarshal(n, msg.Fields[ErasingEdge_Do], &out.Do); e != nil {
		err = errutil.New(Type_ErasingEdge+"."+ErasingEdge_Do, "-", e)
	} else if e := core.Brancher_Detailed_Unmarshal(n, msg.Fields[ErasingEdge_Else], &out.Else); e != nil {
		err = errutil.New(Type_ErasingEdge+"."+ErasingEdge_Else, "-", e)
	}
	return
}

// FromNumList Uses a list of numbers
type FromNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromNumList,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const Type_FromNumList = "from_num_list"
const FromNumList_Var = "$VAR"

func (op *FromNumList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromNumList_Detailed_Marshal(n, op)
}
func (op *FromNumList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromNumList_Detailed_Unmarshal(n, b, op)
}

func FromNumList_Detailed_Marshal(n jsonexp.Context, val *FromNumList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromNumList_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromNumList,
			Fields: fields,
		})
	}
	return
}

func FromNumList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromNumList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_FromNumList, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[FromNumList_Var], &out.Var); e != nil {
		err = errutil.New(Type_FromNumList+"."+FromNumList_Var, "-", e)
	}
	return
}

// FromRecList Uses a list of records
type FromRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromRecList,
		Uses: composer.Type_Flow,
		Lede: "recs",
	}
}

const Type_FromRecList = "from_rec_list"
const FromRecList_Var = "$VAR"

func (op *FromRecList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromRecList_Detailed_Marshal(n, op)
}
func (op *FromRecList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromRecList_Detailed_Unmarshal(n, b, op)
}

func FromRecList_Detailed_Marshal(n jsonexp.Context, val *FromRecList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromRecList_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromRecList,
			Fields: fields,
		})
	}
	return
}

func FromRecList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromRecList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_FromRecList, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[FromRecList_Var], &out.Var); e != nil {
		err = errutil.New(Type_FromRecList+"."+FromRecList_Var, "-", e)
	}
	return
}

// FromTxtList Uses a list of text
type FromTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromTxtList,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const Type_FromTxtList = "from_txt_list"
const FromTxtList_Var = "$VAR"

func (op *FromTxtList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromTxtList_Detailed_Marshal(n, op)
}
func (op *FromTxtList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromTxtList_Detailed_Unmarshal(n, b, op)
}

func FromTxtList_Detailed_Marshal(n jsonexp.Context, val *FromTxtList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[FromTxtList_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_FromTxtList,
			Fields: fields,
		})
	}
	return
}

func FromTxtList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromTxtList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_FromTxtList, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[FromTxtList_Var], &out.Var); e != nil {
		err = errutil.New(Type_FromTxtList+"."+FromTxtList_Var, "-", e)
	}
	return
}

// IntoNumList Targets a list of numbers
type IntoNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoNumList,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const Type_IntoNumList = "into_num_list"
const IntoNumList_Var = "$VAR"

func (op *IntoNumList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IntoNumList_Detailed_Marshal(n, op)
}
func (op *IntoNumList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IntoNumList_Detailed_Unmarshal(n, b, op)
}

func IntoNumList_Detailed_Marshal(n jsonexp.Context, val *IntoNumList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IntoNumList_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IntoNumList,
			Fields: fields,
		})
	}
	return
}

func IntoNumList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoNumList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_IntoNumList, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[IntoNumList_Var], &out.Var); e != nil {
		err = errutil.New(Type_IntoNumList+"."+IntoNumList_Var, "-", e)
	}
	return
}

// IntoRecList Targets a list of records
type IntoRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoRecList,
		Uses: composer.Type_Flow,
		Lede: "recs",
	}
}

const Type_IntoRecList = "into_rec_list"
const IntoRecList_Var = "$VAR"

func (op *IntoRecList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IntoRecList_Detailed_Marshal(n, op)
}
func (op *IntoRecList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IntoRecList_Detailed_Unmarshal(n, b, op)
}

func IntoRecList_Detailed_Marshal(n jsonexp.Context, val *IntoRecList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IntoRecList_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IntoRecList,
			Fields: fields,
		})
	}
	return
}

func IntoRecList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoRecList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_IntoRecList, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[IntoRecList_Var], &out.Var); e != nil {
		err = errutil.New(Type_IntoRecList+"."+IntoRecList_Var, "-", e)
	}
	return
}

// IntoTxtList Targets a list of text
type IntoTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoTxtList,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const Type_IntoTxtList = "into_txt_list"
const IntoTxtList_Var = "$VAR"

func (op *IntoTxtList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IntoTxtList_Detailed_Marshal(n, op)
}
func (op *IntoTxtList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IntoTxtList_Detailed_Unmarshal(n, b, op)
}

func IntoTxtList_Detailed_Marshal(n jsonexp.Context, val *IntoTxtList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[IntoTxtList_Var] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_IntoTxtList,
			Fields: fields,
		})
	}
	return
}

func IntoTxtList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoTxtList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_IntoTxtList, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[IntoTxtList_Var], &out.Var); e != nil {
		err = errutil.New(Type_IntoTxtList+"."+IntoTxtList_Var, "-", e)
	}
	return
}

// ListAt Get a value from a list. The first element is is index 1.
type ListAt struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListAt,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const Type_ListAt = "list_at"
const ListAt_List = "$LIST"
const ListAt_Index = "$INDEX"

func (op *ListAt) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListAt_Detailed_Marshal(n, op)
}
func (op *ListAt) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListAt_Detailed_Unmarshal(n, b, op)
}

func ListAt_Detailed_Marshal(n jsonexp.Context, val *ListAt) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListAt_List] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Index); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListAt_Index] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListAt,
			Fields: fields,
		})
	}
	return
}

func ListAt_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListAt) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListAt, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListAt_List], &out.List); e != nil {
		err = errutil.New(Type_ListAt+"."+ListAt_List, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListAt_Index], &out.Index); e != nil {
		err = errutil.New(Type_ListAt+"."+ListAt_Index, "-", e)
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the &#x27;else&#x27; activity if empty.
type ListEach struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListEach,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const Type_ListEach = "list_each"
const ListEach_List = "$LIST"
const ListEach_As = "$AS"
const ListEach_Do = "$DO"
const ListEach_Else = "$ELSE"

func (op *ListEach) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListEach_Detailed_Marshal(n, op)
}
func (op *ListEach) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListEach_Detailed_Unmarshal(n, b, op)
}

func ListEach_Detailed_Marshal(n jsonexp.Context, val *ListEach) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListEach_List] = b
	}
	if b, e := ListIterator_Detailed_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListEach_As] = b
	}
	if b, e := core.Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListEach_Do] = b
	}
	if b, e := core.Brancher_Detailed_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListEach_Else] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListEach,
			Fields: fields,
		})
	}
	return
}

func ListEach_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListEach) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListEach, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListEach_List], &out.List); e != nil {
		err = errutil.New(Type_ListEach+"."+ListEach_List, "-", e)
	} else if e := ListIterator_Detailed_Unmarshal(n, msg.Fields[ListEach_As], &out.As); e != nil {
		err = errutil.New(Type_ListEach+"."+ListEach_As, "-", e)
	} else if e := core.Activity_Detailed_Unmarshal(n, msg.Fields[ListEach_Do], &out.Do); e != nil {
		err = errutil.New(Type_ListEach+"."+ListEach_Do, "-", e)
	} else if e := core.Brancher_Detailed_Unmarshal(n, msg.Fields[ListEach_Else], &out.Else); e != nil {
		err = errutil.New(Type_ListEach+"."+ListEach_Else, "-", e)
	}
	return
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListFind,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const Type_ListFind = "list_find"
const ListFind_Value = "$VALUE"
const ListFind_List = "$LIST"

func (op *ListFind) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListFind_Detailed_Marshal(n, op)
}
func (op *ListFind) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListFind_Detailed_Unmarshal(n, b, op)
}

func ListFind_Detailed_Marshal(n jsonexp.Context, val *ListFind) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.Value); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListFind_Value] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListFind_List] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListFind,
			Fields: fields,
		})
	}
	return
}

func ListFind_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListFind) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListFind, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListFind_Value], &out.Value); e != nil {
		err = errutil.New(Type_ListFind+"."+ListFind_Value, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListFind_List], &out.List); e != nil {
		err = errutil.New(Type_ListFind+"."+ListFind_List, "-", e)
	}
	return
}

// ListGather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: &#x27;in&#x27; as each value from the list, and &#x27;out&#x27; as the var passed to the gather.
type ListGather struct {
	Var   value.VariableName `if:"label=_"`
	From  ListSource         `if:"label=from"`
	Using string             `if:"label=_,type=text"`
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListGather,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const Type_ListGather = "list_gather"
const ListGather_Var = "$VAR"
const ListGather_From = "$FROM"
const ListGather_Using = "$USING"

func (op *ListGather) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListGather_Detailed_Marshal(n, op)
}
func (op *ListGather) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListGather_Detailed_Unmarshal(n, b, op)
}

func ListGather_Detailed_Marshal(n jsonexp.Context, val *ListGather) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListGather_Var] = b
	}
	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListGather_From] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Using); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListGather_Using] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListGather,
			Fields: fields,
		})
	}
	return
}

func ListGather_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListGather) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListGather, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[ListGather_Var], &out.Var); e != nil {
		err = errutil.New(Type_ListGather+"."+ListGather_Var, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[ListGather_From], &out.From); e != nil {
		err = errutil.New(Type_ListGather+"."+ListGather_From, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListGather_Using], &out.Using); e != nil {
		err = errutil.New(Type_ListGather+"."+ListGather_Using, "-", e)
	}
	return
}

const Type_ListIterator = "list_iterator"

func ListIterator_Detailed_Marshal(n jsonexp.Context, ptr *ListIterator) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_ListIterator,
			Value: b,
		})
	}
	return
}

func ListIterator_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListIterator) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListIterator); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_ListIterator)
	} else {
		(*out) = store
	}
	return
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List rt.Assignment `if:"label=_"`
}

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListLen,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const Type_ListLen = "list_len"
const ListLen_List = "$LIST"

func (op *ListLen) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListLen_Detailed_Marshal(n, op)
}
func (op *ListLen) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListLen_Detailed_Unmarshal(n, b, op)
}

func ListLen_Detailed_Marshal(n jsonexp.Context, val *ListLen) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListLen_List] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListLen,
			Fields: fields,
		})
	}
	return
}

func ListLen_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListLen) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListLen, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListLen_List], &out.List); e != nil {
		err = errutil.New(Type_ListLen+"."+ListLen_List, "-", e)
	}
	return
}

// ListMap Transform the values from one list and place the results in another list. The designated pattern is called with each value from the &#x27;from list&#x27;, one value at a time.
type ListMap struct {
	ToList       string        `if:"label=_,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListMap,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const Type_ListMap = "list_map"
const ListMap_ToList = "$TO_LIST"
const ListMap_FromList = "$FROM_LIST"
const ListMap_UsingPattern = "$USING_PATTERN"

func (op *ListMap) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListMap_Detailed_Marshal(n, op)
}
func (op *ListMap) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListMap_Detailed_Unmarshal(n, b, op)
}

func ListMap_Detailed_Marshal(n jsonexp.Context, val *ListMap) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.ToList); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListMap_ToList] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.FromList); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListMap_FromList] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.UsingPattern); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListMap_UsingPattern] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListMap,
			Fields: fields,
		})
	}
	return
}

func ListMap_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListMap) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListMap, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListMap_ToList], &out.ToList); e != nil {
		err = errutil.New(Type_ListMap+"."+ListMap_ToList, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListMap_FromList], &out.FromList); e != nil {
		err = errutil.New(Type_ListMap+"."+ListMap_FromList, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListMap_UsingPattern], &out.UsingPattern); e != nil {
		err = errutil.New(Type_ListMap+"."+ListMap_UsingPattern, "-", e)
	}
	return
}

// ListReduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: &#x27;in&#x27; ( each element of the list ) and &#x27;out&#x27; ( ex. a record ).
type ListReduce struct {
	IntoValue    string        `if:"label=into,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListReduce,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const Type_ListReduce = "list_reduce"
const ListReduce_IntoValue = "$INTO_VALUE"
const ListReduce_FromList = "$FROM_LIST"
const ListReduce_UsingPattern = "$USING_PATTERN"

func (op *ListReduce) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListReduce_Detailed_Marshal(n, op)
}
func (op *ListReduce) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListReduce_Detailed_Unmarshal(n, b, op)
}

func ListReduce_Detailed_Marshal(n jsonexp.Context, val *ListReduce) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.IntoValue); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListReduce_IntoValue] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.FromList); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListReduce_FromList] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.UsingPattern); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListReduce_UsingPattern] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListReduce,
			Fields: fields,
		})
	}
	return
}

func ListReduce_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListReduce) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListReduce, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListReduce_IntoValue], &out.IntoValue); e != nil {
		err = errutil.New(Type_ListReduce+"."+ListReduce_IntoValue, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListReduce_FromList], &out.FromList); e != nil {
		err = errutil.New(Type_ListReduce+"."+ListReduce_FromList, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListReduce_UsingPattern], &out.UsingPattern); e != nil {
		err = errutil.New(Type_ListReduce+"."+ListReduce_UsingPattern, "-", e)
	}
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	List ListSource `if:"label=_"`
}

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListReverse,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const Type_ListReverse = "list_reverse"
const ListReverse_List = "$LIST"

func (op *ListReverse) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListReverse_Detailed_Marshal(n, op)
}
func (op *ListReverse) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListReverse_Detailed_Unmarshal(n, b, op)
}

func ListReverse_Detailed_Marshal(n jsonexp.Context, val *ListReverse) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ListSource_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListReverse_List] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListReverse,
			Fields: fields,
		})
	}
	return
}

func ListReverse_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListReverse) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListReverse, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[ListReverse_List], &out.List); e != nil {
		err = errutil.New(Type_ListReverse+"."+ListReverse_List, "-", e)
	}
	return
}

// ListSet Overwrite an existing value in a list.
type ListSet struct {
	List  string        `if:"label=_,type=text"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSet,
		Uses: composer.Type_Flow,
		Lede: "set",
	}
}

const Type_ListSet = "list_set"
const ListSet_List = "$LIST"
const ListSet_Index = "$INDEX"
const ListSet_From = "$FROM"

func (op *ListSet) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSet_Detailed_Marshal(n, op)
}
func (op *ListSet) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSet_Detailed_Unmarshal(n, b, op)
}

func ListSet_Detailed_Marshal(n jsonexp.Context, val *ListSet) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSet_List] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Index); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSet_Index] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSet_From] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListSet,
			Fields: fields,
		})
	}
	return
}

func ListSet_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSet) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListSet, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListSet_List], &out.List); e != nil {
		err = errutil.New(Type_ListSet+"."+ListSet_List, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListSet_Index], &out.Index); e != nil {
		err = errutil.New(Type_ListSet+"."+ListSet_Index, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListSet_From], &out.From); e != nil {
		err = errutil.New(Type_ListSet+"."+ListSet_From, "-", e)
	}
	return
}

// ListSlice Create a new list from a section of another list.,Start is optional, if omitted slice starts at the first element.,If start is greater the length, an empty array is returned.,Slice doesnt include the ending index.,Negatives indices indicates an offset from the end.,When end is omitted, copy up to and including the last element;,and do the same if the end is greater than the length
type ListSlice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSlice,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const Type_ListSlice = "list_slice"
const ListSlice_List = "$LIST"
const ListSlice_Start = "$START"
const ListSlice_End = "$END"

func (op *ListSlice) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSlice_Detailed_Marshal(n, op)
}
func (op *ListSlice) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSlice_Detailed_Unmarshal(n, b, op)
}

func ListSlice_Detailed_Marshal(n jsonexp.Context, val *ListSlice) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSlice_List] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Start); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSlice_Start] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.End); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSlice_End] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListSlice,
			Fields: fields,
		})
	}
	return
}

func ListSlice_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSlice) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListSlice, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListSlice_List], &out.List); e != nil {
		err = errutil.New(Type_ListSlice+"."+ListSlice_List, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListSlice_Start], &out.Start); e != nil {
		err = errutil.New(Type_ListSlice+"."+ListSlice_Start, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListSlice_End], &out.End); e != nil {
		err = errutil.New(Type_ListSlice+"."+ListSlice_End, "-", e)
	}
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
}

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSortNumbers,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const Type_ListSortNumbers = "list_sort_numbers"
const ListSortNumbers_Var = "$VAR"
const ListSortNumbers_ByField = "$BY_FIELD"
const ListSortNumbers_Descending = "$DESCENDING"

func (op *ListSortNumbers) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSortNumbers_Detailed_Marshal(n, op)
}
func (op *ListSortNumbers) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSortNumbers_Detailed_Unmarshal(n, b, op)
}

func ListSortNumbers_Detailed_Marshal(n jsonexp.Context, val *ListSortNumbers) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortNumbers_Var] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.ByField); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortNumbers_ByField] = b
	}
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.Descending); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortNumbers_Descending] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListSortNumbers,
			Fields: fields,
		})
	}
	return
}

func ListSortNumbers_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSortNumbers) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListSortNumbers, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[ListSortNumbers_Var], &out.Var); e != nil {
		err = errutil.New(Type_ListSortNumbers+"."+ListSortNumbers_Var, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListSortNumbers_ByField], &out.ByField); e != nil {
		err = errutil.New(Type_ListSortNumbers+"."+ListSortNumbers_ByField, "-", e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ListSortNumbers_Descending], &out.Descending); e != nil {
		err = errutil.New(Type_ListSortNumbers+"."+ListSortNumbers_Descending, "-", e)
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
	UsingCase  rt.BoolEval        `if:"label=using_case,optional"`
}

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSortText,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const Type_ListSortText = "list_sort_text"
const ListSortText_Var = "$VAR"
const ListSortText_ByField = "$BY_FIELD"
const ListSortText_Descending = "$DESCENDING"
const ListSortText_UsingCase = "$USING_CASE"

func (op *ListSortText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSortText_Detailed_Marshal(n, op)
}
func (op *ListSortText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSortText_Detailed_Unmarshal(n, b, op)
}

func ListSortText_Detailed_Marshal(n jsonexp.Context, val *ListSortText) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortText_Var] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.ByField); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortText_ByField] = b
	}
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.Descending); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortText_Descending] = b
	}
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.UsingCase); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortText_UsingCase] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListSortText,
			Fields: fields,
		})
	}
	return
}

func ListSortText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSortText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListSortText, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[ListSortText_Var], &out.Var); e != nil {
		err = errutil.New(Type_ListSortText+"."+ListSortText_Var, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListSortText_ByField], &out.ByField); e != nil {
		err = errutil.New(Type_ListSortText+"."+ListSortText_ByField, "-", e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ListSortText_Descending], &out.Descending); e != nil {
		err = errutil.New(Type_ListSortText+"."+ListSortText_Descending, "-", e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[ListSortText_UsingCase], &out.UsingCase); e != nil {
		err = errutil.New(Type_ListSortText+"."+ListSortText_UsingCase, "-", e)
	}
	return
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortUsing struct {
	Var   value.VariableName `if:"label=_"`
	Using string             `if:"label=using,type=text"`
}

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSortUsing,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const Type_ListSortUsing = "list_sort_using"
const ListSortUsing_Var = "$VAR"
const ListSortUsing_Using = "$USING"

func (op *ListSortUsing) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSortUsing_Detailed_Marshal(n, op)
}
func (op *ListSortUsing) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSortUsing_Detailed_Unmarshal(n, b, op)
}

func ListSortUsing_Detailed_Marshal(n jsonexp.Context, val *ListSortUsing) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortUsing_Var] = b
	}
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Using); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortUsing_Using] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListSortUsing,
			Fields: fields,
		})
	}
	return
}

func ListSortUsing_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSortUsing) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListSortUsing, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[ListSortUsing_Var], &out.Var); e != nil {
		err = errutil.New(Type_ListSortUsing+"."+ListSortUsing_Var, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListSortUsing_Using], &out.Using); e != nil {
		err = errutil.New(Type_ListSortUsing+"."+ListSortUsing_Using, "-", e)
	}
	return
}

const Type_ListSource = "list_source"

func ListSource_Detailed_Marshal(n jsonexp.Context, ptr *ListSource) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_ListSource,
			Value: b,
		})
	}
	return
}

func ListSource_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSource) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListSource); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_ListSource)
	} else {
		(*out) = store
	}
	return
}

// ListSplice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list&#x27;s length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
type ListSplice struct {
	List   string        `if:"label=_,type=text"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSplice,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const Type_ListSplice = "list_splice"
const ListSplice_List = "$LIST"
const ListSplice_Start = "$START"
const ListSplice_Remove = "$REMOVE"
const ListSplice_Insert = "$INSERT"

func (op *ListSplice) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSplice_Detailed_Marshal(n, op)
}
func (op *ListSplice) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSplice_Detailed_Unmarshal(n, b, op)
}

func ListSplice_Detailed_Marshal(n jsonexp.Context, val *ListSplice) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSplice_List] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Start); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSplice_Start] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Remove); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSplice_Remove] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.Insert); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSplice_Insert] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ListSplice,
			Fields: fields,
		})
	}
	return
}

func ListSplice_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSplice) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ListSplice, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[ListSplice_List], &out.List); e != nil {
		err = errutil.New(Type_ListSplice+"."+ListSplice_List, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListSplice_Start], &out.Start); e != nil {
		err = errutil.New(Type_ListSplice+"."+ListSplice_Start, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListSplice_Remove], &out.Remove); e != nil {
		err = errutil.New(Type_ListSplice+"."+ListSplice_Remove, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListSplice_Insert], &out.Insert); e != nil {
		err = errutil.New(Type_ListSplice+"."+ListSplice_Insert, "-", e)
	}
	return
}

const Type_ListTarget = "list_target"

func ListTarget_Detailed_Marshal(n jsonexp.Context, ptr *ListTarget) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_ListTarget,
			Value: b,
		})
	}
	return
}

func ListTarget_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListTarget) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListTarget); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_ListTarget)
	} else {
		(*out) = store
	}
	return
}

// PutEdge Add a value to a list
type PutEdge struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
}

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PutEdge,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const Type_PutEdge = "put_edge"
const PutEdge_From = "$FROM"
const PutEdge_Into = "$INTO"
const PutEdge_AtEdge = "$AT_EDGE"

func (op *PutEdge) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PutEdge_Detailed_Marshal(n, op)
}
func (op *PutEdge) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PutEdge_Detailed_Unmarshal(n, b, op)
}

func PutEdge_Detailed_Marshal(n jsonexp.Context, val *PutEdge) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutEdge_From] = b
	}
	if b, e := ListTarget_Detailed_Marshal(n, &val.Into); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutEdge_Into] = b
	}
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutEdge_AtEdge] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PutEdge,
			Fields: fields,
		})
	}
	return
}

func PutEdge_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PutEdge) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PutEdge, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[PutEdge_From], &out.From); e != nil {
		err = errutil.New(Type_PutEdge+"."+PutEdge_From, "-", e)
	} else if e := ListTarget_Detailed_Unmarshal(n, msg.Fields[PutEdge_Into], &out.Into); e != nil {
		err = errutil.New(Type_PutEdge+"."+PutEdge_Into, "-", e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[PutEdge_AtEdge], &out.AtEdge); e != nil {
		err = errutil.New(Type_PutEdge+"."+PutEdge_AtEdge, "-", e)
	}
	return
}

// PutIndex Replace one value in a list with another
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PutIndex,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const Type_PutIndex = "put_index"
const PutIndex_From = "$FROM"
const PutIndex_Into = "$INTO"
const PutIndex_AtIndex = "$AT_INDEX"

func (op *PutIndex) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PutIndex_Detailed_Marshal(n, op)
}
func (op *PutIndex) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PutIndex_Detailed_Unmarshal(n, b, op)
}

func PutIndex_Detailed_Marshal(n jsonexp.Context, val *PutIndex) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutIndex_From] = b
	}
	if b, e := ListTarget_Detailed_Marshal(n, &val.Into); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutIndex_Into] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutIndex_AtIndex] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PutIndex,
			Fields: fields,
		})
	}
	return
}

func PutIndex_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PutIndex) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PutIndex, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[PutIndex_From], &out.From); e != nil {
		err = errutil.New(Type_PutIndex+"."+PutIndex_From, "-", e)
	} else if e := ListTarget_Detailed_Unmarshal(n, msg.Fields[PutIndex_Into], &out.Into); e != nil {
		err = errutil.New(Type_PutIndex+"."+PutIndex_Into, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[PutIndex_AtIndex], &out.AtIndex); e != nil {
		err = errutil.New(Type_PutIndex+"."+PutIndex_AtIndex, "-", e)
	}
	return
}

// Range Generates a series of numbers r[i] &#x3D; (start + step*i) where i&gt;&#x3D;0.,Start and step default to 1, stop defaults to start;,the inputs are truncated to produce whole numbers;,a zero step returns an error.,A positive step ends the series when the returned value would exceed stop,while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Range,
		Uses: composer.Type_Flow,
	}
}

const Type_Range = "range"
const Range_To = "$TO"
const Range_From = "$FROM"
const Range_ByStep = "$BY_STEP"

func (op *Range) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Range_Detailed_Marshal(n, op)
}
func (op *Range) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Range_Detailed_Unmarshal(n, b, op)
}

func Range_Detailed_Marshal(n jsonexp.Context, val *Range) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.To); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Range_To] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Range_From] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.ByStep); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Range_ByStep] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Range,
			Fields: fields,
		})
	}
	return
}

func Range_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Range) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Range, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[Range_To], &out.To); e != nil {
		err = errutil.New(Type_Range+"."+Range_To, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[Range_From], &out.From); e != nil {
		err = errutil.New(Type_Range+"."+Range_From, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[Range_ByStep], &out.ByStep); e != nil {
		err = errutil.New(Type_Range+"."+Range_ByStep, "-", e)
	}
	return
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}

var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
}
