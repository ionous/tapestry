// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/tapestry/dl/assign"
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/jsn"
	"git.sr.ht/~ionous/tapestry/rt"
	"github.com/ionous/errutil"
)

// EraseEdge Erase at edge: Remove one or more values from a list.
type EraseEdge struct {
	Target assign.Address `if:"label=_"`
	AtEdge rt.BoolEval    `if:"label=at_front,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*EraseEdge)(nil)

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseEdge_Type = "erase_edge"
const EraseEdge_Field_Target = "$TARGET"
const EraseEdge_Field_AtEdge = "$AT_EDGE"

func (op *EraseEdge) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Marshal(m, op)
}

type EraseEdge_Slice []EraseEdge

func (op *EraseEdge_Slice) GetType() string { return EraseEdge_Type }

func (op *EraseEdge_Slice) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Repeats_Marshal(m, (*[]EraseEdge)(op))
}

func (op *EraseEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EraseEdge_Slice) SetSize(cnt int) {
	var els []EraseEdge
	if cnt >= 0 {
		els = make(EraseEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *EraseEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EraseEdge_Marshal(m, &(*op)[i])
}

func EraseEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseEdge) error {
	return jsn.RepeatBlock(m, (*EraseEdge_Slice)(vals))
}

func EraseEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EraseEdge) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EraseEdge_Repeats_Marshal(m, pv)
	}
	return
}

type EraseEdge_Flow struct{ ptr *EraseEdge }

func (n EraseEdge_Flow) GetType() string      { return EraseEdge_Type }
func (n EraseEdge_Flow) GetLede() string      { return "erase" }
func (n EraseEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n EraseEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EraseEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EraseEdge_Optional_Marshal(m jsn.Marshaler, pv **EraseEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseEdge_Marshal(m, *pv)
	} else if !enc {
		var v EraseEdge
		if err = EraseEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseEdge_Marshal(m jsn.Marshaler, val *EraseEdge) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EraseEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EraseEdge_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseEdge_Field_Target))
		}
		e1 := m.MarshalKey("at_front", EraseEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseEdge_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list.
type EraseIndex struct {
	Count   rt.NumberEval  `if:"label=_"`
	Target  assign.Address `if:"label=from"`
	AtIndex rt.NumberEval  `if:"label=at_index"`
	Markup  map[string]any
}

// User implemented slots:
var _ rt.Execute = (*EraseIndex)(nil)

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseIndex_Type = "erase_index"
const EraseIndex_Field_Count = "$COUNT"
const EraseIndex_Field_Target = "$TARGET"
const EraseIndex_Field_AtIndex = "$AT_INDEX"

func (op *EraseIndex) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Marshal(m, op)
}

type EraseIndex_Slice []EraseIndex

func (op *EraseIndex_Slice) GetType() string { return EraseIndex_Type }

func (op *EraseIndex_Slice) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Repeats_Marshal(m, (*[]EraseIndex)(op))
}

func (op *EraseIndex_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EraseIndex_Slice) SetSize(cnt int) {
	var els []EraseIndex
	if cnt >= 0 {
		els = make(EraseIndex_Slice, cnt)
	}
	(*op) = els
}

func (op *EraseIndex_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EraseIndex_Marshal(m, &(*op)[i])
}

func EraseIndex_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseIndex) error {
	return jsn.RepeatBlock(m, (*EraseIndex_Slice)(vals))
}

func EraseIndex_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EraseIndex) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EraseIndex_Repeats_Marshal(m, pv)
	}
	return
}

type EraseIndex_Flow struct{ ptr *EraseIndex }

func (n EraseIndex_Flow) GetType() string      { return EraseIndex_Type }
func (n EraseIndex_Flow) GetLede() string      { return "erase" }
func (n EraseIndex_Flow) GetFlow() interface{} { return n.ptr }
func (n EraseIndex_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EraseIndex); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EraseIndex_Optional_Marshal(m jsn.Marshaler, pv **EraseIndex) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseIndex_Marshal(m, *pv)
	} else if !enc {
		var v EraseIndex
		if err = EraseIndex_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseIndex_Marshal(m jsn.Marshaler, val *EraseIndex) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EraseIndex_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EraseIndex_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseIndex_Field_Count))
		}
		e1 := m.MarshalKey("from", EraseIndex_Field_Target)
		if e1 == nil {
			e1 = assign.Address_Marshal(m, &val.Target)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseIndex_Field_Target))
		}
		e2 := m.MarshalKey("at_index", EraseIndex_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EraseIndex_Field_AtIndex))
		}
		m.EndBlock()
	}
	return
}

// Erasing Erase elements from the front or back of a list.
// Runs a pattern with a list containing the erased values.
// If nothing was erased, the pattern will be called with an empty list.
type Erasing struct {
	Count   rt.NumberEval  `if:"label=_"`
	Target  assign.Address `if:"label=from"`
	AtIndex rt.NumberEval  `if:"label=at_index"`
	As      string         `if:"label=as,type=text"`
	Does    []rt.Execute   `if:"label=does"`
	Markup  map[string]any
}

// User implemented slots:
var _ rt.Execute = (*Erasing)(nil)

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Erasing_Type,
		Uses: composer.Type_Flow,
	}
}

const Erasing_Type = "erasing"
const Erasing_Field_Count = "$COUNT"
const Erasing_Field_Target = "$TARGET"
const Erasing_Field_AtIndex = "$AT_INDEX"
const Erasing_Field_As = "$AS"
const Erasing_Field_Does = "$DOES"

func (op *Erasing) Marshal(m jsn.Marshaler) error {
	return Erasing_Marshal(m, op)
}

type Erasing_Slice []Erasing

func (op *Erasing_Slice) GetType() string { return Erasing_Type }

func (op *Erasing_Slice) Marshal(m jsn.Marshaler) error {
	return Erasing_Repeats_Marshal(m, (*[]Erasing)(op))
}

func (op *Erasing_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Erasing_Slice) SetSize(cnt int) {
	var els []Erasing
	if cnt >= 0 {
		els = make(Erasing_Slice, cnt)
	}
	(*op) = els
}

func (op *Erasing_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Erasing_Marshal(m, &(*op)[i])
}

func Erasing_Repeats_Marshal(m jsn.Marshaler, vals *[]Erasing) error {
	return jsn.RepeatBlock(m, (*Erasing_Slice)(vals))
}

func Erasing_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Erasing) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Erasing_Repeats_Marshal(m, pv)
	}
	return
}

type Erasing_Flow struct{ ptr *Erasing }

func (n Erasing_Flow) GetType() string      { return Erasing_Type }
func (n Erasing_Flow) GetLede() string      { return Erasing_Type }
func (n Erasing_Flow) GetFlow() interface{} { return n.ptr }
func (n Erasing_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Erasing); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Erasing_Optional_Marshal(m jsn.Marshaler, pv **Erasing) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Erasing_Marshal(m, *pv)
	} else if !enc {
		var v Erasing
		if err = Erasing_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Erasing_Marshal(m jsn.Marshaler, val *Erasing) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Erasing_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Erasing_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Erasing_Field_Count))
		}
		e1 := m.MarshalKey("from", Erasing_Field_Target)
		if e1 == nil {
			e1 = assign.Address_Marshal(m, &val.Target)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Erasing_Field_Target))
		}
		e2 := m.MarshalKey("at_index", Erasing_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Erasing_Field_AtIndex))
		}
		e3 := m.MarshalKey("as", Erasing_Field_As)
		if e3 == nil {
			e3 = prim.Text_Unboxed_Marshal(m, &val.As)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", Erasing_Field_As))
		}
		e4 := m.MarshalKey("does", Erasing_Field_Does)
		if e4 == nil {
			e4 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", Erasing_Field_Does))
		}
		m.EndBlock()
	}
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	Target assign.Address `if:"label=_"`
	AtEdge rt.BoolEval    `if:"label=at_front,optional"`
	As     string         `if:"label=as,type=text"`
	Does   []rt.Execute   `if:"label=does"`
	Else   core.Brancher  `if:"label=else,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ErasingEdge)(nil)

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: ErasingEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const ErasingEdge_Type = "erasing_edge"
const ErasingEdge_Field_Target = "$TARGET"
const ErasingEdge_Field_AtEdge = "$AT_EDGE"
const ErasingEdge_Field_As = "$AS"
const ErasingEdge_Field_Does = "$DOES"
const ErasingEdge_Field_Else = "$ELSE"

func (op *ErasingEdge) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Marshal(m, op)
}

type ErasingEdge_Slice []ErasingEdge

func (op *ErasingEdge_Slice) GetType() string { return ErasingEdge_Type }

func (op *ErasingEdge_Slice) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Repeats_Marshal(m, (*[]ErasingEdge)(op))
}

func (op *ErasingEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ErasingEdge_Slice) SetSize(cnt int) {
	var els []ErasingEdge
	if cnt >= 0 {
		els = make(ErasingEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *ErasingEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ErasingEdge_Marshal(m, &(*op)[i])
}

func ErasingEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]ErasingEdge) error {
	return jsn.RepeatBlock(m, (*ErasingEdge_Slice)(vals))
}

func ErasingEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ErasingEdge) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ErasingEdge_Repeats_Marshal(m, pv)
	}
	return
}

type ErasingEdge_Flow struct{ ptr *ErasingEdge }

func (n ErasingEdge_Flow) GetType() string      { return ErasingEdge_Type }
func (n ErasingEdge_Flow) GetLede() string      { return "erasing" }
func (n ErasingEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n ErasingEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ErasingEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ErasingEdge_Optional_Marshal(m jsn.Marshaler, pv **ErasingEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ErasingEdge_Marshal(m, *pv)
	} else if !enc {
		var v ErasingEdge
		if err = ErasingEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ErasingEdge_Marshal(m jsn.Marshaler, val *ErasingEdge) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ErasingEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ErasingEdge_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ErasingEdge_Field_Target))
		}
		e1 := m.MarshalKey("at_front", ErasingEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ErasingEdge_Field_AtEdge))
		}
		e2 := m.MarshalKey("as", ErasingEdge_Field_As)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.As)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ErasingEdge_Field_As))
		}
		e3 := m.MarshalKey("does", ErasingEdge_Field_Does)
		if e3 == nil {
			e3 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ErasingEdge_Field_Does))
		}
		e4 := m.MarshalKey("else", ErasingEdge_Field_Else)
		if e4 == nil {
			e4 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", ErasingEdge_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the 'else' activity if empty.
type ListEach struct {
	List   assign.Assignment `if:"label=across"`
	As     string            `if:"label=as,type=text"`
	Does   []rt.Execute      `if:"label=does"`
	Else   core.Brancher     `if:"label=else,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListEach)(nil)

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: ListEach_Type,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const ListEach_Type = "list_each"
const ListEach_Field_List = "$LIST"
const ListEach_Field_As = "$AS"
const ListEach_Field_Does = "$DOES"
const ListEach_Field_Else = "$ELSE"

func (op *ListEach) Marshal(m jsn.Marshaler) error {
	return ListEach_Marshal(m, op)
}

type ListEach_Slice []ListEach

func (op *ListEach_Slice) GetType() string { return ListEach_Type }

func (op *ListEach_Slice) Marshal(m jsn.Marshaler) error {
	return ListEach_Repeats_Marshal(m, (*[]ListEach)(op))
}

func (op *ListEach_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListEach_Slice) SetSize(cnt int) {
	var els []ListEach
	if cnt >= 0 {
		els = make(ListEach_Slice, cnt)
	}
	(*op) = els
}

func (op *ListEach_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListEach_Marshal(m, &(*op)[i])
}

func ListEach_Repeats_Marshal(m jsn.Marshaler, vals *[]ListEach) error {
	return jsn.RepeatBlock(m, (*ListEach_Slice)(vals))
}

func ListEach_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListEach) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListEach_Repeats_Marshal(m, pv)
	}
	return
}

type ListEach_Flow struct{ ptr *ListEach }

func (n ListEach_Flow) GetType() string      { return ListEach_Type }
func (n ListEach_Flow) GetLede() string      { return "repeating" }
func (n ListEach_Flow) GetFlow() interface{} { return n.ptr }
func (n ListEach_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListEach); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListEach_Optional_Marshal(m jsn.Marshaler, pv **ListEach) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListEach_Marshal(m, *pv)
	} else if !enc {
		var v ListEach
		if err = ListEach_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListEach_Marshal(m jsn.Marshaler, val *ListEach) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListEach_Flow{val}); err == nil {
		e0 := m.MarshalKey("across", ListEach_Field_List)
		if e0 == nil {
			e0 = assign.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListEach_Field_List))
		}
		e1 := m.MarshalKey("as", ListEach_Field_As)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.As)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListEach_Field_As))
		}
		e2 := m.MarshalKey("does", ListEach_Field_Does)
		if e2 == nil {
			e2 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListEach_Field_Does))
		}
		e3 := m.MarshalKey("else", ListEach_Field_Else)
		if e3 == nil {
			e3 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListEach_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value  assign.Assignment `if:"label=_"`
	List   assign.Assignment `if:"label=in_list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.BoolEval = (*ListFind)(nil)
var _ rt.NumberEval = (*ListFind)(nil)

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFind_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFind_Type = "list_find"
const ListFind_Field_Value = "$VALUE"
const ListFind_Field_List = "$LIST"

func (op *ListFind) Marshal(m jsn.Marshaler) error {
	return ListFind_Marshal(m, op)
}

type ListFind_Slice []ListFind

func (op *ListFind_Slice) GetType() string { return ListFind_Type }

func (op *ListFind_Slice) Marshal(m jsn.Marshaler) error {
	return ListFind_Repeats_Marshal(m, (*[]ListFind)(op))
}

func (op *ListFind_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListFind_Slice) SetSize(cnt int) {
	var els []ListFind
	if cnt >= 0 {
		els = make(ListFind_Slice, cnt)
	}
	(*op) = els
}

func (op *ListFind_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListFind_Marshal(m, &(*op)[i])
}

func ListFind_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFind) error {
	return jsn.RepeatBlock(m, (*ListFind_Slice)(vals))
}

func ListFind_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListFind) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListFind_Repeats_Marshal(m, pv)
	}
	return
}

type ListFind_Flow struct{ ptr *ListFind }

func (n ListFind_Flow) GetType() string      { return ListFind_Type }
func (n ListFind_Flow) GetLede() string      { return "find" }
func (n ListFind_Flow) GetFlow() interface{} { return n.ptr }
func (n ListFind_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListFind); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListFind_Optional_Marshal(m jsn.Marshaler, pv **ListFind) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFind_Marshal(m, *pv)
	} else if !enc {
		var v ListFind
		if err = ListFind_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFind_Marshal(m jsn.Marshaler, val *ListFind) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListFind_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListFind_Field_Value)
		if e0 == nil {
			e0 = assign.Assignment_Marshal(m, &val.Value)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFind_Field_Value))
		}
		e1 := m.MarshalKey("in_list", ListFind_Field_List)
		if e1 == nil {
			e1 = assign.Assignment_Marshal(m, &val.List)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFind_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListGather Transform the values from a list.
// The named pattern gets with with two parameters for each value in the list:
// 'in' as each value from the list, and 'out' as the var passed to the gather.
type ListGather struct {
	Target assign.Address    `if:"label=_"`
	From   assign.Assignment `if:"label=from"`
	Using  string            `if:"label=using,type=text"`
	Markup map[string]any
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: ListGather_Type,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const ListGather_Type = "list_gather"
const ListGather_Field_Target = "$TARGET"
const ListGather_Field_From = "$FROM"
const ListGather_Field_Using = "$USING"

func (op *ListGather) Marshal(m jsn.Marshaler) error {
	return ListGather_Marshal(m, op)
}

type ListGather_Slice []ListGather

func (op *ListGather_Slice) GetType() string { return ListGather_Type }

func (op *ListGather_Slice) Marshal(m jsn.Marshaler) error {
	return ListGather_Repeats_Marshal(m, (*[]ListGather)(op))
}

func (op *ListGather_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListGather_Slice) SetSize(cnt int) {
	var els []ListGather
	if cnt >= 0 {
		els = make(ListGather_Slice, cnt)
	}
	(*op) = els
}

func (op *ListGather_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListGather_Marshal(m, &(*op)[i])
}

func ListGather_Repeats_Marshal(m jsn.Marshaler, vals *[]ListGather) error {
	return jsn.RepeatBlock(m, (*ListGather_Slice)(vals))
}

func ListGather_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListGather) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListGather_Repeats_Marshal(m, pv)
	}
	return
}

type ListGather_Flow struct{ ptr *ListGather }

func (n ListGather_Flow) GetType() string      { return ListGather_Type }
func (n ListGather_Flow) GetLede() string      { return "gather" }
func (n ListGather_Flow) GetFlow() interface{} { return n.ptr }
func (n ListGather_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListGather); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListGather_Optional_Marshal(m jsn.Marshaler, pv **ListGather) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListGather_Marshal(m, *pv)
	} else if !enc {
		var v ListGather
		if err = ListGather_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListGather_Marshal(m jsn.Marshaler, val *ListGather) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListGather_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListGather_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListGather_Field_Target))
		}
		e1 := m.MarshalKey("from", ListGather_Field_From)
		if e1 == nil {
			e1 = assign.Assignment_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListGather_Field_From))
		}
		e2 := m.MarshalKey("using", ListGather_Field_Using)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.Using)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListGather_Field_Using))
		}
		m.EndBlock()
	}
	return
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List   assign.Assignment `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumberEval = (*ListLen)(nil)

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: ListLen_Type,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const ListLen_Type = "list_len"
const ListLen_Field_List = "$LIST"

func (op *ListLen) Marshal(m jsn.Marshaler) error {
	return ListLen_Marshal(m, op)
}

type ListLen_Slice []ListLen

func (op *ListLen_Slice) GetType() string { return ListLen_Type }

func (op *ListLen_Slice) Marshal(m jsn.Marshaler) error {
	return ListLen_Repeats_Marshal(m, (*[]ListLen)(op))
}

func (op *ListLen_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListLen_Slice) SetSize(cnt int) {
	var els []ListLen
	if cnt >= 0 {
		els = make(ListLen_Slice, cnt)
	}
	(*op) = els
}

func (op *ListLen_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListLen_Marshal(m, &(*op)[i])
}

func ListLen_Repeats_Marshal(m jsn.Marshaler, vals *[]ListLen) error {
	return jsn.RepeatBlock(m, (*ListLen_Slice)(vals))
}

func ListLen_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListLen) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListLen_Repeats_Marshal(m, pv)
	}
	return
}

type ListLen_Flow struct{ ptr *ListLen }

func (n ListLen_Flow) GetType() string      { return ListLen_Type }
func (n ListLen_Flow) GetLede() string      { return "len" }
func (n ListLen_Flow) GetFlow() interface{} { return n.ptr }
func (n ListLen_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListLen); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListLen_Optional_Marshal(m jsn.Marshaler, pv **ListLen) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListLen_Marshal(m, *pv)
	} else if !enc {
		var v ListLen
		if err = ListLen_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListLen_Marshal(m jsn.Marshaler, val *ListLen) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListLen_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListLen_Field_List)
		if e0 == nil {
			e0 = assign.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListLen_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListMap Transform the values from one list and place the results in another list.
// The designated pattern is called with each value from the 'from list', one value at a time.
type ListMap struct {
	Target      assign.Address    `if:"label=_"`
	List        assign.Assignment `if:"label=from_list"`
	PatternName string            `if:"label=using,type=text"`
	Markup      map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListMap)(nil)

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: ListMap_Type,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const ListMap_Type = "list_map"
const ListMap_Field_Target = "$TARGET"
const ListMap_Field_List = "$LIST"
const ListMap_Field_PatternName = "$PATTERN_NAME"

func (op *ListMap) Marshal(m jsn.Marshaler) error {
	return ListMap_Marshal(m, op)
}

type ListMap_Slice []ListMap

func (op *ListMap_Slice) GetType() string { return ListMap_Type }

func (op *ListMap_Slice) Marshal(m jsn.Marshaler) error {
	return ListMap_Repeats_Marshal(m, (*[]ListMap)(op))
}

func (op *ListMap_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListMap_Slice) SetSize(cnt int) {
	var els []ListMap
	if cnt >= 0 {
		els = make(ListMap_Slice, cnt)
	}
	(*op) = els
}

func (op *ListMap_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListMap_Marshal(m, &(*op)[i])
}

func ListMap_Repeats_Marshal(m jsn.Marshaler, vals *[]ListMap) error {
	return jsn.RepeatBlock(m, (*ListMap_Slice)(vals))
}

func ListMap_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListMap) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListMap_Repeats_Marshal(m, pv)
	}
	return
}

type ListMap_Flow struct{ ptr *ListMap }

func (n ListMap_Flow) GetType() string      { return ListMap_Type }
func (n ListMap_Flow) GetLede() string      { return "map" }
func (n ListMap_Flow) GetFlow() interface{} { return n.ptr }
func (n ListMap_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListMap); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListMap_Optional_Marshal(m jsn.Marshaler, pv **ListMap) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListMap_Marshal(m, *pv)
	} else if !enc {
		var v ListMap
		if err = ListMap_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListMap_Marshal(m jsn.Marshaler, val *ListMap) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListMap_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListMap_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListMap_Field_Target))
		}
		e1 := m.MarshalKey("from_list", ListMap_Field_List)
		if e1 == nil {
			e1 = assign.Assignment_Marshal(m, &val.List)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListMap_Field_List))
		}
		e2 := m.MarshalKey("using", ListMap_Field_PatternName)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.PatternName)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListMap_Field_PatternName))
		}
		m.EndBlock()
	}
	return
}

// ListPush Add a value to a list.
type ListPush struct {
	Value  assign.Assignment `if:"label=_"`
	Target assign.Address    `if:"label=into"`
	AtEdge rt.BoolEval       `if:"label=at_front,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListPush)(nil)

func (*ListPush) Compose() composer.Spec {
	return composer.Spec{
		Name: ListPush_Type,
		Uses: composer.Type_Flow,
		Lede: "push",
	}
}

const ListPush_Type = "list_push"
const ListPush_Field_Value = "$VALUE"
const ListPush_Field_Target = "$TARGET"
const ListPush_Field_AtEdge = "$AT_EDGE"

func (op *ListPush) Marshal(m jsn.Marshaler) error {
	return ListPush_Marshal(m, op)
}

type ListPush_Slice []ListPush

func (op *ListPush_Slice) GetType() string { return ListPush_Type }

func (op *ListPush_Slice) Marshal(m jsn.Marshaler) error {
	return ListPush_Repeats_Marshal(m, (*[]ListPush)(op))
}

func (op *ListPush_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListPush_Slice) SetSize(cnt int) {
	var els []ListPush
	if cnt >= 0 {
		els = make(ListPush_Slice, cnt)
	}
	(*op) = els
}

func (op *ListPush_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListPush_Marshal(m, &(*op)[i])
}

func ListPush_Repeats_Marshal(m jsn.Marshaler, vals *[]ListPush) error {
	return jsn.RepeatBlock(m, (*ListPush_Slice)(vals))
}

func ListPush_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListPush) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListPush_Repeats_Marshal(m, pv)
	}
	return
}

type ListPush_Flow struct{ ptr *ListPush }

func (n ListPush_Flow) GetType() string      { return ListPush_Type }
func (n ListPush_Flow) GetLede() string      { return "push" }
func (n ListPush_Flow) GetFlow() interface{} { return n.ptr }
func (n ListPush_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListPush); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListPush_Optional_Marshal(m jsn.Marshaler, pv **ListPush) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListPush_Marshal(m, *pv)
	} else if !enc {
		var v ListPush
		if err = ListPush_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListPush_Marshal(m jsn.Marshaler, val *ListPush) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListPush_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListPush_Field_Value)
		if e0 == nil {
			e0 = assign.Assignment_Marshal(m, &val.Value)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListPush_Field_Value))
		}
		e1 := m.MarshalKey("into", ListPush_Field_Target)
		if e1 == nil {
			e1 = assign.Address_Marshal(m, &val.Target)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListPush_Field_Target))
		}
		e2 := m.MarshalKey("at_front", ListPush_Field_AtEdge)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListPush_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// ListReduce Combine all of the values in a list into the targeted value.
// The designated pattern is called with two parameters:
// 'in' ( each element of the list ) and 'out' ( ex. a record ).
type ListReduce struct {
	Target      assign.Address    `if:"label=into"`
	List        assign.Assignment `if:"label=from_list"`
	PatternName string            `if:"label=using,type=text"`
	Markup      map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListReduce)(nil)

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReduce_Type,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const ListReduce_Type = "list_reduce"
const ListReduce_Field_Target = "$TARGET"
const ListReduce_Field_List = "$LIST"
const ListReduce_Field_PatternName = "$PATTERN_NAME"

func (op *ListReduce) Marshal(m jsn.Marshaler) error {
	return ListReduce_Marshal(m, op)
}

type ListReduce_Slice []ListReduce

func (op *ListReduce_Slice) GetType() string { return ListReduce_Type }

func (op *ListReduce_Slice) Marshal(m jsn.Marshaler) error {
	return ListReduce_Repeats_Marshal(m, (*[]ListReduce)(op))
}

func (op *ListReduce_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListReduce_Slice) SetSize(cnt int) {
	var els []ListReduce
	if cnt >= 0 {
		els = make(ListReduce_Slice, cnt)
	}
	(*op) = els
}

func (op *ListReduce_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListReduce_Marshal(m, &(*op)[i])
}

func ListReduce_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReduce) error {
	return jsn.RepeatBlock(m, (*ListReduce_Slice)(vals))
}

func ListReduce_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListReduce) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListReduce_Repeats_Marshal(m, pv)
	}
	return
}

type ListReduce_Flow struct{ ptr *ListReduce }

func (n ListReduce_Flow) GetType() string      { return ListReduce_Type }
func (n ListReduce_Flow) GetLede() string      { return "reduce" }
func (n ListReduce_Flow) GetFlow() interface{} { return n.ptr }
func (n ListReduce_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListReduce); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListReduce_Optional_Marshal(m jsn.Marshaler, pv **ListReduce) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReduce_Marshal(m, *pv)
	} else if !enc {
		var v ListReduce
		if err = ListReduce_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReduce_Marshal(m jsn.Marshaler, val *ListReduce) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListReduce_Flow{val}); err == nil {
		e0 := m.MarshalKey("into", ListReduce_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReduce_Field_Target))
		}
		e1 := m.MarshalKey("from_list", ListReduce_Field_List)
		if e1 == nil {
			e1 = assign.Assignment_Marshal(m, &val.List)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListReduce_Field_List))
		}
		e2 := m.MarshalKey("using", ListReduce_Field_PatternName)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.PatternName)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListReduce_Field_PatternName))
		}
		m.EndBlock()
	}
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	Target assign.Address `if:"label=list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListReverse)(nil)

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReverse_Type,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const ListReverse_Type = "list_reverse"
const ListReverse_Field_Target = "$TARGET"

func (op *ListReverse) Marshal(m jsn.Marshaler) error {
	return ListReverse_Marshal(m, op)
}

type ListReverse_Slice []ListReverse

func (op *ListReverse_Slice) GetType() string { return ListReverse_Type }

func (op *ListReverse_Slice) Marshal(m jsn.Marshaler) error {
	return ListReverse_Repeats_Marshal(m, (*[]ListReverse)(op))
}

func (op *ListReverse_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListReverse_Slice) SetSize(cnt int) {
	var els []ListReverse
	if cnt >= 0 {
		els = make(ListReverse_Slice, cnt)
	}
	(*op) = els
}

func (op *ListReverse_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListReverse_Marshal(m, &(*op)[i])
}

func ListReverse_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReverse) error {
	return jsn.RepeatBlock(m, (*ListReverse_Slice)(vals))
}

func ListReverse_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListReverse) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListReverse_Repeats_Marshal(m, pv)
	}
	return
}

type ListReverse_Flow struct{ ptr *ListReverse }

func (n ListReverse_Flow) GetType() string      { return ListReverse_Type }
func (n ListReverse_Flow) GetLede() string      { return "reverse" }
func (n ListReverse_Flow) GetFlow() interface{} { return n.ptr }
func (n ListReverse_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListReverse); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListReverse_Optional_Marshal(m jsn.Marshaler, pv **ListReverse) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReverse_Marshal(m, *pv)
	} else if !enc {
		var v ListReverse
		if err = ListReverse_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReverse_Marshal(m jsn.Marshaler, val *ListReverse) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListReverse_Flow{val}); err == nil {
		e0 := m.MarshalKey("list", ListReverse_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReverse_Field_Target))
		}
		m.EndBlock()
	}
	return
}

// ListSlice Create a new list from a section of another list.
// Start is optional, if omitted slice starts at the first element.
// If start is greater the length, an empty array is returned.
// Slice doesnt include the ending index.
// Negatives indices indicates an offset from the end.
// When end is omitted, copy up to and including the last element;
// and do the same if the end is greater than the length
type ListSlice struct {
	List   assign.Assignment `if:"label=_"`
	Start  rt.NumberEval     `if:"label=start,optional"`
	End    rt.NumberEval     `if:"label=end,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumListEval = (*ListSlice)(nil)
var _ rt.TextListEval = (*ListSlice)(nil)
var _ rt.RecordListEval = (*ListSlice)(nil)

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSlice_Type,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const ListSlice_Type = "list_slice"
const ListSlice_Field_List = "$LIST"
const ListSlice_Field_Start = "$START"
const ListSlice_Field_End = "$END"

func (op *ListSlice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Marshal(m, op)
}

type ListSlice_Slice []ListSlice

func (op *ListSlice_Slice) GetType() string { return ListSlice_Type }

func (op *ListSlice_Slice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Repeats_Marshal(m, (*[]ListSlice)(op))
}

func (op *ListSlice_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSlice_Slice) SetSize(cnt int) {
	var els []ListSlice
	if cnt >= 0 {
		els = make(ListSlice_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSlice_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSlice_Marshal(m, &(*op)[i])
}

func ListSlice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSlice) error {
	return jsn.RepeatBlock(m, (*ListSlice_Slice)(vals))
}

func ListSlice_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSlice) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSlice_Repeats_Marshal(m, pv)
	}
	return
}

type ListSlice_Flow struct{ ptr *ListSlice }

func (n ListSlice_Flow) GetType() string      { return ListSlice_Type }
func (n ListSlice_Flow) GetLede() string      { return "slice" }
func (n ListSlice_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSlice_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSlice); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSlice_Optional_Marshal(m jsn.Marshaler, pv **ListSlice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSlice_Marshal(m, *pv)
	} else if !enc {
		var v ListSlice
		if err = ListSlice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSlice_Marshal(m jsn.Marshaler, val *ListSlice) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSlice_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSlice_Field_List)
		if e0 == nil {
			e0 = assign.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSlice_Field_List))
		}
		e1 := m.MarshalKey("start", ListSlice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSlice_Field_Start))
		}
		e2 := m.MarshalKey("end", ListSlice_Field_End)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.End)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSlice_Field_End))
		}
		m.EndBlock()
	}
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Target     assign.Address `if:"label=_"`
	ByField    string         `if:"label=by_field,type=text"`
	Descending rt.BoolEval    `if:"label=descending,optional"`
	Markup     map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSortNumbers)(nil)

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortNumbers_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_numbers",
	}
}

const ListSortNumbers_Type = "list_sort_numbers"
const ListSortNumbers_Field_Target = "$TARGET"
const ListSortNumbers_Field_ByField = "$BY_FIELD"
const ListSortNumbers_Field_Descending = "$DESCENDING"

func (op *ListSortNumbers) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Marshal(m, op)
}

type ListSortNumbers_Slice []ListSortNumbers

func (op *ListSortNumbers_Slice) GetType() string { return ListSortNumbers_Type }

func (op *ListSortNumbers_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Repeats_Marshal(m, (*[]ListSortNumbers)(op))
}

func (op *ListSortNumbers_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortNumbers_Slice) SetSize(cnt int) {
	var els []ListSortNumbers
	if cnt >= 0 {
		els = make(ListSortNumbers_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortNumbers_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortNumbers_Marshal(m, &(*op)[i])
}

func ListSortNumbers_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortNumbers) error {
	return jsn.RepeatBlock(m, (*ListSortNumbers_Slice)(vals))
}

func ListSortNumbers_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortNumbers) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSortNumbers_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortNumbers_Flow struct{ ptr *ListSortNumbers }

func (n ListSortNumbers_Flow) GetType() string      { return ListSortNumbers_Type }
func (n ListSortNumbers_Flow) GetLede() string      { return "sort_numbers" }
func (n ListSortNumbers_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortNumbers_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortNumbers); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortNumbers_Optional_Marshal(m jsn.Marshaler, pv **ListSortNumbers) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortNumbers_Marshal(m, *pv)
	} else if !enc {
		var v ListSortNumbers
		if err = ListSortNumbers_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortNumbers_Marshal(m jsn.Marshaler, val *ListSortNumbers) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSortNumbers_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortNumbers_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortNumbers_Field_Target))
		}
		e1 := m.MarshalKey("by_field", ListSortNumbers_Field_ByField)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortNumbers_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortNumbers_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortNumbers_Field_Descending))
		}
		m.EndBlock()
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Target     assign.Address `if:"label=_"`
	ByField    string         `if:"label=by_field,type=text"`
	Descending rt.BoolEval    `if:"label=descending,optional"`
	UsingCase  rt.BoolEval    `if:"label=using_case,optional"`
	Markup     map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSortText)(nil)

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortText_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_texts",
	}
}

const ListSortText_Type = "list_sort_text"
const ListSortText_Field_Target = "$TARGET"
const ListSortText_Field_ByField = "$BY_FIELD"
const ListSortText_Field_Descending = "$DESCENDING"
const ListSortText_Field_UsingCase = "$USING_CASE"

func (op *ListSortText) Marshal(m jsn.Marshaler) error {
	return ListSortText_Marshal(m, op)
}

type ListSortText_Slice []ListSortText

func (op *ListSortText_Slice) GetType() string { return ListSortText_Type }

func (op *ListSortText_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortText_Repeats_Marshal(m, (*[]ListSortText)(op))
}

func (op *ListSortText_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortText_Slice) SetSize(cnt int) {
	var els []ListSortText
	if cnt >= 0 {
		els = make(ListSortText_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortText_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortText_Marshal(m, &(*op)[i])
}

func ListSortText_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortText) error {
	return jsn.RepeatBlock(m, (*ListSortText_Slice)(vals))
}

func ListSortText_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortText) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSortText_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortText_Flow struct{ ptr *ListSortText }

func (n ListSortText_Flow) GetType() string      { return ListSortText_Type }
func (n ListSortText_Flow) GetLede() string      { return "sort_texts" }
func (n ListSortText_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortText_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortText); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortText_Optional_Marshal(m jsn.Marshaler, pv **ListSortText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortText_Marshal(m, *pv)
	} else if !enc {
		var v ListSortText
		if err = ListSortText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortText_Marshal(m jsn.Marshaler, val *ListSortText) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSortText_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortText_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortText_Field_Target))
		}
		e1 := m.MarshalKey("by_field", ListSortText_Field_ByField)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortText_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortText_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortText_Field_Descending))
		}
		e3 := m.MarshalKey("using_case", ListSortText_Field_UsingCase)
		if e3 == nil {
			e3 = rt.BoolEval_Optional_Marshal(m, &val.UsingCase)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSortText_Field_UsingCase))
		}
		m.EndBlock()
	}
	return
}

// ListSplice Modify a list by adding and removing elements.
// The type of the elements being added must match the type of the list.
// Text cant be added to a list of numbers, numbers cant be added to a list of text.
// If the starting index is negative, this begins that many elements from the end of the array;
// if list's length plus the start is less than zero, this begins from index zero.
// If the remove count is missing, this removes all elements from the start to the end;
// if the remove count is zero or negative, no elements are removed.
type ListSplice struct {
	Target assign.Address    `if:"label=_"`
	Start  rt.NumberEval     `if:"label=start"`
	Remove rt.NumberEval     `if:"label=remove"`
	Insert assign.Assignment `if:"label=insert"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSplice)(nil)
var _ rt.NumListEval = (*ListSplice)(nil)
var _ rt.TextListEval = (*ListSplice)(nil)
var _ rt.RecordListEval = (*ListSplice)(nil)

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSplice_Type,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const ListSplice_Type = "list_splice"
const ListSplice_Field_Target = "$TARGET"
const ListSplice_Field_Start = "$START"
const ListSplice_Field_Remove = "$REMOVE"
const ListSplice_Field_Insert = "$INSERT"

func (op *ListSplice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Marshal(m, op)
}

type ListSplice_Slice []ListSplice

func (op *ListSplice_Slice) GetType() string { return ListSplice_Type }

func (op *ListSplice_Slice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Repeats_Marshal(m, (*[]ListSplice)(op))
}

func (op *ListSplice_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSplice_Slice) SetSize(cnt int) {
	var els []ListSplice
	if cnt >= 0 {
		els = make(ListSplice_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSplice_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSplice_Marshal(m, &(*op)[i])
}

func ListSplice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSplice) error {
	return jsn.RepeatBlock(m, (*ListSplice_Slice)(vals))
}

func ListSplice_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSplice) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSplice_Repeats_Marshal(m, pv)
	}
	return
}

type ListSplice_Flow struct{ ptr *ListSplice }

func (n ListSplice_Flow) GetType() string      { return ListSplice_Type }
func (n ListSplice_Flow) GetLede() string      { return "splice" }
func (n ListSplice_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSplice_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSplice); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSplice_Optional_Marshal(m jsn.Marshaler, pv **ListSplice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSplice_Marshal(m, *pv)
	} else if !enc {
		var v ListSplice
		if err = ListSplice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSplice_Marshal(m jsn.Marshaler, val *ListSplice) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSplice_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSplice_Field_Target)
		if e0 == nil {
			e0 = assign.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSplice_Field_Target))
		}
		e1 := m.MarshalKey("start", ListSplice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSplice_Field_Start))
		}
		e2 := m.MarshalKey("remove", ListSplice_Field_Remove)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.Remove)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSplice_Field_Remove))
		}
		e3 := m.MarshalKey("insert", ListSplice_Field_Insert)
		if e3 == nil {
			e3 = assign.Assignment_Marshal(m, &val.Insert)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSplice_Field_Insert))
		}
		m.EndBlock()
	}
	return
}

// MakeNumList
type MakeNumList struct {
	Values []rt.NumberEval `if:"label=of_numbers"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumListEval = (*MakeNumList)(nil)

func (*MakeNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: MakeNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "list",
	}
}

const MakeNumList_Type = "make_num_list"
const MakeNumList_Field_Values = "$VALUES"

func (op *MakeNumList) Marshal(m jsn.Marshaler) error {
	return MakeNumList_Marshal(m, op)
}

type MakeNumList_Slice []MakeNumList

func (op *MakeNumList_Slice) GetType() string { return MakeNumList_Type }

func (op *MakeNumList_Slice) Marshal(m jsn.Marshaler) error {
	return MakeNumList_Repeats_Marshal(m, (*[]MakeNumList)(op))
}

func (op *MakeNumList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MakeNumList_Slice) SetSize(cnt int) {
	var els []MakeNumList
	if cnt >= 0 {
		els = make(MakeNumList_Slice, cnt)
	}
	(*op) = els
}

func (op *MakeNumList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MakeNumList_Marshal(m, &(*op)[i])
}

func MakeNumList_Repeats_Marshal(m jsn.Marshaler, vals *[]MakeNumList) error {
	return jsn.RepeatBlock(m, (*MakeNumList_Slice)(vals))
}

func MakeNumList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MakeNumList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MakeNumList_Repeats_Marshal(m, pv)
	}
	return
}

type MakeNumList_Flow struct{ ptr *MakeNumList }

func (n MakeNumList_Flow) GetType() string      { return MakeNumList_Type }
func (n MakeNumList_Flow) GetLede() string      { return "list" }
func (n MakeNumList_Flow) GetFlow() interface{} { return n.ptr }
func (n MakeNumList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*MakeNumList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func MakeNumList_Optional_Marshal(m jsn.Marshaler, pv **MakeNumList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = MakeNumList_Marshal(m, *pv)
	} else if !enc {
		var v MakeNumList
		if err = MakeNumList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func MakeNumList_Marshal(m jsn.Marshaler, val *MakeNumList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(MakeNumList_Flow{val}); err == nil {
		e0 := m.MarshalKey("of_numbers", MakeNumList_Field_Values)
		if e0 == nil {
			e0 = rt.NumberEval_Repeats_Marshal(m, &val.Values)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", MakeNumList_Field_Values))
		}
		m.EndBlock()
	}
	return
}

// MakeRecordList
type MakeRecordList struct {
	Values []rt.RecordEval `if:"label=of_records"`
	Kind   rt.TextEval     `if:"label=of_type"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.RecordListEval = (*MakeRecordList)(nil)

func (*MakeRecordList) Compose() composer.Spec {
	return composer.Spec{
		Name: MakeRecordList_Type,
		Uses: composer.Type_Flow,
		Lede: "list",
	}
}

const MakeRecordList_Type = "make_record_list"
const MakeRecordList_Field_Values = "$VALUES"
const MakeRecordList_Field_Kind = "$KIND"

func (op *MakeRecordList) Marshal(m jsn.Marshaler) error {
	return MakeRecordList_Marshal(m, op)
}

type MakeRecordList_Slice []MakeRecordList

func (op *MakeRecordList_Slice) GetType() string { return MakeRecordList_Type }

func (op *MakeRecordList_Slice) Marshal(m jsn.Marshaler) error {
	return MakeRecordList_Repeats_Marshal(m, (*[]MakeRecordList)(op))
}

func (op *MakeRecordList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MakeRecordList_Slice) SetSize(cnt int) {
	var els []MakeRecordList
	if cnt >= 0 {
		els = make(MakeRecordList_Slice, cnt)
	}
	(*op) = els
}

func (op *MakeRecordList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MakeRecordList_Marshal(m, &(*op)[i])
}

func MakeRecordList_Repeats_Marshal(m jsn.Marshaler, vals *[]MakeRecordList) error {
	return jsn.RepeatBlock(m, (*MakeRecordList_Slice)(vals))
}

func MakeRecordList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MakeRecordList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MakeRecordList_Repeats_Marshal(m, pv)
	}
	return
}

type MakeRecordList_Flow struct{ ptr *MakeRecordList }

func (n MakeRecordList_Flow) GetType() string      { return MakeRecordList_Type }
func (n MakeRecordList_Flow) GetLede() string      { return "list" }
func (n MakeRecordList_Flow) GetFlow() interface{} { return n.ptr }
func (n MakeRecordList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*MakeRecordList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func MakeRecordList_Optional_Marshal(m jsn.Marshaler, pv **MakeRecordList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = MakeRecordList_Marshal(m, *pv)
	} else if !enc {
		var v MakeRecordList
		if err = MakeRecordList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func MakeRecordList_Marshal(m jsn.Marshaler, val *MakeRecordList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(MakeRecordList_Flow{val}); err == nil {
		e0 := m.MarshalKey("of_records", MakeRecordList_Field_Values)
		if e0 == nil {
			e0 = rt.RecordEval_Repeats_Marshal(m, &val.Values)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", MakeRecordList_Field_Values))
		}
		e1 := m.MarshalKey("of_type", MakeRecordList_Field_Kind)
		if e1 == nil {
			e1 = rt.TextEval_Marshal(m, &val.Kind)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", MakeRecordList_Field_Kind))
		}
		m.EndBlock()
	}
	return
}

// MakeTextList
type MakeTextList struct {
	Values []rt.TextEval `if:"label=of_text"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.TextListEval = (*MakeTextList)(nil)

func (*MakeTextList) Compose() composer.Spec {
	return composer.Spec{
		Name: MakeTextList_Type,
		Uses: composer.Type_Flow,
		Lede: "list",
	}
}

const MakeTextList_Type = "make_text_list"
const MakeTextList_Field_Values = "$VALUES"

func (op *MakeTextList) Marshal(m jsn.Marshaler) error {
	return MakeTextList_Marshal(m, op)
}

type MakeTextList_Slice []MakeTextList

func (op *MakeTextList_Slice) GetType() string { return MakeTextList_Type }

func (op *MakeTextList_Slice) Marshal(m jsn.Marshaler) error {
	return MakeTextList_Repeats_Marshal(m, (*[]MakeTextList)(op))
}

func (op *MakeTextList_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *MakeTextList_Slice) SetSize(cnt int) {
	var els []MakeTextList
	if cnt >= 0 {
		els = make(MakeTextList_Slice, cnt)
	}
	(*op) = els
}

func (op *MakeTextList_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return MakeTextList_Marshal(m, &(*op)[i])
}

func MakeTextList_Repeats_Marshal(m jsn.Marshaler, vals *[]MakeTextList) error {
	return jsn.RepeatBlock(m, (*MakeTextList_Slice)(vals))
}

func MakeTextList_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]MakeTextList) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = MakeTextList_Repeats_Marshal(m, pv)
	}
	return
}

type MakeTextList_Flow struct{ ptr *MakeTextList }

func (n MakeTextList_Flow) GetType() string      { return MakeTextList_Type }
func (n MakeTextList_Flow) GetLede() string      { return "list" }
func (n MakeTextList_Flow) GetFlow() interface{} { return n.ptr }
func (n MakeTextList_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*MakeTextList); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func MakeTextList_Optional_Marshal(m jsn.Marshaler, pv **MakeTextList) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = MakeTextList_Marshal(m, *pv)
	} else if !enc {
		var v MakeTextList
		if err = MakeTextList_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func MakeTextList_Marshal(m jsn.Marshaler, val *MakeTextList) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(MakeTextList_Flow{val}); err == nil {
		e0 := m.MarshalKey("of_text", MakeTextList_Field_Values)
		if e0 == nil {
			e0 = rt.TextEval_Repeats_Marshal(m, &val.Values)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", MakeTextList_Field_Values))
		}
		m.EndBlock()
	}
	return
}

// Range Generates a series of numbers r[i] = (start + step*i) where i>=0.
// Start and step default to 1, stop defaults to start;
// the inputs are truncated to produce whole numbers;
// a zero step returns an error.
// A positive step ends the series when the returned value would exceed stop
// while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumListEval = (*Range)(nil)

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Range_Type,
		Uses: composer.Type_Flow,
	}
}

const Range_Type = "range"
const Range_Field_To = "$TO"
const Range_Field_From = "$FROM"
const Range_Field_ByStep = "$BY_STEP"

func (op *Range) Marshal(m jsn.Marshaler) error {
	return Range_Marshal(m, op)
}

type Range_Slice []Range

func (op *Range_Slice) GetType() string { return Range_Type }

func (op *Range_Slice) Marshal(m jsn.Marshaler) error {
	return Range_Repeats_Marshal(m, (*[]Range)(op))
}

func (op *Range_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Range_Slice) SetSize(cnt int) {
	var els []Range
	if cnt >= 0 {
		els = make(Range_Slice, cnt)
	}
	(*op) = els
}

func (op *Range_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Range_Marshal(m, &(*op)[i])
}

func Range_Repeats_Marshal(m jsn.Marshaler, vals *[]Range) error {
	return jsn.RepeatBlock(m, (*Range_Slice)(vals))
}

func Range_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Range) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Range_Repeats_Marshal(m, pv)
	}
	return
}

type Range_Flow struct{ ptr *Range }

func (n Range_Flow) GetType() string      { return Range_Type }
func (n Range_Flow) GetLede() string      { return Range_Type }
func (n Range_Flow) GetFlow() interface{} { return n.ptr }
func (n Range_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Range); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Range_Optional_Marshal(m jsn.Marshaler, pv **Range) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Range_Marshal(m, *pv)
	} else if !enc {
		var v Range
		if err = Range_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Range_Marshal(m jsn.Marshaler, val *Range) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Range_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Range_Field_To)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.To)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Range_Field_To))
		}
		e1 := m.MarshalKey("from", Range_Field_From)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Range_Field_From))
		}
		e2 := m.MarshalKey("by_step", Range_Field_ByStep)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.ByStep)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Range_Field_ByStep))
		}
		m.EndBlock()
	}
	return
}

var Slats = []composer.Composer{
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListPush)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSplice)(nil),
	(*MakeNumList)(nil),
	(*MakeRecordList)(nil),
	(*MakeTextList)(nil),
	(*Range)(nil),
}

var Signatures = map[uint64]interface{}{
	6334415563934548256:  (*ListGather)(nil),      /* Gather:from:using: */
	17857642077015906043: (*EraseEdge)(nil),       /* execute=Erase: */
	4911242881414594201:  (*EraseEdge)(nil),       /* execute=Erase:atFront: */
	13326390992756169124: (*EraseIndex)(nil),      /* execute=Erase:from:atIndex: */
	16587893764566352449: (*ErasingEdge)(nil),     /* execute=Erasing:as:does: */
	1771685988622306554:  (*ErasingEdge)(nil),     /* execute=Erasing:as:does:else: */
	12709950044197813063: (*ErasingEdge)(nil),     /* execute=Erasing:atFront:as:does: */
	307909849155983812:   (*ErasingEdge)(nil),     /* execute=Erasing:atFront:as:does:else: */
	1558163885147286548:  (*Erasing)(nil),         /* execute=Erasing:from:atIndex:as:does: */
	8547752949201735569:  (*ListFind)(nil),        /* bool_eval=Find:inList: */
	16815906459082105780: (*ListFind)(nil),        /* number_eval=Find:inList: */
	3478260273963207965:  (*ListLen)(nil),         /* number_eval=Len: */
	11141869806069158915: (*MakeNumList)(nil),     /* num_list_eval=List ofNumbers: */
	10609280349940760977: (*MakeRecordList)(nil),  /* record_list_eval=List ofRecords:ofType: */
	15650595833095485421: (*MakeTextList)(nil),    /* text_list_eval=List ofText: */
	8449127989109999373:  (*ListMap)(nil),         /* execute=Map:fromList:using: */
	14590825769568398889: (*ListPush)(nil),        /* execute=Push:into: */
	17497959320325918107: (*ListPush)(nil),        /* execute=Push:into:atFront: */
	120416590109430143:   (*Range)(nil),           /* num_list_eval=Range: */
	15503705420922978310: (*Range)(nil),           /* num_list_eval=Range:byStep: */
	16618866959380663563: (*Range)(nil),           /* num_list_eval=Range:from: */
	14227857065891717050: (*Range)(nil),           /* num_list_eval=Range:from:byStep: */
	18245549119758376391: (*ListReduce)(nil),      /* execute=Reduce into:fromList:using: */
	8451005089688158034:  (*ListEach)(nil),        /* execute=Repeating across:as:does: */
	7170937308629588871:  (*ListEach)(nil),        /* execute=Repeating across:as:does:else: */
	177314099445105829:   (*ListReverse)(nil),     /* execute=Reverse list: */
	4235921801420235638:  (*ListSlice)(nil),       /* num_list_eval=Slice: */
	13273073049578089927: (*ListSlice)(nil),       /* record_list_eval=Slice: */
	18323981472330239313: (*ListSlice)(nil),       /* text_list_eval=Slice: */
	3713929053224137387:  (*ListSlice)(nil),       /* num_list_eval=Slice:end: */
	326673439235441194:   (*ListSlice)(nil),       /* record_list_eval=Slice:end: */
	8469880138850798532:  (*ListSlice)(nil),       /* text_list_eval=Slice:end: */
	6763121597476813124:  (*ListSlice)(nil),       /* num_list_eval=Slice:start: */
	10126987075066562677: (*ListSlice)(nil),       /* record_list_eval=Slice:start: */
	2045310658543284955:  (*ListSlice)(nil),       /* text_list_eval=Slice:start: */
	14495675636779114361: (*ListSlice)(nil),       /* num_list_eval=Slice:start:end: */
	3241896595896148736:  (*ListSlice)(nil),       /* record_list_eval=Slice:start:end: */
	8901512565003460886:  (*ListSlice)(nil),       /* text_list_eval=Slice:start:end: */
	2873147130324862012:  (*ListSortNumbers)(nil), /* execute=SortNumbers:byField: */
	16697045456605499852: (*ListSortNumbers)(nil), /* execute=SortNumbers:byField:descending: */
	16004888373963195994: (*ListSortText)(nil),    /* execute=SortTexts:byField: */
	10015011362106184366: (*ListSortText)(nil),    /* execute=SortTexts:byField:descending: */
	10595238214248400404: (*ListSortText)(nil),    /* execute=SortTexts:byField:descending:usingCase: */
	10680774202307610784: (*ListSortText)(nil),    /* execute=SortTexts:byField:usingCase: */
	13203130291219794646: (*ListSplice)(nil),      /* execute=Splice:start:remove:insert: */
	6201472222981604265:  (*ListSplice)(nil),      /* num_list_eval=Splice:start:remove:insert: */
	15778591428898251294: (*ListSplice)(nil),      /* record_list_eval=Splice:start:remove:insert: */
	11160578659475180120: (*ListSplice)(nil),      /* text_list_eval=Splice:start:remove:insert: */
}
