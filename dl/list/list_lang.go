// Code generated by "makeops"; edit at your own risk.
package list

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: AsNum_Type,
		Uses: composer.Type_Flow,
		Lede: "num",
	}
}

const AsNum_Type = "as_num"
const AsNum_Lede = "num"
const AsNum_Field_Var = "$VAR"

func (op *AsNum) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return AsNum_Compact_Marshal(n, op)
}
func (op *AsNum) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return AsNum_Compact_Unmarshal(n, b, op)
}
func (op *AsNum) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AsNum_Detailed_Marshal(n, op)
}
func (op *AsNum) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AsNum_Detailed_Unmarshal(n, b, op)
}

func AsNum_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]AsNum) ([]byte, error) {
	return AsNum_Repeats_Marshal(n, vals, AsNum_Compact_Marshal)
}
func AsNum_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]AsNum) ([]byte, error) {
	return AsNum_Repeats_Marshal(n, vals, AsNum_Detailed_Marshal)
}
func AsNum_Repeats_Marshal(n jsonexp.Context, vals *[]AsNum, marshEl func(jsonexp.Context, *AsNum) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(AsNum_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func AsNum_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsNum) error {
	return AsNum_Repeats_Unmarshal(n, b, out, AsNum_Compact_Unmarshal)
}
func AsNum_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsNum) error {
	return AsNum_Repeats_Unmarshal(n, b, out, AsNum_Detailed_Unmarshal)
}
func AsNum_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsNum, unmarshEl func(jsonexp.Context, []byte, *AsNum) error) (err error) {
	var vals []AsNum
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(AsNum_Type, "-", e)
		} else {
			vals = make([]AsNum, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(AsNum_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func AsNum_Compact_Optional_Marshal(n jsonexp.Context, val **AsNum) (ret []byte, err error) {
	if *val != nil {
		ret, err = AsNum_Compact_Marshal(n, *val)
	}
	return
}
func AsNum_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AsNum) (err error) {
	if len(b) > 0 {
		var val AsNum
		if e := AsNum_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func AsNum_Compact_Marshal(n jsonexp.Context, val *AsNum) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(AsNum_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func AsNum_Compact_Unmarshal(n jsonexp.Context, b []byte, out *AsNum) (err error) {
	return
}

func AsNum_Detailed_Optional_Marshal(n jsonexp.Context, val **AsNum) (ret []byte, err error) {
	if *val != nil {
		ret, err = AsNum_Detailed_Marshal(n, *val)
	}
	return
}
func AsNum_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AsNum) (err error) {
	if len(b) > 0 {
		var val AsNum
		if e := AsNum_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func AsNum_Detailed_Marshal(n jsonexp.Context, val *AsNum) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[AsNum_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   AsNum_Type,
			Fields: fields,
		})
	}
	return
}

func AsNum_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AsNum) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(AsNum_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[AsNum_Field_Var], &out.Var); e != nil {
		err = errutil.New(AsNum_Type+"."+AsNum_Field_Var, "-", e)
	}
	return
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: AsRec_Type,
		Uses: composer.Type_Flow,
		Lede: "rec",
	}
}

const AsRec_Type = "as_rec"
const AsRec_Lede = "rec"
const AsRec_Field_Var = "$VAR"

func (op *AsRec) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return AsRec_Compact_Marshal(n, op)
}
func (op *AsRec) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return AsRec_Compact_Unmarshal(n, b, op)
}
func (op *AsRec) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AsRec_Detailed_Marshal(n, op)
}
func (op *AsRec) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AsRec_Detailed_Unmarshal(n, b, op)
}

func AsRec_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]AsRec) ([]byte, error) {
	return AsRec_Repeats_Marshal(n, vals, AsRec_Compact_Marshal)
}
func AsRec_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]AsRec) ([]byte, error) {
	return AsRec_Repeats_Marshal(n, vals, AsRec_Detailed_Marshal)
}
func AsRec_Repeats_Marshal(n jsonexp.Context, vals *[]AsRec, marshEl func(jsonexp.Context, *AsRec) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(AsRec_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func AsRec_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsRec) error {
	return AsRec_Repeats_Unmarshal(n, b, out, AsRec_Compact_Unmarshal)
}
func AsRec_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsRec) error {
	return AsRec_Repeats_Unmarshal(n, b, out, AsRec_Detailed_Unmarshal)
}
func AsRec_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsRec, unmarshEl func(jsonexp.Context, []byte, *AsRec) error) (err error) {
	var vals []AsRec
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(AsRec_Type, "-", e)
		} else {
			vals = make([]AsRec, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(AsRec_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func AsRec_Compact_Optional_Marshal(n jsonexp.Context, val **AsRec) (ret []byte, err error) {
	if *val != nil {
		ret, err = AsRec_Compact_Marshal(n, *val)
	}
	return
}
func AsRec_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AsRec) (err error) {
	if len(b) > 0 {
		var val AsRec
		if e := AsRec_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func AsRec_Compact_Marshal(n jsonexp.Context, val *AsRec) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(AsRec_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func AsRec_Compact_Unmarshal(n jsonexp.Context, b []byte, out *AsRec) (err error) {
	return
}

func AsRec_Detailed_Optional_Marshal(n jsonexp.Context, val **AsRec) (ret []byte, err error) {
	if *val != nil {
		ret, err = AsRec_Detailed_Marshal(n, *val)
	}
	return
}
func AsRec_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AsRec) (err error) {
	if len(b) > 0 {
		var val AsRec
		if e := AsRec_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func AsRec_Detailed_Marshal(n jsonexp.Context, val *AsRec) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[AsRec_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   AsRec_Type,
			Fields: fields,
		})
	}
	return
}

func AsRec_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AsRec) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(AsRec_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[AsRec_Field_Var], &out.Var); e != nil {
		err = errutil.New(AsRec_Type+"."+AsRec_Field_Var, "-", e)
	}
	return
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: AsTxt_Type,
		Uses: composer.Type_Flow,
		Lede: "txt",
	}
}

const AsTxt_Type = "as_txt"
const AsTxt_Lede = "txt"
const AsTxt_Field_Var = "$VAR"

func (op *AsTxt) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return AsTxt_Compact_Marshal(n, op)
}
func (op *AsTxt) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return AsTxt_Compact_Unmarshal(n, b, op)
}
func (op *AsTxt) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AsTxt_Detailed_Marshal(n, op)
}
func (op *AsTxt) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AsTxt_Detailed_Unmarshal(n, b, op)
}

func AsTxt_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]AsTxt) ([]byte, error) {
	return AsTxt_Repeats_Marshal(n, vals, AsTxt_Compact_Marshal)
}
func AsTxt_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]AsTxt) ([]byte, error) {
	return AsTxt_Repeats_Marshal(n, vals, AsTxt_Detailed_Marshal)
}
func AsTxt_Repeats_Marshal(n jsonexp.Context, vals *[]AsTxt, marshEl func(jsonexp.Context, *AsTxt) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(AsTxt_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func AsTxt_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsTxt) error {
	return AsTxt_Repeats_Unmarshal(n, b, out, AsTxt_Compact_Unmarshal)
}
func AsTxt_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsTxt) error {
	return AsTxt_Repeats_Unmarshal(n, b, out, AsTxt_Detailed_Unmarshal)
}
func AsTxt_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]AsTxt, unmarshEl func(jsonexp.Context, []byte, *AsTxt) error) (err error) {
	var vals []AsTxt
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(AsTxt_Type, "-", e)
		} else {
			vals = make([]AsTxt, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(AsTxt_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func AsTxt_Compact_Optional_Marshal(n jsonexp.Context, val **AsTxt) (ret []byte, err error) {
	if *val != nil {
		ret, err = AsTxt_Compact_Marshal(n, *val)
	}
	return
}
func AsTxt_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AsTxt) (err error) {
	if len(b) > 0 {
		var val AsTxt
		if e := AsTxt_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func AsTxt_Compact_Marshal(n jsonexp.Context, val *AsTxt) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(AsTxt_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func AsTxt_Compact_Unmarshal(n jsonexp.Context, b []byte, out *AsTxt) (err error) {
	return
}

func AsTxt_Detailed_Optional_Marshal(n jsonexp.Context, val **AsTxt) (ret []byte, err error) {
	if *val != nil {
		ret, err = AsTxt_Detailed_Marshal(n, *val)
	}
	return
}
func AsTxt_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AsTxt) (err error) {
	if len(b) > 0 {
		var val AsTxt
		if e := AsTxt_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func AsTxt_Detailed_Marshal(n jsonexp.Context, val *AsTxt) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[AsTxt_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   AsTxt_Type,
			Fields: fields,
		})
	}
	return
}

func AsTxt_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AsTxt) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(AsTxt_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[AsTxt_Field_Var], &out.Var); e != nil {
		err = errutil.New(AsTxt_Type+"."+AsTxt_Field_Var, "-", e)
	}
	return
}

// EraseEdge Erase at edge: Remove one or more values from a list
type EraseEdge struct {
	From   ListSource  `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
}

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseEdge_Type = "erase_edge"
const EraseEdge_Lede = "erase"
const EraseEdge_Field_From = "$FROM"
const EraseEdge_Field_AtEdge = "$AT_EDGE"

func (op *EraseEdge) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return EraseEdge_Compact_Marshal(n, op)
}
func (op *EraseEdge) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return EraseEdge_Compact_Unmarshal(n, b, op)
}
func (op *EraseEdge) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EraseEdge_Detailed_Marshal(n, op)
}
func (op *EraseEdge) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EraseEdge_Detailed_Unmarshal(n, b, op)
}

func EraseEdge_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]EraseEdge) ([]byte, error) {
	return EraseEdge_Repeats_Marshal(n, vals, EraseEdge_Compact_Marshal)
}
func EraseEdge_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]EraseEdge) ([]byte, error) {
	return EraseEdge_Repeats_Marshal(n, vals, EraseEdge_Detailed_Marshal)
}
func EraseEdge_Repeats_Marshal(n jsonexp.Context, vals *[]EraseEdge, marshEl func(jsonexp.Context, *EraseEdge) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(EraseEdge_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func EraseEdge_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]EraseEdge) error {
	return EraseEdge_Repeats_Unmarshal(n, b, out, EraseEdge_Compact_Unmarshal)
}
func EraseEdge_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]EraseEdge) error {
	return EraseEdge_Repeats_Unmarshal(n, b, out, EraseEdge_Detailed_Unmarshal)
}
func EraseEdge_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]EraseEdge, unmarshEl func(jsonexp.Context, []byte, *EraseEdge) error) (err error) {
	var vals []EraseEdge
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(EraseEdge_Type, "-", e)
		} else {
			vals = make([]EraseEdge, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(EraseEdge_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func EraseEdge_Compact_Optional_Marshal(n jsonexp.Context, val **EraseEdge) (ret []byte, err error) {
	if *val != nil {
		ret, err = EraseEdge_Compact_Marshal(n, *val)
	}
	return
}
func EraseEdge_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **EraseEdge) (err error) {
	if len(b) > 0 {
		var val EraseEdge
		if e := EraseEdge_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func EraseEdge_Compact_Marshal(n jsonexp.Context, val *EraseEdge) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(EraseEdge_Lede)
	if b, e := ListSource_Compact_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.BoolEval_Compact_Optional_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("at_front", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func EraseEdge_Compact_Unmarshal(n jsonexp.Context, b []byte, out *EraseEdge) (err error) {
	return
}

func EraseEdge_Detailed_Optional_Marshal(n jsonexp.Context, val **EraseEdge) (ret []byte, err error) {
	if *val != nil {
		ret, err = EraseEdge_Detailed_Marshal(n, *val)
	}
	return
}
func EraseEdge_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **EraseEdge) (err error) {
	if len(b) > 0 {
		var val EraseEdge
		if e := EraseEdge_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func EraseEdge_Detailed_Marshal(n jsonexp.Context, val *EraseEdge) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[EraseEdge_Field_From] = b
	}

	if b, e := rt.BoolEval_Detailed_Optional_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EraseEdge_Field_AtEdge] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   EraseEdge_Type,
			Fields: fields,
		})
	}
	return
}

func EraseEdge_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EraseEdge) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(EraseEdge_Type, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[EraseEdge_Field_From], &out.From); e != nil {
		err = errutil.New(EraseEdge_Type+"."+EraseEdge_Field_From, "-", e)
	} else if e := rt.BoolEval_Detailed_Optional_Unmarshal(n, msg.Fields[EraseEdge_Field_AtEdge], &out.AtEdge); e != nil {
		err = errutil.New(EraseEdge_Type+"."+EraseEdge_Field_AtEdge, "-", e)
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseIndex_Type = "erase_index"
const EraseIndex_Lede = "erase"
const EraseIndex_Field_Count = "$COUNT"
const EraseIndex_Field_From = "$FROM"
const EraseIndex_Field_AtIndex = "$AT_INDEX"

func (op *EraseIndex) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return EraseIndex_Compact_Marshal(n, op)
}
func (op *EraseIndex) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return EraseIndex_Compact_Unmarshal(n, b, op)
}
func (op *EraseIndex) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EraseIndex_Detailed_Marshal(n, op)
}
func (op *EraseIndex) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EraseIndex_Detailed_Unmarshal(n, b, op)
}

func EraseIndex_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]EraseIndex) ([]byte, error) {
	return EraseIndex_Repeats_Marshal(n, vals, EraseIndex_Compact_Marshal)
}
func EraseIndex_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]EraseIndex) ([]byte, error) {
	return EraseIndex_Repeats_Marshal(n, vals, EraseIndex_Detailed_Marshal)
}
func EraseIndex_Repeats_Marshal(n jsonexp.Context, vals *[]EraseIndex, marshEl func(jsonexp.Context, *EraseIndex) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(EraseIndex_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func EraseIndex_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]EraseIndex) error {
	return EraseIndex_Repeats_Unmarshal(n, b, out, EraseIndex_Compact_Unmarshal)
}
func EraseIndex_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]EraseIndex) error {
	return EraseIndex_Repeats_Unmarshal(n, b, out, EraseIndex_Detailed_Unmarshal)
}
func EraseIndex_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]EraseIndex, unmarshEl func(jsonexp.Context, []byte, *EraseIndex) error) (err error) {
	var vals []EraseIndex
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(EraseIndex_Type, "-", e)
		} else {
			vals = make([]EraseIndex, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(EraseIndex_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func EraseIndex_Compact_Optional_Marshal(n jsonexp.Context, val **EraseIndex) (ret []byte, err error) {
	if *val != nil {
		ret, err = EraseIndex_Compact_Marshal(n, *val)
	}
	return
}
func EraseIndex_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **EraseIndex) (err error) {
	if len(b) > 0 {
		var val EraseIndex
		if e := EraseIndex_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func EraseIndex_Compact_Marshal(n jsonexp.Context, val *EraseIndex) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(EraseIndex_Lede)
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.Count); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := ListSource_Compact_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("from", b)
	}
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("at_index", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func EraseIndex_Compact_Unmarshal(n jsonexp.Context, b []byte, out *EraseIndex) (err error) {
	return
}

func EraseIndex_Detailed_Optional_Marshal(n jsonexp.Context, val **EraseIndex) (ret []byte, err error) {
	if *val != nil {
		ret, err = EraseIndex_Detailed_Marshal(n, *val)
	}
	return
}
func EraseIndex_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **EraseIndex) (err error) {
	if len(b) > 0 {
		var val EraseIndex
		if e := EraseIndex_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func EraseIndex_Detailed_Marshal(n jsonexp.Context, val *EraseIndex) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Count); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[EraseIndex_Field_Count] = b
	}

	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[EraseIndex_Field_From] = b
	}

	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[EraseIndex_Field_AtIndex] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   EraseIndex_Type,
			Fields: fields,
		})
	}
	return
}

func EraseIndex_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EraseIndex) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(EraseIndex_Type, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[EraseIndex_Field_Count], &out.Count); e != nil {
		err = errutil.New(EraseIndex_Type+"."+EraseIndex_Field_Count, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[EraseIndex_Field_From], &out.From); e != nil {
		err = errutil.New(EraseIndex_Type+"."+EraseIndex_Field_From, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[EraseIndex_Field_AtIndex], &out.AtIndex); e != nil {
		err = errutil.New(EraseIndex_Type+"."+EraseIndex_Field_AtIndex, "-", e)
	}
	return
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Do      core.Activity `if:"label=do"`
}

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Erasing_Type,
		Uses: composer.Type_Flow,
	}
}

const Erasing_Type = "erasing"
const Erasing_Lede = Erasing_Type
const Erasing_Field_Count = "$COUNT"
const Erasing_Field_From = "$FROM"
const Erasing_Field_AtIndex = "$AT_INDEX"
const Erasing_Field_As = "$AS"
const Erasing_Field_Do = "$DO"

func (op *Erasing) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return Erasing_Compact_Marshal(n, op)
}
func (op *Erasing) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return Erasing_Compact_Unmarshal(n, b, op)
}
func (op *Erasing) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Erasing_Detailed_Marshal(n, op)
}
func (op *Erasing) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Erasing_Detailed_Unmarshal(n, b, op)
}

func Erasing_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]Erasing) ([]byte, error) {
	return Erasing_Repeats_Marshal(n, vals, Erasing_Compact_Marshal)
}
func Erasing_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Erasing) ([]byte, error) {
	return Erasing_Repeats_Marshal(n, vals, Erasing_Detailed_Marshal)
}
func Erasing_Repeats_Marshal(n jsonexp.Context, vals *[]Erasing, marshEl func(jsonexp.Context, *Erasing) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(Erasing_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Erasing_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Erasing) error {
	return Erasing_Repeats_Unmarshal(n, b, out, Erasing_Compact_Unmarshal)
}
func Erasing_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Erasing) error {
	return Erasing_Repeats_Unmarshal(n, b, out, Erasing_Detailed_Unmarshal)
}
func Erasing_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Erasing, unmarshEl func(jsonexp.Context, []byte, *Erasing) error) (err error) {
	var vals []Erasing
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Erasing_Type, "-", e)
		} else {
			vals = make([]Erasing, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(Erasing_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func Erasing_Compact_Optional_Marshal(n jsonexp.Context, val **Erasing) (ret []byte, err error) {
	if *val != nil {
		ret, err = Erasing_Compact_Marshal(n, *val)
	}
	return
}
func Erasing_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Erasing) (err error) {
	if len(b) > 0 {
		var val Erasing
		if e := Erasing_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func Erasing_Compact_Marshal(n jsonexp.Context, val *Erasing) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(Erasing_Lede)
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.Count); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := ListSource_Compact_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("from", b)
	}
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("at_index", b)
	}
	if b, e := value.Text_Override_Compact_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("as", b)
	}
	if b, e := core.Activity_Compact_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("do", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func Erasing_Compact_Unmarshal(n jsonexp.Context, b []byte, out *Erasing) (err error) {
	return
}

func Erasing_Detailed_Optional_Marshal(n jsonexp.Context, val **Erasing) (ret []byte, err error) {
	if *val != nil {
		ret, err = Erasing_Detailed_Marshal(n, *val)
	}
	return
}
func Erasing_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Erasing) (err error) {
	if len(b) > 0 {
		var val Erasing
		if e := Erasing_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func Erasing_Detailed_Marshal(n jsonexp.Context, val *Erasing) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Count); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[Erasing_Field_Count] = b
	}

	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[Erasing_Field_From] = b
	}

	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[Erasing_Field_AtIndex] = b
	}

	if b, e := value.Text_Override_Detailed_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[Erasing_Field_As] = b
	}

	if b, e := core.Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[Erasing_Field_Do] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Erasing_Type,
			Fields: fields,
		})
	}
	return
}

func Erasing_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Erasing) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Erasing_Type, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[Erasing_Field_Count], &out.Count); e != nil {
		err = errutil.New(Erasing_Type+"."+Erasing_Field_Count, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[Erasing_Field_From], &out.From); e != nil {
		err = errutil.New(Erasing_Type+"."+Erasing_Field_From, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[Erasing_Field_AtIndex], &out.AtIndex); e != nil {
		err = errutil.New(Erasing_Type+"."+Erasing_Field_AtIndex, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[Erasing_Field_As], &out.As); e != nil {
		err = errutil.New(Erasing_Type+"."+Erasing_Field_As, "-", e)
	} else if e := core.Activity_Detailed_Unmarshal(n, msg.Fields[Erasing_Field_Do], &out.Do); e != nil {
		err = errutil.New(Erasing_Type+"."+Erasing_Field_Do, "-", e)
	}
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From   ListSource    `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Do     core.Activity `if:"label=do"`
	Else   core.Brancher `if:"label=else,optional"`
}

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: ErasingEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const ErasingEdge_Type = "erasing_edge"
const ErasingEdge_Lede = "erasing"
const ErasingEdge_Field_From = "$FROM"
const ErasingEdge_Field_AtEdge = "$AT_EDGE"
const ErasingEdge_Field_As = "$AS"
const ErasingEdge_Field_Do = "$DO"
const ErasingEdge_Field_Else = "$ELSE"

func (op *ErasingEdge) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ErasingEdge_Compact_Marshal(n, op)
}
func (op *ErasingEdge) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ErasingEdge_Compact_Unmarshal(n, b, op)
}
func (op *ErasingEdge) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ErasingEdge_Detailed_Marshal(n, op)
}
func (op *ErasingEdge) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ErasingEdge_Detailed_Unmarshal(n, b, op)
}

func ErasingEdge_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ErasingEdge) ([]byte, error) {
	return ErasingEdge_Repeats_Marshal(n, vals, ErasingEdge_Compact_Marshal)
}
func ErasingEdge_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ErasingEdge) ([]byte, error) {
	return ErasingEdge_Repeats_Marshal(n, vals, ErasingEdge_Detailed_Marshal)
}
func ErasingEdge_Repeats_Marshal(n jsonexp.Context, vals *[]ErasingEdge, marshEl func(jsonexp.Context, *ErasingEdge) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ErasingEdge_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ErasingEdge_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ErasingEdge) error {
	return ErasingEdge_Repeats_Unmarshal(n, b, out, ErasingEdge_Compact_Unmarshal)
}
func ErasingEdge_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ErasingEdge) error {
	return ErasingEdge_Repeats_Unmarshal(n, b, out, ErasingEdge_Detailed_Unmarshal)
}
func ErasingEdge_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ErasingEdge, unmarshEl func(jsonexp.Context, []byte, *ErasingEdge) error) (err error) {
	var vals []ErasingEdge
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ErasingEdge_Type, "-", e)
		} else {
			vals = make([]ErasingEdge, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ErasingEdge_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ErasingEdge_Compact_Optional_Marshal(n jsonexp.Context, val **ErasingEdge) (ret []byte, err error) {
	if *val != nil {
		ret, err = ErasingEdge_Compact_Marshal(n, *val)
	}
	return
}
func ErasingEdge_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ErasingEdge) (err error) {
	if len(b) > 0 {
		var val ErasingEdge
		if e := ErasingEdge_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ErasingEdge_Compact_Marshal(n jsonexp.Context, val *ErasingEdge) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ErasingEdge_Lede)
	if b, e := ListSource_Compact_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.BoolEval_Compact_Optional_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("at_front", b)
	}
	if b, e := value.Text_Override_Compact_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("as", b)
	}
	if b, e := core.Activity_Compact_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("do", b)
	}
	if b, e := core.Brancher_Compact_Optional_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("else", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ErasingEdge_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ErasingEdge) (err error) {
	return
}

func ErasingEdge_Detailed_Optional_Marshal(n jsonexp.Context, val **ErasingEdge) (ret []byte, err error) {
	if *val != nil {
		ret, err = ErasingEdge_Detailed_Marshal(n, *val)
	}
	return
}
func ErasingEdge_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ErasingEdge) (err error) {
	if len(b) > 0 {
		var val ErasingEdge
		if e := ErasingEdge_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ErasingEdge_Detailed_Marshal(n jsonexp.Context, val *ErasingEdge) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ErasingEdge_Field_From] = b
	}

	if b, e := rt.BoolEval_Detailed_Optional_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ErasingEdge_Field_AtEdge] = b
	}

	if b, e := value.Text_Override_Detailed_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ErasingEdge_Field_As] = b
	}

	if b, e := core.Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ErasingEdge_Field_Do] = b
	}

	if b, e := core.Brancher_Detailed_Optional_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ErasingEdge_Field_Else] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ErasingEdge_Type,
			Fields: fields,
		})
	}
	return
}

func ErasingEdge_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ErasingEdge) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ErasingEdge_Type, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[ErasingEdge_Field_From], &out.From); e != nil {
		err = errutil.New(ErasingEdge_Type+"."+ErasingEdge_Field_From, "-", e)
	} else if e := rt.BoolEval_Detailed_Optional_Unmarshal(n, msg.Fields[ErasingEdge_Field_AtEdge], &out.AtEdge); e != nil {
		err = errutil.New(ErasingEdge_Type+"."+ErasingEdge_Field_AtEdge, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ErasingEdge_Field_As], &out.As); e != nil {
		err = errutil.New(ErasingEdge_Type+"."+ErasingEdge_Field_As, "-", e)
	} else if e := core.Activity_Detailed_Unmarshal(n, msg.Fields[ErasingEdge_Field_Do], &out.Do); e != nil {
		err = errutil.New(ErasingEdge_Type+"."+ErasingEdge_Field_Do, "-", e)
	} else if e := core.Brancher_Detailed_Optional_Unmarshal(n, msg.Fields[ErasingEdge_Field_Else], &out.Else); e != nil {
		err = errutil.New(ErasingEdge_Type+"."+ErasingEdge_Field_Else, "-", e)
	}
	return
}

// FromNumList Uses a list of numbers
type FromNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const FromNumList_Type = "from_num_list"
const FromNumList_Lede = "nums"
const FromNumList_Field_Var = "$VAR"

func (op *FromNumList) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return FromNumList_Compact_Marshal(n, op)
}
func (op *FromNumList) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return FromNumList_Compact_Unmarshal(n, b, op)
}
func (op *FromNumList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromNumList_Detailed_Marshal(n, op)
}
func (op *FromNumList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromNumList_Detailed_Unmarshal(n, b, op)
}

func FromNumList_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]FromNumList) ([]byte, error) {
	return FromNumList_Repeats_Marshal(n, vals, FromNumList_Compact_Marshal)
}
func FromNumList_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]FromNumList) ([]byte, error) {
	return FromNumList_Repeats_Marshal(n, vals, FromNumList_Detailed_Marshal)
}
func FromNumList_Repeats_Marshal(n jsonexp.Context, vals *[]FromNumList, marshEl func(jsonexp.Context, *FromNumList) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(FromNumList_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func FromNumList_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromNumList) error {
	return FromNumList_Repeats_Unmarshal(n, b, out, FromNumList_Compact_Unmarshal)
}
func FromNumList_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromNumList) error {
	return FromNumList_Repeats_Unmarshal(n, b, out, FromNumList_Detailed_Unmarshal)
}
func FromNumList_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromNumList, unmarshEl func(jsonexp.Context, []byte, *FromNumList) error) (err error) {
	var vals []FromNumList
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(FromNumList_Type, "-", e)
		} else {
			vals = make([]FromNumList, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(FromNumList_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func FromNumList_Compact_Optional_Marshal(n jsonexp.Context, val **FromNumList) (ret []byte, err error) {
	if *val != nil {
		ret, err = FromNumList_Compact_Marshal(n, *val)
	}
	return
}
func FromNumList_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromNumList) (err error) {
	if len(b) > 0 {
		var val FromNumList
		if e := FromNumList_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func FromNumList_Compact_Marshal(n jsonexp.Context, val *FromNumList) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(FromNumList_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func FromNumList_Compact_Unmarshal(n jsonexp.Context, b []byte, out *FromNumList) (err error) {
	return
}

func FromNumList_Detailed_Optional_Marshal(n jsonexp.Context, val **FromNumList) (ret []byte, err error) {
	if *val != nil {
		ret, err = FromNumList_Detailed_Marshal(n, *val)
	}
	return
}
func FromNumList_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromNumList) (err error) {
	if len(b) > 0 {
		var val FromNumList
		if e := FromNumList_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func FromNumList_Detailed_Marshal(n jsonexp.Context, val *FromNumList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[FromNumList_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   FromNumList_Type,
			Fields: fields,
		})
	}
	return
}

func FromNumList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromNumList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(FromNumList_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[FromNumList_Field_Var], &out.Var); e != nil {
		err = errutil.New(FromNumList_Type+"."+FromNumList_Field_Var, "-", e)
	}
	return
}

// FromRecList Uses a list of records
type FromRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "recs",
	}
}

const FromRecList_Type = "from_rec_list"
const FromRecList_Lede = "recs"
const FromRecList_Field_Var = "$VAR"

func (op *FromRecList) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return FromRecList_Compact_Marshal(n, op)
}
func (op *FromRecList) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return FromRecList_Compact_Unmarshal(n, b, op)
}
func (op *FromRecList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromRecList_Detailed_Marshal(n, op)
}
func (op *FromRecList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromRecList_Detailed_Unmarshal(n, b, op)
}

func FromRecList_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]FromRecList) ([]byte, error) {
	return FromRecList_Repeats_Marshal(n, vals, FromRecList_Compact_Marshal)
}
func FromRecList_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]FromRecList) ([]byte, error) {
	return FromRecList_Repeats_Marshal(n, vals, FromRecList_Detailed_Marshal)
}
func FromRecList_Repeats_Marshal(n jsonexp.Context, vals *[]FromRecList, marshEl func(jsonexp.Context, *FromRecList) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(FromRecList_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func FromRecList_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromRecList) error {
	return FromRecList_Repeats_Unmarshal(n, b, out, FromRecList_Compact_Unmarshal)
}
func FromRecList_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromRecList) error {
	return FromRecList_Repeats_Unmarshal(n, b, out, FromRecList_Detailed_Unmarshal)
}
func FromRecList_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromRecList, unmarshEl func(jsonexp.Context, []byte, *FromRecList) error) (err error) {
	var vals []FromRecList
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(FromRecList_Type, "-", e)
		} else {
			vals = make([]FromRecList, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(FromRecList_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func FromRecList_Compact_Optional_Marshal(n jsonexp.Context, val **FromRecList) (ret []byte, err error) {
	if *val != nil {
		ret, err = FromRecList_Compact_Marshal(n, *val)
	}
	return
}
func FromRecList_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromRecList) (err error) {
	if len(b) > 0 {
		var val FromRecList
		if e := FromRecList_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func FromRecList_Compact_Marshal(n jsonexp.Context, val *FromRecList) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(FromRecList_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func FromRecList_Compact_Unmarshal(n jsonexp.Context, b []byte, out *FromRecList) (err error) {
	return
}

func FromRecList_Detailed_Optional_Marshal(n jsonexp.Context, val **FromRecList) (ret []byte, err error) {
	if *val != nil {
		ret, err = FromRecList_Detailed_Marshal(n, *val)
	}
	return
}
func FromRecList_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromRecList) (err error) {
	if len(b) > 0 {
		var val FromRecList
		if e := FromRecList_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func FromRecList_Detailed_Marshal(n jsonexp.Context, val *FromRecList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[FromRecList_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   FromRecList_Type,
			Fields: fields,
		})
	}
	return
}

func FromRecList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromRecList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(FromRecList_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[FromRecList_Field_Var], &out.Var); e != nil {
		err = errutil.New(FromRecList_Type+"."+FromRecList_Field_Var, "-", e)
	}
	return
}

// FromTxtList Uses a list of text
type FromTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: FromTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const FromTxtList_Type = "from_txt_list"
const FromTxtList_Lede = "txts"
const FromTxtList_Field_Var = "$VAR"

func (op *FromTxtList) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return FromTxtList_Compact_Marshal(n, op)
}
func (op *FromTxtList) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return FromTxtList_Compact_Unmarshal(n, b, op)
}
func (op *FromTxtList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return FromTxtList_Detailed_Marshal(n, op)
}
func (op *FromTxtList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return FromTxtList_Detailed_Unmarshal(n, b, op)
}

func FromTxtList_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]FromTxtList) ([]byte, error) {
	return FromTxtList_Repeats_Marshal(n, vals, FromTxtList_Compact_Marshal)
}
func FromTxtList_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]FromTxtList) ([]byte, error) {
	return FromTxtList_Repeats_Marshal(n, vals, FromTxtList_Detailed_Marshal)
}
func FromTxtList_Repeats_Marshal(n jsonexp.Context, vals *[]FromTxtList, marshEl func(jsonexp.Context, *FromTxtList) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(FromTxtList_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func FromTxtList_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromTxtList) error {
	return FromTxtList_Repeats_Unmarshal(n, b, out, FromTxtList_Compact_Unmarshal)
}
func FromTxtList_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromTxtList) error {
	return FromTxtList_Repeats_Unmarshal(n, b, out, FromTxtList_Detailed_Unmarshal)
}
func FromTxtList_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]FromTxtList, unmarshEl func(jsonexp.Context, []byte, *FromTxtList) error) (err error) {
	var vals []FromTxtList
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(FromTxtList_Type, "-", e)
		} else {
			vals = make([]FromTxtList, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(FromTxtList_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func FromTxtList_Compact_Optional_Marshal(n jsonexp.Context, val **FromTxtList) (ret []byte, err error) {
	if *val != nil {
		ret, err = FromTxtList_Compact_Marshal(n, *val)
	}
	return
}
func FromTxtList_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromTxtList) (err error) {
	if len(b) > 0 {
		var val FromTxtList
		if e := FromTxtList_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func FromTxtList_Compact_Marshal(n jsonexp.Context, val *FromTxtList) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(FromTxtList_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func FromTxtList_Compact_Unmarshal(n jsonexp.Context, b []byte, out *FromTxtList) (err error) {
	return
}

func FromTxtList_Detailed_Optional_Marshal(n jsonexp.Context, val **FromTxtList) (ret []byte, err error) {
	if *val != nil {
		ret, err = FromTxtList_Detailed_Marshal(n, *val)
	}
	return
}
func FromTxtList_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **FromTxtList) (err error) {
	if len(b) > 0 {
		var val FromTxtList
		if e := FromTxtList_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func FromTxtList_Detailed_Marshal(n jsonexp.Context, val *FromTxtList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[FromTxtList_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   FromTxtList_Type,
			Fields: fields,
		})
	}
	return
}

func FromTxtList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *FromTxtList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(FromTxtList_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[FromTxtList_Field_Var], &out.Var); e != nil {
		err = errutil.New(FromTxtList_Type+"."+FromTxtList_Field_Var, "-", e)
	}
	return
}

// IntoNumList Targets a list of numbers
type IntoNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoNumList_Type,
		Uses: composer.Type_Flow,
		Lede: "nums",
	}
}

const IntoNumList_Type = "into_num_list"
const IntoNumList_Lede = "nums"
const IntoNumList_Field_Var = "$VAR"

func (op *IntoNumList) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return IntoNumList_Compact_Marshal(n, op)
}
func (op *IntoNumList) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return IntoNumList_Compact_Unmarshal(n, b, op)
}
func (op *IntoNumList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IntoNumList_Detailed_Marshal(n, op)
}
func (op *IntoNumList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IntoNumList_Detailed_Unmarshal(n, b, op)
}

func IntoNumList_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]IntoNumList) ([]byte, error) {
	return IntoNumList_Repeats_Marshal(n, vals, IntoNumList_Compact_Marshal)
}
func IntoNumList_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]IntoNumList) ([]byte, error) {
	return IntoNumList_Repeats_Marshal(n, vals, IntoNumList_Detailed_Marshal)
}
func IntoNumList_Repeats_Marshal(n jsonexp.Context, vals *[]IntoNumList, marshEl func(jsonexp.Context, *IntoNumList) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(IntoNumList_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func IntoNumList_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoNumList) error {
	return IntoNumList_Repeats_Unmarshal(n, b, out, IntoNumList_Compact_Unmarshal)
}
func IntoNumList_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoNumList) error {
	return IntoNumList_Repeats_Unmarshal(n, b, out, IntoNumList_Detailed_Unmarshal)
}
func IntoNumList_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoNumList, unmarshEl func(jsonexp.Context, []byte, *IntoNumList) error) (err error) {
	var vals []IntoNumList
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(IntoNumList_Type, "-", e)
		} else {
			vals = make([]IntoNumList, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(IntoNumList_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func IntoNumList_Compact_Optional_Marshal(n jsonexp.Context, val **IntoNumList) (ret []byte, err error) {
	if *val != nil {
		ret, err = IntoNumList_Compact_Marshal(n, *val)
	}
	return
}
func IntoNumList_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IntoNumList) (err error) {
	if len(b) > 0 {
		var val IntoNumList
		if e := IntoNumList_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func IntoNumList_Compact_Marshal(n jsonexp.Context, val *IntoNumList) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(IntoNumList_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func IntoNumList_Compact_Unmarshal(n jsonexp.Context, b []byte, out *IntoNumList) (err error) {
	return
}

func IntoNumList_Detailed_Optional_Marshal(n jsonexp.Context, val **IntoNumList) (ret []byte, err error) {
	if *val != nil {
		ret, err = IntoNumList_Detailed_Marshal(n, *val)
	}
	return
}
func IntoNumList_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IntoNumList) (err error) {
	if len(b) > 0 {
		var val IntoNumList
		if e := IntoNumList_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func IntoNumList_Detailed_Marshal(n jsonexp.Context, val *IntoNumList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[IntoNumList_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   IntoNumList_Type,
			Fields: fields,
		})
	}
	return
}

func IntoNumList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoNumList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(IntoNumList_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[IntoNumList_Field_Var], &out.Var); e != nil {
		err = errutil.New(IntoNumList_Type+"."+IntoNumList_Field_Var, "-", e)
	}
	return
}

// IntoRecList Targets a list of records
type IntoRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoRecList_Type,
		Uses: composer.Type_Flow,
		Lede: "recs",
	}
}

const IntoRecList_Type = "into_rec_list"
const IntoRecList_Lede = "recs"
const IntoRecList_Field_Var = "$VAR"

func (op *IntoRecList) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return IntoRecList_Compact_Marshal(n, op)
}
func (op *IntoRecList) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return IntoRecList_Compact_Unmarshal(n, b, op)
}
func (op *IntoRecList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IntoRecList_Detailed_Marshal(n, op)
}
func (op *IntoRecList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IntoRecList_Detailed_Unmarshal(n, b, op)
}

func IntoRecList_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]IntoRecList) ([]byte, error) {
	return IntoRecList_Repeats_Marshal(n, vals, IntoRecList_Compact_Marshal)
}
func IntoRecList_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]IntoRecList) ([]byte, error) {
	return IntoRecList_Repeats_Marshal(n, vals, IntoRecList_Detailed_Marshal)
}
func IntoRecList_Repeats_Marshal(n jsonexp.Context, vals *[]IntoRecList, marshEl func(jsonexp.Context, *IntoRecList) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(IntoRecList_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func IntoRecList_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoRecList) error {
	return IntoRecList_Repeats_Unmarshal(n, b, out, IntoRecList_Compact_Unmarshal)
}
func IntoRecList_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoRecList) error {
	return IntoRecList_Repeats_Unmarshal(n, b, out, IntoRecList_Detailed_Unmarshal)
}
func IntoRecList_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoRecList, unmarshEl func(jsonexp.Context, []byte, *IntoRecList) error) (err error) {
	var vals []IntoRecList
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(IntoRecList_Type, "-", e)
		} else {
			vals = make([]IntoRecList, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(IntoRecList_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func IntoRecList_Compact_Optional_Marshal(n jsonexp.Context, val **IntoRecList) (ret []byte, err error) {
	if *val != nil {
		ret, err = IntoRecList_Compact_Marshal(n, *val)
	}
	return
}
func IntoRecList_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IntoRecList) (err error) {
	if len(b) > 0 {
		var val IntoRecList
		if e := IntoRecList_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func IntoRecList_Compact_Marshal(n jsonexp.Context, val *IntoRecList) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(IntoRecList_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func IntoRecList_Compact_Unmarshal(n jsonexp.Context, b []byte, out *IntoRecList) (err error) {
	return
}

func IntoRecList_Detailed_Optional_Marshal(n jsonexp.Context, val **IntoRecList) (ret []byte, err error) {
	if *val != nil {
		ret, err = IntoRecList_Detailed_Marshal(n, *val)
	}
	return
}
func IntoRecList_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IntoRecList) (err error) {
	if len(b) > 0 {
		var val IntoRecList
		if e := IntoRecList_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func IntoRecList_Detailed_Marshal(n jsonexp.Context, val *IntoRecList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[IntoRecList_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   IntoRecList_Type,
			Fields: fields,
		})
	}
	return
}

func IntoRecList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoRecList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(IntoRecList_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[IntoRecList_Field_Var], &out.Var); e != nil {
		err = errutil.New(IntoRecList_Type+"."+IntoRecList_Field_Var, "-", e)
	}
	return
}

// IntoTxtList Targets a list of text
type IntoTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: IntoTxtList_Type,
		Uses: composer.Type_Flow,
		Lede: "txts",
	}
}

const IntoTxtList_Type = "into_txt_list"
const IntoTxtList_Lede = "txts"
const IntoTxtList_Field_Var = "$VAR"

func (op *IntoTxtList) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return IntoTxtList_Compact_Marshal(n, op)
}
func (op *IntoTxtList) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return IntoTxtList_Compact_Unmarshal(n, b, op)
}
func (op *IntoTxtList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return IntoTxtList_Detailed_Marshal(n, op)
}
func (op *IntoTxtList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return IntoTxtList_Detailed_Unmarshal(n, b, op)
}

func IntoTxtList_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]IntoTxtList) ([]byte, error) {
	return IntoTxtList_Repeats_Marshal(n, vals, IntoTxtList_Compact_Marshal)
}
func IntoTxtList_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]IntoTxtList) ([]byte, error) {
	return IntoTxtList_Repeats_Marshal(n, vals, IntoTxtList_Detailed_Marshal)
}
func IntoTxtList_Repeats_Marshal(n jsonexp.Context, vals *[]IntoTxtList, marshEl func(jsonexp.Context, *IntoTxtList) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(IntoTxtList_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func IntoTxtList_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoTxtList) error {
	return IntoTxtList_Repeats_Unmarshal(n, b, out, IntoTxtList_Compact_Unmarshal)
}
func IntoTxtList_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoTxtList) error {
	return IntoTxtList_Repeats_Unmarshal(n, b, out, IntoTxtList_Detailed_Unmarshal)
}
func IntoTxtList_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]IntoTxtList, unmarshEl func(jsonexp.Context, []byte, *IntoTxtList) error) (err error) {
	var vals []IntoTxtList
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(IntoTxtList_Type, "-", e)
		} else {
			vals = make([]IntoTxtList, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(IntoTxtList_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func IntoTxtList_Compact_Optional_Marshal(n jsonexp.Context, val **IntoTxtList) (ret []byte, err error) {
	if *val != nil {
		ret, err = IntoTxtList_Compact_Marshal(n, *val)
	}
	return
}
func IntoTxtList_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IntoTxtList) (err error) {
	if len(b) > 0 {
		var val IntoTxtList
		if e := IntoTxtList_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func IntoTxtList_Compact_Marshal(n jsonexp.Context, val *IntoTxtList) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(IntoTxtList_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func IntoTxtList_Compact_Unmarshal(n jsonexp.Context, b []byte, out *IntoTxtList) (err error) {
	return
}

func IntoTxtList_Detailed_Optional_Marshal(n jsonexp.Context, val **IntoTxtList) (ret []byte, err error) {
	if *val != nil {
		ret, err = IntoTxtList_Detailed_Marshal(n, *val)
	}
	return
}
func IntoTxtList_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **IntoTxtList) (err error) {
	if len(b) > 0 {
		var val IntoTxtList
		if e := IntoTxtList_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func IntoTxtList_Detailed_Marshal(n jsonexp.Context, val *IntoTxtList) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[IntoTxtList_Field_Var] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   IntoTxtList_Type,
			Fields: fields,
		})
	}
	return
}

func IntoTxtList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *IntoTxtList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(IntoTxtList_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[IntoTxtList_Field_Var], &out.Var); e != nil {
		err = errutil.New(IntoTxtList_Type+"."+IntoTxtList_Field_Var, "-", e)
	}
	return
}

// ListAt Get a value from a list. The first element is is index 1.
type ListAt struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: ListAt_Type,
		Uses: composer.Type_Flow,
		Lede: "get",
	}
}

const ListAt_Type = "list_at"
const ListAt_Lede = "get"
const ListAt_Field_List = "$LIST"
const ListAt_Field_Index = "$INDEX"

func (op *ListAt) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListAt_Compact_Marshal(n, op)
}
func (op *ListAt) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListAt_Compact_Unmarshal(n, b, op)
}
func (op *ListAt) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListAt_Detailed_Marshal(n, op)
}
func (op *ListAt) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListAt_Detailed_Unmarshal(n, b, op)
}

func ListAt_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListAt) ([]byte, error) {
	return ListAt_Repeats_Marshal(n, vals, ListAt_Compact_Marshal)
}
func ListAt_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListAt) ([]byte, error) {
	return ListAt_Repeats_Marshal(n, vals, ListAt_Detailed_Marshal)
}
func ListAt_Repeats_Marshal(n jsonexp.Context, vals *[]ListAt, marshEl func(jsonexp.Context, *ListAt) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListAt_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListAt_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListAt) error {
	return ListAt_Repeats_Unmarshal(n, b, out, ListAt_Compact_Unmarshal)
}
func ListAt_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListAt) error {
	return ListAt_Repeats_Unmarshal(n, b, out, ListAt_Detailed_Unmarshal)
}
func ListAt_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListAt, unmarshEl func(jsonexp.Context, []byte, *ListAt) error) (err error) {
	var vals []ListAt
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListAt_Type, "-", e)
		} else {
			vals = make([]ListAt, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListAt_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListAt_Compact_Optional_Marshal(n jsonexp.Context, val **ListAt) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListAt_Compact_Marshal(n, *val)
	}
	return
}
func ListAt_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListAt) (err error) {
	if len(b) > 0 {
		var val ListAt
		if e := ListAt_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListAt_Compact_Marshal(n jsonexp.Context, val *ListAt) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListAt_Lede)
	if b, e := rt.Assignment_Compact_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.Index); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("index", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListAt_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListAt) (err error) {
	return
}

func ListAt_Detailed_Optional_Marshal(n jsonexp.Context, val **ListAt) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListAt_Detailed_Marshal(n, *val)
	}
	return
}
func ListAt_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListAt) (err error) {
	if len(b) > 0 {
		var val ListAt
		if e := ListAt_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListAt_Detailed_Marshal(n jsonexp.Context, val *ListAt) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListAt_Field_List] = b
	}

	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Index); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListAt_Field_Index] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListAt_Type,
			Fields: fields,
		})
	}
	return
}

func ListAt_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListAt) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListAt_Type, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListAt_Field_List], &out.List); e != nil {
		err = errutil.New(ListAt_Type+"."+ListAt_Field_List, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListAt_Field_Index], &out.Index); e != nil {
		err = errutil.New(ListAt_Type+"."+ListAt_Field_Index, "-", e)
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the &#x27;else&#x27; activity if empty.
type ListEach struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: ListEach_Type,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const ListEach_Type = "list_each"
const ListEach_Lede = "repeating"
const ListEach_Field_List = "$LIST"
const ListEach_Field_As = "$AS"
const ListEach_Field_Do = "$DO"
const ListEach_Field_Else = "$ELSE"

func (op *ListEach) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListEach_Compact_Marshal(n, op)
}
func (op *ListEach) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListEach_Compact_Unmarshal(n, b, op)
}
func (op *ListEach) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListEach_Detailed_Marshal(n, op)
}
func (op *ListEach) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListEach_Detailed_Unmarshal(n, b, op)
}

func ListEach_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListEach) ([]byte, error) {
	return ListEach_Repeats_Marshal(n, vals, ListEach_Compact_Marshal)
}
func ListEach_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListEach) ([]byte, error) {
	return ListEach_Repeats_Marshal(n, vals, ListEach_Detailed_Marshal)
}
func ListEach_Repeats_Marshal(n jsonexp.Context, vals *[]ListEach, marshEl func(jsonexp.Context, *ListEach) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListEach_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListEach_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListEach) error {
	return ListEach_Repeats_Unmarshal(n, b, out, ListEach_Compact_Unmarshal)
}
func ListEach_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListEach) error {
	return ListEach_Repeats_Unmarshal(n, b, out, ListEach_Detailed_Unmarshal)
}
func ListEach_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListEach, unmarshEl func(jsonexp.Context, []byte, *ListEach) error) (err error) {
	var vals []ListEach
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListEach_Type, "-", e)
		} else {
			vals = make([]ListEach, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListEach_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListEach_Compact_Optional_Marshal(n jsonexp.Context, val **ListEach) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListEach_Compact_Marshal(n, *val)
	}
	return
}
func ListEach_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListEach) (err error) {
	if len(b) > 0 {
		var val ListEach
		if e := ListEach_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListEach_Compact_Marshal(n jsonexp.Context, val *ListEach) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListEach_Lede)
	if b, e := rt.Assignment_Compact_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("across", b)
	}
	if b, e := ListIterator_Compact_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("as", b)
	}
	if b, e := core.Activity_Compact_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("do", b)
	}
	if b, e := core.Brancher_Compact_Optional_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("else", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListEach_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListEach) (err error) {
	return
}

func ListEach_Detailed_Optional_Marshal(n jsonexp.Context, val **ListEach) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListEach_Detailed_Marshal(n, *val)
	}
	return
}
func ListEach_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListEach) (err error) {
	if len(b) > 0 {
		var val ListEach
		if e := ListEach_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListEach_Detailed_Marshal(n jsonexp.Context, val *ListEach) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListEach_Field_List] = b
	}

	if b, e := ListIterator_Detailed_Marshal(n, &val.As); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListEach_Field_As] = b
	}

	if b, e := core.Activity_Detailed_Marshal(n, &val.Do); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListEach_Field_Do] = b
	}

	if b, e := core.Brancher_Detailed_Optional_Marshal(n, &val.Else); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListEach_Field_Else] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListEach_Type,
			Fields: fields,
		})
	}
	return
}

func ListEach_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListEach) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListEach_Type, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListEach_Field_List], &out.List); e != nil {
		err = errutil.New(ListEach_Type+"."+ListEach_Field_List, "-", e)
	} else if e := ListIterator_Detailed_Unmarshal(n, msg.Fields[ListEach_Field_As], &out.As); e != nil {
		err = errutil.New(ListEach_Type+"."+ListEach_Field_As, "-", e)
	} else if e := core.Activity_Detailed_Unmarshal(n, msg.Fields[ListEach_Field_Do], &out.Do); e != nil {
		err = errutil.New(ListEach_Type+"."+ListEach_Field_Do, "-", e)
	} else if e := core.Brancher_Detailed_Optional_Unmarshal(n, msg.Fields[ListEach_Field_Else], &out.Else); e != nil {
		err = errutil.New(ListEach_Type+"."+ListEach_Field_Else, "-", e)
	}
	return
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFind_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFind_Type = "list_find"
const ListFind_Lede = "find"
const ListFind_Field_Value = "$VALUE"
const ListFind_Field_List = "$LIST"

func (op *ListFind) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListFind_Compact_Marshal(n, op)
}
func (op *ListFind) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListFind_Compact_Unmarshal(n, b, op)
}
func (op *ListFind) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListFind_Detailed_Marshal(n, op)
}
func (op *ListFind) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListFind_Detailed_Unmarshal(n, b, op)
}

func ListFind_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListFind) ([]byte, error) {
	return ListFind_Repeats_Marshal(n, vals, ListFind_Compact_Marshal)
}
func ListFind_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListFind) ([]byte, error) {
	return ListFind_Repeats_Marshal(n, vals, ListFind_Detailed_Marshal)
}
func ListFind_Repeats_Marshal(n jsonexp.Context, vals *[]ListFind, marshEl func(jsonexp.Context, *ListFind) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListFind_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListFind_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListFind) error {
	return ListFind_Repeats_Unmarshal(n, b, out, ListFind_Compact_Unmarshal)
}
func ListFind_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListFind) error {
	return ListFind_Repeats_Unmarshal(n, b, out, ListFind_Detailed_Unmarshal)
}
func ListFind_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListFind, unmarshEl func(jsonexp.Context, []byte, *ListFind) error) (err error) {
	var vals []ListFind
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListFind_Type, "-", e)
		} else {
			vals = make([]ListFind, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListFind_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListFind_Compact_Optional_Marshal(n jsonexp.Context, val **ListFind) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListFind_Compact_Marshal(n, *val)
	}
	return
}
func ListFind_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListFind) (err error) {
	if len(b) > 0 {
		var val ListFind
		if e := ListFind_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListFind_Compact_Marshal(n jsonexp.Context, val *ListFind) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListFind_Lede)
	if b, e := rt.Assignment_Compact_Marshal(n, &val.Value); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.Assignment_Compact_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("list", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListFind_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListFind) (err error) {
	return
}

func ListFind_Detailed_Optional_Marshal(n jsonexp.Context, val **ListFind) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListFind_Detailed_Marshal(n, *val)
	}
	return
}
func ListFind_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListFind) (err error) {
	if len(b) > 0 {
		var val ListFind
		if e := ListFind_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListFind_Detailed_Marshal(n jsonexp.Context, val *ListFind) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.Value); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListFind_Field_Value] = b
	}

	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListFind_Field_List] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListFind_Type,
			Fields: fields,
		})
	}
	return
}

func ListFind_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListFind) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListFind_Type, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListFind_Field_Value], &out.Value); e != nil {
		err = errutil.New(ListFind_Type+"."+ListFind_Field_Value, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListFind_Field_List], &out.List); e != nil {
		err = errutil.New(ListFind_Type+"."+ListFind_Field_List, "-", e)
	}
	return
}

// ListGather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: &#x27;in&#x27; as each value from the list, and &#x27;out&#x27; as the var passed to the gather.
type ListGather struct {
	Var   value.VariableName `if:"label=_"`
	From  ListSource         `if:"label=from"`
	Using string             `if:"label=_,type=text"`
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: ListGather_Type,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const ListGather_Type = "list_gather"
const ListGather_Lede = "gather"
const ListGather_Field_Var = "$VAR"
const ListGather_Field_From = "$FROM"
const ListGather_Field_Using = "$USING"

func (op *ListGather) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListGather_Compact_Marshal(n, op)
}
func (op *ListGather) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListGather_Compact_Unmarshal(n, b, op)
}
func (op *ListGather) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListGather_Detailed_Marshal(n, op)
}
func (op *ListGather) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListGather_Detailed_Unmarshal(n, b, op)
}

func ListGather_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListGather) ([]byte, error) {
	return ListGather_Repeats_Marshal(n, vals, ListGather_Compact_Marshal)
}
func ListGather_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListGather) ([]byte, error) {
	return ListGather_Repeats_Marshal(n, vals, ListGather_Detailed_Marshal)
}
func ListGather_Repeats_Marshal(n jsonexp.Context, vals *[]ListGather, marshEl func(jsonexp.Context, *ListGather) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListGather_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListGather_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListGather) error {
	return ListGather_Repeats_Unmarshal(n, b, out, ListGather_Compact_Unmarshal)
}
func ListGather_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListGather) error {
	return ListGather_Repeats_Unmarshal(n, b, out, ListGather_Detailed_Unmarshal)
}
func ListGather_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListGather, unmarshEl func(jsonexp.Context, []byte, *ListGather) error) (err error) {
	var vals []ListGather
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListGather_Type, "-", e)
		} else {
			vals = make([]ListGather, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListGather_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListGather_Compact_Optional_Marshal(n jsonexp.Context, val **ListGather) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListGather_Compact_Marshal(n, *val)
	}
	return
}
func ListGather_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListGather) (err error) {
	if len(b) > 0 {
		var val ListGather
		if e := ListGather_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListGather_Compact_Marshal(n jsonexp.Context, val *ListGather) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListGather_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := ListSource_Compact_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("from", b)
	}
	if b, e := value.Text_Override_Compact_Marshal(n, &val.Using); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListGather_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListGather) (err error) {
	return
}

func ListGather_Detailed_Optional_Marshal(n jsonexp.Context, val **ListGather) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListGather_Detailed_Marshal(n, *val)
	}
	return
}
func ListGather_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListGather) (err error) {
	if len(b) > 0 {
		var val ListGather
		if e := ListGather_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListGather_Detailed_Marshal(n jsonexp.Context, val *ListGather) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListGather_Field_Var] = b
	}

	if b, e := ListSource_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListGather_Field_From] = b
	}

	if b, e := value.Text_Override_Detailed_Marshal(n, &val.Using); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListGather_Field_Using] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListGather_Type,
			Fields: fields,
		})
	}
	return
}

func ListGather_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListGather) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListGather_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[ListGather_Field_Var], &out.Var); e != nil {
		err = errutil.New(ListGather_Type+"."+ListGather_Field_Var, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[ListGather_Field_From], &out.From); e != nil {
		err = errutil.New(ListGather_Type+"."+ListGather_Field_From, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListGather_Field_Using], &out.Using); e != nil {
		err = errutil.New(ListGather_Type+"."+ListGather_Field_Using, "-", e)
	}
	return
}

const ListIterator_Type = "list_iterator"

var ListIterator_Compact_Optional_Marshal = ListIterator_Compact_Marshal
var ListIterator_Compact_Optional_Unmarshal = ListIterator_Compact_Unmarshal

func ListIterator_Compact_Marshal(n jsonexp.Context, ptr *ListIterator) (ret []byte, err error) {
	if slat := *ptr; slat != nil {
		ret, err = slat.(jsonexp.CompactMarshaler).MarshalCompact(n)
	}
	return
}

func ListIterator_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListIterator) (err error) {
	if ptr, e := jsonexp.UnmarshalCompactSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListIterator); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, ListIterator_Type)
	} else {
		(*out) = store
	}
	return
}

var ListIterator_Detailed_Optional_Marshal = ListIterator_Detailed_Marshal
var ListIterator_Detailed_Optional_Unmarshal = ListIterator_Detailed_Unmarshal

func ListIterator_Detailed_Marshal(n jsonexp.Context, ptr *ListIterator) (ret []byte, err error) {
	if slat := *ptr; slat != nil {
		ret, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	return
}

func ListIterator_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListIterator) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListIterator); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, ListIterator_Type)
	} else {
		(*out) = store
	}
	return
}

func ListIterator_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListIterator) ([]byte, error) {
	return ListIterator_Repeats_Marshal(n, vals, ListIterator_Compact_Marshal)
}
func ListIterator_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListIterator) ([]byte, error) {
	return ListIterator_Repeats_Marshal(n, vals, ListIterator_Detailed_Marshal)
}
func ListIterator_Repeats_Marshal(n jsonexp.Context, vals *[]ListIterator, marshEl func(jsonexp.Context, *ListIterator) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListIterator_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListIterator_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListIterator) error {
	return ListIterator_Repeats_Unmarshal(n, b, out, ListIterator_Compact_Unmarshal)
}
func ListIterator_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListIterator) error {
	return ListIterator_Repeats_Unmarshal(n, b, out, ListIterator_Detailed_Unmarshal)
}
func ListIterator_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListIterator, unmarshEl func(jsonexp.Context, []byte, *ListIterator) error) (err error) {
	var vals []ListIterator
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListIterator_Type, "-", e)
		} else {
			vals = make([]ListIterator, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListIterator_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List rt.Assignment `if:"label=_"`
}

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: ListLen_Type,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const ListLen_Type = "list_len"
const ListLen_Lede = "len"
const ListLen_Field_List = "$LIST"

func (op *ListLen) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListLen_Compact_Marshal(n, op)
}
func (op *ListLen) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListLen_Compact_Unmarshal(n, b, op)
}
func (op *ListLen) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListLen_Detailed_Marshal(n, op)
}
func (op *ListLen) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListLen_Detailed_Unmarshal(n, b, op)
}

func ListLen_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListLen) ([]byte, error) {
	return ListLen_Repeats_Marshal(n, vals, ListLen_Compact_Marshal)
}
func ListLen_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListLen) ([]byte, error) {
	return ListLen_Repeats_Marshal(n, vals, ListLen_Detailed_Marshal)
}
func ListLen_Repeats_Marshal(n jsonexp.Context, vals *[]ListLen, marshEl func(jsonexp.Context, *ListLen) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListLen_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListLen_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListLen) error {
	return ListLen_Repeats_Unmarshal(n, b, out, ListLen_Compact_Unmarshal)
}
func ListLen_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListLen) error {
	return ListLen_Repeats_Unmarshal(n, b, out, ListLen_Detailed_Unmarshal)
}
func ListLen_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListLen, unmarshEl func(jsonexp.Context, []byte, *ListLen) error) (err error) {
	var vals []ListLen
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListLen_Type, "-", e)
		} else {
			vals = make([]ListLen, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListLen_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListLen_Compact_Optional_Marshal(n jsonexp.Context, val **ListLen) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListLen_Compact_Marshal(n, *val)
	}
	return
}
func ListLen_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListLen) (err error) {
	if len(b) > 0 {
		var val ListLen
		if e := ListLen_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListLen_Compact_Marshal(n jsonexp.Context, val *ListLen) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListLen_Lede)
	if b, e := rt.Assignment_Compact_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListLen_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListLen) (err error) {
	return
}

func ListLen_Detailed_Optional_Marshal(n jsonexp.Context, val **ListLen) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListLen_Detailed_Marshal(n, *val)
	}
	return
}
func ListLen_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListLen) (err error) {
	if len(b) > 0 {
		var val ListLen
		if e := ListLen_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListLen_Detailed_Marshal(n jsonexp.Context, val *ListLen) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListLen_Field_List] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListLen_Type,
			Fields: fields,
		})
	}
	return
}

func ListLen_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListLen) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListLen_Type, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListLen_Field_List], &out.List); e != nil {
		err = errutil.New(ListLen_Type+"."+ListLen_Field_List, "-", e)
	}
	return
}

// ListMap Transform the values from one list and place the results in another list. The designated pattern is called with each value from the &#x27;from list&#x27;, one value at a time.
type ListMap struct {
	ToList       string        `if:"label=_,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: ListMap_Type,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const ListMap_Type = "list_map"
const ListMap_Lede = "map"
const ListMap_Field_ToList = "$TO_LIST"
const ListMap_Field_FromList = "$FROM_LIST"
const ListMap_Field_UsingPattern = "$USING_PATTERN"

func (op *ListMap) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListMap_Compact_Marshal(n, op)
}
func (op *ListMap) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListMap_Compact_Unmarshal(n, b, op)
}
func (op *ListMap) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListMap_Detailed_Marshal(n, op)
}
func (op *ListMap) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListMap_Detailed_Unmarshal(n, b, op)
}

func ListMap_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListMap) ([]byte, error) {
	return ListMap_Repeats_Marshal(n, vals, ListMap_Compact_Marshal)
}
func ListMap_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListMap) ([]byte, error) {
	return ListMap_Repeats_Marshal(n, vals, ListMap_Detailed_Marshal)
}
func ListMap_Repeats_Marshal(n jsonexp.Context, vals *[]ListMap, marshEl func(jsonexp.Context, *ListMap) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListMap_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListMap_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListMap) error {
	return ListMap_Repeats_Unmarshal(n, b, out, ListMap_Compact_Unmarshal)
}
func ListMap_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListMap) error {
	return ListMap_Repeats_Unmarshal(n, b, out, ListMap_Detailed_Unmarshal)
}
func ListMap_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListMap, unmarshEl func(jsonexp.Context, []byte, *ListMap) error) (err error) {
	var vals []ListMap
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListMap_Type, "-", e)
		} else {
			vals = make([]ListMap, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListMap_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListMap_Compact_Optional_Marshal(n jsonexp.Context, val **ListMap) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListMap_Compact_Marshal(n, *val)
	}
	return
}
func ListMap_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListMap) (err error) {
	if len(b) > 0 {
		var val ListMap
		if e := ListMap_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListMap_Compact_Marshal(n jsonexp.Context, val *ListMap) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListMap_Lede)
	if b, e := value.Text_Override_Compact_Marshal(n, &val.ToList); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.Assignment_Compact_Marshal(n, &val.FromList); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("from_list", b)
	}
	if b, e := value.Text_Override_Compact_Marshal(n, &val.UsingPattern); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("using", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListMap_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListMap) (err error) {
	return
}

func ListMap_Detailed_Optional_Marshal(n jsonexp.Context, val **ListMap) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListMap_Detailed_Marshal(n, *val)
	}
	return
}
func ListMap_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListMap) (err error) {
	if len(b) > 0 {
		var val ListMap
		if e := ListMap_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListMap_Detailed_Marshal(n jsonexp.Context, val *ListMap) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Override_Detailed_Marshal(n, &val.ToList); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListMap_Field_ToList] = b
	}

	if b, e := rt.Assignment_Detailed_Marshal(n, &val.FromList); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListMap_Field_FromList] = b
	}

	if b, e := value.Text_Override_Detailed_Marshal(n, &val.UsingPattern); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListMap_Field_UsingPattern] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListMap_Type,
			Fields: fields,
		})
	}
	return
}

func ListMap_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListMap) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListMap_Type, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListMap_Field_ToList], &out.ToList); e != nil {
		err = errutil.New(ListMap_Type+"."+ListMap_Field_ToList, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListMap_Field_FromList], &out.FromList); e != nil {
		err = errutil.New(ListMap_Type+"."+ListMap_Field_FromList, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListMap_Field_UsingPattern], &out.UsingPattern); e != nil {
		err = errutil.New(ListMap_Type+"."+ListMap_Field_UsingPattern, "-", e)
	}
	return
}

// ListReduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: &#x27;in&#x27; ( each element of the list ) and &#x27;out&#x27; ( ex. a record ).
type ListReduce struct {
	IntoValue    string        `if:"label=into,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReduce_Type,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const ListReduce_Type = "list_reduce"
const ListReduce_Lede = "reduce"
const ListReduce_Field_IntoValue = "$INTO_VALUE"
const ListReduce_Field_FromList = "$FROM_LIST"
const ListReduce_Field_UsingPattern = "$USING_PATTERN"

func (op *ListReduce) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListReduce_Compact_Marshal(n, op)
}
func (op *ListReduce) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListReduce_Compact_Unmarshal(n, b, op)
}
func (op *ListReduce) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListReduce_Detailed_Marshal(n, op)
}
func (op *ListReduce) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListReduce_Detailed_Unmarshal(n, b, op)
}

func ListReduce_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListReduce) ([]byte, error) {
	return ListReduce_Repeats_Marshal(n, vals, ListReduce_Compact_Marshal)
}
func ListReduce_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListReduce) ([]byte, error) {
	return ListReduce_Repeats_Marshal(n, vals, ListReduce_Detailed_Marshal)
}
func ListReduce_Repeats_Marshal(n jsonexp.Context, vals *[]ListReduce, marshEl func(jsonexp.Context, *ListReduce) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListReduce_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListReduce_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListReduce) error {
	return ListReduce_Repeats_Unmarshal(n, b, out, ListReduce_Compact_Unmarshal)
}
func ListReduce_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListReduce) error {
	return ListReduce_Repeats_Unmarshal(n, b, out, ListReduce_Detailed_Unmarshal)
}
func ListReduce_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListReduce, unmarshEl func(jsonexp.Context, []byte, *ListReduce) error) (err error) {
	var vals []ListReduce
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListReduce_Type, "-", e)
		} else {
			vals = make([]ListReduce, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListReduce_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListReduce_Compact_Optional_Marshal(n jsonexp.Context, val **ListReduce) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListReduce_Compact_Marshal(n, *val)
	}
	return
}
func ListReduce_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListReduce) (err error) {
	if len(b) > 0 {
		var val ListReduce
		if e := ListReduce_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListReduce_Compact_Marshal(n jsonexp.Context, val *ListReduce) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListReduce_Lede)
	if b, e := value.Text_Override_Compact_Marshal(n, &val.IntoValue); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("into", b)
	}
	if b, e := rt.Assignment_Compact_Marshal(n, &val.FromList); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("from_list", b)
	}
	if b, e := value.Text_Override_Compact_Marshal(n, &val.UsingPattern); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("using", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListReduce_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListReduce) (err error) {
	return
}

func ListReduce_Detailed_Optional_Marshal(n jsonexp.Context, val **ListReduce) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListReduce_Detailed_Marshal(n, *val)
	}
	return
}
func ListReduce_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListReduce) (err error) {
	if len(b) > 0 {
		var val ListReduce
		if e := ListReduce_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListReduce_Detailed_Marshal(n jsonexp.Context, val *ListReduce) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Override_Detailed_Marshal(n, &val.IntoValue); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListReduce_Field_IntoValue] = b
	}

	if b, e := rt.Assignment_Detailed_Marshal(n, &val.FromList); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListReduce_Field_FromList] = b
	}

	if b, e := value.Text_Override_Detailed_Marshal(n, &val.UsingPattern); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListReduce_Field_UsingPattern] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListReduce_Type,
			Fields: fields,
		})
	}
	return
}

func ListReduce_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListReduce) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListReduce_Type, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListReduce_Field_IntoValue], &out.IntoValue); e != nil {
		err = errutil.New(ListReduce_Type+"."+ListReduce_Field_IntoValue, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListReduce_Field_FromList], &out.FromList); e != nil {
		err = errutil.New(ListReduce_Type+"."+ListReduce_Field_FromList, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListReduce_Field_UsingPattern], &out.UsingPattern); e != nil {
		err = errutil.New(ListReduce_Type+"."+ListReduce_Field_UsingPattern, "-", e)
	}
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	List ListSource `if:"label=_"`
}

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReverse_Type,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const ListReverse_Type = "list_reverse"
const ListReverse_Lede = "reverse"
const ListReverse_Field_List = "$LIST"

func (op *ListReverse) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListReverse_Compact_Marshal(n, op)
}
func (op *ListReverse) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListReverse_Compact_Unmarshal(n, b, op)
}
func (op *ListReverse) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListReverse_Detailed_Marshal(n, op)
}
func (op *ListReverse) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListReverse_Detailed_Unmarshal(n, b, op)
}

func ListReverse_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListReverse) ([]byte, error) {
	return ListReverse_Repeats_Marshal(n, vals, ListReverse_Compact_Marshal)
}
func ListReverse_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListReverse) ([]byte, error) {
	return ListReverse_Repeats_Marshal(n, vals, ListReverse_Detailed_Marshal)
}
func ListReverse_Repeats_Marshal(n jsonexp.Context, vals *[]ListReverse, marshEl func(jsonexp.Context, *ListReverse) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListReverse_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListReverse_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListReverse) error {
	return ListReverse_Repeats_Unmarshal(n, b, out, ListReverse_Compact_Unmarshal)
}
func ListReverse_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListReverse) error {
	return ListReverse_Repeats_Unmarshal(n, b, out, ListReverse_Detailed_Unmarshal)
}
func ListReverse_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListReverse, unmarshEl func(jsonexp.Context, []byte, *ListReverse) error) (err error) {
	var vals []ListReverse
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListReverse_Type, "-", e)
		} else {
			vals = make([]ListReverse, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListReverse_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListReverse_Compact_Optional_Marshal(n jsonexp.Context, val **ListReverse) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListReverse_Compact_Marshal(n, *val)
	}
	return
}
func ListReverse_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListReverse) (err error) {
	if len(b) > 0 {
		var val ListReverse
		if e := ListReverse_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListReverse_Compact_Marshal(n jsonexp.Context, val *ListReverse) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListReverse_Lede)
	if b, e := ListSource_Compact_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListReverse_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListReverse) (err error) {
	return
}

func ListReverse_Detailed_Optional_Marshal(n jsonexp.Context, val **ListReverse) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListReverse_Detailed_Marshal(n, *val)
	}
	return
}
func ListReverse_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListReverse) (err error) {
	if len(b) > 0 {
		var val ListReverse
		if e := ListReverse_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListReverse_Detailed_Marshal(n jsonexp.Context, val *ListReverse) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := ListSource_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListReverse_Field_List] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListReverse_Type,
			Fields: fields,
		})
	}
	return
}

func ListReverse_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListReverse) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListReverse_Type, "-", e)
	} else if e := ListSource_Detailed_Unmarshal(n, msg.Fields[ListReverse_Field_List], &out.List); e != nil {
		err = errutil.New(ListReverse_Type+"."+ListReverse_Field_List, "-", e)
	}
	return
}

// ListSet Overwrite an existing value in a list.
type ListSet struct {
	List  string        `if:"label=_,type=text"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSet_Type,
		Uses: composer.Type_Flow,
		Lede: "set",
	}
}

const ListSet_Type = "list_set"
const ListSet_Lede = "set"
const ListSet_Field_List = "$LIST"
const ListSet_Field_Index = "$INDEX"
const ListSet_Field_From = "$FROM"

func (op *ListSet) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListSet_Compact_Marshal(n, op)
}
func (op *ListSet) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListSet_Compact_Unmarshal(n, b, op)
}
func (op *ListSet) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSet_Detailed_Marshal(n, op)
}
func (op *ListSet) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSet_Detailed_Unmarshal(n, b, op)
}

func ListSet_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListSet) ([]byte, error) {
	return ListSet_Repeats_Marshal(n, vals, ListSet_Compact_Marshal)
}
func ListSet_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListSet) ([]byte, error) {
	return ListSet_Repeats_Marshal(n, vals, ListSet_Detailed_Marshal)
}
func ListSet_Repeats_Marshal(n jsonexp.Context, vals *[]ListSet, marshEl func(jsonexp.Context, *ListSet) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListSet_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListSet_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSet) error {
	return ListSet_Repeats_Unmarshal(n, b, out, ListSet_Compact_Unmarshal)
}
func ListSet_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSet) error {
	return ListSet_Repeats_Unmarshal(n, b, out, ListSet_Detailed_Unmarshal)
}
func ListSet_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSet, unmarshEl func(jsonexp.Context, []byte, *ListSet) error) (err error) {
	var vals []ListSet
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListSet_Type, "-", e)
		} else {
			vals = make([]ListSet, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListSet_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListSet_Compact_Optional_Marshal(n jsonexp.Context, val **ListSet) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSet_Compact_Marshal(n, *val)
	}
	return
}
func ListSet_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSet) (err error) {
	if len(b) > 0 {
		var val ListSet
		if e := ListSet_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSet_Compact_Marshal(n jsonexp.Context, val *ListSet) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListSet_Lede)
	if b, e := value.Text_Override_Compact_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.Index); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("index", b)
	}
	if b, e := rt.Assignment_Compact_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("from", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListSet_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListSet) (err error) {
	return
}

func ListSet_Detailed_Optional_Marshal(n jsonexp.Context, val **ListSet) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSet_Detailed_Marshal(n, *val)
	}
	return
}
func ListSet_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSet) (err error) {
	if len(b) > 0 {
		var val ListSet
		if e := ListSet_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSet_Detailed_Marshal(n jsonexp.Context, val *ListSet) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Override_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSet_Field_List] = b
	}

	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Index); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSet_Field_Index] = b
	}

	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSet_Field_From] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListSet_Type,
			Fields: fields,
		})
	}
	return
}

func ListSet_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSet) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListSet_Type, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListSet_Field_List], &out.List); e != nil {
		err = errutil.New(ListSet_Type+"."+ListSet_Field_List, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListSet_Field_Index], &out.Index); e != nil {
		err = errutil.New(ListSet_Type+"."+ListSet_Field_Index, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListSet_Field_From], &out.From); e != nil {
		err = errutil.New(ListSet_Type+"."+ListSet_Field_From, "-", e)
	}
	return
}

// ListSlice Create a new list from a section of another list.,Start is optional, if omitted slice starts at the first element.,If start is greater the length, an empty array is returned.,Slice doesnt include the ending index.,Negatives indices indicates an offset from the end.,When end is omitted, copy up to and including the last element;,and do the same if the end is greater than the length
type ListSlice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSlice_Type,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const ListSlice_Type = "list_slice"
const ListSlice_Lede = "slice"
const ListSlice_Field_List = "$LIST"
const ListSlice_Field_Start = "$START"
const ListSlice_Field_End = "$END"

func (op *ListSlice) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListSlice_Compact_Marshal(n, op)
}
func (op *ListSlice) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListSlice_Compact_Unmarshal(n, b, op)
}
func (op *ListSlice) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSlice_Detailed_Marshal(n, op)
}
func (op *ListSlice) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSlice_Detailed_Unmarshal(n, b, op)
}

func ListSlice_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListSlice) ([]byte, error) {
	return ListSlice_Repeats_Marshal(n, vals, ListSlice_Compact_Marshal)
}
func ListSlice_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListSlice) ([]byte, error) {
	return ListSlice_Repeats_Marshal(n, vals, ListSlice_Detailed_Marshal)
}
func ListSlice_Repeats_Marshal(n jsonexp.Context, vals *[]ListSlice, marshEl func(jsonexp.Context, *ListSlice) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListSlice_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListSlice_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSlice) error {
	return ListSlice_Repeats_Unmarshal(n, b, out, ListSlice_Compact_Unmarshal)
}
func ListSlice_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSlice) error {
	return ListSlice_Repeats_Unmarshal(n, b, out, ListSlice_Detailed_Unmarshal)
}
func ListSlice_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSlice, unmarshEl func(jsonexp.Context, []byte, *ListSlice) error) (err error) {
	var vals []ListSlice
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListSlice_Type, "-", e)
		} else {
			vals = make([]ListSlice, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListSlice_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListSlice_Compact_Optional_Marshal(n jsonexp.Context, val **ListSlice) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSlice_Compact_Marshal(n, *val)
	}
	return
}
func ListSlice_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSlice) (err error) {
	if len(b) > 0 {
		var val ListSlice
		if e := ListSlice_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSlice_Compact_Marshal(n jsonexp.Context, val *ListSlice) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListSlice_Lede)
	if b, e := rt.Assignment_Compact_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.NumberEval_Compact_Optional_Marshal(n, &val.Start); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("start", b)
	}
	if b, e := rt.NumberEval_Compact_Optional_Marshal(n, &val.End); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("end", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListSlice_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListSlice) (err error) {
	return
}

func ListSlice_Detailed_Optional_Marshal(n jsonexp.Context, val **ListSlice) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSlice_Detailed_Marshal(n, *val)
	}
	return
}
func ListSlice_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSlice) (err error) {
	if len(b) > 0 {
		var val ListSlice
		if e := ListSlice_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSlice_Detailed_Marshal(n jsonexp.Context, val *ListSlice) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSlice_Field_List] = b
	}

	if b, e := rt.NumberEval_Detailed_Optional_Marshal(n, &val.Start); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSlice_Field_Start] = b
	}

	if b, e := rt.NumberEval_Detailed_Optional_Marshal(n, &val.End); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSlice_Field_End] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListSlice_Type,
			Fields: fields,
		})
	}
	return
}

func ListSlice_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSlice) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListSlice_Type, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListSlice_Field_List], &out.List); e != nil {
		err = errutil.New(ListSlice_Type+"."+ListSlice_Field_List, "-", e)
	} else if e := rt.NumberEval_Detailed_Optional_Unmarshal(n, msg.Fields[ListSlice_Field_Start], &out.Start); e != nil {
		err = errutil.New(ListSlice_Type+"."+ListSlice_Field_Start, "-", e)
	} else if e := rt.NumberEval_Detailed_Optional_Unmarshal(n, msg.Fields[ListSlice_Field_End], &out.End); e != nil {
		err = errutil.New(ListSlice_Type+"."+ListSlice_Field_End, "-", e)
	}
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
}

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortNumbers_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortNumbers_Type = "list_sort_numbers"
const ListSortNumbers_Lede = "sort"
const ListSortNumbers_Field_Var = "$VAR"
const ListSortNumbers_Field_ByField = "$BY_FIELD"
const ListSortNumbers_Field_Descending = "$DESCENDING"

func (op *ListSortNumbers) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListSortNumbers_Compact_Marshal(n, op)
}
func (op *ListSortNumbers) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListSortNumbers_Compact_Unmarshal(n, b, op)
}
func (op *ListSortNumbers) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSortNumbers_Detailed_Marshal(n, op)
}
func (op *ListSortNumbers) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSortNumbers_Detailed_Unmarshal(n, b, op)
}

func ListSortNumbers_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortNumbers) ([]byte, error) {
	return ListSortNumbers_Repeats_Marshal(n, vals, ListSortNumbers_Compact_Marshal)
}
func ListSortNumbers_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortNumbers) ([]byte, error) {
	return ListSortNumbers_Repeats_Marshal(n, vals, ListSortNumbers_Detailed_Marshal)
}
func ListSortNumbers_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortNumbers, marshEl func(jsonexp.Context, *ListSortNumbers) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListSortNumbers_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListSortNumbers_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortNumbers) error {
	return ListSortNumbers_Repeats_Unmarshal(n, b, out, ListSortNumbers_Compact_Unmarshal)
}
func ListSortNumbers_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortNumbers) error {
	return ListSortNumbers_Repeats_Unmarshal(n, b, out, ListSortNumbers_Detailed_Unmarshal)
}
func ListSortNumbers_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortNumbers, unmarshEl func(jsonexp.Context, []byte, *ListSortNumbers) error) (err error) {
	var vals []ListSortNumbers
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListSortNumbers_Type, "-", e)
		} else {
			vals = make([]ListSortNumbers, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListSortNumbers_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListSortNumbers_Compact_Optional_Marshal(n jsonexp.Context, val **ListSortNumbers) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSortNumbers_Compact_Marshal(n, *val)
	}
	return
}
func ListSortNumbers_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSortNumbers) (err error) {
	if len(b) > 0 {
		var val ListSortNumbers
		if e := ListSortNumbers_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSortNumbers_Compact_Marshal(n jsonexp.Context, val *ListSortNumbers) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListSortNumbers_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := value.Text_Override_Compact_Marshal(n, &val.ByField); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("by_field", b)
	}
	if b, e := rt.BoolEval_Compact_Optional_Marshal(n, &val.Descending); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("descending", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListSortNumbers_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListSortNumbers) (err error) {
	return
}

func ListSortNumbers_Detailed_Optional_Marshal(n jsonexp.Context, val **ListSortNumbers) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSortNumbers_Detailed_Marshal(n, *val)
	}
	return
}
func ListSortNumbers_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSortNumbers) (err error) {
	if len(b) > 0 {
		var val ListSortNumbers
		if e := ListSortNumbers_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSortNumbers_Detailed_Marshal(n jsonexp.Context, val *ListSortNumbers) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSortNumbers_Field_Var] = b
	}

	if b, e := value.Text_Override_Detailed_Marshal(n, &val.ByField); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSortNumbers_Field_ByField] = b
	}

	if b, e := rt.BoolEval_Detailed_Optional_Marshal(n, &val.Descending); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortNumbers_Field_Descending] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListSortNumbers_Type,
			Fields: fields,
		})
	}
	return
}

func ListSortNumbers_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSortNumbers) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListSortNumbers_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[ListSortNumbers_Field_Var], &out.Var); e != nil {
		err = errutil.New(ListSortNumbers_Type+"."+ListSortNumbers_Field_Var, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListSortNumbers_Field_ByField], &out.ByField); e != nil {
		err = errutil.New(ListSortNumbers_Type+"."+ListSortNumbers_Field_ByField, "-", e)
	} else if e := rt.BoolEval_Detailed_Optional_Unmarshal(n, msg.Fields[ListSortNumbers_Field_Descending], &out.Descending); e != nil {
		err = errutil.New(ListSortNumbers_Type+"."+ListSortNumbers_Field_Descending, "-", e)
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
	UsingCase  rt.BoolEval        `if:"label=using_case,optional"`
}

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortText_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortText_Type = "list_sort_text"
const ListSortText_Lede = "sort"
const ListSortText_Field_Var = "$VAR"
const ListSortText_Field_ByField = "$BY_FIELD"
const ListSortText_Field_Descending = "$DESCENDING"
const ListSortText_Field_UsingCase = "$USING_CASE"

func (op *ListSortText) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListSortText_Compact_Marshal(n, op)
}
func (op *ListSortText) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListSortText_Compact_Unmarshal(n, b, op)
}
func (op *ListSortText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSortText_Detailed_Marshal(n, op)
}
func (op *ListSortText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSortText_Detailed_Unmarshal(n, b, op)
}

func ListSortText_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortText) ([]byte, error) {
	return ListSortText_Repeats_Marshal(n, vals, ListSortText_Compact_Marshal)
}
func ListSortText_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortText) ([]byte, error) {
	return ListSortText_Repeats_Marshal(n, vals, ListSortText_Detailed_Marshal)
}
func ListSortText_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortText, marshEl func(jsonexp.Context, *ListSortText) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListSortText_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListSortText_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortText) error {
	return ListSortText_Repeats_Unmarshal(n, b, out, ListSortText_Compact_Unmarshal)
}
func ListSortText_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortText) error {
	return ListSortText_Repeats_Unmarshal(n, b, out, ListSortText_Detailed_Unmarshal)
}
func ListSortText_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortText, unmarshEl func(jsonexp.Context, []byte, *ListSortText) error) (err error) {
	var vals []ListSortText
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListSortText_Type, "-", e)
		} else {
			vals = make([]ListSortText, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListSortText_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListSortText_Compact_Optional_Marshal(n jsonexp.Context, val **ListSortText) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSortText_Compact_Marshal(n, *val)
	}
	return
}
func ListSortText_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSortText) (err error) {
	if len(b) > 0 {
		var val ListSortText
		if e := ListSortText_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSortText_Compact_Marshal(n jsonexp.Context, val *ListSortText) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListSortText_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := value.Text_Override_Compact_Marshal(n, &val.ByField); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("by_field", b)
	}
	if b, e := rt.BoolEval_Compact_Optional_Marshal(n, &val.Descending); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("descending", b)
	}
	if b, e := rt.BoolEval_Compact_Optional_Marshal(n, &val.UsingCase); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("using_case", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListSortText_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListSortText) (err error) {
	return
}

func ListSortText_Detailed_Optional_Marshal(n jsonexp.Context, val **ListSortText) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSortText_Detailed_Marshal(n, *val)
	}
	return
}
func ListSortText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSortText) (err error) {
	if len(b) > 0 {
		var val ListSortText
		if e := ListSortText_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSortText_Detailed_Marshal(n jsonexp.Context, val *ListSortText) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSortText_Field_Var] = b
	}

	if b, e := value.Text_Override_Detailed_Marshal(n, &val.ByField); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSortText_Field_ByField] = b
	}

	if b, e := rt.BoolEval_Detailed_Optional_Marshal(n, &val.Descending); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortText_Field_Descending] = b
	}

	if b, e := rt.BoolEval_Detailed_Optional_Marshal(n, &val.UsingCase); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ListSortText_Field_UsingCase] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListSortText_Type,
			Fields: fields,
		})
	}
	return
}

func ListSortText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSortText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListSortText_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[ListSortText_Field_Var], &out.Var); e != nil {
		err = errutil.New(ListSortText_Type+"."+ListSortText_Field_Var, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListSortText_Field_ByField], &out.ByField); e != nil {
		err = errutil.New(ListSortText_Type+"."+ListSortText_Field_ByField, "-", e)
	} else if e := rt.BoolEval_Detailed_Optional_Unmarshal(n, msg.Fields[ListSortText_Field_Descending], &out.Descending); e != nil {
		err = errutil.New(ListSortText_Type+"."+ListSortText_Field_Descending, "-", e)
	} else if e := rt.BoolEval_Detailed_Optional_Unmarshal(n, msg.Fields[ListSortText_Field_UsingCase], &out.UsingCase); e != nil {
		err = errutil.New(ListSortText_Type+"."+ListSortText_Field_UsingCase, "-", e)
	}
	return
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortUsing struct {
	Var   value.VariableName `if:"label=_"`
	Using string             `if:"label=using,type=text"`
}

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortUsing_Type,
		Uses: composer.Type_Flow,
		Lede: "sort",
	}
}

const ListSortUsing_Type = "list_sort_using"
const ListSortUsing_Lede = "sort"
const ListSortUsing_Field_Var = "$VAR"
const ListSortUsing_Field_Using = "$USING"

func (op *ListSortUsing) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListSortUsing_Compact_Marshal(n, op)
}
func (op *ListSortUsing) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListSortUsing_Compact_Unmarshal(n, b, op)
}
func (op *ListSortUsing) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSortUsing_Detailed_Marshal(n, op)
}
func (op *ListSortUsing) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSortUsing_Detailed_Unmarshal(n, b, op)
}

func ListSortUsing_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortUsing) ([]byte, error) {
	return ListSortUsing_Repeats_Marshal(n, vals, ListSortUsing_Compact_Marshal)
}
func ListSortUsing_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortUsing) ([]byte, error) {
	return ListSortUsing_Repeats_Marshal(n, vals, ListSortUsing_Detailed_Marshal)
}
func ListSortUsing_Repeats_Marshal(n jsonexp.Context, vals *[]ListSortUsing, marshEl func(jsonexp.Context, *ListSortUsing) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListSortUsing_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListSortUsing_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortUsing) error {
	return ListSortUsing_Repeats_Unmarshal(n, b, out, ListSortUsing_Compact_Unmarshal)
}
func ListSortUsing_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortUsing) error {
	return ListSortUsing_Repeats_Unmarshal(n, b, out, ListSortUsing_Detailed_Unmarshal)
}
func ListSortUsing_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSortUsing, unmarshEl func(jsonexp.Context, []byte, *ListSortUsing) error) (err error) {
	var vals []ListSortUsing
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListSortUsing_Type, "-", e)
		} else {
			vals = make([]ListSortUsing, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListSortUsing_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListSortUsing_Compact_Optional_Marshal(n jsonexp.Context, val **ListSortUsing) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSortUsing_Compact_Marshal(n, *val)
	}
	return
}
func ListSortUsing_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSortUsing) (err error) {
	if len(b) > 0 {
		var val ListSortUsing
		if e := ListSortUsing_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSortUsing_Compact_Marshal(n jsonexp.Context, val *ListSortUsing) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListSortUsing_Lede)
	if b, e := value.VariableName_Compact_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := value.Text_Override_Compact_Marshal(n, &val.Using); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("using", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListSortUsing_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListSortUsing) (err error) {
	return
}

func ListSortUsing_Detailed_Optional_Marshal(n jsonexp.Context, val **ListSortUsing) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSortUsing_Detailed_Marshal(n, *val)
	}
	return
}
func ListSortUsing_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSortUsing) (err error) {
	if len(b) > 0 {
		var val ListSortUsing
		if e := ListSortUsing_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSortUsing_Detailed_Marshal(n jsonexp.Context, val *ListSortUsing) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Var); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSortUsing_Field_Var] = b
	}

	if b, e := value.Text_Override_Detailed_Marshal(n, &val.Using); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSortUsing_Field_Using] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListSortUsing_Type,
			Fields: fields,
		})
	}
	return
}

func ListSortUsing_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSortUsing) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListSortUsing_Type, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[ListSortUsing_Field_Var], &out.Var); e != nil {
		err = errutil.New(ListSortUsing_Type+"."+ListSortUsing_Field_Var, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListSortUsing_Field_Using], &out.Using); e != nil {
		err = errutil.New(ListSortUsing_Type+"."+ListSortUsing_Field_Using, "-", e)
	}
	return
}

const ListSource_Type = "list_source"

var ListSource_Compact_Optional_Marshal = ListSource_Compact_Marshal
var ListSource_Compact_Optional_Unmarshal = ListSource_Compact_Unmarshal

func ListSource_Compact_Marshal(n jsonexp.Context, ptr *ListSource) (ret []byte, err error) {
	if slat := *ptr; slat != nil {
		ret, err = slat.(jsonexp.CompactMarshaler).MarshalCompact(n)
	}
	return
}

func ListSource_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListSource) (err error) {
	if ptr, e := jsonexp.UnmarshalCompactSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListSource); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, ListSource_Type)
	} else {
		(*out) = store
	}
	return
}

var ListSource_Detailed_Optional_Marshal = ListSource_Detailed_Marshal
var ListSource_Detailed_Optional_Unmarshal = ListSource_Detailed_Unmarshal

func ListSource_Detailed_Marshal(n jsonexp.Context, ptr *ListSource) (ret []byte, err error) {
	if slat := *ptr; slat != nil {
		ret, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	return
}

func ListSource_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSource) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListSource); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, ListSource_Type)
	} else {
		(*out) = store
	}
	return
}

func ListSource_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListSource) ([]byte, error) {
	return ListSource_Repeats_Marshal(n, vals, ListSource_Compact_Marshal)
}
func ListSource_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListSource) ([]byte, error) {
	return ListSource_Repeats_Marshal(n, vals, ListSource_Detailed_Marshal)
}
func ListSource_Repeats_Marshal(n jsonexp.Context, vals *[]ListSource, marshEl func(jsonexp.Context, *ListSource) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListSource_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListSource_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSource) error {
	return ListSource_Repeats_Unmarshal(n, b, out, ListSource_Compact_Unmarshal)
}
func ListSource_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSource) error {
	return ListSource_Repeats_Unmarshal(n, b, out, ListSource_Detailed_Unmarshal)
}
func ListSource_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSource, unmarshEl func(jsonexp.Context, []byte, *ListSource) error) (err error) {
	var vals []ListSource
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListSource_Type, "-", e)
		} else {
			vals = make([]ListSource, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListSource_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

// ListSplice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list&#x27;s length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
type ListSplice struct {
	List   string        `if:"label=_,type=text"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSplice_Type,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const ListSplice_Type = "list_splice"
const ListSplice_Lede = "splice"
const ListSplice_Field_List = "$LIST"
const ListSplice_Field_Start = "$START"
const ListSplice_Field_Remove = "$REMOVE"
const ListSplice_Field_Insert = "$INSERT"

func (op *ListSplice) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return ListSplice_Compact_Marshal(n, op)
}
func (op *ListSplice) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return ListSplice_Compact_Unmarshal(n, b, op)
}
func (op *ListSplice) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ListSplice_Detailed_Marshal(n, op)
}
func (op *ListSplice) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ListSplice_Detailed_Unmarshal(n, b, op)
}

func ListSplice_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListSplice) ([]byte, error) {
	return ListSplice_Repeats_Marshal(n, vals, ListSplice_Compact_Marshal)
}
func ListSplice_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListSplice) ([]byte, error) {
	return ListSplice_Repeats_Marshal(n, vals, ListSplice_Detailed_Marshal)
}
func ListSplice_Repeats_Marshal(n jsonexp.Context, vals *[]ListSplice, marshEl func(jsonexp.Context, *ListSplice) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListSplice_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListSplice_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSplice) error {
	return ListSplice_Repeats_Unmarshal(n, b, out, ListSplice_Compact_Unmarshal)
}
func ListSplice_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSplice) error {
	return ListSplice_Repeats_Unmarshal(n, b, out, ListSplice_Detailed_Unmarshal)
}
func ListSplice_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListSplice, unmarshEl func(jsonexp.Context, []byte, *ListSplice) error) (err error) {
	var vals []ListSplice
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListSplice_Type, "-", e)
		} else {
			vals = make([]ListSplice, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListSplice_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func ListSplice_Compact_Optional_Marshal(n jsonexp.Context, val **ListSplice) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSplice_Compact_Marshal(n, *val)
	}
	return
}
func ListSplice_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSplice) (err error) {
	if len(b) > 0 {
		var val ListSplice
		if e := ListSplice_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSplice_Compact_Marshal(n jsonexp.Context, val *ListSplice) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(ListSplice_Lede)
	if b, e := value.Text_Override_Compact_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.Start); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("start", b)
	}
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.Remove); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("remove", b)
	}
	if b, e := rt.Assignment_Compact_Marshal(n, &val.Insert); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("insert", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func ListSplice_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListSplice) (err error) {
	return
}

func ListSplice_Detailed_Optional_Marshal(n jsonexp.Context, val **ListSplice) (ret []byte, err error) {
	if *val != nil {
		ret, err = ListSplice_Detailed_Marshal(n, *val)
	}
	return
}
func ListSplice_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ListSplice) (err error) {
	if len(b) > 0 {
		var val ListSplice
		if e := ListSplice_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func ListSplice_Detailed_Marshal(n jsonexp.Context, val *ListSplice) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := value.Text_Override_Detailed_Marshal(n, &val.List); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSplice_Field_List] = b
	}

	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Start); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSplice_Field_Start] = b
	}

	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Remove); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSplice_Field_Remove] = b
	}

	if b, e := rt.Assignment_Detailed_Marshal(n, &val.Insert); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[ListSplice_Field_Insert] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   ListSplice_Type,
			Fields: fields,
		})
	}
	return
}

func ListSplice_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListSplice) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(ListSplice_Type, "-", e)
	} else if e := value.Text_Override_Detailed_Unmarshal(n, msg.Fields[ListSplice_Field_List], &out.List); e != nil {
		err = errutil.New(ListSplice_Type+"."+ListSplice_Field_List, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListSplice_Field_Start], &out.Start); e != nil {
		err = errutil.New(ListSplice_Type+"."+ListSplice_Field_Start, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[ListSplice_Field_Remove], &out.Remove); e != nil {
		err = errutil.New(ListSplice_Type+"."+ListSplice_Field_Remove, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[ListSplice_Field_Insert], &out.Insert); e != nil {
		err = errutil.New(ListSplice_Type+"."+ListSplice_Field_Insert, "-", e)
	}
	return
}

const ListTarget_Type = "list_target"

var ListTarget_Compact_Optional_Marshal = ListTarget_Compact_Marshal
var ListTarget_Compact_Optional_Unmarshal = ListTarget_Compact_Unmarshal

func ListTarget_Compact_Marshal(n jsonexp.Context, ptr *ListTarget) (ret []byte, err error) {
	if slat := *ptr; slat != nil {
		ret, err = slat.(jsonexp.CompactMarshaler).MarshalCompact(n)
	}
	return
}

func ListTarget_Compact_Unmarshal(n jsonexp.Context, b []byte, out *ListTarget) (err error) {
	if ptr, e := jsonexp.UnmarshalCompactSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListTarget); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, ListTarget_Type)
	} else {
		(*out) = store
	}
	return
}

var ListTarget_Detailed_Optional_Marshal = ListTarget_Detailed_Marshal
var ListTarget_Detailed_Optional_Unmarshal = ListTarget_Detailed_Unmarshal

func ListTarget_Detailed_Marshal(n jsonexp.Context, ptr *ListTarget) (ret []byte, err error) {
	if slat := *ptr; slat != nil {
		ret, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	return
}

func ListTarget_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ListTarget) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(ListTarget); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, ListTarget_Type)
	} else {
		(*out) = store
	}
	return
}

func ListTarget_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]ListTarget) ([]byte, error) {
	return ListTarget_Repeats_Marshal(n, vals, ListTarget_Compact_Marshal)
}
func ListTarget_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]ListTarget) ([]byte, error) {
	return ListTarget_Repeats_Marshal(n, vals, ListTarget_Detailed_Marshal)
}
func ListTarget_Repeats_Marshal(n jsonexp.Context, vals *[]ListTarget, marshEl func(jsonexp.Context, *ListTarget) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(ListTarget_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func ListTarget_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListTarget) error {
	return ListTarget_Repeats_Unmarshal(n, b, out, ListTarget_Compact_Unmarshal)
}
func ListTarget_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListTarget) error {
	return ListTarget_Repeats_Unmarshal(n, b, out, ListTarget_Detailed_Unmarshal)
}
func ListTarget_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]ListTarget, unmarshEl func(jsonexp.Context, []byte, *ListTarget) error) (err error) {
	var vals []ListTarget
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(ListTarget_Type, "-", e)
		} else {
			vals = make([]ListTarget, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(ListTarget_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

// PutEdge Add a value to a list
type PutEdge struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
}

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: PutEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutEdge_Type = "put_edge"
const PutEdge_Lede = "put"
const PutEdge_Field_From = "$FROM"
const PutEdge_Field_Into = "$INTO"
const PutEdge_Field_AtEdge = "$AT_EDGE"

func (op *PutEdge) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return PutEdge_Compact_Marshal(n, op)
}
func (op *PutEdge) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return PutEdge_Compact_Unmarshal(n, b, op)
}
func (op *PutEdge) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PutEdge_Detailed_Marshal(n, op)
}
func (op *PutEdge) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PutEdge_Detailed_Unmarshal(n, b, op)
}

func PutEdge_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]PutEdge) ([]byte, error) {
	return PutEdge_Repeats_Marshal(n, vals, PutEdge_Compact_Marshal)
}
func PutEdge_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]PutEdge) ([]byte, error) {
	return PutEdge_Repeats_Marshal(n, vals, PutEdge_Detailed_Marshal)
}
func PutEdge_Repeats_Marshal(n jsonexp.Context, vals *[]PutEdge, marshEl func(jsonexp.Context, *PutEdge) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(PutEdge_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func PutEdge_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]PutEdge) error {
	return PutEdge_Repeats_Unmarshal(n, b, out, PutEdge_Compact_Unmarshal)
}
func PutEdge_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]PutEdge) error {
	return PutEdge_Repeats_Unmarshal(n, b, out, PutEdge_Detailed_Unmarshal)
}
func PutEdge_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]PutEdge, unmarshEl func(jsonexp.Context, []byte, *PutEdge) error) (err error) {
	var vals []PutEdge
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(PutEdge_Type, "-", e)
		} else {
			vals = make([]PutEdge, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(PutEdge_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func PutEdge_Compact_Optional_Marshal(n jsonexp.Context, val **PutEdge) (ret []byte, err error) {
	if *val != nil {
		ret, err = PutEdge_Compact_Marshal(n, *val)
	}
	return
}
func PutEdge_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PutEdge) (err error) {
	if len(b) > 0 {
		var val PutEdge
		if e := PutEdge_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func PutEdge_Compact_Marshal(n jsonexp.Context, val *PutEdge) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(PutEdge_Lede)
	if b, e := rt.Assignment_Compact_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := ListTarget_Compact_Marshal(n, &val.Into); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("into", b)
	}
	if b, e := rt.BoolEval_Compact_Optional_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("at_front", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func PutEdge_Compact_Unmarshal(n jsonexp.Context, b []byte, out *PutEdge) (err error) {
	return
}

func PutEdge_Detailed_Optional_Marshal(n jsonexp.Context, val **PutEdge) (ret []byte, err error) {
	if *val != nil {
		ret, err = PutEdge_Detailed_Marshal(n, *val)
	}
	return
}
func PutEdge_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PutEdge) (err error) {
	if len(b) > 0 {
		var val PutEdge
		if e := PutEdge_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func PutEdge_Detailed_Marshal(n jsonexp.Context, val *PutEdge) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[PutEdge_Field_From] = b
	}

	if b, e := ListTarget_Detailed_Marshal(n, &val.Into); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[PutEdge_Field_Into] = b
	}

	if b, e := rt.BoolEval_Detailed_Optional_Marshal(n, &val.AtEdge); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PutEdge_Field_AtEdge] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   PutEdge_Type,
			Fields: fields,
		})
	}
	return
}

func PutEdge_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PutEdge) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(PutEdge_Type, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[PutEdge_Field_From], &out.From); e != nil {
		err = errutil.New(PutEdge_Type+"."+PutEdge_Field_From, "-", e)
	} else if e := ListTarget_Detailed_Unmarshal(n, msg.Fields[PutEdge_Field_Into], &out.Into); e != nil {
		err = errutil.New(PutEdge_Type+"."+PutEdge_Field_Into, "-", e)
	} else if e := rt.BoolEval_Detailed_Optional_Unmarshal(n, msg.Fields[PutEdge_Field_AtEdge], &out.AtEdge); e != nil {
		err = errutil.New(PutEdge_Type+"."+PutEdge_Field_AtEdge, "-", e)
	}
	return
}

// PutIndex Replace one value in a list with another
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: PutIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "put",
	}
}

const PutIndex_Type = "put_index"
const PutIndex_Lede = "put"
const PutIndex_Field_From = "$FROM"
const PutIndex_Field_Into = "$INTO"
const PutIndex_Field_AtIndex = "$AT_INDEX"

func (op *PutIndex) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return PutIndex_Compact_Marshal(n, op)
}
func (op *PutIndex) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return PutIndex_Compact_Unmarshal(n, b, op)
}
func (op *PutIndex) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PutIndex_Detailed_Marshal(n, op)
}
func (op *PutIndex) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PutIndex_Detailed_Unmarshal(n, b, op)
}

func PutIndex_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]PutIndex) ([]byte, error) {
	return PutIndex_Repeats_Marshal(n, vals, PutIndex_Compact_Marshal)
}
func PutIndex_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]PutIndex) ([]byte, error) {
	return PutIndex_Repeats_Marshal(n, vals, PutIndex_Detailed_Marshal)
}
func PutIndex_Repeats_Marshal(n jsonexp.Context, vals *[]PutIndex, marshEl func(jsonexp.Context, *PutIndex) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(PutIndex_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func PutIndex_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]PutIndex) error {
	return PutIndex_Repeats_Unmarshal(n, b, out, PutIndex_Compact_Unmarshal)
}
func PutIndex_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]PutIndex) error {
	return PutIndex_Repeats_Unmarshal(n, b, out, PutIndex_Detailed_Unmarshal)
}
func PutIndex_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]PutIndex, unmarshEl func(jsonexp.Context, []byte, *PutIndex) error) (err error) {
	var vals []PutIndex
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(PutIndex_Type, "-", e)
		} else {
			vals = make([]PutIndex, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(PutIndex_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func PutIndex_Compact_Optional_Marshal(n jsonexp.Context, val **PutIndex) (ret []byte, err error) {
	if *val != nil {
		ret, err = PutIndex_Compact_Marshal(n, *val)
	}
	return
}
func PutIndex_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PutIndex) (err error) {
	if len(b) > 0 {
		var val PutIndex
		if e := PutIndex_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func PutIndex_Compact_Marshal(n jsonexp.Context, val *PutIndex) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(PutIndex_Lede)
	if b, e := rt.Assignment_Compact_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := ListTarget_Compact_Marshal(n, &val.Into); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("into", b)
	}
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("at_index", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func PutIndex_Compact_Unmarshal(n jsonexp.Context, b []byte, out *PutIndex) (err error) {
	return
}

func PutIndex_Detailed_Optional_Marshal(n jsonexp.Context, val **PutIndex) (ret []byte, err error) {
	if *val != nil {
		ret, err = PutIndex_Detailed_Marshal(n, *val)
	}
	return
}
func PutIndex_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PutIndex) (err error) {
	if len(b) > 0 {
		var val PutIndex
		if e := PutIndex_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func PutIndex_Detailed_Marshal(n jsonexp.Context, val *PutIndex) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[PutIndex_Field_From] = b
	}

	if b, e := ListTarget_Detailed_Marshal(n, &val.Into); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[PutIndex_Field_Into] = b
	}

	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.AtIndex); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[PutIndex_Field_AtIndex] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   PutIndex_Type,
			Fields: fields,
		})
	}
	return
}

func PutIndex_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PutIndex) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(PutIndex_Type, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[PutIndex_Field_From], &out.From); e != nil {
		err = errutil.New(PutIndex_Type+"."+PutIndex_Field_From, "-", e)
	} else if e := ListTarget_Detailed_Unmarshal(n, msg.Fields[PutIndex_Field_Into], &out.Into); e != nil {
		err = errutil.New(PutIndex_Type+"."+PutIndex_Field_Into, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[PutIndex_Field_AtIndex], &out.AtIndex); e != nil {
		err = errutil.New(PutIndex_Type+"."+PutIndex_Field_AtIndex, "-", e)
	}
	return
}

// Range Generates a series of numbers r[i] &#x3D; (start + step*i) where i&gt;&#x3D;0.,Start and step default to 1, stop defaults to start;,the inputs are truncated to produce whole numbers;,a zero step returns an error.,A positive step ends the series when the returned value would exceed stop,while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Range_Type,
		Uses: composer.Type_Flow,
	}
}

const Range_Type = "range"
const Range_Lede = Range_Type
const Range_Field_To = "$TO"
const Range_Field_From = "$FROM"
const Range_Field_ByStep = "$BY_STEP"

func (op *Range) MarshalCompact(n jsonexp.Context) (ret []byte, err error) {
	return Range_Compact_Marshal(n, op)
}
func (op *Range) UnmarshalCompact(n jsonexp.Context, b []byte) error {
	return Range_Compact_Unmarshal(n, b, op)
}
func (op *Range) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Range_Detailed_Marshal(n, op)
}
func (op *Range) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Range_Detailed_Unmarshal(n, b, op)
}

func Range_Compact_Repeats_Marshal(n jsonexp.Context, vals *[]Range) ([]byte, error) {
	return Range_Repeats_Marshal(n, vals, Range_Compact_Marshal)
}
func Range_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Range) ([]byte, error) {
	return Range_Repeats_Marshal(n, vals, Range_Detailed_Marshal)
}
func Range_Repeats_Marshal(n jsonexp.Context, vals *[]Range, marshEl func(jsonexp.Context, *Range) ([]byte, error)) (ret []byte, err error) {
	var msgs []json.RawMessage
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		msgs = make([]json.RawMessage, cnt)
		for i, el := range *vals {
			if b, e := marshEl(n, &el); e != nil {
				err = errutil.New(Range_Type, "at", i, "-", e)
				break
			} else {
				msgs[i] = b
			}
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Range_Compact_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Range) error {
	return Range_Repeats_Unmarshal(n, b, out, Range_Compact_Unmarshal)
}
func Range_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Range) error {
	return Range_Repeats_Unmarshal(n, b, out, Range_Detailed_Unmarshal)
}
func Range_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Range, unmarshEl func(jsonexp.Context, []byte, *Range) error) (err error) {
	var vals []Range
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Range_Type, "-", e)
		} else {
			vals = make([]Range, len(msgs))
			for i, msg := range msgs {
				if e := unmarshEl(n, msg, &vals[i]); e != nil {
					err = errutil.New(Range_Type, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func Range_Compact_Optional_Marshal(n jsonexp.Context, val **Range) (ret []byte, err error) {
	if *val != nil {
		ret, err = Range_Compact_Marshal(n, *val)
	}
	return
}
func Range_Compact_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Range) (err error) {
	if len(b) > 0 {
		var val Range
		if e := Range_Compact_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func Range_Compact_Marshal(n jsonexp.Context, val *Range) (ret []byte, err error) {
	var sig jsonexp.CompactFlow
	sig.WriteLede(Range_Lede)
	if b, e := rt.NumberEval_Compact_Marshal(n, &val.To); e != nil {
		err = errutil.Append(err, e)
	} else {
		sig.AddMsg("", b)
	}
	if b, e := rt.NumberEval_Compact_Optional_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("from", b)
	}
	if b, e := rt.NumberEval_Compact_Optional_Marshal(n, &val.ByStep); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		sig.AddMsg("by_step", b)
	}
	if err == nil {
		ret, err = sig.MarshalJSON()
	}
	return
}
func Range_Compact_Unmarshal(n jsonexp.Context, b []byte, out *Range) (err error) {
	return
}

func Range_Detailed_Optional_Marshal(n jsonexp.Context, val **Range) (ret []byte, err error) {
	if *val != nil {
		ret, err = Range_Detailed_Marshal(n, *val)
	}
	return
}
func Range_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Range) (err error) {
	if len(b) > 0 {
		var val Range
		if e := Range_Detailed_Unmarshal(n, b, &val); e != nil {
			err = e
		} else {
			*out = &val
		}
	}
	return
}
func Range_Detailed_Marshal(n jsonexp.Context, val *Range) (ret []byte, err error) {
	fields := make(jsonexp.Fields)
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.To); e != nil {
		err = errutil.Append(err, e)
	} else {
		fields[Range_Field_To] = b
	}

	if b, e := rt.NumberEval_Detailed_Optional_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Range_Field_From] = b
	}

	if b, e := rt.NumberEval_Detailed_Optional_Marshal(n, &val.ByStep); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Range_Field_ByStep] = b
	}

	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Range_Type,
			Fields: fields,
		})
	}
	return
}

func Range_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Range) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Range_Type, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[Range_Field_To], &out.To); e != nil {
		err = errutil.New(Range_Type+"."+Range_Field_To, "-", e)
	} else if e := rt.NumberEval_Detailed_Optional_Unmarshal(n, msg.Fields[Range_Field_From], &out.From); e != nil {
		err = errutil.New(Range_Type+"."+Range_Field_From, "-", e)
	} else if e := rt.NumberEval_Detailed_Optional_Unmarshal(n, msg.Fields[Range_Field_ByStep], &out.ByStep); e != nil {
		err = errutil.New(Range_Type+"."+Range_Field_ByStep, "-", e)
	}
	return
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}

var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
}
