// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: "as_num",
		Lede: "num",
	}
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: "as_rec",
		Lede: "rec",
	}
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: "as_txt",
		Lede: "txt",
	}
}

// EraseEdge Erase at edge: Remove one or more values from a list
type EraseEdge struct {
	From   ListSource  `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
}

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: "erase_edge",
		Lede: "erase",
	}
}

// EraseIndex Erase at index: Remove one or more values from a list
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: "erase_index",
		Lede: "erase",
	}
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      value.Text    `if:"label=as"`
	Do      core.Activity `if:"label=do"`
}

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: "erasing",
	}
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From   ListSource    `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     value.Text    `if:"label=as"`
	Do     core.Activity `if:"label=do"`
	Else   core.Brancher `if:"label=else,optional"`
}

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: "erasing_edge",
		Lede: "erasing",
	}
}

// FromNumList Uses a list of numbers
type FromNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_num_list",
		Lede: "nums",
	}
}

// FromRecList Uses a list of records
type FromRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_rec_list",
		Lede: "recs",
	}
}

// FromTxtList Uses a list of text
type FromTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: "from_txt_list",
		Lede: "txts",
	}
}

// IntoNumList Targets a list of numbers
type IntoNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_num_list",
		Lede: "nums",
	}
}

// IntoRecList Targets a list of records
type IntoRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_rec_list",
		Lede: "recs",
	}
}

// IntoTxtList Targets a list of text
type IntoTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: "into_txt_list",
		Lede: "txts",
	}
}

// ListAt Get a value from a list. The first element is is index 1.
type ListAt struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_at",
		Lede: "get",
	}
}

// ListEach Loops over the elements in the passed list, or runs the &#x27;else&#x27; activity if empty.
type ListEach struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_each",
		Lede: "repeating",
	}
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_find",
		Lede: "find",
	}
}

// ListGather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: &#x27;in&#x27; as each value from the list, and &#x27;out&#x27; as the var passed to the gather.
type ListGather struct {
	Var   value.VariableName `if:"label=_"`
	From  ListSource         `if:"label=from"`
	Using value.Text         `if:"label=_"`
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_gather",
		Lede: "gather",
	}
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List rt.Assignment `if:"label=_"`
}

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_len",
		Lede: "len",
	}
}

// ListMap Transform the values from one list and place the results in another list. The designated pattern is called with each value from the &#x27;from list&#x27;, one value at a time.
type ListMap struct {
	ToList       value.Text    `if:"label=_"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern value.Text    `if:"label=using"`
}

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_map",
		Lede: "map",
	}
}

// ListReduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: &#x27;in&#x27; ( each element of the list ) and &#x27;out&#x27; ( ex. a record ).
type ListReduce struct {
	IntoValue    value.Text    `if:"label=into"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern value.Text    `if:"label=using"`
}

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_reduce",
		Lede: "reduce",
	}
}

// ListReverse Reverse a list.
type ListReverse struct {
	List ListSource `if:"label=_"`
}

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_reverse",
		Lede: "reverse",
	}
}

// ListSet Overwrite an existing value in a list.
type ListSet struct {
	List  value.Text    `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_set",
		Lede: "set",
	}
}

// ListSlice Create a new list from a section of another list.,Start is optional, if omitted slice starts at the first element.,If start is greater the length, an empty array is returned.,Slice doesnt include the ending index.,Negatives indices indicates an offset from the end.,When end is omitted, copy up to and including the last element;,and do the same if the end is greater than the length
type ListSlice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_slice",
		Lede: "slice",
	}
}

// ListSortNumbers
type ListSortNumbers struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
}

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_sort_numbers",
		Lede: "sort",
	}
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
	UsingCase  rt.BoolEval        `if:"label=using_case,optional"`
}

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_sort_text",
		Lede: "sort",
	}
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortUsing struct {
	Var   value.VariableName `if:"label=_"`
	Using value.Text         `if:"label=using"`
}

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_sort_using",
		Lede: "sort",
	}
}

// ListSplice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list&#x27;s length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
type ListSplice struct {
	List   value.Text    `if:"label=_"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: "list_splice",
		Lede: "splice",
	}
}

// PutEdge Add a value to a list
type PutEdge struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
}

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: "put_edge",
		Lede: "put",
	}
}

// PutIndex Replace one value in a list with another
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: "put_index",
		Lede: "put",
	}
}

// Range Generates a series of numbers r[i] &#x3D; (start + step*i) where i&gt;&#x3D;0.,Start and step default to 1, stop defaults to start;,the inputs are truncated to produce whole numbers;,a zero step returns an error.,A positive step ends the series when the returned value would exceed stop,while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: "range",
	}
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}
var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
}
