// Code generated by "makeops"; edit at your own risk.
package list

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
)

// AsNum Define the name of a number variable.
type AsNum struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsNum) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AsNum,
		Uses: "flow",
		Lede: "num",
	}
}

var Type_AsNum = "as_num"

func (op *AsNum) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_AsNum,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *AsNum) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// AsRec Define the name of a record variable.
type AsRec struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsRec) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AsRec,
		Uses: "flow",
		Lede: "rec",
	}
}

var Type_AsRec = "as_rec"

func (op *AsRec) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_AsRec,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *AsRec) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// AsTxt Define the name of a text variable.
type AsTxt struct {
	Var value.VariableName `if:"label=_"`
}

func (*AsTxt) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AsTxt,
		Uses: "flow",
		Lede: "txt",
	}
}

var Type_AsTxt = "as_txt"

func (op *AsTxt) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_AsTxt,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *AsTxt) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// EraseEdge Erase at edge: Remove one or more values from a list
type EraseEdge struct {
	From   ListSource  `if:"label=_"`
	AtEdge rt.BoolEval `if:"label=at_front,optional"`
}

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EraseEdge,
		Uses: "flow",
		Lede: "erase",
	}
}

var Type_EraseEdge = "erase_edge"

func (op *EraseEdge) MarshalJSON() (ret []byte, err error) {
	if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonAtEdge, e := op.MarshalJSONAtEdge(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_EraseEdge,
			Value: map[string]json.RawMessage{
				"$FROM":    jsonFrom,
				"$AT_EDGE": jsonAtEdge,
			},
		})
	}
	return
}

func (op *EraseEdge) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListSource,
			Value: v,
		})
	}
	return
}

func (op *EraseEdge) MarshalJSONAtEdge() (ret []byte, err error) {
	if v, e := op.AtEdge.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EraseIndex,
		Uses: "flow",
		Lede: "erase",
	}
}

var Type_EraseIndex = "erase_index"

func (op *EraseIndex) MarshalJSON() (ret []byte, err error) {
	if jsonCount, e := op.MarshalJSONCount(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonAtIndex, e := op.MarshalJSONAtIndex(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_EraseIndex,
			Value: map[string]json.RawMessage{
				"$COUNT":    jsonCount,
				"$FROM":     jsonFrom,
				"$AT_INDEX": jsonAtIndex,
			},
		})
	}
	return
}

func (op *EraseIndex) MarshalJSONCount() (ret []byte, err error) {
	if v, e := op.Count.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *EraseIndex) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListSource,
			Value: v,
		})
	}
	return
}

func (op *EraseIndex) MarshalJSONAtIndex() (ret []byte, err error) {
	if v, e := op.AtIndex.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// Erasing Erase elements from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	From    ListSource    `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Do      core.Activity `if:"label=do"`
}

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Erasing,
		Uses: "flow",
	}
}

var Type_Erasing = "erasing"

func (op *Erasing) MarshalJSON() (ret []byte, err error) {
	if jsonCount, e := op.MarshalJSONCount(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonAtIndex, e := op.MarshalJSONAtIndex(); e != nil {
		err = e
	} else if jsonAs, e := op.MarshalJSONAs(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Erasing,
			Value: map[string]json.RawMessage{
				"$COUNT":    jsonCount,
				"$FROM":     jsonFrom,
				"$AT_INDEX": jsonAtIndex,
				"$AS":       jsonAs,
				"$DO":       jsonDo,
			},
		})
	}
	return
}

func (op *Erasing) MarshalJSONCount() (ret []byte, err error) {
	if v, e := op.Count.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *Erasing) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListSource,
			Value: v,
		})
	}
	return
}

func (op *Erasing) MarshalJSONAtIndex() (ret []byte, err error) {
	if v, e := op.AtIndex.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *Erasing) MarshalJSONAs() (ret []byte, err error) {
	// type override
	m := value.Text{op.As}
	ret, err = m.MarshalJSON()
	return
}

func (op *Erasing) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	From   ListSource    `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Do     core.Activity `if:"label=do"`
	Else   core.Brancher `if:"label=else,optional"`
}

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ErasingEdge,
		Uses: "flow",
		Lede: "erasing",
	}
}

var Type_ErasingEdge = "erasing_edge"

func (op *ErasingEdge) MarshalJSON() (ret []byte, err error) {
	if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonAtEdge, e := op.MarshalJSONAtEdge(); e != nil {
		err = e
	} else if jsonAs, e := op.MarshalJSONAs(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ErasingEdge,
			Value: map[string]json.RawMessage{
				"$FROM":    jsonFrom,
				"$AT_EDGE": jsonAtEdge,
				"$AS":      jsonAs,
				"$DO":      jsonDo,
				"$ELSE":    jsonElse,
			},
		})
	}
	return
}

func (op *ErasingEdge) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListSource,
			Value: v,
		})
	}
	return
}

func (op *ErasingEdge) MarshalJSONAtEdge() (ret []byte, err error) {
	if v, e := op.AtEdge.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *ErasingEdge) MarshalJSONAs() (ret []byte, err error) {
	// type override
	m := value.Text{op.As}
	ret, err = m.MarshalJSON()
	return
}

func (op *ErasingEdge) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

func (op *ErasingEdge) MarshalJSONElse() (ret []byte, err error) {
	if v, e := op.Else.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  core.Type_Brancher,
			Value: v,
		})
	}
	return
}

// FromNumList Uses a list of numbers
type FromNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromNumList,
		Uses: "flow",
		Lede: "nums",
	}
}

var Type_FromNumList = "from_num_list"

func (op *FromNumList) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromNumList,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *FromNumList) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// FromRecList Uses a list of records
type FromRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromRecList,
		Uses: "flow",
		Lede: "recs",
	}
}

var Type_FromRecList = "from_rec_list"

func (op *FromRecList) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromRecList,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *FromRecList) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// FromTxtList Uses a list of text
type FromTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*FromTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_FromTxtList,
		Uses: "flow",
		Lede: "txts",
	}
}

var Type_FromTxtList = "from_txt_list"

func (op *FromTxtList) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_FromTxtList,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *FromTxtList) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// IntoNumList Targets a list of numbers
type IntoNumList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoNumList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoNumList,
		Uses: "flow",
		Lede: "nums",
	}
}

var Type_IntoNumList = "into_num_list"

func (op *IntoNumList) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IntoNumList,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *IntoNumList) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// IntoRecList Targets a list of records
type IntoRecList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoRecList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoRecList,
		Uses: "flow",
		Lede: "recs",
	}
}

var Type_IntoRecList = "into_rec_list"

func (op *IntoRecList) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IntoRecList,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *IntoRecList) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// IntoTxtList Targets a list of text
type IntoTxtList struct {
	Var value.VariableName `if:"label=_"`
}

func (*IntoTxtList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_IntoTxtList,
		Uses: "flow",
		Lede: "txts",
	}
}

var Type_IntoTxtList = "into_txt_list"

func (op *IntoTxtList) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_IntoTxtList,
			Value: map[string]json.RawMessage{
				"$VAR": jsonVar,
			},
		})
	}
	return
}

func (op *IntoTxtList) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

// ListAt Get a value from a list. The first element is is index 1.
type ListAt struct {
	List  rt.Assignment `if:"label=_"`
	Index rt.NumberEval `if:"label=index"`
}

func (*ListAt) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListAt,
		Uses: "flow",
		Lede: "get",
	}
}

var Type_ListAt = "list_at"

func (op *ListAt) MarshalJSON() (ret []byte, err error) {
	if jsonList, e := op.MarshalJSONList(); e != nil {
		err = e
	} else if jsonIndex, e := op.MarshalJSONIndex(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListAt,
			Value: map[string]json.RawMessage{
				"$LIST":  jsonList,
				"$INDEX": jsonIndex,
			},
		})
	}
	return
}

func (op *ListAt) MarshalJSONList() (ret []byte, err error) {
	if v, e := op.List.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *ListAt) MarshalJSONIndex() (ret []byte, err error) {
	if v, e := op.Index.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the &#x27;else&#x27; activity if empty.
type ListEach struct {
	List rt.Assignment `if:"label=across"`
	As   ListIterator  `if:"label=as"`
	Do   core.Activity `if:"label=do"`
	Else core.Brancher `if:"label=else,optional"`
}

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListEach,
		Uses: "flow",
		Lede: "repeating",
	}
}

var Type_ListEach = "list_each"

func (op *ListEach) MarshalJSON() (ret []byte, err error) {
	if jsonList, e := op.MarshalJSONList(); e != nil {
		err = e
	} else if jsonAs, e := op.MarshalJSONAs(); e != nil {
		err = e
	} else if jsonDo, e := op.MarshalJSONDo(); e != nil {
		err = e
	} else if jsonElse, e := op.MarshalJSONElse(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListEach,
			Value: map[string]json.RawMessage{
				"$LIST": jsonList,
				"$AS":   jsonAs,
				"$DO":   jsonDo,
				"$ELSE": jsonElse,
			},
		})
	}
	return
}

func (op *ListEach) MarshalJSONList() (ret []byte, err error) {
	if v, e := op.List.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *ListEach) MarshalJSONAs() (ret []byte, err error) {
	if v, e := op.As.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListIterator,
			Value: v,
		})
	}
	return
}

func (op *ListEach) MarshalJSONDo() (ret []byte, err error) {
	ret, err = op.Do.MarshalJSON()
	return
}

func (op *ListEach) MarshalJSONElse() (ret []byte, err error) {
	if v, e := op.Else.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  core.Type_Brancher,
			Value: v,
		})
	}
	return
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value rt.Assignment `if:"label=_"`
	List  rt.Assignment `if:"label=list"`
}

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListFind,
		Uses: "flow",
		Lede: "find",
	}
}

var Type_ListFind = "list_find"

func (op *ListFind) MarshalJSON() (ret []byte, err error) {
	if jsonValue, e := op.MarshalJSONValue(); e != nil {
		err = e
	} else if jsonList, e := op.MarshalJSONList(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListFind,
			Value: map[string]json.RawMessage{
				"$VALUE": jsonValue,
				"$LIST":  jsonList,
			},
		})
	}
	return
}

func (op *ListFind) MarshalJSONValue() (ret []byte, err error) {
	if v, e := op.Value.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *ListFind) MarshalJSONList() (ret []byte, err error) {
	if v, e := op.List.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

// ListGather Transform the values from a list. The named pattern gets called once for each value in the list. It get called with two parameters: &#x27;in&#x27; as each value from the list, and &#x27;out&#x27; as the var passed to the gather.
type ListGather struct {
	Var   value.VariableName `if:"label=_"`
	From  ListSource         `if:"label=from"`
	Using string             `if:"label=_,type=text"`
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListGather,
		Uses: "flow",
		Lede: "gather",
	}
}

var Type_ListGather = "list_gather"

func (op *ListGather) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonUsing, e := op.MarshalJSONUsing(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListGather,
			Value: map[string]json.RawMessage{
				"$VAR":   jsonVar,
				"$FROM":  jsonFrom,
				"$USING": jsonUsing,
			},
		})
	}
	return
}

func (op *ListGather) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

func (op *ListGather) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListSource,
			Value: v,
		})
	}
	return
}

func (op *ListGather) MarshalJSONUsing() (ret []byte, err error) {
	// type override
	m := value.Text{op.Using}
	ret, err = m.MarshalJSON()
	return
}

const Type_ListIterator = "list_iterator"

// ListLen Determines the number of values in a list.
type ListLen struct {
	List rt.Assignment `if:"label=_"`
}

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListLen,
		Uses: "flow",
		Lede: "len",
	}
}

var Type_ListLen = "list_len"

func (op *ListLen) MarshalJSON() (ret []byte, err error) {
	if jsonList, e := op.MarshalJSONList(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListLen,
			Value: map[string]json.RawMessage{
				"$LIST": jsonList,
			},
		})
	}
	return
}

func (op *ListLen) MarshalJSONList() (ret []byte, err error) {
	if v, e := op.List.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

// ListMap Transform the values from one list and place the results in another list. The designated pattern is called with each value from the &#x27;from list&#x27;, one value at a time.
type ListMap struct {
	ToList       string        `if:"label=_,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListMap,
		Uses: "flow",
		Lede: "map",
	}
}

var Type_ListMap = "list_map"

func (op *ListMap) MarshalJSON() (ret []byte, err error) {
	if jsonToList, e := op.MarshalJSONToList(); e != nil {
		err = e
	} else if jsonFromList, e := op.MarshalJSONFromList(); e != nil {
		err = e
	} else if jsonUsingPattern, e := op.MarshalJSONUsingPattern(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListMap,
			Value: map[string]json.RawMessage{
				"$TO_LIST":       jsonToList,
				"$FROM_LIST":     jsonFromList,
				"$USING_PATTERN": jsonUsingPattern,
			},
		})
	}
	return
}

func (op *ListMap) MarshalJSONToList() (ret []byte, err error) {
	// type override
	m := value.Text{op.ToList}
	ret, err = m.MarshalJSON()
	return
}

func (op *ListMap) MarshalJSONFromList() (ret []byte, err error) {
	if v, e := op.FromList.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *ListMap) MarshalJSONUsingPattern() (ret []byte, err error) {
	// type override
	m := value.Text{op.UsingPattern}
	ret, err = m.MarshalJSON()
	return
}

// ListReduce Transform the values from one list by combining them into a single value. The named pattern is called with two parameters: &#x27;in&#x27; ( each element of the list ) and &#x27;out&#x27; ( ex. a record ).
type ListReduce struct {
	IntoValue    string        `if:"label=into,type=text"`
	FromList     rt.Assignment `if:"label=from_list"`
	UsingPattern string        `if:"label=using,type=text"`
}

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListReduce,
		Uses: "flow",
		Lede: "reduce",
	}
}

var Type_ListReduce = "list_reduce"

func (op *ListReduce) MarshalJSON() (ret []byte, err error) {
	if jsonIntoValue, e := op.MarshalJSONIntoValue(); e != nil {
		err = e
	} else if jsonFromList, e := op.MarshalJSONFromList(); e != nil {
		err = e
	} else if jsonUsingPattern, e := op.MarshalJSONUsingPattern(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListReduce,
			Value: map[string]json.RawMessage{
				"$INTO_VALUE":    jsonIntoValue,
				"$FROM_LIST":     jsonFromList,
				"$USING_PATTERN": jsonUsingPattern,
			},
		})
	}
	return
}

func (op *ListReduce) MarshalJSONIntoValue() (ret []byte, err error) {
	// type override
	m := value.Text{op.IntoValue}
	ret, err = m.MarshalJSON()
	return
}

func (op *ListReduce) MarshalJSONFromList() (ret []byte, err error) {
	if v, e := op.FromList.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *ListReduce) MarshalJSONUsingPattern() (ret []byte, err error) {
	// type override
	m := value.Text{op.UsingPattern}
	ret, err = m.MarshalJSON()
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	List ListSource `if:"label=_"`
}

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListReverse,
		Uses: "flow",
		Lede: "reverse",
	}
}

var Type_ListReverse = "list_reverse"

func (op *ListReverse) MarshalJSON() (ret []byte, err error) {
	if jsonList, e := op.MarshalJSONList(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListReverse,
			Value: map[string]json.RawMessage{
				"$LIST": jsonList,
			},
		})
	}
	return
}

func (op *ListReverse) MarshalJSONList() (ret []byte, err error) {
	if v, e := op.List.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListSource,
			Value: v,
		})
	}
	return
}

// ListSet Overwrite an existing value in a list.
type ListSet struct {
	List  string        `if:"label=_,type=text"`
	Index rt.NumberEval `if:"label=index"`
	From  rt.Assignment `if:"label=from"`
}

func (*ListSet) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSet,
		Uses: "flow",
		Lede: "set",
	}
}

var Type_ListSet = "list_set"

func (op *ListSet) MarshalJSON() (ret []byte, err error) {
	if jsonList, e := op.MarshalJSONList(); e != nil {
		err = e
	} else if jsonIndex, e := op.MarshalJSONIndex(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListSet,
			Value: map[string]json.RawMessage{
				"$LIST":  jsonList,
				"$INDEX": jsonIndex,
				"$FROM":  jsonFrom,
			},
		})
	}
	return
}

func (op *ListSet) MarshalJSONList() (ret []byte, err error) {
	// type override
	m := value.Text{op.List}
	ret, err = m.MarshalJSON()
	return
}

func (op *ListSet) MarshalJSONIndex() (ret []byte, err error) {
	if v, e := op.Index.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *ListSet) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

// ListSlice Create a new list from a section of another list.,Start is optional, if omitted slice starts at the first element.,If start is greater the length, an empty array is returned.,Slice doesnt include the ending index.,Negatives indices indicates an offset from the end.,When end is omitted, copy up to and including the last element;,and do the same if the end is greater than the length
type ListSlice struct {
	List  rt.Assignment `if:"label=_"`
	Start rt.NumberEval `if:"label=start,optional"`
	End   rt.NumberEval `if:"label=end,optional"`
}

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSlice,
		Uses: "flow",
		Lede: "slice",
	}
}

var Type_ListSlice = "list_slice"

func (op *ListSlice) MarshalJSON() (ret []byte, err error) {
	if jsonList, e := op.MarshalJSONList(); e != nil {
		err = e
	} else if jsonStart, e := op.MarshalJSONStart(); e != nil {
		err = e
	} else if jsonEnd, e := op.MarshalJSONEnd(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListSlice,
			Value: map[string]json.RawMessage{
				"$LIST":  jsonList,
				"$START": jsonStart,
				"$END":   jsonEnd,
			},
		})
	}
	return
}

func (op *ListSlice) MarshalJSONList() (ret []byte, err error) {
	if v, e := op.List.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *ListSlice) MarshalJSONStart() (ret []byte, err error) {
	if v, e := op.Start.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *ListSlice) MarshalJSONEnd() (ret []byte, err error) {
	if v, e := op.End.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
}

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSortNumbers,
		Uses: "flow",
		Lede: "sort",
	}
}

var Type_ListSortNumbers = "list_sort_numbers"

func (op *ListSortNumbers) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else if jsonByField, e := op.MarshalJSONByField(); e != nil {
		err = e
	} else if jsonDescending, e := op.MarshalJSONDescending(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListSortNumbers,
			Value: map[string]json.RawMessage{
				"$VAR":        jsonVar,
				"$BY_FIELD":   jsonByField,
				"$DESCENDING": jsonDescending,
			},
		})
	}
	return
}

func (op *ListSortNumbers) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

func (op *ListSortNumbers) MarshalJSONByField() (ret []byte, err error) {
	// type override
	m := value.Text{op.ByField}
	ret, err = m.MarshalJSON()
	return
}

func (op *ListSortNumbers) MarshalJSONDescending() (ret []byte, err error) {
	if v, e := op.Descending.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Var        value.VariableName `if:"label=_"`
	ByField    string             `if:"label=by_field,type=text"`
	Descending rt.BoolEval        `if:"label=descending,optional"`
	UsingCase  rt.BoolEval        `if:"label=using_case,optional"`
}

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSortText,
		Uses: "flow",
		Lede: "sort",
	}
}

var Type_ListSortText = "list_sort_text"

func (op *ListSortText) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else if jsonByField, e := op.MarshalJSONByField(); e != nil {
		err = e
	} else if jsonDescending, e := op.MarshalJSONDescending(); e != nil {
		err = e
	} else if jsonUsingCase, e := op.MarshalJSONUsingCase(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListSortText,
			Value: map[string]json.RawMessage{
				"$VAR":        jsonVar,
				"$BY_FIELD":   jsonByField,
				"$DESCENDING": jsonDescending,
				"$USING_CASE": jsonUsingCase,
			},
		})
	}
	return
}

func (op *ListSortText) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

func (op *ListSortText) MarshalJSONByField() (ret []byte, err error) {
	// type override
	m := value.Text{op.ByField}
	ret, err = m.MarshalJSON()
	return
}

func (op *ListSortText) MarshalJSONDescending() (ret []byte, err error) {
	if v, e := op.Descending.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *ListSortText) MarshalJSONUsingCase() (ret []byte, err error) {
	if v, e := op.UsingCase.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

// ListSortUsing Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortUsing struct {
	Var   value.VariableName `if:"label=_"`
	Using string             `if:"label=using,type=text"`
}

func (*ListSortUsing) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSortUsing,
		Uses: "flow",
		Lede: "sort",
	}
}

var Type_ListSortUsing = "list_sort_using"

func (op *ListSortUsing) MarshalJSON() (ret []byte, err error) {
	if jsonVar, e := op.MarshalJSONVar(); e != nil {
		err = e
	} else if jsonUsing, e := op.MarshalJSONUsing(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListSortUsing,
			Value: map[string]json.RawMessage{
				"$VAR":   jsonVar,
				"$USING": jsonUsing,
			},
		})
	}
	return
}

func (op *ListSortUsing) MarshalJSONVar() (ret []byte, err error) {
	ret, err = op.Var.MarshalJSON()
	return
}

func (op *ListSortUsing) MarshalJSONUsing() (ret []byte, err error) {
	// type override
	m := value.Text{op.Using}
	ret, err = m.MarshalJSON()
	return
}

const Type_ListSource = "list_source"

// ListSplice Modify a list by adding and removing elements. Note: the type of the elements being added must match the type of the list. Text cant be added to a list of numbers, numbers cant be added to a list of text. If the starting index is negative, it will begin that many elements from the end of the array. If list&#x27;s length + the start is less than 0, it will begin from index 0. If the remove count is missing, it removes all elements from the start to the end; if it is 0 or negative, no elements are removed.
type ListSplice struct {
	List   string        `if:"label=_,type=text"`
	Start  rt.NumberEval `if:"label=start"`
	Remove rt.NumberEval `if:"label=remove"`
	Insert rt.Assignment `if:"label=insert"`
}

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ListSplice,
		Uses: "flow",
		Lede: "splice",
	}
}

var Type_ListSplice = "list_splice"

func (op *ListSplice) MarshalJSON() (ret []byte, err error) {
	if jsonList, e := op.MarshalJSONList(); e != nil {
		err = e
	} else if jsonStart, e := op.MarshalJSONStart(); e != nil {
		err = e
	} else if jsonRemove, e := op.MarshalJSONRemove(); e != nil {
		err = e
	} else if jsonInsert, e := op.MarshalJSONInsert(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ListSplice,
			Value: map[string]json.RawMessage{
				"$LIST":   jsonList,
				"$START":  jsonStart,
				"$REMOVE": jsonRemove,
				"$INSERT": jsonInsert,
			},
		})
	}
	return
}

func (op *ListSplice) MarshalJSONList() (ret []byte, err error) {
	// type override
	m := value.Text{op.List}
	ret, err = m.MarshalJSON()
	return
}

func (op *ListSplice) MarshalJSONStart() (ret []byte, err error) {
	if v, e := op.Start.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *ListSplice) MarshalJSONRemove() (ret []byte, err error) {
	if v, e := op.Remove.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *ListSplice) MarshalJSONInsert() (ret []byte, err error) {
	if v, e := op.Insert.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

const Type_ListTarget = "list_target"

// PutEdge Add a value to a list
type PutEdge struct {
	From   rt.Assignment `if:"label=_"`
	Into   ListTarget    `if:"label=into"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
}

func (*PutEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PutEdge,
		Uses: "flow",
		Lede: "put",
	}
}

var Type_PutEdge = "put_edge"

func (op *PutEdge) MarshalJSON() (ret []byte, err error) {
	if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonInto, e := op.MarshalJSONInto(); e != nil {
		err = e
	} else if jsonAtEdge, e := op.MarshalJSONAtEdge(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PutEdge,
			Value: map[string]json.RawMessage{
				"$FROM":    jsonFrom,
				"$INTO":    jsonInto,
				"$AT_EDGE": jsonAtEdge,
			},
		})
	}
	return
}

func (op *PutEdge) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *PutEdge) MarshalJSONInto() (ret []byte, err error) {
	if v, e := op.Into.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListTarget,
			Value: v,
		})
	}
	return
}

func (op *PutEdge) MarshalJSONAtEdge() (ret []byte, err error) {
	if v, e := op.AtEdge.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

// PutIndex Replace one value in a list with another
type PutIndex struct {
	From    rt.Assignment `if:"label=_"`
	Into    ListTarget    `if:"label=into"`
	AtIndex rt.NumberEval `if:"label=at_index"`
}

func (*PutIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PutIndex,
		Uses: "flow",
		Lede: "put",
	}
}

var Type_PutIndex = "put_index"

func (op *PutIndex) MarshalJSON() (ret []byte, err error) {
	if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonInto, e := op.MarshalJSONInto(); e != nil {
		err = e
	} else if jsonAtIndex, e := op.MarshalJSONAtIndex(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PutIndex,
			Value: map[string]json.RawMessage{
				"$FROM":     jsonFrom,
				"$INTO":     jsonInto,
				"$AT_INDEX": jsonAtIndex,
			},
		})
	}
	return
}

func (op *PutIndex) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

func (op *PutIndex) MarshalJSONInto() (ret []byte, err error) {
	if v, e := op.Into.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_ListTarget,
			Value: v,
		})
	}
	return
}

func (op *PutIndex) MarshalJSONAtIndex() (ret []byte, err error) {
	if v, e := op.AtIndex.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// Range Generates a series of numbers r[i] &#x3D; (start + step*i) where i&gt;&#x3D;0.,Start and step default to 1, stop defaults to start;,the inputs are truncated to produce whole numbers;,a zero step returns an error.,A positive step ends the series when the returned value would exceed stop,while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
}

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Range,
		Uses: "flow",
	}
}

var Type_Range = "range"

func (op *Range) MarshalJSON() (ret []byte, err error) {
	if jsonTo, e := op.MarshalJSONTo(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else if jsonByStep, e := op.MarshalJSONByStep(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Range,
			Value: map[string]json.RawMessage{
				"$TO":      jsonTo,
				"$FROM":    jsonFrom,
				"$BY_STEP": jsonByStep,
			},
		})
	}
	return
}

func (op *Range) MarshalJSONTo() (ret []byte, err error) {
	if v, e := op.To.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *Range) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

func (op *Range) MarshalJSONByStep() (ret []byte, err error) {
	if v, e := op.ByStep.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

var Slots = []interface{}{
	(*ListIterator)(nil),
	(*ListSource)(nil),
	(*ListTarget)(nil),
}

var Slats = []composer.Composer{
	(*AsNum)(nil),
	(*AsRec)(nil),
	(*AsTxt)(nil),
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*FromNumList)(nil),
	(*FromRecList)(nil),
	(*FromTxtList)(nil),
	(*IntoNumList)(nil),
	(*IntoRecList)(nil),
	(*IntoTxtList)(nil),
	(*ListAt)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSet)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSortUsing)(nil),
	(*ListSplice)(nil),
	(*PutEdge)(nil),
	(*PutIndex)(nil),
	(*Range)(nil),
}
