// Code generated by "makeops"; edit at your own risk.
package list

import (
	"git.sr.ht/~ionous/tapestry/dl/composer"
	"git.sr.ht/~ionous/tapestry/dl/core"
	"git.sr.ht/~ionous/tapestry/dl/prim"
	"git.sr.ht/~ionous/tapestry/jsn"
	"git.sr.ht/~ionous/tapestry/rt"
	"github.com/ionous/errutil"
)

// EraseEdge Erase at edge: Remove one or more values from a list.
type EraseEdge struct {
	Target core.Address `if:"label=_"`
	AtEdge rt.BoolEval  `if:"label=at_front,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*EraseEdge)(nil)

func (*EraseEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseEdge_Type = "erase_edge"
const EraseEdge_Field_Target = "$TARGET"
const EraseEdge_Field_AtEdge = "$AT_EDGE"

func (op *EraseEdge) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Marshal(m, op)
}

type EraseEdge_Slice []EraseEdge

func (op *EraseEdge_Slice) GetType() string { return EraseEdge_Type }

func (op *EraseEdge_Slice) Marshal(m jsn.Marshaler) error {
	return EraseEdge_Repeats_Marshal(m, (*[]EraseEdge)(op))
}

func (op *EraseEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EraseEdge_Slice) SetSize(cnt int) {
	var els []EraseEdge
	if cnt >= 0 {
		els = make(EraseEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *EraseEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EraseEdge_Marshal(m, &(*op)[i])
}

func EraseEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseEdge) error {
	return jsn.RepeatBlock(m, (*EraseEdge_Slice)(vals))
}

func EraseEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EraseEdge) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EraseEdge_Repeats_Marshal(m, pv)
	}
	return
}

type EraseEdge_Flow struct{ ptr *EraseEdge }

func (n EraseEdge_Flow) GetType() string      { return EraseEdge_Type }
func (n EraseEdge_Flow) GetLede() string      { return "erase" }
func (n EraseEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n EraseEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EraseEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EraseEdge_Optional_Marshal(m jsn.Marshaler, pv **EraseEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseEdge_Marshal(m, *pv)
	} else if !enc {
		var v EraseEdge
		if err = EraseEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseEdge_Marshal(m jsn.Marshaler, val *EraseEdge) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EraseEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EraseEdge_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseEdge_Field_Target))
		}
		e1 := m.MarshalKey("at_front", EraseEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseEdge_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// EraseIndex Erase at index: Remove one or more values from a list.
type EraseIndex struct {
	Count   rt.NumberEval `if:"label=_"`
	Target  core.Address  `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	Markup  map[string]any
}

// User implemented slots:
var _ rt.Execute = (*EraseIndex)(nil)

func (*EraseIndex) Compose() composer.Spec {
	return composer.Spec{
		Name: EraseIndex_Type,
		Uses: composer.Type_Flow,
		Lede: "erase",
	}
}

const EraseIndex_Type = "erase_index"
const EraseIndex_Field_Count = "$COUNT"
const EraseIndex_Field_Target = "$TARGET"
const EraseIndex_Field_AtIndex = "$AT_INDEX"

func (op *EraseIndex) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Marshal(m, op)
}

type EraseIndex_Slice []EraseIndex

func (op *EraseIndex_Slice) GetType() string { return EraseIndex_Type }

func (op *EraseIndex_Slice) Marshal(m jsn.Marshaler) error {
	return EraseIndex_Repeats_Marshal(m, (*[]EraseIndex)(op))
}

func (op *EraseIndex_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *EraseIndex_Slice) SetSize(cnt int) {
	var els []EraseIndex
	if cnt >= 0 {
		els = make(EraseIndex_Slice, cnt)
	}
	(*op) = els
}

func (op *EraseIndex_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return EraseIndex_Marshal(m, &(*op)[i])
}

func EraseIndex_Repeats_Marshal(m jsn.Marshaler, vals *[]EraseIndex) error {
	return jsn.RepeatBlock(m, (*EraseIndex_Slice)(vals))
}

func EraseIndex_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]EraseIndex) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = EraseIndex_Repeats_Marshal(m, pv)
	}
	return
}

type EraseIndex_Flow struct{ ptr *EraseIndex }

func (n EraseIndex_Flow) GetType() string      { return EraseIndex_Type }
func (n EraseIndex_Flow) GetLede() string      { return "erase" }
func (n EraseIndex_Flow) GetFlow() interface{} { return n.ptr }
func (n EraseIndex_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*EraseIndex); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func EraseIndex_Optional_Marshal(m jsn.Marshaler, pv **EraseIndex) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = EraseIndex_Marshal(m, *pv)
	} else if !enc {
		var v EraseIndex
		if err = EraseIndex_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func EraseIndex_Marshal(m jsn.Marshaler, val *EraseIndex) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(EraseIndex_Flow{val}); err == nil {
		e0 := m.MarshalKey("", EraseIndex_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", EraseIndex_Field_Count))
		}
		e1 := m.MarshalKey("from", EraseIndex_Field_Target)
		if e1 == nil {
			e1 = core.Address_Marshal(m, &val.Target)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", EraseIndex_Field_Target))
		}
		e2 := m.MarshalKey("at_index", EraseIndex_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", EraseIndex_Field_AtIndex))
		}
		m.EndBlock()
	}
	return
}

// Erasing Erase elements from the front or back of a list.
// Runs a pattern with a list containing the erased values.
// If nothing was erased, the pattern will be called with an empty list.
type Erasing struct {
	Count   rt.NumberEval `if:"label=_"`
	Target  core.Address  `if:"label=from"`
	AtIndex rt.NumberEval `if:"label=at_index"`
	As      string        `if:"label=as,type=text"`
	Does    []rt.Execute  `if:"label=does"`
	Markup  map[string]any
}

// User implemented slots:
var _ rt.Execute = (*Erasing)(nil)

func (*Erasing) Compose() composer.Spec {
	return composer.Spec{
		Name: Erasing_Type,
		Uses: composer.Type_Flow,
	}
}

const Erasing_Type = "erasing"
const Erasing_Field_Count = "$COUNT"
const Erasing_Field_Target = "$TARGET"
const Erasing_Field_AtIndex = "$AT_INDEX"
const Erasing_Field_As = "$AS"
const Erasing_Field_Does = "$DOES"

func (op *Erasing) Marshal(m jsn.Marshaler) error {
	return Erasing_Marshal(m, op)
}

type Erasing_Slice []Erasing

func (op *Erasing_Slice) GetType() string { return Erasing_Type }

func (op *Erasing_Slice) Marshal(m jsn.Marshaler) error {
	return Erasing_Repeats_Marshal(m, (*[]Erasing)(op))
}

func (op *Erasing_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Erasing_Slice) SetSize(cnt int) {
	var els []Erasing
	if cnt >= 0 {
		els = make(Erasing_Slice, cnt)
	}
	(*op) = els
}

func (op *Erasing_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Erasing_Marshal(m, &(*op)[i])
}

func Erasing_Repeats_Marshal(m jsn.Marshaler, vals *[]Erasing) error {
	return jsn.RepeatBlock(m, (*Erasing_Slice)(vals))
}

func Erasing_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Erasing) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Erasing_Repeats_Marshal(m, pv)
	}
	return
}

type Erasing_Flow struct{ ptr *Erasing }

func (n Erasing_Flow) GetType() string      { return Erasing_Type }
func (n Erasing_Flow) GetLede() string      { return Erasing_Type }
func (n Erasing_Flow) GetFlow() interface{} { return n.ptr }
func (n Erasing_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Erasing); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Erasing_Optional_Marshal(m jsn.Marshaler, pv **Erasing) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Erasing_Marshal(m, *pv)
	} else if !enc {
		var v Erasing
		if err = Erasing_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Erasing_Marshal(m jsn.Marshaler, val *Erasing) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Erasing_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Erasing_Field_Count)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.Count)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Erasing_Field_Count))
		}
		e1 := m.MarshalKey("from", Erasing_Field_Target)
		if e1 == nil {
			e1 = core.Address_Marshal(m, &val.Target)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Erasing_Field_Target))
		}
		e2 := m.MarshalKey("at_index", Erasing_Field_AtIndex)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.AtIndex)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Erasing_Field_AtIndex))
		}
		e3 := m.MarshalKey("as", Erasing_Field_As)
		if e3 == nil {
			e3 = prim.Text_Unboxed_Marshal(m, &val.As)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", Erasing_Field_As))
		}
		e4 := m.MarshalKey("does", Erasing_Field_Does)
		if e4 == nil {
			e4 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", Erasing_Field_Does))
		}
		m.EndBlock()
	}
	return
}

// ErasingEdge Erase one element from the front or back of a list. Runs an activity with a list containing the erased values; the list can be empty if nothing was erased.
type ErasingEdge struct {
	Target core.Address  `if:"label=_"`
	AtEdge rt.BoolEval   `if:"label=at_front,optional"`
	As     string        `if:"label=as,type=text"`
	Does   []rt.Execute  `if:"label=does"`
	Else   core.Brancher `if:"label=else,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ErasingEdge)(nil)

func (*ErasingEdge) Compose() composer.Spec {
	return composer.Spec{
		Name: ErasingEdge_Type,
		Uses: composer.Type_Flow,
		Lede: "erasing",
	}
}

const ErasingEdge_Type = "erasing_edge"
const ErasingEdge_Field_Target = "$TARGET"
const ErasingEdge_Field_AtEdge = "$AT_EDGE"
const ErasingEdge_Field_As = "$AS"
const ErasingEdge_Field_Does = "$DOES"
const ErasingEdge_Field_Else = "$ELSE"

func (op *ErasingEdge) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Marshal(m, op)
}

type ErasingEdge_Slice []ErasingEdge

func (op *ErasingEdge_Slice) GetType() string { return ErasingEdge_Type }

func (op *ErasingEdge_Slice) Marshal(m jsn.Marshaler) error {
	return ErasingEdge_Repeats_Marshal(m, (*[]ErasingEdge)(op))
}

func (op *ErasingEdge_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ErasingEdge_Slice) SetSize(cnt int) {
	var els []ErasingEdge
	if cnt >= 0 {
		els = make(ErasingEdge_Slice, cnt)
	}
	(*op) = els
}

func (op *ErasingEdge_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ErasingEdge_Marshal(m, &(*op)[i])
}

func ErasingEdge_Repeats_Marshal(m jsn.Marshaler, vals *[]ErasingEdge) error {
	return jsn.RepeatBlock(m, (*ErasingEdge_Slice)(vals))
}

func ErasingEdge_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ErasingEdge) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ErasingEdge_Repeats_Marshal(m, pv)
	}
	return
}

type ErasingEdge_Flow struct{ ptr *ErasingEdge }

func (n ErasingEdge_Flow) GetType() string      { return ErasingEdge_Type }
func (n ErasingEdge_Flow) GetLede() string      { return "erasing" }
func (n ErasingEdge_Flow) GetFlow() interface{} { return n.ptr }
func (n ErasingEdge_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ErasingEdge); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ErasingEdge_Optional_Marshal(m jsn.Marshaler, pv **ErasingEdge) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ErasingEdge_Marshal(m, *pv)
	} else if !enc {
		var v ErasingEdge
		if err = ErasingEdge_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ErasingEdge_Marshal(m jsn.Marshaler, val *ErasingEdge) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ErasingEdge_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ErasingEdge_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ErasingEdge_Field_Target))
		}
		e1 := m.MarshalKey("at_front", ErasingEdge_Field_AtEdge)
		if e1 == nil {
			e1 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ErasingEdge_Field_AtEdge))
		}
		e2 := m.MarshalKey("as", ErasingEdge_Field_As)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.As)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ErasingEdge_Field_As))
		}
		e3 := m.MarshalKey("does", ErasingEdge_Field_Does)
		if e3 == nil {
			e3 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ErasingEdge_Field_Does))
		}
		e4 := m.MarshalKey("else", ErasingEdge_Field_Else)
		if e4 == nil {
			e4 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e4 != nil && e4 != jsn.Missing {
			m.Error(errutil.New(e4, "in flow at", ErasingEdge_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// ListEach Loops over the elements in the passed list, or runs the 'else' activity if empty.
type ListEach struct {
	List   core.Assignment `if:"label=across"`
	As     string          `if:"label=as,type=text"`
	Does   []rt.Execute    `if:"label=does"`
	Else   core.Brancher   `if:"label=else,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListEach)(nil)

func (*ListEach) Compose() composer.Spec {
	return composer.Spec{
		Name: ListEach_Type,
		Uses: composer.Type_Flow,
		Lede: "repeating",
	}
}

const ListEach_Type = "list_each"
const ListEach_Field_List = "$LIST"
const ListEach_Field_As = "$AS"
const ListEach_Field_Does = "$DOES"
const ListEach_Field_Else = "$ELSE"

func (op *ListEach) Marshal(m jsn.Marshaler) error {
	return ListEach_Marshal(m, op)
}

type ListEach_Slice []ListEach

func (op *ListEach_Slice) GetType() string { return ListEach_Type }

func (op *ListEach_Slice) Marshal(m jsn.Marshaler) error {
	return ListEach_Repeats_Marshal(m, (*[]ListEach)(op))
}

func (op *ListEach_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListEach_Slice) SetSize(cnt int) {
	var els []ListEach
	if cnt >= 0 {
		els = make(ListEach_Slice, cnt)
	}
	(*op) = els
}

func (op *ListEach_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListEach_Marshal(m, &(*op)[i])
}

func ListEach_Repeats_Marshal(m jsn.Marshaler, vals *[]ListEach) error {
	return jsn.RepeatBlock(m, (*ListEach_Slice)(vals))
}

func ListEach_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListEach) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListEach_Repeats_Marshal(m, pv)
	}
	return
}

type ListEach_Flow struct{ ptr *ListEach }

func (n ListEach_Flow) GetType() string      { return ListEach_Type }
func (n ListEach_Flow) GetLede() string      { return "repeating" }
func (n ListEach_Flow) GetFlow() interface{} { return n.ptr }
func (n ListEach_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListEach); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListEach_Optional_Marshal(m jsn.Marshaler, pv **ListEach) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListEach_Marshal(m, *pv)
	} else if !enc {
		var v ListEach
		if err = ListEach_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListEach_Marshal(m jsn.Marshaler, val *ListEach) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListEach_Flow{val}); err == nil {
		e0 := m.MarshalKey("across", ListEach_Field_List)
		if e0 == nil {
			e0 = core.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListEach_Field_List))
		}
		e1 := m.MarshalKey("as", ListEach_Field_As)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.As)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListEach_Field_As))
		}
		e2 := m.MarshalKey("does", ListEach_Field_Does)
		if e2 == nil {
			e2 = rt.Execute_Repeats_Marshal(m, &val.Does)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListEach_Field_Does))
		}
		e3 := m.MarshalKey("else", ListEach_Field_Else)
		if e3 == nil {
			e3 = core.Brancher_Optional_Marshal(m, &val.Else)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListEach_Field_Else))
		}
		m.EndBlock()
	}
	return
}

// ListFind Search a list for a specific value.
type ListFind struct {
	Value  core.Assignment `if:"label=_"`
	List   core.Assignment `if:"label=in_list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.BoolEval = (*ListFind)(nil)
var _ rt.NumberEval = (*ListFind)(nil)

func (*ListFind) Compose() composer.Spec {
	return composer.Spec{
		Name: ListFind_Type,
		Uses: composer.Type_Flow,
		Lede: "find",
	}
}

const ListFind_Type = "list_find"
const ListFind_Field_Value = "$VALUE"
const ListFind_Field_List = "$LIST"

func (op *ListFind) Marshal(m jsn.Marshaler) error {
	return ListFind_Marshal(m, op)
}

type ListFind_Slice []ListFind

func (op *ListFind_Slice) GetType() string { return ListFind_Type }

func (op *ListFind_Slice) Marshal(m jsn.Marshaler) error {
	return ListFind_Repeats_Marshal(m, (*[]ListFind)(op))
}

func (op *ListFind_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListFind_Slice) SetSize(cnt int) {
	var els []ListFind
	if cnt >= 0 {
		els = make(ListFind_Slice, cnt)
	}
	(*op) = els
}

func (op *ListFind_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListFind_Marshal(m, &(*op)[i])
}

func ListFind_Repeats_Marshal(m jsn.Marshaler, vals *[]ListFind) error {
	return jsn.RepeatBlock(m, (*ListFind_Slice)(vals))
}

func ListFind_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListFind) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListFind_Repeats_Marshal(m, pv)
	}
	return
}

type ListFind_Flow struct{ ptr *ListFind }

func (n ListFind_Flow) GetType() string      { return ListFind_Type }
func (n ListFind_Flow) GetLede() string      { return "find" }
func (n ListFind_Flow) GetFlow() interface{} { return n.ptr }
func (n ListFind_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListFind); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListFind_Optional_Marshal(m jsn.Marshaler, pv **ListFind) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListFind_Marshal(m, *pv)
	} else if !enc {
		var v ListFind
		if err = ListFind_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListFind_Marshal(m jsn.Marshaler, val *ListFind) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListFind_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListFind_Field_Value)
		if e0 == nil {
			e0 = core.Assignment_Marshal(m, &val.Value)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListFind_Field_Value))
		}
		e1 := m.MarshalKey("in_list", ListFind_Field_List)
		if e1 == nil {
			e1 = core.Assignment_Marshal(m, &val.List)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListFind_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListGather Transform the values from a list.
// The named pattern gets with with two parameters for each value in the list:
// 'in' as each value from the list, and 'out' as the var passed to the gather.
type ListGather struct {
	Target core.Address    `if:"label=_"`
	From   core.Assignment `if:"label=from"`
	Using  string          `if:"label=using,type=text"`
	Markup map[string]any
}

func (*ListGather) Compose() composer.Spec {
	return composer.Spec{
		Name: ListGather_Type,
		Uses: composer.Type_Flow,
		Lede: "gather",
	}
}

const ListGather_Type = "list_gather"
const ListGather_Field_Target = "$TARGET"
const ListGather_Field_From = "$FROM"
const ListGather_Field_Using = "$USING"

func (op *ListGather) Marshal(m jsn.Marshaler) error {
	return ListGather_Marshal(m, op)
}

type ListGather_Slice []ListGather

func (op *ListGather_Slice) GetType() string { return ListGather_Type }

func (op *ListGather_Slice) Marshal(m jsn.Marshaler) error {
	return ListGather_Repeats_Marshal(m, (*[]ListGather)(op))
}

func (op *ListGather_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListGather_Slice) SetSize(cnt int) {
	var els []ListGather
	if cnt >= 0 {
		els = make(ListGather_Slice, cnt)
	}
	(*op) = els
}

func (op *ListGather_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListGather_Marshal(m, &(*op)[i])
}

func ListGather_Repeats_Marshal(m jsn.Marshaler, vals *[]ListGather) error {
	return jsn.RepeatBlock(m, (*ListGather_Slice)(vals))
}

func ListGather_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListGather) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListGather_Repeats_Marshal(m, pv)
	}
	return
}

type ListGather_Flow struct{ ptr *ListGather }

func (n ListGather_Flow) GetType() string      { return ListGather_Type }
func (n ListGather_Flow) GetLede() string      { return "gather" }
func (n ListGather_Flow) GetFlow() interface{} { return n.ptr }
func (n ListGather_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListGather); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListGather_Optional_Marshal(m jsn.Marshaler, pv **ListGather) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListGather_Marshal(m, *pv)
	} else if !enc {
		var v ListGather
		if err = ListGather_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListGather_Marshal(m jsn.Marshaler, val *ListGather) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListGather_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListGather_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListGather_Field_Target))
		}
		e1 := m.MarshalKey("from", ListGather_Field_From)
		if e1 == nil {
			e1 = core.Assignment_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListGather_Field_From))
		}
		e2 := m.MarshalKey("using", ListGather_Field_Using)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.Using)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListGather_Field_Using))
		}
		m.EndBlock()
	}
	return
}

// ListLen Determines the number of values in a list.
type ListLen struct {
	List   core.Assignment `if:"label=_"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumberEval = (*ListLen)(nil)

func (*ListLen) Compose() composer.Spec {
	return composer.Spec{
		Name: ListLen_Type,
		Uses: composer.Type_Flow,
		Lede: "len",
	}
}

const ListLen_Type = "list_len"
const ListLen_Field_List = "$LIST"

func (op *ListLen) Marshal(m jsn.Marshaler) error {
	return ListLen_Marshal(m, op)
}

type ListLen_Slice []ListLen

func (op *ListLen_Slice) GetType() string { return ListLen_Type }

func (op *ListLen_Slice) Marshal(m jsn.Marshaler) error {
	return ListLen_Repeats_Marshal(m, (*[]ListLen)(op))
}

func (op *ListLen_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListLen_Slice) SetSize(cnt int) {
	var els []ListLen
	if cnt >= 0 {
		els = make(ListLen_Slice, cnt)
	}
	(*op) = els
}

func (op *ListLen_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListLen_Marshal(m, &(*op)[i])
}

func ListLen_Repeats_Marshal(m jsn.Marshaler, vals *[]ListLen) error {
	return jsn.RepeatBlock(m, (*ListLen_Slice)(vals))
}

func ListLen_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListLen) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListLen_Repeats_Marshal(m, pv)
	}
	return
}

type ListLen_Flow struct{ ptr *ListLen }

func (n ListLen_Flow) GetType() string      { return ListLen_Type }
func (n ListLen_Flow) GetLede() string      { return "len" }
func (n ListLen_Flow) GetFlow() interface{} { return n.ptr }
func (n ListLen_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListLen); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListLen_Optional_Marshal(m jsn.Marshaler, pv **ListLen) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListLen_Marshal(m, *pv)
	} else if !enc {
		var v ListLen
		if err = ListLen_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListLen_Marshal(m jsn.Marshaler, val *ListLen) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListLen_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListLen_Field_List)
		if e0 == nil {
			e0 = core.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListLen_Field_List))
		}
		m.EndBlock()
	}
	return
}

// ListMap Transform the values from one list and place the results in another list.
// The designated pattern is called with each value from the 'from list', one value at a time.
type ListMap struct {
	Target       core.Address    `if:"label=_"`
	List         core.Assignment `if:"label=from_list"`
	UsingPattern string          `if:"label=using,type=text"`
	Markup       map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListMap)(nil)

func (*ListMap) Compose() composer.Spec {
	return composer.Spec{
		Name: ListMap_Type,
		Uses: composer.Type_Flow,
		Lede: "map",
	}
}

const ListMap_Type = "list_map"
const ListMap_Field_Target = "$TARGET"
const ListMap_Field_List = "$LIST"
const ListMap_Field_UsingPattern = "$USING_PATTERN"

func (op *ListMap) Marshal(m jsn.Marshaler) error {
	return ListMap_Marshal(m, op)
}

type ListMap_Slice []ListMap

func (op *ListMap_Slice) GetType() string { return ListMap_Type }

func (op *ListMap_Slice) Marshal(m jsn.Marshaler) error {
	return ListMap_Repeats_Marshal(m, (*[]ListMap)(op))
}

func (op *ListMap_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListMap_Slice) SetSize(cnt int) {
	var els []ListMap
	if cnt >= 0 {
		els = make(ListMap_Slice, cnt)
	}
	(*op) = els
}

func (op *ListMap_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListMap_Marshal(m, &(*op)[i])
}

func ListMap_Repeats_Marshal(m jsn.Marshaler, vals *[]ListMap) error {
	return jsn.RepeatBlock(m, (*ListMap_Slice)(vals))
}

func ListMap_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListMap) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListMap_Repeats_Marshal(m, pv)
	}
	return
}

type ListMap_Flow struct{ ptr *ListMap }

func (n ListMap_Flow) GetType() string      { return ListMap_Type }
func (n ListMap_Flow) GetLede() string      { return "map" }
func (n ListMap_Flow) GetFlow() interface{} { return n.ptr }
func (n ListMap_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListMap); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListMap_Optional_Marshal(m jsn.Marshaler, pv **ListMap) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListMap_Marshal(m, *pv)
	} else if !enc {
		var v ListMap
		if err = ListMap_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListMap_Marshal(m jsn.Marshaler, val *ListMap) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListMap_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListMap_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListMap_Field_Target))
		}
		e1 := m.MarshalKey("from_list", ListMap_Field_List)
		if e1 == nil {
			e1 = core.Assignment_Marshal(m, &val.List)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListMap_Field_List))
		}
		e2 := m.MarshalKey("using", ListMap_Field_UsingPattern)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.UsingPattern)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListMap_Field_UsingPattern))
		}
		m.EndBlock()
	}
	return
}

// ListPush Add a value to a list.
type ListPush struct {
	Value  core.Assignment `if:"label=_"`
	Target core.Address    `if:"label=into"`
	AtEdge rt.BoolEval     `if:"label=at_front,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListPush)(nil)

func (*ListPush) Compose() composer.Spec {
	return composer.Spec{
		Name: ListPush_Type,
		Uses: composer.Type_Flow,
		Lede: "push",
	}
}

const ListPush_Type = "list_push"
const ListPush_Field_Value = "$VALUE"
const ListPush_Field_Target = "$TARGET"
const ListPush_Field_AtEdge = "$AT_EDGE"

func (op *ListPush) Marshal(m jsn.Marshaler) error {
	return ListPush_Marshal(m, op)
}

type ListPush_Slice []ListPush

func (op *ListPush_Slice) GetType() string { return ListPush_Type }

func (op *ListPush_Slice) Marshal(m jsn.Marshaler) error {
	return ListPush_Repeats_Marshal(m, (*[]ListPush)(op))
}

func (op *ListPush_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListPush_Slice) SetSize(cnt int) {
	var els []ListPush
	if cnt >= 0 {
		els = make(ListPush_Slice, cnt)
	}
	(*op) = els
}

func (op *ListPush_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListPush_Marshal(m, &(*op)[i])
}

func ListPush_Repeats_Marshal(m jsn.Marshaler, vals *[]ListPush) error {
	return jsn.RepeatBlock(m, (*ListPush_Slice)(vals))
}

func ListPush_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListPush) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListPush_Repeats_Marshal(m, pv)
	}
	return
}

type ListPush_Flow struct{ ptr *ListPush }

func (n ListPush_Flow) GetType() string      { return ListPush_Type }
func (n ListPush_Flow) GetLede() string      { return "push" }
func (n ListPush_Flow) GetFlow() interface{} { return n.ptr }
func (n ListPush_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListPush); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListPush_Optional_Marshal(m jsn.Marshaler, pv **ListPush) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListPush_Marshal(m, *pv)
	} else if !enc {
		var v ListPush
		if err = ListPush_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListPush_Marshal(m jsn.Marshaler, val *ListPush) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListPush_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListPush_Field_Value)
		if e0 == nil {
			e0 = core.Assignment_Marshal(m, &val.Value)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListPush_Field_Value))
		}
		e1 := m.MarshalKey("into", ListPush_Field_Target)
		if e1 == nil {
			e1 = core.Address_Marshal(m, &val.Target)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListPush_Field_Target))
		}
		e2 := m.MarshalKey("at_front", ListPush_Field_AtEdge)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.AtEdge)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListPush_Field_AtEdge))
		}
		m.EndBlock()
	}
	return
}

// ListReduce Combine all of the values in a list with the targeted value.
// The designated pattern is called with two parameters:
// 'in' ( each element of the list ) and 'out' ( the target ).
type ListReduce struct {
	Target       core.Address    `if:"label=into"`
	List         core.Assignment `if:"label=from_list"`
	UsingPattern string          `if:"label=using,type=text"`
	Markup       map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListReduce)(nil)

func (*ListReduce) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReduce_Type,
		Uses: composer.Type_Flow,
		Lede: "reduce",
	}
}

const ListReduce_Type = "list_reduce"
const ListReduce_Field_Target = "$TARGET"
const ListReduce_Field_List = "$LIST"
const ListReduce_Field_UsingPattern = "$USING_PATTERN"

func (op *ListReduce) Marshal(m jsn.Marshaler) error {
	return ListReduce_Marshal(m, op)
}

type ListReduce_Slice []ListReduce

func (op *ListReduce_Slice) GetType() string { return ListReduce_Type }

func (op *ListReduce_Slice) Marshal(m jsn.Marshaler) error {
	return ListReduce_Repeats_Marshal(m, (*[]ListReduce)(op))
}

func (op *ListReduce_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListReduce_Slice) SetSize(cnt int) {
	var els []ListReduce
	if cnt >= 0 {
		els = make(ListReduce_Slice, cnt)
	}
	(*op) = els
}

func (op *ListReduce_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListReduce_Marshal(m, &(*op)[i])
}

func ListReduce_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReduce) error {
	return jsn.RepeatBlock(m, (*ListReduce_Slice)(vals))
}

func ListReduce_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListReduce) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListReduce_Repeats_Marshal(m, pv)
	}
	return
}

type ListReduce_Flow struct{ ptr *ListReduce }

func (n ListReduce_Flow) GetType() string      { return ListReduce_Type }
func (n ListReduce_Flow) GetLede() string      { return "reduce" }
func (n ListReduce_Flow) GetFlow() interface{} { return n.ptr }
func (n ListReduce_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListReduce); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListReduce_Optional_Marshal(m jsn.Marshaler, pv **ListReduce) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReduce_Marshal(m, *pv)
	} else if !enc {
		var v ListReduce
		if err = ListReduce_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReduce_Marshal(m jsn.Marshaler, val *ListReduce) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListReduce_Flow{val}); err == nil {
		e0 := m.MarshalKey("into", ListReduce_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReduce_Field_Target))
		}
		e1 := m.MarshalKey("from_list", ListReduce_Field_List)
		if e1 == nil {
			e1 = core.Assignment_Marshal(m, &val.List)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListReduce_Field_List))
		}
		e2 := m.MarshalKey("using", ListReduce_Field_UsingPattern)
		if e2 == nil {
			e2 = prim.Text_Unboxed_Marshal(m, &val.UsingPattern)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListReduce_Field_UsingPattern))
		}
		m.EndBlock()
	}
	return
}

// ListReverse Reverse a list.
type ListReverse struct {
	Target core.Address `if:"label=list"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListReverse)(nil)

func (*ListReverse) Compose() composer.Spec {
	return composer.Spec{
		Name: ListReverse_Type,
		Uses: composer.Type_Flow,
		Lede: "reverse",
	}
}

const ListReverse_Type = "list_reverse"
const ListReverse_Field_Target = "$TARGET"

func (op *ListReverse) Marshal(m jsn.Marshaler) error {
	return ListReverse_Marshal(m, op)
}

type ListReverse_Slice []ListReverse

func (op *ListReverse_Slice) GetType() string { return ListReverse_Type }

func (op *ListReverse_Slice) Marshal(m jsn.Marshaler) error {
	return ListReverse_Repeats_Marshal(m, (*[]ListReverse)(op))
}

func (op *ListReverse_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListReverse_Slice) SetSize(cnt int) {
	var els []ListReverse
	if cnt >= 0 {
		els = make(ListReverse_Slice, cnt)
	}
	(*op) = els
}

func (op *ListReverse_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListReverse_Marshal(m, &(*op)[i])
}

func ListReverse_Repeats_Marshal(m jsn.Marshaler, vals *[]ListReverse) error {
	return jsn.RepeatBlock(m, (*ListReverse_Slice)(vals))
}

func ListReverse_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListReverse) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListReverse_Repeats_Marshal(m, pv)
	}
	return
}

type ListReverse_Flow struct{ ptr *ListReverse }

func (n ListReverse_Flow) GetType() string      { return ListReverse_Type }
func (n ListReverse_Flow) GetLede() string      { return "reverse" }
func (n ListReverse_Flow) GetFlow() interface{} { return n.ptr }
func (n ListReverse_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListReverse); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListReverse_Optional_Marshal(m jsn.Marshaler, pv **ListReverse) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListReverse_Marshal(m, *pv)
	} else if !enc {
		var v ListReverse
		if err = ListReverse_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListReverse_Marshal(m jsn.Marshaler, val *ListReverse) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListReverse_Flow{val}); err == nil {
		e0 := m.MarshalKey("list", ListReverse_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListReverse_Field_Target))
		}
		m.EndBlock()
	}
	return
}

// ListSlice Create a new list from a section of another list.
// Start is optional, if omitted slice starts at the first element.
// If start is greater the length, an empty array is returned.
// Slice doesnt include the ending index.
// Negatives indices indicates an offset from the end.
// When end is omitted, copy up to and including the last element;
// and do the same if the end is greater than the length
type ListSlice struct {
	List   core.Assignment `if:"label=_"`
	Start  rt.NumberEval   `if:"label=start,optional"`
	End    rt.NumberEval   `if:"label=end,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumListEval = (*ListSlice)(nil)
var _ rt.TextListEval = (*ListSlice)(nil)
var _ rt.RecordListEval = (*ListSlice)(nil)

func (*ListSlice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSlice_Type,
		Uses: composer.Type_Flow,
		Lede: "slice",
	}
}

const ListSlice_Type = "list_slice"
const ListSlice_Field_List = "$LIST"
const ListSlice_Field_Start = "$START"
const ListSlice_Field_End = "$END"

func (op *ListSlice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Marshal(m, op)
}

type ListSlice_Slice []ListSlice

func (op *ListSlice_Slice) GetType() string { return ListSlice_Type }

func (op *ListSlice_Slice) Marshal(m jsn.Marshaler) error {
	return ListSlice_Repeats_Marshal(m, (*[]ListSlice)(op))
}

func (op *ListSlice_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSlice_Slice) SetSize(cnt int) {
	var els []ListSlice
	if cnt >= 0 {
		els = make(ListSlice_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSlice_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSlice_Marshal(m, &(*op)[i])
}

func ListSlice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSlice) error {
	return jsn.RepeatBlock(m, (*ListSlice_Slice)(vals))
}

func ListSlice_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSlice) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSlice_Repeats_Marshal(m, pv)
	}
	return
}

type ListSlice_Flow struct{ ptr *ListSlice }

func (n ListSlice_Flow) GetType() string      { return ListSlice_Type }
func (n ListSlice_Flow) GetLede() string      { return "slice" }
func (n ListSlice_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSlice_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSlice); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSlice_Optional_Marshal(m jsn.Marshaler, pv **ListSlice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSlice_Marshal(m, *pv)
	} else if !enc {
		var v ListSlice
		if err = ListSlice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSlice_Marshal(m jsn.Marshaler, val *ListSlice) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSlice_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSlice_Field_List)
		if e0 == nil {
			e0 = core.Assignment_Marshal(m, &val.List)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSlice_Field_List))
		}
		e1 := m.MarshalKey("start", ListSlice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSlice_Field_Start))
		}
		e2 := m.MarshalKey("end", ListSlice_Field_End)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.End)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSlice_Field_End))
		}
		m.EndBlock()
	}
	return
}

// ListSortNumbers
type ListSortNumbers struct {
	Target     core.Address `if:"label=_"`
	ByField    string       `if:"label=by_field,type=text"`
	Descending rt.BoolEval  `if:"label=descending,optional"`
	Markup     map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSortNumbers)(nil)

func (*ListSortNumbers) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortNumbers_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_numbers",
	}
}

const ListSortNumbers_Type = "list_sort_numbers"
const ListSortNumbers_Field_Target = "$TARGET"
const ListSortNumbers_Field_ByField = "$BY_FIELD"
const ListSortNumbers_Field_Descending = "$DESCENDING"

func (op *ListSortNumbers) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Marshal(m, op)
}

type ListSortNumbers_Slice []ListSortNumbers

func (op *ListSortNumbers_Slice) GetType() string { return ListSortNumbers_Type }

func (op *ListSortNumbers_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortNumbers_Repeats_Marshal(m, (*[]ListSortNumbers)(op))
}

func (op *ListSortNumbers_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortNumbers_Slice) SetSize(cnt int) {
	var els []ListSortNumbers
	if cnt >= 0 {
		els = make(ListSortNumbers_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortNumbers_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortNumbers_Marshal(m, &(*op)[i])
}

func ListSortNumbers_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortNumbers) error {
	return jsn.RepeatBlock(m, (*ListSortNumbers_Slice)(vals))
}

func ListSortNumbers_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortNumbers) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSortNumbers_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortNumbers_Flow struct{ ptr *ListSortNumbers }

func (n ListSortNumbers_Flow) GetType() string      { return ListSortNumbers_Type }
func (n ListSortNumbers_Flow) GetLede() string      { return "sort_numbers" }
func (n ListSortNumbers_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortNumbers_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortNumbers); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortNumbers_Optional_Marshal(m jsn.Marshaler, pv **ListSortNumbers) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortNumbers_Marshal(m, *pv)
	} else if !enc {
		var v ListSortNumbers
		if err = ListSortNumbers_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortNumbers_Marshal(m jsn.Marshaler, val *ListSortNumbers) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSortNumbers_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortNumbers_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortNumbers_Field_Target))
		}
		e1 := m.MarshalKey("by_field", ListSortNumbers_Field_ByField)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortNumbers_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortNumbers_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortNumbers_Field_Descending))
		}
		m.EndBlock()
	}
	return
}

// ListSortText Rearrange the elements in the named list by using the designated pattern to test pairs of elements.
type ListSortText struct {
	Target     core.Address `if:"label=_"`
	ByField    string       `if:"label=by_field,type=text"`
	Descending rt.BoolEval  `if:"label=descending,optional"`
	UsingCase  rt.BoolEval  `if:"label=using_case,optional"`
	Markup     map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSortText)(nil)

func (*ListSortText) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSortText_Type,
		Uses: composer.Type_Flow,
		Lede: "sort_texts",
	}
}

const ListSortText_Type = "list_sort_text"
const ListSortText_Field_Target = "$TARGET"
const ListSortText_Field_ByField = "$BY_FIELD"
const ListSortText_Field_Descending = "$DESCENDING"
const ListSortText_Field_UsingCase = "$USING_CASE"

func (op *ListSortText) Marshal(m jsn.Marshaler) error {
	return ListSortText_Marshal(m, op)
}

type ListSortText_Slice []ListSortText

func (op *ListSortText_Slice) GetType() string { return ListSortText_Type }

func (op *ListSortText_Slice) Marshal(m jsn.Marshaler) error {
	return ListSortText_Repeats_Marshal(m, (*[]ListSortText)(op))
}

func (op *ListSortText_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSortText_Slice) SetSize(cnt int) {
	var els []ListSortText
	if cnt >= 0 {
		els = make(ListSortText_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSortText_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSortText_Marshal(m, &(*op)[i])
}

func ListSortText_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSortText) error {
	return jsn.RepeatBlock(m, (*ListSortText_Slice)(vals))
}

func ListSortText_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSortText) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSortText_Repeats_Marshal(m, pv)
	}
	return
}

type ListSortText_Flow struct{ ptr *ListSortText }

func (n ListSortText_Flow) GetType() string      { return ListSortText_Type }
func (n ListSortText_Flow) GetLede() string      { return "sort_texts" }
func (n ListSortText_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSortText_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSortText); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSortText_Optional_Marshal(m jsn.Marshaler, pv **ListSortText) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSortText_Marshal(m, *pv)
	} else if !enc {
		var v ListSortText
		if err = ListSortText_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSortText_Marshal(m jsn.Marshaler, val *ListSortText) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSortText_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSortText_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSortText_Field_Target))
		}
		e1 := m.MarshalKey("by_field", ListSortText_Field_ByField)
		if e1 == nil {
			e1 = prim.Text_Unboxed_Marshal(m, &val.ByField)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSortText_Field_ByField))
		}
		e2 := m.MarshalKey("descending", ListSortText_Field_Descending)
		if e2 == nil {
			e2 = rt.BoolEval_Optional_Marshal(m, &val.Descending)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSortText_Field_Descending))
		}
		e3 := m.MarshalKey("using_case", ListSortText_Field_UsingCase)
		if e3 == nil {
			e3 = rt.BoolEval_Optional_Marshal(m, &val.UsingCase)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSortText_Field_UsingCase))
		}
		m.EndBlock()
	}
	return
}

// ListSplice Modify a list by adding and removing elements.
// The type of the elements being added must match the type of the list.
// Text cant be added to a list of numbers, numbers cant be added to a list of text.
// If the starting index is negative, this begins that many elements from the end of the array;
// if list's length plus the start is less than zero, this begins from index zero.
// If the remove count is missing, this removes all elements from the start to the end;
// if the remove count is zero or negative, no elements are removed.
type ListSplice struct {
	Target core.Address    `if:"label=_"`
	Start  rt.NumberEval   `if:"label=start"`
	Remove rt.NumberEval   `if:"label=remove"`
	Insert core.Assignment `if:"label=insert"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.Execute = (*ListSplice)(nil)
var _ rt.NumListEval = (*ListSplice)(nil)
var _ rt.TextListEval = (*ListSplice)(nil)
var _ rt.RecordListEval = (*ListSplice)(nil)

func (*ListSplice) Compose() composer.Spec {
	return composer.Spec{
		Name: ListSplice_Type,
		Uses: composer.Type_Flow,
		Lede: "splice",
	}
}

const ListSplice_Type = "list_splice"
const ListSplice_Field_Target = "$TARGET"
const ListSplice_Field_Start = "$START"
const ListSplice_Field_Remove = "$REMOVE"
const ListSplice_Field_Insert = "$INSERT"

func (op *ListSplice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Marshal(m, op)
}

type ListSplice_Slice []ListSplice

func (op *ListSplice_Slice) GetType() string { return ListSplice_Type }

func (op *ListSplice_Slice) Marshal(m jsn.Marshaler) error {
	return ListSplice_Repeats_Marshal(m, (*[]ListSplice)(op))
}

func (op *ListSplice_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *ListSplice_Slice) SetSize(cnt int) {
	var els []ListSplice
	if cnt >= 0 {
		els = make(ListSplice_Slice, cnt)
	}
	(*op) = els
}

func (op *ListSplice_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return ListSplice_Marshal(m, &(*op)[i])
}

func ListSplice_Repeats_Marshal(m jsn.Marshaler, vals *[]ListSplice) error {
	return jsn.RepeatBlock(m, (*ListSplice_Slice)(vals))
}

func ListSplice_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]ListSplice) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = ListSplice_Repeats_Marshal(m, pv)
	}
	return
}

type ListSplice_Flow struct{ ptr *ListSplice }

func (n ListSplice_Flow) GetType() string      { return ListSplice_Type }
func (n ListSplice_Flow) GetLede() string      { return "splice" }
func (n ListSplice_Flow) GetFlow() interface{} { return n.ptr }
func (n ListSplice_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*ListSplice); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func ListSplice_Optional_Marshal(m jsn.Marshaler, pv **ListSplice) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = ListSplice_Marshal(m, *pv)
	} else if !enc {
		var v ListSplice
		if err = ListSplice_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func ListSplice_Marshal(m jsn.Marshaler, val *ListSplice) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(ListSplice_Flow{val}); err == nil {
		e0 := m.MarshalKey("", ListSplice_Field_Target)
		if e0 == nil {
			e0 = core.Address_Marshal(m, &val.Target)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", ListSplice_Field_Target))
		}
		e1 := m.MarshalKey("start", ListSplice_Field_Start)
		if e1 == nil {
			e1 = rt.NumberEval_Marshal(m, &val.Start)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", ListSplice_Field_Start))
		}
		e2 := m.MarshalKey("remove", ListSplice_Field_Remove)
		if e2 == nil {
			e2 = rt.NumberEval_Marshal(m, &val.Remove)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", ListSplice_Field_Remove))
		}
		e3 := m.MarshalKey("insert", ListSplice_Field_Insert)
		if e3 == nil {
			e3 = core.Assignment_Marshal(m, &val.Insert)
		}
		if e3 != nil && e3 != jsn.Missing {
			m.Error(errutil.New(e3, "in flow at", ListSplice_Field_Insert))
		}
		m.EndBlock()
	}
	return
}

// Range Generates a series of numbers r[i] = (start + step*i) where i>=0.
// Start and step default to 1, stop defaults to start;
// the inputs are truncated to produce whole numbers;
// a zero step returns an error.
// A positive step ends the series when the returned value would exceed stop
// while a negative step ends before generating a value less than stop.
type Range struct {
	To     rt.NumberEval `if:"label=_"`
	From   rt.NumberEval `if:"label=from,optional"`
	ByStep rt.NumberEval `if:"label=by_step,optional"`
	Markup map[string]any
}

// User implemented slots:
var _ rt.NumListEval = (*Range)(nil)

func (*Range) Compose() composer.Spec {
	return composer.Spec{
		Name: Range_Type,
		Uses: composer.Type_Flow,
	}
}

const Range_Type = "range"
const Range_Field_To = "$TO"
const Range_Field_From = "$FROM"
const Range_Field_ByStep = "$BY_STEP"

func (op *Range) Marshal(m jsn.Marshaler) error {
	return Range_Marshal(m, op)
}

type Range_Slice []Range

func (op *Range_Slice) GetType() string { return Range_Type }

func (op *Range_Slice) Marshal(m jsn.Marshaler) error {
	return Range_Repeats_Marshal(m, (*[]Range)(op))
}

func (op *Range_Slice) GetSize() (ret int) {
	if els := *op; els != nil {
		ret = len(els)
	} else {
		ret = -1
	}
	return
}

func (op *Range_Slice) SetSize(cnt int) {
	var els []Range
	if cnt >= 0 {
		els = make(Range_Slice, cnt)
	}
	(*op) = els
}

func (op *Range_Slice) MarshalEl(m jsn.Marshaler, i int) error {
	return Range_Marshal(m, &(*op)[i])
}

func Range_Repeats_Marshal(m jsn.Marshaler, vals *[]Range) error {
	return jsn.RepeatBlock(m, (*Range_Slice)(vals))
}

func Range_Optional_Repeats_Marshal(m jsn.Marshaler, pv *[]Range) (err error) {
	if len(*pv) > 0 || !m.IsEncoding() {
		err = Range_Repeats_Marshal(m, pv)
	}
	return
}

type Range_Flow struct{ ptr *Range }

func (n Range_Flow) GetType() string      { return Range_Type }
func (n Range_Flow) GetLede() string      { return Range_Type }
func (n Range_Flow) GetFlow() interface{} { return n.ptr }
func (n Range_Flow) SetFlow(i interface{}) (okay bool) {
	if ptr, ok := i.(*Range); ok {
		*n.ptr, okay = *ptr, true
	}
	return
}

func Range_Optional_Marshal(m jsn.Marshaler, pv **Range) (err error) {
	if enc := m.IsEncoding(); enc && *pv != nil {
		err = Range_Marshal(m, *pv)
	} else if !enc {
		var v Range
		if err = Range_Marshal(m, &v); err == nil {
			*pv = &v
		}
	}
	return
}

func Range_Marshal(m jsn.Marshaler, val *Range) (err error) {
	m.SetMarkup(&val.Markup)
	if err = m.MarshalBlock(Range_Flow{val}); err == nil {
		e0 := m.MarshalKey("", Range_Field_To)
		if e0 == nil {
			e0 = rt.NumberEval_Marshal(m, &val.To)
		}
		if e0 != nil && e0 != jsn.Missing {
			m.Error(errutil.New(e0, "in flow at", Range_Field_To))
		}
		e1 := m.MarshalKey("from", Range_Field_From)
		if e1 == nil {
			e1 = rt.NumberEval_Optional_Marshal(m, &val.From)
		}
		if e1 != nil && e1 != jsn.Missing {
			m.Error(errutil.New(e1, "in flow at", Range_Field_From))
		}
		e2 := m.MarshalKey("by_step", Range_Field_ByStep)
		if e2 == nil {
			e2 = rt.NumberEval_Optional_Marshal(m, &val.ByStep)
		}
		if e2 != nil && e2 != jsn.Missing {
			m.Error(errutil.New(e2, "in flow at", Range_Field_ByStep))
		}
		m.EndBlock()
	}
	return
}

var Slats = []composer.Composer{
	(*EraseEdge)(nil),
	(*EraseIndex)(nil),
	(*Erasing)(nil),
	(*ErasingEdge)(nil),
	(*ListEach)(nil),
	(*ListFind)(nil),
	(*ListGather)(nil),
	(*ListLen)(nil),
	(*ListMap)(nil),
	(*ListPush)(nil),
	(*ListReduce)(nil),
	(*ListReverse)(nil),
	(*ListSlice)(nil),
	(*ListSortNumbers)(nil),
	(*ListSortText)(nil),
	(*ListSplice)(nil),
	(*Range)(nil),
}

var Signatures = map[uint64]interface{}{
	4834855566453385149:  (*ListGather)(nil),      /* Gather object:from bool:using: */
	15211428265749514771: (*ListGather)(nil),      /* Gather object:from numList:using: */
	1041128765096947214:  (*ListGather)(nil),      /* Gather object:from number:using: */
	15181035077484080630: (*ListGather)(nil),      /* Gather object:from record:using: */
	6527107026845627330:  (*ListGather)(nil),      /* Gather object:from recordList:using: */
	18368601393953066792: (*ListGather)(nil),      /* Gather object:from text:using: */
	2698192178382880800:  (*ListGather)(nil),      /* Gather object:from textList:using: */
	15935288953360013024: (*ListGather)(nil),      /* Gather variable:from bool:using: */
	18258259361055151864: (*ListGather)(nil),      /* Gather variable:from numList:using: */
	7768636804631335339:  (*ListGather)(nil),      /* Gather variable:from number:using: */
	8390079513383739007:  (*ListGather)(nil),      /* Gather variable:from record:using: */
	11612120723995890267: (*ListGather)(nil),      /* Gather variable:from recordList:using: */
	5201624097684423657:  (*ListGather)(nil),      /* Gather variable:from text:using: */
	11735105521502822593: (*ListGather)(nil),      /* Gather variable:from textList:using: */
	14478606265438922628: (*EraseEdge)(nil),       /* execute=Erase object: */
	9282735962373956066:  (*EraseEdge)(nil),       /* execute=Erase object:atFront: */
	12482240611163626049: (*EraseEdge)(nil),       /* execute=Erase variable: */
	4367519203676111939:  (*EraseEdge)(nil),       /* execute=Erase variable:atFront: */
	2783457209873625683:  (*EraseIndex)(nil),      /* execute=Erase:from object:atIndex: */
	7431187839812372978:  (*EraseIndex)(nil),      /* execute=Erase:from variable:atIndex: */
	6467041291453091024:  (*ErasingEdge)(nil),     /* execute=Erasing object:as:does: */
	6340310696015763041:  (*ErasingEdge)(nil),     /* execute=Erasing object:as:does:else: */
	18171821493907737090: (*ErasingEdge)(nil),     /* execute=Erasing object:atFront:as:does: */
	4857564834398783063:  (*ErasingEdge)(nil),     /* execute=Erasing object:atFront:as:does:else: */
	10291819134056353121: (*ErasingEdge)(nil),     /* execute=Erasing variable:as:does: */
	6288078742401258778:  (*ErasingEdge)(nil),     /* execute=Erasing variable:as:does:else: */
	11123972830297154727: (*ErasingEdge)(nil),     /* execute=Erasing variable:atFront:as:does: */
	8304679251198058276:  (*ErasingEdge)(nil),     /* execute=Erasing variable:atFront:as:does:else: */
	10143128393744540981: (*Erasing)(nil),         /* execute=Erasing:from object:atIndex:as:does: */
	12913506357911229396: (*Erasing)(nil),         /* execute=Erasing:from variable:atIndex:as:does: */
	4798629662167190311:  (*ListFind)(nil),        /* bool_eval=Find bool:inList bool: */
	15496679535846055330: (*ListFind)(nil),        /* number_eval=Find bool:inList bool: */
	9825556450444029045:  (*ListFind)(nil),        /* bool_eval=Find bool:inList numList: */
	16528474899807055458: (*ListFind)(nil),        /* number_eval=Find bool:inList numList: */
	12044053119929816536: (*ListFind)(nil),        /* bool_eval=Find bool:inList number: */
	11913939542662143277: (*ListFind)(nil),        /* number_eval=Find bool:inList number: */
	3052123319382255080:  (*ListFind)(nil),        /* bool_eval=Find bool:inList record: */
	9694868371866035137:  (*ListFind)(nil),        /* number_eval=Find bool:inList record: */
	9023601832477479948:  (*ListFind)(nil),        /* bool_eval=Find bool:inList recordList: */
	17981633245748776277: (*ListFind)(nil),        /* number_eval=Find bool:inList recordList: */
	1500647723196650026:  (*ListFind)(nil),        /* bool_eval=Find bool:inList text: */
	2903868483097085819:  (*ListFind)(nil),        /* number_eval=Find bool:inList text: */
	4756245556509023346:  (*ListFind)(nil),        /* bool_eval=Find bool:inList textList: */
	7483576431261612195:  (*ListFind)(nil),        /* number_eval=Find bool:inList textList: */
	4883391365216342407:  (*ListFind)(nil),        /* bool_eval=Find numList:inList bool: */
	7840770186716954640:  (*ListFind)(nil),        /* number_eval=Find numList:inList bool: */
	13572012353775251477: (*ListFind)(nil),        /* bool_eval=Find numList:inList numList: */
	11728511162266892096: (*ListFind)(nil),        /* number_eval=Find numList:inList numList: */
	7690016808528207032:  (*ListFind)(nil),        /* bool_eval=Find numList:inList number: */
	5830452114605157963:  (*ListFind)(nil),        /* number_eval=Find numList:inList number: */
	17144690344201786184: (*ListFind)(nil),        /* bool_eval=Find numList:inList record: */
	2826678904067205755:  (*ListFind)(nil),        /* number_eval=Find numList:inList record: */
	17268211705068730668: (*ListFind)(nil),        /* bool_eval=Find numList:inList recordList: */
	6623021979824360355:  (*ListFind)(nil),        /* number_eval=Find numList:inList recordList: */
	7819798664338025866:  (*ListFind)(nil),        /* bool_eval=Find numList:inList text: */
	4633606205628459677:  (*ListFind)(nil),        /* number_eval=Find numList:inList text: */
	6124897371284439442:  (*ListFind)(nil),        /* bool_eval=Find numList:inList textList: */
	14391486515486068049: (*ListFind)(nil),        /* number_eval=Find numList:inList textList: */
	8751824420486616712:  (*ListFind)(nil),        /* bool_eval=Find number:inList bool: */
	17900038923979954549: (*ListFind)(nil),        /* number_eval=Find number:inList bool: */
	1770194941104087992:  (*ListFind)(nil),        /* bool_eval=Find number:inList numList: */
	18185554683488165027: (*ListFind)(nil),        /* number_eval=Find number:inList numList: */
	792062938938704979:   (*ListFind)(nil),        /* bool_eval=Find number:inList number: */
	12660797964853363710: (*ListFind)(nil),        /* number_eval=Find number:inList number: */
	6670555753527766259:  (*ListFind)(nil),        /* bool_eval=Find number:inList record: */
	16179555044001150002: (*ListFind)(nil),        /* number_eval=Find number:inList record: */
	13284160881060722139: (*ListFind)(nil),        /* bool_eval=Find number:inList recordList: */
	15878707675118176442: (*ListFind)(nil),        /* number_eval=Find number:inList recordList: */
	10347326664567502389: (*ListFind)(nil),        /* bool_eval=Find number:inList text: */
	7277141623401675964:  (*ListFind)(nil),        /* number_eval=Find number:inList text: */
	14877787943524816841: (*ListFind)(nil),        /* bool_eval=Find number:inList textList: */
	8570194865177788032:  (*ListFind)(nil),        /* number_eval=Find number:inList textList: */
	6549273478988393980:  (*ListFind)(nil),        /* bool_eval=Find record:inList bool: */
	1582006419269568565:  (*ListFind)(nil),        /* number_eval=Find record:inList bool: */
	4983517830338515572:  (*ListFind)(nil),        /* bool_eval=Find record:inList numList: */
	14956017093881013859: (*ListFind)(nil),        /* number_eval=Find record:inList numList: */
	7642277694920408143:  (*ListFind)(nil),        /* bool_eval=Find record:inList number: */
	9617759477496160446:  (*ListFind)(nil),        /* number_eval=Find record:inList number: */
	5013728000098006919:  (*ListFind)(nil),        /* bool_eval=Find record:inList record: */
	6662929451280538610:  (*ListFind)(nil),        /* number_eval=Find record:inList record: */
	6154699522158868655:  (*ListFind)(nil),        /* bool_eval=Find record:inList recordList: */
	9513159735218572666:  (*ListFind)(nil),        /* number_eval=Find record:inList recordList: */
	10159493979471565833: (*ListFind)(nil),        /* bool_eval=Find record:inList text: */
	2926580724521905532:  (*ListFind)(nil),        /* number_eval=Find record:inList text: */
	7004533036077749309:  (*ListFind)(nil),        /* bool_eval=Find record:inList textList: */
	11466514096698381888: (*ListFind)(nil),        /* number_eval=Find record:inList textList: */
	5219655416923856736:  (*ListFind)(nil),        /* bool_eval=Find recordList:inList bool: */
	16011403491957795353: (*ListFind)(nil),        /* number_eval=Find recordList:inList bool: */
	7464860859085804624:  (*ListFind)(nil),        /* bool_eval=Find recordList:inList numList: */
	7039752474390898287:  (*ListFind)(nil),        /* number_eval=Find recordList:inList numList: */
	7398363037665457947:  (*ListFind)(nil),        /* bool_eval=Find recordList:inList number: */
	2627971465223708458:  (*ListFind)(nil),        /* number_eval=Find recordList:inList number: */
	1772582454242836555:  (*ListFind)(nil),        /* bool_eval=Find recordList:inList record: */
	2020284005342045254:  (*ListFind)(nil),        /* number_eval=Find recordList:inList record: */
	4782409525887952115:  (*ListFind)(nil),        /* bool_eval=Find recordList:inList recordList: */
	466116651387500974:   (*ListFind)(nil),        /* number_eval=Find recordList:inList recordList: */
	13895308172737804621: (*ListFind)(nil),        /* bool_eval=Find recordList:inList text: */
	5943863057000524496:  (*ListFind)(nil),        /* number_eval=Find recordList:inList text: */
	15964379503982170689: (*ListFind)(nil),        /* bool_eval=Find recordList:inList textList: */
	4857120857680337972:  (*ListFind)(nil),        /* number_eval=Find recordList:inList textList: */
	16548788711483530454: (*ListFind)(nil),        /* bool_eval=Find text:inList bool: */
	4297686639920227743:  (*ListFind)(nil),        /* number_eval=Find text:inList bool: */
	16383538306170244670: (*ListFind)(nil),        /* bool_eval=Find text:inList numList: */
	10290406350836964845: (*ListFind)(nil),        /* number_eval=Find text:inList numList: */
	5259625134272047465:  (*ListFind)(nil),        /* bool_eval=Find text:inList number: */
	13307805073849880256: (*ListFind)(nil),        /* number_eval=Find text:inList number: */
	2072534090034643317:  (*ListFind)(nil),        /* bool_eval=Find text:inList record: */
	12077988993210590272: (*ListFind)(nil),        /* number_eval=Find text:inList record: */
	13264851135264311817: (*ListFind)(nil),        /* bool_eval=Find text:inList recordList: */
	16159500457161101668: (*ListFind)(nil),        /* number_eval=Find text:inList recordList: */
	3838954189566393919:  (*ListFind)(nil),        /* bool_eval=Find text:inList text: */
	13545854215908644514: (*ListFind)(nil),        /* number_eval=Find text:inList text: */
	215654777309859111:   (*ListFind)(nil),        /* bool_eval=Find text:inList textList: */
	3822119946373754218:  (*ListFind)(nil),        /* number_eval=Find text:inList textList: */
	10808826658776084734: (*ListFind)(nil),        /* bool_eval=Find textList:inList bool: */
	14947005753086002727: (*ListFind)(nil),        /* number_eval=Find textList:inList bool: */
	17906549100233067910: (*ListFind)(nil),        /* bool_eval=Find textList:inList numList: */
	14744001795738555765: (*ListFind)(nil),        /* number_eval=Find textList:inList numList: */
	5761838712338347201:  (*ListFind)(nil),        /* bool_eval=Find textList:inList number: */
	1467581581530417368:  (*ListFind)(nil),        /* number_eval=Find textList:inList number: */
	17251999743892516893: (*ListFind)(nil),        /* bool_eval=Find textList:inList record: */
	10922395854692407528: (*ListFind)(nil),        /* number_eval=Find textList:inList record: */
	9680969228619901649:  (*ListFind)(nil),        /* bool_eval=Find textList:inList recordList: */
	8954468803612751628:  (*ListFind)(nil),        /* number_eval=Find textList:inList recordList: */
	2548416432624298599:  (*ListFind)(nil),        /* bool_eval=Find textList:inList text: */
	11649023814115462442: (*ListFind)(nil),        /* number_eval=Find textList:inList text: */
	4926794106090969167:  (*ListFind)(nil),        /* bool_eval=Find textList:inList textList: */
	12827879591764936562: (*ListFind)(nil),        /* number_eval=Find textList:inList textList: */
	15771146728493073891: (*ListLen)(nil),         /* number_eval=Len bool: */
	13148152504949517065: (*ListLen)(nil),         /* number_eval=Len numList: */
	17629935431866945020: (*ListLen)(nil),         /* number_eval=Len number: */
	6288535260840067156:  (*ListLen)(nil),         /* number_eval=Len record: */
	5879602511151983064:  (*ListLen)(nil),         /* number_eval=Len recordList: */
	4894088838788583174:  (*ListLen)(nil),         /* number_eval=Len text: */
	15268125286018430830: (*ListLen)(nil),         /* number_eval=Len textList: */
	6300693019956665056:  (*ListMap)(nil),         /* execute=Map object:fromList bool:using: */
	12370769425037869816: (*ListMap)(nil),         /* execute=Map object:fromList numList:using: */
	15666754401429763499: (*ListMap)(nil),         /* execute=Map object:fromList number:using: */
	16288197110182167167: (*ListMap)(nil),         /* execute=Map object:fromList record:using: */
	7382518741870114395:  (*ListMap)(nil),         /* execute=Map object:fromList recordList:using: */
	14013772237990627305: (*ListMap)(nil),         /* execute=Map object:fromList text:using: */
	14822823295607039169: (*ListMap)(nil),         /* execute=Map object:fromList textList:using: */
	16742008827802526201: (*ListMap)(nil),         /* execute=Map variable:fromList bool:using: */
	14095417218301489111: (*ListMap)(nil),         /* execute=Map variable:fromList numList:using: */
	12197544336897376514: (*ListMap)(nil),         /* execute=Map variable:fromList number:using: */
	2501706441326043762:  (*ListMap)(nil),         /* execute=Map variable:fromList record:using: */
	12867728403674492990: (*ListMap)(nil),         /* execute=Map variable:fromList recordList:using: */
	2018364426527770836:  (*ListMap)(nil),         /* execute=Map variable:fromList text:using: */
	4552143749892410604:  (*ListMap)(nil),         /* execute=Map variable:fromList textList:using: */
	17460700385371836464: (*ListPush)(nil),        /* execute=Push bool:into object: */
	6056110790853933910:  (*ListPush)(nil),        /* execute=Push bool:into object:atFront: */
	2535261440951144669:  (*ListPush)(nil),        /* execute=Push bool:into variable: */
	18152773814529573991: (*ListPush)(nil),        /* execute=Push bool:into variable:atFront: */
	11320513384328480706: (*ListPush)(nil),        /* execute=Push numList:into object: */
	15533273064073310284: (*ListPush)(nil),        /* execute=Push numList:into object:atFront: */
	457344833627593787:   (*ListPush)(nil),        /* execute=Push numList:into variable: */
	4050524748381726297:  (*ListPush)(nil),        /* execute=Push numList:into variable:atFront: */
	12687913441322660603: (*ListPush)(nil),        /* execute=Push number:into object: */
	3535200343819049625:  (*ListPush)(nil),        /* execute=Push number:into object:atFront: */
	2012631263590879202:  (*ListPush)(nil),        /* execute=Push number:into variable: */
	17098403402451646252: (*ListPush)(nil),        /* execute=Push number:into variable:atFront: */
	9393284254281218439:  (*ListPush)(nil),        /* execute=Push record:into object: */
	6709774368926077693:  (*ListPush)(nil),        /* execute=Push record:into object:atFront: */
	5177050190408275070:  (*ListPush)(nil),        /* execute=Push record:into variable: */
	2015085615115694592:  (*ListPush)(nil),        /* execute=Push record:into variable:atFront: */
	11873326717073588367: (*ListPush)(nil),        /* execute=Push recordList:into object: */
	15712815456746515861: (*ListPush)(nil),        /* execute=Push recordList:into object:atFront: */
	13592019764413832454: (*ListPush)(nil),        /* execute=Push recordList:into variable: */
	16403912930406815384: (*ListPush)(nil),        /* execute=Push recordList:into variable:atFront: */
	3369987343011440621:  (*ListPush)(nil),        /* execute=Push text:into object: */
	3441000633086539703:  (*ListPush)(nil),        /* execute=Push text:into object:atFront: */
	16318378693412220248: (*ListPush)(nil),        /* execute=Push text:into variable: */
	3810526518917234510:  (*ListPush)(nil),        /* execute=Push text:into variable:atFront: */
	5255956843392128465:  (*ListPush)(nil),        /* execute=Push textList:into object: */
	2686881294722992083:  (*ListPush)(nil),        /* execute=Push textList:into object:atFront: */
	8013046464578751724:  (*ListPush)(nil),        /* execute=Push textList:into variable: */
	4562243350258231802:  (*ListPush)(nil),        /* execute=Push textList:into variable:atFront: */
	120416590109430143:   (*Range)(nil),           /* num_list_eval=Range: */
	15503705420922978310: (*Range)(nil),           /* num_list_eval=Range:byStep: */
	16618866959380663563: (*Range)(nil),           /* num_list_eval=Range:from: */
	14227857065891717050: (*Range)(nil),           /* num_list_eval=Range:from:byStep: */
	17109467529831837198: (*ListReduce)(nil),      /* execute=Reduce into object:fromList bool:using: */
	17000490356777766358: (*ListReduce)(nil),      /* execute=Reduce into object:fromList numList:using: */
	9366847048501616273:  (*ListReduce)(nil),      /* execute=Reduce into object:fromList number:using: */
	4440221666091188953:  (*ListReduce)(nil),      /* execute=Reduce into object:fromList record:using: */
	11763309932171020849: (*ListReduce)(nil),      /* execute=Reduce into object:fromList recordList:using: */
	7251766363632235731:  (*ListReduce)(nil),      /* execute=Reduce into object:fromList text:using: */
	12719000401652018127: (*ListReduce)(nil),      /* execute=Reduce into object:fromList textList:using: */
	15039942697949797459: (*ListReduce)(nil),      /* execute=Reduce into variable:fromList bool:using: */
	5358748091708601985:  (*ListReduce)(nil),      /* execute=Reduce into variable:fromList numList:using: */
	120736126498984868:   (*ListReduce)(nil),      /* execute=Reduce into variable:fromList number:using: */
	9871203455417191928:  (*ListReduce)(nil),      /* execute=Reduce into variable:fromList record:using: */
	8792716967726355184:  (*ListReduce)(nil),      /* execute=Reduce into variable:fromList recordList:using: */
	6088665226617120570:  (*ListReduce)(nil),      /* execute=Reduce into variable:fromList text:using: */
	18044924664543056838: (*ListReduce)(nil),      /* execute=Reduce into variable:fromList textList:using: */
	11373769717792348940: (*ListEach)(nil),        /* execute=Repeating across bool:as:does: */
	6772049628026210925:  (*ListEach)(nil),        /* execute=Repeating across bool:as:does:else: */
	14905805402665229262: (*ListEach)(nil),        /* execute=Repeating across numList:as:does: */
	7401547180676923763:  (*ListEach)(nil),        /* execute=Repeating across numList:as:does:else: */
	9441770216901454627:  (*ListEach)(nil),        /* execute=Repeating across number:as:does: */
	10613366508938233648: (*ListEach)(nil),        /* execute=Repeating across number:as:does:else: */
	8482560869331470195:  (*ListEach)(nil),        /* execute=Repeating across record:as:does: */
	11704780684564553504: (*ListEach)(nil),        /* execute=Repeating across record:as:does:else: */
	2878151878592905567:  (*ListEach)(nil),        /* execute=Repeating across recordList:as:does: */
	11591562832854171244: (*ListEach)(nil),        /* execute=Repeating across recordList:as:does:else: */
	9866670752584273857:  (*ListEach)(nil),        /* execute=Repeating across text:as:does: */
	13122655079684130170: (*ListEach)(nil),        /* execute=Repeating across text:as:does:else: */
	2999023839284626713:  (*ListEach)(nil),        /* execute=Repeating across textList:as:does: */
	5936926416578155938:  (*ListEach)(nil),        /* execute=Repeating across textList:as:does:else: */
	11445472112426895002: (*ListReverse)(nil),     /* execute=Reverse list object: */
	9028179729453633619:  (*ListReverse)(nil),     /* execute=Reverse list variable: */
	687740249528241494:   (*ListSlice)(nil),       /* num_list_eval=Slice bool: */
	7477623252005102885:  (*ListSlice)(nil),       /* record_list_eval=Slice bool: */
	10583133103161952119: (*ListSlice)(nil),       /* text_list_eval=Slice bool: */
	9830270355687528203:  (*ListSlice)(nil),       /* num_list_eval=Slice bool:end: */
	14700213591516078992: (*ListSlice)(nil),       /* record_list_eval=Slice bool:end: */
	7620261441166002618:  (*ListSlice)(nil),       /* text_list_eval=Slice bool:end: */
	10091706125993025444: (*ListSlice)(nil),       /* num_list_eval=Slice bool:start: */
	3618370589102673887:  (*ListSlice)(nil),       /* record_list_eval=Slice bool:start: */
	2413289201032818373:  (*ListSlice)(nil),       /* text_list_eval=Slice bool:start: */
	11071611209237880153: (*ListSlice)(nil),       /* num_list_eval=Slice bool:start:end: */
	16381407642661604418: (*ListSlice)(nil),       /* record_list_eval=Slice bool:start:end: */
	17697142756383396144: (*ListSlice)(nil),       /* text_list_eval=Slice bool:start:end: */
	6174045901093974974:  (*ListSlice)(nil),       /* num_list_eval=Slice numList: */
	6737230864618501459:  (*ListSlice)(nil),       /* record_list_eval=Slice numList: */
	1777591537678528965:  (*ListSlice)(nil),       /* text_list_eval=Slice numList: */
	10686284793975073715: (*ListSlice)(nil),       /* num_list_eval=Slice numList:end: */
	4257341276502486254:  (*ListSlice)(nil),       /* record_list_eval=Slice numList:end: */
	9758816093257237552:  (*ListSlice)(nil),       /* text_list_eval=Slice numList:end: */
	9194046234818555932:  (*ListSlice)(nil),       /* num_list_eval=Slice numList:start: */
	4478864869180331201:  (*ListSlice)(nil),       /* record_list_eval=Slice numList:start: */
	9500656902410367615:  (*ListSlice)(nil),       /* text_list_eval=Slice numList:start: */
	10700451860932825873: (*ListSlice)(nil),       /* num_list_eval=Slice numList:start:end: */
	13060933077919140628: (*ListSlice)(nil),       /* record_list_eval=Slice numList:start:end: */
	14305657401602515682: (*ListSlice)(nil),       /* text_list_eval=Slice numList:start:end: */
	7319486253292826089:  (*ListSlice)(nil),       /* num_list_eval=Slice number: */
	4634686133626189870:  (*ListSlice)(nil),       /* record_list_eval=Slice number: */
	5676791116388392808:  (*ListSlice)(nil),       /* text_list_eval=Slice number: */
	13030066371456642044: (*ListSlice)(nil),       /* num_list_eval=Slice number:end: */
	17985713863645920451: (*ListSlice)(nil),       /* record_list_eval=Slice number:end: */
	9652603043351421749:  (*ListSlice)(nil),       /* text_list_eval=Slice number:end: */
	13056061230635284227: (*ListSlice)(nil),       /* num_list_eval=Slice number:start: */
	5154187822401091244:  (*ListSlice)(nil),       /* record_list_eval=Slice number:start: */
	435651182264678570:   (*ListSlice)(nil),       /* text_list_eval=Slice number:start: */
	7381586987032717694:  (*ListSlice)(nil),       /* num_list_eval=Slice number:start:end: */
	12950392980078948673: (*ListSlice)(nil),       /* record_list_eval=Slice number:start:end: */
	18312698166011807895: (*ListSlice)(nil),       /* text_list_eval=Slice number:start:end: */
	4132395209055421941:  (*ListSlice)(nil),       /* num_list_eval=Slice record: */
	7156142198557851042:  (*ListSlice)(nil),       /* record_list_eval=Slice record: */
	11544551921255140600: (*ListSlice)(nil),       /* text_list_eval=Slice record: */
	11928116709124896896: (*ListSlice)(nil),       /* num_list_eval=Slice record:end: */
	16024736234595360815: (*ListSlice)(nil),       /* record_list_eval=Slice record:end: */
	11403018960783699685: (*ListSlice)(nil),       /* text_list_eval=Slice record:end: */
	5985953244105548303:  (*ListSlice)(nil),       /* num_list_eval=Slice record:start: */
	11915160734447285760: (*ListSlice)(nil),       /* record_list_eval=Slice record:start: */
	5691947242970543898:  (*ListSlice)(nil),       /* text_list_eval=Slice record:start: */
	5491171661651386706:  (*ListSlice)(nil),       /* num_list_eval=Slice record:start:end: */
	15196312810342329485: (*ListSlice)(nil),       /* record_list_eval=Slice record:start:end: */
	11502927729046873063: (*ListSlice)(nil),       /* text_list_eval=Slice record:start:end: */
	12519002010128848521: (*ListSlice)(nil),       /* num_list_eval=Slice recordList: */
	14429883617907033194: (*ListSlice)(nil),       /* record_list_eval=Slice recordList: */
	11432186531375119964: (*ListSlice)(nil),       /* text_list_eval=Slice recordList: */
	16536235310257874716: (*ListSlice)(nil),       /* num_list_eval=Slice recordList:end: */
	12083011931257404887: (*ListSlice)(nil),       /* record_list_eval=Slice recordList:end: */
	6677257335508720593:  (*ListSlice)(nil),       /* text_list_eval=Slice recordList:end: */
	15794963570383188899: (*ListSlice)(nil),       /* num_list_eval=Slice recordList:start: */
	13348208109320820728: (*ListSlice)(nil),       /* record_list_eval=Slice recordList:start: */
	9740494822366536638:  (*ListSlice)(nil),       /* text_list_eval=Slice recordList:start: */
	6248542592474266782:  (*ListSlice)(nil),       /* num_list_eval=Slice recordList:start:end: */
	17273095392328657381: (*ListSlice)(nil),       /* record_list_eval=Slice recordList:start:end: */
	12201780319389785011: (*ListSlice)(nil),       /* text_list_eval=Slice recordList:start:end: */
	6424649801320656575:  (*ListSlice)(nil),       /* num_list_eval=Slice text: */
	2880198564141747020:  (*ListSlice)(nil),       /* record_list_eval=Slice text: */
	7577541409167942746:  (*ListSlice)(nil),       /* text_list_eval=Slice text: */
	13833115380441811618: (*ListSlice)(nil),       /* num_list_eval=Slice text:end: */
	1731565053043038689:  (*ListSlice)(nil),       /* record_list_eval=Slice text:end: */
	17693088135176660647: (*ListSlice)(nil),       /* text_list_eval=Slice text:end: */
	13758137233374768093: (*ListSlice)(nil),       /* num_list_eval=Slice text:start: */
	1123287878359048846:  (*ListSlice)(nil),       /* record_list_eval=Slice text:start: */
	7399917200046510856:  (*ListSlice)(nil),       /* text_list_eval=Slice text:start: */
	12296457659283851144: (*ListSlice)(nil),       /* num_list_eval=Slice text:start:end: */
	12185380936141810083: (*ListSlice)(nil),       /* record_list_eval=Slice text:start:end: */
	170920642466474965:   (*ListSlice)(nil),       /* text_list_eval=Slice text:start:end: */
	11769936664949622183: (*ListSlice)(nil),       /* num_list_eval=Slice textList: */
	8811003461802931280:  (*ListSlice)(nil),       /* record_list_eval=Slice textList: */
	7475599544229173794:  (*ListSlice)(nil),       /* text_list_eval=Slice textList: */
	620597108004713610:   (*ListSlice)(nil),       /* num_list_eval=Slice textList:end: */
	14361736680466806717: (*ListSlice)(nil),       /* record_list_eval=Slice textList:end: */
	10243148548097836207: (*ListSlice)(nil),       /* text_list_eval=Slice textList:end: */
	11352720954416934101: (*ListSlice)(nil),       /* num_list_eval=Slice textList:start: */
	4417532206553105122:  (*ListSlice)(nil),       /* record_list_eval=Slice textList:start: */
	12363318130645520000: (*ListSlice)(nil),       /* text_list_eval=Slice textList:start: */
	13255799277286474592: (*ListSlice)(nil),       /* num_list_eval=Slice textList:start:end: */
	17538828973473648623: (*ListSlice)(nil),       /* record_list_eval=Slice textList:start:end: */
	2769197376988253453:  (*ListSlice)(nil),       /* text_list_eval=Slice textList:start:end: */
	421498711850031655:   (*ListSortNumbers)(nil), /* execute=SortNumbers object:byField: */
	16497684129300035417: (*ListSortNumbers)(nil), /* execute=SortNumbers object:byField:descending: */
	5849496999430306662:  (*ListSortNumbers)(nil), /* execute=SortNumbers variable:byField: */
	5424404571725863098:  (*ListSortNumbers)(nil), /* execute=SortNumbers variable:byField:descending: */
	14456995616405811689: (*ListSortText)(nil),    /* execute=SortTexts object:byField: */
	6503987754421782359:  (*ListSortText)(nil),    /* execute=SortTexts object:byField:descending: */
	600977390647603797:   (*ListSortText)(nil),    /* execute=SortTexts object:byField:descending:usingCase: */
	3621745037740421335:  (*ListSortText)(nil),    /* execute=SortTexts object:byField:usingCase: */
	14942187006010075588: (*ListSortText)(nil),    /* execute=SortTexts variable:byField: */
	11003982858264652004: (*ListSortText)(nil),    /* execute=SortTexts variable:byField:descending: */
	16749751527264114426: (*ListSortText)(nil),    /* execute=SortTexts variable:byField:descending:usingCase: */
	7681352795670764826:  (*ListSortText)(nil),    /* execute=SortTexts variable:byField:usingCase: */
	254505568650062711:   (*ListSplice)(nil),      /* execute=Splice object:start:remove:insert bool: */
	14473465088241368288: (*ListSplice)(nil),      /* num_list_eval=Splice object:start:remove:insert bool: */
	10907694060219474095: (*ListSplice)(nil),      /* record_list_eval=Splice object:start:remove:insert bool: */
	9588020195550516101:  (*ListSplice)(nil),      /* text_list_eval=Splice object:start:remove:insert bool: */
	4953874312339275205:  (*ListSplice)(nil),      /* execute=Splice object:start:remove:insert numList: */
	10036210830066206928: (*ListSplice)(nil),      /* num_list_eval=Splice object:start:remove:insert numList: */
	11877450138547579581: (*ListSplice)(nil),      /* record_list_eval=Splice object:start:remove:insert numList: */
	17320190953942263027: (*ListSplice)(nil),      /* text_list_eval=Splice object:start:remove:insert numList: */
	6212968220386894696:  (*ListSplice)(nil),      /* execute=Splice object:start:remove:insert number: */
	10837284387544461467: (*ListSplice)(nil),      /* num_list_eval=Splice object:start:remove:insert number: */
	16548514040101249424: (*ListSplice)(nil),      /* record_list_eval=Splice object:start:remove:insert number: */
	18327819217042272398: (*ListSplice)(nil),      /* text_list_eval=Splice object:start:remove:insert number: */
	12080729025253642488: (*ListSplice)(nil),      /* execute=Splice object:start:remove:insert record: */
	5211503804121840075:  (*ListSplice)(nil),      /* num_list_eval=Splice object:start:remove:insert record: */
	7989605691056834896:  (*ListSplice)(nil),      /* record_list_eval=Splice object:start:remove:insert record: */
	4167651507363618818:  (*ListSplice)(nil),      /* text_list_eval=Splice object:start:remove:insert record: */
	18191097171320504924: (*ListSplice)(nil),      /* execute=Splice object:start:remove:insert recordList: */
	4841682711032149619:  (*ListSplice)(nil),      /* num_list_eval=Splice object:start:remove:insert recordList: */
	16734101867085488820: (*ListSplice)(nil),      /* record_list_eval=Splice object:start:remove:insert recordList: */
	13611854116028542730: (*ListSplice)(nil),      /* text_list_eval=Splice object:start:remove:insert recordList: */
	15695657948365604954: (*ListSplice)(nil),      /* execute=Splice object:start:remove:insert text: */
	4702373770345764557:  (*ListSplice)(nil),      /* num_list_eval=Splice object:start:remove:insert text: */
	4870934094039167890:  (*ListSplice)(nil),      /* record_list_eval=Splice object:start:remove:insert text: */
	4990595507687160236:  (*ListSplice)(nil),      /* text_list_eval=Splice object:start:remove:insert text: */
	2809903728659791394:  (*ListSplice)(nil),      /* execute=Splice object:start:remove:insert textList: */
	18434334661778163649: (*ListSplice)(nil),      /* num_list_eval=Splice object:start:remove:insert textList: */
	17848994770818519514: (*ListSplice)(nil),      /* record_list_eval=Splice object:start:remove:insert textList: */
	6255332626240908784:  (*ListSplice)(nil),      /* text_list_eval=Splice object:start:remove:insert textList: */
	94692154838844448:    (*ListSplice)(nil),      /* execute=Splice variable:start:remove:insert bool: */
	834002895175246815:   (*ListSplice)(nil),      /* num_list_eval=Splice variable:start:remove:insert bool: */
	3091564847518459832:  (*ListSplice)(nil),      /* record_list_eval=Splice variable:start:remove:insert bool: */
	2290242410755864938:  (*ListSplice)(nil),      /* text_list_eval=Splice variable:start:remove:insert bool: */
	15946286690290403600: (*ListSplice)(nil),      /* execute=Splice variable:start:remove:insert numList: */
	17078132711325563949: (*ListSplice)(nil),      /* num_list_eval=Splice variable:start:remove:insert numList: */
	5885731321866503976:  (*ListSplice)(nil),      /* record_list_eval=Splice variable:start:remove:insert numList: */
	15234187832380791946: (*ListSplice)(nil),      /* text_list_eval=Splice variable:start:remove:insert numList: */
	16504995663933432027: (*ListSplice)(nil),      /* execute=Splice variable:start:remove:insert number: */
	15428307853647068160: (*ListSplice)(nil),      /* num_list_eval=Splice variable:start:remove:insert number: */
	6377975723711103747:  (*ListSplice)(nil),      /* record_list_eval=Splice variable:start:remove:insert number: */
	2374993890198756581:  (*ListSplice)(nil),      /* text_list_eval=Splice variable:start:remove:insert number: */
	10495292378639235851: (*ListSplice)(nil),      /* execute=Splice variable:start:remove:insert record: */
	6198982235816317568:  (*ListSplice)(nil),      /* num_list_eval=Splice variable:start:remove:insert record: */
	8114195147842030883:  (*ListSplice)(nil),      /* record_list_eval=Splice variable:start:remove:insert record: */
	2303881887029688521:  (*ListSplice)(nil),      /* text_list_eval=Splice variable:start:remove:insert record: */
	9158900994911257011:  (*ListSplice)(nil),      /* execute=Splice variable:start:remove:insert recordList: */
	6164668362673214372:  (*ListSplice)(nil),      /* num_list_eval=Splice variable:start:remove:insert recordList: */
	6305393212333269451:  (*ListSplice)(nil),      /* record_list_eval=Splice variable:start:remove:insert recordList: */
	16939933291233560829: (*ListSplice)(nil),      /* text_list_eval=Splice variable:start:remove:insert recordList: */
	15249617378531728397: (*ListSplice)(nil),      /* execute=Splice variable:start:remove:insert text: */
	9837287241376951266:  (*ListSplice)(nil),      /* num_list_eval=Splice variable:start:remove:insert text: */
	10306364190290141637: (*ListSplice)(nil),      /* record_list_eval=Splice variable:start:remove:insert text: */
	11138339034756661923: (*ListSplice)(nil),      /* text_list_eval=Splice variable:start:remove:insert text: */
	16704899702181821441: (*ListSplice)(nil),      /* execute=Splice variable:start:remove:insert textList: */
	12938904036510151082: (*ListSplice)(nil),      /* num_list_eval=Splice variable:start:remove:insert textList: */
	14769204272593250009: (*ListSplice)(nil),      /* record_list_eval=Splice variable:start:remove:insert textList: */
	11691226362631679819: (*ListSplice)(nil),      /* text_list_eval=Splice variable:start:remove:insert textList: */
}
