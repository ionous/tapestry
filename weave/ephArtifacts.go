package weave

import (
	"errors"
	"hash/fnv"
	"io"
	"strings"

	"github.com/ionous/errutil"
)

// arbitrary key to value storage of declarations generated by the assembler.
// exists specifically to detect ambiguities in authored stories.
type Artifacts map[uint64]Definition

// an arbitrary string value and the location of its first declaration.
type Definition struct {
	key       keyType
	at, value string
}

// error generated by mismatched or duplicated artifacts within the same domain
type Conflict struct {
	Key    keyType
	Reason ReasonForConflict
	Was    Definition
	Value  string
}

type keyType struct {
	hash uint64
	vals []string
}

func (k keyType) String() string {
	return strings.Join(k.vals, ",")
}

func MakeKey(keys ...string) keyType {
	return keyType{makeKey(keys...), keys}
}

func makeKey(strs ...string) uint64 {
	w := fnv.New64a()
	for _, str := range strs {
		io.WriteString(w, str)
	}
	return w.Sum64()
}

func (n *Conflict) Error() string {
	return errutil.Sprintf("%s %s was %q at %s now %q", n.Reason.String(), n.Key.String(), n.Was.value, n.Was.at, n.Value)
}

func (n *Conflict) Duplicated() bool {
	return Duplicated == n.Reason

}
func (n *Conflict) Redefined() bool {
	return Redefined == n.Reason
}

func newConflict(key keyType, why ReasonForConflict, was Definition, newval string) *Conflict {
	return &Conflict{key, why, was, newval}
}

type ReasonForConflict int

//go:generate stringer -type=ReasonForConflict
const (
	Redefined ReasonForConflict = iota
	Duplicated
)

// return an error ( type Conflict ) if the passed pair would collide with any existing pair
func (defs Artifacts) CheckConflict(key keyType, value string) (err error) {
	if def, ok := defs[key.hash]; ok {
		var why ReasonForConflict
		if def.value == value {
			why = Duplicated // if its duplicated, the previous entry would have checked for redefined
		} else {
			why = Redefined
		}
		err = newConflict(key, why, def, value)
	}
	return
}

// add the passed artifacts looking for and rejecting conflicts
func (defs Artifacts) Merge(from Artifacts, allowDupes bool, warn func(error)) (err error) {
	for k, def := range from {
		var conflict *Conflict
		if e := defs.CheckConflict(def.key, def.value); e == nil {
			defs[k] = def // store if there was no conflict
		} else if allowDupes && errors.As(e, &conflict) && conflict.Reason == Duplicated {
			warn(e) // warn if it was a duplicated definition
		} else {
			err = errutil.Append(err, e)
		}
	}
	return
}
