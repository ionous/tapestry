package mdl

import (
	"database/sql"
	"strings"

	"git.sr.ht/~ionous/tapestry/affine"
	"git.sr.ht/~ionous/tapestry/dl/literal"
	"git.sr.ht/~ionous/tapestry/jsn"
	"git.sr.ht/~ionous/tapestry/jsn/cout"
	"git.sr.ht/~ionous/tapestry/rt"
	"git.sr.ht/~ionous/tapestry/tables"
	"github.com/ionous/errutil"
)

func MakePath(path ...string) string {
	return strings.Join(path, ".")
}

type pathAff struct {
	a affine.Affinity
	p []string
}

func (pa *pathAff) getAff(i int) (ret affine.Affinity) {
	if i == len(pa.p) {
		ret = pa.a
	} else {
		ret = affine.Record
	}
	return
}

func (pen *Pen) addValue(owner, root string, path []string, value string, aff affine.Affinity) (err error) {
	pathAff := pathAff{aff, path}
	if noun, e := pen.findRequiredNoun(owner, nounWithKind); e != nil {
		err = e
	} else {
		var dot string
		var field fieldInfo
		if field, err = pen.findField(noun.class(), root, pathAff.getAff(0)); e == nil && len(path) > 0 {
			cls := field.class() // drill down through records to find the final targeted field.
			var join strings.Builder
			for i, subField := range path {
				if i > 0 {
					join.WriteRune('.')
				}
				if next, e := pen.findField(cls, subField, pathAff.getAff(i+1)); e != nil {
					err = e
					break
				} else {
					join.WriteString(subField)
					cls = next.class()
				}
			}
			dot = join.String()
		}

		if err == nil {
			opt := sql.NullString{
				String: dot,
				Valid:  len(dot) > 0,
			}
			// search for existing paths which conflict:
			// could be the same path, or could be a record written as a whole
			// now being written as a part; or vice versa.
			// OR the exact match ( ex. a duplicate )
			var prev struct {
				dot   sql.NullString
				value string
			}
			// find cases where the new path starts a previous path,
			// or a previous path starts the new path.
			// instr(X,Y) - searches X for Y.
			if rows, e := pen.db.Query(`
				select mv.dot, mv.value 
				from mdl_value mv 
				where mv.noun = @1
				and mv.field = @2
				and (
					 (1 == instr(CASE WHEN mv.dot is null THEN "." ELSE '.' || mv.dot || '.' END, 
					             CASE WHEN   @3   is null THEN "." ELSE '.' ||   @3   || '.' END)) or 
				   (1 == instr(CASE WHEN   @3   is null THEN "." ELSE '.' ||   @3   || '.' END, 
				               CASE WHEN mv.dot is null THEN "." ELSE '.' || mv.dot || '.' END))
				)`,
				noun.id, field.id, opt,
			); e != nil {
				err = errutil.New("database error", e)
			} else if e := tables.ScanAll(rows, func() (err error) {
				if prev.dot.String != dot {
					err = errutil.Fmt(`%w writing value for %s, had value for %s.`,
						Conflict, debugJoin(owner, root, dot), debugJoin(owner, root, prev.dot.String))
				} else if prev.value != value {
					err = errutil.Fmt(`%w mismatched value for %s.`,
						Conflict, debugJoin(owner, root, dot))
				} else {
					err = errutil.Fmt(`%w value for %s.`,
						Duplicate, debugJoin(owner, root, dot))
				}
				return
			}, &prev.dot, &prev.value); e != nil {
				err = eatDuplicates(pen.warn, e)
			} else {
				if _, e := pen.db.Exec(mdl_value, noun.id, field.id, opt, value, pen.at); e != nil {
					err = e
				}
			}
		}
	}
	return
}

func debugJoin(noun, field, path string) string {
	var b strings.Builder
	b.WriteRune('\'')
	b.WriteString(noun)
	b.WriteRune('.')
	b.WriteString(field)
	if len(path) > 0 {
		b.WriteRune('.')
		b.WriteString(path)
	}
	b.WriteRune('\'')
	return b.String()
}

// shared generic marshal prog to text
func marshalout(cmd any) (ret string, err error) {
	if cmd != nil {
		if pen, ok := cmd.(jsn.Marshalee); !ok {
			err = errutil.Fmt("can only marshal autogenerated types (%T)", cmd)
		} else {

			ret, err = cout.Marshal(pen, literal.CompactEncoder)
		}
	}
	return
}

func marshalprog(prog []rt.Execute) (ret string, err error) {
	if len(prog) > 0 {
		slice := rt.Execute_Slice(prog)
		if out, e := marshalout(&slice); e != nil {
			err = e
		} else {
			ret = out
		}
	}
	return
}
