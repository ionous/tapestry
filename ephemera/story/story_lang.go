// Code generated by "makeops"; edit at your own risk.
package story

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/grammar"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// AbstractAction requires a user-specified string.
type AbstractAction struct {
	Str string
}

func (op *AbstractAction) String() (ret string) {
	return op.Str
}

const AbstractAction_Nothing = "$NOTHING"

func (*AbstractAction) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AbstractAction,
		Uses: composer.Type_Str,
		Choices: []string{
			AbstractAction_Nothing,
		},
		Strings: []string{
			"nothing",
		},
	}
}

const Type_AbstractAction = "abstract_action"

func (op *AbstractAction) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AbstractAction_Detailed_Marshal(n, op)
}
func (op *AbstractAction) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AbstractAction_Detailed_Unmarshal(n, b, op)
}
func AbstractAction_Detailed_Marshal(n jsonexp.Context, val *AbstractAction) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_AbstractAction,
		Value: val.Str,
	})
}

func AbstractAction_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AbstractAction) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_AbstractAction, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// ActionContext
type ActionContext struct {
	At   reader.Position `if:"internal"`
	Kind SingularKind    `if:"label=kind"`
}

func (*ActionContext) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ActionContext,
		Uses: composer.Type_Flow,
	}
}

const Type_ActionContext = "action_context"
const ActionContext_Kind = "$KIND"

func (op *ActionContext) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ActionContext_Detailed_Marshal(n, op)
}
func (op *ActionContext) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ActionContext_Detailed_Unmarshal(n, b, op)
}

func ActionContext_Detailed_Marshal(n jsonexp.Context, val *ActionContext) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := SingularKind_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ActionContext_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_ActionContext,
			Fields: fields,
		})
	}
	return
}

func ActionContext_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ActionContext) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ActionContext, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[ActionContext_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_ActionContext+"."+ActionContext_Kind, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func ActionContext_Detailed_Optional_Marshal(n jsonexp.Context, val **ActionContext) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ActionContext_Detailed_Marshal(n, ptr)
	}
	return
}
func ActionContext_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ActionContext) (err error) {
	if len(b) > 0 {
		var el ActionContext
		if e := ActionContext_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_ActionContext, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// ActionDecl
type ActionDecl struct {
	At           reader.Position `if:"internal"`
	Event        EventName       `if:"label=event"`
	Action       ActionName      `if:"label=action"`
	ActionParams ActionParams    `if:"label=action_params"`
}

func (*ActionDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ActionDecl,
		Uses: composer.Type_Flow,
	}
}

const Type_ActionDecl = "action_decl"
const ActionDecl_Event = "$EVENT"
const ActionDecl_Action = "$ACTION"
const ActionDecl_ActionParams = "$ACTION_PARAMS"

func (op *ActionDecl) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ActionDecl_Detailed_Marshal(n, op)
}
func (op *ActionDecl) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ActionDecl_Detailed_Unmarshal(n, b, op)
}

func ActionDecl_Detailed_Marshal(n jsonexp.Context, val *ActionDecl) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := EventName_Detailed_Marshal(n, &val.Event); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ActionDecl_Event] = b
	}
	if b, e := ActionName_Detailed_Marshal(n, &val.Action); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ActionDecl_Action] = b
	}
	if b, e := ActionParams_Detailed_Marshal(n, &val.ActionParams); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ActionDecl_ActionParams] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_ActionDecl,
			Fields: fields,
		})
	}
	return
}

func ActionDecl_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ActionDecl) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ActionDecl, "-", e)
	} else if e := EventName_Detailed_Unmarshal(n, msg.Fields[ActionDecl_Event], &out.Event); e != nil {
		err = errutil.New(Type_ActionDecl+"."+ActionDecl_Event, "-", e)
	} else if e := ActionName_Detailed_Unmarshal(n, msg.Fields[ActionDecl_Action], &out.Action); e != nil {
		err = errutil.New(Type_ActionDecl+"."+ActionDecl_Action, "-", e)
	} else if e := ActionParams_Detailed_Unmarshal(n, msg.Fields[ActionDecl_ActionParams], &out.ActionParams); e != nil {
		err = errutil.New(Type_ActionDecl+"."+ActionDecl_ActionParams, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func ActionDecl_Detailed_Optional_Marshal(n jsonexp.Context, val **ActionDecl) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ActionDecl_Detailed_Marshal(n, ptr)
	}
	return
}
func ActionDecl_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ActionDecl) (err error) {
	if len(b) > 0 {
		var el ActionDecl
		if e := ActionDecl_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_ActionDecl, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// ActionName requires a user-specified string.
type ActionName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *ActionName) String() (ret string) {
	return op.Str
}

func (*ActionName) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_ActionName,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_ActionName = "action_name"

func (op *ActionName) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ActionName_Detailed_Marshal(n, op)
}
func (op *ActionName) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ActionName_Detailed_Unmarshal(n, b, op)
}
func ActionName_Detailed_Marshal(n jsonexp.Context, val *ActionName) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_ActionName,
		Value: val.Str,
	})
}

func ActionName_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ActionName) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_ActionName, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// ActionParams swaps between various options
type ActionParams struct {
	Opt interface{}
}

const ActionParams_Common = "$COMMON"
const ActionParams_Dual = "$DUAL"
const ActionParams_None = "$NONE"

func (*ActionParams) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ActionParams,
		Uses: composer.Type_Swap,
		Choices: []string{
			ActionParams_Common, ActionParams_Dual, ActionParams_None,
		},
		Swaps: []interface{}{
			(*CommonAction)(nil),
			(*PairedAction)(nil),
			(*AbstractAction)(nil),
		},
	}
}

const Type_ActionParams = "action_params"

func (op *ActionParams) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *CommonAction:
		ret, okay = ActionParams_Common, true
	case *PairedAction:
		ret, okay = ActionParams_Dual, true
	case *AbstractAction:
		ret, okay = ActionParams_None, true
	}
	return
}
func (op *ActionParams) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ActionParams_Detailed_Marshal(n, op)
}
func (op *ActionParams) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ActionParams_Detailed_Unmarshal(n, b, op)
}

func ActionParams_Detailed_Marshal(n jsonexp.Context, val *ActionParams) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_ActionParams)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_ActionParams, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{
					Type: Type_ActionParams,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func ActionParams_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ActionParams) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_ActionParams, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case ActionParams_Common:
				ptr = new(CommonAction)
			case ActionParams_Dual:
				ptr = new(PairedAction)
			case ActionParams_None:
				ptr = new(AbstractAction)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_ActionParams, "-", e)
			} else {
				out.Opt = ptr
			}
		}
	}
	return
}

// Ana requires a user-specified string.
type Ana struct {
	Str string
}

func (op *Ana) String() (ret string) {
	return op.Str
}

const Ana_A = "$A"
const Ana_An = "$AN"

func (*Ana) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Ana,
		Uses: composer.Type_Str,
		Choices: []string{
			Ana_A, Ana_An,
		},
		Strings: []string{
			"a", "an",
		},
	}
}

const Type_Ana = "ana"

func (op *Ana) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Ana_Detailed_Marshal(n, op)
}
func (op *Ana) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Ana_Detailed_Unmarshal(n, b, op)
}
func Ana_Detailed_Marshal(n jsonexp.Context, val *Ana) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_Ana,
		Value: val.Str,
	})
}

func Ana_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Ana) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_Ana, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// AreAn requires a user-specified string.
type AreAn struct {
	Str string
}

func (op *AreAn) String() (ret string) {
	return op.Str
}

const AreAn_Are = "$ARE"
const AreAn_Area = "$AREA"
const AreAn_Arean = "$AREAN"
const AreAn_Is = "$IS"
const AreAn_Isa = "$ISA"
const AreAn_Isan = "$ISAN"

func (*AreAn) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AreAn,
		Uses: composer.Type_Str,
		Choices: []string{
			AreAn_Are, AreAn_Area, AreAn_Arean, AreAn_Is, AreAn_Isa, AreAn_Isan,
		},
		Strings: []string{
			"are", "area", "arean", "is", "isa", "isan",
		},
	}
}

const Type_AreAn = "are_an"

func (op *AreAn) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AreAn_Detailed_Marshal(n, op)
}
func (op *AreAn) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AreAn_Detailed_Unmarshal(n, b, op)
}
func AreAn_Detailed_Marshal(n jsonexp.Context, val *AreAn) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_AreAn,
		Value: val.Str,
	})
}

func AreAn_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AreAn) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_AreAn, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// AreBeing requires a user-specified string.
type AreBeing struct {
	Str string
}

func (op *AreBeing) String() (ret string) {
	return op.Str
}

const AreBeing_Are = "$ARE"
const AreBeing_Is = "$IS"

func (*AreBeing) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AreBeing,
		Uses: composer.Type_Str,
		Choices: []string{
			AreBeing_Are, AreBeing_Is,
		},
		Strings: []string{
			"are", "is",
		},
	}
}

const Type_AreBeing = "are_being"

func (op *AreBeing) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AreBeing_Detailed_Marshal(n, op)
}
func (op *AreBeing) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AreBeing_Detailed_Unmarshal(n, b, op)
}
func AreBeing_Detailed_Marshal(n jsonexp.Context, val *AreBeing) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_AreBeing,
		Value: val.Str,
	})
}

func AreBeing_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AreBeing) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_AreBeing, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// AreEither requires a user-specified string.
type AreEither struct {
	Str string
}

func (op *AreEither) String() (ret string) {
	return op.Str
}

const AreEither_Canbe = "$CANBE"
const AreEither_Either = "$EITHER"

func (*AreEither) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AreEither,
		Uses: composer.Type_Str,
		Choices: []string{
			AreEither_Canbe, AreEither_Either,
		},
		Strings: []string{
			"canbe", "either",
		},
	}
}

const Type_AreEither = "are_either"

func (op *AreEither) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AreEither_Detailed_Marshal(n, op)
}
func (op *AreEither) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AreEither_Detailed_Unmarshal(n, b, op)
}
func AreEither_Detailed_Marshal(n jsonexp.Context, val *AreEither) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_AreEither,
		Value: val.Str,
	})
}

func AreEither_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AreEither) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_AreEither, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// Argument
type Argument struct {
	At   reader.Position `if:"internal"`
	Name string          `if:"label=_,type=text"`
	From rt.Assignment   `if:"label=from"`
}

func (*Argument) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Argument,
		Uses: composer.Type_Flow,
		Lede: "arg",
	}
}

const Type_Argument = "argument"
const Argument_Name = "$NAME"
const Argument_From = "$FROM"

func (op *Argument) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Argument_Detailed_Marshal(n, op)
}
func (op *Argument) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Argument_Detailed_Unmarshal(n, b, op)
}

func Argument_Detailed_Marshal(n jsonexp.Context, val *Argument) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Argument_Name] = b
	}
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.From); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Argument_From] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_Argument,
			Fields: fields,
		})
	}
	return
}

func Argument_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Argument) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Argument, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Argument_Name], &out.Name); e != nil {
		err = errutil.New(Type_Argument+"."+Argument_Name, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[Argument_From], &out.From); e != nil {
		err = errutil.New(Type_Argument+"."+Argument_From, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func Argument_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Argument) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := Argument_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_Argument, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Argument_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Argument) (err error) {
	var vals []Argument
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_Argument, "-", e)
		} else {
			vals = make([]Argument, len(msgs))
			for i, msg := range msgs {
				if e := Argument_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_Argument, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func Argument_Detailed_Optional_Marshal(n jsonexp.Context, val **Argument) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Argument_Detailed_Marshal(n, ptr)
	}
	return
}
func Argument_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Argument) (err error) {
	if len(b) > 0 {
		var el Argument
		if e := Argument_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Argument, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Arguments
type Arguments struct {
	At   reader.Position `if:"internal"`
	Args []Argument      `if:"label=_"`
}

func (*Arguments) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Arguments,
		Uses: composer.Type_Flow,
		Lede: "args",
	}
}

const Type_Arguments = "arguments"
const Arguments_Args = "$ARGS"

func (op *Arguments) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Arguments_Detailed_Marshal(n, op)
}
func (op *Arguments) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Arguments_Detailed_Unmarshal(n, b, op)
}

func Arguments_Detailed_Marshal(n jsonexp.Context, val *Arguments) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Argument_Detailed_Repeats_Marshal(n, &val.Args); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Arguments_Args] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_Arguments,
			Fields: fields,
		})
	}
	return
}

func Arguments_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Arguments) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Arguments, "-", e)
	} else if e := Argument_Detailed_Repeats_Unmarshal(n, msg.Fields[Arguments_Args], &out.Args); e != nil {
		err = errutil.New(Type_Arguments+"."+Arguments_Args, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func Arguments_Detailed_Optional_Marshal(n jsonexp.Context, val **Arguments) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Arguments_Detailed_Marshal(n, ptr)
	}
	return
}
func Arguments_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Arguments) (err error) {
	if len(b) > 0 {
		var el Arguments
		if e := Arguments_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Arguments, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Aspect requires a user-specified string.
type Aspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Aspect) String() (ret string) {
	return op.Str
}

func (*Aspect) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Aspect,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_Aspect = "aspect"

func (op *Aspect) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Aspect_Detailed_Marshal(n, op)
}
func (op *Aspect) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Aspect_Detailed_Unmarshal(n, b, op)
}
func Aspect_Detailed_Marshal(n jsonexp.Context, val *Aspect) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_Aspect,
		Value: val.Str,
	})
}

func Aspect_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Aspect) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_Aspect, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// AspectTraits
type AspectTraits struct {
	Aspect      Aspect      `if:"label=_"`
	TraitPhrase TraitPhrase `if:"label=trait_phrase"`
}

func (*AspectTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AspectTraits,
		Uses: composer.Type_Flow,
	}
}

const Type_AspectTraits = "aspect_traits"
const AspectTraits_Aspect = "$ASPECT"
const AspectTraits_TraitPhrase = "$TRAIT_PHRASE"

func (op *AspectTraits) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return AspectTraits_Detailed_Marshal(n, op)
}
func (op *AspectTraits) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return AspectTraits_Detailed_Unmarshal(n, b, op)
}

func AspectTraits_Detailed_Marshal(n jsonexp.Context, val *AspectTraits) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Aspect_Detailed_Marshal(n, &val.Aspect); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AspectTraits_Aspect] = b
	}
	if b, e := TraitPhrase_Detailed_Marshal(n, &val.TraitPhrase); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[AspectTraits_TraitPhrase] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_AspectTraits,
			Fields: fields,
		})
	}
	return
}

func AspectTraits_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *AspectTraits) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_AspectTraits, "-", e)
	} else if e := Aspect_Detailed_Unmarshal(n, msg.Fields[AspectTraits_Aspect], &out.Aspect); e != nil {
		err = errutil.New(Type_AspectTraits+"."+AspectTraits_Aspect, "-", e)
	} else if e := TraitPhrase_Detailed_Unmarshal(n, msg.Fields[AspectTraits_TraitPhrase], &out.TraitPhrase); e != nil {
		err = errutil.New(Type_AspectTraits+"."+AspectTraits_TraitPhrase, "-", e)
	}
	return
}

func AspectTraits_Detailed_Optional_Marshal(n jsonexp.Context, val **AspectTraits) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = AspectTraits_Detailed_Marshal(n, ptr)
	}
	return
}
func AspectTraits_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **AspectTraits) (err error) {
	if len(b) > 0 {
		var el AspectTraits
		if e := AspectTraits_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_AspectTraits, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// BoxedNumber
type BoxedNumber struct {
	Number float64 `if:"label=_,type=number"`
}

func (*BoxedNumber) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BoxedNumber,
		Uses: composer.Type_Flow,
	}
}

const Type_BoxedNumber = "boxed_number"
const BoxedNumber_Number = "$NUMBER"

func (op *BoxedNumber) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return BoxedNumber_Detailed_Marshal(n, op)
}
func (op *BoxedNumber) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return BoxedNumber_Detailed_Unmarshal(n, b, op)
}

func BoxedNumber_Detailed_Marshal(n jsonexp.Context, val *BoxedNumber) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Number_Detailed_Override_Marshal(n, &val.Number); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[BoxedNumber_Number] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_BoxedNumber,
			Fields: fields,
		})
	}
	return
}

func BoxedNumber_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *BoxedNumber) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_BoxedNumber, "-", e)
	} else if e := value.Number_Detailed_Override_Unmarshal(n, msg.Fields[BoxedNumber_Number], &out.Number); e != nil {
		err = errutil.New(Type_BoxedNumber+"."+BoxedNumber_Number, "-", e)
	}
	return
}

func BoxedNumber_Detailed_Optional_Marshal(n jsonexp.Context, val **BoxedNumber) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = BoxedNumber_Detailed_Marshal(n, ptr)
	}
	return
}
func BoxedNumber_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **BoxedNumber) (err error) {
	if len(b) > 0 {
		var el BoxedNumber
		if e := BoxedNumber_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_BoxedNumber, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// BoxedText
type BoxedText struct {
	Text string `if:"label=_,type=text"`
}

func (*BoxedText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BoxedText,
		Uses: composer.Type_Flow,
	}
}

const Type_BoxedText = "boxed_text"
const BoxedText_Text = "$TEXT"

func (op *BoxedText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return BoxedText_Detailed_Marshal(n, op)
}
func (op *BoxedText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return BoxedText_Detailed_Unmarshal(n, b, op)
}

func BoxedText_Detailed_Marshal(n jsonexp.Context, val *BoxedText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Text); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[BoxedText_Text] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_BoxedText,
			Fields: fields,
		})
	}
	return
}

func BoxedText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *BoxedText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_BoxedText, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[BoxedText_Text], &out.Text); e != nil {
		err = errutil.New(Type_BoxedText+"."+BoxedText_Text, "-", e)
	}
	return
}

func BoxedText_Detailed_Optional_Marshal(n jsonexp.Context, val **BoxedText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = BoxedText_Detailed_Marshal(n, ptr)
	}
	return
}
func BoxedText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **BoxedText) (err error) {
	if len(b) > 0 {
		var el BoxedText
		if e := BoxedText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_BoxedText, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Certainties
type Certainties struct {
	PluralKinds PluralKinds `if:"label=_"`
	AreBeing    AreBeing    `if:"label=are_being"`
	Certainty   Certainty   `if:"label=certainty"`
	Trait       Trait       `if:"label=trait"`
}

func (*Certainties) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Certainties,
		Uses: composer.Type_Flow,
	}
}

const Type_Certainties = "certainties"
const Certainties_PluralKinds = "$PLURAL_KINDS"
const Certainties_AreBeing = "$ARE_BEING"
const Certainties_Certainty = "$CERTAINTY"
const Certainties_Trait = "$TRAIT"

func (op *Certainties) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Certainties_Detailed_Marshal(n, op)
}
func (op *Certainties) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Certainties_Detailed_Unmarshal(n, b, op)
}

func Certainties_Detailed_Marshal(n jsonexp.Context, val *Certainties) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := PluralKinds_Detailed_Marshal(n, &val.PluralKinds); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Certainties_PluralKinds] = b
	}
	if b, e := AreBeing_Detailed_Marshal(n, &val.AreBeing); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Certainties_AreBeing] = b
	}
	if b, e := Certainty_Detailed_Marshal(n, &val.Certainty); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Certainties_Certainty] = b
	}
	if b, e := Trait_Detailed_Marshal(n, &val.Trait); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Certainties_Trait] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Certainties,
			Fields: fields,
		})
	}
	return
}

func Certainties_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Certainties) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Certainties, "-", e)
	} else if e := PluralKinds_Detailed_Unmarshal(n, msg.Fields[Certainties_PluralKinds], &out.PluralKinds); e != nil {
		err = errutil.New(Type_Certainties+"."+Certainties_PluralKinds, "-", e)
	} else if e := AreBeing_Detailed_Unmarshal(n, msg.Fields[Certainties_AreBeing], &out.AreBeing); e != nil {
		err = errutil.New(Type_Certainties+"."+Certainties_AreBeing, "-", e)
	} else if e := Certainty_Detailed_Unmarshal(n, msg.Fields[Certainties_Certainty], &out.Certainty); e != nil {
		err = errutil.New(Type_Certainties+"."+Certainties_Certainty, "-", e)
	} else if e := Trait_Detailed_Unmarshal(n, msg.Fields[Certainties_Trait], &out.Trait); e != nil {
		err = errutil.New(Type_Certainties+"."+Certainties_Trait, "-", e)
	}
	return
}

func Certainties_Detailed_Optional_Marshal(n jsonexp.Context, val **Certainties) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Certainties_Detailed_Marshal(n, ptr)
	}
	return
}
func Certainties_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Certainties) (err error) {
	if len(b) > 0 {
		var el Certainties
		if e := Certainties_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Certainties, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Certainty requires a user-specified string.
type Certainty struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Certainty) String() (ret string) {
	return op.Str
}

const Certainty_Usually = "$USUALLY"
const Certainty_Always = "$ALWAYS"
const Certainty_Seldom = "$SELDOM"
const Certainty_Never = "$NEVER"

func (*Certainty) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Certainty,
		Uses: composer.Type_Str,
		Choices: []string{
			Certainty_Usually, Certainty_Always, Certainty_Seldom, Certainty_Never,
		},
		Strings: []string{
			"usually", "always", "seldom", "never",
		},
	}
}

const Type_Certainty = "certainty"

func (op *Certainty) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Certainty_Detailed_Marshal(n, op)
}
func (op *Certainty) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Certainty_Detailed_Unmarshal(n, b, op)
}
func Certainty_Detailed_Marshal(n jsonexp.Context, val *Certainty) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_Certainty,
		Value: val.Str,
	})
}

func Certainty_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Certainty) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_Certainty, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// Comment Information about the story for you and other authors.
type Comment struct {
	Lines value.Lines `if:"label=_"`
}

func (*Comment) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Comment,
		Uses: composer.Type_Flow,
	}
}

const Type_Comment = "comment"
const Comment_Lines = "$LINES"

func (op *Comment) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Comment_Detailed_Marshal(n, op)
}
func (op *Comment) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Comment_Detailed_Unmarshal(n, b, op)
}

func Comment_Detailed_Marshal(n jsonexp.Context, val *Comment) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Lines_Detailed_Marshal(n, &val.Lines); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Comment_Lines] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Comment,
			Fields: fields,
		})
	}
	return
}

func Comment_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Comment) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Comment, "-", e)
	} else if e := value.Lines_Detailed_Unmarshal(n, msg.Fields[Comment_Lines], &out.Lines); e != nil {
		err = errutil.New(Type_Comment+"."+Comment_Lines, "-", e)
	}
	return
}

func Comment_Detailed_Optional_Marshal(n jsonexp.Context, val **Comment) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Comment_Detailed_Marshal(n, ptr)
	}
	return
}
func Comment_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Comment) (err error) {
	if len(b) > 0 {
		var el Comment
		if e := Comment_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Comment, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// CommonAction
type CommonAction struct {
	At            reader.Position `if:"internal"`
	Kind          SingularKind    `if:"label=kind"`
	ActionContext *ActionContext  `if:"label=action_context,optional"`
}

func (*CommonAction) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CommonAction,
		Uses: composer.Type_Flow,
	}
}

const Type_CommonAction = "common_action"
const CommonAction_Kind = "$KIND"
const CommonAction_ActionContext = "$ACTION_CONTEXT"

func (op *CommonAction) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CommonAction_Detailed_Marshal(n, op)
}
func (op *CommonAction) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CommonAction_Detailed_Unmarshal(n, b, op)
}

func CommonAction_Detailed_Marshal(n jsonexp.Context, val *CommonAction) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := SingularKind_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CommonAction_Kind] = b
	}
	if b, e := ActionContext_Detailed_Optional_Marshal(n, &val.ActionContext); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CommonAction_ActionContext] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_CommonAction,
			Fields: fields,
		})
	}
	return
}

func CommonAction_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CommonAction) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_CommonAction, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[CommonAction_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_CommonAction+"."+CommonAction_Kind, "-", e)
	} else if e := ActionContext_Detailed_Optional_Unmarshal(n, msg.Fields[CommonAction_ActionContext], &out.ActionContext); e != nil {
		err = errutil.New(Type_CommonAction+"."+CommonAction_ActionContext, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func CommonAction_Detailed_Optional_Marshal(n jsonexp.Context, val **CommonAction) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CommonAction_Detailed_Marshal(n, ptr)
	}
	return
}
func CommonAction_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CommonAction) (err error) {
	if len(b) > 0 {
		var el CommonAction
		if e := CommonAction_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_CommonAction, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// CountOf A guard which returns true based on a counter.
type CountOf struct {
	At      reader.Position `if:"internal"`
	Trigger core.Trigger    `if:"label=trigger"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CountOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CountOf,
		Uses: composer.Type_Flow,
	}
}

const Type_CountOf = "count_of"
const CountOf_Trigger = "$TRIGGER"
const CountOf_Num = "$NUM"

func (op *CountOf) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CountOf_Detailed_Marshal(n, op)
}
func (op *CountOf) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CountOf_Detailed_Unmarshal(n, b, op)
}

func CountOf_Detailed_Marshal(n jsonexp.Context, val *CountOf) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := core.Trigger_Detailed_Marshal(n, &val.Trigger); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CountOf_Trigger] = b
	}
	if b, e := rt.NumberEval_Detailed_Marshal(n, &val.Num); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CountOf_Num] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_CountOf,
			Fields: fields,
		})
	}
	return
}

func CountOf_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CountOf) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_CountOf, "-", e)
	} else if e := core.Trigger_Detailed_Unmarshal(n, msg.Fields[CountOf_Trigger], &out.Trigger); e != nil {
		err = errutil.New(Type_CountOf+"."+CountOf_Trigger, "-", e)
	} else if e := rt.NumberEval_Detailed_Unmarshal(n, msg.Fields[CountOf_Num], &out.Num); e != nil {
		err = errutil.New(Type_CountOf+"."+CountOf_Num, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func CountOf_Detailed_Optional_Marshal(n jsonexp.Context, val **CountOf) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CountOf_Detailed_Marshal(n, ptr)
	}
	return
}
func CountOf_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CountOf) (err error) {
	if len(b) > 0 {
		var el CountOf
		if e := CountOf_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_CountOf, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// CycleText
type CycleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*CycleText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CycleText,
		Uses: composer.Type_Flow,
	}
}

const Type_CycleText = "cycle_text"
const CycleText_Parts = "$PARTS"

func (op *CycleText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return CycleText_Detailed_Marshal(n, op)
}
func (op *CycleText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return CycleText_Detailed_Unmarshal(n, b, op)
}

func CycleText_Detailed_Marshal(n jsonexp.Context, val *CycleText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Repeats_Marshal(n, &val.Parts); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[CycleText_Parts] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_CycleText,
			Fields: fields,
		})
	}
	return
}

func CycleText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *CycleText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_CycleText, "-", e)
	} else if e := rt.TextEval_Detailed_Repeats_Unmarshal(n, msg.Fields[CycleText_Parts], &out.Parts); e != nil {
		err = errutil.New(Type_CycleText+"."+CycleText_Parts, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func CycleText_Detailed_Optional_Marshal(n jsonexp.Context, val **CycleText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = CycleText_Detailed_Marshal(n, ptr)
	}
	return
}
func CycleText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **CycleText) (err error) {
	if len(b) > 0 {
		var el CycleText
		if e := CycleText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_CycleText, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Determine
type Determine struct {
	Name      value.PatternName `if:"label=_"`
	Arguments *Arguments        `if:"label=arguments,optional"`
}

func (*Determine) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Determine,
		Uses: composer.Type_Flow,
	}
}

const Type_Determine = "determine"
const Determine_Name = "$NAME"
const Determine_Arguments = "$ARGUMENTS"

func (op *Determine) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Determine_Detailed_Marshal(n, op)
}
func (op *Determine) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Determine_Detailed_Unmarshal(n, b, op)
}

func Determine_Detailed_Marshal(n jsonexp.Context, val *Determine) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.PatternName_Detailed_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Determine_Name] = b
	}
	if b, e := Arguments_Detailed_Optional_Marshal(n, &val.Arguments); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Determine_Arguments] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Determine,
			Fields: fields,
		})
	}
	return
}

func Determine_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Determine) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Determine, "-", e)
	} else if e := value.PatternName_Detailed_Unmarshal(n, msg.Fields[Determine_Name], &out.Name); e != nil {
		err = errutil.New(Type_Determine+"."+Determine_Name, "-", e)
	} else if e := Arguments_Detailed_Optional_Unmarshal(n, msg.Fields[Determine_Arguments], &out.Arguments); e != nil {
		err = errutil.New(Type_Determine+"."+Determine_Arguments, "-", e)
	}
	return
}

func Determine_Detailed_Optional_Marshal(n jsonexp.Context, val **Determine) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Determine_Detailed_Marshal(n, ptr)
	}
	return
}
func Determine_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Determine) (err error) {
	if len(b) > 0 {
		var el Determine
		if e := Determine_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Determine, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Determiner requires a user-specified string.
type Determiner struct {
	Str string
}

func (op *Determiner) String() (ret string) {
	return op.Str
}

const Determiner_A = "$A"
const Determiner_An = "$AN"
const Determiner_The = "$THE"
const Determiner_Our = "$OUR"

func (*Determiner) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Determiner,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			Determiner_A, Determiner_An, Determiner_The, Determiner_Our,
		},
		Strings: []string{
			"a", "an", "the", "our",
		},
	}
}

const Type_Determiner = "determiner"

func (op *Determiner) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Determiner_Detailed_Marshal(n, op)
}
func (op *Determiner) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Determiner_Detailed_Unmarshal(n, b, op)
}
func Determiner_Detailed_Marshal(n jsonexp.Context, val *Determiner) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_Determiner,
		Value: val.Str,
	})
}

func Determiner_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Determiner) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_Determiner, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// EventBlock Listeners let objects in the game world react to changes before, during, or after they happen.
type EventBlock struct {
	At       reader.Position `if:"internal"`
	Target   EventTarget     `if:"label=target"`
	Handlers []EventHandler  `if:"label=handlers"`
}

func (*EventBlock) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EventBlock,
		Uses: composer.Type_Flow,
	}
}

const Type_EventBlock = "event_block"
const EventBlock_Target = "$TARGET"
const EventBlock_Handlers = "$HANDLERS"

func (op *EventBlock) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EventBlock_Detailed_Marshal(n, op)
}
func (op *EventBlock) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EventBlock_Detailed_Unmarshal(n, b, op)
}

func EventBlock_Detailed_Marshal(n jsonexp.Context, val *EventBlock) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := EventTarget_Detailed_Marshal(n, &val.Target); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EventBlock_Target] = b
	}
	if b, e := EventHandler_Detailed_Repeats_Marshal(n, &val.Handlers); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EventBlock_Handlers] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_EventBlock,
			Fields: fields,
		})
	}
	return
}

func EventBlock_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EventBlock) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_EventBlock, "-", e)
	} else if e := EventTarget_Detailed_Unmarshal(n, msg.Fields[EventBlock_Target], &out.Target); e != nil {
		err = errutil.New(Type_EventBlock+"."+EventBlock_Target, "-", e)
	} else if e := EventHandler_Detailed_Repeats_Unmarshal(n, msg.Fields[EventBlock_Handlers], &out.Handlers); e != nil {
		err = errutil.New(Type_EventBlock+"."+EventBlock_Handlers, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func EventBlock_Detailed_Optional_Marshal(n jsonexp.Context, val **EventBlock) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = EventBlock_Detailed_Marshal(n, ptr)
	}
	return
}
func EventBlock_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **EventBlock) (err error) {
	if len(b) > 0 {
		var el EventBlock
		if e := EventBlock_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_EventBlock, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// EventHandler
type EventHandler struct {
	EventPhase   EventPhase     `if:"label=_"`
	Event        EventName      `if:"label=event"`
	Locals       *PatternLocals `if:"label=locals,optional"`
	PatternRules PatternRules   `if:"label=pattern_rules"`
}

func (*EventHandler) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EventHandler,
		Uses: composer.Type_Flow,
	}
}

const Type_EventHandler = "event_handler"
const EventHandler_EventPhase = "$EVENT_PHASE"
const EventHandler_Event = "$EVENT"
const EventHandler_Locals = "$LOCALS"
const EventHandler_PatternRules = "$PATTERN_RULES"

func (op *EventHandler) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EventHandler_Detailed_Marshal(n, op)
}
func (op *EventHandler) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EventHandler_Detailed_Unmarshal(n, b, op)
}

func EventHandler_Detailed_Marshal(n jsonexp.Context, val *EventHandler) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := EventPhase_Detailed_Marshal(n, &val.EventPhase); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EventHandler_EventPhase] = b
	}
	if b, e := EventName_Detailed_Marshal(n, &val.Event); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EventHandler_Event] = b
	}
	if b, e := PatternLocals_Detailed_Optional_Marshal(n, &val.Locals); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EventHandler_Locals] = b
	}
	if b, e := PatternRules_Detailed_Marshal(n, &val.PatternRules); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[EventHandler_PatternRules] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_EventHandler,
			Fields: fields,
		})
	}
	return
}

func EventHandler_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EventHandler) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_EventHandler, "-", e)
	} else if e := EventPhase_Detailed_Unmarshal(n, msg.Fields[EventHandler_EventPhase], &out.EventPhase); e != nil {
		err = errutil.New(Type_EventHandler+"."+EventHandler_EventPhase, "-", e)
	} else if e := EventName_Detailed_Unmarshal(n, msg.Fields[EventHandler_Event], &out.Event); e != nil {
		err = errutil.New(Type_EventHandler+"."+EventHandler_Event, "-", e)
	} else if e := PatternLocals_Detailed_Optional_Unmarshal(n, msg.Fields[EventHandler_Locals], &out.Locals); e != nil {
		err = errutil.New(Type_EventHandler+"."+EventHandler_Locals, "-", e)
	} else if e := PatternRules_Detailed_Unmarshal(n, msg.Fields[EventHandler_PatternRules], &out.PatternRules); e != nil {
		err = errutil.New(Type_EventHandler+"."+EventHandler_PatternRules, "-", e)
	}
	return
}

func EventHandler_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]EventHandler) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := EventHandler_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_EventHandler, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func EventHandler_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]EventHandler) (err error) {
	var vals []EventHandler
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_EventHandler, "-", e)
		} else {
			vals = make([]EventHandler, len(msgs))
			for i, msg := range msgs {
				if e := EventHandler_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_EventHandler, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func EventHandler_Detailed_Optional_Marshal(n jsonexp.Context, val **EventHandler) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = EventHandler_Detailed_Marshal(n, ptr)
	}
	return
}
func EventHandler_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **EventHandler) (err error) {
	if len(b) > 0 {
		var el EventHandler
		if e := EventHandler_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_EventHandler, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// EventName requires a user-specified string.
type EventName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *EventName) String() (ret string) {
	return op.Str
}

func (*EventName) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_EventName,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_EventName = "event_name"

func (op *EventName) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EventName_Detailed_Marshal(n, op)
}
func (op *EventName) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EventName_Detailed_Unmarshal(n, b, op)
}
func EventName_Detailed_Marshal(n jsonexp.Context, val *EventName) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_EventName,
		Value: val.Str,
	})
}

func EventName_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EventName) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_EventName, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// EventPhase requires a user-specified string.
type EventPhase struct {
	Str string
}

func (op *EventPhase) String() (ret string) {
	return op.Str
}

const EventPhase_Before = "$BEFORE"
const EventPhase_While = "$WHILE"
const EventPhase_After = "$AFTER"

func (*EventPhase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EventPhase,
		Uses: composer.Type_Str,
		Choices: []string{
			EventPhase_Before, EventPhase_While, EventPhase_After,
		},
		Strings: []string{
			"before", "while", "after",
		},
	}
}

const Type_EventPhase = "event_phase"

func (op *EventPhase) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EventPhase_Detailed_Marshal(n, op)
}
func (op *EventPhase) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EventPhase_Detailed_Unmarshal(n, b, op)
}
func EventPhase_Detailed_Marshal(n jsonexp.Context, val *EventPhase) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_EventPhase,
		Value: val.Str,
	})
}

func EventPhase_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EventPhase) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_EventPhase, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// EventTarget swaps between various options
type EventTarget struct {
	Opt interface{}
}

const EventTarget_Kinds = "$KINDS"
const EventTarget_NamedNoun = "$NAMED_NOUN"

func (*EventTarget) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EventTarget,
		Uses: composer.Type_Swap,
		Choices: []string{
			EventTarget_Kinds, EventTarget_NamedNoun,
		},
		Swaps: []interface{}{
			(*PluralKinds)(nil),
			(*NamedNoun)(nil),
		},
	}
}

const Type_EventTarget = "event_target"

func (op *EventTarget) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PluralKinds:
		ret, okay = EventTarget_Kinds, true
	case *NamedNoun:
		ret, okay = EventTarget_NamedNoun, true
	}
	return
}
func (op *EventTarget) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return EventTarget_Detailed_Marshal(n, op)
}
func (op *EventTarget) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return EventTarget_Detailed_Unmarshal(n, b, op)
}

func EventTarget_Detailed_Marshal(n jsonexp.Context, val *EventTarget) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_EventTarget)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_EventTarget, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{
					Type: Type_EventTarget,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func EventTarget_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *EventTarget) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_EventTarget, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case EventTarget_Kinds:
				ptr = new(PluralKinds)
			case EventTarget_NamedNoun:
				ptr = new(NamedNoun)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_EventTarget, "-", e)
			} else {
				out.Opt = ptr
			}
		}
	}
	return
}

// ExtType swaps between various options
type ExtType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ExtType_Numbers = "$NUMBERS"
const ExtType_TextList = "$TEXT_LIST"
const ExtType_Record = "$RECORD"
const ExtType_Records = "$RECORDS"

func (*ExtType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ExtType,
		Uses: composer.Type_Swap,
		Choices: []string{
			ExtType_Numbers, ExtType_TextList, ExtType_Record, ExtType_Records,
		},
		Swaps: []interface{}{
			(*NumberList)(nil),
			(*TextList)(nil),
			(*RecordType)(nil),
			(*RecordList)(nil),
		},
	}
}

const Type_ExtType = "ext_type"

func (op *ExtType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *NumberList:
		ret, okay = ExtType_Numbers, true
	case *TextList:
		ret, okay = ExtType_TextList, true
	case *RecordType:
		ret, okay = ExtType_Record, true
	case *RecordList:
		ret, okay = ExtType_Records, true
	}
	return
}
func (op *ExtType) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ExtType_Detailed_Marshal(n, op)
}
func (op *ExtType) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ExtType_Detailed_Unmarshal(n, b, op)
}

func ExtType_Detailed_Marshal(n jsonexp.Context, val *ExtType) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_ExtType)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_ExtType, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{Id: val.At.Offset,
					Type: Type_ExtType,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func ExtType_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ExtType) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_ExtType, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case ExtType_Numbers:
				ptr = new(NumberList)
			case ExtType_TextList:
				ptr = new(TextList)
			case ExtType_Record:
				ptr = new(RecordType)
			case ExtType_Records:
				ptr = new(RecordList)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_ExtType, "-", e)
			} else {
				out.Opt = ptr
				out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
			}
		}
	}
	return
}

// GrammarDecl
type GrammarDecl struct {
	Grammar grammar.GrammarMaker `if:"label=_"`
}

func (*GrammarDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_GrammarDecl,
		Uses: composer.Type_Flow,
	}
}

const Type_GrammarDecl = "grammar_decl"
const GrammarDecl_Grammar = "$GRAMMAR"

func (op *GrammarDecl) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return GrammarDecl_Detailed_Marshal(n, op)
}
func (op *GrammarDecl) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return GrammarDecl_Detailed_Unmarshal(n, b, op)
}

func GrammarDecl_Detailed_Marshal(n jsonexp.Context, val *GrammarDecl) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := grammar.GrammarMaker_Detailed_Marshal(n, &val.Grammar); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[GrammarDecl_Grammar] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_GrammarDecl,
			Fields: fields,
		})
	}
	return
}

func GrammarDecl_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *GrammarDecl) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_GrammarDecl, "-", e)
	} else if e := grammar.GrammarMaker_Detailed_Unmarshal(n, msg.Fields[GrammarDecl_Grammar], &out.Grammar); e != nil {
		err = errutil.New(Type_GrammarDecl+"."+GrammarDecl_Grammar, "-", e)
	}
	return
}

func GrammarDecl_Detailed_Optional_Marshal(n jsonexp.Context, val **GrammarDecl) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = GrammarDecl_Detailed_Marshal(n, ptr)
	}
	return
}
func GrammarDecl_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **GrammarDecl) (err error) {
	if len(b) > 0 {
		var el GrammarDecl
		if e := GrammarDecl_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_GrammarDecl, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// KindOfNoun
type KindOfNoun struct {
	AreAn        AreAn         `if:"label=_"`
	Trait        []Trait       `if:"label=trait,optional"`
	Kind         SingularKind  `if:"label=kind"`
	NounRelation *NounRelation `if:"label=noun_relation,optional"`
}

func (*KindOfNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindOfNoun,
		Uses: composer.Type_Flow,
	}
}

const Type_KindOfNoun = "kind_of_noun"
const KindOfNoun_AreAn = "$ARE_AN"
const KindOfNoun_Trait = "$TRAIT"
const KindOfNoun_Kind = "$KIND"
const KindOfNoun_NounRelation = "$NOUN_RELATION"

func (op *KindOfNoun) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return KindOfNoun_Detailed_Marshal(n, op)
}
func (op *KindOfNoun) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return KindOfNoun_Detailed_Unmarshal(n, b, op)
}

func KindOfNoun_Detailed_Marshal(n jsonexp.Context, val *KindOfNoun) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := AreAn_Detailed_Marshal(n, &val.AreAn); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindOfNoun_AreAn] = b
	}
	if b, e := Trait_Detailed_Repeats_Marshal(n, &val.Trait); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindOfNoun_Trait] = b
	}
	if b, e := SingularKind_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindOfNoun_Kind] = b
	}
	if b, e := NounRelation_Detailed_Optional_Marshal(n, &val.NounRelation); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindOfNoun_NounRelation] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_KindOfNoun,
			Fields: fields,
		})
	}
	return
}

func KindOfNoun_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *KindOfNoun) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_KindOfNoun, "-", e)
	} else if e := AreAn_Detailed_Unmarshal(n, msg.Fields[KindOfNoun_AreAn], &out.AreAn); e != nil {
		err = errutil.New(Type_KindOfNoun+"."+KindOfNoun_AreAn, "-", e)
	} else if e := Trait_Detailed_Repeats_Unmarshal(n, msg.Fields[KindOfNoun_Trait], &out.Trait); e != nil {
		err = errutil.New(Type_KindOfNoun+"."+KindOfNoun_Trait, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[KindOfNoun_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_KindOfNoun+"."+KindOfNoun_Kind, "-", e)
	} else if e := NounRelation_Detailed_Optional_Unmarshal(n, msg.Fields[KindOfNoun_NounRelation], &out.NounRelation); e != nil {
		err = errutil.New(Type_KindOfNoun+"."+KindOfNoun_NounRelation, "-", e)
	}
	return
}

func KindOfNoun_Detailed_Optional_Marshal(n jsonexp.Context, val **KindOfNoun) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = KindOfNoun_Detailed_Marshal(n, ptr)
	}
	return
}
func KindOfNoun_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **KindOfNoun) (err error) {
	if len(b) > 0 {
		var el KindOfNoun
		if e := KindOfNoun_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_KindOfNoun, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// KindOfRelation
type KindOfRelation struct {
	Relation            value.RelationName  `if:"label=_"`
	RelationCardinality RelationCardinality `if:"label=relation_cardinality"`
}

func (*KindOfRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindOfRelation,
		Uses: composer.Type_Flow,
	}
}

const Type_KindOfRelation = "kind_of_relation"
const KindOfRelation_Relation = "$RELATION"
const KindOfRelation_RelationCardinality = "$RELATION_CARDINALITY"

func (op *KindOfRelation) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return KindOfRelation_Detailed_Marshal(n, op)
}
func (op *KindOfRelation) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return KindOfRelation_Detailed_Unmarshal(n, b, op)
}

func KindOfRelation_Detailed_Marshal(n jsonexp.Context, val *KindOfRelation) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.RelationName_Detailed_Marshal(n, &val.Relation); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindOfRelation_Relation] = b
	}
	if b, e := RelationCardinality_Detailed_Marshal(n, &val.RelationCardinality); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindOfRelation_RelationCardinality] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_KindOfRelation,
			Fields: fields,
		})
	}
	return
}

func KindOfRelation_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *KindOfRelation) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_KindOfRelation, "-", e)
	} else if e := value.RelationName_Detailed_Unmarshal(n, msg.Fields[KindOfRelation_Relation], &out.Relation); e != nil {
		err = errutil.New(Type_KindOfRelation+"."+KindOfRelation_Relation, "-", e)
	} else if e := RelationCardinality_Detailed_Unmarshal(n, msg.Fields[KindOfRelation_RelationCardinality], &out.RelationCardinality); e != nil {
		err = errutil.New(Type_KindOfRelation+"."+KindOfRelation_RelationCardinality, "-", e)
	}
	return
}

func KindOfRelation_Detailed_Optional_Marshal(n jsonexp.Context, val **KindOfRelation) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = KindOfRelation_Detailed_Marshal(n, ptr)
	}
	return
}
func KindOfRelation_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **KindOfRelation) (err error) {
	if len(b) > 0 {
		var el KindOfRelation
		if e := KindOfRelation_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_KindOfRelation, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// KindsOfAspect
type KindsOfAspect struct {
	Aspect Aspect `if:"label=_"`
}

func (*KindsOfAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsOfAspect,
		Uses: composer.Type_Flow,
	}
}

const Type_KindsOfAspect = "kinds_of_aspect"
const KindsOfAspect_Aspect = "$ASPECT"

func (op *KindsOfAspect) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return KindsOfAspect_Detailed_Marshal(n, op)
}
func (op *KindsOfAspect) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return KindsOfAspect_Detailed_Unmarshal(n, b, op)
}

func KindsOfAspect_Detailed_Marshal(n jsonexp.Context, val *KindsOfAspect) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Aspect_Detailed_Marshal(n, &val.Aspect); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindsOfAspect_Aspect] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_KindsOfAspect,
			Fields: fields,
		})
	}
	return
}

func KindsOfAspect_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *KindsOfAspect) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_KindsOfAspect, "-", e)
	} else if e := Aspect_Detailed_Unmarshal(n, msg.Fields[KindsOfAspect_Aspect], &out.Aspect); e != nil {
		err = errutil.New(Type_KindsOfAspect+"."+KindsOfAspect_Aspect, "-", e)
	}
	return
}

func KindsOfAspect_Detailed_Optional_Marshal(n jsonexp.Context, val **KindsOfAspect) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = KindsOfAspect_Detailed_Marshal(n, ptr)
	}
	return
}
func KindsOfAspect_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **KindsOfAspect) (err error) {
	if len(b) > 0 {
		var el KindsOfAspect
		if e := KindsOfAspect_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_KindsOfAspect, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// KindsOfKind
type KindsOfKind struct {
	PluralKinds  PluralKinds  `if:"label=_"`
	SingularKind SingularKind `if:"label=singular_kind"`
}

func (*KindsOfKind) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsOfKind,
		Uses: composer.Type_Flow,
	}
}

const Type_KindsOfKind = "kinds_of_kind"
const KindsOfKind_PluralKinds = "$PLURAL_KINDS"
const KindsOfKind_SingularKind = "$SINGULAR_KIND"

func (op *KindsOfKind) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return KindsOfKind_Detailed_Marshal(n, op)
}
func (op *KindsOfKind) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return KindsOfKind_Detailed_Unmarshal(n, b, op)
}

func KindsOfKind_Detailed_Marshal(n jsonexp.Context, val *KindsOfKind) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := PluralKinds_Detailed_Marshal(n, &val.PluralKinds); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindsOfKind_PluralKinds] = b
	}
	if b, e := SingularKind_Detailed_Marshal(n, &val.SingularKind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindsOfKind_SingularKind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_KindsOfKind,
			Fields: fields,
		})
	}
	return
}

func KindsOfKind_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *KindsOfKind) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_KindsOfKind, "-", e)
	} else if e := PluralKinds_Detailed_Unmarshal(n, msg.Fields[KindsOfKind_PluralKinds], &out.PluralKinds); e != nil {
		err = errutil.New(Type_KindsOfKind+"."+KindsOfKind_PluralKinds, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[KindsOfKind_SingularKind], &out.SingularKind); e != nil {
		err = errutil.New(Type_KindsOfKind+"."+KindsOfKind_SingularKind, "-", e)
	}
	return
}

func KindsOfKind_Detailed_Optional_Marshal(n jsonexp.Context, val **KindsOfKind) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = KindsOfKind_Detailed_Marshal(n, ptr)
	}
	return
}
func KindsOfKind_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **KindsOfKind) (err error) {
	if len(b) > 0 {
		var el KindsOfKind
		if e := KindsOfKind_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_KindsOfKind, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// KindsOfRecord
type KindsOfRecord struct {
	RecordPlural RecordPlural `if:"label=_"`
}

func (*KindsOfRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsOfRecord,
		Uses: composer.Type_Flow,
	}
}

const Type_KindsOfRecord = "kinds_of_record"
const KindsOfRecord_RecordPlural = "$RECORD_PLURAL"

func (op *KindsOfRecord) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return KindsOfRecord_Detailed_Marshal(n, op)
}
func (op *KindsOfRecord) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return KindsOfRecord_Detailed_Unmarshal(n, b, op)
}

func KindsOfRecord_Detailed_Marshal(n jsonexp.Context, val *KindsOfRecord) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := RecordPlural_Detailed_Marshal(n, &val.RecordPlural); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindsOfRecord_RecordPlural] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_KindsOfRecord,
			Fields: fields,
		})
	}
	return
}

func KindsOfRecord_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *KindsOfRecord) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_KindsOfRecord, "-", e)
	} else if e := RecordPlural_Detailed_Unmarshal(n, msg.Fields[KindsOfRecord_RecordPlural], &out.RecordPlural); e != nil {
		err = errutil.New(Type_KindsOfRecord+"."+KindsOfRecord_RecordPlural, "-", e)
	}
	return
}

func KindsOfRecord_Detailed_Optional_Marshal(n jsonexp.Context, val **KindsOfRecord) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = KindsOfRecord_Detailed_Marshal(n, ptr)
	}
	return
}
func KindsOfRecord_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **KindsOfRecord) (err error) {
	if len(b) > 0 {
		var el KindsOfRecord
		if e := KindsOfRecord_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_KindsOfRecord, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// KindsPossessProperties
type KindsPossessProperties struct {
	PluralKinds  PluralKinds    `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*KindsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsPossessProperties,
		Uses: composer.Type_Flow,
	}
}

const Type_KindsPossessProperties = "kinds_possess_properties"
const KindsPossessProperties_PluralKinds = "$PLURAL_KINDS"
const KindsPossessProperties_PropertyDecl = "$PROPERTY_DECL"

func (op *KindsPossessProperties) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return KindsPossessProperties_Detailed_Marshal(n, op)
}
func (op *KindsPossessProperties) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return KindsPossessProperties_Detailed_Unmarshal(n, b, op)
}

func KindsPossessProperties_Detailed_Marshal(n jsonexp.Context, val *KindsPossessProperties) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := PluralKinds_Detailed_Marshal(n, &val.PluralKinds); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindsPossessProperties_PluralKinds] = b
	}
	if b, e := PropertyDecl_Detailed_Repeats_Marshal(n, &val.PropertyDecl); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[KindsPossessProperties_PropertyDecl] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_KindsPossessProperties,
			Fields: fields,
		})
	}
	return
}

func KindsPossessProperties_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *KindsPossessProperties) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_KindsPossessProperties, "-", e)
	} else if e := PluralKinds_Detailed_Unmarshal(n, msg.Fields[KindsPossessProperties_PluralKinds], &out.PluralKinds); e != nil {
		err = errutil.New(Type_KindsPossessProperties+"."+KindsPossessProperties_PluralKinds, "-", e)
	} else if e := PropertyDecl_Detailed_Repeats_Unmarshal(n, msg.Fields[KindsPossessProperties_PropertyDecl], &out.PropertyDecl); e != nil {
		err = errutil.New(Type_KindsPossessProperties+"."+KindsPossessProperties_PropertyDecl, "-", e)
	}
	return
}

func KindsPossessProperties_Detailed_Optional_Marshal(n jsonexp.Context, val **KindsPossessProperties) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = KindsPossessProperties_Detailed_Marshal(n, ptr)
	}
	return
}
func KindsPossessProperties_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **KindsPossessProperties) (err error) {
	if len(b) > 0 {
		var el KindsPossessProperties
		if e := KindsPossessProperties_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_KindsPossessProperties, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Lede Describes one or more nouns.
type Lede struct {
	Nouns      []NamedNoun `if:"label=_"`
	NounPhrase NounPhrase  `if:"label=noun_phrase"`
}

func (*Lede) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Lede,
		Uses: composer.Type_Flow,
	}
}

const Type_Lede = "lede"
const Lede_Nouns = "$NOUNS"
const Lede_NounPhrase = "$NOUN_PHRASE"

func (op *Lede) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Lede_Detailed_Marshal(n, op)
}
func (op *Lede) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Lede_Detailed_Unmarshal(n, b, op)
}

func Lede_Detailed_Marshal(n jsonexp.Context, val *Lede) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := NamedNoun_Detailed_Repeats_Marshal(n, &val.Nouns); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Lede_Nouns] = b
	}
	if b, e := NounPhrase_Detailed_Marshal(n, &val.NounPhrase); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Lede_NounPhrase] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Lede,
			Fields: fields,
		})
	}
	return
}

func Lede_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Lede) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Lede, "-", e)
	} else if e := NamedNoun_Detailed_Repeats_Unmarshal(n, msg.Fields[Lede_Nouns], &out.Nouns); e != nil {
		err = errutil.New(Type_Lede+"."+Lede_Nouns, "-", e)
	} else if e := NounPhrase_Detailed_Unmarshal(n, msg.Fields[Lede_NounPhrase], &out.NounPhrase); e != nil {
		err = errutil.New(Type_Lede+"."+Lede_NounPhrase, "-", e)
	}
	return
}

func Lede_Detailed_Optional_Marshal(n jsonexp.Context, val **Lede) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Lede_Detailed_Marshal(n, ptr)
	}
	return
}
func Lede_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Lede) (err error) {
	if len(b) > 0 {
		var el Lede
		if e := Lede_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Lede, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// LocalDecl
type LocalDecl struct {
	VariableDecl VariableDecl `if:"label=_"`
	Value        *LocalInit   `if:"label=value,optional"`
}

func (*LocalDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_LocalDecl,
		Uses: composer.Type_Flow,
	}
}

const Type_LocalDecl = "local_decl"
const LocalDecl_VariableDecl = "$VARIABLE_DECL"
const LocalDecl_Value = "$VALUE"

func (op *LocalDecl) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return LocalDecl_Detailed_Marshal(n, op)
}
func (op *LocalDecl) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return LocalDecl_Detailed_Unmarshal(n, b, op)
}

func LocalDecl_Detailed_Marshal(n jsonexp.Context, val *LocalDecl) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := VariableDecl_Detailed_Marshal(n, &val.VariableDecl); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[LocalDecl_VariableDecl] = b
	}
	if b, e := LocalInit_Detailed_Optional_Marshal(n, &val.Value); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[LocalDecl_Value] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_LocalDecl,
			Fields: fields,
		})
	}
	return
}

func LocalDecl_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *LocalDecl) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_LocalDecl, "-", e)
	} else if e := VariableDecl_Detailed_Unmarshal(n, msg.Fields[LocalDecl_VariableDecl], &out.VariableDecl); e != nil {
		err = errutil.New(Type_LocalDecl+"."+LocalDecl_VariableDecl, "-", e)
	} else if e := LocalInit_Detailed_Optional_Unmarshal(n, msg.Fields[LocalDecl_Value], &out.Value); e != nil {
		err = errutil.New(Type_LocalDecl+"."+LocalDecl_Value, "-", e)
	}
	return
}

func LocalDecl_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]LocalDecl) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := LocalDecl_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_LocalDecl, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func LocalDecl_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]LocalDecl) (err error) {
	var vals []LocalDecl
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_LocalDecl, "-", e)
		} else {
			vals = make([]LocalDecl, len(msgs))
			for i, msg := range msgs {
				if e := LocalDecl_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_LocalDecl, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func LocalDecl_Detailed_Optional_Marshal(n jsonexp.Context, val **LocalDecl) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = LocalDecl_Detailed_Marshal(n, ptr)
	}
	return
}
func LocalDecl_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **LocalDecl) (err error) {
	if len(b) > 0 {
		var el LocalDecl
		if e := LocalDecl_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_LocalDecl, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// LocalInit
type LocalInit struct {
	Value rt.Assignment `if:"label=_"`
}

func (*LocalInit) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_LocalInit,
		Uses: composer.Type_Flow,
	}
}

const Type_LocalInit = "local_init"
const LocalInit_Value = "$VALUE"

func (op *LocalInit) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return LocalInit_Detailed_Marshal(n, op)
}
func (op *LocalInit) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return LocalInit_Detailed_Unmarshal(n, b, op)
}

func LocalInit_Detailed_Marshal(n jsonexp.Context, val *LocalInit) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.Assignment_Detailed_Marshal(n, &val.Value); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[LocalInit_Value] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_LocalInit,
			Fields: fields,
		})
	}
	return
}

func LocalInit_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *LocalInit) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_LocalInit, "-", e)
	} else if e := rt.Assignment_Detailed_Unmarshal(n, msg.Fields[LocalInit_Value], &out.Value); e != nil {
		err = errutil.New(Type_LocalInit+"."+LocalInit_Value, "-", e)
	}
	return
}

func LocalInit_Detailed_Optional_Marshal(n jsonexp.Context, val **LocalInit) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = LocalInit_Detailed_Marshal(n, ptr)
	}
	return
}
func LocalInit_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **LocalInit) (err error) {
	if len(b) > 0 {
		var el LocalInit
		if e := LocalInit_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_LocalInit, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Make
type Make struct {
	Name      string     `if:"label=_,type=text"`
	Arguments *Arguments `if:"label=arguments,optional"`
}

func (*Make) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Make,
		Uses: composer.Type_Flow,
	}
}

const Type_Make = "make"
const Make_Name = "$NAME"
const Make_Arguments = "$ARGUMENTS"

func (op *Make) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Make_Detailed_Marshal(n, op)
}
func (op *Make) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Make_Detailed_Unmarshal(n, b, op)
}

func Make_Detailed_Marshal(n jsonexp.Context, val *Make) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Make_Name] = b
	}
	if b, e := Arguments_Detailed_Optional_Marshal(n, &val.Arguments); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Make_Arguments] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Make,
			Fields: fields,
		})
	}
	return
}

func Make_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Make) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Make, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Make_Name], &out.Name); e != nil {
		err = errutil.New(Type_Make+"."+Make_Name, "-", e)
	} else if e := Arguments_Detailed_Optional_Unmarshal(n, msg.Fields[Make_Arguments], &out.Arguments); e != nil {
		err = errutil.New(Type_Make+"."+Make_Arguments, "-", e)
	}
	return
}

func Make_Detailed_Optional_Marshal(n jsonexp.Context, val **Make) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Make_Detailed_Marshal(n, ptr)
	}
	return
}
func Make_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Make) (err error) {
	if len(b) > 0 {
		var el Make
		if e := Make_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Make, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// ManyToMany
type ManyToMany struct {
	Kinds      PluralKinds `if:"label=_"`
	OtherKinds PluralKinds `if:"label=other_kinds"`
}

func (*ManyToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ManyToMany,
		Uses: composer.Type_Flow,
	}
}

const Type_ManyToMany = "many_to_many"
const ManyToMany_Kinds = "$KINDS"
const ManyToMany_OtherKinds = "$OTHER_KINDS"

func (op *ManyToMany) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ManyToMany_Detailed_Marshal(n, op)
}
func (op *ManyToMany) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ManyToMany_Detailed_Unmarshal(n, b, op)
}

func ManyToMany_Detailed_Marshal(n jsonexp.Context, val *ManyToMany) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := PluralKinds_Detailed_Marshal(n, &val.Kinds); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ManyToMany_Kinds] = b
	}
	if b, e := PluralKinds_Detailed_Marshal(n, &val.OtherKinds); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ManyToMany_OtherKinds] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ManyToMany,
			Fields: fields,
		})
	}
	return
}

func ManyToMany_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ManyToMany) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ManyToMany, "-", e)
	} else if e := PluralKinds_Detailed_Unmarshal(n, msg.Fields[ManyToMany_Kinds], &out.Kinds); e != nil {
		err = errutil.New(Type_ManyToMany+"."+ManyToMany_Kinds, "-", e)
	} else if e := PluralKinds_Detailed_Unmarshal(n, msg.Fields[ManyToMany_OtherKinds], &out.OtherKinds); e != nil {
		err = errutil.New(Type_ManyToMany+"."+ManyToMany_OtherKinds, "-", e)
	}
	return
}

func ManyToMany_Detailed_Optional_Marshal(n jsonexp.Context, val **ManyToMany) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ManyToMany_Detailed_Marshal(n, ptr)
	}
	return
}
func ManyToMany_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ManyToMany) (err error) {
	if len(b) > 0 {
		var el ManyToMany
		if e := ManyToMany_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_ManyToMany, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// ManyToOne
type ManyToOne struct {
	Kinds PluralKinds  `if:"label=_"`
	Kind  SingularKind `if:"label=kind"`
}

func (*ManyToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ManyToOne,
		Uses: composer.Type_Flow,
	}
}

const Type_ManyToOne = "many_to_one"
const ManyToOne_Kinds = "$KINDS"
const ManyToOne_Kind = "$KIND"

func (op *ManyToOne) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ManyToOne_Detailed_Marshal(n, op)
}
func (op *ManyToOne) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ManyToOne_Detailed_Unmarshal(n, b, op)
}

func ManyToOne_Detailed_Marshal(n jsonexp.Context, val *ManyToOne) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := PluralKinds_Detailed_Marshal(n, &val.Kinds); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ManyToOne_Kinds] = b
	}
	if b, e := SingularKind_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ManyToOne_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ManyToOne,
			Fields: fields,
		})
	}
	return
}

func ManyToOne_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ManyToOne) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ManyToOne, "-", e)
	} else if e := PluralKinds_Detailed_Unmarshal(n, msg.Fields[ManyToOne_Kinds], &out.Kinds); e != nil {
		err = errutil.New(Type_ManyToOne+"."+ManyToOne_Kinds, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[ManyToOne_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_ManyToOne+"."+ManyToOne_Kind, "-", e)
	}
	return
}

func ManyToOne_Detailed_Optional_Marshal(n jsonexp.Context, val **ManyToOne) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ManyToOne_Detailed_Marshal(n, ptr)
	}
	return
}
func ManyToOne_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ManyToOne) (err error) {
	if len(b) > 0 {
		var el ManyToOne
		if e := ManyToOne_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_ManyToOne, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// NamedNoun
type NamedNoun struct {
	Determiner Determiner `if:"label=_"`
	Name       NounName   `if:"label=name"`
}

func (*NamedNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NamedNoun,
		Uses: composer.Type_Flow,
	}
}

const Type_NamedNoun = "named_noun"
const NamedNoun_Determiner = "$DETERMINER"
const NamedNoun_Name = "$NAME"

func (op *NamedNoun) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NamedNoun_Detailed_Marshal(n, op)
}
func (op *NamedNoun) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NamedNoun_Detailed_Unmarshal(n, b, op)
}

func NamedNoun_Detailed_Marshal(n jsonexp.Context, val *NamedNoun) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Determiner_Detailed_Marshal(n, &val.Determiner); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NamedNoun_Determiner] = b
	}
	if b, e := NounName_Detailed_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NamedNoun_Name] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_NamedNoun,
			Fields: fields,
		})
	}
	return
}

func NamedNoun_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NamedNoun) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_NamedNoun, "-", e)
	} else if e := Determiner_Detailed_Unmarshal(n, msg.Fields[NamedNoun_Determiner], &out.Determiner); e != nil {
		err = errutil.New(Type_NamedNoun+"."+NamedNoun_Determiner, "-", e)
	} else if e := NounName_Detailed_Unmarshal(n, msg.Fields[NamedNoun_Name], &out.Name); e != nil {
		err = errutil.New(Type_NamedNoun+"."+NamedNoun_Name, "-", e)
	}
	return
}

func NamedNoun_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]NamedNoun) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := NamedNoun_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_NamedNoun, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func NamedNoun_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]NamedNoun) (err error) {
	var vals []NamedNoun
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_NamedNoun, "-", e)
		} else {
			vals = make([]NamedNoun, len(msgs))
			for i, msg := range msgs {
				if e := NamedNoun_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_NamedNoun, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func NamedNoun_Detailed_Optional_Marshal(n jsonexp.Context, val **NamedNoun) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = NamedNoun_Detailed_Marshal(n, ptr)
	}
	return
}
func NamedNoun_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **NamedNoun) (err error) {
	if len(b) > 0 {
		var el NamedNoun
		if e := NamedNoun_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_NamedNoun, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// NounAssignment Assign text.
type NounAssignment struct {
	Property Property    `if:"label=_"`
	Nouns    []NamedNoun `if:"label=nouns"`
	Lines    value.Lines `if:"label=lines"`
}

func (*NounAssignment) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounAssignment,
		Uses: composer.Type_Flow,
	}
}

const Type_NounAssignment = "noun_assignment"
const NounAssignment_Property = "$PROPERTY"
const NounAssignment_Nouns = "$NOUNS"
const NounAssignment_Lines = "$LINES"

func (op *NounAssignment) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NounAssignment_Detailed_Marshal(n, op)
}
func (op *NounAssignment) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NounAssignment_Detailed_Unmarshal(n, b, op)
}

func NounAssignment_Detailed_Marshal(n jsonexp.Context, val *NounAssignment) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Property_Detailed_Marshal(n, &val.Property); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounAssignment_Property] = b
	}
	if b, e := NamedNoun_Detailed_Repeats_Marshal(n, &val.Nouns); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounAssignment_Nouns] = b
	}
	if b, e := value.Lines_Detailed_Marshal(n, &val.Lines); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounAssignment_Lines] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_NounAssignment,
			Fields: fields,
		})
	}
	return
}

func NounAssignment_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NounAssignment) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_NounAssignment, "-", e)
	} else if e := Property_Detailed_Unmarshal(n, msg.Fields[NounAssignment_Property], &out.Property); e != nil {
		err = errutil.New(Type_NounAssignment+"."+NounAssignment_Property, "-", e)
	} else if e := NamedNoun_Detailed_Repeats_Unmarshal(n, msg.Fields[NounAssignment_Nouns], &out.Nouns); e != nil {
		err = errutil.New(Type_NounAssignment+"."+NounAssignment_Nouns, "-", e)
	} else if e := value.Lines_Detailed_Unmarshal(n, msg.Fields[NounAssignment_Lines], &out.Lines); e != nil {
		err = errutil.New(Type_NounAssignment+"."+NounAssignment_Lines, "-", e)
	}
	return
}

func NounAssignment_Detailed_Optional_Marshal(n jsonexp.Context, val **NounAssignment) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = NounAssignment_Detailed_Marshal(n, ptr)
	}
	return
}
func NounAssignment_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **NounAssignment) (err error) {
	if len(b) > 0 {
		var el NounAssignment
		if e := NounAssignment_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_NounAssignment, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// NounName requires a user-specified string.
type NounName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *NounName) String() (ret string) {
	return op.Str
}

func (*NounName) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_NounName,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_NounName = "noun_name"

func (op *NounName) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NounName_Detailed_Marshal(n, op)
}
func (op *NounName) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NounName_Detailed_Unmarshal(n, b, op)
}
func NounName_Detailed_Marshal(n jsonexp.Context, val *NounName) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_NounName,
		Value: val.Str,
	})
}

func NounName_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NounName) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_NounName, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// NounPhrase swaps between various options
type NounPhrase struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const NounPhrase_KindOfNoun = "$KIND_OF_NOUN"
const NounPhrase_NounTraits = "$NOUN_TRAITS"
const NounPhrase_NounRelation = "$NOUN_RELATION"

func (*NounPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounPhrase,
		Uses: composer.Type_Swap,
		Choices: []string{
			NounPhrase_KindOfNoun, NounPhrase_NounTraits, NounPhrase_NounRelation,
		},
		Swaps: []interface{}{
			(*KindOfNoun)(nil),
			(*NounTraits)(nil),
			(*NounRelation)(nil),
		},
	}
}

const Type_NounPhrase = "noun_phrase"

func (op *NounPhrase) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *KindOfNoun:
		ret, okay = NounPhrase_KindOfNoun, true
	case *NounTraits:
		ret, okay = NounPhrase_NounTraits, true
	case *NounRelation:
		ret, okay = NounPhrase_NounRelation, true
	}
	return
}
func (op *NounPhrase) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NounPhrase_Detailed_Marshal(n, op)
}
func (op *NounPhrase) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NounPhrase_Detailed_Unmarshal(n, b, op)
}

func NounPhrase_Detailed_Marshal(n jsonexp.Context, val *NounPhrase) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_NounPhrase)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_NounPhrase, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{Id: val.At.Offset,
					Type: Type_NounPhrase,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func NounPhrase_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NounPhrase) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_NounPhrase, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case NounPhrase_KindOfNoun:
				ptr = new(KindOfNoun)
			case NounPhrase_NounTraits:
				ptr = new(NounTraits)
			case NounPhrase_NounRelation:
				ptr = new(NounRelation)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_NounPhrase, "-", e)
			} else {
				out.Opt = ptr
				out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
			}
		}
	}
	return
}

// NounRelation
type NounRelation struct {
	AreBeing AreBeing           `if:"label=_,optional"`
	Relation value.RelationName `if:"label=relation"`
	Nouns    []NamedNoun        `if:"label=nouns"`
}

func (*NounRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounRelation,
		Uses: composer.Type_Flow,
	}
}

const Type_NounRelation = "noun_relation"
const NounRelation_AreBeing = "$ARE_BEING"
const NounRelation_Relation = "$RELATION"
const NounRelation_Nouns = "$NOUNS"

func (op *NounRelation) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NounRelation_Detailed_Marshal(n, op)
}
func (op *NounRelation) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NounRelation_Detailed_Unmarshal(n, b, op)
}

func NounRelation_Detailed_Marshal(n jsonexp.Context, val *NounRelation) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := AreBeing_Detailed_Marshal(n, &val.AreBeing); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounRelation_AreBeing] = b
	}
	if b, e := value.RelationName_Detailed_Marshal(n, &val.Relation); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounRelation_Relation] = b
	}
	if b, e := NamedNoun_Detailed_Repeats_Marshal(n, &val.Nouns); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounRelation_Nouns] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_NounRelation,
			Fields: fields,
		})
	}
	return
}

func NounRelation_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NounRelation) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_NounRelation, "-", e)
	} else if e := AreBeing_Detailed_Unmarshal(n, msg.Fields[NounRelation_AreBeing], &out.AreBeing); e != nil {
		err = errutil.New(Type_NounRelation+"."+NounRelation_AreBeing, "-", e)
	} else if e := value.RelationName_Detailed_Unmarshal(n, msg.Fields[NounRelation_Relation], &out.Relation); e != nil {
		err = errutil.New(Type_NounRelation+"."+NounRelation_Relation, "-", e)
	} else if e := NamedNoun_Detailed_Repeats_Unmarshal(n, msg.Fields[NounRelation_Nouns], &out.Nouns); e != nil {
		err = errutil.New(Type_NounRelation+"."+NounRelation_Nouns, "-", e)
	}
	return
}

func NounRelation_Detailed_Optional_Marshal(n jsonexp.Context, val **NounRelation) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = NounRelation_Detailed_Marshal(n, ptr)
	}
	return
}
func NounRelation_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **NounRelation) (err error) {
	if len(b) > 0 {
		var el NounRelation
		if e := NounRelation_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_NounRelation, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// NounStatement Describes people, places, or things.
type NounStatement struct {
	Lede    Lede     `if:"label=_"`
	Tail    []Tail   `if:"label=tail,optional"`
	Summary *Summary `if:"label=summary,optional"`
}

func (*NounStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounStatement,
		Uses: composer.Type_Flow,
	}
}

const Type_NounStatement = "noun_statement"
const NounStatement_Lede = "$LEDE"
const NounStatement_Tail = "$TAIL"
const NounStatement_Summary = "$SUMMARY"

func (op *NounStatement) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NounStatement_Detailed_Marshal(n, op)
}
func (op *NounStatement) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NounStatement_Detailed_Unmarshal(n, b, op)
}

func NounStatement_Detailed_Marshal(n jsonexp.Context, val *NounStatement) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Lede_Detailed_Marshal(n, &val.Lede); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounStatement_Lede] = b
	}
	if b, e := Tail_Detailed_Repeats_Marshal(n, &val.Tail); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounStatement_Tail] = b
	}
	if b, e := Summary_Detailed_Optional_Marshal(n, &val.Summary); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounStatement_Summary] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_NounStatement,
			Fields: fields,
		})
	}
	return
}

func NounStatement_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NounStatement) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_NounStatement, "-", e)
	} else if e := Lede_Detailed_Unmarshal(n, msg.Fields[NounStatement_Lede], &out.Lede); e != nil {
		err = errutil.New(Type_NounStatement+"."+NounStatement_Lede, "-", e)
	} else if e := Tail_Detailed_Repeats_Unmarshal(n, msg.Fields[NounStatement_Tail], &out.Tail); e != nil {
		err = errutil.New(Type_NounStatement+"."+NounStatement_Tail, "-", e)
	} else if e := Summary_Detailed_Optional_Unmarshal(n, msg.Fields[NounStatement_Summary], &out.Summary); e != nil {
		err = errutil.New(Type_NounStatement+"."+NounStatement_Summary, "-", e)
	}
	return
}

func NounStatement_Detailed_Optional_Marshal(n jsonexp.Context, val **NounStatement) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = NounStatement_Detailed_Marshal(n, ptr)
	}
	return
}
func NounStatement_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **NounStatement) (err error) {
	if len(b) > 0 {
		var el NounStatement
		if e := NounStatement_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_NounStatement, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// NounTraits
type NounTraits struct {
	AreBeing AreBeing `if:"label=_"`
	Trait    []Trait  `if:"label=trait"`
}

func (*NounTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounTraits,
		Uses: composer.Type_Flow,
	}
}

const Type_NounTraits = "noun_traits"
const NounTraits_AreBeing = "$ARE_BEING"
const NounTraits_Trait = "$TRAIT"

func (op *NounTraits) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NounTraits_Detailed_Marshal(n, op)
}
func (op *NounTraits) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NounTraits_Detailed_Unmarshal(n, b, op)
}

func NounTraits_Detailed_Marshal(n jsonexp.Context, val *NounTraits) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := AreBeing_Detailed_Marshal(n, &val.AreBeing); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounTraits_AreBeing] = b
	}
	if b, e := Trait_Detailed_Repeats_Marshal(n, &val.Trait); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[NounTraits_Trait] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_NounTraits,
			Fields: fields,
		})
	}
	return
}

func NounTraits_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NounTraits) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_NounTraits, "-", e)
	} else if e := AreBeing_Detailed_Unmarshal(n, msg.Fields[NounTraits_AreBeing], &out.AreBeing); e != nil {
		err = errutil.New(Type_NounTraits+"."+NounTraits_AreBeing, "-", e)
	} else if e := Trait_Detailed_Repeats_Unmarshal(n, msg.Fields[NounTraits_Trait], &out.Trait); e != nil {
		err = errutil.New(Type_NounTraits+"."+NounTraits_Trait, "-", e)
	}
	return
}

func NounTraits_Detailed_Optional_Marshal(n jsonexp.Context, val **NounTraits) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = NounTraits_Detailed_Marshal(n, ptr)
	}
	return
}
func NounTraits_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **NounTraits) (err error) {
	if len(b) > 0 {
		var el NounTraits
		if e := NounTraits_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_NounTraits, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// NumberList requires a user-specified string.
type NumberList struct {
	Str string
}

func (op *NumberList) String() (ret string) {
	return op.Str
}

const NumberList_List = "$LIST"

func (*NumberList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NumberList,
		Uses: composer.Type_Str,
		Choices: []string{
			NumberList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

const Type_NumberList = "number_list"

func (op *NumberList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return NumberList_Detailed_Marshal(n, op)
}
func (op *NumberList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return NumberList_Detailed_Unmarshal(n, b, op)
}
func NumberList_Detailed_Marshal(n jsonexp.Context, val *NumberList) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_NumberList,
		Value: val.Str,
	})
}

func NumberList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *NumberList) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_NumberList, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// ObjectType
type ObjectType struct {
	An   Ana          `if:"label=_"`
	Kind SingularKind `if:"label=kind"`
}

func (*ObjectType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ObjectType,
		Uses: composer.Type_Flow,
	}
}

const Type_ObjectType = "object_type"
const ObjectType_An = "$AN"
const ObjectType_Kind = "$KIND"

func (op *ObjectType) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ObjectType_Detailed_Marshal(n, op)
}
func (op *ObjectType) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ObjectType_Detailed_Unmarshal(n, b, op)
}

func ObjectType_Detailed_Marshal(n jsonexp.Context, val *ObjectType) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Ana_Detailed_Marshal(n, &val.An); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ObjectType_An] = b
	}
	if b, e := SingularKind_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ObjectType_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_ObjectType,
			Fields: fields,
		})
	}
	return
}

func ObjectType_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ObjectType) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ObjectType, "-", e)
	} else if e := Ana_Detailed_Unmarshal(n, msg.Fields[ObjectType_An], &out.An); e != nil {
		err = errutil.New(Type_ObjectType+"."+ObjectType_An, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[ObjectType_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_ObjectType+"."+ObjectType_Kind, "-", e)
	}
	return
}

func ObjectType_Detailed_Optional_Marshal(n jsonexp.Context, val **ObjectType) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ObjectType_Detailed_Marshal(n, ptr)
	}
	return
}
func ObjectType_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ObjectType) (err error) {
	if len(b) > 0 {
		var el ObjectType
		if e := ObjectType_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_ObjectType, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// OneToMany
type OneToMany struct {
	Kind  SingularKind `if:"label=_"`
	Kinds PluralKinds  `if:"label=kinds"`
}

func (*OneToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_OneToMany,
		Uses: composer.Type_Flow,
	}
}

const Type_OneToMany = "one_to_many"
const OneToMany_Kind = "$KIND"
const OneToMany_Kinds = "$KINDS"

func (op *OneToMany) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return OneToMany_Detailed_Marshal(n, op)
}
func (op *OneToMany) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return OneToMany_Detailed_Unmarshal(n, b, op)
}

func OneToMany_Detailed_Marshal(n jsonexp.Context, val *OneToMany) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := SingularKind_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[OneToMany_Kind] = b
	}
	if b, e := PluralKinds_Detailed_Marshal(n, &val.Kinds); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[OneToMany_Kinds] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_OneToMany,
			Fields: fields,
		})
	}
	return
}

func OneToMany_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *OneToMany) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_OneToMany, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[OneToMany_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_OneToMany+"."+OneToMany_Kind, "-", e)
	} else if e := PluralKinds_Detailed_Unmarshal(n, msg.Fields[OneToMany_Kinds], &out.Kinds); e != nil {
		err = errutil.New(Type_OneToMany+"."+OneToMany_Kinds, "-", e)
	}
	return
}

func OneToMany_Detailed_Optional_Marshal(n jsonexp.Context, val **OneToMany) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = OneToMany_Detailed_Marshal(n, ptr)
	}
	return
}
func OneToMany_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **OneToMany) (err error) {
	if len(b) > 0 {
		var el OneToMany
		if e := OneToMany_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_OneToMany, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// OneToOne
type OneToOne struct {
	Kind      SingularKind `if:"label=_"`
	OtherKind SingularKind `if:"label=other_kind"`
}

func (*OneToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_OneToOne,
		Uses: composer.Type_Flow,
	}
}

const Type_OneToOne = "one_to_one"
const OneToOne_Kind = "$KIND"
const OneToOne_OtherKind = "$OTHER_KIND"

func (op *OneToOne) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return OneToOne_Detailed_Marshal(n, op)
}
func (op *OneToOne) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return OneToOne_Detailed_Unmarshal(n, b, op)
}

func OneToOne_Detailed_Marshal(n jsonexp.Context, val *OneToOne) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := SingularKind_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[OneToOne_Kind] = b
	}
	if b, e := SingularKind_Detailed_Marshal(n, &val.OtherKind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[OneToOne_OtherKind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_OneToOne,
			Fields: fields,
		})
	}
	return
}

func OneToOne_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *OneToOne) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_OneToOne, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[OneToOne_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_OneToOne+"."+OneToOne_Kind, "-", e)
	} else if e := SingularKind_Detailed_Unmarshal(n, msg.Fields[OneToOne_OtherKind], &out.OtherKind); e != nil {
		err = errutil.New(Type_OneToOne+"."+OneToOne_OtherKind, "-", e)
	}
	return
}

func OneToOne_Detailed_Optional_Marshal(n jsonexp.Context, val **OneToOne) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = OneToOne_Detailed_Marshal(n, ptr)
	}
	return
}
func OneToOne_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **OneToOne) (err error) {
	if len(b) > 0 {
		var el OneToOne
		if e := OneToOne_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_OneToOne, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PairedAction
type PairedAction struct {
	At    reader.Position `if:"internal"`
	Kinds PluralKinds     `if:"label=kinds"`
}

func (*PairedAction) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PairedAction,
		Uses: composer.Type_Flow,
	}
}

const Type_PairedAction = "paired_action"
const PairedAction_Kinds = "$KINDS"

func (op *PairedAction) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PairedAction_Detailed_Marshal(n, op)
}
func (op *PairedAction) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PairedAction_Detailed_Unmarshal(n, b, op)
}

func PairedAction_Detailed_Marshal(n jsonexp.Context, val *PairedAction) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := PluralKinds_Detailed_Marshal(n, &val.Kinds); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PairedAction_Kinds] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_PairedAction,
			Fields: fields,
		})
	}
	return
}

func PairedAction_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PairedAction) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PairedAction, "-", e)
	} else if e := PluralKinds_Detailed_Unmarshal(n, msg.Fields[PairedAction_Kinds], &out.Kinds); e != nil {
		err = errutil.New(Type_PairedAction+"."+PairedAction_Kinds, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func PairedAction_Detailed_Optional_Marshal(n jsonexp.Context, val **PairedAction) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PairedAction_Detailed_Marshal(n, ptr)
	}
	return
}
func PairedAction_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PairedAction) (err error) {
	if len(b) > 0 {
		var el PairedAction
		if e := PairedAction_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PairedAction, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Paragraph
type Paragraph struct {
	StoryStatement []StoryStatement `if:"label=_,optional"`
}

func (*Paragraph) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Paragraph,
		Uses: composer.Type_Flow,
	}
}

const Type_Paragraph = "paragraph"
const Paragraph_StoryStatement = "$STORY_STATEMENT"

func (op *Paragraph) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Paragraph_Detailed_Marshal(n, op)
}
func (op *Paragraph) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Paragraph_Detailed_Unmarshal(n, b, op)
}

func Paragraph_Detailed_Marshal(n jsonexp.Context, val *Paragraph) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := StoryStatement_Detailed_Repeats_Marshal(n, &val.StoryStatement); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Paragraph_StoryStatement] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Paragraph,
			Fields: fields,
		})
	}
	return
}

func Paragraph_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Paragraph) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Paragraph, "-", e)
	} else if e := StoryStatement_Detailed_Repeats_Unmarshal(n, msg.Fields[Paragraph_StoryStatement], &out.StoryStatement); e != nil {
		err = errutil.New(Type_Paragraph+"."+Paragraph_StoryStatement, "-", e)
	}
	return
}

func Paragraph_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Paragraph) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := Paragraph_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_Paragraph, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Paragraph_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Paragraph) (err error) {
	var vals []Paragraph
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_Paragraph, "-", e)
		} else {
			vals = make([]Paragraph, len(msgs))
			for i, msg := range msgs {
				if e := Paragraph_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_Paragraph, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func Paragraph_Detailed_Optional_Marshal(n jsonexp.Context, val **Paragraph) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Paragraph_Detailed_Marshal(n, ptr)
	}
	return
}
func Paragraph_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Paragraph) (err error) {
	if len(b) > 0 {
		var el Paragraph
		if e := Paragraph_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Paragraph, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PatternActions Actions to take when using a pattern.
type PatternActions struct {
	Name          value.PatternName `if:"label=_"`
	PatternLocals *PatternLocals    `if:"label=pattern_locals,optional"`
	PatternReturn *PatternReturn    `if:"label=pattern_return,optional"`
	PatternRules  PatternRules      `if:"label=pattern_rules"`
}

func (*PatternActions) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternActions,
		Uses: composer.Type_Flow,
	}
}

const Type_PatternActions = "pattern_actions"
const PatternActions_Name = "$NAME"
const PatternActions_PatternLocals = "$PATTERN_LOCALS"
const PatternActions_PatternReturn = "$PATTERN_RETURN"
const PatternActions_PatternRules = "$PATTERN_RULES"

func (op *PatternActions) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternActions_Detailed_Marshal(n, op)
}
func (op *PatternActions) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternActions_Detailed_Unmarshal(n, b, op)
}

func PatternActions_Detailed_Marshal(n jsonexp.Context, val *PatternActions) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.PatternName_Detailed_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternActions_Name] = b
	}
	if b, e := PatternLocals_Detailed_Optional_Marshal(n, &val.PatternLocals); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternActions_PatternLocals] = b
	}
	if b, e := PatternReturn_Detailed_Optional_Marshal(n, &val.PatternReturn); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternActions_PatternReturn] = b
	}
	if b, e := PatternRules_Detailed_Marshal(n, &val.PatternRules); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternActions_PatternRules] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PatternActions,
			Fields: fields,
		})
	}
	return
}

func PatternActions_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternActions) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PatternActions, "-", e)
	} else if e := value.PatternName_Detailed_Unmarshal(n, msg.Fields[PatternActions_Name], &out.Name); e != nil {
		err = errutil.New(Type_PatternActions+"."+PatternActions_Name, "-", e)
	} else if e := PatternLocals_Detailed_Optional_Unmarshal(n, msg.Fields[PatternActions_PatternLocals], &out.PatternLocals); e != nil {
		err = errutil.New(Type_PatternActions+"."+PatternActions_PatternLocals, "-", e)
	} else if e := PatternReturn_Detailed_Optional_Unmarshal(n, msg.Fields[PatternActions_PatternReturn], &out.PatternReturn); e != nil {
		err = errutil.New(Type_PatternActions+"."+PatternActions_PatternReturn, "-", e)
	} else if e := PatternRules_Detailed_Unmarshal(n, msg.Fields[PatternActions_PatternRules], &out.PatternRules); e != nil {
		err = errutil.New(Type_PatternActions+"."+PatternActions_PatternRules, "-", e)
	}
	return
}

func PatternActions_Detailed_Optional_Marshal(n jsonexp.Context, val **PatternActions) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PatternActions_Detailed_Marshal(n, ptr)
	}
	return
}
func PatternActions_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PatternActions) (err error) {
	if len(b) > 0 {
		var el PatternActions
		if e := PatternActions_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PatternActions, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PatternDecl
type PatternDecl struct {
	Type          PatternType           `if:"label=_"`
	Name          value.PatternName     `if:"label=name"`
	Optvars       *PatternVariablesTail `if:"label=optvars,optional"`
	PatternReturn *PatternReturn        `if:"label=pattern_return,optional"`
	About         *Comment              `if:"label=about,optional"`
}

func (*PatternDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternDecl,
		Uses: composer.Type_Flow,
	}
}

const Type_PatternDecl = "pattern_decl"
const PatternDecl_Type = "$TYPE"
const PatternDecl_Name = "$NAME"
const PatternDecl_Optvars = "$OPTVARS"
const PatternDecl_PatternReturn = "$PATTERN_RETURN"
const PatternDecl_About = "$ABOUT"

func (op *PatternDecl) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternDecl_Detailed_Marshal(n, op)
}
func (op *PatternDecl) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternDecl_Detailed_Unmarshal(n, b, op)
}

func PatternDecl_Detailed_Marshal(n jsonexp.Context, val *PatternDecl) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := PatternType_Detailed_Marshal(n, &val.Type); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternDecl_Type] = b
	}
	if b, e := value.PatternName_Detailed_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternDecl_Name] = b
	}
	if b, e := PatternVariablesTail_Detailed_Optional_Marshal(n, &val.Optvars); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternDecl_Optvars] = b
	}
	if b, e := PatternReturn_Detailed_Optional_Marshal(n, &val.PatternReturn); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternDecl_PatternReturn] = b
	}
	if b, e := Comment_Detailed_Optional_Marshal(n, &val.About); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternDecl_About] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PatternDecl,
			Fields: fields,
		})
	}
	return
}

func PatternDecl_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternDecl) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PatternDecl, "-", e)
	} else if e := PatternType_Detailed_Unmarshal(n, msg.Fields[PatternDecl_Type], &out.Type); e != nil {
		err = errutil.New(Type_PatternDecl+"."+PatternDecl_Type, "-", e)
	} else if e := value.PatternName_Detailed_Unmarshal(n, msg.Fields[PatternDecl_Name], &out.Name); e != nil {
		err = errutil.New(Type_PatternDecl+"."+PatternDecl_Name, "-", e)
	} else if e := PatternVariablesTail_Detailed_Optional_Unmarshal(n, msg.Fields[PatternDecl_Optvars], &out.Optvars); e != nil {
		err = errutil.New(Type_PatternDecl+"."+PatternDecl_Optvars, "-", e)
	} else if e := PatternReturn_Detailed_Optional_Unmarshal(n, msg.Fields[PatternDecl_PatternReturn], &out.PatternReturn); e != nil {
		err = errutil.New(Type_PatternDecl+"."+PatternDecl_PatternReturn, "-", e)
	} else if e := Comment_Detailed_Optional_Unmarshal(n, msg.Fields[PatternDecl_About], &out.About); e != nil {
		err = errutil.New(Type_PatternDecl+"."+PatternDecl_About, "-", e)
	}
	return
}

func PatternDecl_Detailed_Optional_Marshal(n jsonexp.Context, val **PatternDecl) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PatternDecl_Detailed_Marshal(n, ptr)
	}
	return
}
func PatternDecl_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PatternDecl) (err error) {
	if len(b) > 0 {
		var el PatternDecl
		if e := PatternDecl_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PatternDecl, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PatternFlags requires a user-specified string.
type PatternFlags struct {
	Str string
}

func (op *PatternFlags) String() (ret string) {
	return op.Str
}

const PatternFlags_Before = "$BEFORE"
const PatternFlags_After = "$AFTER"
const PatternFlags_Terminate = "$TERMINATE"

func (*PatternFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternFlags,
		Uses: composer.Type_Str,
		Choices: []string{
			PatternFlags_Before, PatternFlags_After, PatternFlags_Terminate,
		},
		Strings: []string{
			"before", "after", "terminate",
		},
	}
}

const Type_PatternFlags = "pattern_flags"

func (op *PatternFlags) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternFlags_Detailed_Marshal(n, op)
}
func (op *PatternFlags) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternFlags_Detailed_Unmarshal(n, b, op)
}
func PatternFlags_Detailed_Marshal(n jsonexp.Context, val *PatternFlags) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_PatternFlags,
		Value: val.Str,
	})
}

func PatternFlags_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternFlags) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_PatternFlags, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// PatternLocals
type PatternLocals struct {
	LocalDecl []LocalDecl `if:"label=_"`
}

func (*PatternLocals) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternLocals,
		Uses: composer.Type_Flow,
	}
}

const Type_PatternLocals = "pattern_locals"
const PatternLocals_LocalDecl = "$LOCAL_DECL"

func (op *PatternLocals) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternLocals_Detailed_Marshal(n, op)
}
func (op *PatternLocals) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternLocals_Detailed_Unmarshal(n, b, op)
}

func PatternLocals_Detailed_Marshal(n jsonexp.Context, val *PatternLocals) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := LocalDecl_Detailed_Repeats_Marshal(n, &val.LocalDecl); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternLocals_LocalDecl] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PatternLocals,
			Fields: fields,
		})
	}
	return
}

func PatternLocals_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternLocals) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PatternLocals, "-", e)
	} else if e := LocalDecl_Detailed_Repeats_Unmarshal(n, msg.Fields[PatternLocals_LocalDecl], &out.LocalDecl); e != nil {
		err = errutil.New(Type_PatternLocals+"."+PatternLocals_LocalDecl, "-", e)
	}
	return
}

func PatternLocals_Detailed_Optional_Marshal(n jsonexp.Context, val **PatternLocals) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PatternLocals_Detailed_Marshal(n, ptr)
	}
	return
}
func PatternLocals_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PatternLocals) (err error) {
	if len(b) > 0 {
		var el PatternLocals
		if e := PatternLocals_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PatternLocals, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PatternReturn
type PatternReturn struct {
	Result VariableDecl `if:"label=_"`
}

func (*PatternReturn) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternReturn,
		Uses: composer.Type_Flow,
	}
}

const Type_PatternReturn = "pattern_return"
const PatternReturn_Result = "$RESULT"

func (op *PatternReturn) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternReturn_Detailed_Marshal(n, op)
}
func (op *PatternReturn) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternReturn_Detailed_Unmarshal(n, b, op)
}

func PatternReturn_Detailed_Marshal(n jsonexp.Context, val *PatternReturn) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := VariableDecl_Detailed_Marshal(n, &val.Result); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternReturn_Result] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PatternReturn,
			Fields: fields,
		})
	}
	return
}

func PatternReturn_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternReturn) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PatternReturn, "-", e)
	} else if e := VariableDecl_Detailed_Unmarshal(n, msg.Fields[PatternReturn_Result], &out.Result); e != nil {
		err = errutil.New(Type_PatternReturn+"."+PatternReturn_Result, "-", e)
	}
	return
}

func PatternReturn_Detailed_Optional_Marshal(n jsonexp.Context, val **PatternReturn) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PatternReturn_Detailed_Marshal(n, ptr)
	}
	return
}
func PatternReturn_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PatternReturn) (err error) {
	if len(b) > 0 {
		var el PatternReturn
		if e := PatternReturn_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PatternReturn, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PatternRule
type PatternRule struct {
	Guard rt.BoolEval  `if:"label=_"`
	Flags PatternFlags `if:"label=flags,optional"`
	Hook  ProgramHook  `if:"label=hook"`
}

func (*PatternRule) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternRule,
		Uses: composer.Type_Flow,
	}
}

const Type_PatternRule = "pattern_rule"
const PatternRule_Guard = "$GUARD"
const PatternRule_Flags = "$FLAGS"
const PatternRule_Hook = "$HOOK"

func (op *PatternRule) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternRule_Detailed_Marshal(n, op)
}
func (op *PatternRule) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternRule_Detailed_Unmarshal(n, b, op)
}

func PatternRule_Detailed_Marshal(n jsonexp.Context, val *PatternRule) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.BoolEval_Detailed_Marshal(n, &val.Guard); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternRule_Guard] = b
	}
	if b, e := PatternFlags_Detailed_Marshal(n, &val.Flags); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternRule_Flags] = b
	}
	if b, e := ProgramHook_Detailed_Marshal(n, &val.Hook); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternRule_Hook] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PatternRule,
			Fields: fields,
		})
	}
	return
}

func PatternRule_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternRule) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PatternRule, "-", e)
	} else if e := rt.BoolEval_Detailed_Unmarshal(n, msg.Fields[PatternRule_Guard], &out.Guard); e != nil {
		err = errutil.New(Type_PatternRule+"."+PatternRule_Guard, "-", e)
	} else if e := PatternFlags_Detailed_Unmarshal(n, msg.Fields[PatternRule_Flags], &out.Flags); e != nil {
		err = errutil.New(Type_PatternRule+"."+PatternRule_Flags, "-", e)
	} else if e := ProgramHook_Detailed_Unmarshal(n, msg.Fields[PatternRule_Hook], &out.Hook); e != nil {
		err = errutil.New(Type_PatternRule+"."+PatternRule_Hook, "-", e)
	}
	return
}

func PatternRule_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]PatternRule) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := PatternRule_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_PatternRule, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func PatternRule_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]PatternRule) (err error) {
	var vals []PatternRule
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_PatternRule, "-", e)
		} else {
			vals = make([]PatternRule, len(msgs))
			for i, msg := range msgs {
				if e := PatternRule_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_PatternRule, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func PatternRule_Detailed_Optional_Marshal(n jsonexp.Context, val **PatternRule) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PatternRule_Detailed_Marshal(n, ptr)
	}
	return
}
func PatternRule_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PatternRule) (err error) {
	if len(b) > 0 {
		var el PatternRule
		if e := PatternRule_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PatternRule, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PatternRules
type PatternRules struct {
	PatternRule []PatternRule `if:"label=_,optional"`
}

func (*PatternRules) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternRules,
		Uses: composer.Type_Flow,
	}
}

const Type_PatternRules = "pattern_rules"
const PatternRules_PatternRule = "$PATTERN_RULE"

func (op *PatternRules) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternRules_Detailed_Marshal(n, op)
}
func (op *PatternRules) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternRules_Detailed_Unmarshal(n, b, op)
}

func PatternRules_Detailed_Marshal(n jsonexp.Context, val *PatternRules) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := PatternRule_Detailed_Repeats_Marshal(n, &val.PatternRule); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternRules_PatternRule] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PatternRules,
			Fields: fields,
		})
	}
	return
}

func PatternRules_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternRules) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PatternRules, "-", e)
	} else if e := PatternRule_Detailed_Repeats_Unmarshal(n, msg.Fields[PatternRules_PatternRule], &out.PatternRule); e != nil {
		err = errutil.New(Type_PatternRules+"."+PatternRules_PatternRule, "-", e)
	}
	return
}

func PatternRules_Detailed_Optional_Marshal(n jsonexp.Context, val **PatternRules) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PatternRules_Detailed_Marshal(n, ptr)
	}
	return
}
func PatternRules_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PatternRules) (err error) {
	if len(b) > 0 {
		var el PatternRules
		if e := PatternRules_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PatternRules, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PatternType requires a user-specified string.
type PatternType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PatternType) String() (ret string) {
	return op.Str
}

const PatternType_Patterns = "$PATTERNS"
const PatternType_Actions = "$ACTIONS"
const PatternType_Events = "$EVENTS"

func (*PatternType) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_PatternType,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			PatternType_Patterns, PatternType_Actions, PatternType_Events,
		},
		Strings: []string{
			"patterns", "actions", "events",
		},
	}
}

const Type_PatternType = "pattern_type"

func (op *PatternType) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternType_Detailed_Marshal(n, op)
}
func (op *PatternType) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternType_Detailed_Unmarshal(n, b, op)
}
func PatternType_Detailed_Marshal(n jsonexp.Context, val *PatternType) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_PatternType,
		Value: val.Str,
	})
}

func PatternType_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternType) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_PatternType, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// PatternVariablesDecl Values provided when calling a pattern.
type PatternVariablesDecl struct {
	PatternName  value.PatternName `if:"label=_"`
	VariableDecl []VariableDecl    `if:"label=variable_decl"`
}

func (*PatternVariablesDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternVariablesDecl,
		Uses: composer.Type_Flow,
	}
}

const Type_PatternVariablesDecl = "pattern_variables_decl"
const PatternVariablesDecl_PatternName = "$PATTERN_NAME"
const PatternVariablesDecl_VariableDecl = "$VARIABLE_DECL"

func (op *PatternVariablesDecl) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternVariablesDecl_Detailed_Marshal(n, op)
}
func (op *PatternVariablesDecl) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternVariablesDecl_Detailed_Unmarshal(n, b, op)
}

func PatternVariablesDecl_Detailed_Marshal(n jsonexp.Context, val *PatternVariablesDecl) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.PatternName_Detailed_Marshal(n, &val.PatternName); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternVariablesDecl_PatternName] = b
	}
	if b, e := VariableDecl_Detailed_Repeats_Marshal(n, &val.VariableDecl); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternVariablesDecl_VariableDecl] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PatternVariablesDecl,
			Fields: fields,
		})
	}
	return
}

func PatternVariablesDecl_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternVariablesDecl) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PatternVariablesDecl, "-", e)
	} else if e := value.PatternName_Detailed_Unmarshal(n, msg.Fields[PatternVariablesDecl_PatternName], &out.PatternName); e != nil {
		err = errutil.New(Type_PatternVariablesDecl+"."+PatternVariablesDecl_PatternName, "-", e)
	} else if e := VariableDecl_Detailed_Repeats_Unmarshal(n, msg.Fields[PatternVariablesDecl_VariableDecl], &out.VariableDecl); e != nil {
		err = errutil.New(Type_PatternVariablesDecl+"."+PatternVariablesDecl_VariableDecl, "-", e)
	}
	return
}

func PatternVariablesDecl_Detailed_Optional_Marshal(n jsonexp.Context, val **PatternVariablesDecl) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PatternVariablesDecl_Detailed_Marshal(n, ptr)
	}
	return
}
func PatternVariablesDecl_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PatternVariablesDecl) (err error) {
	if len(b) > 0 {
		var el PatternVariablesDecl
		if e := PatternVariablesDecl_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PatternVariablesDecl, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PatternVariablesTail Storage for values used during the execution of a pattern.
type PatternVariablesTail struct {
	VariableDecl []VariableDecl `if:"label=_"`
}

func (*PatternVariablesTail) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternVariablesTail,
		Uses: composer.Type_Flow,
	}
}

const Type_PatternVariablesTail = "pattern_variables_tail"
const PatternVariablesTail_VariableDecl = "$VARIABLE_DECL"

func (op *PatternVariablesTail) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PatternVariablesTail_Detailed_Marshal(n, op)
}
func (op *PatternVariablesTail) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PatternVariablesTail_Detailed_Unmarshal(n, b, op)
}

func PatternVariablesTail_Detailed_Marshal(n jsonexp.Context, val *PatternVariablesTail) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := VariableDecl_Detailed_Repeats_Marshal(n, &val.VariableDecl); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PatternVariablesTail_VariableDecl] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PatternVariablesTail,
			Fields: fields,
		})
	}
	return
}

func PatternVariablesTail_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PatternVariablesTail) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PatternVariablesTail, "-", e)
	} else if e := VariableDecl_Detailed_Repeats_Unmarshal(n, msg.Fields[PatternVariablesTail_VariableDecl], &out.VariableDecl); e != nil {
		err = errutil.New(Type_PatternVariablesTail+"."+PatternVariablesTail_VariableDecl, "-", e)
	}
	return
}

func PatternVariablesTail_Detailed_Optional_Marshal(n jsonexp.Context, val **PatternVariablesTail) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PatternVariablesTail_Detailed_Marshal(n, ptr)
	}
	return
}
func PatternVariablesTail_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PatternVariablesTail) (err error) {
	if len(b) > 0 {
		var el PatternVariablesTail
		if e := PatternVariablesTail_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PatternVariablesTail, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PluralKinds requires a user-specified string.
type PluralKinds struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PluralKinds) String() (ret string) {
	return op.Str
}

func (*PluralKinds) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_PluralKinds,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_PluralKinds = "plural_kinds"

func (op *PluralKinds) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PluralKinds_Detailed_Marshal(n, op)
}
func (op *PluralKinds) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PluralKinds_Detailed_Unmarshal(n, b, op)
}
func PluralKinds_Detailed_Marshal(n jsonexp.Context, val *PluralKinds) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_PluralKinds,
		Value: val.Str,
	})
}

func PluralKinds_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PluralKinds) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_PluralKinds, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// PrimitiveType requires a user-specified string.
type PrimitiveType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PrimitiveType) String() (ret string) {
	return op.Str
}

const PrimitiveType_Number = "$NUMBER"
const PrimitiveType_Text = "$TEXT"
const PrimitiveType_Bool = "$BOOL"

func (*PrimitiveType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PrimitiveType,
		Uses: composer.Type_Str,
		Choices: []string{
			PrimitiveType_Number, PrimitiveType_Text, PrimitiveType_Bool,
		},
		Strings: []string{
			"number", "text", "bool",
		},
	}
}

const Type_PrimitiveType = "primitive_type"

func (op *PrimitiveType) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PrimitiveType_Detailed_Marshal(n, op)
}
func (op *PrimitiveType) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PrimitiveType_Detailed_Unmarshal(n, b, op)
}
func PrimitiveType_Detailed_Marshal(n jsonexp.Context, val *PrimitiveType) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_PrimitiveType,
		Value: val.Str,
	})
}

func PrimitiveType_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PrimitiveType) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_PrimitiveType, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// PrimitiveValue swaps between various options
type PrimitiveValue struct {
	Opt interface{}
}

const PrimitiveValue_BoxedText = "$BOXED_TEXT"
const PrimitiveValue_BoxedNumber = "$BOXED_NUMBER"

func (*PrimitiveValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PrimitiveValue,
		Uses: composer.Type_Swap,
		Choices: []string{
			PrimitiveValue_BoxedText, PrimitiveValue_BoxedNumber,
		},
		Swaps: []interface{}{
			(*BoxedText)(nil),
			(*BoxedNumber)(nil),
		},
	}
}

const Type_PrimitiveValue = "primitive_value"

func (op *PrimitiveValue) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *BoxedText:
		ret, okay = PrimitiveValue_BoxedText, true
	case *BoxedNumber:
		ret, okay = PrimitiveValue_BoxedNumber, true
	}
	return
}
func (op *PrimitiveValue) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PrimitiveValue_Detailed_Marshal(n, op)
}
func (op *PrimitiveValue) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PrimitiveValue_Detailed_Unmarshal(n, b, op)
}

func PrimitiveValue_Detailed_Marshal(n jsonexp.Context, val *PrimitiveValue) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_PrimitiveValue)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_PrimitiveValue, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{
					Type: Type_PrimitiveValue,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func PrimitiveValue_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PrimitiveValue) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_PrimitiveValue, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case PrimitiveValue_BoxedText:
				ptr = new(BoxedText)
			case PrimitiveValue_BoxedNumber:
				ptr = new(BoxedNumber)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_PrimitiveValue, "-", e)
			} else {
				out.Opt = ptr
			}
		}
	}
	return
}

// ProgramHook swaps between various options
type ProgramHook struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ProgramHook_Activity = "$ACTIVITY"

func (*ProgramHook) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ProgramHook,
		Uses: composer.Type_Swap,
		Choices: []string{
			ProgramHook_Activity,
		},
		Swaps: []interface{}{
			(*core.Activity)(nil),
		},
	}
}

const Type_ProgramHook = "program_hook"

func (op *ProgramHook) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *core.Activity:
		ret, okay = ProgramHook_Activity, true
	}
	return
}
func (op *ProgramHook) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ProgramHook_Detailed_Marshal(n, op)
}
func (op *ProgramHook) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ProgramHook_Detailed_Unmarshal(n, b, op)
}

func ProgramHook_Detailed_Marshal(n jsonexp.Context, val *ProgramHook) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_ProgramHook)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_ProgramHook, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{Id: val.At.Offset,
					Type: Type_ProgramHook,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func ProgramHook_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ProgramHook) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_ProgramHook, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case ProgramHook_Activity:
				ptr = new(core.Activity)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_ProgramHook, "-", e)
			} else {
				out.Opt = ptr
				out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
			}
		}
	}
	return
}

// Pronoun requires a user-specified string.
type Pronoun struct {
	Str string
}

func (op *Pronoun) String() (ret string) {
	return op.Str
}

const Pronoun_It = "$IT"
const Pronoun_They = "$THEY"

func (*Pronoun) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Pronoun,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			Pronoun_It, Pronoun_They,
		},
		Strings: []string{
			"it", "they",
		},
	}
}

const Type_Pronoun = "pronoun"

func (op *Pronoun) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Pronoun_Detailed_Marshal(n, op)
}
func (op *Pronoun) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Pronoun_Detailed_Unmarshal(n, b, op)
}
func Pronoun_Detailed_Marshal(n jsonexp.Context, val *Pronoun) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_Pronoun,
		Value: val.Str,
	})
}

func Pronoun_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Pronoun) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_Pronoun, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// Property requires a user-specified string.
type Property struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Property) String() (ret string) {
	return op.Str
}

func (*Property) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Property,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_Property = "property"

func (op *Property) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Property_Detailed_Marshal(n, op)
}
func (op *Property) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Property_Detailed_Unmarshal(n, b, op)
}
func Property_Detailed_Marshal(n jsonexp.Context, val *Property) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_Property,
		Value: val.Str,
	})
}

func Property_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Property) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_Property, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// PropertyAspect requires a user-specified string.
type PropertyAspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PropertyAspect) String() (ret string) {
	return op.Str
}

const PropertyAspect_Aspect = "$ASPECT"

func (*PropertyAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PropertyAspect,
		Uses: composer.Type_Str,
		Choices: []string{
			PropertyAspect_Aspect,
		},
		Strings: []string{
			"aspect",
		},
	}
}

const Type_PropertyAspect = "property_aspect"

func (op *PropertyAspect) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PropertyAspect_Detailed_Marshal(n, op)
}
func (op *PropertyAspect) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PropertyAspect_Detailed_Unmarshal(n, b, op)
}
func PropertyAspect_Detailed_Marshal(n jsonexp.Context, val *PropertyAspect) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_PropertyAspect,
		Value: val.Str,
	})
}

func PropertyAspect_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PropertyAspect) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_PropertyAspect, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// PropertyDecl
type PropertyDecl struct {
	An           Determiner   `if:"label=_"`
	Property     Property     `if:"label=property"`
	PropertyType PropertyType `if:"label=property_type"`
	Comment      value.Lines  `if:"label=comment,optional"`
}

func (*PropertyDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PropertyDecl,
		Uses: composer.Type_Flow,
	}
}

const Type_PropertyDecl = "property_decl"
const PropertyDecl_An = "$AN"
const PropertyDecl_Property = "$PROPERTY"
const PropertyDecl_PropertyType = "$PROPERTY_TYPE"
const PropertyDecl_Comment = "$COMMENT"

func (op *PropertyDecl) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PropertyDecl_Detailed_Marshal(n, op)
}
func (op *PropertyDecl) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PropertyDecl_Detailed_Unmarshal(n, b, op)
}

func PropertyDecl_Detailed_Marshal(n jsonexp.Context, val *PropertyDecl) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Determiner_Detailed_Marshal(n, &val.An); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PropertyDecl_An] = b
	}
	if b, e := Property_Detailed_Marshal(n, &val.Property); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PropertyDecl_Property] = b
	}
	if b, e := PropertyType_Detailed_Marshal(n, &val.PropertyType); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PropertyDecl_PropertyType] = b
	}
	if b, e := value.Lines_Detailed_Marshal(n, &val.Comment); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[PropertyDecl_Comment] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_PropertyDecl,
			Fields: fields,
		})
	}
	return
}

func PropertyDecl_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PropertyDecl) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_PropertyDecl, "-", e)
	} else if e := Determiner_Detailed_Unmarshal(n, msg.Fields[PropertyDecl_An], &out.An); e != nil {
		err = errutil.New(Type_PropertyDecl+"."+PropertyDecl_An, "-", e)
	} else if e := Property_Detailed_Unmarshal(n, msg.Fields[PropertyDecl_Property], &out.Property); e != nil {
		err = errutil.New(Type_PropertyDecl+"."+PropertyDecl_Property, "-", e)
	} else if e := PropertyType_Detailed_Unmarshal(n, msg.Fields[PropertyDecl_PropertyType], &out.PropertyType); e != nil {
		err = errutil.New(Type_PropertyDecl+"."+PropertyDecl_PropertyType, "-", e)
	} else if e := value.Lines_Detailed_Unmarshal(n, msg.Fields[PropertyDecl_Comment], &out.Comment); e != nil {
		err = errutil.New(Type_PropertyDecl+"."+PropertyDecl_Comment, "-", e)
	}
	return
}

func PropertyDecl_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]PropertyDecl) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := PropertyDecl_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_PropertyDecl, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func PropertyDecl_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]PropertyDecl) (err error) {
	var vals []PropertyDecl
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_PropertyDecl, "-", e)
		} else {
			vals = make([]PropertyDecl, len(msgs))
			for i, msg := range msgs {
				if e := PropertyDecl_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_PropertyDecl, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func PropertyDecl_Detailed_Optional_Marshal(n jsonexp.Context, val **PropertyDecl) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = PropertyDecl_Detailed_Marshal(n, ptr)
	}
	return
}
func PropertyDecl_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **PropertyDecl) (err error) {
	if len(b) > 0 {
		var el PropertyDecl
		if e := PropertyDecl_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_PropertyDecl, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// PropertyType swaps between various options
type PropertyType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const PropertyType_PropertyAspect = "$PROPERTY_ASPECT"
const PropertyType_Primitive = "$PRIMITIVE"
const PropertyType_Ext = "$EXT"

func (*PropertyType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PropertyType,
		Uses: composer.Type_Swap,
		Choices: []string{
			PropertyType_PropertyAspect, PropertyType_Primitive, PropertyType_Ext,
		},
		Swaps: []interface{}{
			(*PropertyAspect)(nil),
			(*PrimitiveType)(nil),
			(*ExtType)(nil),
		},
	}
}

const Type_PropertyType = "property_type"

func (op *PropertyType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PropertyAspect:
		ret, okay = PropertyType_PropertyAspect, true
	case *PrimitiveType:
		ret, okay = PropertyType_Primitive, true
	case *ExtType:
		ret, okay = PropertyType_Ext, true
	}
	return
}
func (op *PropertyType) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return PropertyType_Detailed_Marshal(n, op)
}
func (op *PropertyType) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return PropertyType_Detailed_Unmarshal(n, b, op)
}

func PropertyType_Detailed_Marshal(n jsonexp.Context, val *PropertyType) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_PropertyType)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_PropertyType, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{Id: val.At.Offset,
					Type: Type_PropertyType,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func PropertyType_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *PropertyType) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_PropertyType, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case PropertyType_PropertyAspect:
				ptr = new(PropertyAspect)
			case PropertyType_Primitive:
				ptr = new(PrimitiveType)
			case PropertyType_Ext:
				ptr = new(ExtType)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_PropertyType, "-", e)
			} else {
				out.Opt = ptr
				out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
			}
		}
	}
	return
}

// RecordList
type RecordList struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RecordList,
		Uses: composer.Type_Flow,
	}
}

const Type_RecordList = "record_list"
const RecordList_Kind = "$KIND"

func (op *RecordList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RecordList_Detailed_Marshal(n, op)
}
func (op *RecordList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RecordList_Detailed_Unmarshal(n, b, op)
}

func RecordList_Detailed_Marshal(n jsonexp.Context, val *RecordList) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := RecordSingular_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RecordList_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_RecordList,
			Fields: fields,
		})
	}
	return
}

func RecordList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordList) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RecordList, "-", e)
	} else if e := RecordSingular_Detailed_Unmarshal(n, msg.Fields[RecordList_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_RecordList+"."+RecordList_Kind, "-", e)
	}
	return
}

func RecordList_Detailed_Optional_Marshal(n jsonexp.Context, val **RecordList) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = RecordList_Detailed_Marshal(n, ptr)
	}
	return
}
func RecordList_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **RecordList) (err error) {
	if len(b) > 0 {
		var el RecordList
		if e := RecordList_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_RecordList, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// RecordPlural requires a user-specified string.
type RecordPlural struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordPlural) String() (ret string) {
	return op.Str
}

func (*RecordPlural) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_RecordPlural,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_RecordPlural = "record_plural"

func (op *RecordPlural) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RecordPlural_Detailed_Marshal(n, op)
}
func (op *RecordPlural) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RecordPlural_Detailed_Unmarshal(n, b, op)
}
func RecordPlural_Detailed_Marshal(n jsonexp.Context, val *RecordPlural) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_RecordPlural,
		Value: val.Str,
	})
}

func RecordPlural_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordPlural) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_RecordPlural, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// RecordSingular requires a user-specified string.
type RecordSingular struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordSingular) String() (ret string) {
	return op.Str
}

func (*RecordSingular) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_RecordSingular,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_RecordSingular = "record_singular"

func (op *RecordSingular) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RecordSingular_Detailed_Marshal(n, op)
}
func (op *RecordSingular) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RecordSingular_Detailed_Unmarshal(n, b, op)
}
func RecordSingular_Detailed_Marshal(n jsonexp.Context, val *RecordSingular) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_RecordSingular,
		Value: val.Str,
	})
}

func RecordSingular_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordSingular) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_RecordSingular, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// RecordType
type RecordType struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RecordType,
		Uses: composer.Type_Flow,
	}
}

const Type_RecordType = "record_type"
const RecordType_Kind = "$KIND"

func (op *RecordType) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RecordType_Detailed_Marshal(n, op)
}
func (op *RecordType) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RecordType_Detailed_Unmarshal(n, b, op)
}

func RecordType_Detailed_Marshal(n jsonexp.Context, val *RecordType) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := RecordSingular_Detailed_Marshal(n, &val.Kind); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RecordType_Kind] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_RecordType,
			Fields: fields,
		})
	}
	return
}

func RecordType_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordType) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RecordType, "-", e)
	} else if e := RecordSingular_Detailed_Unmarshal(n, msg.Fields[RecordType_Kind], &out.Kind); e != nil {
		err = errutil.New(Type_RecordType+"."+RecordType_Kind, "-", e)
	}
	return
}

func RecordType_Detailed_Optional_Marshal(n jsonexp.Context, val **RecordType) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = RecordType_Detailed_Marshal(n, ptr)
	}
	return
}
func RecordType_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **RecordType) (err error) {
	if len(b) > 0 {
		var el RecordType
		if e := RecordType_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_RecordType, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// RecordsPossessProperties
type RecordsPossessProperties struct {
	RecordPlural RecordPlural   `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*RecordsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RecordsPossessProperties,
		Uses: composer.Type_Flow,
	}
}

const Type_RecordsPossessProperties = "records_possess_properties"
const RecordsPossessProperties_RecordPlural = "$RECORD_PLURAL"
const RecordsPossessProperties_PropertyDecl = "$PROPERTY_DECL"

func (op *RecordsPossessProperties) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RecordsPossessProperties_Detailed_Marshal(n, op)
}
func (op *RecordsPossessProperties) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RecordsPossessProperties_Detailed_Unmarshal(n, b, op)
}

func RecordsPossessProperties_Detailed_Marshal(n jsonexp.Context, val *RecordsPossessProperties) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := RecordPlural_Detailed_Marshal(n, &val.RecordPlural); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RecordsPossessProperties_RecordPlural] = b
	}
	if b, e := PropertyDecl_Detailed_Repeats_Marshal(n, &val.PropertyDecl); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RecordsPossessProperties_PropertyDecl] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_RecordsPossessProperties,
			Fields: fields,
		})
	}
	return
}

func RecordsPossessProperties_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RecordsPossessProperties) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RecordsPossessProperties, "-", e)
	} else if e := RecordPlural_Detailed_Unmarshal(n, msg.Fields[RecordsPossessProperties_RecordPlural], &out.RecordPlural); e != nil {
		err = errutil.New(Type_RecordsPossessProperties+"."+RecordsPossessProperties_RecordPlural, "-", e)
	} else if e := PropertyDecl_Detailed_Repeats_Unmarshal(n, msg.Fields[RecordsPossessProperties_PropertyDecl], &out.PropertyDecl); e != nil {
		err = errutil.New(Type_RecordsPossessProperties+"."+RecordsPossessProperties_PropertyDecl, "-", e)
	}
	return
}

func RecordsPossessProperties_Detailed_Optional_Marshal(n jsonexp.Context, val **RecordsPossessProperties) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = RecordsPossessProperties_Detailed_Marshal(n, ptr)
	}
	return
}
func RecordsPossessProperties_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **RecordsPossessProperties) (err error) {
	if len(b) > 0 {
		var el RecordsPossessProperties
		if e := RecordsPossessProperties_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_RecordsPossessProperties, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// RelationCardinality swaps between various options
type RelationCardinality struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const RelationCardinality_OneToOne = "$ONE_TO_ONE"
const RelationCardinality_OneToMany = "$ONE_TO_MANY"
const RelationCardinality_ManyToOne = "$MANY_TO_ONE"
const RelationCardinality_ManyToMany = "$MANY_TO_MANY"

func (*RelationCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RelationCardinality,
		Uses: composer.Type_Swap,
		Choices: []string{
			RelationCardinality_OneToOne, RelationCardinality_OneToMany, RelationCardinality_ManyToOne, RelationCardinality_ManyToMany,
		},
		Swaps: []interface{}{
			(*OneToOne)(nil),
			(*OneToMany)(nil),
			(*ManyToOne)(nil),
			(*ManyToMany)(nil),
		},
	}
}

const Type_RelationCardinality = "relation_cardinality"

func (op *RelationCardinality) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *OneToOne:
		ret, okay = RelationCardinality_OneToOne, true
	case *OneToMany:
		ret, okay = RelationCardinality_OneToMany, true
	case *ManyToOne:
		ret, okay = RelationCardinality_ManyToOne, true
	case *ManyToMany:
		ret, okay = RelationCardinality_ManyToMany, true
	}
	return
}
func (op *RelationCardinality) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RelationCardinality_Detailed_Marshal(n, op)
}
func (op *RelationCardinality) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RelationCardinality_Detailed_Unmarshal(n, b, op)
}

func RelationCardinality_Detailed_Marshal(n jsonexp.Context, val *RelationCardinality) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_RelationCardinality)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_RelationCardinality, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{Id: val.At.Offset,
					Type: Type_RelationCardinality,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func RelationCardinality_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RelationCardinality) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_RelationCardinality, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case RelationCardinality_OneToOne:
				ptr = new(OneToOne)
			case RelationCardinality_OneToMany:
				ptr = new(OneToMany)
			case RelationCardinality_ManyToOne:
				ptr = new(ManyToOne)
			case RelationCardinality_ManyToMany:
				ptr = new(ManyToMany)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_RelationCardinality, "-", e)
			} else {
				out.Opt = ptr
				out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
			}
		}
	}
	return
}

// RelativeToNoun
type RelativeToNoun struct {
	Relation value.RelationName `if:"label=_"`
	Nouns    []NamedNoun        `if:"label=nouns"`
	AreBeing AreBeing           `if:"label=are_being"`
	Nouns1   []NamedNoun        `if:"label=nouns1"`
}

func (*RelativeToNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RelativeToNoun,
		Uses: composer.Type_Flow,
	}
}

const Type_RelativeToNoun = "relative_to_noun"
const RelativeToNoun_Relation = "$RELATION"
const RelativeToNoun_Nouns = "$NOUNS"
const RelativeToNoun_AreBeing = "$ARE_BEING"
const RelativeToNoun_Nouns1 = "$NOUNS1"

func (op *RelativeToNoun) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RelativeToNoun_Detailed_Marshal(n, op)
}
func (op *RelativeToNoun) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RelativeToNoun_Detailed_Unmarshal(n, b, op)
}

func RelativeToNoun_Detailed_Marshal(n jsonexp.Context, val *RelativeToNoun) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.RelationName_Detailed_Marshal(n, &val.Relation); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RelativeToNoun_Relation] = b
	}
	if b, e := NamedNoun_Detailed_Repeats_Marshal(n, &val.Nouns); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RelativeToNoun_Nouns] = b
	}
	if b, e := AreBeing_Detailed_Marshal(n, &val.AreBeing); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RelativeToNoun_AreBeing] = b
	}
	if b, e := NamedNoun_Detailed_Repeats_Marshal(n, &val.Nouns1); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RelativeToNoun_Nouns1] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_RelativeToNoun,
			Fields: fields,
		})
	}
	return
}

func RelativeToNoun_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RelativeToNoun) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RelativeToNoun, "-", e)
	} else if e := value.RelationName_Detailed_Unmarshal(n, msg.Fields[RelativeToNoun_Relation], &out.Relation); e != nil {
		err = errutil.New(Type_RelativeToNoun+"."+RelativeToNoun_Relation, "-", e)
	} else if e := NamedNoun_Detailed_Repeats_Unmarshal(n, msg.Fields[RelativeToNoun_Nouns], &out.Nouns); e != nil {
		err = errutil.New(Type_RelativeToNoun+"."+RelativeToNoun_Nouns, "-", e)
	} else if e := AreBeing_Detailed_Unmarshal(n, msg.Fields[RelativeToNoun_AreBeing], &out.AreBeing); e != nil {
		err = errutil.New(Type_RelativeToNoun+"."+RelativeToNoun_AreBeing, "-", e)
	} else if e := NamedNoun_Detailed_Repeats_Unmarshal(n, msg.Fields[RelativeToNoun_Nouns1], &out.Nouns1); e != nil {
		err = errutil.New(Type_RelativeToNoun+"."+RelativeToNoun_Nouns1, "-", e)
	}
	return
}

func RelativeToNoun_Detailed_Optional_Marshal(n jsonexp.Context, val **RelativeToNoun) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = RelativeToNoun_Detailed_Marshal(n, ptr)
	}
	return
}
func RelativeToNoun_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **RelativeToNoun) (err error) {
	if len(b) > 0 {
		var el RelativeToNoun
		if e := RelativeToNoun_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_RelativeToNoun, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// RenderTemplate Parse text using iffy templates.
type RenderTemplate struct {
	Template value.Lines `if:"label=_"`
}

func (*RenderTemplate) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RenderTemplate,
		Uses: composer.Type_Flow,
	}
}

const Type_RenderTemplate = "render_template"
const RenderTemplate_Template = "$TEMPLATE"

func (op *RenderTemplate) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return RenderTemplate_Detailed_Marshal(n, op)
}
func (op *RenderTemplate) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return RenderTemplate_Detailed_Unmarshal(n, b, op)
}

func RenderTemplate_Detailed_Marshal(n jsonexp.Context, val *RenderTemplate) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Lines_Detailed_Marshal(n, &val.Template); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[RenderTemplate_Template] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_RenderTemplate,
			Fields: fields,
		})
	}
	return
}

func RenderTemplate_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *RenderTemplate) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_RenderTemplate, "-", e)
	} else if e := value.Lines_Detailed_Unmarshal(n, msg.Fields[RenderTemplate_Template], &out.Template); e != nil {
		err = errutil.New(Type_RenderTemplate+"."+RenderTemplate_Template, "-", e)
	}
	return
}

func RenderTemplate_Detailed_Optional_Marshal(n jsonexp.Context, val **RenderTemplate) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = RenderTemplate_Detailed_Marshal(n, ptr)
	}
	return
}
func RenderTemplate_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **RenderTemplate) (err error) {
	if len(b) > 0 {
		var el RenderTemplate
		if e := RenderTemplate_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_RenderTemplate, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Send
type Send struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=path"`
	Arguments *Arguments      `if:"label=arguments,optional"`
}

func (*Send) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Send,
		Uses: composer.Type_Flow,
	}
}

const Type_Send = "send"
const Send_Event = "$EVENT"
const Send_Path = "$PATH"
const Send_Arguments = "$ARGUMENTS"

func (op *Send) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Send_Detailed_Marshal(n, op)
}
func (op *Send) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Send_Detailed_Unmarshal(n, b, op)
}

func Send_Detailed_Marshal(n jsonexp.Context, val *Send) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Text_Detailed_Override_Marshal(n, &val.Event); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Send_Event] = b
	}
	if b, e := rt.TextListEval_Detailed_Marshal(n, &val.Path); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Send_Path] = b
	}
	if b, e := Arguments_Detailed_Optional_Marshal(n, &val.Arguments); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Send_Arguments] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Send,
			Fields: fields,
		})
	}
	return
}

func Send_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Send) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Send, "-", e)
	} else if e := value.Text_Detailed_Override_Unmarshal(n, msg.Fields[Send_Event], &out.Event); e != nil {
		err = errutil.New(Type_Send+"."+Send_Event, "-", e)
	} else if e := rt.TextListEval_Detailed_Unmarshal(n, msg.Fields[Send_Path], &out.Path); e != nil {
		err = errutil.New(Type_Send+"."+Send_Path, "-", e)
	} else if e := Arguments_Detailed_Optional_Unmarshal(n, msg.Fields[Send_Arguments], &out.Arguments); e != nil {
		err = errutil.New(Type_Send+"."+Send_Arguments, "-", e)
	}
	return
}

func Send_Detailed_Optional_Marshal(n jsonexp.Context, val **Send) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Send_Detailed_Marshal(n, ptr)
	}
	return
}
func Send_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Send) (err error) {
	if len(b) > 0 {
		var el Send
		if e := Send_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Send, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// ShuffleText
type ShuffleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*ShuffleText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ShuffleText,
		Uses: composer.Type_Flow,
	}
}

const Type_ShuffleText = "shuffle_text"
const ShuffleText_Parts = "$PARTS"

func (op *ShuffleText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return ShuffleText_Detailed_Marshal(n, op)
}
func (op *ShuffleText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return ShuffleText_Detailed_Unmarshal(n, b, op)
}

func ShuffleText_Detailed_Marshal(n jsonexp.Context, val *ShuffleText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Repeats_Marshal(n, &val.Parts); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[ShuffleText_Parts] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_ShuffleText,
			Fields: fields,
		})
	}
	return
}

func ShuffleText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *ShuffleText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_ShuffleText, "-", e)
	} else if e := rt.TextEval_Detailed_Repeats_Unmarshal(n, msg.Fields[ShuffleText_Parts], &out.Parts); e != nil {
		err = errutil.New(Type_ShuffleText+"."+ShuffleText_Parts, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func ShuffleText_Detailed_Optional_Marshal(n jsonexp.Context, val **ShuffleText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = ShuffleText_Detailed_Marshal(n, ptr)
	}
	return
}
func ShuffleText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **ShuffleText) (err error) {
	if len(b) > 0 {
		var el ShuffleText
		if e := ShuffleText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_ShuffleText, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// SingularKind requires a user-specified string.
type SingularKind struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *SingularKind) String() (ret string) {
	return op.Str
}

func (*SingularKind) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_SingularKind,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_SingularKind = "singular_kind"

func (op *SingularKind) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return SingularKind_Detailed_Marshal(n, op)
}
func (op *SingularKind) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return SingularKind_Detailed_Unmarshal(n, b, op)
}
func SingularKind_Detailed_Marshal(n jsonexp.Context, val *SingularKind) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_SingularKind,
		Value: val.Str,
	})
}

func SingularKind_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *SingularKind) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_SingularKind, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// StoppingText
type StoppingText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*StoppingText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_StoppingText,
		Uses: composer.Type_Flow,
	}
}

const Type_StoppingText = "stopping_text"
const StoppingText_Parts = "$PARTS"

func (op *StoppingText) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return StoppingText_Detailed_Marshal(n, op)
}
func (op *StoppingText) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return StoppingText_Detailed_Unmarshal(n, b, op)
}

func StoppingText_Detailed_Marshal(n jsonexp.Context, val *StoppingText) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := rt.TextEval_Detailed_Repeats_Marshal(n, &val.Parts); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[StoppingText_Parts] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_StoppingText,
			Fields: fields,
		})
	}
	return
}

func StoppingText_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *StoppingText) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_StoppingText, "-", e)
	} else if e := rt.TextEval_Detailed_Repeats_Unmarshal(n, msg.Fields[StoppingText_Parts], &out.Parts); e != nil {
		err = errutil.New(Type_StoppingText+"."+StoppingText_Parts, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func StoppingText_Detailed_Optional_Marshal(n jsonexp.Context, val **StoppingText) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = StoppingText_Detailed_Marshal(n, ptr)
	}
	return
}
func StoppingText_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **StoppingText) (err error) {
	if len(b) > 0 {
		var el StoppingText
		if e := StoppingText_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_StoppingText, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Story
type Story struct {
	Paragraph []Paragraph `if:"label=_,optional"`
}

func (*Story) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Story,
		Uses: composer.Type_Flow,
	}
}

const Type_Story = "story"
const Story_Paragraph = "$PARAGRAPH"

func (op *Story) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Story_Detailed_Marshal(n, op)
}
func (op *Story) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Story_Detailed_Unmarshal(n, b, op)
}

func Story_Detailed_Marshal(n jsonexp.Context, val *Story) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Paragraph_Detailed_Repeats_Marshal(n, &val.Paragraph); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Story_Paragraph] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Story,
			Fields: fields,
		})
	}
	return
}

func Story_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Story) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Story, "-", e)
	} else if e := Paragraph_Detailed_Repeats_Unmarshal(n, msg.Fields[Story_Paragraph], &out.Paragraph); e != nil {
		err = errutil.New(Type_Story+"."+Story_Paragraph, "-", e)
	}
	return
}

func Story_Detailed_Optional_Marshal(n jsonexp.Context, val **Story) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Story_Detailed_Marshal(n, ptr)
	}
	return
}
func Story_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Story) (err error) {
	if len(b) > 0 {
		var el Story
		if e := Story_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Story, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_StoryStatement = "story_statement"

func StoryStatement_Detailed_Marshal(n jsonexp.Context, ptr *StoryStatement) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_StoryStatement,
			Value: b,
		})
	}
	return
}

func StoryStatement_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *StoryStatement) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(StoryStatement); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_StoryStatement)
	} else {
		(*out) = store
	}
	return
}

func StoryStatement_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]StoryStatement) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := StoryStatement_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_StoryStatement, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func StoryStatement_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]StoryStatement) (err error) {
	var vals []StoryStatement
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_StoryStatement, "-", e)
		} else {
			vals = make([]StoryStatement, len(msgs))
			for i, msg := range msgs {
				if e := StoryStatement_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_StoryStatement, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

// Summary
type Summary struct {
	At    reader.Position `if:"internal"`
	Lines value.Lines     `if:"label=lines"`
}

func (*Summary) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Summary,
		Uses: composer.Type_Flow,
	}
}

const Type_Summary = "summary"
const Summary_Lines = "$LINES"

func (op *Summary) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Summary_Detailed_Marshal(n, op)
}
func (op *Summary) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Summary_Detailed_Unmarshal(n, b, op)
}

func Summary_Detailed_Marshal(n jsonexp.Context, val *Summary) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Lines_Detailed_Marshal(n, &val.Lines); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Summary_Lines] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_Summary,
			Fields: fields,
		})
	}
	return
}

func Summary_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Summary) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Summary, "-", e)
	} else if e := value.Lines_Detailed_Unmarshal(n, msg.Fields[Summary_Lines], &out.Lines); e != nil {
		err = errutil.New(Type_Summary+"."+Summary_Lines, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func Summary_Detailed_Optional_Marshal(n jsonexp.Context, val **Summary) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Summary_Detailed_Marshal(n, ptr)
	}
	return
}
func Summary_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Summary) (err error) {
	if len(b) > 0 {
		var el Summary
		if e := Summary_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Summary, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// Tail Adds details about the preceding noun or nouns.
type Tail struct {
	Pronoun    Pronoun    `if:"label=_"`
	NounPhrase NounPhrase `if:"label=noun_phrase"`
}

func (*Tail) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Tail,
		Uses: composer.Type_Flow,
	}
}

const Type_Tail = "tail"
const Tail_Pronoun = "$PRONOUN"
const Tail_NounPhrase = "$NOUN_PHRASE"

func (op *Tail) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Tail_Detailed_Marshal(n, op)
}
func (op *Tail) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Tail_Detailed_Unmarshal(n, b, op)
}

func Tail_Detailed_Marshal(n jsonexp.Context, val *Tail) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Pronoun_Detailed_Marshal(n, &val.Pronoun); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Tail_Pronoun] = b
	}
	if b, e := NounPhrase_Detailed_Marshal(n, &val.NounPhrase); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[Tail_NounPhrase] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_Tail,
			Fields: fields,
		})
	}
	return
}

func Tail_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Tail) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_Tail, "-", e)
	} else if e := Pronoun_Detailed_Unmarshal(n, msg.Fields[Tail_Pronoun], &out.Pronoun); e != nil {
		err = errutil.New(Type_Tail+"."+Tail_Pronoun, "-", e)
	} else if e := NounPhrase_Detailed_Unmarshal(n, msg.Fields[Tail_NounPhrase], &out.NounPhrase); e != nil {
		err = errutil.New(Type_Tail+"."+Tail_NounPhrase, "-", e)
	}
	return
}

func Tail_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Tail) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := Tail_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_Tail, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Tail_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Tail) (err error) {
	var vals []Tail
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_Tail, "-", e)
		} else {
			vals = make([]Tail, len(msgs))
			for i, msg := range msgs {
				if e := Tail_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_Tail, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func Tail_Detailed_Optional_Marshal(n jsonexp.Context, val **Tail) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = Tail_Detailed_Marshal(n, ptr)
	}
	return
}
func Tail_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **Tail) (err error) {
	if len(b) > 0 {
		var el Tail
		if e := Tail_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_Tail, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// TestName requires a user-specified string.
type TestName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *TestName) String() (ret string) {
	return op.Str
}

const TestName_CurrentTest = "$CURRENT_TEST"

func (*TestName) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_TestName,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			TestName_CurrentTest,
		},
		Strings: []string{
			"current_test",
		},
	}
}

const Type_TestName = "test_name"

func (op *TestName) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TestName_Detailed_Marshal(n, op)
}
func (op *TestName) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TestName_Detailed_Unmarshal(n, b, op)
}
func TestName_Detailed_Marshal(n jsonexp.Context, val *TestName) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_TestName,
		Value: val.Str,
	})
}

func TestName_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TestName) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_TestName, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

// TestOutput Expect that a test uses &#x27;Say&#x27; to print some specific text.
type TestOutput struct {
	Lines value.Lines `if:"label=_"`
}

func (*TestOutput) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TestOutput,
		Uses: composer.Type_Flow,
	}
}

const Type_TestOutput = "test_output"
const TestOutput_Lines = "$LINES"

func (op *TestOutput) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TestOutput_Detailed_Marshal(n, op)
}
func (op *TestOutput) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TestOutput_Detailed_Unmarshal(n, b, op)
}

func TestOutput_Detailed_Marshal(n jsonexp.Context, val *TestOutput) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := value.Lines_Detailed_Marshal(n, &val.Lines); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TestOutput_Lines] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_TestOutput,
			Fields: fields,
		})
	}
	return
}

func TestOutput_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TestOutput) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_TestOutput, "-", e)
	} else if e := value.Lines_Detailed_Unmarshal(n, msg.Fields[TestOutput_Lines], &out.Lines); e != nil {
		err = errutil.New(Type_TestOutput+"."+TestOutput_Lines, "-", e)
	}
	return
}

func TestOutput_Detailed_Optional_Marshal(n jsonexp.Context, val **TestOutput) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TestOutput_Detailed_Marshal(n, ptr)
	}
	return
}
func TestOutput_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TestOutput) (err error) {
	if len(b) > 0 {
		var el TestOutput
		if e := TestOutput_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_TestOutput, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// TestRule
type TestRule struct {
	TestName TestName    `if:"label=_"`
	Hook     ProgramHook `if:"label=hook"`
}

func (*TestRule) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TestRule,
		Uses: composer.Type_Flow,
	}
}

const Type_TestRule = "test_rule"
const TestRule_TestName = "$TEST_NAME"
const TestRule_Hook = "$HOOK"

func (op *TestRule) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TestRule_Detailed_Marshal(n, op)
}
func (op *TestRule) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TestRule_Detailed_Unmarshal(n, b, op)
}

func TestRule_Detailed_Marshal(n jsonexp.Context, val *TestRule) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := TestName_Detailed_Marshal(n, &val.TestName); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TestRule_TestName] = b
	}
	if b, e := ProgramHook_Detailed_Marshal(n, &val.Hook); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TestRule_Hook] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_TestRule,
			Fields: fields,
		})
	}
	return
}

func TestRule_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TestRule) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_TestRule, "-", e)
	} else if e := TestName_Detailed_Unmarshal(n, msg.Fields[TestRule_TestName], &out.TestName); e != nil {
		err = errutil.New(Type_TestRule+"."+TestRule_TestName, "-", e)
	} else if e := ProgramHook_Detailed_Unmarshal(n, msg.Fields[TestRule_Hook], &out.Hook); e != nil {
		err = errutil.New(Type_TestRule+"."+TestRule_Hook, "-", e)
	}
	return
}

func TestRule_Detailed_Optional_Marshal(n jsonexp.Context, val **TestRule) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TestRule_Detailed_Marshal(n, ptr)
	}
	return
}
func TestRule_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TestRule) (err error) {
	if len(b) > 0 {
		var el TestRule
		if e := TestRule_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_TestRule, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// TestScene
type TestScene struct {
	TestName TestName `if:"label=_"`
	Story    Story    `if:"label=story"`
}

func (*TestScene) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TestScene,
		Uses: composer.Type_Flow,
	}
}

const Type_TestScene = "test_scene"
const TestScene_TestName = "$TEST_NAME"
const TestScene_Story = "$STORY"

func (op *TestScene) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TestScene_Detailed_Marshal(n, op)
}
func (op *TestScene) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TestScene_Detailed_Unmarshal(n, b, op)
}

func TestScene_Detailed_Marshal(n jsonexp.Context, val *TestScene) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := TestName_Detailed_Marshal(n, &val.TestName); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TestScene_TestName] = b
	}
	if b, e := Story_Detailed_Marshal(n, &val.Story); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TestScene_Story] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_TestScene,
			Fields: fields,
		})
	}
	return
}

func TestScene_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TestScene) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_TestScene, "-", e)
	} else if e := TestName_Detailed_Unmarshal(n, msg.Fields[TestScene_TestName], &out.TestName); e != nil {
		err = errutil.New(Type_TestScene+"."+TestScene_TestName, "-", e)
	} else if e := Story_Detailed_Unmarshal(n, msg.Fields[TestScene_Story], &out.Story); e != nil {
		err = errutil.New(Type_TestScene+"."+TestScene_Story, "-", e)
	}
	return
}

func TestScene_Detailed_Optional_Marshal(n jsonexp.Context, val **TestScene) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TestScene_Detailed_Marshal(n, ptr)
	}
	return
}
func TestScene_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TestScene) (err error) {
	if len(b) > 0 {
		var el TestScene
		if e := TestScene_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_TestScene, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// TestStatement
type TestStatement struct {
	At       reader.Position `if:"internal"`
	TestName TestName        `if:"label=test_name"`
	Test     Testing         `if:"label=test"`
}

func (*TestStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TestStatement,
		Uses: composer.Type_Flow,
	}
}

const Type_TestStatement = "test_statement"
const TestStatement_TestName = "$TEST_NAME"
const TestStatement_Test = "$TEST"

func (op *TestStatement) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TestStatement_Detailed_Marshal(n, op)
}
func (op *TestStatement) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TestStatement_Detailed_Unmarshal(n, b, op)
}

func TestStatement_Detailed_Marshal(n jsonexp.Context, val *TestStatement) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := TestName_Detailed_Marshal(n, &val.TestName); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TestStatement_TestName] = b
	}
	if b, e := Testing_Detailed_Marshal(n, &val.Test); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TestStatement_Test] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{Id: val.At.Offset,
			Type:   Type_TestStatement,
			Fields: fields,
		})
	}
	return
}

func TestStatement_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TestStatement) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_TestStatement, "-", e)
	} else if e := TestName_Detailed_Unmarshal(n, msg.Fields[TestStatement_TestName], &out.TestName); e != nil {
		err = errutil.New(Type_TestStatement+"."+TestStatement_TestName, "-", e)
	} else if e := Testing_Detailed_Unmarshal(n, msg.Fields[TestStatement_Test], &out.Test); e != nil {
		err = errutil.New(Type_TestStatement+"."+TestStatement_Test, "-", e)
	} else {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
	}
	return
}

func TestStatement_Detailed_Optional_Marshal(n jsonexp.Context, val **TestStatement) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TestStatement_Detailed_Marshal(n, ptr)
	}
	return
}
func TestStatement_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TestStatement) (err error) {
	if len(b) > 0 {
		var el TestStatement
		if e := TestStatement_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_TestStatement, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

const Type_Testing = "testing"

func Testing_Detailed_Marshal(n jsonexp.Context, ptr *Testing) (ret []byte, err error) {
	var b []byte
	if slat := *ptr; slat != nil {
		b, err = slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n)
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Node{
			Type:  Type_Testing,
			Value: b,
		})
	}
	return
}

func Testing_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Testing) (err error) {
	if ptr, e := jsonexp.UnmarshalDetailedSlot(n, b); e != nil {
		err = e
	} else if store, ok := ptr.(Testing); !ok && ptr != nil {
		err = errutil.Fmt("couldnt store %T into %s", ptr, Type_Testing)
	} else {
		(*out) = store
	}
	return
}

// TextList requires a user-specified string.
type TextList struct {
	Str string
}

func (op *TextList) String() (ret string) {
	return op.Str
}

const TextList_List = "$LIST"

func (*TextList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TextList,
		Uses: composer.Type_Str,
		Choices: []string{
			TextList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

const Type_TextList = "text_list"

func (op *TextList) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TextList_Detailed_Marshal(n, op)
}
func (op *TextList) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TextList_Detailed_Unmarshal(n, b, op)
}
func TextList_Detailed_Marshal(n jsonexp.Context, val *TextList) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Type:  Type_TextList,
		Value: val.Str,
	})
}

func TextList_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TextList) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_TextList, "-", e)
		}
	}
	if err == nil {
		out.Str = msg.Value
	}
	return
}

// Trait requires a user-specified string.
type Trait struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Trait) String() (ret string) {
	return op.Str
}

func (*Trait) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Trait,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Type_Trait = "trait"

func (op *Trait) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return Trait_Detailed_Marshal(n, op)
}
func (op *Trait) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return Trait_Detailed_Unmarshal(n, b, op)
}
func Trait_Detailed_Marshal(n jsonexp.Context, val *Trait) ([]byte, error) {
	return json.Marshal(jsonexp.Str{
		Id:    val.At.Offset,
		Type:  Type_Trait,
		Value: val.Str,
	})
}

func Trait_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *Trait) (err error) {
	var msg jsonexp.Str
	if len(b) > 0 { // generated code collapses optional and empty.
		if e := json.Unmarshal(b, &msg); e != nil {
			err = errutil.New(Type_Trait, "-", e)
		}
	}
	if err == nil {
		out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
		out.Str = msg.Value
	}
	return
}

func Trait_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]Trait) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := Trait_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_Trait, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func Trait_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]Trait) (err error) {
	var vals []Trait
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_Trait, "-", e)
		} else {
			vals = make([]Trait, len(msgs))
			for i, msg := range msgs {
				if e := Trait_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_Trait, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

// TraitPhrase
type TraitPhrase struct {
	AreEither AreEither `if:"label=_"`
	Trait     []Trait   `if:"label=trait"`
}

func (*TraitPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TraitPhrase,
		Uses: composer.Type_Flow,
	}
}

const Type_TraitPhrase = "trait_phrase"
const TraitPhrase_AreEither = "$ARE_EITHER"
const TraitPhrase_Trait = "$TRAIT"

func (op *TraitPhrase) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return TraitPhrase_Detailed_Marshal(n, op)
}
func (op *TraitPhrase) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return TraitPhrase_Detailed_Unmarshal(n, b, op)
}

func TraitPhrase_Detailed_Marshal(n jsonexp.Context, val *TraitPhrase) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := AreEither_Detailed_Marshal(n, &val.AreEither); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TraitPhrase_AreEither] = b
	}
	if b, e := Trait_Detailed_Repeats_Marshal(n, &val.Trait); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[TraitPhrase_Trait] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_TraitPhrase,
			Fields: fields,
		})
	}
	return
}

func TraitPhrase_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *TraitPhrase) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_TraitPhrase, "-", e)
	} else if e := AreEither_Detailed_Unmarshal(n, msg.Fields[TraitPhrase_AreEither], &out.AreEither); e != nil {
		err = errutil.New(Type_TraitPhrase+"."+TraitPhrase_AreEither, "-", e)
	} else if e := Trait_Detailed_Repeats_Unmarshal(n, msg.Fields[TraitPhrase_Trait], &out.Trait); e != nil {
		err = errutil.New(Type_TraitPhrase+"."+TraitPhrase_Trait, "-", e)
	}
	return
}

func TraitPhrase_Detailed_Optional_Marshal(n jsonexp.Context, val **TraitPhrase) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = TraitPhrase_Detailed_Marshal(n, ptr)
	}
	return
}
func TraitPhrase_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **TraitPhrase) (err error) {
	if len(b) > 0 {
		var el TraitPhrase
		if e := TraitPhrase_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_TraitPhrase, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// VariableDecl
type VariableDecl struct {
	An      Determiner         `if:"label=_"`
	Name    value.VariableName `if:"label=name"`
	Type    VariableType       `if:"label=type"`
	Comment value.Lines        `if:"label=comment,optional"`
}

func (*VariableDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_VariableDecl,
		Uses: composer.Type_Flow,
	}
}

const Type_VariableDecl = "variable_decl"
const VariableDecl_An = "$AN"
const VariableDecl_Name = "$NAME"
const VariableDecl_Type = "$TYPE"
const VariableDecl_Comment = "$COMMENT"

func (op *VariableDecl) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return VariableDecl_Detailed_Marshal(n, op)
}
func (op *VariableDecl) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return VariableDecl_Detailed_Unmarshal(n, b, op)
}

func VariableDecl_Detailed_Marshal(n jsonexp.Context, val *VariableDecl) (ret []byte, err error) {
	var fields jsonexp.Fields
	fields = make(jsonexp.Fields)
	if b, e := Determiner_Detailed_Marshal(n, &val.An); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[VariableDecl_An] = b
	}
	if b, e := value.VariableName_Detailed_Marshal(n, &val.Name); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[VariableDecl_Name] = b
	}
	if b, e := VariableType_Detailed_Marshal(n, &val.Type); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[VariableDecl_Type] = b
	}
	if b, e := value.Lines_Detailed_Marshal(n, &val.Comment); e != nil {
		err = errutil.Append(err, e)
	} else if len(b) > 0 {
		fields[VariableDecl_Comment] = b
	}
	if err == nil {
		ret, err = json.Marshal(jsonexp.Flow{
			Type:   Type_VariableDecl,
			Fields: fields,
		})
	}
	return
}

func VariableDecl_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *VariableDecl) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New(Type_VariableDecl, "-", e)
	} else if e := Determiner_Detailed_Unmarshal(n, msg.Fields[VariableDecl_An], &out.An); e != nil {
		err = errutil.New(Type_VariableDecl+"."+VariableDecl_An, "-", e)
	} else if e := value.VariableName_Detailed_Unmarshal(n, msg.Fields[VariableDecl_Name], &out.Name); e != nil {
		err = errutil.New(Type_VariableDecl+"."+VariableDecl_Name, "-", e)
	} else if e := VariableType_Detailed_Unmarshal(n, msg.Fields[VariableDecl_Type], &out.Type); e != nil {
		err = errutil.New(Type_VariableDecl+"."+VariableDecl_Type, "-", e)
	} else if e := value.Lines_Detailed_Unmarshal(n, msg.Fields[VariableDecl_Comment], &out.Comment); e != nil {
		err = errutil.New(Type_VariableDecl+"."+VariableDecl_Comment, "-", e)
	}
	return
}

func VariableDecl_Detailed_Repeats_Marshal(n jsonexp.Context, vals *[]VariableDecl) (ret []byte, err error) {
	var msgs []json.RawMessage
	msgs = make([]json.RawMessage, len(*vals))
	for i, el := range *vals {
		if b, e := VariableDecl_Detailed_Marshal(n, &el); e != nil {
			err = errutil.New(Type_VariableDecl, "at", i, "-", e)
			break
		} else {
			msgs[i] = b
		}
	}
	if err == nil {
		ret, err = json.Marshal(msgs)
	}
	return
}

func VariableDecl_Detailed_Repeats_Unmarshal(n jsonexp.Context, b []byte, out *[]VariableDecl) (err error) {
	var vals []VariableDecl
	if len(b) > 0 { // generated code collapses optional and empty.
		var msgs []json.RawMessage
		if e := json.Unmarshal(b, &msgs); e != nil {
			err = errutil.New(Type_VariableDecl, "-", e)
		} else {
			vals = make([]VariableDecl, len(msgs))
			for i, msg := range msgs {
				if e := VariableDecl_Detailed_Unmarshal(n, msg, &vals[i]); e != nil {
					err = errutil.New(Type_VariableDecl, "at", i, "-", e)
					break
				}
			}
		}
	}
	if err == nil {
		*out = vals
	}
	return
}

func VariableDecl_Detailed_Optional_Marshal(n jsonexp.Context, val **VariableDecl) (ret []byte, err error) {
	if ptr := *val; ptr != nil {
		ret, err = VariableDecl_Detailed_Marshal(n, ptr)
	}
	return
}
func VariableDecl_Detailed_Optional_Unmarshal(n jsonexp.Context, b []byte, out **VariableDecl) (err error) {
	if len(b) > 0 {
		var el VariableDecl
		if e := VariableDecl_Detailed_Unmarshal(n, b, &el); e != nil {
			err = errutil.New(Type_VariableDecl, "-", e)
		} else {
			*out = &el
		}
	}
	return
}

// VariableType swaps between various options
type VariableType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const VariableType_Primitive = "$PRIMITIVE"
const VariableType_Object = "$OBJECT"
const VariableType_Ext = "$EXT"

func (*VariableType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_VariableType,
		Uses: composer.Type_Swap,
		Choices: []string{
			VariableType_Primitive, VariableType_Object, VariableType_Ext,
		},
		Swaps: []interface{}{
			(*PrimitiveType)(nil),
			(*ObjectType)(nil),
			(*ExtType)(nil),
		},
	}
}

const Type_VariableType = "variable_type"

func (op *VariableType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PrimitiveType:
		ret, okay = VariableType_Primitive, true
	case *ObjectType:
		ret, okay = VariableType_Object, true
	case *ExtType:
		ret, okay = VariableType_Ext, true
	}
	return
}
func (op *VariableType) MarshalDetailed(n jsonexp.Context) (ret []byte, err error) {
	return VariableType_Detailed_Marshal(n, op)
}
func (op *VariableType) UnmarshalDetailed(n jsonexp.Context, b []byte) error {
	return VariableType_Detailed_Unmarshal(n, b, op)
}

func VariableType_Detailed_Marshal(n jsonexp.Context, val *VariableType) (ret []byte, err error) {
	if pick, ok := val.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %s", val.Opt, Type_VariableType)
	} else if slat := val.Opt; len(pick) > 0 {
		if b, e := slat.(jsonexp.DetailedMarshaler).MarshalDetailed(n); e != nil {
			err = errutil.New(Type_VariableType, "-", e)
		} else {
			ret, err = json.Marshal(
				jsonexp.Flow{Id: val.At.Offset,
					Type: Type_VariableType,
					Fields: jsonexp.Fields{
						pick: b,
					},
				})
		}
	}
	return
}

func VariableType_Detailed_Unmarshal(n jsonexp.Context, b []byte, out *VariableType) (err error) {
	var msg jsonexp.Flow
	if e := json.Unmarshal(b, &msg); e != nil {
		err = errutil.New("value of", Type_VariableType, "-", e)
	} else {
		var ptr jsonexp.DetailedMarshaler
		var raw json.RawMessage
		for k, v := range msg.Fields {
			switch k {
			case VariableType_Primitive:
				ptr = new(PrimitiveType)
			case VariableType_Object:
				ptr = new(ObjectType)
			case VariableType_Ext:
				ptr = new(ExtType)
			default:
				err = errutil.New("unknown choice", k, n.Source(), msg.Id)
			}
			raw = v
			break
		}
		if ptr == nil {
			err = errutil.New("missing choice", n.Source(), msg.Id)
		} else if err == nil {
			if e := ptr.UnmarshalDetailed(n, raw); e != nil {
				err = errutil.New("contents of", Type_VariableType, "-", e)
			} else {
				out.Opt = ptr
				out.At = reader.Position{Source: n.Source(), Offset: msg.Id}
			}
		}
	}
	return
}

var Slots = []interface{}{
	(*StoryStatement)(nil),
	(*Testing)(nil),
}

var Slats = []composer.Composer{
	(*AbstractAction)(nil),
	(*ActionContext)(nil),
	(*ActionDecl)(nil),
	(*ActionName)(nil),
	(*ActionParams)(nil),
	(*Ana)(nil),
	(*AreAn)(nil),
	(*AreBeing)(nil),
	(*AreEither)(nil),
	(*Argument)(nil),
	(*Arguments)(nil),
	(*Aspect)(nil),
	(*AspectTraits)(nil),
	(*BoxedNumber)(nil),
	(*BoxedText)(nil),
	(*Certainties)(nil),
	(*Certainty)(nil),
	(*Comment)(nil),
	(*CommonAction)(nil),
	(*CountOf)(nil),
	(*CycleText)(nil),
	(*Determine)(nil),
	(*Determiner)(nil),
	(*EventBlock)(nil),
	(*EventHandler)(nil),
	(*EventName)(nil),
	(*EventPhase)(nil),
	(*EventTarget)(nil),
	(*ExtType)(nil),
	(*GrammarDecl)(nil),
	(*KindOfNoun)(nil),
	(*KindOfRelation)(nil),
	(*KindsOfAspect)(nil),
	(*KindsOfKind)(nil),
	(*KindsOfRecord)(nil),
	(*KindsPossessProperties)(nil),
	(*Lede)(nil),
	(*LocalDecl)(nil),
	(*LocalInit)(nil),
	(*Make)(nil),
	(*ManyToMany)(nil),
	(*ManyToOne)(nil),
	(*NamedNoun)(nil),
	(*NounAssignment)(nil),
	(*NounName)(nil),
	(*NounPhrase)(nil),
	(*NounRelation)(nil),
	(*NounStatement)(nil),
	(*NounTraits)(nil),
	(*NumberList)(nil),
	(*ObjectType)(nil),
	(*OneToMany)(nil),
	(*OneToOne)(nil),
	(*PairedAction)(nil),
	(*Paragraph)(nil),
	(*PatternActions)(nil),
	(*PatternDecl)(nil),
	(*PatternFlags)(nil),
	(*PatternLocals)(nil),
	(*PatternReturn)(nil),
	(*PatternRule)(nil),
	(*PatternRules)(nil),
	(*PatternType)(nil),
	(*PatternVariablesDecl)(nil),
	(*PatternVariablesTail)(nil),
	(*PluralKinds)(nil),
	(*PrimitiveType)(nil),
	(*PrimitiveValue)(nil),
	(*ProgramHook)(nil),
	(*Pronoun)(nil),
	(*Property)(nil),
	(*PropertyAspect)(nil),
	(*PropertyDecl)(nil),
	(*PropertyType)(nil),
	(*RecordList)(nil),
	(*RecordPlural)(nil),
	(*RecordSingular)(nil),
	(*RecordType)(nil),
	(*RecordsPossessProperties)(nil),
	(*RelationCardinality)(nil),
	(*RelativeToNoun)(nil),
	(*RenderTemplate)(nil),
	(*Send)(nil),
	(*ShuffleText)(nil),
	(*SingularKind)(nil),
	(*StoppingText)(nil),
	(*Story)(nil),
	(*Summary)(nil),
	(*Tail)(nil),
	(*TestName)(nil),
	(*TestOutput)(nil),
	(*TestRule)(nil),
	(*TestScene)(nil),
	(*TestStatement)(nil),
	(*TextList)(nil),
	(*Trait)(nil),
	(*TraitPhrase)(nil),
	(*VariableDecl)(nil),
	(*VariableType)(nil),
}
