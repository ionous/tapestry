// Code generated by "makeops"; edit at your own risk.
package story

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/grammar"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
)

// AbstractAction requires a user-specified string.
type AbstractAction struct {
	Str string
}

func (op *AbstractAction) String() (ret string) {
	return op.Str
}

const AbstractAction_Nothing = "$NOTHING"

func (*AbstractAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "abstract_action",
		Uses: "str",
		Choices: []string{
			AbstractAction_Nothing,
		},
		Strings: []string{
			"nothing",
		},
	}
}

// ActionContext
type ActionContext struct {
	At   reader.Position `if:"internal"`
	Kind SingularKind    `if:"label=kind"`
}

func (*ActionContext) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_context",
		Uses: "flow",
	}
}

// ActionDecl
type ActionDecl struct {
	At           reader.Position `if:"internal"`
	Event        EventName       `if:"label=event"`
	Action       ActionName      `if:"label=action"`
	ActionParams ActionParams    `if:"label=action_params"`
}

var _ StoryStatement = (*ActionDecl)(nil)

func (*ActionDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_decl",
		Uses: "flow",
	}
}

// ActionName requires a user-specified string.
type ActionName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *ActionName) String() (ret string) {
	return op.Str
}

func (*ActionName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "action_name",
		Uses:        "str",
		OpenStrings: true,
	}
}

// ActionParams swaps between various options
type ActionParams struct {
	Opt interface{}
}

func (*ActionParams) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_params",
		Uses: "swap",
	}
}

func (*ActionParams) Choices() map[string]interface{} {
	return map[string]interface{}{
		"common": (*CommonAction)(nil),
		"dual":   (*PairedAction)(nil),
		"none":   (*AbstractAction)(nil),
	}
}

// Ana requires a user-specified string.
type Ana struct {
	Str string
}

func (op *Ana) String() (ret string) {
	return op.Str
}

const Ana_A = "$A"
const Ana_An = "$AN"

func (*Ana) Compose() composer.Spec {
	return composer.Spec{
		Name: "ana",
		Uses: "str",
		Choices: []string{
			Ana_A, Ana_An,
		},
		Strings: []string{
			"a", "an",
		},
	}
}

// AreAn requires a user-specified string.
type AreAn struct {
	Str string
}

func (op *AreAn) String() (ret string) {
	return op.Str
}

const AreAn_Are = "$ARE"
const AreAn_Area = "$AREA"
const AreAn_Arean = "$AREAN"
const AreAn_Is = "$IS"
const AreAn_Isa = "$ISA"
const AreAn_Isan = "$ISAN"

func (*AreAn) Compose() composer.Spec {
	return composer.Spec{
		Name: "are_an",
		Uses: "str",
		Choices: []string{
			AreAn_Are, AreAn_Area, AreAn_Arean, AreAn_Is, AreAn_Isa, AreAn_Isan,
		},
		Strings: []string{
			"are", "area", "arean", "is", "isa", "isan",
		},
	}
}

// AreBeing requires a user-specified string.
type AreBeing struct {
	Str string
}

func (op *AreBeing) String() (ret string) {
	return op.Str
}

const AreBeing_Are = "$ARE"
const AreBeing_Is = "$IS"

func (*AreBeing) Compose() composer.Spec {
	return composer.Spec{
		Name: "are_being",
		Uses: "str",
		Choices: []string{
			AreBeing_Are, AreBeing_Is,
		},
		Strings: []string{
			"are", "is",
		},
	}
}

// AreEither requires a user-specified string.
type AreEither struct {
	Str string
}

func (op *AreEither) String() (ret string) {
	return op.Str
}

const AreEither_Canbe = "$CANBE"
const AreEither_Either = "$EITHER"

func (*AreEither) Compose() composer.Spec {
	return composer.Spec{
		Name: "are_either",
		Uses: "str",
		Choices: []string{
			AreEither_Canbe, AreEither_Either,
		},
		Strings: []string{
			"canbe", "either",
		},
	}
}

// Argument
type Argument struct {
	At   reader.Position `if:"internal"`
	Name string          `if:"label=_,type=text"`
	From rt.Assignment   `if:"label=from"`
}

func (*Argument) Compose() composer.Spec {
	return composer.Spec{
		Name: "argument",
		Uses: "flow",
		Lede: "arg",
	}
}

// Arguments
type Arguments struct {
	At   reader.Position `if:"internal"`
	Args []Argument      `if:"label=_"`
}

func (*Arguments) Compose() composer.Spec {
	return composer.Spec{
		Name: "arguments",
		Uses: "flow",
		Lede: "args",
	}
}

// Aspect requires a user-specified string.
type Aspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Aspect) String() (ret string) {
	return op.Str
}

func (*Aspect) Compose() composer.Spec {
	return composer.Spec{
		Name:        "aspect",
		Uses:        "str",
		OpenStrings: true,
	}
}

// AspectTraits
type AspectTraits struct {
	Aspect      Aspect      `if:"label=_"`
	TraitPhrase TraitPhrase `if:"label=trait_phrase"`
}

var _ StoryStatement = (*AspectTraits)(nil)

func (*AspectTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: "aspect_traits",
		Uses: "flow",
	}
}

// BoxedNumber
type BoxedNumber struct {
	Number float64 `if:"label=_,type=number"`
}

func (*BoxedNumber) Compose() composer.Spec {
	return composer.Spec{
		Name: "boxed_number",
		Uses: "flow",
	}
}

// BoxedText
type BoxedText struct {
	Text string `if:"label=_,type=text"`
}

func (*BoxedText) Compose() composer.Spec {
	return composer.Spec{
		Name: "boxed_text",
		Uses: "flow",
	}
}

// Certainties
type Certainties struct {
	PluralKinds PluralKinds `if:"label=_"`
	AreBeing    bool        `if:"label=are_being,type=are_being"`
	Certainty   Certainty   `if:"label=certainty"`
	Trait       Trait       `if:"label=trait"`
}

var _ StoryStatement = (*Certainties)(nil)

func (*Certainties) Compose() composer.Spec {
	return composer.Spec{
		Name: "certainties",
		Uses: "flow",
	}
}

// Certainty requires a user-specified string.
type Certainty struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Certainty) String() (ret string) {
	return op.Str
}

const Certainty_Usually = "$USUALLY"
const Certainty_Always = "$ALWAYS"
const Certainty_Seldom = "$SELDOM"
const Certainty_Never = "$NEVER"

func (*Certainty) Compose() composer.Spec {
	return composer.Spec{
		Name: "certainty",
		Uses: "str",
		Choices: []string{
			Certainty_Usually, Certainty_Always, Certainty_Seldom, Certainty_Never,
		},
		Strings: []string{
			"usually", "always", "seldom", "never",
		},
	}
}

// Comment Information about the story for you and other authors.
type Comment struct {
	Lines value.Lines `if:"label=_"`
}

var _ StoryStatement = (*Comment)(nil)
var _ rt.Execute = (*Comment)(nil)

func (*Comment) Compose() composer.Spec {
	return composer.Spec{
		Name: "comment",
		Uses: "flow",
	}
}

// CommonAction
type CommonAction struct {
	At            reader.Position `if:"internal"`
	Kind          SingularKind    `if:"label=kind"`
	ActionContext *ActionContext  `if:"label=action_context,optional"`
}

func (*CommonAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "common_action",
		Uses: "flow",
	}
}

// CountOf A guard which returns true based on a counter.
type CountOf struct {
	At      reader.Position `if:"internal"`
	Trigger core.Trigger    `if:"label=trigger"`
	Num     rt.NumberEval   `if:"label=num"`
}

var _ rt.BoolEval = (*CountOf)(nil)

func (*CountOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "count_of",
		Uses: "flow",
	}
}

// CycleText
type CycleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

var _ rt.TextEval = (*CycleText)(nil)

func (*CycleText) Compose() composer.Spec {
	return composer.Spec{
		Name: "cycle_text",
		Uses: "flow",
	}
}

// Determine
type Determine struct {
	Name      value.PatternName `if:"label=_"`
	Arguments *Arguments        `if:"label=arguments,optional"`
}

var _ rt.Execute = (*Determine)(nil)
var _ rt.BoolEval = (*Determine)(nil)
var _ rt.NumberEval = (*Determine)(nil)
var _ rt.TextEval = (*Determine)(nil)
var _ rt.RecordEval = (*Determine)(nil)
var _ rt.NumListEval = (*Determine)(nil)
var _ rt.TextListEval = (*Determine)(nil)
var _ rt.RecordListEval = (*Determine)(nil)

func (*Determine) Compose() composer.Spec {
	return composer.Spec{
		Name: "determine",
		Uses: "flow",
	}
}

// Determiner requires a user-specified string.
type Determiner struct {
	Str string
}

func (op *Determiner) String() (ret string) {
	return op.Str
}

const Determiner_A = "$A"
const Determiner_An = "$AN"
const Determiner_The = "$THE"
const Determiner_Our = "$OUR"

func (*Determiner) Compose() composer.Spec {
	return composer.Spec{
		Name:        "determiner",
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			Determiner_A, Determiner_An, Determiner_The, Determiner_Our,
		},
		Strings: []string{
			"a", "an", "the", "our",
		},
	}
}

// EventBlock Listeners let objects in the game world react to changes before, during, or after they happen.
type EventBlock struct {
	At       reader.Position `if:"internal"`
	Target   EventTarget     `if:"label=target"`
	Handlers []EventHandler  `if:"label=handlers"`
}

var _ StoryStatement = (*EventBlock)(nil)

func (*EventBlock) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_block",
		Uses: "flow",
	}
}

// EventHandler
type EventHandler struct {
	EventPhase   EventPhase     `if:"label=_"`
	Event        EventName      `if:"label=event"`
	Locals       *PatternLocals `if:"label=locals,optional"`
	PatternRules PatternRules   `if:"label=pattern_rules"`
}

func (*EventHandler) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_handler",
		Uses: "flow",
	}
}

// EventName requires a user-specified string.
type EventName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *EventName) String() (ret string) {
	return op.Str
}

func (*EventName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "event_name",
		Uses:        "str",
		OpenStrings: true,
	}
}

// EventPhase requires a user-specified string.
type EventPhase struct {
	Str string
}

func (op *EventPhase) String() (ret string) {
	return op.Str
}

const EventPhase_Before = "$BEFORE"
const EventPhase_While = "$WHILE"
const EventPhase_After = "$AFTER"

func (*EventPhase) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_phase",
		Uses: "str",
		Choices: []string{
			EventPhase_Before, EventPhase_While, EventPhase_After,
		},
		Strings: []string{
			"before", "while", "after",
		},
	}
}

// EventTarget swaps between various options
type EventTarget struct {
	Opt interface{}
}

func (*EventTarget) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_target",
		Uses: "swap",
	}
}

func (*EventTarget) Choices() map[string]interface{} {
	return map[string]interface{}{
		"kinds":      (*PluralKinds)(nil),
		"named_noun": (*NamedNoun)(nil),
	}
}

// ExtType swaps between various options
type ExtType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

func (*ExtType) Compose() composer.Spec {
	return composer.Spec{
		Name: "ext_type",
		Uses: "swap",
	}
}

func (*ExtType) Choices() map[string]interface{} {
	return map[string]interface{}{
		"numbers":   (*NumberList)(nil),
		"text_list": (*TextList)(nil),
		"record":    (*RecordType)(nil),
		"records":   (*RecordList)(nil),
	}
}

// GrammarDecl
type GrammarDecl struct {
	Grammar grammar.GrammarMaker `if:"label=_"`
}

func (*GrammarDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "grammar_decl",
		Uses: "flow",
	}
}

// KindOfNoun
type KindOfNoun struct {
	AreAn        AreAn         `if:"label=_"`
	Trait        []Trait       `if:"label=trait,optional"`
	Kind         SingularKind  `if:"label=kind"`
	NounRelation *NounRelation `if:"label=noun_relation,optional"`
}

func (*KindOfNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of_noun",
		Uses: "flow",
	}
}

// KindOfRelation
type KindOfRelation struct {
	Relation            value.RelationName  `if:"label=_"`
	RelationCardinality RelationCardinality `if:"label=relation_cardinality"`
}

var _ StoryStatement = (*KindOfRelation)(nil)

func (*KindOfRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of_relation",
		Uses: "flow",
	}
}

// KindsOfAspect
type KindsOfAspect struct {
	Aspect Aspect `if:"label=_"`
}

var _ StoryStatement = (*KindsOfAspect)(nil)

func (*KindsOfAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_aspect",
		Uses: "flow",
	}
}

// KindsOfKind
type KindsOfKind struct {
	PluralKinds  PluralKinds  `if:"label=_"`
	SingularKind SingularKind `if:"label=singular_kind"`
}

var _ StoryStatement = (*KindsOfKind)(nil)

func (*KindsOfKind) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_kind",
		Uses: "flow",
	}
}

// KindsOfRecord
type KindsOfRecord struct {
	RecordPlural RecordPlural `if:"label=_"`
}

var _ StoryStatement = (*KindsOfRecord)(nil)

func (*KindsOfRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_record",
		Uses: "flow",
	}
}

// KindsPossessProperties
type KindsPossessProperties struct {
	PluralKinds  PluralKinds    `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

var _ StoryStatement = (*KindsPossessProperties)(nil)

func (*KindsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_possess_properties",
		Uses: "flow",
	}
}

// Lede Describes one or more nouns.
type Lede struct {
	Nouns      []NamedNoun `if:"label=_"`
	NounPhrase NounPhrase  `if:"label=noun_phrase"`
}

func (*Lede) Compose() composer.Spec {
	return composer.Spec{
		Name: "lede",
		Uses: "flow",
	}
}

// LocalDecl
type LocalDecl struct {
	VariableDecl VariableDecl `if:"label=_"`
	Value        *LocalInit   `if:"label=value,optional"`
}

func (*LocalDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "local_decl",
		Uses: "flow",
	}
}

// LocalInit
type LocalInit struct {
	Value rt.Assignment `if:"label=_"`
}

func (*LocalInit) Compose() composer.Spec {
	return composer.Spec{
		Name: "local_init",
		Uses: "flow",
	}
}

// Make
type Make struct {
	Name      string     `if:"label=_,type=text"`
	Arguments *Arguments `if:"label=arguments,optional"`
}

var _ rt.RecordEval = (*Make)(nil)

func (*Make) Compose() composer.Spec {
	return composer.Spec{
		Name: "make",
		Uses: "flow",
	}
}

// ManyToMany
type ManyToMany struct {
	Kinds      PluralKinds `if:"label=_"`
	OtherKinds PluralKinds `if:"label=other_kinds"`
}

func (*ManyToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: "many_to_many",
		Uses: "flow",
	}
}

// ManyToOne
type ManyToOne struct {
	Kinds PluralKinds  `if:"label=_"`
	Kind  SingularKind `if:"label=kind"`
}

func (*ManyToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: "many_to_one",
		Uses: "flow",
	}
}

// NamedNoun
type NamedNoun struct {
	Determiner Determiner `if:"label=_"`
	Name       NounName   `if:"label=name"`
}

func (*NamedNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "named_noun",
		Uses: "flow",
	}
}

// NounAssignment Assign text.
type NounAssignment struct {
	Property Property    `if:"label=_"`
	Nouns    []NamedNoun `if:"label=nouns"`
	Lines    value.Lines `if:"label=lines"`
}

var _ StoryStatement = (*NounAssignment)(nil)

func (*NounAssignment) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_assignment",
		Uses: "flow",
	}
}

// NounName requires a user-specified string.
type NounName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *NounName) String() (ret string) {
	return op.Str
}

func (*NounName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "noun_name",
		Uses:        "str",
		OpenStrings: true,
	}
}

// NounPhrase swaps between various options
type NounPhrase struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

func (*NounPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_phrase",
		Uses: "swap",
	}
}

func (*NounPhrase) Choices() map[string]interface{} {
	return map[string]interface{}{
		"kind_of_noun":  (*KindOfNoun)(nil),
		"noun_traits":   (*NounTraits)(nil),
		"noun_relation": (*NounRelation)(nil),
	}
}

// NounRelation
type NounRelation struct {
	AreBeing bool               `if:"label=_,optional,type=are_being"`
	Relation value.RelationName `if:"label=relation"`
	Nouns    []NamedNoun        `if:"label=nouns"`
}

func (*NounRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_relation",
		Uses: "flow",
	}
}

// NounStatement Describes people, places, or things.
type NounStatement struct {
	Lede    Lede     `if:"label=_"`
	Tail    []Tail   `if:"label=tail,optional"`
	Summary *Summary `if:"label=summary,optional"`
}

var _ StoryStatement = (*NounStatement)(nil)

func (*NounStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_statement",
		Uses: "flow",
	}
}

// NounTraits
type NounTraits struct {
	AreBeing bool    `if:"label=_,type=are_being"`
	Trait    []Trait `if:"label=trait"`
}

func (*NounTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_traits",
		Uses: "flow",
	}
}

// NumberList requires a user-specified string.
type NumberList struct {
	Str string
}

func (op *NumberList) String() (ret string) {
	return op.Str
}

const NumberList_List = "$LIST"

func (*NumberList) Compose() composer.Spec {
	return composer.Spec{
		Name: "number_list",
		Uses: "str",
		Choices: []string{
			NumberList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

// ObjectType
type ObjectType struct {
	An   bool         `if:"label=_,type=ana"`
	Kind SingularKind `if:"label=kind"`
}

func (*ObjectType) Compose() composer.Spec {
	return composer.Spec{
		Name: "object_type",
		Uses: "flow",
	}
}

// OneToMany
type OneToMany struct {
	Kind  SingularKind `if:"label=_"`
	Kinds PluralKinds  `if:"label=kinds"`
}

func (*OneToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: "one_to_many",
		Uses: "flow",
	}
}

// OneToOne
type OneToOne struct {
	Kind      SingularKind `if:"label=_"`
	OtherKind SingularKind `if:"label=other_kind"`
}

func (*OneToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: "one_to_one",
		Uses: "flow",
	}
}

// PairedAction
type PairedAction struct {
	At    reader.Position `if:"internal"`
	Kinds PluralKinds     `if:"label=kinds"`
}

func (*PairedAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "paired_action",
		Uses: "flow",
	}
}

// Paragraph
type Paragraph struct {
	StoryStatement []StoryStatement `if:"label=_,optional"`
}

func (*Paragraph) Compose() composer.Spec {
	return composer.Spec{
		Name: "paragraph",
		Uses: "flow",
	}
}

// PatternActions Actions to take when using a pattern.
type PatternActions struct {
	Name          value.PatternName `if:"label=_"`
	PatternLocals *PatternLocals    `if:"label=pattern_locals,optional"`
	PatternReturn *PatternReturn    `if:"label=pattern_return,optional"`
	PatternRules  PatternRules      `if:"label=pattern_rules"`
}

var _ StoryStatement = (*PatternActions)(nil)

func (*PatternActions) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_actions",
		Uses: "flow",
	}
}

// PatternDecl
type PatternDecl struct {
	Type          PatternType           `if:"label=_"`
	Name          value.PatternName     `if:"label=name"`
	Optvars       *PatternVariablesTail `if:"label=optvars,optional"`
	PatternReturn *PatternReturn        `if:"label=pattern_return,optional"`
	About         *Comment              `if:"label=about,optional"`
}

var _ StoryStatement = (*PatternDecl)(nil)

func (*PatternDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_decl",
		Uses: "flow",
	}
}

// PatternFlags requires a user-specified string.
type PatternFlags struct {
	Str string
}

func (op *PatternFlags) String() (ret string) {
	return op.Str
}

const PatternFlags_Before = "$BEFORE"
const PatternFlags_After = "$AFTER"
const PatternFlags_Terminate = "$TERMINATE"

func (*PatternFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_flags",
		Uses: "str",
		Choices: []string{
			PatternFlags_Before, PatternFlags_After, PatternFlags_Terminate,
		},
		Strings: []string{
			"before", "after", "terminate",
		},
	}
}

// PatternLocals
type PatternLocals struct {
	LocalDecl []LocalDecl `if:"label=_"`
}

func (*PatternLocals) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_locals",
		Uses: "flow",
	}
}

// PatternReturn
type PatternReturn struct {
	Result VariableDecl `if:"label=_"`
}

func (*PatternReturn) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_return",
		Uses: "flow",
	}
}

// PatternRule
type PatternRule struct {
	Guard rt.BoolEval  `if:"label=_"`
	Flags PatternFlags `if:"label=flags,optional"`
	Hook  ProgramHook  `if:"label=hook"`
}

func (*PatternRule) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_rule",
		Uses: "flow",
	}
}

// PatternRules
type PatternRules struct {
	PatternRule []PatternRule `if:"label=_,optional"`
}

func (*PatternRules) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_rules",
		Uses: "flow",
	}
}

// PatternType requires a user-specified string.
type PatternType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PatternType) String() (ret string) {
	return op.Str
}

const PatternType_Patterns = "$PATTERNS"
const PatternType_Actions = "$ACTIONS"
const PatternType_Events = "$EVENTS"

func (*PatternType) Compose() composer.Spec {
	return composer.Spec{
		Name:        "pattern_type",
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			PatternType_Patterns, PatternType_Actions, PatternType_Events,
		},
		Strings: []string{
			"patterns", "actions", "events",
		},
	}
}

// PatternVariablesDecl Values provided when calling a pattern.
type PatternVariablesDecl struct {
	PatternName  value.PatternName `if:"label=_"`
	VariableDecl []VariableDecl    `if:"label=variable_decl"`
}

var _ StoryStatement = (*PatternVariablesDecl)(nil)

func (*PatternVariablesDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_variables_decl",
		Uses: "flow",
	}
}

// PatternVariablesTail Storage for values used during the execution of a pattern.
type PatternVariablesTail struct {
	VariableDecl []VariableDecl `if:"label=_"`
}

func (*PatternVariablesTail) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_variables_tail",
		Uses: "flow",
	}
}

// PluralKinds requires a user-specified string.
type PluralKinds struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PluralKinds) String() (ret string) {
	return op.Str
}

func (*PluralKinds) Compose() composer.Spec {
	return composer.Spec{
		Name:        "plural_kinds",
		Uses:        "str",
		OpenStrings: true,
	}
}

// PrimitiveType requires a user-specified string.
type PrimitiveType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PrimitiveType) String() (ret string) {
	return op.Str
}

const PrimitiveType_Number = "$NUMBER"
const PrimitiveType_Text = "$TEXT"
const PrimitiveType_Bool = "$BOOL"

func (*PrimitiveType) Compose() composer.Spec {
	return composer.Spec{
		Name: "primitive_type",
		Uses: "str",
		Choices: []string{
			PrimitiveType_Number, PrimitiveType_Text, PrimitiveType_Bool,
		},
		Strings: []string{
			"number", "text", "bool",
		},
	}
}

// PrimitiveValue swaps between various options
type PrimitiveValue struct {
	Opt interface{}
}

func (*PrimitiveValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "primitive_value",
		Uses: "swap",
	}
}

func (*PrimitiveValue) Choices() map[string]interface{} {
	return map[string]interface{}{
		"boxed_text":   (*BoxedText)(nil),
		"boxed_number": (*BoxedNumber)(nil),
	}
}

// ProgramHook swaps between various options
type ProgramHook struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

func (*ProgramHook) Compose() composer.Spec {
	return composer.Spec{
		Name: "program_hook",
		Uses: "swap",
	}
}

func (*ProgramHook) Choices() map[string]interface{} {
	return map[string]interface{}{
		"activity": (*core.Activity)(nil),
	}
}

// Pronoun requires a user-specified string.
type Pronoun struct {
	Str string
}

func (op *Pronoun) String() (ret string) {
	return op.Str
}

const Pronoun_It = "$IT"
const Pronoun_They = "$THEY"

func (*Pronoun) Compose() composer.Spec {
	return composer.Spec{
		Name:        "pronoun",
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			Pronoun_It, Pronoun_They,
		},
		Strings: []string{
			"it", "they",
		},
	}
}

// Property requires a user-specified string.
type Property struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Property) String() (ret string) {
	return op.Str
}

func (*Property) Compose() composer.Spec {
	return composer.Spec{
		Name:        "property",
		Uses:        "str",
		OpenStrings: true,
	}
}

// PropertyAspect requires a user-specified string.
type PropertyAspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PropertyAspect) String() (ret string) {
	return op.Str
}

const PropertyAspect_Aspect = "$ASPECT"

func (*PropertyAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_aspect",
		Uses: "str",
		Choices: []string{
			PropertyAspect_Aspect,
		},
		Strings: []string{
			"aspect",
		},
	}
}

// PropertyDecl
type PropertyDecl struct {
	An           Determiner   `if:"label=_"`
	Property     Property     `if:"label=property"`
	PropertyType PropertyType `if:"label=property_type"`
	Comment      value.Lines  `if:"label=comment,optional"`
}

func (*PropertyDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_decl",
		Uses: "flow",
	}
}

// PropertyType swaps between various options
type PropertyType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

func (*PropertyType) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_type",
		Uses: "swap",
	}
}

func (*PropertyType) Choices() map[string]interface{} {
	return map[string]interface{}{
		"property_aspect": (*PropertyAspect)(nil),
		"primitive":       (*PrimitiveType)(nil),
		"ext":             (*ExtType)(nil),
	}
}

// RecordList
type RecordList struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordList) Compose() composer.Spec {
	return composer.Spec{
		Name: "record_list",
		Uses: "flow",
	}
}

// RecordPlural requires a user-specified string.
type RecordPlural struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordPlural) String() (ret string) {
	return op.Str
}

func (*RecordPlural) Compose() composer.Spec {
	return composer.Spec{
		Name:        "record_plural",
		Uses:        "str",
		OpenStrings: true,
	}
}

// RecordSingular requires a user-specified string.
type RecordSingular struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordSingular) String() (ret string) {
	return op.Str
}

func (*RecordSingular) Compose() composer.Spec {
	return composer.Spec{
		Name:        "record_singular",
		Uses:        "str",
		OpenStrings: true,
	}
}

// RecordType
type RecordType struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordType) Compose() composer.Spec {
	return composer.Spec{
		Name: "record_type",
		Uses: "flow",
	}
}

// RecordsPossessProperties
type RecordsPossessProperties struct {
	RecordPlural RecordPlural   `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

var _ StoryStatement = (*RecordsPossessProperties)(nil)

func (*RecordsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: "records_possess_properties",
		Uses: "flow",
	}
}

// RelationCardinality swaps between various options
type RelationCardinality struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

func (*RelationCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: "relation_cardinality",
		Uses: "swap",
	}
}

func (*RelationCardinality) Choices() map[string]interface{} {
	return map[string]interface{}{
		"one_to_one":   (*OneToOne)(nil),
		"one_to_many":  (*OneToMany)(nil),
		"many_to_one":  (*ManyToOne)(nil),
		"many_to_many": (*ManyToMany)(nil),
	}
}

// RelativeToNoun
type RelativeToNoun struct {
	Relation value.RelationName `if:"label=_"`
	Nouns    []NamedNoun        `if:"label=nouns"`
	AreBeing bool               `if:"label=are_being,type=are_being"`
	Nouns1   []NamedNoun        `if:"label=nouns1"`
}

var _ StoryStatement = (*RelativeToNoun)(nil)

func (*RelativeToNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "relative_to_noun",
		Uses: "flow",
	}
}

// RenderTemplate Parse text using iffy templates.
type RenderTemplate struct {
	Template value.Lines `if:"label=_"`
}

var _ rt.TextEval = (*RenderTemplate)(nil)

func (*RenderTemplate) Compose() composer.Spec {
	return composer.Spec{
		Name: "render_template",
		Uses: "flow",
	}
}

// Send
type Send struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=path"`
	Arguments *Arguments      `if:"label=arguments,optional"`
}

var _ rt.Execute = (*Send)(nil)
var _ rt.BoolEval = (*Send)(nil)

func (*Send) Compose() composer.Spec {
	return composer.Spec{
		Name: "send",
		Uses: "flow",
	}
}

// ShuffleText
type ShuffleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

var _ rt.TextEval = (*ShuffleText)(nil)

func (*ShuffleText) Compose() composer.Spec {
	return composer.Spec{
		Name: "shuffle_text",
		Uses: "flow",
	}
}

// SingularKind requires a user-specified string.
type SingularKind struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *SingularKind) String() (ret string) {
	return op.Str
}

func (*SingularKind) Compose() composer.Spec {
	return composer.Spec{
		Name:        "singular_kind",
		Uses:        "str",
		OpenStrings: true,
	}
}

// StoppingText
type StoppingText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

var _ rt.TextEval = (*StoppingText)(nil)

func (*StoppingText) Compose() composer.Spec {
	return composer.Spec{
		Name: "stopping_text",
		Uses: "flow",
	}
}

// Story
type Story struct {
	Paragraph []Paragraph `if:"label=_,optional"`
}

func (*Story) Compose() composer.Spec {
	return composer.Spec{
		Name: "story",
		Uses: "flow",
	}
}

// Summary
type Summary struct {
	At    reader.Position `if:"internal"`
	Lines value.Lines     `if:"label=lines"`
}

func (*Summary) Compose() composer.Spec {
	return composer.Spec{
		Name: "summary",
		Uses: "flow",
	}
}

// Tail Adds details about the preceding noun or nouns.
type Tail struct {
	Pronoun    Pronoun    `if:"label=_"`
	NounPhrase NounPhrase `if:"label=noun_phrase"`
}

func (*Tail) Compose() composer.Spec {
	return composer.Spec{
		Name: "tail",
		Uses: "flow",
	}
}

// TestName requires a user-specified string.
type TestName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *TestName) String() (ret string) {
	return op.Str
}

const TestName_CurrentTest = "$CURRENT_TEST"

func (*TestName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "test_name",
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			TestName_CurrentTest,
		},
		Strings: []string{
			"current_test",
		},
	}
}

// TestOutput Expect that a test uses &#x27;Say&#x27; to print some specific text.
type TestOutput struct {
	Lines value.Lines `if:"label=_"`
}

var _ Testing = (*TestOutput)(nil)

func (*TestOutput) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_output",
		Uses: "flow",
	}
}

// TestRule
type TestRule struct {
	TestName TestName    `if:"label=_"`
	Hook     ProgramHook `if:"label=hook"`
}

var _ StoryStatement = (*TestRule)(nil)

func (*TestRule) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_rule",
		Uses: "flow",
	}
}

// TestScene
type TestScene struct {
	TestName TestName `if:"label=_"`
	Story    Story    `if:"label=story"`
}

var _ StoryStatement = (*TestScene)(nil)

func (*TestScene) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_scene",
		Uses: "flow",
	}
}

// TestStatement
type TestStatement struct {
	At       reader.Position `if:"internal"`
	TestName TestName        `if:"label=test_name"`
	Test     Testing         `if:"label=test"`
}

var _ StoryStatement = (*TestStatement)(nil)

func (*TestStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_statement",
		Uses: "flow",
	}
}

// TextList requires a user-specified string.
type TextList struct {
	Str string
}

func (op *TextList) String() (ret string) {
	return op.Str
}

const TextList_List = "$LIST"

func (*TextList) Compose() composer.Spec {
	return composer.Spec{
		Name: "text_list",
		Uses: "str",
		Choices: []string{
			TextList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

// Trait requires a user-specified string.
type Trait struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Trait) String() (ret string) {
	return op.Str
}

func (*Trait) Compose() composer.Spec {
	return composer.Spec{
		Name:        "trait",
		Uses:        "str",
		OpenStrings: true,
	}
}

// TraitPhrase
type TraitPhrase struct {
	AreEither bool    `if:"label=_,type=are_either"`
	Trait     []Trait `if:"label=trait"`
}

func (*TraitPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: "trait_phrase",
		Uses: "flow",
	}
}

// VariableDecl
type VariableDecl struct {
	An      Determiner         `if:"label=_"`
	Name    value.VariableName `if:"label=name"`
	Type    VariableType       `if:"label=type"`
	Comment value.Lines        `if:"label=comment,optional"`
}

func (*VariableDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "variable_decl",
		Uses: "flow",
	}
}

// VariableType swaps between various options
type VariableType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

func (*VariableType) Compose() composer.Spec {
	return composer.Spec{
		Name: "variable_type",
		Uses: "swap",
	}
}

func (*VariableType) Choices() map[string]interface{} {
	return map[string]interface{}{
		"primitive": (*PrimitiveType)(nil),
		"object":    (*ObjectType)(nil),
		"ext":       (*ExtType)(nil),
	}
}

var Slots = []interface{}{
	(*StoryStatement)(nil),
	(*Testing)(nil),
}
var Slats = []composer.Composer{
	(*AbstractAction)(nil),
	(*ActionContext)(nil),
	(*ActionDecl)(nil),
	(*ActionName)(nil),
	(*ActionParams)(nil),
	(*Ana)(nil),
	(*AreAn)(nil),
	(*AreBeing)(nil),
	(*AreEither)(nil),
	(*Argument)(nil),
	(*Arguments)(nil),
	(*Aspect)(nil),
	(*AspectTraits)(nil),
	(*BoxedNumber)(nil),
	(*BoxedText)(nil),
	(*Certainties)(nil),
	(*Certainty)(nil),
	(*Comment)(nil),
	(*CommonAction)(nil),
	(*CountOf)(nil),
	(*CycleText)(nil),
	(*Determine)(nil),
	(*Determiner)(nil),
	(*EventBlock)(nil),
	(*EventHandler)(nil),
	(*EventName)(nil),
	(*EventPhase)(nil),
	(*EventTarget)(nil),
	(*ExtType)(nil),
	(*GrammarDecl)(nil),
	(*KindOfNoun)(nil),
	(*KindOfRelation)(nil),
	(*KindsOfAspect)(nil),
	(*KindsOfKind)(nil),
	(*KindsOfRecord)(nil),
	(*KindsPossessProperties)(nil),
	(*Lede)(nil),
	(*LocalDecl)(nil),
	(*LocalInit)(nil),
	(*Make)(nil),
	(*ManyToMany)(nil),
	(*ManyToOne)(nil),
	(*NamedNoun)(nil),
	(*NounAssignment)(nil),
	(*NounName)(nil),
	(*NounPhrase)(nil),
	(*NounRelation)(nil),
	(*NounStatement)(nil),
	(*NounTraits)(nil),
	(*NumberList)(nil),
	(*ObjectType)(nil),
	(*OneToMany)(nil),
	(*OneToOne)(nil),
	(*PairedAction)(nil),
	(*Paragraph)(nil),
	(*PatternActions)(nil),
	(*PatternDecl)(nil),
	(*PatternFlags)(nil),
	(*PatternLocals)(nil),
	(*PatternReturn)(nil),
	(*PatternRule)(nil),
	(*PatternRules)(nil),
	(*PatternType)(nil),
	(*PatternVariablesDecl)(nil),
	(*PatternVariablesTail)(nil),
	(*PluralKinds)(nil),
	(*PrimitiveType)(nil),
	(*PrimitiveValue)(nil),
	(*ProgramHook)(nil),
	(*Pronoun)(nil),
	(*Property)(nil),
	(*PropertyAspect)(nil),
	(*PropertyDecl)(nil),
	(*PropertyType)(nil),
	(*RecordList)(nil),
	(*RecordPlural)(nil),
	(*RecordSingular)(nil),
	(*RecordType)(nil),
	(*RecordsPossessProperties)(nil),
	(*RelationCardinality)(nil),
	(*RelativeToNoun)(nil),
	(*RenderTemplate)(nil),
	(*Send)(nil),
	(*ShuffleText)(nil),
	(*SingularKind)(nil),
	(*StoppingText)(nil),
	(*Story)(nil),
	(*Summary)(nil),
	(*Tail)(nil),
	(*TestName)(nil),
	(*TestOutput)(nil),
	(*TestRule)(nil),
	(*TestScene)(nil),
	(*TestStatement)(nil),
	(*TextList)(nil),
	(*Trait)(nil),
	(*TraitPhrase)(nil),
	(*VariableDecl)(nil),
	(*VariableType)(nil),
}
