// Code generated by "makeops"; edit at your own risk.
package story

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/grammar"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsonexp"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// AbstractAction requires a user-specified string.
type AbstractAction struct {
	Str string
}

func (op *AbstractAction) String() (ret string) {
	return op.Str
}

func (*AbstractAction) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AbstractAction,
		Uses: "str",
		Choices: []string{
			AbstractAction_Nothing,
		},
		Strings: []string{
			"nothing",
		},
	}
}

var Type_AbstractAction = "abstract_action"

func (op *AbstractAction) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_AbstractAction,
		Value: op.Str,
	})
}

func (op *AbstractAction) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const AbstractAction_Nothing = "$NOTHING"

// ActionContext
type ActionContext struct {
	At   reader.Position `if:"internal"`
	Kind SingularKind    `if:"label=kind"`
}

func (*ActionContext) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ActionContext,
		Uses: "flow",
	}
}

var Type_ActionContext = "action_context"

func (op *ActionContext) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_ActionContext,
			Value: map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *ActionContext) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

// ActionDecl
type ActionDecl struct {
	At           reader.Position `if:"internal"`
	Event        EventName       `if:"label=event"`
	Action       ActionName      `if:"label=action"`
	ActionParams ActionParams    `if:"label=action_params"`
}

func (*ActionDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ActionDecl,
		Uses: "flow",
	}
}

var Type_ActionDecl = "action_decl"

func (op *ActionDecl) MarshalJSON() (ret []byte, err error) {
	if jsonEvent, e := op.MarshalJSONEvent(); e != nil {
		err = e
	} else if jsonAction, e := op.MarshalJSONAction(); e != nil {
		err = e
	} else if jsonActionParams, e := op.MarshalJSONActionParams(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_ActionDecl,
			Value: map[string]json.RawMessage{
				"$EVENT":         jsonEvent,
				"$ACTION":        jsonAction,
				"$ACTION_PARAMS": jsonActionParams,
			},
		})
	}
	return
}

func (op *ActionDecl) MarshalJSONEvent() (ret []byte, err error) {
	ret, err = op.Event.MarshalJSON()
	return
}

func (op *ActionDecl) MarshalJSONAction() (ret []byte, err error) {
	ret, err = op.Action.MarshalJSON()
	return
}

func (op *ActionDecl) MarshalJSONActionParams() (ret []byte, err error) {
	ret, err = op.ActionParams.MarshalJSON()
	return
}

// ActionName requires a user-specified string.
type ActionName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *ActionName) String() (ret string) {
	return op.Str
}

func (*ActionName) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_ActionName,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_ActionName = "action_name"

func (op *ActionName) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_ActionName,
		Value: op.Str,
	})
}

func (op *ActionName) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// ActionParams swaps between various options
type ActionParams struct {
	Opt interface{}
}

const ActionParams_Common = "$COMMON"
const ActionParams_Dual = "$DUAL"
const ActionParams_None = "$NONE"

func (*ActionParams) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ActionParams,
		Uses: "swap",
		Choices: []string{
			ActionParams_Common, ActionParams_Dual, ActionParams_None,
		},
		Swaps: []interface{}{
			(*CommonAction)(nil),
			(*PairedAction)(nil),
			(*AbstractAction)(nil),
		},
	}
}

var Type_ActionParams = "action_params"

func (op *ActionParams) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "action_params",
			"value": val,
		})
	}
	return
}

func (op *ActionParams) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *ActionParams) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *CommonAction:
		ret, okay = ActionParams_Common, true
	case *PairedAction:
		ret, okay = ActionParams_Dual, true
	case *AbstractAction:
		ret, okay = ActionParams_None, true
	}
	return
}

// Ana requires a user-specified string.
type Ana struct {
	Str string
}

func (op *Ana) String() (ret string) {
	return op.Str
}

func (*Ana) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Ana,
		Uses: "str",
		Choices: []string{
			Ana_A, Ana_An,
		},
		Strings: []string{
			"a", "an",
		},
	}
}

var Type_Ana = "ana"

func (op *Ana) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_Ana,
		Value: op.Str,
	})
}

func (op *Ana) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const Ana_A = "$A"
const Ana_An = "$AN"

// AreAn requires a user-specified string.
type AreAn struct {
	Str string
}

func (op *AreAn) String() (ret string) {
	return op.Str
}

func (*AreAn) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AreAn,
		Uses: "str",
		Choices: []string{
			AreAn_Are, AreAn_Area, AreAn_Arean, AreAn_Is, AreAn_Isa, AreAn_Isan,
		},
		Strings: []string{
			"are", "area", "arean", "is", "isa", "isan",
		},
	}
}

var Type_AreAn = "are_an"

func (op *AreAn) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_AreAn,
		Value: op.Str,
	})
}

func (op *AreAn) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const AreAn_Are = "$ARE"
const AreAn_Area = "$AREA"
const AreAn_Arean = "$AREAN"
const AreAn_Is = "$IS"
const AreAn_Isa = "$ISA"
const AreAn_Isan = "$ISAN"

// AreBeing requires a user-specified string.
type AreBeing struct {
	Str string
}

func (op *AreBeing) String() (ret string) {
	return op.Str
}

func (*AreBeing) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AreBeing,
		Uses: "str",
		Choices: []string{
			AreBeing_Are, AreBeing_Is,
		},
		Strings: []string{
			"are", "is",
		},
	}
}

var Type_AreBeing = "are_being"

func (op *AreBeing) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_AreBeing,
		Value: op.Str,
	})
}

func (op *AreBeing) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const AreBeing_Are = "$ARE"
const AreBeing_Is = "$IS"

// AreEither requires a user-specified string.
type AreEither struct {
	Str string
}

func (op *AreEither) String() (ret string) {
	return op.Str
}

func (*AreEither) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AreEither,
		Uses: "str",
		Choices: []string{
			AreEither_Canbe, AreEither_Either,
		},
		Strings: []string{
			"canbe", "either",
		},
	}
}

var Type_AreEither = "are_either"

func (op *AreEither) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_AreEither,
		Value: op.Str,
	})
}

func (op *AreEither) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const AreEither_Canbe = "$CANBE"
const AreEither_Either = "$EITHER"

// Argument
type Argument struct {
	At   reader.Position `if:"internal"`
	Name string          `if:"label=_,type=text"`
	From rt.Assignment   `if:"label=from"`
}

func (*Argument) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Argument,
		Uses: "flow",
		Lede: "arg",
	}
}

var Type_Argument = "argument"

func (op *Argument) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_Argument,
			Value: map[string]json.RawMessage{
				"$NAME": jsonName,
				"$FROM": jsonFrom,
			},
		})
	}
	return
}

func (op *Argument) MarshalJSONName() (ret []byte, err error) {
	// type override
	m := value.Text{op.Name}
	ret, err = m.MarshalJSON()
	return
}

func (op *Argument) MarshalJSONFrom() (ret []byte, err error) {
	if v, e := op.From.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

// Arguments
type Arguments struct {
	At   reader.Position `if:"internal"`
	Args []Argument      `if:"label=_"`
}

func (*Arguments) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Arguments,
		Uses: "flow",
		Lede: "args",
	}
}

var Type_Arguments = "arguments"

func (op *Arguments) MarshalJSON() (ret []byte, err error) {
	if jsonArgs, e := op.MarshalJSONArgs(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_Arguments,
			Value: map[string]json.RawMessage{
				"$ARGS": jsonArgs,
			},
		})
	}
	return
}

func (op *Arguments) MarshalJSONArgs() (ret []byte, err error) {
	ret, err = json.Marshal(op.Args)
	return
}

// Aspect requires a user-specified string.
type Aspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Aspect) String() (ret string) {
	return op.Str
}

func (*Aspect) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Aspect,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_Aspect = "aspect"

func (op *Aspect) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_Aspect,
		Value: op.Str,
	})
}

func (op *Aspect) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// AspectTraits
type AspectTraits struct {
	Aspect      Aspect      `if:"label=_"`
	TraitPhrase TraitPhrase `if:"label=trait_phrase"`
}

func (*AspectTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_AspectTraits,
		Uses: "flow",
	}
}

var Type_AspectTraits = "aspect_traits"

func (op *AspectTraits) MarshalJSON() (ret []byte, err error) {
	if jsonAspect, e := op.MarshalJSONAspect(); e != nil {
		err = e
	} else if jsonTraitPhrase, e := op.MarshalJSONTraitPhrase(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_AspectTraits,
			Value: map[string]json.RawMessage{
				"$ASPECT":       jsonAspect,
				"$TRAIT_PHRASE": jsonTraitPhrase,
			},
		})
	}
	return
}

func (op *AspectTraits) MarshalJSONAspect() (ret []byte, err error) {
	ret, err = op.Aspect.MarshalJSON()
	return
}

func (op *AspectTraits) MarshalJSONTraitPhrase() (ret []byte, err error) {
	ret, err = op.TraitPhrase.MarshalJSON()
	return
}

// BoxedNumber
type BoxedNumber struct {
	Number float64 `if:"label=_,type=number"`
}

func (*BoxedNumber) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BoxedNumber,
		Uses: "flow",
	}
}

var Type_BoxedNumber = "boxed_number"

func (op *BoxedNumber) MarshalJSON() (ret []byte, err error) {
	if jsonNumber, e := op.MarshalJSONNumber(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_BoxedNumber,
			Value: map[string]json.RawMessage{
				"$NUMBER": jsonNumber,
			},
		})
	}
	return
}

func (op *BoxedNumber) MarshalJSONNumber() (ret []byte, err error) {
	// type override
	m := value.Number{op.Number}
	ret, err = m.MarshalJSON()
	return
}

// BoxedText
type BoxedText struct {
	Text string `if:"label=_,type=text"`
}

func (*BoxedText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_BoxedText,
		Uses: "flow",
	}
}

var Type_BoxedText = "boxed_text"

func (op *BoxedText) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_BoxedText,
			Value: map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *BoxedText) MarshalJSONText() (ret []byte, err error) {
	// type override
	m := value.Text{op.Text}
	ret, err = m.MarshalJSON()
	return
}

// Certainties
type Certainties struct {
	PluralKinds PluralKinds `if:"label=_"`
	AreBeing    bool        `if:"label=are_being,type=are_being"`
	Certainty   Certainty   `if:"label=certainty"`
	Trait       Trait       `if:"label=trait"`
}

func (*Certainties) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Certainties,
		Uses: "flow",
	}
}

var Type_Certainties = "certainties"

func (op *Certainties) MarshalJSON() (ret []byte, err error) {
	if jsonPluralKinds, e := op.MarshalJSONPluralKinds(); e != nil {
		err = e
	} else if jsonAreBeing, e := op.MarshalJSONAreBeing(); e != nil {
		err = e
	} else if jsonCertainty, e := op.MarshalJSONCertainty(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Certainties,
			Value: map[string]json.RawMessage{
				"$PLURAL_KINDS": jsonPluralKinds,
				"$ARE_BEING":    jsonAreBeing,
				"$CERTAINTY":    jsonCertainty,
				"$TRAIT":        jsonTrait,
			},
		})
	}
	return
}

func (op *Certainties) MarshalJSONPluralKinds() (ret []byte, err error) {
	ret, err = op.PluralKinds.MarshalJSON()
	return
}

func (op *Certainties) MarshalJSONAreBeing() (ret []byte, err error) {
	// bool override
	var str string
	if op.AreBeing {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	ret, err = m.MarshalJSON()
	return
}

func (op *Certainties) MarshalJSONCertainty() (ret []byte, err error) {
	ret, err = op.Certainty.MarshalJSON()
	return
}

func (op *Certainties) MarshalJSONTrait() (ret []byte, err error) {
	ret, err = op.Trait.MarshalJSON()
	return
}

// Certainty requires a user-specified string.
type Certainty struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Certainty) String() (ret string) {
	return op.Str
}

func (*Certainty) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Certainty,
		Uses: "str",
		Choices: []string{
			Certainty_Usually, Certainty_Always, Certainty_Seldom, Certainty_Never,
		},
		Strings: []string{
			"usually", "always", "seldom", "never",
		},
	}
}

var Type_Certainty = "certainty"

func (op *Certainty) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_Certainty,
		Value: op.Str,
	})
}

func (op *Certainty) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

const Certainty_Usually = "$USUALLY"
const Certainty_Always = "$ALWAYS"
const Certainty_Seldom = "$SELDOM"
const Certainty_Never = "$NEVER"

// Comment Information about the story for you and other authors.
type Comment struct {
	Lines value.Lines `if:"label=_"`
}

func (*Comment) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Comment,
		Uses: "flow",
	}
}

var Type_Comment = "comment"

func (op *Comment) MarshalJSON() (ret []byte, err error) {
	if jsonLines, e := op.MarshalJSONLines(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Comment,
			Value: map[string]json.RawMessage{
				"$LINES": jsonLines,
			},
		})
	}
	return
}

func (op *Comment) MarshalJSONLines() (ret []byte, err error) {
	ret, err = op.Lines.MarshalJSON()
	return
}

// CommonAction
type CommonAction struct {
	At            reader.Position `if:"internal"`
	Kind          SingularKind    `if:"label=kind"`
	ActionContext *ActionContext  `if:"label=action_context,optional"`
}

func (*CommonAction) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CommonAction,
		Uses: "flow",
	}
}

var Type_CommonAction = "common_action"

func (op *CommonAction) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonActionContext, e := op.MarshalJSONActionContext(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_CommonAction,
			Value: map[string]json.RawMessage{
				"$KIND":           jsonKind,
				"$ACTION_CONTEXT": jsonActionContext,
			},
		})
	}
	return
}

func (op *CommonAction) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

func (op *CommonAction) MarshalJSONActionContext() (ret []byte, err error) {
	ret, err = op.ActionContext.MarshalJSON()
	return
}

// CountOf A guard which returns true based on a counter.
type CountOf struct {
	At      reader.Position `if:"internal"`
	Trigger core.Trigger    `if:"label=trigger"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CountOf) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CountOf,
		Uses: "flow",
	}
}

var Type_CountOf = "count_of"

func (op *CountOf) MarshalJSON() (ret []byte, err error) {
	if jsonTrigger, e := op.MarshalJSONTrigger(); e != nil {
		err = e
	} else if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_CountOf,
			Value: map[string]json.RawMessage{
				"$TRIGGER": jsonTrigger,
				"$NUM":     jsonNum,
			},
		})
	}
	return
}

func (op *CountOf) MarshalJSONTrigger() (ret []byte, err error) {
	if v, e := op.Trigger.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  core.Type_Trigger,
			Value: v,
		})
	}
	return
}

func (op *CountOf) MarshalJSONNum() (ret []byte, err error) {
	if v, e := op.Num.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_NumberEval,
			Value: v,
		})
	}
	return
}

// CycleText
type CycleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*CycleText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_CycleText,
		Uses: "flow",
	}
}

var Type_CycleText = "cycle_text"

func (op *CycleText) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_CycleText,
			Value: map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *CycleText) MarshalJSONParts() (ret []byte, err error) {
	ret, err = json.Marshal(op.Parts)
	return
}

// Determine
type Determine struct {
	Name      value.PatternName `if:"label=_"`
	Arguments *Arguments        `if:"label=arguments,optional"`
}

func (*Determine) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Determine,
		Uses: "flow",
	}
}

var Type_Determine = "determine"

func (op *Determine) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Determine,
			Value: map[string]json.RawMessage{
				"$NAME":      jsonName,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *Determine) MarshalJSONName() (ret []byte, err error) {
	ret, err = op.Name.MarshalJSON()
	return
}

func (op *Determine) MarshalJSONArguments() (ret []byte, err error) {
	ret, err = op.Arguments.MarshalJSON()
	return
}

// Determiner requires a user-specified string.
type Determiner struct {
	Str string
}

func (op *Determiner) String() (ret string) {
	return op.Str
}

func (*Determiner) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Determiner,
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			Determiner_A, Determiner_An, Determiner_The, Determiner_Our,
		},
		Strings: []string{
			"a", "an", "the", "our",
		},
	}
}

var Type_Determiner = "determiner"

func (op *Determiner) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_Determiner,
		Value: op.Str,
	})
}

func (op *Determiner) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const Determiner_A = "$A"
const Determiner_An = "$AN"
const Determiner_The = "$THE"
const Determiner_Our = "$OUR"

// EventBlock Listeners let objects in the game world react to changes before, during, or after they happen.
type EventBlock struct {
	At       reader.Position `if:"internal"`
	Target   EventTarget     `if:"label=target"`
	Handlers []EventHandler  `if:"label=handlers"`
}

func (*EventBlock) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EventBlock,
		Uses: "flow",
	}
}

var Type_EventBlock = "event_block"

func (op *EventBlock) MarshalJSON() (ret []byte, err error) {
	if jsonTarget, e := op.MarshalJSONTarget(); e != nil {
		err = e
	} else if jsonHandlers, e := op.MarshalJSONHandlers(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_EventBlock,
			Value: map[string]json.RawMessage{
				"$TARGET":   jsonTarget,
				"$HANDLERS": jsonHandlers,
			},
		})
	}
	return
}

func (op *EventBlock) MarshalJSONTarget() (ret []byte, err error) {
	ret, err = op.Target.MarshalJSON()
	return
}

func (op *EventBlock) MarshalJSONHandlers() (ret []byte, err error) {
	ret, err = json.Marshal(op.Handlers)
	return
}

// EventHandler
type EventHandler struct {
	EventPhase   EventPhase     `if:"label=_"`
	Event        EventName      `if:"label=event"`
	Locals       *PatternLocals `if:"label=locals,optional"`
	PatternRules PatternRules   `if:"label=pattern_rules"`
}

func (*EventHandler) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EventHandler,
		Uses: "flow",
	}
}

var Type_EventHandler = "event_handler"

func (op *EventHandler) MarshalJSON() (ret []byte, err error) {
	if jsonEventPhase, e := op.MarshalJSONEventPhase(); e != nil {
		err = e
	} else if jsonEvent, e := op.MarshalJSONEvent(); e != nil {
		err = e
	} else if jsonLocals, e := op.MarshalJSONLocals(); e != nil {
		err = e
	} else if jsonPatternRules, e := op.MarshalJSONPatternRules(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_EventHandler,
			Value: map[string]json.RawMessage{
				"$EVENT_PHASE":   jsonEventPhase,
				"$EVENT":         jsonEvent,
				"$LOCALS":        jsonLocals,
				"$PATTERN_RULES": jsonPatternRules,
			},
		})
	}
	return
}

func (op *EventHandler) MarshalJSONEventPhase() (ret []byte, err error) {
	ret, err = op.EventPhase.MarshalJSON()
	return
}

func (op *EventHandler) MarshalJSONEvent() (ret []byte, err error) {
	ret, err = op.Event.MarshalJSON()
	return
}

func (op *EventHandler) MarshalJSONLocals() (ret []byte, err error) {
	ret, err = op.Locals.MarshalJSON()
	return
}

func (op *EventHandler) MarshalJSONPatternRules() (ret []byte, err error) {
	ret, err = op.PatternRules.MarshalJSON()
	return
}

// EventName requires a user-specified string.
type EventName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *EventName) String() (ret string) {
	return op.Str
}

func (*EventName) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_EventName,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_EventName = "event_name"

func (op *EventName) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_EventName,
		Value: op.Str,
	})
}

func (op *EventName) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// EventPhase requires a user-specified string.
type EventPhase struct {
	Str string
}

func (op *EventPhase) String() (ret string) {
	return op.Str
}

func (*EventPhase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EventPhase,
		Uses: "str",
		Choices: []string{
			EventPhase_Before, EventPhase_While, EventPhase_After,
		},
		Strings: []string{
			"before", "while", "after",
		},
	}
}

var Type_EventPhase = "event_phase"

func (op *EventPhase) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_EventPhase,
		Value: op.Str,
	})
}

func (op *EventPhase) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const EventPhase_Before = "$BEFORE"
const EventPhase_While = "$WHILE"
const EventPhase_After = "$AFTER"

// EventTarget swaps between various options
type EventTarget struct {
	Opt interface{}
}

const EventTarget_Kinds = "$KINDS"
const EventTarget_NamedNoun = "$NAMED_NOUN"

func (*EventTarget) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_EventTarget,
		Uses: "swap",
		Choices: []string{
			EventTarget_Kinds, EventTarget_NamedNoun,
		},
		Swaps: []interface{}{
			(*PluralKinds)(nil),
			(*NamedNoun)(nil),
		},
	}
}

var Type_EventTarget = "event_target"

func (op *EventTarget) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "event_target",
			"value": val,
		})
	}
	return
}

func (op *EventTarget) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *EventTarget) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PluralKinds:
		ret, okay = EventTarget_Kinds, true
	case *NamedNoun:
		ret, okay = EventTarget_NamedNoun, true
	}
	return
}

// ExtType swaps between various options
type ExtType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ExtType_Numbers = "$NUMBERS"
const ExtType_TextList = "$TEXT_LIST"
const ExtType_Record = "$RECORD"
const ExtType_Records = "$RECORDS"

func (*ExtType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ExtType,
		Uses: "swap",
		Choices: []string{
			ExtType_Numbers, ExtType_TextList, ExtType_Record, ExtType_Records,
		},
		Swaps: []interface{}{
			(*NumberList)(nil),
			(*TextList)(nil),
			(*RecordType)(nil),
			(*RecordList)(nil),
		},
	}
}

var Type_ExtType = "ext_type"

func (op *ExtType) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "ext_type",
			"value": val,
		})
	}
	return
}

func (op *ExtType) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *ExtType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *NumberList:
		ret, okay = ExtType_Numbers, true
	case *TextList:
		ret, okay = ExtType_TextList, true
	case *RecordType:
		ret, okay = ExtType_Record, true
	case *RecordList:
		ret, okay = ExtType_Records, true
	}
	return
}

// GrammarDecl
type GrammarDecl struct {
	Grammar grammar.GrammarMaker `if:"label=_"`
}

func (*GrammarDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_GrammarDecl,
		Uses: "flow",
	}
}

var Type_GrammarDecl = "grammar_decl"

func (op *GrammarDecl) MarshalJSON() (ret []byte, err error) {
	if jsonGrammar, e := op.MarshalJSONGrammar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_GrammarDecl,
			Value: map[string]json.RawMessage{
				"$GRAMMAR": jsonGrammar,
			},
		})
	}
	return
}

func (op *GrammarDecl) MarshalJSONGrammar() (ret []byte, err error) {
	if v, e := op.Grammar.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  grammar.Type_GrammarMaker,
			Value: v,
		})
	}
	return
}

// KindOfNoun
type KindOfNoun struct {
	AreAn        AreAn         `if:"label=_"`
	Trait        []Trait       `if:"label=trait,optional"`
	Kind         SingularKind  `if:"label=kind"`
	NounRelation *NounRelation `if:"label=noun_relation,optional"`
}

func (*KindOfNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindOfNoun,
		Uses: "flow",
	}
}

var Type_KindOfNoun = "kind_of_noun"

func (op *KindOfNoun) MarshalJSON() (ret []byte, err error) {
	if jsonAreAn, e := op.MarshalJSONAreAn(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonNounRelation, e := op.MarshalJSONNounRelation(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_KindOfNoun,
			Value: map[string]json.RawMessage{
				"$ARE_AN":        jsonAreAn,
				"$TRAIT":         jsonTrait,
				"$KIND":          jsonKind,
				"$NOUN_RELATION": jsonNounRelation,
			},
		})
	}
	return
}

func (op *KindOfNoun) MarshalJSONAreAn() (ret []byte, err error) {
	ret, err = op.AreAn.MarshalJSON()
	return
}

func (op *KindOfNoun) MarshalJSONTrait() (ret []byte, err error) {
	ret, err = json.Marshal(op.Trait)
	return
}

func (op *KindOfNoun) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

func (op *KindOfNoun) MarshalJSONNounRelation() (ret []byte, err error) {
	ret, err = op.NounRelation.MarshalJSON()
	return
}

// KindOfRelation
type KindOfRelation struct {
	Relation            value.RelationName  `if:"label=_"`
	RelationCardinality RelationCardinality `if:"label=relation_cardinality"`
}

func (*KindOfRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindOfRelation,
		Uses: "flow",
	}
}

var Type_KindOfRelation = "kind_of_relation"

func (op *KindOfRelation) MarshalJSON() (ret []byte, err error) {
	if jsonRelation, e := op.MarshalJSONRelation(); e != nil {
		err = e
	} else if jsonRelationCardinality, e := op.MarshalJSONRelationCardinality(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_KindOfRelation,
			Value: map[string]json.RawMessage{
				"$RELATION":             jsonRelation,
				"$RELATION_CARDINALITY": jsonRelationCardinality,
			},
		})
	}
	return
}

func (op *KindOfRelation) MarshalJSONRelation() (ret []byte, err error) {
	ret, err = op.Relation.MarshalJSON()
	return
}

func (op *KindOfRelation) MarshalJSONRelationCardinality() (ret []byte, err error) {
	ret, err = op.RelationCardinality.MarshalJSON()
	return
}

// KindsOfAspect
type KindsOfAspect struct {
	Aspect Aspect `if:"label=_"`
}

func (*KindsOfAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsOfAspect,
		Uses: "flow",
	}
}

var Type_KindsOfAspect = "kinds_of_aspect"

func (op *KindsOfAspect) MarshalJSON() (ret []byte, err error) {
	if jsonAspect, e := op.MarshalJSONAspect(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_KindsOfAspect,
			Value: map[string]json.RawMessage{
				"$ASPECT": jsonAspect,
			},
		})
	}
	return
}

func (op *KindsOfAspect) MarshalJSONAspect() (ret []byte, err error) {
	ret, err = op.Aspect.MarshalJSON()
	return
}

// KindsOfKind
type KindsOfKind struct {
	PluralKinds  PluralKinds  `if:"label=_"`
	SingularKind SingularKind `if:"label=singular_kind"`
}

func (*KindsOfKind) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsOfKind,
		Uses: "flow",
	}
}

var Type_KindsOfKind = "kinds_of_kind"

func (op *KindsOfKind) MarshalJSON() (ret []byte, err error) {
	if jsonPluralKinds, e := op.MarshalJSONPluralKinds(); e != nil {
		err = e
	} else if jsonSingularKind, e := op.MarshalJSONSingularKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_KindsOfKind,
			Value: map[string]json.RawMessage{
				"$PLURAL_KINDS":  jsonPluralKinds,
				"$SINGULAR_KIND": jsonSingularKind,
			},
		})
	}
	return
}

func (op *KindsOfKind) MarshalJSONPluralKinds() (ret []byte, err error) {
	ret, err = op.PluralKinds.MarshalJSON()
	return
}

func (op *KindsOfKind) MarshalJSONSingularKind() (ret []byte, err error) {
	ret, err = op.SingularKind.MarshalJSON()
	return
}

// KindsOfRecord
type KindsOfRecord struct {
	RecordPlural RecordPlural `if:"label=_"`
}

func (*KindsOfRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsOfRecord,
		Uses: "flow",
	}
}

var Type_KindsOfRecord = "kinds_of_record"

func (op *KindsOfRecord) MarshalJSON() (ret []byte, err error) {
	if jsonRecordPlural, e := op.MarshalJSONRecordPlural(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_KindsOfRecord,
			Value: map[string]json.RawMessage{
				"$RECORD_PLURAL": jsonRecordPlural,
			},
		})
	}
	return
}

func (op *KindsOfRecord) MarshalJSONRecordPlural() (ret []byte, err error) {
	ret, err = op.RecordPlural.MarshalJSON()
	return
}

// KindsPossessProperties
type KindsPossessProperties struct {
	PluralKinds  PluralKinds    `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*KindsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_KindsPossessProperties,
		Uses: "flow",
	}
}

var Type_KindsPossessProperties = "kinds_possess_properties"

func (op *KindsPossessProperties) MarshalJSON() (ret []byte, err error) {
	if jsonPluralKinds, e := op.MarshalJSONPluralKinds(); e != nil {
		err = e
	} else if jsonPropertyDecl, e := op.MarshalJSONPropertyDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_KindsPossessProperties,
			Value: map[string]json.RawMessage{
				"$PLURAL_KINDS":  jsonPluralKinds,
				"$PROPERTY_DECL": jsonPropertyDecl,
			},
		})
	}
	return
}

func (op *KindsPossessProperties) MarshalJSONPluralKinds() (ret []byte, err error) {
	ret, err = op.PluralKinds.MarshalJSON()
	return
}

func (op *KindsPossessProperties) MarshalJSONPropertyDecl() (ret []byte, err error) {
	ret, err = json.Marshal(op.PropertyDecl)
	return
}

// Lede Describes one or more nouns.
type Lede struct {
	Nouns      []NamedNoun `if:"label=_"`
	NounPhrase NounPhrase  `if:"label=noun_phrase"`
}

func (*Lede) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Lede,
		Uses: "flow",
	}
}

var Type_Lede = "lede"

func (op *Lede) MarshalJSON() (ret []byte, err error) {
	if jsonNouns, e := op.MarshalJSONNouns(); e != nil {
		err = e
	} else if jsonNounPhrase, e := op.MarshalJSONNounPhrase(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Lede,
			Value: map[string]json.RawMessage{
				"$NOUNS":       jsonNouns,
				"$NOUN_PHRASE": jsonNounPhrase,
			},
		})
	}
	return
}

func (op *Lede) MarshalJSONNouns() (ret []byte, err error) {
	ret, err = json.Marshal(op.Nouns)
	return
}

func (op *Lede) MarshalJSONNounPhrase() (ret []byte, err error) {
	ret, err = op.NounPhrase.MarshalJSON()
	return
}

// LocalDecl
type LocalDecl struct {
	VariableDecl VariableDecl `if:"label=_"`
	Value        *LocalInit   `if:"label=value,optional"`
}

func (*LocalDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_LocalDecl,
		Uses: "flow",
	}
}

var Type_LocalDecl = "local_decl"

func (op *LocalDecl) MarshalJSON() (ret []byte, err error) {
	if jsonVariableDecl, e := op.MarshalJSONVariableDecl(); e != nil {
		err = e
	} else if jsonValue, e := op.MarshalJSONValue(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_LocalDecl,
			Value: map[string]json.RawMessage{
				"$VARIABLE_DECL": jsonVariableDecl,
				"$VALUE":         jsonValue,
			},
		})
	}
	return
}

func (op *LocalDecl) MarshalJSONVariableDecl() (ret []byte, err error) {
	ret, err = op.VariableDecl.MarshalJSON()
	return
}

func (op *LocalDecl) MarshalJSONValue() (ret []byte, err error) {
	ret, err = op.Value.MarshalJSON()
	return
}

// LocalInit
type LocalInit struct {
	Value rt.Assignment `if:"label=_"`
}

func (*LocalInit) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_LocalInit,
		Uses: "flow",
	}
}

var Type_LocalInit = "local_init"

func (op *LocalInit) MarshalJSON() (ret []byte, err error) {
	if jsonValue, e := op.MarshalJSONValue(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_LocalInit,
			Value: map[string]json.RawMessage{
				"$VALUE": jsonValue,
			},
		})
	}
	return
}

func (op *LocalInit) MarshalJSONValue() (ret []byte, err error) {
	if v, e := op.Value.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_Assignment,
			Value: v,
		})
	}
	return
}

// Make
type Make struct {
	Name      string     `if:"label=_,type=text"`
	Arguments *Arguments `if:"label=arguments,optional"`
}

func (*Make) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Make,
		Uses: "flow",
	}
}

var Type_Make = "make"

func (op *Make) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Make,
			Value: map[string]json.RawMessage{
				"$NAME":      jsonName,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *Make) MarshalJSONName() (ret []byte, err error) {
	// type override
	m := value.Text{op.Name}
	ret, err = m.MarshalJSON()
	return
}

func (op *Make) MarshalJSONArguments() (ret []byte, err error) {
	ret, err = op.Arguments.MarshalJSON()
	return
}

// ManyToMany
type ManyToMany struct {
	Kinds      PluralKinds `if:"label=_"`
	OtherKinds PluralKinds `if:"label=other_kinds"`
}

func (*ManyToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ManyToMany,
		Uses: "flow",
	}
}

var Type_ManyToMany = "many_to_many"

func (op *ManyToMany) MarshalJSON() (ret []byte, err error) {
	if jsonKinds, e := op.MarshalJSONKinds(); e != nil {
		err = e
	} else if jsonOtherKinds, e := op.MarshalJSONOtherKinds(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ManyToMany,
			Value: map[string]json.RawMessage{
				"$KINDS":       jsonKinds,
				"$OTHER_KINDS": jsonOtherKinds,
			},
		})
	}
	return
}

func (op *ManyToMany) MarshalJSONKinds() (ret []byte, err error) {
	ret, err = op.Kinds.MarshalJSON()
	return
}

func (op *ManyToMany) MarshalJSONOtherKinds() (ret []byte, err error) {
	ret, err = op.OtherKinds.MarshalJSON()
	return
}

// ManyToOne
type ManyToOne struct {
	Kinds PluralKinds  `if:"label=_"`
	Kind  SingularKind `if:"label=kind"`
}

func (*ManyToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ManyToOne,
		Uses: "flow",
	}
}

var Type_ManyToOne = "many_to_one"

func (op *ManyToOne) MarshalJSON() (ret []byte, err error) {
	if jsonKinds, e := op.MarshalJSONKinds(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ManyToOne,
			Value: map[string]json.RawMessage{
				"$KINDS": jsonKinds,
				"$KIND":  jsonKind,
			},
		})
	}
	return
}

func (op *ManyToOne) MarshalJSONKinds() (ret []byte, err error) {
	ret, err = op.Kinds.MarshalJSON()
	return
}

func (op *ManyToOne) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

// NamedNoun
type NamedNoun struct {
	Determiner Determiner `if:"label=_"`
	Name       NounName   `if:"label=name"`
}

func (*NamedNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NamedNoun,
		Uses: "flow",
	}
}

var Type_NamedNoun = "named_noun"

func (op *NamedNoun) MarshalJSON() (ret []byte, err error) {
	if jsonDeterminer, e := op.MarshalJSONDeterminer(); e != nil {
		err = e
	} else if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_NamedNoun,
			Value: map[string]json.RawMessage{
				"$DETERMINER": jsonDeterminer,
				"$NAME":       jsonName,
			},
		})
	}
	return
}

func (op *NamedNoun) MarshalJSONDeterminer() (ret []byte, err error) {
	ret, err = op.Determiner.MarshalJSON()
	return
}

func (op *NamedNoun) MarshalJSONName() (ret []byte, err error) {
	ret, err = op.Name.MarshalJSON()
	return
}

// NounAssignment Assign text.
type NounAssignment struct {
	Property Property    `if:"label=_"`
	Nouns    []NamedNoun `if:"label=nouns"`
	Lines    value.Lines `if:"label=lines"`
}

func (*NounAssignment) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounAssignment,
		Uses: "flow",
	}
}

var Type_NounAssignment = "noun_assignment"

func (op *NounAssignment) MarshalJSON() (ret []byte, err error) {
	if jsonProperty, e := op.MarshalJSONProperty(); e != nil {
		err = e
	} else if jsonNouns, e := op.MarshalJSONNouns(); e != nil {
		err = e
	} else if jsonLines, e := op.MarshalJSONLines(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_NounAssignment,
			Value: map[string]json.RawMessage{
				"$PROPERTY": jsonProperty,
				"$NOUNS":    jsonNouns,
				"$LINES":    jsonLines,
			},
		})
	}
	return
}

func (op *NounAssignment) MarshalJSONProperty() (ret []byte, err error) {
	ret, err = op.Property.MarshalJSON()
	return
}

func (op *NounAssignment) MarshalJSONNouns() (ret []byte, err error) {
	ret, err = json.Marshal(op.Nouns)
	return
}

func (op *NounAssignment) MarshalJSONLines() (ret []byte, err error) {
	ret, err = op.Lines.MarshalJSON()
	return
}

// NounName requires a user-specified string.
type NounName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *NounName) String() (ret string) {
	return op.Str
}

func (*NounName) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_NounName,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_NounName = "noun_name"

func (op *NounName) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_NounName,
		Value: op.Str,
	})
}

func (op *NounName) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// NounPhrase swaps between various options
type NounPhrase struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const NounPhrase_KindOfNoun = "$KIND_OF_NOUN"
const NounPhrase_NounTraits = "$NOUN_TRAITS"
const NounPhrase_NounRelation = "$NOUN_RELATION"

func (*NounPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounPhrase,
		Uses: "swap",
		Choices: []string{
			NounPhrase_KindOfNoun, NounPhrase_NounTraits, NounPhrase_NounRelation,
		},
		Swaps: []interface{}{
			(*KindOfNoun)(nil),
			(*NounTraits)(nil),
			(*NounRelation)(nil),
		},
	}
}

var Type_NounPhrase = "noun_phrase"

func (op *NounPhrase) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "noun_phrase",
			"value": val,
		})
	}
	return
}

func (op *NounPhrase) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *NounPhrase) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *KindOfNoun:
		ret, okay = NounPhrase_KindOfNoun, true
	case *NounTraits:
		ret, okay = NounPhrase_NounTraits, true
	case *NounRelation:
		ret, okay = NounPhrase_NounRelation, true
	}
	return
}

// NounRelation
type NounRelation struct {
	AreBeing bool               `if:"label=_,optional,type=are_being"`
	Relation value.RelationName `if:"label=relation"`
	Nouns    []NamedNoun        `if:"label=nouns"`
}

func (*NounRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounRelation,
		Uses: "flow",
	}
}

var Type_NounRelation = "noun_relation"

func (op *NounRelation) MarshalJSON() (ret []byte, err error) {
	if jsonAreBeing, e := op.MarshalJSONAreBeing(); e != nil {
		err = e
	} else if jsonRelation, e := op.MarshalJSONRelation(); e != nil {
		err = e
	} else if jsonNouns, e := op.MarshalJSONNouns(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_NounRelation,
			Value: map[string]json.RawMessage{
				"$ARE_BEING": jsonAreBeing,
				"$RELATION":  jsonRelation,
				"$NOUNS":     jsonNouns,
			},
		})
	}
	return
}

func (op *NounRelation) MarshalJSONAreBeing() (ret []byte, err error) {
	// bool override
	var str string
	if op.AreBeing {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	ret, err = m.MarshalJSON()
	return
}

func (op *NounRelation) MarshalJSONRelation() (ret []byte, err error) {
	ret, err = op.Relation.MarshalJSON()
	return
}

func (op *NounRelation) MarshalJSONNouns() (ret []byte, err error) {
	ret, err = json.Marshal(op.Nouns)
	return
}

// NounStatement Describes people, places, or things.
type NounStatement struct {
	Lede    Lede     `if:"label=_"`
	Tail    []Tail   `if:"label=tail,optional"`
	Summary *Summary `if:"label=summary,optional"`
}

func (*NounStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounStatement,
		Uses: "flow",
	}
}

var Type_NounStatement = "noun_statement"

func (op *NounStatement) MarshalJSON() (ret []byte, err error) {
	if jsonLede, e := op.MarshalJSONLede(); e != nil {
		err = e
	} else if jsonTail, e := op.MarshalJSONTail(); e != nil {
		err = e
	} else if jsonSummary, e := op.MarshalJSONSummary(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_NounStatement,
			Value: map[string]json.RawMessage{
				"$LEDE":    jsonLede,
				"$TAIL":    jsonTail,
				"$SUMMARY": jsonSummary,
			},
		})
	}
	return
}

func (op *NounStatement) MarshalJSONLede() (ret []byte, err error) {
	ret, err = op.Lede.MarshalJSON()
	return
}

func (op *NounStatement) MarshalJSONTail() (ret []byte, err error) {
	ret, err = json.Marshal(op.Tail)
	return
}

func (op *NounStatement) MarshalJSONSummary() (ret []byte, err error) {
	ret, err = op.Summary.MarshalJSON()
	return
}

// NounTraits
type NounTraits struct {
	AreBeing bool    `if:"label=_,type=are_being"`
	Trait    []Trait `if:"label=trait"`
}

func (*NounTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NounTraits,
		Uses: "flow",
	}
}

var Type_NounTraits = "noun_traits"

func (op *NounTraits) MarshalJSON() (ret []byte, err error) {
	if jsonAreBeing, e := op.MarshalJSONAreBeing(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_NounTraits,
			Value: map[string]json.RawMessage{
				"$ARE_BEING": jsonAreBeing,
				"$TRAIT":     jsonTrait,
			},
		})
	}
	return
}

func (op *NounTraits) MarshalJSONAreBeing() (ret []byte, err error) {
	// bool override
	var str string
	if op.AreBeing {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	ret, err = m.MarshalJSON()
	return
}

func (op *NounTraits) MarshalJSONTrait() (ret []byte, err error) {
	ret, err = json.Marshal(op.Trait)
	return
}

// NumberList requires a user-specified string.
type NumberList struct {
	Str string
}

func (op *NumberList) String() (ret string) {
	return op.Str
}

func (*NumberList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_NumberList,
		Uses: "str",
		Choices: []string{
			NumberList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

var Type_NumberList = "number_list"

func (op *NumberList) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_NumberList,
		Value: op.Str,
	})
}

func (op *NumberList) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const NumberList_List = "$LIST"

// ObjectType
type ObjectType struct {
	An   bool         `if:"label=_,type=ana"`
	Kind SingularKind `if:"label=kind"`
}

func (*ObjectType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ObjectType,
		Uses: "flow",
	}
}

var Type_ObjectType = "object_type"

func (op *ObjectType) MarshalJSON() (ret []byte, err error) {
	if jsonAn, e := op.MarshalJSONAn(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_ObjectType,
			Value: map[string]json.RawMessage{
				"$AN":   jsonAn,
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *ObjectType) MarshalJSONAn() (ret []byte, err error) {
	// bool override
	var str string
	if op.An {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	ret, err = m.MarshalJSON()
	return
}

func (op *ObjectType) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

// OneToMany
type OneToMany struct {
	Kind  SingularKind `if:"label=_"`
	Kinds PluralKinds  `if:"label=kinds"`
}

func (*OneToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_OneToMany,
		Uses: "flow",
	}
}

var Type_OneToMany = "one_to_many"

func (op *OneToMany) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonKinds, e := op.MarshalJSONKinds(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_OneToMany,
			Value: map[string]json.RawMessage{
				"$KIND":  jsonKind,
				"$KINDS": jsonKinds,
			},
		})
	}
	return
}

func (op *OneToMany) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

func (op *OneToMany) MarshalJSONKinds() (ret []byte, err error) {
	ret, err = op.Kinds.MarshalJSON()
	return
}

// OneToOne
type OneToOne struct {
	Kind      SingularKind `if:"label=_"`
	OtherKind SingularKind `if:"label=other_kind"`
}

func (*OneToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_OneToOne,
		Uses: "flow",
	}
}

var Type_OneToOne = "one_to_one"

func (op *OneToOne) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonOtherKind, e := op.MarshalJSONOtherKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_OneToOne,
			Value: map[string]json.RawMessage{
				"$KIND":       jsonKind,
				"$OTHER_KIND": jsonOtherKind,
			},
		})
	}
	return
}

func (op *OneToOne) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

func (op *OneToOne) MarshalJSONOtherKind() (ret []byte, err error) {
	ret, err = op.OtherKind.MarshalJSON()
	return
}

// PairedAction
type PairedAction struct {
	At    reader.Position `if:"internal"`
	Kinds PluralKinds     `if:"label=kinds"`
}

func (*PairedAction) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PairedAction,
		Uses: "flow",
	}
}

var Type_PairedAction = "paired_action"

func (op *PairedAction) MarshalJSON() (ret []byte, err error) {
	if jsonKinds, e := op.MarshalJSONKinds(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_PairedAction,
			Value: map[string]json.RawMessage{
				"$KINDS": jsonKinds,
			},
		})
	}
	return
}

func (op *PairedAction) MarshalJSONKinds() (ret []byte, err error) {
	ret, err = op.Kinds.MarshalJSON()
	return
}

// Paragraph
type Paragraph struct {
	StoryStatement []StoryStatement `if:"label=_,optional"`
}

func (*Paragraph) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Paragraph,
		Uses: "flow",
	}
}

var Type_Paragraph = "paragraph"

func (op *Paragraph) MarshalJSON() (ret []byte, err error) {
	if jsonStoryStatement, e := op.MarshalJSONStoryStatement(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Paragraph,
			Value: map[string]json.RawMessage{
				"$STORY_STATEMENT": jsonStoryStatement,
			},
		})
	}
	return
}

func (op *Paragraph) MarshalJSONStoryStatement() (ret []byte, err error) {
	ret, err = json.Marshal(op.StoryStatement)
	return
}

// PatternActions Actions to take when using a pattern.
type PatternActions struct {
	Name          value.PatternName `if:"label=_"`
	PatternLocals *PatternLocals    `if:"label=pattern_locals,optional"`
	PatternReturn *PatternReturn    `if:"label=pattern_return,optional"`
	PatternRules  PatternRules      `if:"label=pattern_rules"`
}

func (*PatternActions) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternActions,
		Uses: "flow",
	}
}

var Type_PatternActions = "pattern_actions"

func (op *PatternActions) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonPatternLocals, e := op.MarshalJSONPatternLocals(); e != nil {
		err = e
	} else if jsonPatternReturn, e := op.MarshalJSONPatternReturn(); e != nil {
		err = e
	} else if jsonPatternRules, e := op.MarshalJSONPatternRules(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PatternActions,
			Value: map[string]json.RawMessage{
				"$NAME":           jsonName,
				"$PATTERN_LOCALS": jsonPatternLocals,
				"$PATTERN_RETURN": jsonPatternReturn,
				"$PATTERN_RULES":  jsonPatternRules,
			},
		})
	}
	return
}

func (op *PatternActions) MarshalJSONName() (ret []byte, err error) {
	ret, err = op.Name.MarshalJSON()
	return
}

func (op *PatternActions) MarshalJSONPatternLocals() (ret []byte, err error) {
	ret, err = op.PatternLocals.MarshalJSON()
	return
}

func (op *PatternActions) MarshalJSONPatternReturn() (ret []byte, err error) {
	ret, err = op.PatternReturn.MarshalJSON()
	return
}

func (op *PatternActions) MarshalJSONPatternRules() (ret []byte, err error) {
	ret, err = op.PatternRules.MarshalJSON()
	return
}

// PatternDecl
type PatternDecl struct {
	Type          PatternType           `if:"label=_"`
	Name          value.PatternName     `if:"label=name"`
	Optvars       *PatternVariablesTail `if:"label=optvars,optional"`
	PatternReturn *PatternReturn        `if:"label=pattern_return,optional"`
	About         *Comment              `if:"label=about,optional"`
}

func (*PatternDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternDecl,
		Uses: "flow",
	}
}

var Type_PatternDecl = "pattern_decl"

func (op *PatternDecl) MarshalJSON() (ret []byte, err error) {
	if jsonType, e := op.MarshalJSONType(); e != nil {
		err = e
	} else if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonOptvars, e := op.MarshalJSONOptvars(); e != nil {
		err = e
	} else if jsonPatternReturn, e := op.MarshalJSONPatternReturn(); e != nil {
		err = e
	} else if jsonAbout, e := op.MarshalJSONAbout(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PatternDecl,
			Value: map[string]json.RawMessage{
				"$TYPE":           jsonType,
				"$NAME":           jsonName,
				"$OPTVARS":        jsonOptvars,
				"$PATTERN_RETURN": jsonPatternReturn,
				"$ABOUT":          jsonAbout,
			},
		})
	}
	return
}

func (op *PatternDecl) MarshalJSONType() (ret []byte, err error) {
	ret, err = op.Type.MarshalJSON()
	return
}

func (op *PatternDecl) MarshalJSONName() (ret []byte, err error) {
	ret, err = op.Name.MarshalJSON()
	return
}

func (op *PatternDecl) MarshalJSONOptvars() (ret []byte, err error) {
	ret, err = op.Optvars.MarshalJSON()
	return
}

func (op *PatternDecl) MarshalJSONPatternReturn() (ret []byte, err error) {
	ret, err = op.PatternReturn.MarshalJSON()
	return
}

func (op *PatternDecl) MarshalJSONAbout() (ret []byte, err error) {
	ret, err = op.About.MarshalJSON()
	return
}

// PatternFlags requires a user-specified string.
type PatternFlags struct {
	Str string
}

func (op *PatternFlags) String() (ret string) {
	return op.Str
}

func (*PatternFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternFlags,
		Uses: "str",
		Choices: []string{
			PatternFlags_Before, PatternFlags_After, PatternFlags_Terminate,
		},
		Strings: []string{
			"before", "after", "terminate",
		},
	}
}

var Type_PatternFlags = "pattern_flags"

func (op *PatternFlags) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_PatternFlags,
		Value: op.Str,
	})
}

func (op *PatternFlags) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const PatternFlags_Before = "$BEFORE"
const PatternFlags_After = "$AFTER"
const PatternFlags_Terminate = "$TERMINATE"

// PatternLocals
type PatternLocals struct {
	LocalDecl []LocalDecl `if:"label=_"`
}

func (*PatternLocals) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternLocals,
		Uses: "flow",
	}
}

var Type_PatternLocals = "pattern_locals"

func (op *PatternLocals) MarshalJSON() (ret []byte, err error) {
	if jsonLocalDecl, e := op.MarshalJSONLocalDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PatternLocals,
			Value: map[string]json.RawMessage{
				"$LOCAL_DECL": jsonLocalDecl,
			},
		})
	}
	return
}

func (op *PatternLocals) MarshalJSONLocalDecl() (ret []byte, err error) {
	ret, err = json.Marshal(op.LocalDecl)
	return
}

// PatternReturn
type PatternReturn struct {
	Result VariableDecl `if:"label=_"`
}

func (*PatternReturn) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternReturn,
		Uses: "flow",
	}
}

var Type_PatternReturn = "pattern_return"

func (op *PatternReturn) MarshalJSON() (ret []byte, err error) {
	if jsonResult, e := op.MarshalJSONResult(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PatternReturn,
			Value: map[string]json.RawMessage{
				"$RESULT": jsonResult,
			},
		})
	}
	return
}

func (op *PatternReturn) MarshalJSONResult() (ret []byte, err error) {
	ret, err = op.Result.MarshalJSON()
	return
}

// PatternRule
type PatternRule struct {
	Guard rt.BoolEval  `if:"label=_"`
	Flags PatternFlags `if:"label=flags,optional"`
	Hook  ProgramHook  `if:"label=hook"`
}

func (*PatternRule) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternRule,
		Uses: "flow",
	}
}

var Type_PatternRule = "pattern_rule"

func (op *PatternRule) MarshalJSON() (ret []byte, err error) {
	if jsonGuard, e := op.MarshalJSONGuard(); e != nil {
		err = e
	} else if jsonFlags, e := op.MarshalJSONFlags(); e != nil {
		err = e
	} else if jsonHook, e := op.MarshalJSONHook(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PatternRule,
			Value: map[string]json.RawMessage{
				"$GUARD": jsonGuard,
				"$FLAGS": jsonFlags,
				"$HOOK":  jsonHook,
			},
		})
	}
	return
}

func (op *PatternRule) MarshalJSONGuard() (ret []byte, err error) {
	if v, e := op.Guard.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_BoolEval,
			Value: v,
		})
	}
	return
}

func (op *PatternRule) MarshalJSONFlags() (ret []byte, err error) {
	ret, err = op.Flags.MarshalJSON()
	return
}

func (op *PatternRule) MarshalJSONHook() (ret []byte, err error) {
	ret, err = op.Hook.MarshalJSON()
	return
}

// PatternRules
type PatternRules struct {
	PatternRule []PatternRule `if:"label=_,optional"`
}

func (*PatternRules) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternRules,
		Uses: "flow",
	}
}

var Type_PatternRules = "pattern_rules"

func (op *PatternRules) MarshalJSON() (ret []byte, err error) {
	if jsonPatternRule, e := op.MarshalJSONPatternRule(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PatternRules,
			Value: map[string]json.RawMessage{
				"$PATTERN_RULE": jsonPatternRule,
			},
		})
	}
	return
}

func (op *PatternRules) MarshalJSONPatternRule() (ret []byte, err error) {
	ret, err = json.Marshal(op.PatternRule)
	return
}

// PatternType requires a user-specified string.
type PatternType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PatternType) String() (ret string) {
	return op.Str
}

func (*PatternType) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_PatternType,
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			PatternType_Patterns, PatternType_Actions, PatternType_Events,
		},
		Strings: []string{
			"patterns", "actions", "events",
		},
	}
}

var Type_PatternType = "pattern_type"

func (op *PatternType) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_PatternType,
		Value: op.Str,
	})
}

func (op *PatternType) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

const PatternType_Patterns = "$PATTERNS"
const PatternType_Actions = "$ACTIONS"
const PatternType_Events = "$EVENTS"

// PatternVariablesDecl Values provided when calling a pattern.
type PatternVariablesDecl struct {
	PatternName  value.PatternName `if:"label=_"`
	VariableDecl []VariableDecl    `if:"label=variable_decl"`
}

func (*PatternVariablesDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternVariablesDecl,
		Uses: "flow",
	}
}

var Type_PatternVariablesDecl = "pattern_variables_decl"

func (op *PatternVariablesDecl) MarshalJSON() (ret []byte, err error) {
	if jsonPatternName, e := op.MarshalJSONPatternName(); e != nil {
		err = e
	} else if jsonVariableDecl, e := op.MarshalJSONVariableDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PatternVariablesDecl,
			Value: map[string]json.RawMessage{
				"$PATTERN_NAME":  jsonPatternName,
				"$VARIABLE_DECL": jsonVariableDecl,
			},
		})
	}
	return
}

func (op *PatternVariablesDecl) MarshalJSONPatternName() (ret []byte, err error) {
	ret, err = op.PatternName.MarshalJSON()
	return
}

func (op *PatternVariablesDecl) MarshalJSONVariableDecl() (ret []byte, err error) {
	ret, err = json.Marshal(op.VariableDecl)
	return
}

// PatternVariablesTail Storage for values used during the execution of a pattern.
type PatternVariablesTail struct {
	VariableDecl []VariableDecl `if:"label=_"`
}

func (*PatternVariablesTail) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PatternVariablesTail,
		Uses: "flow",
	}
}

var Type_PatternVariablesTail = "pattern_variables_tail"

func (op *PatternVariablesTail) MarshalJSON() (ret []byte, err error) {
	if jsonVariableDecl, e := op.MarshalJSONVariableDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PatternVariablesTail,
			Value: map[string]json.RawMessage{
				"$VARIABLE_DECL": jsonVariableDecl,
			},
		})
	}
	return
}

func (op *PatternVariablesTail) MarshalJSONVariableDecl() (ret []byte, err error) {
	ret, err = json.Marshal(op.VariableDecl)
	return
}

// PluralKinds requires a user-specified string.
type PluralKinds struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PluralKinds) String() (ret string) {
	return op.Str
}

func (*PluralKinds) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_PluralKinds,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_PluralKinds = "plural_kinds"

func (op *PluralKinds) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_PluralKinds,
		Value: op.Str,
	})
}

func (op *PluralKinds) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// PrimitiveType requires a user-specified string.
type PrimitiveType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PrimitiveType) String() (ret string) {
	return op.Str
}

func (*PrimitiveType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PrimitiveType,
		Uses: "str",
		Choices: []string{
			PrimitiveType_Number, PrimitiveType_Text, PrimitiveType_Bool,
		},
		Strings: []string{
			"number", "text", "bool",
		},
	}
}

var Type_PrimitiveType = "primitive_type"

func (op *PrimitiveType) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_PrimitiveType,
		Value: op.Str,
	})
}

func (op *PrimitiveType) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

const PrimitiveType_Number = "$NUMBER"
const PrimitiveType_Text = "$TEXT"
const PrimitiveType_Bool = "$BOOL"

// PrimitiveValue swaps between various options
type PrimitiveValue struct {
	Opt interface{}
}

const PrimitiveValue_BoxedText = "$BOXED_TEXT"
const PrimitiveValue_BoxedNumber = "$BOXED_NUMBER"

func (*PrimitiveValue) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PrimitiveValue,
		Uses: "swap",
		Choices: []string{
			PrimitiveValue_BoxedText, PrimitiveValue_BoxedNumber,
		},
		Swaps: []interface{}{
			(*BoxedText)(nil),
			(*BoxedNumber)(nil),
		},
	}
}

var Type_PrimitiveValue = "primitive_value"

func (op *PrimitiveValue) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "primitive_value",
			"value": val,
		})
	}
	return
}

func (op *PrimitiveValue) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *PrimitiveValue) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *BoxedText:
		ret, okay = PrimitiveValue_BoxedText, true
	case *BoxedNumber:
		ret, okay = PrimitiveValue_BoxedNumber, true
	}
	return
}

// ProgramHook swaps between various options
type ProgramHook struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ProgramHook_Activity = "$ACTIVITY"

func (*ProgramHook) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ProgramHook,
		Uses: "swap",
		Choices: []string{
			ProgramHook_Activity,
		},
		Swaps: []interface{}{
			(*core.Activity)(nil),
		},
	}
}

var Type_ProgramHook = "program_hook"

func (op *ProgramHook) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "program_hook",
			"value": val,
		})
	}
	return
}

func (op *ProgramHook) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *ProgramHook) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *core.Activity:
		ret, okay = ProgramHook_Activity, true
	}
	return
}

// Pronoun requires a user-specified string.
type Pronoun struct {
	Str string
}

func (op *Pronoun) String() (ret string) {
	return op.Str
}

func (*Pronoun) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Pronoun,
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			Pronoun_It, Pronoun_They,
		},
		Strings: []string{
			"it", "they",
		},
	}
}

var Type_Pronoun = "pronoun"

func (op *Pronoun) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_Pronoun,
		Value: op.Str,
	})
}

func (op *Pronoun) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const Pronoun_It = "$IT"
const Pronoun_They = "$THEY"

// Property requires a user-specified string.
type Property struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Property) String() (ret string) {
	return op.Str
}

func (*Property) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Property,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_Property = "property"

func (op *Property) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_Property,
		Value: op.Str,
	})
}

func (op *Property) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// PropertyAspect requires a user-specified string.
type PropertyAspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PropertyAspect) String() (ret string) {
	return op.Str
}

func (*PropertyAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PropertyAspect,
		Uses: "str",
		Choices: []string{
			PropertyAspect_Aspect,
		},
		Strings: []string{
			"aspect",
		},
	}
}

var Type_PropertyAspect = "property_aspect"

func (op *PropertyAspect) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_PropertyAspect,
		Value: op.Str,
	})
}

func (op *PropertyAspect) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

const PropertyAspect_Aspect = "$ASPECT"

// PropertyDecl
type PropertyDecl struct {
	An           Determiner   `if:"label=_"`
	Property     Property     `if:"label=property"`
	PropertyType PropertyType `if:"label=property_type"`
	Comment      value.Lines  `if:"label=comment,optional"`
}

func (*PropertyDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PropertyDecl,
		Uses: "flow",
	}
}

var Type_PropertyDecl = "property_decl"

func (op *PropertyDecl) MarshalJSON() (ret []byte, err error) {
	if jsonAn, e := op.MarshalJSONAn(); e != nil {
		err = e
	} else if jsonProperty, e := op.MarshalJSONProperty(); e != nil {
		err = e
	} else if jsonPropertyType, e := op.MarshalJSONPropertyType(); e != nil {
		err = e
	} else if jsonComment, e := op.MarshalJSONComment(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_PropertyDecl,
			Value: map[string]json.RawMessage{
				"$AN":            jsonAn,
				"$PROPERTY":      jsonProperty,
				"$PROPERTY_TYPE": jsonPropertyType,
				"$COMMENT":       jsonComment,
			},
		})
	}
	return
}

func (op *PropertyDecl) MarshalJSONAn() (ret []byte, err error) {
	ret, err = op.An.MarshalJSON()
	return
}

func (op *PropertyDecl) MarshalJSONProperty() (ret []byte, err error) {
	ret, err = op.Property.MarshalJSON()
	return
}

func (op *PropertyDecl) MarshalJSONPropertyType() (ret []byte, err error) {
	ret, err = op.PropertyType.MarshalJSON()
	return
}

func (op *PropertyDecl) MarshalJSONComment() (ret []byte, err error) {
	ret, err = op.Comment.MarshalJSON()
	return
}

// PropertyType swaps between various options
type PropertyType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const PropertyType_PropertyAspect = "$PROPERTY_ASPECT"
const PropertyType_Primitive = "$PRIMITIVE"
const PropertyType_Ext = "$EXT"

func (*PropertyType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_PropertyType,
		Uses: "swap",
		Choices: []string{
			PropertyType_PropertyAspect, PropertyType_Primitive, PropertyType_Ext,
		},
		Swaps: []interface{}{
			(*PropertyAspect)(nil),
			(*PrimitiveType)(nil),
			(*ExtType)(nil),
		},
	}
}

var Type_PropertyType = "property_type"

func (op *PropertyType) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "property_type",
			"value": val,
		})
	}
	return
}

func (op *PropertyType) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *PropertyType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PropertyAspect:
		ret, okay = PropertyType_PropertyAspect, true
	case *PrimitiveType:
		ret, okay = PropertyType_Primitive, true
	case *ExtType:
		ret, okay = PropertyType_Ext, true
	}
	return
}

// RecordList
type RecordList struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RecordList,
		Uses: "flow",
	}
}

var Type_RecordList = "record_list"

func (op *RecordList) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RecordList,
			Value: map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *RecordList) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

// RecordPlural requires a user-specified string.
type RecordPlural struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordPlural) String() (ret string) {
	return op.Str
}

func (*RecordPlural) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_RecordPlural,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_RecordPlural = "record_plural"

func (op *RecordPlural) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_RecordPlural,
		Value: op.Str,
	})
}

func (op *RecordPlural) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// RecordSingular requires a user-specified string.
type RecordSingular struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordSingular) String() (ret string) {
	return op.Str
}

func (*RecordSingular) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_RecordSingular,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_RecordSingular = "record_singular"

func (op *RecordSingular) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_RecordSingular,
		Value: op.Str,
	})
}

func (op *RecordSingular) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// RecordType
type RecordType struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RecordType,
		Uses: "flow",
	}
}

var Type_RecordType = "record_type"

func (op *RecordType) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RecordType,
			Value: map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *RecordType) MarshalJSONKind() (ret []byte, err error) {
	ret, err = op.Kind.MarshalJSON()
	return
}

// RecordsPossessProperties
type RecordsPossessProperties struct {
	RecordPlural RecordPlural   `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*RecordsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RecordsPossessProperties,
		Uses: "flow",
	}
}

var Type_RecordsPossessProperties = "records_possess_properties"

func (op *RecordsPossessProperties) MarshalJSON() (ret []byte, err error) {
	if jsonRecordPlural, e := op.MarshalJSONRecordPlural(); e != nil {
		err = e
	} else if jsonPropertyDecl, e := op.MarshalJSONPropertyDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RecordsPossessProperties,
			Value: map[string]json.RawMessage{
				"$RECORD_PLURAL": jsonRecordPlural,
				"$PROPERTY_DECL": jsonPropertyDecl,
			},
		})
	}
	return
}

func (op *RecordsPossessProperties) MarshalJSONRecordPlural() (ret []byte, err error) {
	ret, err = op.RecordPlural.MarshalJSON()
	return
}

func (op *RecordsPossessProperties) MarshalJSONPropertyDecl() (ret []byte, err error) {
	ret, err = json.Marshal(op.PropertyDecl)
	return
}

// RelationCardinality swaps between various options
type RelationCardinality struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const RelationCardinality_OneToOne = "$ONE_TO_ONE"
const RelationCardinality_OneToMany = "$ONE_TO_MANY"
const RelationCardinality_ManyToOne = "$MANY_TO_ONE"
const RelationCardinality_ManyToMany = "$MANY_TO_MANY"

func (*RelationCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RelationCardinality,
		Uses: "swap",
		Choices: []string{
			RelationCardinality_OneToOne, RelationCardinality_OneToMany, RelationCardinality_ManyToOne, RelationCardinality_ManyToMany,
		},
		Swaps: []interface{}{
			(*OneToOne)(nil),
			(*OneToMany)(nil),
			(*ManyToOne)(nil),
			(*ManyToMany)(nil),
		},
	}
}

var Type_RelationCardinality = "relation_cardinality"

func (op *RelationCardinality) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "relation_cardinality",
			"value": val,
		})
	}
	return
}

func (op *RelationCardinality) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *RelationCardinality) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *OneToOne:
		ret, okay = RelationCardinality_OneToOne, true
	case *OneToMany:
		ret, okay = RelationCardinality_OneToMany, true
	case *ManyToOne:
		ret, okay = RelationCardinality_ManyToOne, true
	case *ManyToMany:
		ret, okay = RelationCardinality_ManyToMany, true
	}
	return
}

// RelativeToNoun
type RelativeToNoun struct {
	Relation value.RelationName `if:"label=_"`
	Nouns    []NamedNoun        `if:"label=nouns"`
	AreBeing bool               `if:"label=are_being,type=are_being"`
	Nouns1   []NamedNoun        `if:"label=nouns1"`
}

func (*RelativeToNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RelativeToNoun,
		Uses: "flow",
	}
}

var Type_RelativeToNoun = "relative_to_noun"

func (op *RelativeToNoun) MarshalJSON() (ret []byte, err error) {
	if jsonRelation, e := op.MarshalJSONRelation(); e != nil {
		err = e
	} else if jsonNouns, e := op.MarshalJSONNouns(); e != nil {
		err = e
	} else if jsonAreBeing, e := op.MarshalJSONAreBeing(); e != nil {
		err = e
	} else if jsonNouns1, e := op.MarshalJSONNouns1(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RelativeToNoun,
			Value: map[string]json.RawMessage{
				"$RELATION":  jsonRelation,
				"$NOUNS":     jsonNouns,
				"$ARE_BEING": jsonAreBeing,
				"$NOUNS1":    jsonNouns1,
			},
		})
	}
	return
}

func (op *RelativeToNoun) MarshalJSONRelation() (ret []byte, err error) {
	ret, err = op.Relation.MarshalJSON()
	return
}

func (op *RelativeToNoun) MarshalJSONNouns() (ret []byte, err error) {
	ret, err = json.Marshal(op.Nouns)
	return
}

func (op *RelativeToNoun) MarshalJSONAreBeing() (ret []byte, err error) {
	// bool override
	var str string
	if op.AreBeing {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	ret, err = m.MarshalJSON()
	return
}

func (op *RelativeToNoun) MarshalJSONNouns1() (ret []byte, err error) {
	ret, err = json.Marshal(op.Nouns1)
	return
}

// RenderTemplate Parse text using iffy templates.
type RenderTemplate struct {
	Template value.Lines `if:"label=_"`
}

func (*RenderTemplate) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_RenderTemplate,
		Uses: "flow",
	}
}

var Type_RenderTemplate = "render_template"

func (op *RenderTemplate) MarshalJSON() (ret []byte, err error) {
	if jsonTemplate, e := op.MarshalJSONTemplate(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_RenderTemplate,
			Value: map[string]json.RawMessage{
				"$TEMPLATE": jsonTemplate,
			},
		})
	}
	return
}

func (op *RenderTemplate) MarshalJSONTemplate() (ret []byte, err error) {
	ret, err = op.Template.MarshalJSON()
	return
}

// Send
type Send struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=path"`
	Arguments *Arguments      `if:"label=arguments,optional"`
}

func (*Send) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Send,
		Uses: "flow",
	}
}

var Type_Send = "send"

func (op *Send) MarshalJSON() (ret []byte, err error) {
	if jsonEvent, e := op.MarshalJSONEvent(); e != nil {
		err = e
	} else if jsonPath, e := op.MarshalJSONPath(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Send,
			Value: map[string]json.RawMessage{
				"$EVENT":     jsonEvent,
				"$PATH":      jsonPath,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *Send) MarshalJSONEvent() (ret []byte, err error) {
	// type override
	m := value.Text{op.Event}
	ret, err = m.MarshalJSON()
	return
}

func (op *Send) MarshalJSONPath() (ret []byte, err error) {
	if v, e := op.Path.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  rt.Type_TextListEval,
			Value: v,
		})
	}
	return
}

func (op *Send) MarshalJSONArguments() (ret []byte, err error) {
	ret, err = op.Arguments.MarshalJSON()
	return
}

// ShuffleText
type ShuffleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*ShuffleText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_ShuffleText,
		Uses: "flow",
	}
}

var Type_ShuffleText = "shuffle_text"

func (op *ShuffleText) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_ShuffleText,
			Value: map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *ShuffleText) MarshalJSONParts() (ret []byte, err error) {
	ret, err = json.Marshal(op.Parts)
	return
}

// SingularKind requires a user-specified string.
type SingularKind struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *SingularKind) String() (ret string) {
	return op.Str
}

func (*SingularKind) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_SingularKind,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_SingularKind = "singular_kind"

func (op *SingularKind) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_SingularKind,
		Value: op.Str,
	})
}

func (op *SingularKind) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// StoppingText
type StoppingText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*StoppingText) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_StoppingText,
		Uses: "flow",
	}
}

var Type_StoppingText = "stopping_text"

func (op *StoppingText) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_StoppingText,
			Value: map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *StoppingText) MarshalJSONParts() (ret []byte, err error) {
	ret, err = json.Marshal(op.Parts)
	return
}

// Story
type Story struct {
	Paragraph []Paragraph `if:"label=_,optional"`
}

func (*Story) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Story,
		Uses: "flow",
	}
}

var Type_Story = "story"

func (op *Story) MarshalJSON() (ret []byte, err error) {
	if jsonParagraph, e := op.MarshalJSONParagraph(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Story,
			Value: map[string]json.RawMessage{
				"$PARAGRAPH": jsonParagraph,
			},
		})
	}
	return
}

func (op *Story) MarshalJSONParagraph() (ret []byte, err error) {
	ret, err = json.Marshal(op.Paragraph)
	return
}

const Type_StoryStatement = "story_statement"

// Summary
type Summary struct {
	At    reader.Position `if:"internal"`
	Lines value.Lines     `if:"label=lines"`
}

func (*Summary) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Summary,
		Uses: "flow",
	}
}

var Type_Summary = "summary"

func (op *Summary) MarshalJSON() (ret []byte, err error) {
	if jsonLines, e := op.MarshalJSONLines(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_Summary,
			Value: map[string]json.RawMessage{
				"$LINES": jsonLines,
			},
		})
	}
	return
}

func (op *Summary) MarshalJSONLines() (ret []byte, err error) {
	ret, err = op.Lines.MarshalJSON()
	return
}

// Tail Adds details about the preceding noun or nouns.
type Tail struct {
	Pronoun    Pronoun    `if:"label=_"`
	NounPhrase NounPhrase `if:"label=noun_phrase"`
}

func (*Tail) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_Tail,
		Uses: "flow",
	}
}

var Type_Tail = "tail"

func (op *Tail) MarshalJSON() (ret []byte, err error) {
	if jsonPronoun, e := op.MarshalJSONPronoun(); e != nil {
		err = e
	} else if jsonNounPhrase, e := op.MarshalJSONNounPhrase(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_Tail,
			Value: map[string]json.RawMessage{
				"$PRONOUN":     jsonPronoun,
				"$NOUN_PHRASE": jsonNounPhrase,
			},
		})
	}
	return
}

func (op *Tail) MarshalJSONPronoun() (ret []byte, err error) {
	ret, err = op.Pronoun.MarshalJSON()
	return
}

func (op *Tail) MarshalJSONNounPhrase() (ret []byte, err error) {
	ret, err = op.NounPhrase.MarshalJSON()
	return
}

// TestName requires a user-specified string.
type TestName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *TestName) String() (ret string) {
	return op.Str
}

func (*TestName) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_TestName,
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			TestName_CurrentTest,
		},
		Strings: []string{
			"current_test",
		},
	}
}

var Type_TestName = "test_name"

func (op *TestName) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_TestName,
		Value: op.Str,
	})
}

func (op *TestName) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

const TestName_CurrentTest = "$CURRENT_TEST"

// TestOutput Expect that a test uses &#x27;Say&#x27; to print some specific text.
type TestOutput struct {
	Lines value.Lines `if:"label=_"`
}

func (*TestOutput) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TestOutput,
		Uses: "flow",
	}
}

var Type_TestOutput = "test_output"

func (op *TestOutput) MarshalJSON() (ret []byte, err error) {
	if jsonLines, e := op.MarshalJSONLines(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_TestOutput,
			Value: map[string]json.RawMessage{
				"$LINES": jsonLines,
			},
		})
	}
	return
}

func (op *TestOutput) MarshalJSONLines() (ret []byte, err error) {
	ret, err = op.Lines.MarshalJSON()
	return
}

// TestRule
type TestRule struct {
	TestName TestName    `if:"label=_"`
	Hook     ProgramHook `if:"label=hook"`
}

func (*TestRule) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TestRule,
		Uses: "flow",
	}
}

var Type_TestRule = "test_rule"

func (op *TestRule) MarshalJSON() (ret []byte, err error) {
	if jsonTestName, e := op.MarshalJSONTestName(); e != nil {
		err = e
	} else if jsonHook, e := op.MarshalJSONHook(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_TestRule,
			Value: map[string]json.RawMessage{
				"$TEST_NAME": jsonTestName,
				"$HOOK":      jsonHook,
			},
		})
	}
	return
}

func (op *TestRule) MarshalJSONTestName() (ret []byte, err error) {
	ret, err = op.TestName.MarshalJSON()
	return
}

func (op *TestRule) MarshalJSONHook() (ret []byte, err error) {
	ret, err = op.Hook.MarshalJSON()
	return
}

// TestScene
type TestScene struct {
	TestName TestName `if:"label=_"`
	Story    Story    `if:"label=story"`
}

func (*TestScene) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TestScene,
		Uses: "flow",
	}
}

var Type_TestScene = "test_scene"

func (op *TestScene) MarshalJSON() (ret []byte, err error) {
	if jsonTestName, e := op.MarshalJSONTestName(); e != nil {
		err = e
	} else if jsonStory, e := op.MarshalJSONStory(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_TestScene,
			Value: map[string]json.RawMessage{
				"$TEST_NAME": jsonTestName,
				"$STORY":     jsonStory,
			},
		})
	}
	return
}

func (op *TestScene) MarshalJSONTestName() (ret []byte, err error) {
	ret, err = op.TestName.MarshalJSON()
	return
}

func (op *TestScene) MarshalJSONStory() (ret []byte, err error) {
	ret, err = op.Story.MarshalJSON()
	return
}

// TestStatement
type TestStatement struct {
	At       reader.Position `if:"internal"`
	TestName TestName        `if:"label=test_name"`
	Test     Testing         `if:"label=test"`
}

func (*TestStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TestStatement,
		Uses: "flow",
	}
}

var Type_TestStatement = "test_statement"

func (op *TestStatement) MarshalJSON() (ret []byte, err error) {
	if jsonTestName, e := op.MarshalJSONTestName(); e != nil {
		err = e
	} else if jsonTest, e := op.MarshalJSONTest(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Id:   op.At.Offset,
			Type: Type_TestStatement,
			Value: map[string]json.RawMessage{
				"$TEST_NAME": jsonTestName,
				"$TEST":      jsonTest,
			},
		})
	}
	return
}

func (op *TestStatement) MarshalJSONTestName() (ret []byte, err error) {
	ret, err = op.TestName.MarshalJSON()
	return
}

func (op *TestStatement) MarshalJSONTest() (ret []byte, err error) {
	if v, e := op.Test.(json.Marshaler).MarshalJSON(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Slot{
			Type:  Type_Testing,
			Value: v,
		})
	}
	return
}

const Type_Testing = "testing"

// TextList requires a user-specified string.
type TextList struct {
	Str string
}

func (op *TextList) String() (ret string) {
	return op.Str
}

func (*TextList) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TextList,
		Uses: "str",
		Choices: []string{
			TextList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

var Type_TextList = "text_list"

func (op *TextList) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Type:  Type_TextList,
		Value: op.Str,
	})
}

func (op *TextList) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.Str = d.Value
	}
	return
}

const TextList_List = "$LIST"

// Trait requires a user-specified string.
type Trait struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Trait) String() (ret string) {
	return op.Str
}

func (*Trait) Compose() composer.Spec {
	return composer.Spec{
		Name:        Type_Trait,
		Uses:        "str",
		OpenStrings: true,
	}
}

var Type_Trait = "trait"

func (op *Trait) MarshalJSON() ([]byte, error) {
	return json.Marshal(jsonexp.String{
		Id:    op.At.Offset,
		Type:  Type_Trait,
		Value: op.Str,
	})
}

func (op *Trait) UnmarshalJSON(b []byte) (err error) {
	var d jsonexp.String
	if e := json.Unmarshal(b, &d); e != nil {
		err = e
	} else {
		op.At.Offset = d.Id
		op.Str = d.Value
	}
	return
}

// TraitPhrase
type TraitPhrase struct {
	AreEither bool    `if:"label=_,type=are_either"`
	Trait     []Trait `if:"label=trait"`
}

func (*TraitPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_TraitPhrase,
		Uses: "flow",
	}
}

var Type_TraitPhrase = "trait_phrase"

func (op *TraitPhrase) MarshalJSON() (ret []byte, err error) {
	if jsonAreEither, e := op.MarshalJSONAreEither(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_TraitPhrase,
			Value: map[string]json.RawMessage{
				"$ARE_EITHER": jsonAreEither,
				"$TRAIT":      jsonTrait,
			},
		})
	}
	return
}

func (op *TraitPhrase) MarshalJSONAreEither() (ret []byte, err error) {
	// bool override
	var str string
	if op.AreEither {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	ret, err = m.MarshalJSON()
	return
}

func (op *TraitPhrase) MarshalJSONTrait() (ret []byte, err error) {
	ret, err = json.Marshal(op.Trait)
	return
}

// VariableDecl
type VariableDecl struct {
	An      Determiner         `if:"label=_"`
	Name    value.VariableName `if:"label=name"`
	Type    VariableType       `if:"label=type"`
	Comment value.Lines        `if:"label=comment,optional"`
}

func (*VariableDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_VariableDecl,
		Uses: "flow",
	}
}

var Type_VariableDecl = "variable_decl"

func (op *VariableDecl) MarshalJSON() (ret []byte, err error) {
	if jsonAn, e := op.MarshalJSONAn(); e != nil {
		err = e
	} else if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonType, e := op.MarshalJSONType(); e != nil {
		err = e
	} else if jsonComment, e := op.MarshalJSONComment(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(jsonexp.Flow{
			Type: Type_VariableDecl,
			Value: map[string]json.RawMessage{
				"$AN":      jsonAn,
				"$NAME":    jsonName,
				"$TYPE":    jsonType,
				"$COMMENT": jsonComment,
			},
		})
	}
	return
}

func (op *VariableDecl) MarshalJSONAn() (ret []byte, err error) {
	ret, err = op.An.MarshalJSON()
	return
}

func (op *VariableDecl) MarshalJSONName() (ret []byte, err error) {
	ret, err = op.Name.MarshalJSON()
	return
}

func (op *VariableDecl) MarshalJSONType() (ret []byte, err error) {
	ret, err = op.Type.MarshalJSON()
	return
}

func (op *VariableDecl) MarshalJSONComment() (ret []byte, err error) {
	ret, err = op.Comment.MarshalJSON()
	return
}

// VariableType swaps between various options
type VariableType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const VariableType_Primitive = "$PRIMITIVE"
const VariableType_Object = "$OBJECT"
const VariableType_Ext = "$EXT"

func (*VariableType) Compose() composer.Spec {
	return composer.Spec{
		Name: Type_VariableType,
		Uses: "swap",
		Choices: []string{
			VariableType_Primitive, VariableType_Object, VariableType_Ext,
		},
		Swaps: []interface{}{
			(*PrimitiveType)(nil),
			(*ObjectType)(nil),
			(*ExtType)(nil),
		},
	}
}

var Type_VariableType = "variable_type"

func (op *VariableType) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "variable_type",
			"value": val,
		})
	}
	return
}

func (op *VariableType) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *VariableType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PrimitiveType:
		ret, okay = VariableType_Primitive, true
	case *ObjectType:
		ret, okay = VariableType_Object, true
	case *ExtType:
		ret, okay = VariableType_Ext, true
	}
	return
}

var Slots = []interface{}{
	(*StoryStatement)(nil),
	(*Testing)(nil),
}

var Slats = []composer.Composer{
	(*AbstractAction)(nil),
	(*ActionContext)(nil),
	(*ActionDecl)(nil),
	(*ActionName)(nil),
	(*ActionParams)(nil),
	(*Ana)(nil),
	(*AreAn)(nil),
	(*AreBeing)(nil),
	(*AreEither)(nil),
	(*Argument)(nil),
	(*Arguments)(nil),
	(*Aspect)(nil),
	(*AspectTraits)(nil),
	(*BoxedNumber)(nil),
	(*BoxedText)(nil),
	(*Certainties)(nil),
	(*Certainty)(nil),
	(*Comment)(nil),
	(*CommonAction)(nil),
	(*CountOf)(nil),
	(*CycleText)(nil),
	(*Determine)(nil),
	(*Determiner)(nil),
	(*EventBlock)(nil),
	(*EventHandler)(nil),
	(*EventName)(nil),
	(*EventPhase)(nil),
	(*EventTarget)(nil),
	(*ExtType)(nil),
	(*GrammarDecl)(nil),
	(*KindOfNoun)(nil),
	(*KindOfRelation)(nil),
	(*KindsOfAspect)(nil),
	(*KindsOfKind)(nil),
	(*KindsOfRecord)(nil),
	(*KindsPossessProperties)(nil),
	(*Lede)(nil),
	(*LocalDecl)(nil),
	(*LocalInit)(nil),
	(*Make)(nil),
	(*ManyToMany)(nil),
	(*ManyToOne)(nil),
	(*NamedNoun)(nil),
	(*NounAssignment)(nil),
	(*NounName)(nil),
	(*NounPhrase)(nil),
	(*NounRelation)(nil),
	(*NounStatement)(nil),
	(*NounTraits)(nil),
	(*NumberList)(nil),
	(*ObjectType)(nil),
	(*OneToMany)(nil),
	(*OneToOne)(nil),
	(*PairedAction)(nil),
	(*Paragraph)(nil),
	(*PatternActions)(nil),
	(*PatternDecl)(nil),
	(*PatternFlags)(nil),
	(*PatternLocals)(nil),
	(*PatternReturn)(nil),
	(*PatternRule)(nil),
	(*PatternRules)(nil),
	(*PatternType)(nil),
	(*PatternVariablesDecl)(nil),
	(*PatternVariablesTail)(nil),
	(*PluralKinds)(nil),
	(*PrimitiveType)(nil),
	(*PrimitiveValue)(nil),
	(*ProgramHook)(nil),
	(*Pronoun)(nil),
	(*Property)(nil),
	(*PropertyAspect)(nil),
	(*PropertyDecl)(nil),
	(*PropertyType)(nil),
	(*RecordList)(nil),
	(*RecordPlural)(nil),
	(*RecordSingular)(nil),
	(*RecordType)(nil),
	(*RecordsPossessProperties)(nil),
	(*RelationCardinality)(nil),
	(*RelativeToNoun)(nil),
	(*RenderTemplate)(nil),
	(*Send)(nil),
	(*ShuffleText)(nil),
	(*SingularKind)(nil),
	(*StoppingText)(nil),
	(*Story)(nil),
	(*Summary)(nil),
	(*Tail)(nil),
	(*TestName)(nil),
	(*TestOutput)(nil),
	(*TestRule)(nil),
	(*TestScene)(nil),
	(*TestStatement)(nil),
	(*TextList)(nil),
	(*Trait)(nil),
	(*TraitPhrase)(nil),
	(*VariableDecl)(nil),
	(*VariableType)(nil),
}
