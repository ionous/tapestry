// Code generated by "makeops"; edit at your own risk.
package story

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/grammar"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/jsn"
	"git.sr.ht/~ionous/iffy/rt"
)

// AbstractAction requires a user-specified string.
type AbstractAction struct {
	Str string
}

func (op *AbstractAction) String() string {
	return op.Str
}

const AbstractAction_Nothing = "$NOTHING"

func (*AbstractAction) Compose() composer.Spec {
	return composer.Spec{
		Name: AbstractAction_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			AbstractAction_Nothing,
		},
		Strings: []string{
			"nothing",
		},
	}
}

const AbstractAction_Type = "abstract_action"

func (op *AbstractAction) Marshal(n jsn.Marshaler) {
	AbstractAction_Marshal(n, op)
}

func AbstractAction_Optional_Marshal(n jsn.Marshaler, val *AbstractAction) {
	var zero AbstractAction
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		AbstractAction_Marshal(n, val)
	}
}

func AbstractAction_Marshal(n jsn.Marshaler, val *AbstractAction) {
	n.MarshalValue(AbstractAction_Type, jsn.MakeEnum(val, &val.Str))
}

type AbstractAction_Slice []AbstractAction

func (op *AbstractAction_Slice) GetType() string { return AbstractAction_Type }
func (op *AbstractAction_Slice) GetSize() int    { return len(*op) }
func (op *AbstractAction_Slice) SetSize(cnt int) { (*op) = make(AbstractAction_Slice, cnt) }

func AbstractAction_Repeats_Marshal(n jsn.Marshaler, vals *[]AbstractAction) {
	if n.MarshalBlock((*AbstractAction_Slice)(vals)) {
		for i := range *vals {
			AbstractAction_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// ActionContext
type ActionContext struct {
	At   reader.Position `if:"internal"`
	Kind SingularKind    `if:"label=_"`
}

func (*ActionContext) Compose() composer.Spec {
	return composer.Spec{
		Name: ActionContext_Type,
		Uses: composer.Type_Flow,
	}
}

const ActionContext_Type = "action_context"

const ActionContext_Field_Kind = "$KIND"

func (op *ActionContext) Marshal(n jsn.Marshaler) {
	ActionContext_Marshal(n, op)
}

type ActionContext_Slice []ActionContext

func (op *ActionContext_Slice) GetType() string { return ActionContext_Type }
func (op *ActionContext_Slice) GetSize() int    { return len(*op) }
func (op *ActionContext_Slice) SetSize(cnt int) { (*op) = make(ActionContext_Slice, cnt) }

func ActionContext_Repeats_Marshal(n jsn.Marshaler, vals *[]ActionContext) {
	if n.MarshalBlock((*ActionContext_Slice)(vals)) {
		for i := range *vals {
			ActionContext_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func ActionContext_Optional_Marshal(n jsn.Marshaler, pv **ActionContext) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ActionContext_Marshal(n, *pv)
	} else if !enc {
		var v ActionContext
		if ActionContext_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ActionContext_Marshal(n jsn.Marshaler, val *ActionContext) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(ActionContext_Type,
		ActionContext_Type)); okay {
		if n.MarshalKey("", ActionContext_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		n.EndBlock()
	}
	return
}

// ActionDecl
// User implements: StoryStatement.
type ActionDecl struct {
	At           reader.Position `if:"internal"`
	Event        EventName       `if:"label=_"`
	Action       ActionName      `if:"label=action"`
	ActionParams ActionParams    `if:"label=action_params"`
}

func (*ActionDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: ActionDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const ActionDecl_Type = "action_decl"

const ActionDecl_Field_Event = "$EVENT"
const ActionDecl_Field_Action = "$ACTION"
const ActionDecl_Field_ActionParams = "$ACTION_PARAMS"

func (op *ActionDecl) Marshal(n jsn.Marshaler) {
	ActionDecl_Marshal(n, op)
}

type ActionDecl_Slice []ActionDecl

func (op *ActionDecl_Slice) GetType() string { return ActionDecl_Type }
func (op *ActionDecl_Slice) GetSize() int    { return len(*op) }
func (op *ActionDecl_Slice) SetSize(cnt int) { (*op) = make(ActionDecl_Slice, cnt) }

func ActionDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]ActionDecl) {
	if n.MarshalBlock((*ActionDecl_Slice)(vals)) {
		for i := range *vals {
			ActionDecl_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func ActionDecl_Optional_Marshal(n jsn.Marshaler, pv **ActionDecl) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ActionDecl_Marshal(n, *pv)
	} else if !enc {
		var v ActionDecl
		if ActionDecl_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ActionDecl_Marshal(n jsn.Marshaler, val *ActionDecl) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(ActionDecl_Type,
		ActionDecl_Type)); okay {
		if n.MarshalKey("", ActionDecl_Field_Event) {
			EventName_Marshal(n, &val.Event)
		}
		if n.MarshalKey("action", ActionDecl_Field_Action) {
			ActionName_Marshal(n, &val.Action)
		}
		if n.MarshalKey("action_params", ActionDecl_Field_ActionParams) {
			ActionParams_Marshal(n, &val.ActionParams)
		}
		n.EndBlock()
	}
	return
}

// ActionName requires a user-specified string.
type ActionName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *ActionName) String() string {
	return op.Str
}

func (*ActionName) Compose() composer.Spec {
	return composer.Spec{
		Name:        ActionName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const ActionName_Type = "action_name"

func (op *ActionName) Marshal(n jsn.Marshaler) {
	ActionName_Marshal(n, op)
}

func ActionName_Optional_Marshal(n jsn.Marshaler, val *ActionName) {
	var zero ActionName
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		ActionName_Marshal(n, val)
	}
}

func ActionName_Marshal(n jsn.Marshaler, val *ActionName) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(ActionName_Type, &val.Str)
}

type ActionName_Slice []ActionName

func (op *ActionName_Slice) GetType() string { return ActionName_Type }
func (op *ActionName_Slice) GetSize() int    { return len(*op) }
func (op *ActionName_Slice) SetSize(cnt int) { (*op) = make(ActionName_Slice, cnt) }

func ActionName_Repeats_Marshal(n jsn.Marshaler, vals *[]ActionName) {
	if n.MarshalBlock((*ActionName_Slice)(vals)) {
		for i := range *vals {
			ActionName_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// ActionParams swaps between various options
type ActionParams struct {
	Opt interface{}
}

const ActionParams_Common_Opt = "$COMMON"
const ActionParams_Dual_Opt = "$DUAL"
const ActionParams_None_Opt = "$NONE"

func (*ActionParams) Compose() composer.Spec {
	return composer.Spec{
		Name: ActionParams_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			ActionParams_Common_Opt, ActionParams_Dual_Opt, ActionParams_None_Opt,
		},
		Swaps: []interface{}{
			(*CommonAction)(nil),
			(*PairedAction)(nil),
			(*AbstractAction)(nil),
		},
	}
}

const ActionParams_Type = "action_params"

func (op *ActionParams) GetType() string { return ActionParams_Type }

func (op *ActionParams) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *CommonAction:
		ret, okay = ActionParams_Common_Opt, true
	case *PairedAction:
		ret, okay = ActionParams_Dual_Opt, true
	case *AbstractAction:
		ret, okay = ActionParams_None_Opt, true
	}
	return
}

func (op *ActionParams) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case ActionParams_Common_Opt:
		opt := new(CommonAction)
		op.Opt, ret, okay = opt, opt, true
	case ActionParams_Dual_Opt:
		opt := new(PairedAction)
		op.Opt, ret, okay = opt, opt, true
	case ActionParams_None_Opt:
		opt := new(AbstractAction)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *ActionParams) Marshal(n jsn.Marshaler) {
	ActionParams_Marshal(n, op)
}
func ActionParams_Marshal(n jsn.Marshaler, val *ActionParams) {
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type ActionParams_Slice []ActionParams

func (op *ActionParams_Slice) GetType() string { return ActionParams_Type }
func (op *ActionParams_Slice) GetSize() int    { return len(*op) }
func (op *ActionParams_Slice) SetSize(cnt int) { (*op) = make(ActionParams_Slice, cnt) }

func ActionParams_Repeats_Marshal(n jsn.Marshaler, vals *[]ActionParams) {
	if n.MarshalBlock((*ActionParams_Slice)(vals)) {
		for i := range *vals {
			ActionParams_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// Ana requires a user-specified string.
type Ana struct {
	Str string
}

func (op *Ana) String() string {
	return op.Str
}

const Ana_A = "$A"
const Ana_An = "$AN"

func (*Ana) Compose() composer.Spec {
	return composer.Spec{
		Name: Ana_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			Ana_A, Ana_An,
		},
		Strings: []string{
			"a", "an",
		},
	}
}

const Ana_Type = "ana"

func (op *Ana) Marshal(n jsn.Marshaler) {
	Ana_Marshal(n, op)
}

func Ana_Optional_Marshal(n jsn.Marshaler, val *Ana) {
	var zero Ana
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		Ana_Marshal(n, val)
	}
}

func Ana_Marshal(n jsn.Marshaler, val *Ana) {
	n.MarshalValue(Ana_Type, jsn.MakeEnum(val, &val.Str))
}

type Ana_Slice []Ana

func (op *Ana_Slice) GetType() string { return Ana_Type }
func (op *Ana_Slice) GetSize() int    { return len(*op) }
func (op *Ana_Slice) SetSize(cnt int) { (*op) = make(Ana_Slice, cnt) }

func Ana_Repeats_Marshal(n jsn.Marshaler, vals *[]Ana) {
	if n.MarshalBlock((*Ana_Slice)(vals)) {
		for i := range *vals {
			Ana_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// AreAn requires a user-specified string.
type AreAn struct {
	Str string
}

func (op *AreAn) String() string {
	return op.Str
}

const AreAn_Are = "$ARE"
const AreAn_Area = "$AREA"
const AreAn_Arean = "$AREAN"
const AreAn_Is = "$IS"
const AreAn_Isa = "$ISA"
const AreAn_Isan = "$ISAN"

func (*AreAn) Compose() composer.Spec {
	return composer.Spec{
		Name: AreAn_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			AreAn_Are, AreAn_Area, AreAn_Arean, AreAn_Is, AreAn_Isa, AreAn_Isan,
		},
		Strings: []string{
			"are", "area", "arean", "is", "isa", "isan",
		},
	}
}

const AreAn_Type = "are_an"

func (op *AreAn) Marshal(n jsn.Marshaler) {
	AreAn_Marshal(n, op)
}

func AreAn_Optional_Marshal(n jsn.Marshaler, val *AreAn) {
	var zero AreAn
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		AreAn_Marshal(n, val)
	}
}

func AreAn_Marshal(n jsn.Marshaler, val *AreAn) {
	n.MarshalValue(AreAn_Type, jsn.MakeEnum(val, &val.Str))
}

type AreAn_Slice []AreAn

func (op *AreAn_Slice) GetType() string { return AreAn_Type }
func (op *AreAn_Slice) GetSize() int    { return len(*op) }
func (op *AreAn_Slice) SetSize(cnt int) { (*op) = make(AreAn_Slice, cnt) }

func AreAn_Repeats_Marshal(n jsn.Marshaler, vals *[]AreAn) {
	if n.MarshalBlock((*AreAn_Slice)(vals)) {
		for i := range *vals {
			AreAn_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// AreBeing requires a user-specified string.
type AreBeing struct {
	Str string
}

func (op *AreBeing) String() string {
	return op.Str
}

const AreBeing_Are = "$ARE"
const AreBeing_Is = "$IS"

func (*AreBeing) Compose() composer.Spec {
	return composer.Spec{
		Name: AreBeing_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			AreBeing_Are, AreBeing_Is,
		},
		Strings: []string{
			"are", "is",
		},
	}
}

const AreBeing_Type = "are_being"

func (op *AreBeing) Marshal(n jsn.Marshaler) {
	AreBeing_Marshal(n, op)
}

func AreBeing_Optional_Marshal(n jsn.Marshaler, val *AreBeing) {
	var zero AreBeing
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		AreBeing_Marshal(n, val)
	}
}

func AreBeing_Marshal(n jsn.Marshaler, val *AreBeing) {
	n.MarshalValue(AreBeing_Type, jsn.MakeEnum(val, &val.Str))
}

type AreBeing_Slice []AreBeing

func (op *AreBeing_Slice) GetType() string { return AreBeing_Type }
func (op *AreBeing_Slice) GetSize() int    { return len(*op) }
func (op *AreBeing_Slice) SetSize(cnt int) { (*op) = make(AreBeing_Slice, cnt) }

func AreBeing_Repeats_Marshal(n jsn.Marshaler, vals *[]AreBeing) {
	if n.MarshalBlock((*AreBeing_Slice)(vals)) {
		for i := range *vals {
			AreBeing_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// AreEither requires a user-specified string.
type AreEither struct {
	Str string
}

func (op *AreEither) String() string {
	return op.Str
}

const AreEither_Canbe = "$CANBE"
const AreEither_Either = "$EITHER"

func (*AreEither) Compose() composer.Spec {
	return composer.Spec{
		Name: AreEither_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			AreEither_Canbe, AreEither_Either,
		},
		Strings: []string{
			"canbe", "either",
		},
	}
}

const AreEither_Type = "are_either"

func (op *AreEither) Marshal(n jsn.Marshaler) {
	AreEither_Marshal(n, op)
}

func AreEither_Optional_Marshal(n jsn.Marshaler, val *AreEither) {
	var zero AreEither
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		AreEither_Marshal(n, val)
	}
}

func AreEither_Marshal(n jsn.Marshaler, val *AreEither) {
	n.MarshalValue(AreEither_Type, jsn.MakeEnum(val, &val.Str))
}

type AreEither_Slice []AreEither

func (op *AreEither_Slice) GetType() string { return AreEither_Type }
func (op *AreEither_Slice) GetSize() int    { return len(*op) }
func (op *AreEither_Slice) SetSize(cnt int) { (*op) = make(AreEither_Slice, cnt) }

func AreEither_Repeats_Marshal(n jsn.Marshaler, vals *[]AreEither) {
	if n.MarshalBlock((*AreEither_Slice)(vals)) {
		for i := range *vals {
			AreEither_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// Argument
type Argument struct {
	At   reader.Position `if:"internal"`
	Name string          `if:"label=_,type=text"`
	From rt.Assignment   `if:"label=from"`
}

func (*Argument) Compose() composer.Spec {
	return composer.Spec{
		Name: Argument_Type,
		Uses: composer.Type_Flow,
		Lede: "arg",
	}
}

const Argument_Type = "argument"

const Argument_Field_Name = "$NAME"
const Argument_Field_From = "$FROM"

func (op *Argument) Marshal(n jsn.Marshaler) {
	Argument_Marshal(n, op)
}

type Argument_Slice []Argument

func (op *Argument_Slice) GetType() string { return Argument_Type }
func (op *Argument_Slice) GetSize() int    { return len(*op) }
func (op *Argument_Slice) SetSize(cnt int) { (*op) = make(Argument_Slice, cnt) }

func Argument_Repeats_Marshal(n jsn.Marshaler, vals *[]Argument) {
	if n.MarshalBlock((*Argument_Slice)(vals)) {
		for i := range *vals {
			Argument_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Argument_Optional_Marshal(n jsn.Marshaler, pv **Argument) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Argument_Marshal(n, *pv)
	} else if !enc {
		var v Argument
		if Argument_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Argument_Marshal(n jsn.Marshaler, val *Argument) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow("arg",
		Argument_Type)); okay {
		if n.MarshalKey("", Argument_Field_Name) {
			value.Text_Unboxed_Marshal(n, &val.Name)
		}
		if n.MarshalKey("from", Argument_Field_From) {
			rt.Assignment_Marshal(n, &val.From)
		}
		n.EndBlock()
	}
	return
}

// Arguments
type Arguments struct {
	At   reader.Position `if:"internal"`
	Args []Argument      `if:"label=_"`
}

func (*Arguments) Compose() composer.Spec {
	return composer.Spec{
		Name: Arguments_Type,
		Uses: composer.Type_Flow,
		Lede: "args",
	}
}

const Arguments_Type = "arguments"

const Arguments_Field_Args = "$ARGS"

func (op *Arguments) Marshal(n jsn.Marshaler) {
	Arguments_Marshal(n, op)
}

type Arguments_Slice []Arguments

func (op *Arguments_Slice) GetType() string { return Arguments_Type }
func (op *Arguments_Slice) GetSize() int    { return len(*op) }
func (op *Arguments_Slice) SetSize(cnt int) { (*op) = make(Arguments_Slice, cnt) }

func Arguments_Repeats_Marshal(n jsn.Marshaler, vals *[]Arguments) {
	if n.MarshalBlock((*Arguments_Slice)(vals)) {
		for i := range *vals {
			Arguments_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Arguments_Optional_Marshal(n jsn.Marshaler, pv **Arguments) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Arguments_Marshal(n, *pv)
	} else if !enc {
		var v Arguments
		if Arguments_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Arguments_Marshal(n jsn.Marshaler, val *Arguments) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow("args",
		Arguments_Type)); okay {
		if n.MarshalKey("", Arguments_Field_Args) {
			Argument_Repeats_Marshal(n, &val.Args)
		}
		n.EndBlock()
	}
	return
}

// Aspect requires a user-specified string.
type Aspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Aspect) String() string {
	return op.Str
}

func (*Aspect) Compose() composer.Spec {
	return composer.Spec{
		Name:        Aspect_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Aspect_Type = "aspect"

func (op *Aspect) Marshal(n jsn.Marshaler) {
	Aspect_Marshal(n, op)
}

func Aspect_Optional_Marshal(n jsn.Marshaler, val *Aspect) {
	var zero Aspect
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		Aspect_Marshal(n, val)
	}
}

func Aspect_Marshal(n jsn.Marshaler, val *Aspect) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(Aspect_Type, &val.Str)
}

type Aspect_Slice []Aspect

func (op *Aspect_Slice) GetType() string { return Aspect_Type }
func (op *Aspect_Slice) GetSize() int    { return len(*op) }
func (op *Aspect_Slice) SetSize(cnt int) { (*op) = make(Aspect_Slice, cnt) }

func Aspect_Repeats_Marshal(n jsn.Marshaler, vals *[]Aspect) {
	if n.MarshalBlock((*Aspect_Slice)(vals)) {
		for i := range *vals {
			Aspect_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// AspectTraits
// User implements: StoryStatement.
type AspectTraits struct {
	Aspect      Aspect      `if:"label=_"`
	TraitPhrase TraitPhrase `if:"label=trait_phrase"`
}

func (*AspectTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: AspectTraits_Type,
		Uses: composer.Type_Flow,
	}
}

const AspectTraits_Type = "aspect_traits"

const AspectTraits_Field_Aspect = "$ASPECT"
const AspectTraits_Field_TraitPhrase = "$TRAIT_PHRASE"

func (op *AspectTraits) Marshal(n jsn.Marshaler) {
	AspectTraits_Marshal(n, op)
}

type AspectTraits_Slice []AspectTraits

func (op *AspectTraits_Slice) GetType() string { return AspectTraits_Type }
func (op *AspectTraits_Slice) GetSize() int    { return len(*op) }
func (op *AspectTraits_Slice) SetSize(cnt int) { (*op) = make(AspectTraits_Slice, cnt) }

func AspectTraits_Repeats_Marshal(n jsn.Marshaler, vals *[]AspectTraits) {
	if n.MarshalBlock((*AspectTraits_Slice)(vals)) {
		for i := range *vals {
			AspectTraits_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func AspectTraits_Optional_Marshal(n jsn.Marshaler, pv **AspectTraits) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		AspectTraits_Marshal(n, *pv)
	} else if !enc {
		var v AspectTraits
		if AspectTraits_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func AspectTraits_Marshal(n jsn.Marshaler, val *AspectTraits) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(AspectTraits_Type,
		AspectTraits_Type)); okay {
		if n.MarshalKey("", AspectTraits_Field_Aspect) {
			Aspect_Marshal(n, &val.Aspect)
		}
		if n.MarshalKey("trait_phrase", AspectTraits_Field_TraitPhrase) {
			TraitPhrase_Marshal(n, &val.TraitPhrase)
		}
		n.EndBlock()
	}
	return
}

// BoxedNumber
type BoxedNumber struct {
	Number float64 `if:"label=_,type=number"`
}

func (*BoxedNumber) Compose() composer.Spec {
	return composer.Spec{
		Name: BoxedNumber_Type,
		Uses: composer.Type_Flow,
	}
}

const BoxedNumber_Type = "boxed_number"

const BoxedNumber_Field_Number = "$NUMBER"

func (op *BoxedNumber) Marshal(n jsn.Marshaler) {
	BoxedNumber_Marshal(n, op)
}

type BoxedNumber_Slice []BoxedNumber

func (op *BoxedNumber_Slice) GetType() string { return BoxedNumber_Type }
func (op *BoxedNumber_Slice) GetSize() int    { return len(*op) }
func (op *BoxedNumber_Slice) SetSize(cnt int) { (*op) = make(BoxedNumber_Slice, cnt) }

func BoxedNumber_Repeats_Marshal(n jsn.Marshaler, vals *[]BoxedNumber) {
	if n.MarshalBlock((*BoxedNumber_Slice)(vals)) {
		for i := range *vals {
			BoxedNumber_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func BoxedNumber_Optional_Marshal(n jsn.Marshaler, pv **BoxedNumber) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		BoxedNumber_Marshal(n, *pv)
	} else if !enc {
		var v BoxedNumber
		if BoxedNumber_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func BoxedNumber_Marshal(n jsn.Marshaler, val *BoxedNumber) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(BoxedNumber_Type,
		BoxedNumber_Type)); okay {
		if n.MarshalKey("", BoxedNumber_Field_Number) {
			value.Number_Unboxed_Marshal(n, &val.Number)
		}
		n.EndBlock()
	}
	return
}

// BoxedText
type BoxedText struct {
	Text string `if:"label=_,type=text"`
}

func (*BoxedText) Compose() composer.Spec {
	return composer.Spec{
		Name: BoxedText_Type,
		Uses: composer.Type_Flow,
	}
}

const BoxedText_Type = "boxed_text"

const BoxedText_Field_Text = "$TEXT"

func (op *BoxedText) Marshal(n jsn.Marshaler) {
	BoxedText_Marshal(n, op)
}

type BoxedText_Slice []BoxedText

func (op *BoxedText_Slice) GetType() string { return BoxedText_Type }
func (op *BoxedText_Slice) GetSize() int    { return len(*op) }
func (op *BoxedText_Slice) SetSize(cnt int) { (*op) = make(BoxedText_Slice, cnt) }

func BoxedText_Repeats_Marshal(n jsn.Marshaler, vals *[]BoxedText) {
	if n.MarshalBlock((*BoxedText_Slice)(vals)) {
		for i := range *vals {
			BoxedText_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func BoxedText_Optional_Marshal(n jsn.Marshaler, pv **BoxedText) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		BoxedText_Marshal(n, *pv)
	} else if !enc {
		var v BoxedText
		if BoxedText_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func BoxedText_Marshal(n jsn.Marshaler, val *BoxedText) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(BoxedText_Type,
		BoxedText_Type)); okay {
		if n.MarshalKey("", BoxedText_Field_Text) {
			value.Text_Unboxed_Marshal(n, &val.Text)
		}
		n.EndBlock()
	}
	return
}

// Certainties
// User implements: StoryStatement.
type Certainties struct {
	PluralKinds PluralKinds `if:"label=_"`
	AreBeing    AreBeing    `if:"label=are_being"`
	Certainty   Certainty   `if:"label=certainty"`
	Trait       Trait       `if:"label=trait"`
}

func (*Certainties) Compose() composer.Spec {
	return composer.Spec{
		Name: Certainties_Type,
		Uses: composer.Type_Flow,
	}
}

const Certainties_Type = "certainties"

const Certainties_Field_PluralKinds = "$PLURAL_KINDS"
const Certainties_Field_AreBeing = "$ARE_BEING"
const Certainties_Field_Certainty = "$CERTAINTY"
const Certainties_Field_Trait = "$TRAIT"

func (op *Certainties) Marshal(n jsn.Marshaler) {
	Certainties_Marshal(n, op)
}

type Certainties_Slice []Certainties

func (op *Certainties_Slice) GetType() string { return Certainties_Type }
func (op *Certainties_Slice) GetSize() int    { return len(*op) }
func (op *Certainties_Slice) SetSize(cnt int) { (*op) = make(Certainties_Slice, cnt) }

func Certainties_Repeats_Marshal(n jsn.Marshaler, vals *[]Certainties) {
	if n.MarshalBlock((*Certainties_Slice)(vals)) {
		for i := range *vals {
			Certainties_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Certainties_Optional_Marshal(n jsn.Marshaler, pv **Certainties) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Certainties_Marshal(n, *pv)
	} else if !enc {
		var v Certainties
		if Certainties_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Certainties_Marshal(n jsn.Marshaler, val *Certainties) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Certainties_Type,
		Certainties_Type)); okay {
		if n.MarshalKey("", Certainties_Field_PluralKinds) {
			PluralKinds_Marshal(n, &val.PluralKinds)
		}
		if n.MarshalKey("are_being", Certainties_Field_AreBeing) {
			AreBeing_Marshal(n, &val.AreBeing)
		}
		if n.MarshalKey("certainty", Certainties_Field_Certainty) {
			Certainty_Marshal(n, &val.Certainty)
		}
		if n.MarshalKey("trait", Certainties_Field_Trait) {
			Trait_Marshal(n, &val.Trait)
		}
		n.EndBlock()
	}
	return
}

// Certainty requires a user-specified string.
type Certainty struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Certainty) String() string {
	return op.Str
}

const Certainty_Usually = "$USUALLY"
const Certainty_Always = "$ALWAYS"
const Certainty_Seldom = "$SELDOM"
const Certainty_Never = "$NEVER"

func (*Certainty) Compose() composer.Spec {
	return composer.Spec{
		Name: Certainty_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			Certainty_Usually, Certainty_Always, Certainty_Seldom, Certainty_Never,
		},
		Strings: []string{
			"usually", "always", "seldom", "never",
		},
	}
}

const Certainty_Type = "certainty"

func (op *Certainty) Marshal(n jsn.Marshaler) {
	Certainty_Marshal(n, op)
}

func Certainty_Optional_Marshal(n jsn.Marshaler, val *Certainty) {
	var zero Certainty
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		Certainty_Marshal(n, val)
	}
}

func Certainty_Marshal(n jsn.Marshaler, val *Certainty) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(Certainty_Type, jsn.MakeEnum(val, &val.Str))
}

type Certainty_Slice []Certainty

func (op *Certainty_Slice) GetType() string { return Certainty_Type }
func (op *Certainty_Slice) GetSize() int    { return len(*op) }
func (op *Certainty_Slice) SetSize(cnt int) { (*op) = make(Certainty_Slice, cnt) }

func Certainty_Repeats_Marshal(n jsn.Marshaler, vals *[]Certainty) {
	if n.MarshalBlock((*Certainty_Slice)(vals)) {
		for i := range *vals {
			Certainty_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// Comment Information about the story for you and other authors.
// User implements: StoryStatement, Execute.
type Comment struct {
	Lines value.Lines `if:"label=_"`
}

func (*Comment) Compose() composer.Spec {
	return composer.Spec{
		Name: Comment_Type,
		Uses: composer.Type_Flow,
	}
}

const Comment_Type = "comment"

const Comment_Field_Lines = "$LINES"

func (op *Comment) Marshal(n jsn.Marshaler) {
	Comment_Marshal(n, op)
}

type Comment_Slice []Comment

func (op *Comment_Slice) GetType() string { return Comment_Type }
func (op *Comment_Slice) GetSize() int    { return len(*op) }
func (op *Comment_Slice) SetSize(cnt int) { (*op) = make(Comment_Slice, cnt) }

func Comment_Repeats_Marshal(n jsn.Marshaler, vals *[]Comment) {
	if n.MarshalBlock((*Comment_Slice)(vals)) {
		for i := range *vals {
			Comment_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Comment_Optional_Marshal(n jsn.Marshaler, pv **Comment) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Comment_Marshal(n, *pv)
	} else if !enc {
		var v Comment
		if Comment_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Comment_Marshal(n jsn.Marshaler, val *Comment) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Comment_Type,
		Comment_Type)); okay {
		if n.MarshalKey("", Comment_Field_Lines) {
			value.Lines_Marshal(n, &val.Lines)
		}
		n.EndBlock()
	}
	return
}

// CommonAction
type CommonAction struct {
	At            reader.Position `if:"internal"`
	Kind          SingularKind    `if:"label=_"`
	ActionContext *ActionContext  `if:"label=action_context,optional"`
}

func (*CommonAction) Compose() composer.Spec {
	return composer.Spec{
		Name: CommonAction_Type,
		Uses: composer.Type_Flow,
	}
}

const CommonAction_Type = "common_action"

const CommonAction_Field_Kind = "$KIND"
const CommonAction_Field_ActionContext = "$ACTION_CONTEXT"

func (op *CommonAction) Marshal(n jsn.Marshaler) {
	CommonAction_Marshal(n, op)
}

type CommonAction_Slice []CommonAction

func (op *CommonAction_Slice) GetType() string { return CommonAction_Type }
func (op *CommonAction_Slice) GetSize() int    { return len(*op) }
func (op *CommonAction_Slice) SetSize(cnt int) { (*op) = make(CommonAction_Slice, cnt) }

func CommonAction_Repeats_Marshal(n jsn.Marshaler, vals *[]CommonAction) {
	if n.MarshalBlock((*CommonAction_Slice)(vals)) {
		for i := range *vals {
			CommonAction_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func CommonAction_Optional_Marshal(n jsn.Marshaler, pv **CommonAction) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		CommonAction_Marshal(n, *pv)
	} else if !enc {
		var v CommonAction
		if CommonAction_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func CommonAction_Marshal(n jsn.Marshaler, val *CommonAction) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(CommonAction_Type,
		CommonAction_Type)); okay {
		if n.MarshalKey("", CommonAction_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		if n.MarshalKey("action_context", CommonAction_Field_ActionContext) {
			ActionContext_Optional_Marshal(n, &val.ActionContext)
		}
		n.EndBlock()
	}
	return
}

// CountOf A guard which returns true based on a counter.
// User implements: BoolEval.
type CountOf struct {
	At      reader.Position `if:"internal"`
	Trigger core.Trigger    `if:"label=_"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CountOf) Compose() composer.Spec {
	return composer.Spec{
		Name: CountOf_Type,
		Uses: composer.Type_Flow,
	}
}

const CountOf_Type = "count_of"

const CountOf_Field_Trigger = "$TRIGGER"
const CountOf_Field_Num = "$NUM"

func (op *CountOf) Marshal(n jsn.Marshaler) {
	CountOf_Marshal(n, op)
}

type CountOf_Slice []CountOf

func (op *CountOf_Slice) GetType() string { return CountOf_Type }
func (op *CountOf_Slice) GetSize() int    { return len(*op) }
func (op *CountOf_Slice) SetSize(cnt int) { (*op) = make(CountOf_Slice, cnt) }

func CountOf_Repeats_Marshal(n jsn.Marshaler, vals *[]CountOf) {
	if n.MarshalBlock((*CountOf_Slice)(vals)) {
		for i := range *vals {
			CountOf_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func CountOf_Optional_Marshal(n jsn.Marshaler, pv **CountOf) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		CountOf_Marshal(n, *pv)
	} else if !enc {
		var v CountOf
		if CountOf_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func CountOf_Marshal(n jsn.Marshaler, val *CountOf) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(CountOf_Type,
		CountOf_Type)); okay {
		if n.MarshalKey("", CountOf_Field_Trigger) {
			core.Trigger_Marshal(n, &val.Trigger)
		}
		if n.MarshalKey("num", CountOf_Field_Num) {
			rt.NumberEval_Marshal(n, &val.Num)
		}
		n.EndBlock()
	}
	return
}

// CycleText
// User implements: TextEval.
type CycleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*CycleText) Compose() composer.Spec {
	return composer.Spec{
		Name: CycleText_Type,
		Uses: composer.Type_Flow,
	}
}

const CycleText_Type = "cycle_text"

const CycleText_Field_Parts = "$PARTS"

func (op *CycleText) Marshal(n jsn.Marshaler) {
	CycleText_Marshal(n, op)
}

type CycleText_Slice []CycleText

func (op *CycleText_Slice) GetType() string { return CycleText_Type }
func (op *CycleText_Slice) GetSize() int    { return len(*op) }
func (op *CycleText_Slice) SetSize(cnt int) { (*op) = make(CycleText_Slice, cnt) }

func CycleText_Repeats_Marshal(n jsn.Marshaler, vals *[]CycleText) {
	if n.MarshalBlock((*CycleText_Slice)(vals)) {
		for i := range *vals {
			CycleText_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func CycleText_Optional_Marshal(n jsn.Marshaler, pv **CycleText) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		CycleText_Marshal(n, *pv)
	} else if !enc {
		var v CycleText
		if CycleText_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func CycleText_Marshal(n jsn.Marshaler, val *CycleText) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(CycleText_Type,
		CycleText_Type)); okay {
		if n.MarshalKey("", CycleText_Field_Parts) {
			rt.TextEval_Repeats_Marshal(n, &val.Parts)
		}
		n.EndBlock()
	}
	return
}

// Determine
// User implements: Execute, BoolEval, NumberEval, TextEval, RecordEval, NumListEval, TextListEval, RecordListEval.
type Determine struct {
	Name      value.PatternName `if:"label=_"`
	Arguments *Arguments        `if:"label=arguments,optional"`
}

func (*Determine) Compose() composer.Spec {
	return composer.Spec{
		Name: Determine_Type,
		Uses: composer.Type_Flow,
	}
}

const Determine_Type = "determine"

const Determine_Field_Name = "$NAME"
const Determine_Field_Arguments = "$ARGUMENTS"

func (op *Determine) Marshal(n jsn.Marshaler) {
	Determine_Marshal(n, op)
}

type Determine_Slice []Determine

func (op *Determine_Slice) GetType() string { return Determine_Type }
func (op *Determine_Slice) GetSize() int    { return len(*op) }
func (op *Determine_Slice) SetSize(cnt int) { (*op) = make(Determine_Slice, cnt) }

func Determine_Repeats_Marshal(n jsn.Marshaler, vals *[]Determine) {
	if n.MarshalBlock((*Determine_Slice)(vals)) {
		for i := range *vals {
			Determine_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Determine_Optional_Marshal(n jsn.Marshaler, pv **Determine) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Determine_Marshal(n, *pv)
	} else if !enc {
		var v Determine
		if Determine_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Determine_Marshal(n jsn.Marshaler, val *Determine) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Determine_Type,
		Determine_Type)); okay {
		if n.MarshalKey("", Determine_Field_Name) {
			value.PatternName_Marshal(n, &val.Name)
		}
		if n.MarshalKey("arguments", Determine_Field_Arguments) {
			Arguments_Optional_Marshal(n, &val.Arguments)
		}
		n.EndBlock()
	}
	return
}

// Determiner requires a user-specified string.
type Determiner struct {
	Str string
}

func (op *Determiner) String() string {
	return op.Str
}

const Determiner_A = "$A"
const Determiner_An = "$AN"
const Determiner_The = "$THE"
const Determiner_Our = "$OUR"

func (*Determiner) Compose() composer.Spec {
	return composer.Spec{
		Name:        Determiner_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			Determiner_A, Determiner_An, Determiner_The, Determiner_Our,
		},
		Strings: []string{
			"a", "an", "the", "our",
		},
	}
}

const Determiner_Type = "determiner"

func (op *Determiner) Marshal(n jsn.Marshaler) {
	Determiner_Marshal(n, op)
}

func Determiner_Optional_Marshal(n jsn.Marshaler, val *Determiner) {
	var zero Determiner
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		Determiner_Marshal(n, val)
	}
}

func Determiner_Marshal(n jsn.Marshaler, val *Determiner) {
	n.MarshalValue(Determiner_Type, jsn.MakeEnum(val, &val.Str))
}

type Determiner_Slice []Determiner

func (op *Determiner_Slice) GetType() string { return Determiner_Type }
func (op *Determiner_Slice) GetSize() int    { return len(*op) }
func (op *Determiner_Slice) SetSize(cnt int) { (*op) = make(Determiner_Slice, cnt) }

func Determiner_Repeats_Marshal(n jsn.Marshaler, vals *[]Determiner) {
	if n.MarshalBlock((*Determiner_Slice)(vals)) {
		for i := range *vals {
			Determiner_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// EventBlock Listeners let objects in the game world react to changes before, during, or after they happen.
// User implements: StoryStatement.
type EventBlock struct {
	At       reader.Position `if:"internal"`
	Target   EventTarget     `if:"label=_"`
	Handlers []EventHandler  `if:"label=handlers"`
}

func (*EventBlock) Compose() composer.Spec {
	return composer.Spec{
		Name: EventBlock_Type,
		Uses: composer.Type_Flow,
	}
}

const EventBlock_Type = "event_block"

const EventBlock_Field_Target = "$TARGET"
const EventBlock_Field_Handlers = "$HANDLERS"

func (op *EventBlock) Marshal(n jsn.Marshaler) {
	EventBlock_Marshal(n, op)
}

type EventBlock_Slice []EventBlock

func (op *EventBlock_Slice) GetType() string { return EventBlock_Type }
func (op *EventBlock_Slice) GetSize() int    { return len(*op) }
func (op *EventBlock_Slice) SetSize(cnt int) { (*op) = make(EventBlock_Slice, cnt) }

func EventBlock_Repeats_Marshal(n jsn.Marshaler, vals *[]EventBlock) {
	if n.MarshalBlock((*EventBlock_Slice)(vals)) {
		for i := range *vals {
			EventBlock_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func EventBlock_Optional_Marshal(n jsn.Marshaler, pv **EventBlock) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		EventBlock_Marshal(n, *pv)
	} else if !enc {
		var v EventBlock
		if EventBlock_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func EventBlock_Marshal(n jsn.Marshaler, val *EventBlock) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(EventBlock_Type,
		EventBlock_Type)); okay {
		if n.MarshalKey("", EventBlock_Field_Target) {
			EventTarget_Marshal(n, &val.Target)
		}
		if n.MarshalKey("handlers", EventBlock_Field_Handlers) {
			EventHandler_Repeats_Marshal(n, &val.Handlers)
		}
		n.EndBlock()
	}
	return
}

// EventHandler
type EventHandler struct {
	EventPhase   EventPhase     `if:"label=_"`
	Event        EventName      `if:"label=event"`
	Locals       *PatternLocals `if:"label=locals,optional"`
	PatternRules PatternRules   `if:"label=pattern_rules"`
}

func (*EventHandler) Compose() composer.Spec {
	return composer.Spec{
		Name: EventHandler_Type,
		Uses: composer.Type_Flow,
	}
}

const EventHandler_Type = "event_handler"

const EventHandler_Field_EventPhase = "$EVENT_PHASE"
const EventHandler_Field_Event = "$EVENT"
const EventHandler_Field_Locals = "$LOCALS"
const EventHandler_Field_PatternRules = "$PATTERN_RULES"

func (op *EventHandler) Marshal(n jsn.Marshaler) {
	EventHandler_Marshal(n, op)
}

type EventHandler_Slice []EventHandler

func (op *EventHandler_Slice) GetType() string { return EventHandler_Type }
func (op *EventHandler_Slice) GetSize() int    { return len(*op) }
func (op *EventHandler_Slice) SetSize(cnt int) { (*op) = make(EventHandler_Slice, cnt) }

func EventHandler_Repeats_Marshal(n jsn.Marshaler, vals *[]EventHandler) {
	if n.MarshalBlock((*EventHandler_Slice)(vals)) {
		for i := range *vals {
			EventHandler_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func EventHandler_Optional_Marshal(n jsn.Marshaler, pv **EventHandler) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		EventHandler_Marshal(n, *pv)
	} else if !enc {
		var v EventHandler
		if EventHandler_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func EventHandler_Marshal(n jsn.Marshaler, val *EventHandler) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(EventHandler_Type,
		EventHandler_Type)); okay {
		if n.MarshalKey("", EventHandler_Field_EventPhase) {
			EventPhase_Marshal(n, &val.EventPhase)
		}
		if n.MarshalKey("event", EventHandler_Field_Event) {
			EventName_Marshal(n, &val.Event)
		}
		if n.MarshalKey("locals", EventHandler_Field_Locals) {
			PatternLocals_Optional_Marshal(n, &val.Locals)
		}
		if n.MarshalKey("pattern_rules", EventHandler_Field_PatternRules) {
			PatternRules_Marshal(n, &val.PatternRules)
		}
		n.EndBlock()
	}
	return
}

// EventName requires a user-specified string.
type EventName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *EventName) String() string {
	return op.Str
}

func (*EventName) Compose() composer.Spec {
	return composer.Spec{
		Name:        EventName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const EventName_Type = "event_name"

func (op *EventName) Marshal(n jsn.Marshaler) {
	EventName_Marshal(n, op)
}

func EventName_Optional_Marshal(n jsn.Marshaler, val *EventName) {
	var zero EventName
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		EventName_Marshal(n, val)
	}
}

func EventName_Marshal(n jsn.Marshaler, val *EventName) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(EventName_Type, &val.Str)
}

type EventName_Slice []EventName

func (op *EventName_Slice) GetType() string { return EventName_Type }
func (op *EventName_Slice) GetSize() int    { return len(*op) }
func (op *EventName_Slice) SetSize(cnt int) { (*op) = make(EventName_Slice, cnt) }

func EventName_Repeats_Marshal(n jsn.Marshaler, vals *[]EventName) {
	if n.MarshalBlock((*EventName_Slice)(vals)) {
		for i := range *vals {
			EventName_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// EventPhase requires a user-specified string.
type EventPhase struct {
	Str string
}

func (op *EventPhase) String() string {
	return op.Str
}

const EventPhase_Before = "$BEFORE"
const EventPhase_While = "$WHILE"
const EventPhase_After = "$AFTER"

func (*EventPhase) Compose() composer.Spec {
	return composer.Spec{
		Name: EventPhase_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			EventPhase_Before, EventPhase_While, EventPhase_After,
		},
		Strings: []string{
			"before", "while", "after",
		},
	}
}

const EventPhase_Type = "event_phase"

func (op *EventPhase) Marshal(n jsn.Marshaler) {
	EventPhase_Marshal(n, op)
}

func EventPhase_Optional_Marshal(n jsn.Marshaler, val *EventPhase) {
	var zero EventPhase
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		EventPhase_Marshal(n, val)
	}
}

func EventPhase_Marshal(n jsn.Marshaler, val *EventPhase) {
	n.MarshalValue(EventPhase_Type, jsn.MakeEnum(val, &val.Str))
}

type EventPhase_Slice []EventPhase

func (op *EventPhase_Slice) GetType() string { return EventPhase_Type }
func (op *EventPhase_Slice) GetSize() int    { return len(*op) }
func (op *EventPhase_Slice) SetSize(cnt int) { (*op) = make(EventPhase_Slice, cnt) }

func EventPhase_Repeats_Marshal(n jsn.Marshaler, vals *[]EventPhase) {
	if n.MarshalBlock((*EventPhase_Slice)(vals)) {
		for i := range *vals {
			EventPhase_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// EventTarget swaps between various options
type EventTarget struct {
	Opt interface{}
}

const EventTarget_Kinds_Opt = "$KINDS"
const EventTarget_NamedNoun_Opt = "$NAMED_NOUN"

func (*EventTarget) Compose() composer.Spec {
	return composer.Spec{
		Name: EventTarget_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			EventTarget_Kinds_Opt, EventTarget_NamedNoun_Opt,
		},
		Swaps: []interface{}{
			(*PluralKinds)(nil),
			(*NamedNoun)(nil),
		},
	}
}

const EventTarget_Type = "event_target"

func (op *EventTarget) GetType() string { return EventTarget_Type }

func (op *EventTarget) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PluralKinds:
		ret, okay = EventTarget_Kinds_Opt, true
	case *NamedNoun:
		ret, okay = EventTarget_NamedNoun_Opt, true
	}
	return
}

func (op *EventTarget) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case EventTarget_Kinds_Opt:
		opt := new(PluralKinds)
		op.Opt, ret, okay = opt, opt, true
	case EventTarget_NamedNoun_Opt:
		opt := new(NamedNoun)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *EventTarget) Marshal(n jsn.Marshaler) {
	EventTarget_Marshal(n, op)
}
func EventTarget_Marshal(n jsn.Marshaler, val *EventTarget) {
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type EventTarget_Slice []EventTarget

func (op *EventTarget_Slice) GetType() string { return EventTarget_Type }
func (op *EventTarget_Slice) GetSize() int    { return len(*op) }
func (op *EventTarget_Slice) SetSize(cnt int) { (*op) = make(EventTarget_Slice, cnt) }

func EventTarget_Repeats_Marshal(n jsn.Marshaler, vals *[]EventTarget) {
	if n.MarshalBlock((*EventTarget_Slice)(vals)) {
		for i := range *vals {
			EventTarget_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// ExtType swaps between various options
type ExtType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ExtType_Numbers_Opt = "$NUMBERS"
const ExtType_TextList_Opt = "$TEXT_LIST"
const ExtType_Record_Opt = "$RECORD"
const ExtType_Records_Opt = "$RECORDS"

func (*ExtType) Compose() composer.Spec {
	return composer.Spec{
		Name: ExtType_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			ExtType_Numbers_Opt, ExtType_TextList_Opt, ExtType_Record_Opt, ExtType_Records_Opt,
		},
		Swaps: []interface{}{
			(*NumberList)(nil),
			(*TextList)(nil),
			(*RecordType)(nil),
			(*RecordList)(nil),
		},
	}
}

const ExtType_Type = "ext_type"

func (op *ExtType) GetType() string { return ExtType_Type }

func (op *ExtType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *NumberList:
		ret, okay = ExtType_Numbers_Opt, true
	case *TextList:
		ret, okay = ExtType_TextList_Opt, true
	case *RecordType:
		ret, okay = ExtType_Record_Opt, true
	case *RecordList:
		ret, okay = ExtType_Records_Opt, true
	}
	return
}

func (op *ExtType) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case ExtType_Numbers_Opt:
		opt := new(NumberList)
		op.Opt, ret, okay = opt, opt, true
	case ExtType_TextList_Opt:
		opt := new(TextList)
		op.Opt, ret, okay = opt, opt, true
	case ExtType_Record_Opt:
		opt := new(RecordType)
		op.Opt, ret, okay = opt, opt, true
	case ExtType_Records_Opt:
		opt := new(RecordList)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *ExtType) Marshal(n jsn.Marshaler) {
	ExtType_Marshal(n, op)
}
func ExtType_Marshal(n jsn.Marshaler, val *ExtType) {
	n.SetCursor(val.At.Offset)
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type ExtType_Slice []ExtType

func (op *ExtType_Slice) GetType() string { return ExtType_Type }
func (op *ExtType_Slice) GetSize() int    { return len(*op) }
func (op *ExtType_Slice) SetSize(cnt int) { (*op) = make(ExtType_Slice, cnt) }

func ExtType_Repeats_Marshal(n jsn.Marshaler, vals *[]ExtType) {
	if n.MarshalBlock((*ExtType_Slice)(vals)) {
		for i := range *vals {
			ExtType_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// GrammarDecl
type GrammarDecl struct {
	Grammar grammar.GrammarMaker `if:"label=_"`
}

func (*GrammarDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: GrammarDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const GrammarDecl_Type = "grammar_decl"

const GrammarDecl_Field_Grammar = "$GRAMMAR"

func (op *GrammarDecl) Marshal(n jsn.Marshaler) {
	GrammarDecl_Marshal(n, op)
}

type GrammarDecl_Slice []GrammarDecl

func (op *GrammarDecl_Slice) GetType() string { return GrammarDecl_Type }
func (op *GrammarDecl_Slice) GetSize() int    { return len(*op) }
func (op *GrammarDecl_Slice) SetSize(cnt int) { (*op) = make(GrammarDecl_Slice, cnt) }

func GrammarDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]GrammarDecl) {
	if n.MarshalBlock((*GrammarDecl_Slice)(vals)) {
		for i := range *vals {
			GrammarDecl_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func GrammarDecl_Optional_Marshal(n jsn.Marshaler, pv **GrammarDecl) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		GrammarDecl_Marshal(n, *pv)
	} else if !enc {
		var v GrammarDecl
		if GrammarDecl_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func GrammarDecl_Marshal(n jsn.Marshaler, val *GrammarDecl) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(GrammarDecl_Type,
		GrammarDecl_Type)); okay {
		if n.MarshalKey("", GrammarDecl_Field_Grammar) {
			grammar.GrammarMaker_Marshal(n, &val.Grammar)
		}
		n.EndBlock()
	}
	return
}

// KindOfNoun
type KindOfNoun struct {
	AreAn        AreAn         `if:"label=_"`
	Trait        []Trait       `if:"label=trait,optional"`
	Kind         SingularKind  `if:"label=kind"`
	NounRelation *NounRelation `if:"label=noun_relation,optional"`
}

func (*KindOfNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: KindOfNoun_Type,
		Uses: composer.Type_Flow,
	}
}

const KindOfNoun_Type = "kind_of_noun"

const KindOfNoun_Field_AreAn = "$ARE_AN"
const KindOfNoun_Field_Trait = "$TRAIT"
const KindOfNoun_Field_Kind = "$KIND"
const KindOfNoun_Field_NounRelation = "$NOUN_RELATION"

func (op *KindOfNoun) Marshal(n jsn.Marshaler) {
	KindOfNoun_Marshal(n, op)
}

type KindOfNoun_Slice []KindOfNoun

func (op *KindOfNoun_Slice) GetType() string { return KindOfNoun_Type }
func (op *KindOfNoun_Slice) GetSize() int    { return len(*op) }
func (op *KindOfNoun_Slice) SetSize(cnt int) { (*op) = make(KindOfNoun_Slice, cnt) }

func KindOfNoun_Repeats_Marshal(n jsn.Marshaler, vals *[]KindOfNoun) {
	if n.MarshalBlock((*KindOfNoun_Slice)(vals)) {
		for i := range *vals {
			KindOfNoun_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func KindOfNoun_Optional_Marshal(n jsn.Marshaler, pv **KindOfNoun) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		KindOfNoun_Marshal(n, *pv)
	} else if !enc {
		var v KindOfNoun
		if KindOfNoun_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func KindOfNoun_Marshal(n jsn.Marshaler, val *KindOfNoun) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(KindOfNoun_Type,
		KindOfNoun_Type)); okay {
		if n.MarshalKey("", KindOfNoun_Field_AreAn) {
			AreAn_Marshal(n, &val.AreAn)
		}
		if n.MarshalKey("trait", KindOfNoun_Field_Trait) {
			Trait_Repeats_Marshal(n, &val.Trait)
		}
		if n.MarshalKey("kind", KindOfNoun_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		if n.MarshalKey("noun_relation", KindOfNoun_Field_NounRelation) {
			NounRelation_Optional_Marshal(n, &val.NounRelation)
		}
		n.EndBlock()
	}
	return
}

// KindOfRelation
// User implements: StoryStatement.
type KindOfRelation struct {
	Relation    value.RelationName  `if:"label=_"`
	Cardinality RelationCardinality `if:"label=cardinality"`
}

func (*KindOfRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: KindOfRelation_Type,
		Uses: composer.Type_Flow,
	}
}

const KindOfRelation_Type = "kind_of_relation"

const KindOfRelation_Field_Relation = "$RELATION"
const KindOfRelation_Field_Cardinality = "$CARDINALITY"

func (op *KindOfRelation) Marshal(n jsn.Marshaler) {
	KindOfRelation_Marshal(n, op)
}

type KindOfRelation_Slice []KindOfRelation

func (op *KindOfRelation_Slice) GetType() string { return KindOfRelation_Type }
func (op *KindOfRelation_Slice) GetSize() int    { return len(*op) }
func (op *KindOfRelation_Slice) SetSize(cnt int) { (*op) = make(KindOfRelation_Slice, cnt) }

func KindOfRelation_Repeats_Marshal(n jsn.Marshaler, vals *[]KindOfRelation) {
	if n.MarshalBlock((*KindOfRelation_Slice)(vals)) {
		for i := range *vals {
			KindOfRelation_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func KindOfRelation_Optional_Marshal(n jsn.Marshaler, pv **KindOfRelation) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		KindOfRelation_Marshal(n, *pv)
	} else if !enc {
		var v KindOfRelation
		if KindOfRelation_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func KindOfRelation_Marshal(n jsn.Marshaler, val *KindOfRelation) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(KindOfRelation_Type,
		KindOfRelation_Type)); okay {
		if n.MarshalKey("", KindOfRelation_Field_Relation) {
			value.RelationName_Marshal(n, &val.Relation)
		}
		if n.MarshalKey("cardinality", KindOfRelation_Field_Cardinality) {
			RelationCardinality_Marshal(n, &val.Cardinality)
		}
		n.EndBlock()
	}
	return
}

// KindsOfAspect
// User implements: StoryStatement.
type KindsOfAspect struct {
	Aspect Aspect `if:"label=_"`
}

func (*KindsOfAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: KindsOfAspect_Type,
		Uses: composer.Type_Flow,
	}
}

const KindsOfAspect_Type = "kinds_of_aspect"

const KindsOfAspect_Field_Aspect = "$ASPECT"

func (op *KindsOfAspect) Marshal(n jsn.Marshaler) {
	KindsOfAspect_Marshal(n, op)
}

type KindsOfAspect_Slice []KindsOfAspect

func (op *KindsOfAspect_Slice) GetType() string { return KindsOfAspect_Type }
func (op *KindsOfAspect_Slice) GetSize() int    { return len(*op) }
func (op *KindsOfAspect_Slice) SetSize(cnt int) { (*op) = make(KindsOfAspect_Slice, cnt) }

func KindsOfAspect_Repeats_Marshal(n jsn.Marshaler, vals *[]KindsOfAspect) {
	if n.MarshalBlock((*KindsOfAspect_Slice)(vals)) {
		for i := range *vals {
			KindsOfAspect_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func KindsOfAspect_Optional_Marshal(n jsn.Marshaler, pv **KindsOfAspect) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		KindsOfAspect_Marshal(n, *pv)
	} else if !enc {
		var v KindsOfAspect
		if KindsOfAspect_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func KindsOfAspect_Marshal(n jsn.Marshaler, val *KindsOfAspect) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(KindsOfAspect_Type,
		KindsOfAspect_Type)); okay {
		if n.MarshalKey("", KindsOfAspect_Field_Aspect) {
			Aspect_Marshal(n, &val.Aspect)
		}
		n.EndBlock()
	}
	return
}

// KindsOfKind
// User implements: StoryStatement.
type KindsOfKind struct {
	PluralKinds  PluralKinds  `if:"label=_"`
	SingularKind SingularKind `if:"label=singular_kind"`
}

func (*KindsOfKind) Compose() composer.Spec {
	return composer.Spec{
		Name: KindsOfKind_Type,
		Uses: composer.Type_Flow,
	}
}

const KindsOfKind_Type = "kinds_of_kind"

const KindsOfKind_Field_PluralKinds = "$PLURAL_KINDS"
const KindsOfKind_Field_SingularKind = "$SINGULAR_KIND"

func (op *KindsOfKind) Marshal(n jsn.Marshaler) {
	KindsOfKind_Marshal(n, op)
}

type KindsOfKind_Slice []KindsOfKind

func (op *KindsOfKind_Slice) GetType() string { return KindsOfKind_Type }
func (op *KindsOfKind_Slice) GetSize() int    { return len(*op) }
func (op *KindsOfKind_Slice) SetSize(cnt int) { (*op) = make(KindsOfKind_Slice, cnt) }

func KindsOfKind_Repeats_Marshal(n jsn.Marshaler, vals *[]KindsOfKind) {
	if n.MarshalBlock((*KindsOfKind_Slice)(vals)) {
		for i := range *vals {
			KindsOfKind_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func KindsOfKind_Optional_Marshal(n jsn.Marshaler, pv **KindsOfKind) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		KindsOfKind_Marshal(n, *pv)
	} else if !enc {
		var v KindsOfKind
		if KindsOfKind_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func KindsOfKind_Marshal(n jsn.Marshaler, val *KindsOfKind) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(KindsOfKind_Type,
		KindsOfKind_Type)); okay {
		if n.MarshalKey("", KindsOfKind_Field_PluralKinds) {
			PluralKinds_Marshal(n, &val.PluralKinds)
		}
		if n.MarshalKey("singular_kind", KindsOfKind_Field_SingularKind) {
			SingularKind_Marshal(n, &val.SingularKind)
		}
		n.EndBlock()
	}
	return
}

// KindsOfRecord
// User implements: StoryStatement.
type KindsOfRecord struct {
	RecordPlural RecordPlural `if:"label=_"`
}

func (*KindsOfRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: KindsOfRecord_Type,
		Uses: composer.Type_Flow,
	}
}

const KindsOfRecord_Type = "kinds_of_record"

const KindsOfRecord_Field_RecordPlural = "$RECORD_PLURAL"

func (op *KindsOfRecord) Marshal(n jsn.Marshaler) {
	KindsOfRecord_Marshal(n, op)
}

type KindsOfRecord_Slice []KindsOfRecord

func (op *KindsOfRecord_Slice) GetType() string { return KindsOfRecord_Type }
func (op *KindsOfRecord_Slice) GetSize() int    { return len(*op) }
func (op *KindsOfRecord_Slice) SetSize(cnt int) { (*op) = make(KindsOfRecord_Slice, cnt) }

func KindsOfRecord_Repeats_Marshal(n jsn.Marshaler, vals *[]KindsOfRecord) {
	if n.MarshalBlock((*KindsOfRecord_Slice)(vals)) {
		for i := range *vals {
			KindsOfRecord_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func KindsOfRecord_Optional_Marshal(n jsn.Marshaler, pv **KindsOfRecord) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		KindsOfRecord_Marshal(n, *pv)
	} else if !enc {
		var v KindsOfRecord
		if KindsOfRecord_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func KindsOfRecord_Marshal(n jsn.Marshaler, val *KindsOfRecord) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(KindsOfRecord_Type,
		KindsOfRecord_Type)); okay {
		if n.MarshalKey("", KindsOfRecord_Field_RecordPlural) {
			RecordPlural_Marshal(n, &val.RecordPlural)
		}
		n.EndBlock()
	}
	return
}

// KindsPossessProperties
// User implements: StoryStatement.
type KindsPossessProperties struct {
	PluralKinds  PluralKinds    `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*KindsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: KindsPossessProperties_Type,
		Uses: composer.Type_Flow,
	}
}

const KindsPossessProperties_Type = "kinds_possess_properties"

const KindsPossessProperties_Field_PluralKinds = "$PLURAL_KINDS"
const KindsPossessProperties_Field_PropertyDecl = "$PROPERTY_DECL"

func (op *KindsPossessProperties) Marshal(n jsn.Marshaler) {
	KindsPossessProperties_Marshal(n, op)
}

type KindsPossessProperties_Slice []KindsPossessProperties

func (op *KindsPossessProperties_Slice) GetType() string { return KindsPossessProperties_Type }
func (op *KindsPossessProperties_Slice) GetSize() int    { return len(*op) }
func (op *KindsPossessProperties_Slice) SetSize(cnt int) {
	(*op) = make(KindsPossessProperties_Slice, cnt)
}

func KindsPossessProperties_Repeats_Marshal(n jsn.Marshaler, vals *[]KindsPossessProperties) {
	if n.MarshalBlock((*KindsPossessProperties_Slice)(vals)) {
		for i := range *vals {
			KindsPossessProperties_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func KindsPossessProperties_Optional_Marshal(n jsn.Marshaler, pv **KindsPossessProperties) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		KindsPossessProperties_Marshal(n, *pv)
	} else if !enc {
		var v KindsPossessProperties
		if KindsPossessProperties_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func KindsPossessProperties_Marshal(n jsn.Marshaler, val *KindsPossessProperties) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(KindsPossessProperties_Type,
		KindsPossessProperties_Type)); okay {
		if n.MarshalKey("", KindsPossessProperties_Field_PluralKinds) {
			PluralKinds_Marshal(n, &val.PluralKinds)
		}
		if n.MarshalKey("property_decl", KindsPossessProperties_Field_PropertyDecl) {
			PropertyDecl_Repeats_Marshal(n, &val.PropertyDecl)
		}
		n.EndBlock()
	}
	return
}

// Lede Describes one or more nouns.
type Lede struct {
	Nouns      []NamedNoun `if:"label=_"`
	NounPhrase NounPhrase  `if:"label=noun_phrase"`
}

func (*Lede) Compose() composer.Spec {
	return composer.Spec{
		Name: Lede_Type,
		Uses: composer.Type_Flow,
	}
}

const Lede_Type = "lede"

const Lede_Field_Nouns = "$NOUNS"
const Lede_Field_NounPhrase = "$NOUN_PHRASE"

func (op *Lede) Marshal(n jsn.Marshaler) {
	Lede_Marshal(n, op)
}

type Lede_Slice []Lede

func (op *Lede_Slice) GetType() string { return Lede_Type }
func (op *Lede_Slice) GetSize() int    { return len(*op) }
func (op *Lede_Slice) SetSize(cnt int) { (*op) = make(Lede_Slice, cnt) }

func Lede_Repeats_Marshal(n jsn.Marshaler, vals *[]Lede) {
	if n.MarshalBlock((*Lede_Slice)(vals)) {
		for i := range *vals {
			Lede_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Lede_Optional_Marshal(n jsn.Marshaler, pv **Lede) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Lede_Marshal(n, *pv)
	} else if !enc {
		var v Lede
		if Lede_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Lede_Marshal(n jsn.Marshaler, val *Lede) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Lede_Type,
		Lede_Type)); okay {
		if n.MarshalKey("", Lede_Field_Nouns) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns)
		}
		if n.MarshalKey("noun_phrase", Lede_Field_NounPhrase) {
			NounPhrase_Marshal(n, &val.NounPhrase)
		}
		n.EndBlock()
	}
	return
}

// LocalDecl
type LocalDecl struct {
	VariableDecl VariableDecl `if:"label=_"`
	Value        *LocalInit   `if:"label=value,optional"`
}

func (*LocalDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: LocalDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const LocalDecl_Type = "local_decl"

const LocalDecl_Field_VariableDecl = "$VARIABLE_DECL"
const LocalDecl_Field_Value = "$VALUE"

func (op *LocalDecl) Marshal(n jsn.Marshaler) {
	LocalDecl_Marshal(n, op)
}

type LocalDecl_Slice []LocalDecl

func (op *LocalDecl_Slice) GetType() string { return LocalDecl_Type }
func (op *LocalDecl_Slice) GetSize() int    { return len(*op) }
func (op *LocalDecl_Slice) SetSize(cnt int) { (*op) = make(LocalDecl_Slice, cnt) }

func LocalDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]LocalDecl) {
	if n.MarshalBlock((*LocalDecl_Slice)(vals)) {
		for i := range *vals {
			LocalDecl_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func LocalDecl_Optional_Marshal(n jsn.Marshaler, pv **LocalDecl) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		LocalDecl_Marshal(n, *pv)
	} else if !enc {
		var v LocalDecl
		if LocalDecl_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func LocalDecl_Marshal(n jsn.Marshaler, val *LocalDecl) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(LocalDecl_Type,
		LocalDecl_Type)); okay {
		if n.MarshalKey("", LocalDecl_Field_VariableDecl) {
			VariableDecl_Marshal(n, &val.VariableDecl)
		}
		if n.MarshalKey("value", LocalDecl_Field_Value) {
			LocalInit_Optional_Marshal(n, &val.Value)
		}
		n.EndBlock()
	}
	return
}

// LocalInit
type LocalInit struct {
	Value rt.Assignment `if:"label=_"`
}

func (*LocalInit) Compose() composer.Spec {
	return composer.Spec{
		Name: LocalInit_Type,
		Uses: composer.Type_Flow,
	}
}

const LocalInit_Type = "local_init"

const LocalInit_Field_Value = "$VALUE"

func (op *LocalInit) Marshal(n jsn.Marshaler) {
	LocalInit_Marshal(n, op)
}

type LocalInit_Slice []LocalInit

func (op *LocalInit_Slice) GetType() string { return LocalInit_Type }
func (op *LocalInit_Slice) GetSize() int    { return len(*op) }
func (op *LocalInit_Slice) SetSize(cnt int) { (*op) = make(LocalInit_Slice, cnt) }

func LocalInit_Repeats_Marshal(n jsn.Marshaler, vals *[]LocalInit) {
	if n.MarshalBlock((*LocalInit_Slice)(vals)) {
		for i := range *vals {
			LocalInit_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func LocalInit_Optional_Marshal(n jsn.Marshaler, pv **LocalInit) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		LocalInit_Marshal(n, *pv)
	} else if !enc {
		var v LocalInit
		if LocalInit_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func LocalInit_Marshal(n jsn.Marshaler, val *LocalInit) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(LocalInit_Type,
		LocalInit_Type)); okay {
		if n.MarshalKey("", LocalInit_Field_Value) {
			rt.Assignment_Marshal(n, &val.Value)
		}
		n.EndBlock()
	}
	return
}

// Make
// User implements: RecordEval.
type Make struct {
	Name      string     `if:"label=_,type=text"`
	Arguments *Arguments `if:"label=arguments,optional"`
}

func (*Make) Compose() composer.Spec {
	return composer.Spec{
		Name: Make_Type,
		Uses: composer.Type_Flow,
	}
}

const Make_Type = "make"

const Make_Field_Name = "$NAME"
const Make_Field_Arguments = "$ARGUMENTS"

func (op *Make) Marshal(n jsn.Marshaler) {
	Make_Marshal(n, op)
}

type Make_Slice []Make

func (op *Make_Slice) GetType() string { return Make_Type }
func (op *Make_Slice) GetSize() int    { return len(*op) }
func (op *Make_Slice) SetSize(cnt int) { (*op) = make(Make_Slice, cnt) }

func Make_Repeats_Marshal(n jsn.Marshaler, vals *[]Make) {
	if n.MarshalBlock((*Make_Slice)(vals)) {
		for i := range *vals {
			Make_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Make_Optional_Marshal(n jsn.Marshaler, pv **Make) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Make_Marshal(n, *pv)
	} else if !enc {
		var v Make
		if Make_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Make_Marshal(n jsn.Marshaler, val *Make) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Make_Type,
		Make_Type)); okay {
		if n.MarshalKey("", Make_Field_Name) {
			value.Text_Unboxed_Marshal(n, &val.Name)
		}
		if n.MarshalKey("arguments", Make_Field_Arguments) {
			Arguments_Optional_Marshal(n, &val.Arguments)
		}
		n.EndBlock()
	}
	return
}

// ManyToMany
type ManyToMany struct {
	Kinds      PluralKinds `if:"label=_"`
	OtherKinds PluralKinds `if:"label=other_kinds"`
}

func (*ManyToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyToMany_Type,
		Uses: composer.Type_Flow,
	}
}

const ManyToMany_Type = "many_to_many"

const ManyToMany_Field_Kinds = "$KINDS"
const ManyToMany_Field_OtherKinds = "$OTHER_KINDS"

func (op *ManyToMany) Marshal(n jsn.Marshaler) {
	ManyToMany_Marshal(n, op)
}

type ManyToMany_Slice []ManyToMany

func (op *ManyToMany_Slice) GetType() string { return ManyToMany_Type }
func (op *ManyToMany_Slice) GetSize() int    { return len(*op) }
func (op *ManyToMany_Slice) SetSize(cnt int) { (*op) = make(ManyToMany_Slice, cnt) }

func ManyToMany_Repeats_Marshal(n jsn.Marshaler, vals *[]ManyToMany) {
	if n.MarshalBlock((*ManyToMany_Slice)(vals)) {
		for i := range *vals {
			ManyToMany_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func ManyToMany_Optional_Marshal(n jsn.Marshaler, pv **ManyToMany) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ManyToMany_Marshal(n, *pv)
	} else if !enc {
		var v ManyToMany
		if ManyToMany_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ManyToMany_Marshal(n jsn.Marshaler, val *ManyToMany) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(ManyToMany_Type,
		ManyToMany_Type)); okay {
		if n.MarshalKey("", ManyToMany_Field_Kinds) {
			PluralKinds_Marshal(n, &val.Kinds)
		}
		if n.MarshalKey("other_kinds", ManyToMany_Field_OtherKinds) {
			PluralKinds_Marshal(n, &val.OtherKinds)
		}
		n.EndBlock()
	}
	return
}

// ManyToOne
type ManyToOne struct {
	Kinds PluralKinds  `if:"label=_"`
	Kind  SingularKind `if:"label=kind"`
}

func (*ManyToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyToOne_Type,
		Uses: composer.Type_Flow,
	}
}

const ManyToOne_Type = "many_to_one"

const ManyToOne_Field_Kinds = "$KINDS"
const ManyToOne_Field_Kind = "$KIND"

func (op *ManyToOne) Marshal(n jsn.Marshaler) {
	ManyToOne_Marshal(n, op)
}

type ManyToOne_Slice []ManyToOne

func (op *ManyToOne_Slice) GetType() string { return ManyToOne_Type }
func (op *ManyToOne_Slice) GetSize() int    { return len(*op) }
func (op *ManyToOne_Slice) SetSize(cnt int) { (*op) = make(ManyToOne_Slice, cnt) }

func ManyToOne_Repeats_Marshal(n jsn.Marshaler, vals *[]ManyToOne) {
	if n.MarshalBlock((*ManyToOne_Slice)(vals)) {
		for i := range *vals {
			ManyToOne_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func ManyToOne_Optional_Marshal(n jsn.Marshaler, pv **ManyToOne) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ManyToOne_Marshal(n, *pv)
	} else if !enc {
		var v ManyToOne
		if ManyToOne_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ManyToOne_Marshal(n jsn.Marshaler, val *ManyToOne) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(ManyToOne_Type,
		ManyToOne_Type)); okay {
		if n.MarshalKey("", ManyToOne_Field_Kinds) {
			PluralKinds_Marshal(n, &val.Kinds)
		}
		if n.MarshalKey("kind", ManyToOne_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		n.EndBlock()
	}
	return
}

// NamedNoun
type NamedNoun struct {
	Determiner Determiner `if:"label=_"`
	Name       NounName   `if:"label=name"`
}

func (*NamedNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: NamedNoun_Type,
		Uses: composer.Type_Flow,
	}
}

const NamedNoun_Type = "named_noun"

const NamedNoun_Field_Determiner = "$DETERMINER"
const NamedNoun_Field_Name = "$NAME"

func (op *NamedNoun) Marshal(n jsn.Marshaler) {
	NamedNoun_Marshal(n, op)
}

type NamedNoun_Slice []NamedNoun

func (op *NamedNoun_Slice) GetType() string { return NamedNoun_Type }
func (op *NamedNoun_Slice) GetSize() int    { return len(*op) }
func (op *NamedNoun_Slice) SetSize(cnt int) { (*op) = make(NamedNoun_Slice, cnt) }

func NamedNoun_Repeats_Marshal(n jsn.Marshaler, vals *[]NamedNoun) {
	if n.MarshalBlock((*NamedNoun_Slice)(vals)) {
		for i := range *vals {
			NamedNoun_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func NamedNoun_Optional_Marshal(n jsn.Marshaler, pv **NamedNoun) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		NamedNoun_Marshal(n, *pv)
	} else if !enc {
		var v NamedNoun
		if NamedNoun_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func NamedNoun_Marshal(n jsn.Marshaler, val *NamedNoun) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(NamedNoun_Type,
		NamedNoun_Type)); okay {
		if n.MarshalKey("", NamedNoun_Field_Determiner) {
			Determiner_Marshal(n, &val.Determiner)
		}
		if n.MarshalKey("name", NamedNoun_Field_Name) {
			NounName_Marshal(n, &val.Name)
		}
		n.EndBlock()
	}
	return
}

// NounAssignment Assign text.
// User implements: StoryStatement.
type NounAssignment struct {
	Property Property    `if:"label=_"`
	Nouns    []NamedNoun `if:"label=nouns"`
	Lines    value.Lines `if:"label=lines"`
}

func (*NounAssignment) Compose() composer.Spec {
	return composer.Spec{
		Name: NounAssignment_Type,
		Uses: composer.Type_Flow,
	}
}

const NounAssignment_Type = "noun_assignment"

const NounAssignment_Field_Property = "$PROPERTY"
const NounAssignment_Field_Nouns = "$NOUNS"
const NounAssignment_Field_Lines = "$LINES"

func (op *NounAssignment) Marshal(n jsn.Marshaler) {
	NounAssignment_Marshal(n, op)
}

type NounAssignment_Slice []NounAssignment

func (op *NounAssignment_Slice) GetType() string { return NounAssignment_Type }
func (op *NounAssignment_Slice) GetSize() int    { return len(*op) }
func (op *NounAssignment_Slice) SetSize(cnt int) { (*op) = make(NounAssignment_Slice, cnt) }

func NounAssignment_Repeats_Marshal(n jsn.Marshaler, vals *[]NounAssignment) {
	if n.MarshalBlock((*NounAssignment_Slice)(vals)) {
		for i := range *vals {
			NounAssignment_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func NounAssignment_Optional_Marshal(n jsn.Marshaler, pv **NounAssignment) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		NounAssignment_Marshal(n, *pv)
	} else if !enc {
		var v NounAssignment
		if NounAssignment_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func NounAssignment_Marshal(n jsn.Marshaler, val *NounAssignment) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(NounAssignment_Type,
		NounAssignment_Type)); okay {
		if n.MarshalKey("", NounAssignment_Field_Property) {
			Property_Marshal(n, &val.Property)
		}
		if n.MarshalKey("nouns", NounAssignment_Field_Nouns) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns)
		}
		if n.MarshalKey("lines", NounAssignment_Field_Lines) {
			value.Lines_Marshal(n, &val.Lines)
		}
		n.EndBlock()
	}
	return
}

// NounName requires a user-specified string.
type NounName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *NounName) String() string {
	return op.Str
}

func (*NounName) Compose() composer.Spec {
	return composer.Spec{
		Name:        NounName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const NounName_Type = "noun_name"

func (op *NounName) Marshal(n jsn.Marshaler) {
	NounName_Marshal(n, op)
}

func NounName_Optional_Marshal(n jsn.Marshaler, val *NounName) {
	var zero NounName
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		NounName_Marshal(n, val)
	}
}

func NounName_Marshal(n jsn.Marshaler, val *NounName) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(NounName_Type, &val.Str)
}

type NounName_Slice []NounName

func (op *NounName_Slice) GetType() string { return NounName_Type }
func (op *NounName_Slice) GetSize() int    { return len(*op) }
func (op *NounName_Slice) SetSize(cnt int) { (*op) = make(NounName_Slice, cnt) }

func NounName_Repeats_Marshal(n jsn.Marshaler, vals *[]NounName) {
	if n.MarshalBlock((*NounName_Slice)(vals)) {
		for i := range *vals {
			NounName_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// NounPhrase swaps between various options
type NounPhrase struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const NounPhrase_KindOfNoun_Opt = "$KIND_OF_NOUN"
const NounPhrase_NounTraits_Opt = "$NOUN_TRAITS"
const NounPhrase_NounRelation_Opt = "$NOUN_RELATION"

func (*NounPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: NounPhrase_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			NounPhrase_KindOfNoun_Opt, NounPhrase_NounTraits_Opt, NounPhrase_NounRelation_Opt,
		},
		Swaps: []interface{}{
			(*KindOfNoun)(nil),
			(*NounTraits)(nil),
			(*NounRelation)(nil),
		},
	}
}

const NounPhrase_Type = "noun_phrase"

func (op *NounPhrase) GetType() string { return NounPhrase_Type }

func (op *NounPhrase) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *KindOfNoun:
		ret, okay = NounPhrase_KindOfNoun_Opt, true
	case *NounTraits:
		ret, okay = NounPhrase_NounTraits_Opt, true
	case *NounRelation:
		ret, okay = NounPhrase_NounRelation_Opt, true
	}
	return
}

func (op *NounPhrase) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case NounPhrase_KindOfNoun_Opt:
		opt := new(KindOfNoun)
		op.Opt, ret, okay = opt, opt, true
	case NounPhrase_NounTraits_Opt:
		opt := new(NounTraits)
		op.Opt, ret, okay = opt, opt, true
	case NounPhrase_NounRelation_Opt:
		opt := new(NounRelation)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *NounPhrase) Marshal(n jsn.Marshaler) {
	NounPhrase_Marshal(n, op)
}
func NounPhrase_Marshal(n jsn.Marshaler, val *NounPhrase) {
	n.SetCursor(val.At.Offset)
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type NounPhrase_Slice []NounPhrase

func (op *NounPhrase_Slice) GetType() string { return NounPhrase_Type }
func (op *NounPhrase_Slice) GetSize() int    { return len(*op) }
func (op *NounPhrase_Slice) SetSize(cnt int) { (*op) = make(NounPhrase_Slice, cnt) }

func NounPhrase_Repeats_Marshal(n jsn.Marshaler, vals *[]NounPhrase) {
	if n.MarshalBlock((*NounPhrase_Slice)(vals)) {
		for i := range *vals {
			NounPhrase_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// NounRelation
type NounRelation struct {
	AreBeing AreBeing           `if:"label=_,optional"`
	Relation value.RelationName `if:"label=relation"`
	Nouns    []NamedNoun        `if:"label=nouns"`
}

func (*NounRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: NounRelation_Type,
		Uses: composer.Type_Flow,
	}
}

const NounRelation_Type = "noun_relation"

const NounRelation_Field_AreBeing = "$ARE_BEING"
const NounRelation_Field_Relation = "$RELATION"
const NounRelation_Field_Nouns = "$NOUNS"

func (op *NounRelation) Marshal(n jsn.Marshaler) {
	NounRelation_Marshal(n, op)
}

type NounRelation_Slice []NounRelation

func (op *NounRelation_Slice) GetType() string { return NounRelation_Type }
func (op *NounRelation_Slice) GetSize() int    { return len(*op) }
func (op *NounRelation_Slice) SetSize(cnt int) { (*op) = make(NounRelation_Slice, cnt) }

func NounRelation_Repeats_Marshal(n jsn.Marshaler, vals *[]NounRelation) {
	if n.MarshalBlock((*NounRelation_Slice)(vals)) {
		for i := range *vals {
			NounRelation_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func NounRelation_Optional_Marshal(n jsn.Marshaler, pv **NounRelation) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		NounRelation_Marshal(n, *pv)
	} else if !enc {
		var v NounRelation
		if NounRelation_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func NounRelation_Marshal(n jsn.Marshaler, val *NounRelation) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(NounRelation_Type,
		NounRelation_Type)); okay {
		if n.MarshalKey("", NounRelation_Field_AreBeing) {
			AreBeing_Optional_Marshal(n, &val.AreBeing)
		}
		if n.MarshalKey("relation", NounRelation_Field_Relation) {
			value.RelationName_Marshal(n, &val.Relation)
		}
		if n.MarshalKey("nouns", NounRelation_Field_Nouns) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns)
		}
		n.EndBlock()
	}
	return
}

// NounStatement Describes people, places, or things.
// User implements: StoryStatement.
type NounStatement struct {
	Lede    Lede     `if:"label=_"`
	Tail    []Tail   `if:"label=tail,optional"`
	Summary *Summary `if:"label=summary,optional"`
}

func (*NounStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: NounStatement_Type,
		Uses: composer.Type_Flow,
	}
}

const NounStatement_Type = "noun_statement"

const NounStatement_Field_Lede = "$LEDE"
const NounStatement_Field_Tail = "$TAIL"
const NounStatement_Field_Summary = "$SUMMARY"

func (op *NounStatement) Marshal(n jsn.Marshaler) {
	NounStatement_Marshal(n, op)
}

type NounStatement_Slice []NounStatement

func (op *NounStatement_Slice) GetType() string { return NounStatement_Type }
func (op *NounStatement_Slice) GetSize() int    { return len(*op) }
func (op *NounStatement_Slice) SetSize(cnt int) { (*op) = make(NounStatement_Slice, cnt) }

func NounStatement_Repeats_Marshal(n jsn.Marshaler, vals *[]NounStatement) {
	if n.MarshalBlock((*NounStatement_Slice)(vals)) {
		for i := range *vals {
			NounStatement_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func NounStatement_Optional_Marshal(n jsn.Marshaler, pv **NounStatement) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		NounStatement_Marshal(n, *pv)
	} else if !enc {
		var v NounStatement
		if NounStatement_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func NounStatement_Marshal(n jsn.Marshaler, val *NounStatement) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(NounStatement_Type,
		NounStatement_Type)); okay {
		if n.MarshalKey("", NounStatement_Field_Lede) {
			Lede_Marshal(n, &val.Lede)
		}
		if n.MarshalKey("tail", NounStatement_Field_Tail) {
			Tail_Repeats_Marshal(n, &val.Tail)
		}
		if n.MarshalKey("summary", NounStatement_Field_Summary) {
			Summary_Optional_Marshal(n, &val.Summary)
		}
		n.EndBlock()
	}
	return
}

// NounTraits
type NounTraits struct {
	AreBeing AreBeing `if:"label=_"`
	Trait    []Trait  `if:"label=trait"`
}

func (*NounTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: NounTraits_Type,
		Uses: composer.Type_Flow,
	}
}

const NounTraits_Type = "noun_traits"

const NounTraits_Field_AreBeing = "$ARE_BEING"
const NounTraits_Field_Trait = "$TRAIT"

func (op *NounTraits) Marshal(n jsn.Marshaler) {
	NounTraits_Marshal(n, op)
}

type NounTraits_Slice []NounTraits

func (op *NounTraits_Slice) GetType() string { return NounTraits_Type }
func (op *NounTraits_Slice) GetSize() int    { return len(*op) }
func (op *NounTraits_Slice) SetSize(cnt int) { (*op) = make(NounTraits_Slice, cnt) }

func NounTraits_Repeats_Marshal(n jsn.Marshaler, vals *[]NounTraits) {
	if n.MarshalBlock((*NounTraits_Slice)(vals)) {
		for i := range *vals {
			NounTraits_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func NounTraits_Optional_Marshal(n jsn.Marshaler, pv **NounTraits) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		NounTraits_Marshal(n, *pv)
	} else if !enc {
		var v NounTraits
		if NounTraits_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func NounTraits_Marshal(n jsn.Marshaler, val *NounTraits) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(NounTraits_Type,
		NounTraits_Type)); okay {
		if n.MarshalKey("", NounTraits_Field_AreBeing) {
			AreBeing_Marshal(n, &val.AreBeing)
		}
		if n.MarshalKey("trait", NounTraits_Field_Trait) {
			Trait_Repeats_Marshal(n, &val.Trait)
		}
		n.EndBlock()
	}
	return
}

// NumberList requires a user-specified string.
type NumberList struct {
	Str string
}

func (op *NumberList) String() string {
	return op.Str
}

const NumberList_List = "$LIST"

func (*NumberList) Compose() composer.Spec {
	return composer.Spec{
		Name: NumberList_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			NumberList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

const NumberList_Type = "number_list"

func (op *NumberList) Marshal(n jsn.Marshaler) {
	NumberList_Marshal(n, op)
}

func NumberList_Optional_Marshal(n jsn.Marshaler, val *NumberList) {
	var zero NumberList
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		NumberList_Marshal(n, val)
	}
}

func NumberList_Marshal(n jsn.Marshaler, val *NumberList) {
	n.MarshalValue(NumberList_Type, jsn.MakeEnum(val, &val.Str))
}

type NumberList_Slice []NumberList

func (op *NumberList_Slice) GetType() string { return NumberList_Type }
func (op *NumberList_Slice) GetSize() int    { return len(*op) }
func (op *NumberList_Slice) SetSize(cnt int) { (*op) = make(NumberList_Slice, cnt) }

func NumberList_Repeats_Marshal(n jsn.Marshaler, vals *[]NumberList) {
	if n.MarshalBlock((*NumberList_Slice)(vals)) {
		for i := range *vals {
			NumberList_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// ObjectType
type ObjectType struct {
	An   Ana          `if:"label=_"`
	Kind SingularKind `if:"label=kind"`
}

func (*ObjectType) Compose() composer.Spec {
	return composer.Spec{
		Name: ObjectType_Type,
		Uses: composer.Type_Flow,
	}
}

const ObjectType_Type = "object_type"

const ObjectType_Field_An = "$AN"
const ObjectType_Field_Kind = "$KIND"

func (op *ObjectType) Marshal(n jsn.Marshaler) {
	ObjectType_Marshal(n, op)
}

type ObjectType_Slice []ObjectType

func (op *ObjectType_Slice) GetType() string { return ObjectType_Type }
func (op *ObjectType_Slice) GetSize() int    { return len(*op) }
func (op *ObjectType_Slice) SetSize(cnt int) { (*op) = make(ObjectType_Slice, cnt) }

func ObjectType_Repeats_Marshal(n jsn.Marshaler, vals *[]ObjectType) {
	if n.MarshalBlock((*ObjectType_Slice)(vals)) {
		for i := range *vals {
			ObjectType_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func ObjectType_Optional_Marshal(n jsn.Marshaler, pv **ObjectType) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ObjectType_Marshal(n, *pv)
	} else if !enc {
		var v ObjectType
		if ObjectType_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ObjectType_Marshal(n jsn.Marshaler, val *ObjectType) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(ObjectType_Type,
		ObjectType_Type)); okay {
		if n.MarshalKey("", ObjectType_Field_An) {
			Ana_Marshal(n, &val.An)
		}
		if n.MarshalKey("kind", ObjectType_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		n.EndBlock()
	}
	return
}

// OneToMany
type OneToMany struct {
	Kind  SingularKind `if:"label=_"`
	Kinds PluralKinds  `if:"label=kinds"`
}

func (*OneToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: OneToMany_Type,
		Uses: composer.Type_Flow,
	}
}

const OneToMany_Type = "one_to_many"

const OneToMany_Field_Kind = "$KIND"
const OneToMany_Field_Kinds = "$KINDS"

func (op *OneToMany) Marshal(n jsn.Marshaler) {
	OneToMany_Marshal(n, op)
}

type OneToMany_Slice []OneToMany

func (op *OneToMany_Slice) GetType() string { return OneToMany_Type }
func (op *OneToMany_Slice) GetSize() int    { return len(*op) }
func (op *OneToMany_Slice) SetSize(cnt int) { (*op) = make(OneToMany_Slice, cnt) }

func OneToMany_Repeats_Marshal(n jsn.Marshaler, vals *[]OneToMany) {
	if n.MarshalBlock((*OneToMany_Slice)(vals)) {
		for i := range *vals {
			OneToMany_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func OneToMany_Optional_Marshal(n jsn.Marshaler, pv **OneToMany) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		OneToMany_Marshal(n, *pv)
	} else if !enc {
		var v OneToMany
		if OneToMany_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func OneToMany_Marshal(n jsn.Marshaler, val *OneToMany) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(OneToMany_Type,
		OneToMany_Type)); okay {
		if n.MarshalKey("", OneToMany_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		if n.MarshalKey("kinds", OneToMany_Field_Kinds) {
			PluralKinds_Marshal(n, &val.Kinds)
		}
		n.EndBlock()
	}
	return
}

// OneToOne
type OneToOne struct {
	Kind      SingularKind `if:"label=_"`
	OtherKind SingularKind `if:"label=other_kind"`
}

func (*OneToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: OneToOne_Type,
		Uses: composer.Type_Flow,
	}
}

const OneToOne_Type = "one_to_one"

const OneToOne_Field_Kind = "$KIND"
const OneToOne_Field_OtherKind = "$OTHER_KIND"

func (op *OneToOne) Marshal(n jsn.Marshaler) {
	OneToOne_Marshal(n, op)
}

type OneToOne_Slice []OneToOne

func (op *OneToOne_Slice) GetType() string { return OneToOne_Type }
func (op *OneToOne_Slice) GetSize() int    { return len(*op) }
func (op *OneToOne_Slice) SetSize(cnt int) { (*op) = make(OneToOne_Slice, cnt) }

func OneToOne_Repeats_Marshal(n jsn.Marshaler, vals *[]OneToOne) {
	if n.MarshalBlock((*OneToOne_Slice)(vals)) {
		for i := range *vals {
			OneToOne_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func OneToOne_Optional_Marshal(n jsn.Marshaler, pv **OneToOne) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		OneToOne_Marshal(n, *pv)
	} else if !enc {
		var v OneToOne
		if OneToOne_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func OneToOne_Marshal(n jsn.Marshaler, val *OneToOne) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(OneToOne_Type,
		OneToOne_Type)); okay {
		if n.MarshalKey("", OneToOne_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		if n.MarshalKey("other_kind", OneToOne_Field_OtherKind) {
			SingularKind_Marshal(n, &val.OtherKind)
		}
		n.EndBlock()
	}
	return
}

// PairedAction
type PairedAction struct {
	At    reader.Position `if:"internal"`
	Kinds PluralKinds     `if:"label=_"`
}

func (*PairedAction) Compose() composer.Spec {
	return composer.Spec{
		Name: PairedAction_Type,
		Uses: composer.Type_Flow,
	}
}

const PairedAction_Type = "paired_action"

const PairedAction_Field_Kinds = "$KINDS"

func (op *PairedAction) Marshal(n jsn.Marshaler) {
	PairedAction_Marshal(n, op)
}

type PairedAction_Slice []PairedAction

func (op *PairedAction_Slice) GetType() string { return PairedAction_Type }
func (op *PairedAction_Slice) GetSize() int    { return len(*op) }
func (op *PairedAction_Slice) SetSize(cnt int) { (*op) = make(PairedAction_Slice, cnt) }

func PairedAction_Repeats_Marshal(n jsn.Marshaler, vals *[]PairedAction) {
	if n.MarshalBlock((*PairedAction_Slice)(vals)) {
		for i := range *vals {
			PairedAction_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PairedAction_Optional_Marshal(n jsn.Marshaler, pv **PairedAction) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PairedAction_Marshal(n, *pv)
	} else if !enc {
		var v PairedAction
		if PairedAction_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PairedAction_Marshal(n jsn.Marshaler, val *PairedAction) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(PairedAction_Type,
		PairedAction_Type)); okay {
		if n.MarshalKey("", PairedAction_Field_Kinds) {
			PluralKinds_Marshal(n, &val.Kinds)
		}
		n.EndBlock()
	}
	return
}

// Paragraph
type Paragraph struct {
	StoryStatement []StoryStatement `if:"label=_,optional"`
}

func (*Paragraph) Compose() composer.Spec {
	return composer.Spec{
		Name: Paragraph_Type,
		Uses: composer.Type_Flow,
	}
}

const Paragraph_Type = "paragraph"

const Paragraph_Field_StoryStatement = "$STORY_STATEMENT"

func (op *Paragraph) Marshal(n jsn.Marshaler) {
	Paragraph_Marshal(n, op)
}

type Paragraph_Slice []Paragraph

func (op *Paragraph_Slice) GetType() string { return Paragraph_Type }
func (op *Paragraph_Slice) GetSize() int    { return len(*op) }
func (op *Paragraph_Slice) SetSize(cnt int) { (*op) = make(Paragraph_Slice, cnt) }

func Paragraph_Repeats_Marshal(n jsn.Marshaler, vals *[]Paragraph) {
	if n.MarshalBlock((*Paragraph_Slice)(vals)) {
		for i := range *vals {
			Paragraph_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Paragraph_Optional_Marshal(n jsn.Marshaler, pv **Paragraph) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Paragraph_Marshal(n, *pv)
	} else if !enc {
		var v Paragraph
		if Paragraph_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Paragraph_Marshal(n jsn.Marshaler, val *Paragraph) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Paragraph_Type,
		Paragraph_Type)); okay {
		if n.MarshalKey("", Paragraph_Field_StoryStatement) {
			StoryStatement_Repeats_Marshal(n, &val.StoryStatement)
		}
		n.EndBlock()
	}
	return
}

// PatternActions Actions to take when using a pattern.
// User implements: StoryStatement.
type PatternActions struct {
	Name          value.PatternName `if:"label=_"`
	PatternLocals *PatternLocals    `if:"label=pattern_locals,optional"`
	PatternReturn *PatternReturn    `if:"label=pattern_return,optional"`
	PatternRules  PatternRules      `if:"label=pattern_rules"`
}

func (*PatternActions) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternActions_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternActions_Type = "pattern_actions"

const PatternActions_Field_Name = "$NAME"
const PatternActions_Field_PatternLocals = "$PATTERN_LOCALS"
const PatternActions_Field_PatternReturn = "$PATTERN_RETURN"
const PatternActions_Field_PatternRules = "$PATTERN_RULES"

func (op *PatternActions) Marshal(n jsn.Marshaler) {
	PatternActions_Marshal(n, op)
}

type PatternActions_Slice []PatternActions

func (op *PatternActions_Slice) GetType() string { return PatternActions_Type }
func (op *PatternActions_Slice) GetSize() int    { return len(*op) }
func (op *PatternActions_Slice) SetSize(cnt int) { (*op) = make(PatternActions_Slice, cnt) }

func PatternActions_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternActions) {
	if n.MarshalBlock((*PatternActions_Slice)(vals)) {
		for i := range *vals {
			PatternActions_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PatternActions_Optional_Marshal(n jsn.Marshaler, pv **PatternActions) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PatternActions_Marshal(n, *pv)
	} else if !enc {
		var v PatternActions
		if PatternActions_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PatternActions_Marshal(n jsn.Marshaler, val *PatternActions) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PatternActions_Type,
		PatternActions_Type)); okay {
		if n.MarshalKey("", PatternActions_Field_Name) {
			value.PatternName_Marshal(n, &val.Name)
		}
		if n.MarshalKey("pattern_locals", PatternActions_Field_PatternLocals) {
			PatternLocals_Optional_Marshal(n, &val.PatternLocals)
		}
		if n.MarshalKey("pattern_return", PatternActions_Field_PatternReturn) {
			PatternReturn_Optional_Marshal(n, &val.PatternReturn)
		}
		if n.MarshalKey("pattern_rules", PatternActions_Field_PatternRules) {
			PatternRules_Marshal(n, &val.PatternRules)
		}
		n.EndBlock()
	}
	return
}

// PatternDecl
// User implements: StoryStatement.
type PatternDecl struct {
	Type          PatternType           `if:"label=_"`
	Name          value.PatternName     `if:"label=name"`
	Optvars       *PatternVariablesTail `if:"label=optvars,optional"`
	PatternReturn *PatternReturn        `if:"label=pattern_return,optional"`
	About         *Comment              `if:"label=about,optional"`
}

func (*PatternDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternDecl_Type = "pattern_decl"

const PatternDecl_Field_Type = "$TYPE"
const PatternDecl_Field_Name = "$NAME"
const PatternDecl_Field_Optvars = "$OPTVARS"
const PatternDecl_Field_PatternReturn = "$PATTERN_RETURN"
const PatternDecl_Field_About = "$ABOUT"

func (op *PatternDecl) Marshal(n jsn.Marshaler) {
	PatternDecl_Marshal(n, op)
}

type PatternDecl_Slice []PatternDecl

func (op *PatternDecl_Slice) GetType() string { return PatternDecl_Type }
func (op *PatternDecl_Slice) GetSize() int    { return len(*op) }
func (op *PatternDecl_Slice) SetSize(cnt int) { (*op) = make(PatternDecl_Slice, cnt) }

func PatternDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternDecl) {
	if n.MarshalBlock((*PatternDecl_Slice)(vals)) {
		for i := range *vals {
			PatternDecl_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PatternDecl_Optional_Marshal(n jsn.Marshaler, pv **PatternDecl) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PatternDecl_Marshal(n, *pv)
	} else if !enc {
		var v PatternDecl
		if PatternDecl_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PatternDecl_Marshal(n jsn.Marshaler, val *PatternDecl) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PatternDecl_Type,
		PatternDecl_Type)); okay {
		if n.MarshalKey("", PatternDecl_Field_Type) {
			PatternType_Marshal(n, &val.Type)
		}
		if n.MarshalKey("name", PatternDecl_Field_Name) {
			value.PatternName_Marshal(n, &val.Name)
		}
		if n.MarshalKey("optvars", PatternDecl_Field_Optvars) {
			PatternVariablesTail_Optional_Marshal(n, &val.Optvars)
		}
		if n.MarshalKey("pattern_return", PatternDecl_Field_PatternReturn) {
			PatternReturn_Optional_Marshal(n, &val.PatternReturn)
		}
		if n.MarshalKey("about", PatternDecl_Field_About) {
			Comment_Optional_Marshal(n, &val.About)
		}
		n.EndBlock()
	}
	return
}

// PatternFlags requires a user-specified string.
type PatternFlags struct {
	Str string
}

func (op *PatternFlags) String() string {
	return op.Str
}

const PatternFlags_Before = "$BEFORE"
const PatternFlags_After = "$AFTER"
const PatternFlags_Terminate = "$TERMINATE"

func (*PatternFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternFlags_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			PatternFlags_Before, PatternFlags_After, PatternFlags_Terminate,
		},
		Strings: []string{
			"before", "after", "terminate",
		},
	}
}

const PatternFlags_Type = "pattern_flags"

func (op *PatternFlags) Marshal(n jsn.Marshaler) {
	PatternFlags_Marshal(n, op)
}

func PatternFlags_Optional_Marshal(n jsn.Marshaler, val *PatternFlags) {
	var zero PatternFlags
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		PatternFlags_Marshal(n, val)
	}
}

func PatternFlags_Marshal(n jsn.Marshaler, val *PatternFlags) {
	n.MarshalValue(PatternFlags_Type, jsn.MakeEnum(val, &val.Str))
}

type PatternFlags_Slice []PatternFlags

func (op *PatternFlags_Slice) GetType() string { return PatternFlags_Type }
func (op *PatternFlags_Slice) GetSize() int    { return len(*op) }
func (op *PatternFlags_Slice) SetSize(cnt int) { (*op) = make(PatternFlags_Slice, cnt) }

func PatternFlags_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternFlags) {
	if n.MarshalBlock((*PatternFlags_Slice)(vals)) {
		for i := range *vals {
			PatternFlags_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// PatternLocals
type PatternLocals struct {
	LocalDecl []LocalDecl `if:"label=_"`
}

func (*PatternLocals) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternLocals_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternLocals_Type = "pattern_locals"

const PatternLocals_Field_LocalDecl = "$LOCAL_DECL"

func (op *PatternLocals) Marshal(n jsn.Marshaler) {
	PatternLocals_Marshal(n, op)
}

type PatternLocals_Slice []PatternLocals

func (op *PatternLocals_Slice) GetType() string { return PatternLocals_Type }
func (op *PatternLocals_Slice) GetSize() int    { return len(*op) }
func (op *PatternLocals_Slice) SetSize(cnt int) { (*op) = make(PatternLocals_Slice, cnt) }

func PatternLocals_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternLocals) {
	if n.MarshalBlock((*PatternLocals_Slice)(vals)) {
		for i := range *vals {
			PatternLocals_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PatternLocals_Optional_Marshal(n jsn.Marshaler, pv **PatternLocals) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PatternLocals_Marshal(n, *pv)
	} else if !enc {
		var v PatternLocals
		if PatternLocals_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PatternLocals_Marshal(n jsn.Marshaler, val *PatternLocals) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PatternLocals_Type,
		PatternLocals_Type)); okay {
		if n.MarshalKey("", PatternLocals_Field_LocalDecl) {
			LocalDecl_Repeats_Marshal(n, &val.LocalDecl)
		}
		n.EndBlock()
	}
	return
}

// PatternReturn
type PatternReturn struct {
	Result VariableDecl `if:"label=_"`
}

func (*PatternReturn) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternReturn_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternReturn_Type = "pattern_return"

const PatternReturn_Field_Result = "$RESULT"

func (op *PatternReturn) Marshal(n jsn.Marshaler) {
	PatternReturn_Marshal(n, op)
}

type PatternReturn_Slice []PatternReturn

func (op *PatternReturn_Slice) GetType() string { return PatternReturn_Type }
func (op *PatternReturn_Slice) GetSize() int    { return len(*op) }
func (op *PatternReturn_Slice) SetSize(cnt int) { (*op) = make(PatternReturn_Slice, cnt) }

func PatternReturn_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternReturn) {
	if n.MarshalBlock((*PatternReturn_Slice)(vals)) {
		for i := range *vals {
			PatternReturn_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PatternReturn_Optional_Marshal(n jsn.Marshaler, pv **PatternReturn) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PatternReturn_Marshal(n, *pv)
	} else if !enc {
		var v PatternReturn
		if PatternReturn_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PatternReturn_Marshal(n jsn.Marshaler, val *PatternReturn) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PatternReturn_Type,
		PatternReturn_Type)); okay {
		if n.MarshalKey("", PatternReturn_Field_Result) {
			VariableDecl_Marshal(n, &val.Result)
		}
		n.EndBlock()
	}
	return
}

// PatternRule
type PatternRule struct {
	Guard rt.BoolEval  `if:"label=_"`
	Flags PatternFlags `if:"label=flags,optional"`
	Hook  ProgramHook  `if:"label=hook"`
}

func (*PatternRule) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternRule_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternRule_Type = "pattern_rule"

const PatternRule_Field_Guard = "$GUARD"
const PatternRule_Field_Flags = "$FLAGS"
const PatternRule_Field_Hook = "$HOOK"

func (op *PatternRule) Marshal(n jsn.Marshaler) {
	PatternRule_Marshal(n, op)
}

type PatternRule_Slice []PatternRule

func (op *PatternRule_Slice) GetType() string { return PatternRule_Type }
func (op *PatternRule_Slice) GetSize() int    { return len(*op) }
func (op *PatternRule_Slice) SetSize(cnt int) { (*op) = make(PatternRule_Slice, cnt) }

func PatternRule_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternRule) {
	if n.MarshalBlock((*PatternRule_Slice)(vals)) {
		for i := range *vals {
			PatternRule_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PatternRule_Optional_Marshal(n jsn.Marshaler, pv **PatternRule) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PatternRule_Marshal(n, *pv)
	} else if !enc {
		var v PatternRule
		if PatternRule_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PatternRule_Marshal(n jsn.Marshaler, val *PatternRule) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PatternRule_Type,
		PatternRule_Type)); okay {
		if n.MarshalKey("", PatternRule_Field_Guard) {
			rt.BoolEval_Marshal(n, &val.Guard)
		}
		if n.MarshalKey("flags", PatternRule_Field_Flags) {
			PatternFlags_Optional_Marshal(n, &val.Flags)
		}
		if n.MarshalKey("hook", PatternRule_Field_Hook) {
			ProgramHook_Marshal(n, &val.Hook)
		}
		n.EndBlock()
	}
	return
}

// PatternRules
type PatternRules struct {
	PatternRule []PatternRule `if:"label=_,optional"`
}

func (*PatternRules) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternRules_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternRules_Type = "pattern_rules"

const PatternRules_Field_PatternRule = "$PATTERN_RULE"

func (op *PatternRules) Marshal(n jsn.Marshaler) {
	PatternRules_Marshal(n, op)
}

type PatternRules_Slice []PatternRules

func (op *PatternRules_Slice) GetType() string { return PatternRules_Type }
func (op *PatternRules_Slice) GetSize() int    { return len(*op) }
func (op *PatternRules_Slice) SetSize(cnt int) { (*op) = make(PatternRules_Slice, cnt) }

func PatternRules_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternRules) {
	if n.MarshalBlock((*PatternRules_Slice)(vals)) {
		for i := range *vals {
			PatternRules_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PatternRules_Optional_Marshal(n jsn.Marshaler, pv **PatternRules) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PatternRules_Marshal(n, *pv)
	} else if !enc {
		var v PatternRules
		if PatternRules_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PatternRules_Marshal(n jsn.Marshaler, val *PatternRules) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PatternRules_Type,
		PatternRules_Type)); okay {
		if n.MarshalKey("", PatternRules_Field_PatternRule) {
			PatternRule_Repeats_Marshal(n, &val.PatternRule)
		}
		n.EndBlock()
	}
	return
}

// PatternType requires a user-specified string.
type PatternType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PatternType) String() string {
	return op.Str
}

const PatternType_Patterns = "$PATTERNS"
const PatternType_Actions = "$ACTIONS"
const PatternType_Events = "$EVENTS"

func (*PatternType) Compose() composer.Spec {
	return composer.Spec{
		Name:        PatternType_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			PatternType_Patterns, PatternType_Actions, PatternType_Events,
		},
		Strings: []string{
			"patterns", "actions", "events",
		},
	}
}

const PatternType_Type = "pattern_type"

func (op *PatternType) Marshal(n jsn.Marshaler) {
	PatternType_Marshal(n, op)
}

func PatternType_Optional_Marshal(n jsn.Marshaler, val *PatternType) {
	var zero PatternType
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		PatternType_Marshal(n, val)
	}
}

func PatternType_Marshal(n jsn.Marshaler, val *PatternType) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(PatternType_Type, jsn.MakeEnum(val, &val.Str))
}

type PatternType_Slice []PatternType

func (op *PatternType_Slice) GetType() string { return PatternType_Type }
func (op *PatternType_Slice) GetSize() int    { return len(*op) }
func (op *PatternType_Slice) SetSize(cnt int) { (*op) = make(PatternType_Slice, cnt) }

func PatternType_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternType) {
	if n.MarshalBlock((*PatternType_Slice)(vals)) {
		for i := range *vals {
			PatternType_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// PatternVariablesDecl Values provided when calling a pattern.
// User implements: StoryStatement.
type PatternVariablesDecl struct {
	PatternName  value.PatternName `if:"label=_"`
	VariableDecl []VariableDecl    `if:"label=variable_decl"`
}

func (*PatternVariablesDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternVariablesDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternVariablesDecl_Type = "pattern_variables_decl"

const PatternVariablesDecl_Field_PatternName = "$PATTERN_NAME"
const PatternVariablesDecl_Field_VariableDecl = "$VARIABLE_DECL"

func (op *PatternVariablesDecl) Marshal(n jsn.Marshaler) {
	PatternVariablesDecl_Marshal(n, op)
}

type PatternVariablesDecl_Slice []PatternVariablesDecl

func (op *PatternVariablesDecl_Slice) GetType() string { return PatternVariablesDecl_Type }
func (op *PatternVariablesDecl_Slice) GetSize() int    { return len(*op) }
func (op *PatternVariablesDecl_Slice) SetSize(cnt int) { (*op) = make(PatternVariablesDecl_Slice, cnt) }

func PatternVariablesDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternVariablesDecl) {
	if n.MarshalBlock((*PatternVariablesDecl_Slice)(vals)) {
		for i := range *vals {
			PatternVariablesDecl_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PatternVariablesDecl_Optional_Marshal(n jsn.Marshaler, pv **PatternVariablesDecl) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PatternVariablesDecl_Marshal(n, *pv)
	} else if !enc {
		var v PatternVariablesDecl
		if PatternVariablesDecl_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PatternVariablesDecl_Marshal(n jsn.Marshaler, val *PatternVariablesDecl) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PatternVariablesDecl_Type,
		PatternVariablesDecl_Type)); okay {
		if n.MarshalKey("", PatternVariablesDecl_Field_PatternName) {
			value.PatternName_Marshal(n, &val.PatternName)
		}
		if n.MarshalKey("variable_decl", PatternVariablesDecl_Field_VariableDecl) {
			VariableDecl_Repeats_Marshal(n, &val.VariableDecl)
		}
		n.EndBlock()
	}
	return
}

// PatternVariablesTail Storage for values used during the execution of a pattern.
type PatternVariablesTail struct {
	VariableDecl []VariableDecl `if:"label=_"`
}

func (*PatternVariablesTail) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternVariablesTail_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternVariablesTail_Type = "pattern_variables_tail"

const PatternVariablesTail_Field_VariableDecl = "$VARIABLE_DECL"

func (op *PatternVariablesTail) Marshal(n jsn.Marshaler) {
	PatternVariablesTail_Marshal(n, op)
}

type PatternVariablesTail_Slice []PatternVariablesTail

func (op *PatternVariablesTail_Slice) GetType() string { return PatternVariablesTail_Type }
func (op *PatternVariablesTail_Slice) GetSize() int    { return len(*op) }
func (op *PatternVariablesTail_Slice) SetSize(cnt int) { (*op) = make(PatternVariablesTail_Slice, cnt) }

func PatternVariablesTail_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternVariablesTail) {
	if n.MarshalBlock((*PatternVariablesTail_Slice)(vals)) {
		for i := range *vals {
			PatternVariablesTail_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PatternVariablesTail_Optional_Marshal(n jsn.Marshaler, pv **PatternVariablesTail) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PatternVariablesTail_Marshal(n, *pv)
	} else if !enc {
		var v PatternVariablesTail
		if PatternVariablesTail_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PatternVariablesTail_Marshal(n jsn.Marshaler, val *PatternVariablesTail) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PatternVariablesTail_Type,
		PatternVariablesTail_Type)); okay {
		if n.MarshalKey("", PatternVariablesTail_Field_VariableDecl) {
			VariableDecl_Repeats_Marshal(n, &val.VariableDecl)
		}
		n.EndBlock()
	}
	return
}

// PluralKinds requires a user-specified string.
type PluralKinds struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PluralKinds) String() string {
	return op.Str
}

func (*PluralKinds) Compose() composer.Spec {
	return composer.Spec{
		Name:        PluralKinds_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const PluralKinds_Type = "plural_kinds"

func (op *PluralKinds) Marshal(n jsn.Marshaler) {
	PluralKinds_Marshal(n, op)
}

func PluralKinds_Optional_Marshal(n jsn.Marshaler, val *PluralKinds) {
	var zero PluralKinds
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		PluralKinds_Marshal(n, val)
	}
}

func PluralKinds_Marshal(n jsn.Marshaler, val *PluralKinds) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(PluralKinds_Type, &val.Str)
}

type PluralKinds_Slice []PluralKinds

func (op *PluralKinds_Slice) GetType() string { return PluralKinds_Type }
func (op *PluralKinds_Slice) GetSize() int    { return len(*op) }
func (op *PluralKinds_Slice) SetSize(cnt int) { (*op) = make(PluralKinds_Slice, cnt) }

func PluralKinds_Repeats_Marshal(n jsn.Marshaler, vals *[]PluralKinds) {
	if n.MarshalBlock((*PluralKinds_Slice)(vals)) {
		for i := range *vals {
			PluralKinds_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// PrimitiveType requires a user-specified string.
type PrimitiveType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PrimitiveType) String() string {
	return op.Str
}

const PrimitiveType_Number = "$NUMBER"
const PrimitiveType_Text = "$TEXT"
const PrimitiveType_Bool = "$BOOL"

func (*PrimitiveType) Compose() composer.Spec {
	return composer.Spec{
		Name: PrimitiveType_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			PrimitiveType_Number, PrimitiveType_Text, PrimitiveType_Bool,
		},
		Strings: []string{
			"number", "text", "bool",
		},
	}
}

const PrimitiveType_Type = "primitive_type"

func (op *PrimitiveType) Marshal(n jsn.Marshaler) {
	PrimitiveType_Marshal(n, op)
}

func PrimitiveType_Optional_Marshal(n jsn.Marshaler, val *PrimitiveType) {
	var zero PrimitiveType
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		PrimitiveType_Marshal(n, val)
	}
}

func PrimitiveType_Marshal(n jsn.Marshaler, val *PrimitiveType) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(PrimitiveType_Type, jsn.MakeEnum(val, &val.Str))
}

type PrimitiveType_Slice []PrimitiveType

func (op *PrimitiveType_Slice) GetType() string { return PrimitiveType_Type }
func (op *PrimitiveType_Slice) GetSize() int    { return len(*op) }
func (op *PrimitiveType_Slice) SetSize(cnt int) { (*op) = make(PrimitiveType_Slice, cnt) }

func PrimitiveType_Repeats_Marshal(n jsn.Marshaler, vals *[]PrimitiveType) {
	if n.MarshalBlock((*PrimitiveType_Slice)(vals)) {
		for i := range *vals {
			PrimitiveType_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// PrimitiveValue swaps between various options
type PrimitiveValue struct {
	Opt interface{}
}

const PrimitiveValue_BoxedText_Opt = "$BOXED_TEXT"
const PrimitiveValue_BoxedNumber_Opt = "$BOXED_NUMBER"

func (*PrimitiveValue) Compose() composer.Spec {
	return composer.Spec{
		Name: PrimitiveValue_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			PrimitiveValue_BoxedText_Opt, PrimitiveValue_BoxedNumber_Opt,
		},
		Swaps: []interface{}{
			(*BoxedText)(nil),
			(*BoxedNumber)(nil),
		},
	}
}

const PrimitiveValue_Type = "primitive_value"

func (op *PrimitiveValue) GetType() string { return PrimitiveValue_Type }

func (op *PrimitiveValue) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *BoxedText:
		ret, okay = PrimitiveValue_BoxedText_Opt, true
	case *BoxedNumber:
		ret, okay = PrimitiveValue_BoxedNumber_Opt, true
	}
	return
}

func (op *PrimitiveValue) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case PrimitiveValue_BoxedText_Opt:
		opt := new(BoxedText)
		op.Opt, ret, okay = opt, opt, true
	case PrimitiveValue_BoxedNumber_Opt:
		opt := new(BoxedNumber)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *PrimitiveValue) Marshal(n jsn.Marshaler) {
	PrimitiveValue_Marshal(n, op)
}
func PrimitiveValue_Marshal(n jsn.Marshaler, val *PrimitiveValue) {
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type PrimitiveValue_Slice []PrimitiveValue

func (op *PrimitiveValue_Slice) GetType() string { return PrimitiveValue_Type }
func (op *PrimitiveValue_Slice) GetSize() int    { return len(*op) }
func (op *PrimitiveValue_Slice) SetSize(cnt int) { (*op) = make(PrimitiveValue_Slice, cnt) }

func PrimitiveValue_Repeats_Marshal(n jsn.Marshaler, vals *[]PrimitiveValue) {
	if n.MarshalBlock((*PrimitiveValue_Slice)(vals)) {
		for i := range *vals {
			PrimitiveValue_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// ProgramHook swaps between various options
type ProgramHook struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ProgramHook_Activity_Opt = "$ACTIVITY"

func (*ProgramHook) Compose() composer.Spec {
	return composer.Spec{
		Name: ProgramHook_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			ProgramHook_Activity_Opt,
		},
		Swaps: []interface{}{
			(*core.Activity)(nil),
		},
	}
}

const ProgramHook_Type = "program_hook"

func (op *ProgramHook) GetType() string { return ProgramHook_Type }

func (op *ProgramHook) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *core.Activity:
		ret, okay = ProgramHook_Activity_Opt, true
	}
	return
}

func (op *ProgramHook) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case ProgramHook_Activity_Opt:
		opt := new(core.Activity)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *ProgramHook) Marshal(n jsn.Marshaler) {
	ProgramHook_Marshal(n, op)
}
func ProgramHook_Marshal(n jsn.Marshaler, val *ProgramHook) {
	n.SetCursor(val.At.Offset)
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type ProgramHook_Slice []ProgramHook

func (op *ProgramHook_Slice) GetType() string { return ProgramHook_Type }
func (op *ProgramHook_Slice) GetSize() int    { return len(*op) }
func (op *ProgramHook_Slice) SetSize(cnt int) { (*op) = make(ProgramHook_Slice, cnt) }

func ProgramHook_Repeats_Marshal(n jsn.Marshaler, vals *[]ProgramHook) {
	if n.MarshalBlock((*ProgramHook_Slice)(vals)) {
		for i := range *vals {
			ProgramHook_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// Pronoun requires a user-specified string.
type Pronoun struct {
	Str string
}

func (op *Pronoun) String() string {
	return op.Str
}

const Pronoun_It = "$IT"
const Pronoun_They = "$THEY"

func (*Pronoun) Compose() composer.Spec {
	return composer.Spec{
		Name:        Pronoun_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			Pronoun_It, Pronoun_They,
		},
		Strings: []string{
			"it", "they",
		},
	}
}

const Pronoun_Type = "pronoun"

func (op *Pronoun) Marshal(n jsn.Marshaler) {
	Pronoun_Marshal(n, op)
}

func Pronoun_Optional_Marshal(n jsn.Marshaler, val *Pronoun) {
	var zero Pronoun
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		Pronoun_Marshal(n, val)
	}
}

func Pronoun_Marshal(n jsn.Marshaler, val *Pronoun) {
	n.MarshalValue(Pronoun_Type, jsn.MakeEnum(val, &val.Str))
}

type Pronoun_Slice []Pronoun

func (op *Pronoun_Slice) GetType() string { return Pronoun_Type }
func (op *Pronoun_Slice) GetSize() int    { return len(*op) }
func (op *Pronoun_Slice) SetSize(cnt int) { (*op) = make(Pronoun_Slice, cnt) }

func Pronoun_Repeats_Marshal(n jsn.Marshaler, vals *[]Pronoun) {
	if n.MarshalBlock((*Pronoun_Slice)(vals)) {
		for i := range *vals {
			Pronoun_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// Property requires a user-specified string.
type Property struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Property) String() string {
	return op.Str
}

func (*Property) Compose() composer.Spec {
	return composer.Spec{
		Name:        Property_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Property_Type = "property"

func (op *Property) Marshal(n jsn.Marshaler) {
	Property_Marshal(n, op)
}

func Property_Optional_Marshal(n jsn.Marshaler, val *Property) {
	var zero Property
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		Property_Marshal(n, val)
	}
}

func Property_Marshal(n jsn.Marshaler, val *Property) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(Property_Type, &val.Str)
}

type Property_Slice []Property

func (op *Property_Slice) GetType() string { return Property_Type }
func (op *Property_Slice) GetSize() int    { return len(*op) }
func (op *Property_Slice) SetSize(cnt int) { (*op) = make(Property_Slice, cnt) }

func Property_Repeats_Marshal(n jsn.Marshaler, vals *[]Property) {
	if n.MarshalBlock((*Property_Slice)(vals)) {
		for i := range *vals {
			Property_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// PropertyAspect requires a user-specified string.
type PropertyAspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PropertyAspect) String() string {
	return op.Str
}

const PropertyAspect_Aspect = "$ASPECT"

func (*PropertyAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: PropertyAspect_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			PropertyAspect_Aspect,
		},
		Strings: []string{
			"aspect",
		},
	}
}

const PropertyAspect_Type = "property_aspect"

func (op *PropertyAspect) Marshal(n jsn.Marshaler) {
	PropertyAspect_Marshal(n, op)
}

func PropertyAspect_Optional_Marshal(n jsn.Marshaler, val *PropertyAspect) {
	var zero PropertyAspect
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		PropertyAspect_Marshal(n, val)
	}
}

func PropertyAspect_Marshal(n jsn.Marshaler, val *PropertyAspect) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(PropertyAspect_Type, jsn.MakeEnum(val, &val.Str))
}

type PropertyAspect_Slice []PropertyAspect

func (op *PropertyAspect_Slice) GetType() string { return PropertyAspect_Type }
func (op *PropertyAspect_Slice) GetSize() int    { return len(*op) }
func (op *PropertyAspect_Slice) SetSize(cnt int) { (*op) = make(PropertyAspect_Slice, cnt) }

func PropertyAspect_Repeats_Marshal(n jsn.Marshaler, vals *[]PropertyAspect) {
	if n.MarshalBlock((*PropertyAspect_Slice)(vals)) {
		for i := range *vals {
			PropertyAspect_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// PropertyDecl
type PropertyDecl struct {
	An           Determiner   `if:"label=_"`
	Property     Property     `if:"label=property"`
	PropertyType PropertyType `if:"label=property_type"`
	Comment      value.Lines  `if:"label=comment,optional"`
}

func (*PropertyDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: PropertyDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const PropertyDecl_Type = "property_decl"

const PropertyDecl_Field_An = "$AN"
const PropertyDecl_Field_Property = "$PROPERTY"
const PropertyDecl_Field_PropertyType = "$PROPERTY_TYPE"
const PropertyDecl_Field_Comment = "$COMMENT"

func (op *PropertyDecl) Marshal(n jsn.Marshaler) {
	PropertyDecl_Marshal(n, op)
}

type PropertyDecl_Slice []PropertyDecl

func (op *PropertyDecl_Slice) GetType() string { return PropertyDecl_Type }
func (op *PropertyDecl_Slice) GetSize() int    { return len(*op) }
func (op *PropertyDecl_Slice) SetSize(cnt int) { (*op) = make(PropertyDecl_Slice, cnt) }

func PropertyDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]PropertyDecl) {
	if n.MarshalBlock((*PropertyDecl_Slice)(vals)) {
		for i := range *vals {
			PropertyDecl_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func PropertyDecl_Optional_Marshal(n jsn.Marshaler, pv **PropertyDecl) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		PropertyDecl_Marshal(n, *pv)
	} else if !enc {
		var v PropertyDecl
		if PropertyDecl_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func PropertyDecl_Marshal(n jsn.Marshaler, val *PropertyDecl) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(PropertyDecl_Type,
		PropertyDecl_Type)); okay {
		if n.MarshalKey("", PropertyDecl_Field_An) {
			Determiner_Marshal(n, &val.An)
		}
		if n.MarshalKey("property", PropertyDecl_Field_Property) {
			Property_Marshal(n, &val.Property)
		}
		if n.MarshalKey("property_type", PropertyDecl_Field_PropertyType) {
			PropertyType_Marshal(n, &val.PropertyType)
		}
		if n.MarshalKey("comment", PropertyDecl_Field_Comment) {
			value.Lines_Optional_Marshal(n, &val.Comment)
		}
		n.EndBlock()
	}
	return
}

// PropertyType swaps between various options
type PropertyType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const PropertyType_PropertyAspect_Opt = "$PROPERTY_ASPECT"
const PropertyType_Primitive_Opt = "$PRIMITIVE"
const PropertyType_Ext_Opt = "$EXT"

func (*PropertyType) Compose() composer.Spec {
	return composer.Spec{
		Name: PropertyType_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			PropertyType_PropertyAspect_Opt, PropertyType_Primitive_Opt, PropertyType_Ext_Opt,
		},
		Swaps: []interface{}{
			(*PropertyAspect)(nil),
			(*PrimitiveType)(nil),
			(*ExtType)(nil),
		},
	}
}

const PropertyType_Type = "property_type"

func (op *PropertyType) GetType() string { return PropertyType_Type }

func (op *PropertyType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PropertyAspect:
		ret, okay = PropertyType_PropertyAspect_Opt, true
	case *PrimitiveType:
		ret, okay = PropertyType_Primitive_Opt, true
	case *ExtType:
		ret, okay = PropertyType_Ext_Opt, true
	}
	return
}

func (op *PropertyType) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case PropertyType_PropertyAspect_Opt:
		opt := new(PropertyAspect)
		op.Opt, ret, okay = opt, opt, true
	case PropertyType_Primitive_Opt:
		opt := new(PrimitiveType)
		op.Opt, ret, okay = opt, opt, true
	case PropertyType_Ext_Opt:
		opt := new(ExtType)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *PropertyType) Marshal(n jsn.Marshaler) {
	PropertyType_Marshal(n, op)
}
func PropertyType_Marshal(n jsn.Marshaler, val *PropertyType) {
	n.SetCursor(val.At.Offset)
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type PropertyType_Slice []PropertyType

func (op *PropertyType_Slice) GetType() string { return PropertyType_Type }
func (op *PropertyType_Slice) GetSize() int    { return len(*op) }
func (op *PropertyType_Slice) SetSize(cnt int) { (*op) = make(PropertyType_Slice, cnt) }

func PropertyType_Repeats_Marshal(n jsn.Marshaler, vals *[]PropertyType) {
	if n.MarshalBlock((*PropertyType_Slice)(vals)) {
		for i := range *vals {
			PropertyType_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// RecordList
type RecordList struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordList) Compose() composer.Spec {
	return composer.Spec{
		Name: RecordList_Type,
		Uses: composer.Type_Flow,
	}
}

const RecordList_Type = "record_list"

const RecordList_Field_Kind = "$KIND"

func (op *RecordList) Marshal(n jsn.Marshaler) {
	RecordList_Marshal(n, op)
}

type RecordList_Slice []RecordList

func (op *RecordList_Slice) GetType() string { return RecordList_Type }
func (op *RecordList_Slice) GetSize() int    { return len(*op) }
func (op *RecordList_Slice) SetSize(cnt int) { (*op) = make(RecordList_Slice, cnt) }

func RecordList_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordList) {
	if n.MarshalBlock((*RecordList_Slice)(vals)) {
		for i := range *vals {
			RecordList_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func RecordList_Optional_Marshal(n jsn.Marshaler, pv **RecordList) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		RecordList_Marshal(n, *pv)
	} else if !enc {
		var v RecordList
		if RecordList_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func RecordList_Marshal(n jsn.Marshaler, val *RecordList) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(RecordList_Type,
		RecordList_Type)); okay {
		if n.MarshalKey("", RecordList_Field_Kind) {
			RecordSingular_Marshal(n, &val.Kind)
		}
		n.EndBlock()
	}
	return
}

// RecordPlural requires a user-specified string.
type RecordPlural struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordPlural) String() string {
	return op.Str
}

func (*RecordPlural) Compose() composer.Spec {
	return composer.Spec{
		Name:        RecordPlural_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const RecordPlural_Type = "record_plural"

func (op *RecordPlural) Marshal(n jsn.Marshaler) {
	RecordPlural_Marshal(n, op)
}

func RecordPlural_Optional_Marshal(n jsn.Marshaler, val *RecordPlural) {
	var zero RecordPlural
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		RecordPlural_Marshal(n, val)
	}
}

func RecordPlural_Marshal(n jsn.Marshaler, val *RecordPlural) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(RecordPlural_Type, &val.Str)
}

type RecordPlural_Slice []RecordPlural

func (op *RecordPlural_Slice) GetType() string { return RecordPlural_Type }
func (op *RecordPlural_Slice) GetSize() int    { return len(*op) }
func (op *RecordPlural_Slice) SetSize(cnt int) { (*op) = make(RecordPlural_Slice, cnt) }

func RecordPlural_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordPlural) {
	if n.MarshalBlock((*RecordPlural_Slice)(vals)) {
		for i := range *vals {
			RecordPlural_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// RecordSingular requires a user-specified string.
type RecordSingular struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordSingular) String() string {
	return op.Str
}

func (*RecordSingular) Compose() composer.Spec {
	return composer.Spec{
		Name:        RecordSingular_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const RecordSingular_Type = "record_singular"

func (op *RecordSingular) Marshal(n jsn.Marshaler) {
	RecordSingular_Marshal(n, op)
}

func RecordSingular_Optional_Marshal(n jsn.Marshaler, val *RecordSingular) {
	var zero RecordSingular
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		RecordSingular_Marshal(n, val)
	}
}

func RecordSingular_Marshal(n jsn.Marshaler, val *RecordSingular) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(RecordSingular_Type, &val.Str)
}

type RecordSingular_Slice []RecordSingular

func (op *RecordSingular_Slice) GetType() string { return RecordSingular_Type }
func (op *RecordSingular_Slice) GetSize() int    { return len(*op) }
func (op *RecordSingular_Slice) SetSize(cnt int) { (*op) = make(RecordSingular_Slice, cnt) }

func RecordSingular_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordSingular) {
	if n.MarshalBlock((*RecordSingular_Slice)(vals)) {
		for i := range *vals {
			RecordSingular_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// RecordType
type RecordType struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordType) Compose() composer.Spec {
	return composer.Spec{
		Name: RecordType_Type,
		Uses: composer.Type_Flow,
	}
}

const RecordType_Type = "record_type"

const RecordType_Field_Kind = "$KIND"

func (op *RecordType) Marshal(n jsn.Marshaler) {
	RecordType_Marshal(n, op)
}

type RecordType_Slice []RecordType

func (op *RecordType_Slice) GetType() string { return RecordType_Type }
func (op *RecordType_Slice) GetSize() int    { return len(*op) }
func (op *RecordType_Slice) SetSize(cnt int) { (*op) = make(RecordType_Slice, cnt) }

func RecordType_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordType) {
	if n.MarshalBlock((*RecordType_Slice)(vals)) {
		for i := range *vals {
			RecordType_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func RecordType_Optional_Marshal(n jsn.Marshaler, pv **RecordType) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		RecordType_Marshal(n, *pv)
	} else if !enc {
		var v RecordType
		if RecordType_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func RecordType_Marshal(n jsn.Marshaler, val *RecordType) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(RecordType_Type,
		RecordType_Type)); okay {
		if n.MarshalKey("", RecordType_Field_Kind) {
			RecordSingular_Marshal(n, &val.Kind)
		}
		n.EndBlock()
	}
	return
}

// RecordsPossessProperties
// User implements: StoryStatement.
type RecordsPossessProperties struct {
	RecordPlural RecordPlural   `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*RecordsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: RecordsPossessProperties_Type,
		Uses: composer.Type_Flow,
	}
}

const RecordsPossessProperties_Type = "records_possess_properties"

const RecordsPossessProperties_Field_RecordPlural = "$RECORD_PLURAL"
const RecordsPossessProperties_Field_PropertyDecl = "$PROPERTY_DECL"

func (op *RecordsPossessProperties) Marshal(n jsn.Marshaler) {
	RecordsPossessProperties_Marshal(n, op)
}

type RecordsPossessProperties_Slice []RecordsPossessProperties

func (op *RecordsPossessProperties_Slice) GetType() string { return RecordsPossessProperties_Type }
func (op *RecordsPossessProperties_Slice) GetSize() int    { return len(*op) }
func (op *RecordsPossessProperties_Slice) SetSize(cnt int) {
	(*op) = make(RecordsPossessProperties_Slice, cnt)
}

func RecordsPossessProperties_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordsPossessProperties) {
	if n.MarshalBlock((*RecordsPossessProperties_Slice)(vals)) {
		for i := range *vals {
			RecordsPossessProperties_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func RecordsPossessProperties_Optional_Marshal(n jsn.Marshaler, pv **RecordsPossessProperties) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		RecordsPossessProperties_Marshal(n, *pv)
	} else if !enc {
		var v RecordsPossessProperties
		if RecordsPossessProperties_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func RecordsPossessProperties_Marshal(n jsn.Marshaler, val *RecordsPossessProperties) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(RecordsPossessProperties_Type,
		RecordsPossessProperties_Type)); okay {
		if n.MarshalKey("", RecordsPossessProperties_Field_RecordPlural) {
			RecordPlural_Marshal(n, &val.RecordPlural)
		}
		if n.MarshalKey("property_decl", RecordsPossessProperties_Field_PropertyDecl) {
			PropertyDecl_Repeats_Marshal(n, &val.PropertyDecl)
		}
		n.EndBlock()
	}
	return
}

// RelationCardinality swaps between various options
type RelationCardinality struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const RelationCardinality_OneToOne_Opt = "$ONE_TO_ONE"
const RelationCardinality_OneToMany_Opt = "$ONE_TO_MANY"
const RelationCardinality_ManyToOne_Opt = "$MANY_TO_ONE"
const RelationCardinality_ManyToMany_Opt = "$MANY_TO_MANY"

func (*RelationCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: RelationCardinality_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			RelationCardinality_OneToOne_Opt, RelationCardinality_OneToMany_Opt, RelationCardinality_ManyToOne_Opt, RelationCardinality_ManyToMany_Opt,
		},
		Swaps: []interface{}{
			(*OneToOne)(nil),
			(*OneToMany)(nil),
			(*ManyToOne)(nil),
			(*ManyToMany)(nil),
		},
	}
}

const RelationCardinality_Type = "relation_cardinality"

func (op *RelationCardinality) GetType() string { return RelationCardinality_Type }

func (op *RelationCardinality) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *OneToOne:
		ret, okay = RelationCardinality_OneToOne_Opt, true
	case *OneToMany:
		ret, okay = RelationCardinality_OneToMany_Opt, true
	case *ManyToOne:
		ret, okay = RelationCardinality_ManyToOne_Opt, true
	case *ManyToMany:
		ret, okay = RelationCardinality_ManyToMany_Opt, true
	}
	return
}

func (op *RelationCardinality) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case RelationCardinality_OneToOne_Opt:
		opt := new(OneToOne)
		op.Opt, ret, okay = opt, opt, true
	case RelationCardinality_OneToMany_Opt:
		opt := new(OneToMany)
		op.Opt, ret, okay = opt, opt, true
	case RelationCardinality_ManyToOne_Opt:
		opt := new(ManyToOne)
		op.Opt, ret, okay = opt, opt, true
	case RelationCardinality_ManyToMany_Opt:
		opt := new(ManyToMany)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *RelationCardinality) Marshal(n jsn.Marshaler) {
	RelationCardinality_Marshal(n, op)
}
func RelationCardinality_Marshal(n jsn.Marshaler, val *RelationCardinality) {
	n.SetCursor(val.At.Offset)
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type RelationCardinality_Slice []RelationCardinality

func (op *RelationCardinality_Slice) GetType() string { return RelationCardinality_Type }
func (op *RelationCardinality_Slice) GetSize() int    { return len(*op) }
func (op *RelationCardinality_Slice) SetSize(cnt int) { (*op) = make(RelationCardinality_Slice, cnt) }

func RelationCardinality_Repeats_Marshal(n jsn.Marshaler, vals *[]RelationCardinality) {
	if n.MarshalBlock((*RelationCardinality_Slice)(vals)) {
		for i := range *vals {
			RelationCardinality_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// RelativeToNoun
// User implements: StoryStatement.
type RelativeToNoun struct {
	Relation value.RelationName `if:"label=_"`
	Nouns    []NamedNoun        `if:"label=nouns"`
	AreBeing AreBeing           `if:"label=are_being"`
	Nouns1   []NamedNoun        `if:"label=nouns1"`
}

func (*RelativeToNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: RelativeToNoun_Type,
		Uses: composer.Type_Flow,
	}
}

const RelativeToNoun_Type = "relative_to_noun"

const RelativeToNoun_Field_Relation = "$RELATION"
const RelativeToNoun_Field_Nouns = "$NOUNS"
const RelativeToNoun_Field_AreBeing = "$ARE_BEING"
const RelativeToNoun_Field_Nouns1 = "$NOUNS1"

func (op *RelativeToNoun) Marshal(n jsn.Marshaler) {
	RelativeToNoun_Marshal(n, op)
}

type RelativeToNoun_Slice []RelativeToNoun

func (op *RelativeToNoun_Slice) GetType() string { return RelativeToNoun_Type }
func (op *RelativeToNoun_Slice) GetSize() int    { return len(*op) }
func (op *RelativeToNoun_Slice) SetSize(cnt int) { (*op) = make(RelativeToNoun_Slice, cnt) }

func RelativeToNoun_Repeats_Marshal(n jsn.Marshaler, vals *[]RelativeToNoun) {
	if n.MarshalBlock((*RelativeToNoun_Slice)(vals)) {
		for i := range *vals {
			RelativeToNoun_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func RelativeToNoun_Optional_Marshal(n jsn.Marshaler, pv **RelativeToNoun) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		RelativeToNoun_Marshal(n, *pv)
	} else if !enc {
		var v RelativeToNoun
		if RelativeToNoun_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func RelativeToNoun_Marshal(n jsn.Marshaler, val *RelativeToNoun) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(RelativeToNoun_Type,
		RelativeToNoun_Type)); okay {
		if n.MarshalKey("", RelativeToNoun_Field_Relation) {
			value.RelationName_Marshal(n, &val.Relation)
		}
		if n.MarshalKey("nouns", RelativeToNoun_Field_Nouns) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns)
		}
		if n.MarshalKey("are_being", RelativeToNoun_Field_AreBeing) {
			AreBeing_Marshal(n, &val.AreBeing)
		}
		if n.MarshalKey("nouns1", RelativeToNoun_Field_Nouns1) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns1)
		}
		n.EndBlock()
	}
	return
}

// RenderTemplate Parse text using iffy templates.
// User implements: TextEval.
type RenderTemplate struct {
	Template value.Lines `if:"label=_"`
}

func (*RenderTemplate) Compose() composer.Spec {
	return composer.Spec{
		Name: RenderTemplate_Type,
		Uses: composer.Type_Flow,
	}
}

const RenderTemplate_Type = "render_template"

const RenderTemplate_Field_Template = "$TEMPLATE"

func (op *RenderTemplate) Marshal(n jsn.Marshaler) {
	RenderTemplate_Marshal(n, op)
}

type RenderTemplate_Slice []RenderTemplate

func (op *RenderTemplate_Slice) GetType() string { return RenderTemplate_Type }
func (op *RenderTemplate_Slice) GetSize() int    { return len(*op) }
func (op *RenderTemplate_Slice) SetSize(cnt int) { (*op) = make(RenderTemplate_Slice, cnt) }

func RenderTemplate_Repeats_Marshal(n jsn.Marshaler, vals *[]RenderTemplate) {
	if n.MarshalBlock((*RenderTemplate_Slice)(vals)) {
		for i := range *vals {
			RenderTemplate_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func RenderTemplate_Optional_Marshal(n jsn.Marshaler, pv **RenderTemplate) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		RenderTemplate_Marshal(n, *pv)
	} else if !enc {
		var v RenderTemplate
		if RenderTemplate_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func RenderTemplate_Marshal(n jsn.Marshaler, val *RenderTemplate) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(RenderTemplate_Type,
		RenderTemplate_Type)); okay {
		if n.MarshalKey("", RenderTemplate_Field_Template) {
			value.Lines_Marshal(n, &val.Template)
		}
		n.EndBlock()
	}
	return
}

// Send
// User implements: Execute, BoolEval.
type Send struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=path"`
	Arguments *Arguments      `if:"label=arguments,optional"`
}

func (*Send) Compose() composer.Spec {
	return composer.Spec{
		Name: Send_Type,
		Uses: composer.Type_Flow,
	}
}

const Send_Type = "send"

const Send_Field_Event = "$EVENT"
const Send_Field_Path = "$PATH"
const Send_Field_Arguments = "$ARGUMENTS"

func (op *Send) Marshal(n jsn.Marshaler) {
	Send_Marshal(n, op)
}

type Send_Slice []Send

func (op *Send_Slice) GetType() string { return Send_Type }
func (op *Send_Slice) GetSize() int    { return len(*op) }
func (op *Send_Slice) SetSize(cnt int) { (*op) = make(Send_Slice, cnt) }

func Send_Repeats_Marshal(n jsn.Marshaler, vals *[]Send) {
	if n.MarshalBlock((*Send_Slice)(vals)) {
		for i := range *vals {
			Send_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Send_Optional_Marshal(n jsn.Marshaler, pv **Send) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Send_Marshal(n, *pv)
	} else if !enc {
		var v Send
		if Send_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Send_Marshal(n jsn.Marshaler, val *Send) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Send_Type,
		Send_Type)); okay {
		if n.MarshalKey("", Send_Field_Event) {
			value.Text_Unboxed_Marshal(n, &val.Event)
		}
		if n.MarshalKey("path", Send_Field_Path) {
			rt.TextListEval_Marshal(n, &val.Path)
		}
		if n.MarshalKey("arguments", Send_Field_Arguments) {
			Arguments_Optional_Marshal(n, &val.Arguments)
		}
		n.EndBlock()
	}
	return
}

// ShuffleText
// User implements: TextEval.
type ShuffleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*ShuffleText) Compose() composer.Spec {
	return composer.Spec{
		Name: ShuffleText_Type,
		Uses: composer.Type_Flow,
	}
}

const ShuffleText_Type = "shuffle_text"

const ShuffleText_Field_Parts = "$PARTS"

func (op *ShuffleText) Marshal(n jsn.Marshaler) {
	ShuffleText_Marshal(n, op)
}

type ShuffleText_Slice []ShuffleText

func (op *ShuffleText_Slice) GetType() string { return ShuffleText_Type }
func (op *ShuffleText_Slice) GetSize() int    { return len(*op) }
func (op *ShuffleText_Slice) SetSize(cnt int) { (*op) = make(ShuffleText_Slice, cnt) }

func ShuffleText_Repeats_Marshal(n jsn.Marshaler, vals *[]ShuffleText) {
	if n.MarshalBlock((*ShuffleText_Slice)(vals)) {
		for i := range *vals {
			ShuffleText_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func ShuffleText_Optional_Marshal(n jsn.Marshaler, pv **ShuffleText) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		ShuffleText_Marshal(n, *pv)
	} else if !enc {
		var v ShuffleText
		if ShuffleText_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func ShuffleText_Marshal(n jsn.Marshaler, val *ShuffleText) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(ShuffleText_Type,
		ShuffleText_Type)); okay {
		if n.MarshalKey("", ShuffleText_Field_Parts) {
			rt.TextEval_Repeats_Marshal(n, &val.Parts)
		}
		n.EndBlock()
	}
	return
}

// SingularKind requires a user-specified string.
type SingularKind struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *SingularKind) String() string {
	return op.Str
}

func (*SingularKind) Compose() composer.Spec {
	return composer.Spec{
		Name:        SingularKind_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const SingularKind_Type = "singular_kind"

func (op *SingularKind) Marshal(n jsn.Marshaler) {
	SingularKind_Marshal(n, op)
}

func SingularKind_Optional_Marshal(n jsn.Marshaler, val *SingularKind) {
	var zero SingularKind
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		SingularKind_Marshal(n, val)
	}
}

func SingularKind_Marshal(n jsn.Marshaler, val *SingularKind) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(SingularKind_Type, &val.Str)
}

type SingularKind_Slice []SingularKind

func (op *SingularKind_Slice) GetType() string { return SingularKind_Type }
func (op *SingularKind_Slice) GetSize() int    { return len(*op) }
func (op *SingularKind_Slice) SetSize(cnt int) { (*op) = make(SingularKind_Slice, cnt) }

func SingularKind_Repeats_Marshal(n jsn.Marshaler, vals *[]SingularKind) {
	if n.MarshalBlock((*SingularKind_Slice)(vals)) {
		for i := range *vals {
			SingularKind_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// StoppingText
// User implements: TextEval.
type StoppingText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=_"`
}

func (*StoppingText) Compose() composer.Spec {
	return composer.Spec{
		Name: StoppingText_Type,
		Uses: composer.Type_Flow,
	}
}

const StoppingText_Type = "stopping_text"

const StoppingText_Field_Parts = "$PARTS"

func (op *StoppingText) Marshal(n jsn.Marshaler) {
	StoppingText_Marshal(n, op)
}

type StoppingText_Slice []StoppingText

func (op *StoppingText_Slice) GetType() string { return StoppingText_Type }
func (op *StoppingText_Slice) GetSize() int    { return len(*op) }
func (op *StoppingText_Slice) SetSize(cnt int) { (*op) = make(StoppingText_Slice, cnt) }

func StoppingText_Repeats_Marshal(n jsn.Marshaler, vals *[]StoppingText) {
	if n.MarshalBlock((*StoppingText_Slice)(vals)) {
		for i := range *vals {
			StoppingText_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func StoppingText_Optional_Marshal(n jsn.Marshaler, pv **StoppingText) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		StoppingText_Marshal(n, *pv)
	} else if !enc {
		var v StoppingText
		if StoppingText_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func StoppingText_Marshal(n jsn.Marshaler, val *StoppingText) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(StoppingText_Type,
		StoppingText_Type)); okay {
		if n.MarshalKey("", StoppingText_Field_Parts) {
			rt.TextEval_Repeats_Marshal(n, &val.Parts)
		}
		n.EndBlock()
	}
	return
}

// Story
type Story struct {
	Paragraph []Paragraph `if:"label=_,optional"`
}

func (*Story) Compose() composer.Spec {
	return composer.Spec{
		Name: Story_Type,
		Uses: composer.Type_Flow,
	}
}

const Story_Type = "story"

const Story_Field_Paragraph = "$PARAGRAPH"

func (op *Story) Marshal(n jsn.Marshaler) {
	Story_Marshal(n, op)
}

type Story_Slice []Story

func (op *Story_Slice) GetType() string { return Story_Type }
func (op *Story_Slice) GetSize() int    { return len(*op) }
func (op *Story_Slice) SetSize(cnt int) { (*op) = make(Story_Slice, cnt) }

func Story_Repeats_Marshal(n jsn.Marshaler, vals *[]Story) {
	if n.MarshalBlock((*Story_Slice)(vals)) {
		for i := range *vals {
			Story_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Story_Optional_Marshal(n jsn.Marshaler, pv **Story) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Story_Marshal(n, *pv)
	} else if !enc {
		var v Story
		if Story_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Story_Marshal(n jsn.Marshaler, val *Story) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Story_Type,
		Story_Type)); okay {
		if n.MarshalKey("", Story_Field_Paragraph) {
			Paragraph_Repeats_Marshal(n, &val.Paragraph)
		}
		n.EndBlock()
	}
	return
}

const StoryStatement_Type = "story_statement"

var StoryStatement_Optional_Marshal = StoryStatement_Marshal

type StoryStatement_Slot struct{ ptr *StoryStatement }

func (At StoryStatement_Slot) GetType() string { return StoryStatement_Type }
func (at StoryStatement_Slot) HasSlot() bool   { return at.ptr != nil }
func (at StoryStatement_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(StoryStatement)
	return
}

func StoryStatement_Marshal(n jsn.Marshaler, ptr *StoryStatement) (okay bool) {
	if okay = n.MarshalBlock(StoryStatement_Slot{ptr}); okay {
		(*ptr).(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
	return
}

type StoryStatement_Slice []StoryStatement

func (op *StoryStatement_Slice) GetType() string { return StoryStatement_Type }
func (op *StoryStatement_Slice) GetSize() int    { return len(*op) }
func (op *StoryStatement_Slice) SetSize(cnt int) { (*op) = make(StoryStatement_Slice, cnt) }

func StoryStatement_Repeats_Marshal(n jsn.Marshaler, vals *[]StoryStatement) {
	if n.MarshalBlock((*StoryStatement_Slice)(vals)) {
		for i := range *vals {
			StoryStatement_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// Summary
type Summary struct {
	At    reader.Position `if:"internal"`
	Lines value.Lines     `if:"label=_"`
}

func (*Summary) Compose() composer.Spec {
	return composer.Spec{
		Name: Summary_Type,
		Uses: composer.Type_Flow,
	}
}

const Summary_Type = "summary"

const Summary_Field_Lines = "$LINES"

func (op *Summary) Marshal(n jsn.Marshaler) {
	Summary_Marshal(n, op)
}

type Summary_Slice []Summary

func (op *Summary_Slice) GetType() string { return Summary_Type }
func (op *Summary_Slice) GetSize() int    { return len(*op) }
func (op *Summary_Slice) SetSize(cnt int) { (*op) = make(Summary_Slice, cnt) }

func Summary_Repeats_Marshal(n jsn.Marshaler, vals *[]Summary) {
	if n.MarshalBlock((*Summary_Slice)(vals)) {
		for i := range *vals {
			Summary_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Summary_Optional_Marshal(n jsn.Marshaler, pv **Summary) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Summary_Marshal(n, *pv)
	} else if !enc {
		var v Summary
		if Summary_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Summary_Marshal(n jsn.Marshaler, val *Summary) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(Summary_Type,
		Summary_Type)); okay {
		if n.MarshalKey("", Summary_Field_Lines) {
			value.Lines_Marshal(n, &val.Lines)
		}
		n.EndBlock()
	}
	return
}

// Tail Adds details about the preceding noun or nouns.
type Tail struct {
	Pronoun    Pronoun    `if:"label=_"`
	NounPhrase NounPhrase `if:"label=noun_phrase"`
}

func (*Tail) Compose() composer.Spec {
	return composer.Spec{
		Name: Tail_Type,
		Uses: composer.Type_Flow,
	}
}

const Tail_Type = "tail"

const Tail_Field_Pronoun = "$PRONOUN"
const Tail_Field_NounPhrase = "$NOUN_PHRASE"

func (op *Tail) Marshal(n jsn.Marshaler) {
	Tail_Marshal(n, op)
}

type Tail_Slice []Tail

func (op *Tail_Slice) GetType() string { return Tail_Type }
func (op *Tail_Slice) GetSize() int    { return len(*op) }
func (op *Tail_Slice) SetSize(cnt int) { (*op) = make(Tail_Slice, cnt) }

func Tail_Repeats_Marshal(n jsn.Marshaler, vals *[]Tail) {
	if n.MarshalBlock((*Tail_Slice)(vals)) {
		for i := range *vals {
			Tail_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func Tail_Optional_Marshal(n jsn.Marshaler, pv **Tail) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		Tail_Marshal(n, *pv)
	} else if !enc {
		var v Tail
		if Tail_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func Tail_Marshal(n jsn.Marshaler, val *Tail) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(Tail_Type,
		Tail_Type)); okay {
		if n.MarshalKey("", Tail_Field_Pronoun) {
			Pronoun_Marshal(n, &val.Pronoun)
		}
		if n.MarshalKey("noun_phrase", Tail_Field_NounPhrase) {
			NounPhrase_Marshal(n, &val.NounPhrase)
		}
		n.EndBlock()
	}
	return
}

// TestName requires a user-specified string.
type TestName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *TestName) String() string {
	return op.Str
}

const TestName_CurrentTest = "$CURRENT_TEST"

func (*TestName) Compose() composer.Spec {
	return composer.Spec{
		Name:        TestName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			TestName_CurrentTest,
		},
		Strings: []string{
			"current_test",
		},
	}
}

const TestName_Type = "test_name"

func (op *TestName) Marshal(n jsn.Marshaler) {
	TestName_Marshal(n, op)
}

func TestName_Optional_Marshal(n jsn.Marshaler, val *TestName) {
	var zero TestName
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		TestName_Marshal(n, val)
	}
}

func TestName_Marshal(n jsn.Marshaler, val *TestName) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(TestName_Type, jsn.MakeEnum(val, &val.Str))
}

type TestName_Slice []TestName

func (op *TestName_Slice) GetType() string { return TestName_Type }
func (op *TestName_Slice) GetSize() int    { return len(*op) }
func (op *TestName_Slice) SetSize(cnt int) { (*op) = make(TestName_Slice, cnt) }

func TestName_Repeats_Marshal(n jsn.Marshaler, vals *[]TestName) {
	if n.MarshalBlock((*TestName_Slice)(vals)) {
		for i := range *vals {
			TestName_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// TestOutput Expect that a test uses &#x27;Say&#x27; to print some specific text.
// User implements: Testing.
type TestOutput struct {
	Lines value.Lines `if:"label=_"`
}

func (*TestOutput) Compose() composer.Spec {
	return composer.Spec{
		Name: TestOutput_Type,
		Uses: composer.Type_Flow,
	}
}

const TestOutput_Type = "test_output"

const TestOutput_Field_Lines = "$LINES"

func (op *TestOutput) Marshal(n jsn.Marshaler) {
	TestOutput_Marshal(n, op)
}

type TestOutput_Slice []TestOutput

func (op *TestOutput_Slice) GetType() string { return TestOutput_Type }
func (op *TestOutput_Slice) GetSize() int    { return len(*op) }
func (op *TestOutput_Slice) SetSize(cnt int) { (*op) = make(TestOutput_Slice, cnt) }

func TestOutput_Repeats_Marshal(n jsn.Marshaler, vals *[]TestOutput) {
	if n.MarshalBlock((*TestOutput_Slice)(vals)) {
		for i := range *vals {
			TestOutput_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func TestOutput_Optional_Marshal(n jsn.Marshaler, pv **TestOutput) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		TestOutput_Marshal(n, *pv)
	} else if !enc {
		var v TestOutput
		if TestOutput_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func TestOutput_Marshal(n jsn.Marshaler, val *TestOutput) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(TestOutput_Type,
		TestOutput_Type)); okay {
		if n.MarshalKey("", TestOutput_Field_Lines) {
			value.Lines_Marshal(n, &val.Lines)
		}
		n.EndBlock()
	}
	return
}

// TestRule
// User implements: StoryStatement.
type TestRule struct {
	TestName TestName    `if:"label=_"`
	Hook     ProgramHook `if:"label=hook"`
}

func (*TestRule) Compose() composer.Spec {
	return composer.Spec{
		Name: TestRule_Type,
		Uses: composer.Type_Flow,
	}
}

const TestRule_Type = "test_rule"

const TestRule_Field_TestName = "$TEST_NAME"
const TestRule_Field_Hook = "$HOOK"

func (op *TestRule) Marshal(n jsn.Marshaler) {
	TestRule_Marshal(n, op)
}

type TestRule_Slice []TestRule

func (op *TestRule_Slice) GetType() string { return TestRule_Type }
func (op *TestRule_Slice) GetSize() int    { return len(*op) }
func (op *TestRule_Slice) SetSize(cnt int) { (*op) = make(TestRule_Slice, cnt) }

func TestRule_Repeats_Marshal(n jsn.Marshaler, vals *[]TestRule) {
	if n.MarshalBlock((*TestRule_Slice)(vals)) {
		for i := range *vals {
			TestRule_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func TestRule_Optional_Marshal(n jsn.Marshaler, pv **TestRule) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		TestRule_Marshal(n, *pv)
	} else if !enc {
		var v TestRule
		if TestRule_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func TestRule_Marshal(n jsn.Marshaler, val *TestRule) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(TestRule_Type,
		TestRule_Type)); okay {
		if n.MarshalKey("", TestRule_Field_TestName) {
			TestName_Marshal(n, &val.TestName)
		}
		if n.MarshalKey("hook", TestRule_Field_Hook) {
			ProgramHook_Marshal(n, &val.Hook)
		}
		n.EndBlock()
	}
	return
}

// TestScene
// User implements: StoryStatement.
type TestScene struct {
	TestName TestName `if:"label=_"`
	Story    Story    `if:"label=story"`
}

func (*TestScene) Compose() composer.Spec {
	return composer.Spec{
		Name: TestScene_Type,
		Uses: composer.Type_Flow,
	}
}

const TestScene_Type = "test_scene"

const TestScene_Field_TestName = "$TEST_NAME"
const TestScene_Field_Story = "$STORY"

func (op *TestScene) Marshal(n jsn.Marshaler) {
	TestScene_Marshal(n, op)
}

type TestScene_Slice []TestScene

func (op *TestScene_Slice) GetType() string { return TestScene_Type }
func (op *TestScene_Slice) GetSize() int    { return len(*op) }
func (op *TestScene_Slice) SetSize(cnt int) { (*op) = make(TestScene_Slice, cnt) }

func TestScene_Repeats_Marshal(n jsn.Marshaler, vals *[]TestScene) {
	if n.MarshalBlock((*TestScene_Slice)(vals)) {
		for i := range *vals {
			TestScene_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func TestScene_Optional_Marshal(n jsn.Marshaler, pv **TestScene) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		TestScene_Marshal(n, *pv)
	} else if !enc {
		var v TestScene
		if TestScene_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func TestScene_Marshal(n jsn.Marshaler, val *TestScene) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(TestScene_Type,
		TestScene_Type)); okay {
		if n.MarshalKey("", TestScene_Field_TestName) {
			TestName_Marshal(n, &val.TestName)
		}
		if n.MarshalKey("story", TestScene_Field_Story) {
			Story_Marshal(n, &val.Story)
		}
		n.EndBlock()
	}
	return
}

// TestStatement
// User implements: StoryStatement.
type TestStatement struct {
	At       reader.Position `if:"internal"`
	TestName TestName        `if:"label=_"`
	Test     Testing         `if:"label=test"`
}

func (*TestStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: TestStatement_Type,
		Uses: composer.Type_Flow,
	}
}

const TestStatement_Type = "test_statement"

const TestStatement_Field_TestName = "$TEST_NAME"
const TestStatement_Field_Test = "$TEST"

func (op *TestStatement) Marshal(n jsn.Marshaler) {
	TestStatement_Marshal(n, op)
}

type TestStatement_Slice []TestStatement

func (op *TestStatement_Slice) GetType() string { return TestStatement_Type }
func (op *TestStatement_Slice) GetSize() int    { return len(*op) }
func (op *TestStatement_Slice) SetSize(cnt int) { (*op) = make(TestStatement_Slice, cnt) }

func TestStatement_Repeats_Marshal(n jsn.Marshaler, vals *[]TestStatement) {
	if n.MarshalBlock((*TestStatement_Slice)(vals)) {
		for i := range *vals {
			TestStatement_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func TestStatement_Optional_Marshal(n jsn.Marshaler, pv **TestStatement) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		TestStatement_Marshal(n, *pv)
	} else if !enc {
		var v TestStatement
		if TestStatement_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func TestStatement_Marshal(n jsn.Marshaler, val *TestStatement) (okay bool) {
	n.SetCursor(val.At.Offset)
	if okay = n.MarshalBlock(jsn.MarkFlow(TestStatement_Type,
		TestStatement_Type)); okay {
		if n.MarshalKey("", TestStatement_Field_TestName) {
			TestName_Marshal(n, &val.TestName)
		}
		if n.MarshalKey("test", TestStatement_Field_Test) {
			Testing_Marshal(n, &val.Test)
		}
		n.EndBlock()
	}
	return
}

const Testing_Type = "testing"

var Testing_Optional_Marshal = Testing_Marshal

type Testing_Slot struct{ ptr *Testing }

func (At Testing_Slot) GetType() string { return Testing_Type }
func (at Testing_Slot) HasSlot() bool   { return at.ptr != nil }
func (at Testing_Slot) SetSlot(v interface{}) (okay bool) {
	(*at.ptr), okay = v.(Testing)
	return
}

func Testing_Marshal(n jsn.Marshaler, ptr *Testing) (okay bool) {
	if okay = n.MarshalBlock(Testing_Slot{ptr}); okay {
		(*ptr).(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
	return
}

type Testing_Slice []Testing

func (op *Testing_Slice) GetType() string { return Testing_Type }
func (op *Testing_Slice) GetSize() int    { return len(*op) }
func (op *Testing_Slice) SetSize(cnt int) { (*op) = make(Testing_Slice, cnt) }

func Testing_Repeats_Marshal(n jsn.Marshaler, vals *[]Testing) {
	if n.MarshalBlock((*Testing_Slice)(vals)) {
		for i := range *vals {
			Testing_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// TextList requires a user-specified string.
type TextList struct {
	Str string
}

func (op *TextList) String() string {
	return op.Str
}

const TextList_List = "$LIST"

func (*TextList) Compose() composer.Spec {
	return composer.Spec{
		Name: TextList_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			TextList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

const TextList_Type = "text_list"

func (op *TextList) Marshal(n jsn.Marshaler) {
	TextList_Marshal(n, op)
}

func TextList_Optional_Marshal(n jsn.Marshaler, val *TextList) {
	var zero TextList
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		TextList_Marshal(n, val)
	}
}

func TextList_Marshal(n jsn.Marshaler, val *TextList) {
	n.MarshalValue(TextList_Type, jsn.MakeEnum(val, &val.Str))
}

type TextList_Slice []TextList

func (op *TextList_Slice) GetType() string { return TextList_Type }
func (op *TextList_Slice) GetSize() int    { return len(*op) }
func (op *TextList_Slice) SetSize(cnt int) { (*op) = make(TextList_Slice, cnt) }

func TextList_Repeats_Marshal(n jsn.Marshaler, vals *[]TextList) {
	if n.MarshalBlock((*TextList_Slice)(vals)) {
		for i := range *vals {
			TextList_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// Trait requires a user-specified string.
type Trait struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Trait) String() string {
	return op.Str
}

func (*Trait) Compose() composer.Spec {
	return composer.Spec{
		Name:        Trait_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

const Trait_Type = "trait"

func (op *Trait) Marshal(n jsn.Marshaler) {
	Trait_Marshal(n, op)
}

func Trait_Optional_Marshal(n jsn.Marshaler, val *Trait) {
	var zero Trait
	if enc := n.IsEncoding(); !enc || val.Str != zero.Str {
		Trait_Marshal(n, val)
	}
}

func Trait_Marshal(n jsn.Marshaler, val *Trait) {
	n.SetCursor(val.At.Offset)
	n.MarshalValue(Trait_Type, &val.Str)
}

type Trait_Slice []Trait

func (op *Trait_Slice) GetType() string { return Trait_Type }
func (op *Trait_Slice) GetSize() int    { return len(*op) }
func (op *Trait_Slice) SetSize(cnt int) { (*op) = make(Trait_Slice, cnt) }

func Trait_Repeats_Marshal(n jsn.Marshaler, vals *[]Trait) {
	if n.MarshalBlock((*Trait_Slice)(vals)) {
		for i := range *vals {
			Trait_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

// TraitPhrase
type TraitPhrase struct {
	AreEither AreEither `if:"label=_"`
	Trait     []Trait   `if:"label=trait"`
}

func (*TraitPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: TraitPhrase_Type,
		Uses: composer.Type_Flow,
	}
}

const TraitPhrase_Type = "trait_phrase"

const TraitPhrase_Field_AreEither = "$ARE_EITHER"
const TraitPhrase_Field_Trait = "$TRAIT"

func (op *TraitPhrase) Marshal(n jsn.Marshaler) {
	TraitPhrase_Marshal(n, op)
}

type TraitPhrase_Slice []TraitPhrase

func (op *TraitPhrase_Slice) GetType() string { return TraitPhrase_Type }
func (op *TraitPhrase_Slice) GetSize() int    { return len(*op) }
func (op *TraitPhrase_Slice) SetSize(cnt int) { (*op) = make(TraitPhrase_Slice, cnt) }

func TraitPhrase_Repeats_Marshal(n jsn.Marshaler, vals *[]TraitPhrase) {
	if n.MarshalBlock((*TraitPhrase_Slice)(vals)) {
		for i := range *vals {
			TraitPhrase_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func TraitPhrase_Optional_Marshal(n jsn.Marshaler, pv **TraitPhrase) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		TraitPhrase_Marshal(n, *pv)
	} else if !enc {
		var v TraitPhrase
		if TraitPhrase_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func TraitPhrase_Marshal(n jsn.Marshaler, val *TraitPhrase) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(TraitPhrase_Type,
		TraitPhrase_Type)); okay {
		if n.MarshalKey("", TraitPhrase_Field_AreEither) {
			AreEither_Marshal(n, &val.AreEither)
		}
		if n.MarshalKey("trait", TraitPhrase_Field_Trait) {
			Trait_Repeats_Marshal(n, &val.Trait)
		}
		n.EndBlock()
	}
	return
}

// VariableDecl
type VariableDecl struct {
	An      Determiner         `if:"label=_"`
	Name    value.VariableName `if:"label=name"`
	Type    VariableType       `if:"label=type"`
	Comment value.Lines        `if:"label=comment,optional"`
}

func (*VariableDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: VariableDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const VariableDecl_Type = "variable_decl"

const VariableDecl_Field_An = "$AN"
const VariableDecl_Field_Name = "$NAME"
const VariableDecl_Field_Type = "$TYPE"
const VariableDecl_Field_Comment = "$COMMENT"

func (op *VariableDecl) Marshal(n jsn.Marshaler) {
	VariableDecl_Marshal(n, op)
}

type VariableDecl_Slice []VariableDecl

func (op *VariableDecl_Slice) GetType() string { return VariableDecl_Type }
func (op *VariableDecl_Slice) GetSize() int    { return len(*op) }
func (op *VariableDecl_Slice) SetSize(cnt int) { (*op) = make(VariableDecl_Slice, cnt) }

func VariableDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]VariableDecl) {
	if n.MarshalBlock((*VariableDecl_Slice)(vals)) {
		for i := range *vals {
			VariableDecl_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

func VariableDecl_Optional_Marshal(n jsn.Marshaler, pv **VariableDecl) {
	if enc := n.IsEncoding(); enc && *pv != nil {
		VariableDecl_Marshal(n, *pv)
	} else if !enc {
		var v VariableDecl
		if VariableDecl_Marshal(n, &v) {
			*pv = &v
		}
	}
}

func VariableDecl_Marshal(n jsn.Marshaler, val *VariableDecl) (okay bool) {
	if okay = n.MarshalBlock(jsn.MarkFlow(VariableDecl_Type,
		VariableDecl_Type)); okay {
		if n.MarshalKey("", VariableDecl_Field_An) {
			Determiner_Marshal(n, &val.An)
		}
		if n.MarshalKey("name", VariableDecl_Field_Name) {
			value.VariableName_Marshal(n, &val.Name)
		}
		if n.MarshalKey("type", VariableDecl_Field_Type) {
			VariableType_Marshal(n, &val.Type)
		}
		if n.MarshalKey("comment", VariableDecl_Field_Comment) {
			value.Lines_Optional_Marshal(n, &val.Comment)
		}
		n.EndBlock()
	}
	return
}

// VariableType swaps between various options
type VariableType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const VariableType_Primitive_Opt = "$PRIMITIVE"
const VariableType_Object_Opt = "$OBJECT"
const VariableType_Ext_Opt = "$EXT"

func (*VariableType) Compose() composer.Spec {
	return composer.Spec{
		Name: VariableType_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			VariableType_Primitive_Opt, VariableType_Object_Opt, VariableType_Ext_Opt,
		},
		Swaps: []interface{}{
			(*PrimitiveType)(nil),
			(*ObjectType)(nil),
			(*ExtType)(nil),
		},
	}
}

const VariableType_Type = "variable_type"

func (op *VariableType) GetType() string { return VariableType_Type }

func (op *VariableType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PrimitiveType:
		ret, okay = VariableType_Primitive_Opt, true
	case *ObjectType:
		ret, okay = VariableType_Object_Opt, true
	case *ExtType:
		ret, okay = VariableType_Ext_Opt, true
	}
	return
}

func (op *VariableType) SetChoice(c string) (ret interface{}, okay bool) {
	switch c {
	case "":
		op.Opt, okay = nil, true
	case VariableType_Primitive_Opt:
		opt := new(PrimitiveType)
		op.Opt, ret, okay = opt, opt, true
	case VariableType_Object_Opt:
		opt := new(ObjectType)
		op.Opt, ret, okay = opt, opt, true
	case VariableType_Ext_Opt:
		opt := new(ExtType)
		op.Opt, ret, okay = opt, opt, true
	}
	return
}

func (op *VariableType) Marshal(n jsn.Marshaler) {
	VariableType_Marshal(n, op)
}
func VariableType_Marshal(n jsn.Marshaler, val *VariableType) {
	n.SetCursor(val.At.Offset)
	if n.MarshalBlock(val) {
		val.Opt.(jsn.Marshalee).Marshal(n)
		n.EndBlock()
	}
}

type VariableType_Slice []VariableType

func (op *VariableType_Slice) GetType() string { return VariableType_Type }
func (op *VariableType_Slice) GetSize() int    { return len(*op) }
func (op *VariableType_Slice) SetSize(cnt int) { (*op) = make(VariableType_Slice, cnt) }

func VariableType_Repeats_Marshal(n jsn.Marshaler, vals *[]VariableType) {
	if n.MarshalBlock((*VariableType_Slice)(vals)) {
		for i := range *vals {
			VariableType_Marshal(n, &(*vals)[i])
		}
		n.EndBlock()
	}
}

var Slots = []interface{}{
	(*StoryStatement)(nil),
	(*Testing)(nil),
}

var Slats = []composer.Composer{
	(*AbstractAction)(nil),
	(*ActionContext)(nil),
	(*ActionDecl)(nil),
	(*ActionName)(nil),
	(*ActionParams)(nil),
	(*Ana)(nil),
	(*AreAn)(nil),
	(*AreBeing)(nil),
	(*AreEither)(nil),
	(*Argument)(nil),
	(*Arguments)(nil),
	(*Aspect)(nil),
	(*AspectTraits)(nil),
	(*BoxedNumber)(nil),
	(*BoxedText)(nil),
	(*Certainties)(nil),
	(*Certainty)(nil),
	(*Comment)(nil),
	(*CommonAction)(nil),
	(*CountOf)(nil),
	(*CycleText)(nil),
	(*Determine)(nil),
	(*Determiner)(nil),
	(*EventBlock)(nil),
	(*EventHandler)(nil),
	(*EventName)(nil),
	(*EventPhase)(nil),
	(*EventTarget)(nil),
	(*ExtType)(nil),
	(*GrammarDecl)(nil),
	(*KindOfNoun)(nil),
	(*KindOfRelation)(nil),
	(*KindsOfAspect)(nil),
	(*KindsOfKind)(nil),
	(*KindsOfRecord)(nil),
	(*KindsPossessProperties)(nil),
	(*Lede)(nil),
	(*LocalDecl)(nil),
	(*LocalInit)(nil),
	(*Make)(nil),
	(*ManyToMany)(nil),
	(*ManyToOne)(nil),
	(*NamedNoun)(nil),
	(*NounAssignment)(nil),
	(*NounName)(nil),
	(*NounPhrase)(nil),
	(*NounRelation)(nil),
	(*NounStatement)(nil),
	(*NounTraits)(nil),
	(*NumberList)(nil),
	(*ObjectType)(nil),
	(*OneToMany)(nil),
	(*OneToOne)(nil),
	(*PairedAction)(nil),
	(*Paragraph)(nil),
	(*PatternActions)(nil),
	(*PatternDecl)(nil),
	(*PatternFlags)(nil),
	(*PatternLocals)(nil),
	(*PatternReturn)(nil),
	(*PatternRule)(nil),
	(*PatternRules)(nil),
	(*PatternType)(nil),
	(*PatternVariablesDecl)(nil),
	(*PatternVariablesTail)(nil),
	(*PluralKinds)(nil),
	(*PrimitiveType)(nil),
	(*PrimitiveValue)(nil),
	(*ProgramHook)(nil),
	(*Pronoun)(nil),
	(*Property)(nil),
	(*PropertyAspect)(nil),
	(*PropertyDecl)(nil),
	(*PropertyType)(nil),
	(*RecordList)(nil),
	(*RecordPlural)(nil),
	(*RecordSingular)(nil),
	(*RecordType)(nil),
	(*RecordsPossessProperties)(nil),
	(*RelationCardinality)(nil),
	(*RelativeToNoun)(nil),
	(*RenderTemplate)(nil),
	(*Send)(nil),
	(*ShuffleText)(nil),
	(*SingularKind)(nil),
	(*StoppingText)(nil),
	(*Story)(nil),
	(*Summary)(nil),
	(*Tail)(nil),
	(*TestName)(nil),
	(*TestOutput)(nil),
	(*TestRule)(nil),
	(*TestScene)(nil),
	(*TestStatement)(nil),
	(*TextList)(nil),
	(*Trait)(nil),
	(*TraitPhrase)(nil),
	(*VariableDecl)(nil),
	(*VariableType)(nil),
}

var Signatures = map[uint64]interface{}{
	7872120455849093108:  (*ActionContext)(nil),            /* ActionContext: */
	2237475528376444648:  (*ActionDecl)(nil),               /* ActionDecl:action:actionParams common: */
	18212021549969329253: (*ActionDecl)(nil),               /* ActionDecl:action:actionParams dual: */
	10825614489046735389: (*ActionDecl)(nil),               /* ActionDecl:action:actionParams none: */
	18300029595359975322: (*ActionParams)(nil),             /* ActionParams:common: */
	4752185652171688239:  (*ActionParams)(nil),             /* ActionParams:dual: */
	17380596181957311395: (*ActionParams)(nil),             /* ActionParams:none: */
	6291103735245333139:  (*Argument)(nil),                 /* Arg:from: */
	2275326896920679506:  (*Arguments)(nil),                /* Args: */
	17855209504331534011: (*AspectTraits)(nil),             /* AspectTraits:traitPhrase: */
	13349866918792328232: (*BoxedNumber)(nil),              /* BoxedNumber: */
	3226924893680341786:  (*BoxedText)(nil),                /* BoxedText: */
	170374163879469822:   (*Certainties)(nil),              /* Certainties:areBeing:certainty:trait: */
	15857890977690710700: (*Comment)(nil),                  /* Comment: */
	13295757043766156580: (*CommonAction)(nil),             /* CommonAction: */
	11796688776587655409: (*CommonAction)(nil),             /* CommonAction:actionContext: */
	10211567489959209123: (*CountOf)(nil),                  /* CountOf:num: */
	475310308664194536:   (*CycleText)(nil),                /* CycleText: */
	14117144937213193556: (*Determine)(nil),                /* Determine: */
	18058198214790918510: (*Determine)(nil),                /* Determine:arguments: */
	16508933934588876743: (*EventBlock)(nil),               /* EventBlock:handlers: */
	8929470137779261632:  (*EventHandler)(nil),             /* EventHandler:event:patternRules: */
	4061872818055525560:  (*EventHandler)(nil),             /* EventHandler:event:locals:patternRules: */
	6887864790708299171:  (*EventTarget)(nil),              /* EventTarget:kinds: */
	11603761789178301969: (*EventTarget)(nil),              /* EventTarget:namedNoun: */
	13719335624899508122: (*ExtType)(nil),                  /* ExtType:numbers: */
	3700250546663585901:  (*ExtType)(nil),                  /* ExtType:textList: */
	15214188159083551639: (*ExtType)(nil),                  /* ExtType:record: */
	16675795078091962050: (*ExtType)(nil),                  /* ExtType:records: */
	351838510430560892:   (*GrammarDecl)(nil),              /* GrammarDecl: */
	8395536647843606072:  (*KindOfNoun)(nil),               /* KindOfNoun:kind: */
	2174943222093748082:  (*KindOfNoun)(nil),               /* KindOfNoun:trait:kind: */
	7004049933953251122:  (*KindOfNoun)(nil),               /* KindOfNoun:kind:nounRelation: */
	9031009285767794428:  (*KindOfNoun)(nil),               /* KindOfNoun:trait:kind:nounRelation: */
	17103003772384715675: (*KindOfRelation)(nil),           /* KindOfRelation:cardinality one_to_one: */
	13760602953454050004: (*KindOfRelation)(nil),           /* KindOfRelation:cardinality one_to_many: */
	10994426186697812284: (*KindOfRelation)(nil),           /* KindOfRelation:cardinality many_to_one: */
	6159517700304723289:  (*KindOfRelation)(nil),           /* KindOfRelation:cardinality many_to_many: */
	16689641787061327381: (*KindsOfAspect)(nil),            /* KindsOfAspect: */
	18152778218757267226: (*KindsOfKind)(nil),              /* KindsOfKind:singularKind: */
	12878641740711100222: (*KindsOfRecord)(nil),            /* KindsOfRecord: */
	7748657468599352730:  (*KindsPossessProperties)(nil),   /* KindsPossessProperties:propertyDecl: */
	17403355389529444331: (*Lede)(nil),                     /* Lede:nounPhrase kind_of_noun: */
	10946804106489118898: (*Lede)(nil),                     /* Lede:nounPhrase noun_traits: */
	1740466021425803333:  (*Lede)(nil),                     /* Lede:nounPhrase noun_relation: */
	10446315654994385322: (*LocalDecl)(nil),                /* LocalDecl: */
	6009252662016869003:  (*LocalDecl)(nil),                /* LocalDecl:value: */
	11789909816860756800: (*LocalInit)(nil),                /* LocalInit: */
	9981010364372027439:  (*Make)(nil),                     /* Make: */
	12609627593403083413: (*Make)(nil),                     /* Make:arguments: */
	17563761532337350103: (*ManyToMany)(nil),               /* ManyToMany:otherKinds: */
	4129025779762507875:  (*ManyToOne)(nil),                /* ManyToOne:kind: */
	16572015744003324651: (*NamedNoun)(nil),                /* NamedNoun:name: */
	10597814521259612392: (*NounAssignment)(nil),           /* NounAssignment:nouns:lines: */
	11861883425272284529: (*NounPhrase)(nil),               /* NounPhrase:kindOfNoun: */
	12126045192749329611: (*NounPhrase)(nil),               /* NounPhrase:nounTraits: */
	7293688131970027220:  (*NounPhrase)(nil),               /* NounPhrase:nounRelation: */
	3463959207148309224:  (*NounRelation)(nil),             /* NounRelation:relation:nouns: */
	16756778993528596640: (*NounStatement)(nil),            /* NounStatement: */
	13104026651265504280: (*NounStatement)(nil),            /* NounStatement:tail: */
	5039251519992036198:  (*NounStatement)(nil),            /* NounStatement:summary: */
	4978269156154497630:  (*NounStatement)(nil),            /* NounStatement:tail:summary: */
	18242559699550270796: (*NounTraits)(nil),               /* NounTraits:trait: */
	17470035189832390536: (*ObjectType)(nil),               /* ObjectType:kind: */
	17075866407822548206: (*OneToMany)(nil),                /* OneToMany:kinds: */
	13766274136867271026: (*OneToOne)(nil),                 /* OneToOne:otherKind: */
	18143853777230560632: (*PairedAction)(nil),             /* PairedAction: */
	1044755875845214073:  (*Paragraph)(nil),                /* Paragraph: */
	10735038169260724899: (*PatternActions)(nil),           /* PatternActions:patternRules: */
	626108847940444615:   (*PatternActions)(nil),           /* PatternActions:patternLocals:patternRules: */
	8043268755698861333:  (*PatternActions)(nil),           /* PatternActions:patternReturn:patternRules: */
	14295113253706291193: (*PatternActions)(nil),           /* PatternActions:patternLocals:patternReturn:patternRules: */
	12269627840097064600: (*PatternDecl)(nil),              /* PatternDecl:name: */
	14226432888280203235: (*PatternDecl)(nil),              /* PatternDecl:name:optvars: */
	16699606798420796914: (*PatternDecl)(nil),              /* PatternDecl:name:patternReturn: */
	12239987563966389881: (*PatternDecl)(nil),              /* PatternDecl:name:optvars:patternReturn: */
	15390970540499719701: (*PatternDecl)(nil),              /* PatternDecl:name:about: */
	2773647507718310398:  (*PatternDecl)(nil),              /* PatternDecl:name:optvars:about: */
	15396002863266428067: (*PatternDecl)(nil),              /* PatternDecl:name:patternReturn:about: */
	18176072221785763176: (*PatternDecl)(nil),              /* PatternDecl:name:optvars:patternReturn:about: */
	16940656754612309445: (*PatternLocals)(nil),            /* PatternLocals: */
	9272141818556957835:  (*PatternReturn)(nil),            /* PatternReturn: */
	15914753357447503965: (*PatternRule)(nil),              /* PatternRule:hook activity: */
	14391699440407036198: (*PatternRule)(nil),              /* PatternRule:flags:hook activity: */
	12644281899387438986: (*PatternRules)(nil),             /* PatternRules: */
	2711635406027692142:  (*PatternVariablesDecl)(nil),     /* PatternVariablesDecl:variableDecl: */
	2318440529621094838:  (*PatternVariablesTail)(nil),     /* PatternVariablesTail: */
	10026568271710825232: (*PrimitiveValue)(nil),           /* PrimitiveValue:boxedText: */
	2609855438821334634:  (*PrimitiveValue)(nil),           /* PrimitiveValue:boxedNumber: */
	4810952077799758135:  (*ProgramHook)(nil),              /* ProgramHook:activity: */
	8568607257949030878:  (*PropertyDecl)(nil),             /* PropertyDecl:property:propertyType property_aspect: */
	9417869270879260791:  (*PropertyDecl)(nil),             /* PropertyDecl:property:propertyType primitive: */
	18289966116990726001: (*PropertyDecl)(nil),             /* PropertyDecl:property:propertyType ext: */
	15558227017670234027: (*PropertyDecl)(nil),             /* PropertyDecl:property:propertyType property_aspect:comment: */
	11674503435152513662: (*PropertyDecl)(nil),             /* PropertyDecl:property:propertyType primitive:comment: */
	10271231677614855256: (*PropertyDecl)(nil),             /* PropertyDecl:property:propertyType ext:comment: */
	17992535257738220455: (*PropertyType)(nil),             /* PropertyType:propertyAspect: */
	13177019507713113035: (*PropertyType)(nil),             /* PropertyType:primitive: */
	12280377783075176181: (*PropertyType)(nil),             /* PropertyType:ext: */
	1370374852585817674:  (*RecordList)(nil),               /* RecordList: */
	9391386016837677242:  (*RecordType)(nil),               /* RecordType: */
	10207737577741406477: (*RecordsPossessProperties)(nil), /* RecordsPossessProperties:propertyDecl: */
	4728592636183011922:  (*RelationCardinality)(nil),      /* RelationCardinality:oneToOne: */
	5154141581067052895:  (*RelationCardinality)(nil),      /* RelationCardinality:oneToMany: */
	1533380520705338807:  (*RelationCardinality)(nil),      /* RelationCardinality:manyToOne: */
	7880710420710628720:  (*RelationCardinality)(nil),      /* RelationCardinality:manyToMany: */
	7151092568991800158:  (*RelativeToNoun)(nil),           /* RelativeToNoun:nouns:areBeing:nouns1: */
	15988073058027477451: (*RenderTemplate)(nil),           /* RenderTemplate: */
	2420057392455761494:  (*Send)(nil),                     /* Send:path: */
	10010483713146895284: (*Send)(nil),                     /* Send:path:arguments: */
	7279273919312137397:  (*ShuffleText)(nil),              /* ShuffleText: */
	10085329253831819088: (*StoppingText)(nil),             /* StoppingText: */
	13392546219852761816: (*Story)(nil),                    /* Story: */
	7688593191439831819:  (*Summary)(nil),                  /* Summary: */
	13414258410622497845: (*Tail)(nil),                     /* Tail:nounPhrase kind_of_noun: */
	13552532623454855284: (*Tail)(nil),                     /* Tail:nounPhrase noun_traits: */
	17730753679906155267: (*Tail)(nil),                     /* Tail:nounPhrase noun_relation: */
	15090827023293362138: (*TestOutput)(nil),               /* TestOutput: */
	11231723833188820353: (*TestRule)(nil),                 /* TestRule:hook activity: */
	15304439741055926590: (*TestScene)(nil),                /* TestScene:story: */
	1385539489971009934:  (*TestStatement)(nil),            /* TestStatement:test: */
	14061432096605043790: (*TraitPhrase)(nil),              /* TraitPhrase:trait: */
	5275567442482955525:  (*VariableDecl)(nil),             /* VariableDecl:name:type primitive: */
	1626262850875652971:  (*VariableDecl)(nil),             /* VariableDecl:name:type object: */
	18304402114793467999: (*VariableDecl)(nil),             /* VariableDecl:name:type ext: */
	1433602155249308844:  (*VariableDecl)(nil),             /* VariableDecl:name:type primitive:comment: */
	14918607060645225458: (*VariableDecl)(nil),             /* VariableDecl:name:type object:comment: */
	158426266364219478:   (*VariableDecl)(nil),             /* VariableDecl:name:type ext:comment: */
	1065289488566626068:  (*VariableType)(nil),             /* VariableType:primitive: */
	13072719124953783152: (*VariableType)(nil),             /* VariableType:object: */
	18283572172781454234: (*VariableType)(nil),             /* VariableType:ext: */
}
