// Code generated by "makeops"; edit at your own risk.
package story

import (
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/grammar"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/export/jsn"
	"git.sr.ht/~ionous/iffy/rt"
)

// AbstractAction requires a user-specified string.
type AbstractAction struct {
	Str string
}

func (op *AbstractAction) String() string {
	return op.Str
}

const AbstractAction_Nothing = "$NOTHING"

func (*AbstractAction) Compose() composer.Spec {
	return composer.Spec{
		Name: AbstractAction_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			AbstractAction_Nothing,
		},
		Strings: []string{
			"nothing",
		},
	}
}

func (op *AbstractAction) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const AbstractAction_Type = "abstract_action"

func (op *AbstractAction) Marshal(n jsn.Marshaler) {
	AbstractAction_Marshal(n, op)
}

func AbstractAction_Optional_Marshal(n jsn.Marshaler, val *AbstractAction) {
	var zero AbstractAction
	if val.Str != zero.Str {
		AbstractAction_Marshal(n, val)
	}
}

func AbstractAction_Marshal(n jsn.Marshaler, val *AbstractAction) {
	n.SpecifyEnum(AbstractAction_Type, val)
}

func AbstractAction_Repeats_Marshal(n jsn.Marshaler, vals *[]AbstractAction) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				AbstractAction_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// ActionContext
type ActionContext struct {
	At   reader.Position `if:"internal"`
	Kind SingularKind    `if:"label=kind"`
}

func (*ActionContext) Compose() composer.Spec {
	return composer.Spec{
		Name: ActionContext_Type,
		Uses: composer.Type_Flow,
	}
}

const ActionContext_Type = "action_context"

const ActionContext_Field_Kind = "$KIND"

func (op *ActionContext) Marshal(n jsn.Marshaler) {
	ActionContext_Marshal(n, op)
}

func ActionContext_Repeats_Marshal(n jsn.Marshaler, vals *[]ActionContext) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ActionContext_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func ActionContext_Optional_Marshal(n jsn.Marshaler, val **ActionContext) {
	if *val != nil {
		ActionContext_Marshal(n, *val)
	}
}

func ActionContext_Marshal(n jsn.Marshaler, val *ActionContext) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(ActionContext_Type, ActionContext_Type) {
		if n.MapKey("kind", ActionContext_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		n.EndValues()
	}
	return
}

// ActionDecl
type ActionDecl struct {
	At           reader.Position `if:"internal"`
	Event        EventName       `if:"label=event"`
	Action       ActionName      `if:"label=action"`
	ActionParams ActionParams    `if:"label=action_params"`
}

func (*ActionDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: ActionDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const ActionDecl_Type = "action_decl"

const ActionDecl_Field_Event = "$EVENT"
const ActionDecl_Field_Action = "$ACTION"
const ActionDecl_Field_ActionParams = "$ACTION_PARAMS"

func (op *ActionDecl) Marshal(n jsn.Marshaler) {
	ActionDecl_Marshal(n, op)
}

func ActionDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]ActionDecl) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ActionDecl_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func ActionDecl_Optional_Marshal(n jsn.Marshaler, val **ActionDecl) {
	if *val != nil {
		ActionDecl_Marshal(n, *val)
	}
}

func ActionDecl_Marshal(n jsn.Marshaler, val *ActionDecl) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(ActionDecl_Type, ActionDecl_Type) {
		if n.MapKey("event", ActionDecl_Field_Event) {
			EventName_Marshal(n, &val.Event)
		}
		if n.MapKey("action", ActionDecl_Field_Action) {
			ActionName_Marshal(n, &val.Action)
		}
		if n.MapKey("action_params", ActionDecl_Field_ActionParams) {
			ActionParams_Marshal(n, &val.ActionParams)
		}
		n.EndValues()
	}
	return
}

// ActionName requires a user-specified string.
type ActionName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *ActionName) String() string {
	return op.Str
}

func (*ActionName) Compose() composer.Spec {
	return composer.Spec{
		Name:        ActionName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *ActionName) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const ActionName_Type = "action_name"

func (op *ActionName) Marshal(n jsn.Marshaler) {
	ActionName_Marshal(n, op)
}

func ActionName_Optional_Marshal(n jsn.Marshaler, val *ActionName) {
	var zero ActionName
	if val.Str != zero.Str {
		ActionName_Marshal(n, val)
	}
}

func ActionName_Marshal(n jsn.Marshaler, val *ActionName) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(ActionName_Type, val.Str)
}

func ActionName_Repeats_Marshal(n jsn.Marshaler, vals *[]ActionName) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ActionName_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// ActionParams swaps between various options
type ActionParams struct {
	Opt interface{}
}

const ActionParams_Common_Opt = "$COMMON"
const ActionParams_Dual_Opt = "$DUAL"
const ActionParams_None_Opt = "$NONE"

func (*ActionParams) Compose() composer.Spec {
	return composer.Spec{
		Name: ActionParams_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			ActionParams_Common_Opt, ActionParams_Dual_Opt, ActionParams_None_Opt,
		},
		Swaps: []interface{}{
			(*CommonAction)(nil),
			(*PairedAction)(nil),
			(*AbstractAction)(nil),
		},
	}
}

const ActionParams_Type = "action_params"

func (op *ActionParams) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *CommonAction:
		ret, okay = ActionParams_Common_Opt, true
	case *PairedAction:
		ret, okay = ActionParams_Dual_Opt, true
	case *AbstractAction:
		ret, okay = ActionParams_None_Opt, true
	}
	return
}
func (op *ActionParams) Marshal(n jsn.Marshaler) {
	ActionParams_Marshal(n, op)
}
func ActionParams_Marshal(n jsn.Marshaler, val *ActionParams) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			if n.PickValues(ActionParams_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func ActionParams_Repeats_Marshal(n jsn.Marshaler, vals *[]ActionParams) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ActionParams_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// Ana requires a user-specified string.
type Ana struct {
	Str string
}

func (op *Ana) String() string {
	return op.Str
}

const Ana_A = "$A"
const Ana_An = "$AN"

func (*Ana) Compose() composer.Spec {
	return composer.Spec{
		Name: Ana_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			Ana_A, Ana_An,
		},
		Strings: []string{
			"a", "an",
		},
	}
}

func (op *Ana) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const Ana_Type = "ana"

func (op *Ana) Marshal(n jsn.Marshaler) {
	Ana_Marshal(n, op)
}

func Ana_Optional_Marshal(n jsn.Marshaler, val *Ana) {
	var zero Ana
	if val.Str != zero.Str {
		Ana_Marshal(n, val)
	}
}

func Ana_Marshal(n jsn.Marshaler, val *Ana) {
	n.SpecifyEnum(Ana_Type, val)
}

func Ana_Repeats_Marshal(n jsn.Marshaler, vals *[]Ana) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Ana_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// AreAn requires a user-specified string.
type AreAn struct {
	Str string
}

func (op *AreAn) String() string {
	return op.Str
}

const AreAn_Are = "$ARE"
const AreAn_Area = "$AREA"
const AreAn_Arean = "$AREAN"
const AreAn_Is = "$IS"
const AreAn_Isa = "$ISA"
const AreAn_Isan = "$ISAN"

func (*AreAn) Compose() composer.Spec {
	return composer.Spec{
		Name: AreAn_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			AreAn_Are, AreAn_Area, AreAn_Arean, AreAn_Is, AreAn_Isa, AreAn_Isan,
		},
		Strings: []string{
			"are", "area", "arean", "is", "isa", "isan",
		},
	}
}

func (op *AreAn) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const AreAn_Type = "are_an"

func (op *AreAn) Marshal(n jsn.Marshaler) {
	AreAn_Marshal(n, op)
}

func AreAn_Optional_Marshal(n jsn.Marshaler, val *AreAn) {
	var zero AreAn
	if val.Str != zero.Str {
		AreAn_Marshal(n, val)
	}
}

func AreAn_Marshal(n jsn.Marshaler, val *AreAn) {
	n.SpecifyEnum(AreAn_Type, val)
}

func AreAn_Repeats_Marshal(n jsn.Marshaler, vals *[]AreAn) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				AreAn_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// AreBeing requires a user-specified string.
type AreBeing struct {
	Str string
}

func (op *AreBeing) String() string {
	return op.Str
}

const AreBeing_Are = "$ARE"
const AreBeing_Is = "$IS"

func (*AreBeing) Compose() composer.Spec {
	return composer.Spec{
		Name: AreBeing_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			AreBeing_Are, AreBeing_Is,
		},
		Strings: []string{
			"are", "is",
		},
	}
}

func (op *AreBeing) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const AreBeing_Type = "are_being"

func (op *AreBeing) Marshal(n jsn.Marshaler) {
	AreBeing_Marshal(n, op)
}

func AreBeing_Optional_Marshal(n jsn.Marshaler, val *AreBeing) {
	var zero AreBeing
	if val.Str != zero.Str {
		AreBeing_Marshal(n, val)
	}
}

func AreBeing_Marshal(n jsn.Marshaler, val *AreBeing) {
	n.SpecifyEnum(AreBeing_Type, val)
}

func AreBeing_Repeats_Marshal(n jsn.Marshaler, vals *[]AreBeing) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				AreBeing_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// AreEither requires a user-specified string.
type AreEither struct {
	Str string
}

func (op *AreEither) String() string {
	return op.Str
}

const AreEither_Canbe = "$CANBE"
const AreEither_Either = "$EITHER"

func (*AreEither) Compose() composer.Spec {
	return composer.Spec{
		Name: AreEither_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			AreEither_Canbe, AreEither_Either,
		},
		Strings: []string{
			"canbe", "either",
		},
	}
}

func (op *AreEither) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const AreEither_Type = "are_either"

func (op *AreEither) Marshal(n jsn.Marshaler) {
	AreEither_Marshal(n, op)
}

func AreEither_Optional_Marshal(n jsn.Marshaler, val *AreEither) {
	var zero AreEither
	if val.Str != zero.Str {
		AreEither_Marshal(n, val)
	}
}

func AreEither_Marshal(n jsn.Marshaler, val *AreEither) {
	n.SpecifyEnum(AreEither_Type, val)
}

func AreEither_Repeats_Marshal(n jsn.Marshaler, vals *[]AreEither) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				AreEither_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// Argument
type Argument struct {
	At   reader.Position `if:"internal"`
	Name string          `if:"label=_,type=text"`
	From rt.Assignment   `if:"label=from"`
}

func (*Argument) Compose() composer.Spec {
	return composer.Spec{
		Name: Argument_Type,
		Uses: composer.Type_Flow,
		Lede: "arg",
	}
}

const Argument_Type = "argument"

const Argument_Field_Name = "$NAME"
const Argument_Field_From = "$FROM"

func (op *Argument) Marshal(n jsn.Marshaler) {
	Argument_Marshal(n, op)
}

func Argument_Repeats_Marshal(n jsn.Marshaler, vals *[]Argument) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Argument_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Argument_Optional_Marshal(n jsn.Marshaler, val **Argument) {
	if *val != nil {
		Argument_Marshal(n, *val)
	}
}

func Argument_Marshal(n jsn.Marshaler, val *Argument) {
	n.SetCursor(val.At.Offset)
	if n.MapValues("arg", Argument_Type) {
		if n.MapKey("", Argument_Field_Name) {
			value.Text_Unboxed_Marshal(n, &val.Name)
		}
		if n.MapKey("from", Argument_Field_From) {
			rt.Assignment_Marshal(n, &val.From)
		}
		n.EndValues()
	}
	return
}

// Arguments
type Arguments struct {
	At   reader.Position `if:"internal"`
	Args []Argument      `if:"label=_"`
}

func (*Arguments) Compose() composer.Spec {
	return composer.Spec{
		Name: Arguments_Type,
		Uses: composer.Type_Flow,
		Lede: "args",
	}
}

const Arguments_Type = "arguments"

const Arguments_Field_Args = "$ARGS"

func (op *Arguments) Marshal(n jsn.Marshaler) {
	Arguments_Marshal(n, op)
}

func Arguments_Repeats_Marshal(n jsn.Marshaler, vals *[]Arguments) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Arguments_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Arguments_Optional_Marshal(n jsn.Marshaler, val **Arguments) {
	if *val != nil {
		Arguments_Marshal(n, *val)
	}
}

func Arguments_Marshal(n jsn.Marshaler, val *Arguments) {
	n.SetCursor(val.At.Offset)
	if n.MapValues("args", Arguments_Type) {
		if n.MapKey("", Arguments_Field_Args) {
			Argument_Repeats_Marshal(n, &val.Args)
		}
		n.EndValues()
	}
	return
}

// Aspect requires a user-specified string.
type Aspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Aspect) String() string {
	return op.Str
}

func (*Aspect) Compose() composer.Spec {
	return composer.Spec{
		Name:        Aspect_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *Aspect) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const Aspect_Type = "aspect"

func (op *Aspect) Marshal(n jsn.Marshaler) {
	Aspect_Marshal(n, op)
}

func Aspect_Optional_Marshal(n jsn.Marshaler, val *Aspect) {
	var zero Aspect
	if val.Str != zero.Str {
		Aspect_Marshal(n, val)
	}
}

func Aspect_Marshal(n jsn.Marshaler, val *Aspect) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(Aspect_Type, val.Str)
}

func Aspect_Repeats_Marshal(n jsn.Marshaler, vals *[]Aspect) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Aspect_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// AspectTraits
type AspectTraits struct {
	Aspect      Aspect      `if:"label=_"`
	TraitPhrase TraitPhrase `if:"label=trait_phrase"`
}

func (*AspectTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: AspectTraits_Type,
		Uses: composer.Type_Flow,
	}
}

const AspectTraits_Type = "aspect_traits"

const AspectTraits_Field_Aspect = "$ASPECT"
const AspectTraits_Field_TraitPhrase = "$TRAIT_PHRASE"

func (op *AspectTraits) Marshal(n jsn.Marshaler) {
	AspectTraits_Marshal(n, op)
}

func AspectTraits_Repeats_Marshal(n jsn.Marshaler, vals *[]AspectTraits) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				AspectTraits_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func AspectTraits_Optional_Marshal(n jsn.Marshaler, val **AspectTraits) {
	if *val != nil {
		AspectTraits_Marshal(n, *val)
	}
}

func AspectTraits_Marshal(n jsn.Marshaler, val *AspectTraits) {
	if n.MapValues(AspectTraits_Type, AspectTraits_Type) {
		if n.MapKey("", AspectTraits_Field_Aspect) {
			Aspect_Marshal(n, &val.Aspect)
		}
		if n.MapKey("trait_phrase", AspectTraits_Field_TraitPhrase) {
			TraitPhrase_Marshal(n, &val.TraitPhrase)
		}
		n.EndValues()
	}
	return
}

// BoxedNumber
type BoxedNumber struct {
	Number float64 `if:"label=_,type=number"`
}

func (*BoxedNumber) Compose() composer.Spec {
	return composer.Spec{
		Name: BoxedNumber_Type,
		Uses: composer.Type_Flow,
	}
}

const BoxedNumber_Type = "boxed_number"

const BoxedNumber_Field_Number = "$NUMBER"

func (op *BoxedNumber) Marshal(n jsn.Marshaler) {
	BoxedNumber_Marshal(n, op)
}

func BoxedNumber_Repeats_Marshal(n jsn.Marshaler, vals *[]BoxedNumber) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				BoxedNumber_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func BoxedNumber_Optional_Marshal(n jsn.Marshaler, val **BoxedNumber) {
	if *val != nil {
		BoxedNumber_Marshal(n, *val)
	}
}

func BoxedNumber_Marshal(n jsn.Marshaler, val *BoxedNumber) {
	if n.MapValues(BoxedNumber_Type, BoxedNumber_Type) {
		if n.MapKey("", BoxedNumber_Field_Number) {
			value.Number_Unboxed_Marshal(n, &val.Number)
		}
		n.EndValues()
	}
	return
}

// BoxedText
type BoxedText struct {
	Text string `if:"label=_,type=text"`
}

func (*BoxedText) Compose() composer.Spec {
	return composer.Spec{
		Name: BoxedText_Type,
		Uses: composer.Type_Flow,
	}
}

const BoxedText_Type = "boxed_text"

const BoxedText_Field_Text = "$TEXT"

func (op *BoxedText) Marshal(n jsn.Marshaler) {
	BoxedText_Marshal(n, op)
}

func BoxedText_Repeats_Marshal(n jsn.Marshaler, vals *[]BoxedText) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				BoxedText_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func BoxedText_Optional_Marshal(n jsn.Marshaler, val **BoxedText) {
	if *val != nil {
		BoxedText_Marshal(n, *val)
	}
}

func BoxedText_Marshal(n jsn.Marshaler, val *BoxedText) {
	if n.MapValues(BoxedText_Type, BoxedText_Type) {
		if n.MapKey("", BoxedText_Field_Text) {
			value.Text_Unboxed_Marshal(n, &val.Text)
		}
		n.EndValues()
	}
	return
}

// Certainties
type Certainties struct {
	PluralKinds PluralKinds `if:"label=_"`
	AreBeing    AreBeing    `if:"label=are_being"`
	Certainty   Certainty   `if:"label=certainty"`
	Trait       Trait       `if:"label=trait"`
}

func (*Certainties) Compose() composer.Spec {
	return composer.Spec{
		Name: Certainties_Type,
		Uses: composer.Type_Flow,
	}
}

const Certainties_Type = "certainties"

const Certainties_Field_PluralKinds = "$PLURAL_KINDS"
const Certainties_Field_AreBeing = "$ARE_BEING"
const Certainties_Field_Certainty = "$CERTAINTY"
const Certainties_Field_Trait = "$TRAIT"

func (op *Certainties) Marshal(n jsn.Marshaler) {
	Certainties_Marshal(n, op)
}

func Certainties_Repeats_Marshal(n jsn.Marshaler, vals *[]Certainties) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Certainties_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Certainties_Optional_Marshal(n jsn.Marshaler, val **Certainties) {
	if *val != nil {
		Certainties_Marshal(n, *val)
	}
}

func Certainties_Marshal(n jsn.Marshaler, val *Certainties) {
	if n.MapValues(Certainties_Type, Certainties_Type) {
		if n.MapKey("", Certainties_Field_PluralKinds) {
			PluralKinds_Marshal(n, &val.PluralKinds)
		}
		if n.MapKey("are_being", Certainties_Field_AreBeing) {
			AreBeing_Marshal(n, &val.AreBeing)
		}
		if n.MapKey("certainty", Certainties_Field_Certainty) {
			Certainty_Marshal(n, &val.Certainty)
		}
		if n.MapKey("trait", Certainties_Field_Trait) {
			Trait_Marshal(n, &val.Trait)
		}
		n.EndValues()
	}
	return
}

// Certainty requires a user-specified string.
type Certainty struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Certainty) String() string {
	return op.Str
}

const Certainty_Usually = "$USUALLY"
const Certainty_Always = "$ALWAYS"
const Certainty_Seldom = "$SELDOM"
const Certainty_Never = "$NEVER"

func (*Certainty) Compose() composer.Spec {
	return composer.Spec{
		Name: Certainty_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			Certainty_Usually, Certainty_Always, Certainty_Seldom, Certainty_Never,
		},
		Strings: []string{
			"usually", "always", "seldom", "never",
		},
	}
}

func (op *Certainty) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const Certainty_Type = "certainty"

func (op *Certainty) Marshal(n jsn.Marshaler) {
	Certainty_Marshal(n, op)
}

func Certainty_Optional_Marshal(n jsn.Marshaler, val *Certainty) {
	var zero Certainty
	if val.Str != zero.Str {
		Certainty_Marshal(n, val)
	}
}

func Certainty_Marshal(n jsn.Marshaler, val *Certainty) {
	n.SetCursor(val.At.Offset)
	n.SpecifyEnum(Certainty_Type, val)
}

func Certainty_Repeats_Marshal(n jsn.Marshaler, vals *[]Certainty) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Certainty_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// Comment Information about the story for you and other authors.
type Comment struct {
	Lines value.Lines `if:"label=_"`
}

func (*Comment) Compose() composer.Spec {
	return composer.Spec{
		Name: Comment_Type,
		Uses: composer.Type_Flow,
	}
}

const Comment_Type = "comment"

const Comment_Field_Lines = "$LINES"

func (op *Comment) Marshal(n jsn.Marshaler) {
	Comment_Marshal(n, op)
}

func Comment_Repeats_Marshal(n jsn.Marshaler, vals *[]Comment) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Comment_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Comment_Optional_Marshal(n jsn.Marshaler, val **Comment) {
	if *val != nil {
		Comment_Marshal(n, *val)
	}
}

func Comment_Marshal(n jsn.Marshaler, val *Comment) {
	if n.MapValues(Comment_Type, Comment_Type) {
		if n.MapKey("", Comment_Field_Lines) {
			value.Lines_Marshal(n, &val.Lines)
		}
		n.EndValues()
	}
	return
}

// CommonAction
type CommonAction struct {
	At            reader.Position `if:"internal"`
	Kind          SingularKind    `if:"label=kind"`
	ActionContext *ActionContext  `if:"label=action_context,optional"`
}

func (*CommonAction) Compose() composer.Spec {
	return composer.Spec{
		Name: CommonAction_Type,
		Uses: composer.Type_Flow,
	}
}

const CommonAction_Type = "common_action"

const CommonAction_Field_Kind = "$KIND"
const CommonAction_Field_ActionContext = "$ACTION_CONTEXT"

func (op *CommonAction) Marshal(n jsn.Marshaler) {
	CommonAction_Marshal(n, op)
}

func CommonAction_Repeats_Marshal(n jsn.Marshaler, vals *[]CommonAction) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				CommonAction_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func CommonAction_Optional_Marshal(n jsn.Marshaler, val **CommonAction) {
	if *val != nil {
		CommonAction_Marshal(n, *val)
	}
}

func CommonAction_Marshal(n jsn.Marshaler, val *CommonAction) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(CommonAction_Type, CommonAction_Type) {
		if n.MapKey("kind", CommonAction_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		if n.MapKey("action_context", CommonAction_Field_ActionContext) {
			ActionContext_Optional_Marshal(n, &val.ActionContext)
		}
		n.EndValues()
	}
	return
}

// CountOf A guard which returns true based on a counter.
type CountOf struct {
	At      reader.Position `if:"internal"`
	Trigger core.Trigger    `if:"label=trigger"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CountOf) Compose() composer.Spec {
	return composer.Spec{
		Name: CountOf_Type,
		Uses: composer.Type_Flow,
	}
}

const CountOf_Type = "count_of"

const CountOf_Field_Trigger = "$TRIGGER"
const CountOf_Field_Num = "$NUM"

func (op *CountOf) Marshal(n jsn.Marshaler) {
	CountOf_Marshal(n, op)
}

func CountOf_Repeats_Marshal(n jsn.Marshaler, vals *[]CountOf) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				CountOf_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func CountOf_Optional_Marshal(n jsn.Marshaler, val **CountOf) {
	if *val != nil {
		CountOf_Marshal(n, *val)
	}
}

func CountOf_Marshal(n jsn.Marshaler, val *CountOf) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(CountOf_Type, CountOf_Type) {
		if n.MapKey("trigger", CountOf_Field_Trigger) {
			core.Trigger_Marshal(n, &val.Trigger)
		}
		if n.MapKey("num", CountOf_Field_Num) {
			rt.NumberEval_Marshal(n, &val.Num)
		}
		n.EndValues()
	}
	return
}

// CycleText
type CycleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*CycleText) Compose() composer.Spec {
	return composer.Spec{
		Name: CycleText_Type,
		Uses: composer.Type_Flow,
	}
}

const CycleText_Type = "cycle_text"

const CycleText_Field_Parts = "$PARTS"

func (op *CycleText) Marshal(n jsn.Marshaler) {
	CycleText_Marshal(n, op)
}

func CycleText_Repeats_Marshal(n jsn.Marshaler, vals *[]CycleText) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				CycleText_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func CycleText_Optional_Marshal(n jsn.Marshaler, val **CycleText) {
	if *val != nil {
		CycleText_Marshal(n, *val)
	}
}

func CycleText_Marshal(n jsn.Marshaler, val *CycleText) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(CycleText_Type, CycleText_Type) {
		if n.MapKey("parts", CycleText_Field_Parts) {
			rt.TextEval_Repeats_Marshal(n, &val.Parts)
		}
		n.EndValues()
	}
	return
}

// Determine
type Determine struct {
	Name      value.PatternName `if:"label=_"`
	Arguments *Arguments        `if:"label=arguments,optional"`
}

func (*Determine) Compose() composer.Spec {
	return composer.Spec{
		Name: Determine_Type,
		Uses: composer.Type_Flow,
	}
}

const Determine_Type = "determine"

const Determine_Field_Name = "$NAME"
const Determine_Field_Arguments = "$ARGUMENTS"

func (op *Determine) Marshal(n jsn.Marshaler) {
	Determine_Marshal(n, op)
}

func Determine_Repeats_Marshal(n jsn.Marshaler, vals *[]Determine) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Determine_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Determine_Optional_Marshal(n jsn.Marshaler, val **Determine) {
	if *val != nil {
		Determine_Marshal(n, *val)
	}
}

func Determine_Marshal(n jsn.Marshaler, val *Determine) {
	if n.MapValues(Determine_Type, Determine_Type) {
		if n.MapKey("", Determine_Field_Name) {
			value.PatternName_Marshal(n, &val.Name)
		}
		if n.MapKey("arguments", Determine_Field_Arguments) {
			Arguments_Optional_Marshal(n, &val.Arguments)
		}
		n.EndValues()
	}
	return
}

// Determiner requires a user-specified string.
type Determiner struct {
	Str string
}

func (op *Determiner) String() string {
	return op.Str
}

const Determiner_A = "$A"
const Determiner_An = "$AN"
const Determiner_The = "$THE"
const Determiner_Our = "$OUR"

func (*Determiner) Compose() composer.Spec {
	return composer.Spec{
		Name:        Determiner_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			Determiner_A, Determiner_An, Determiner_The, Determiner_Our,
		},
		Strings: []string{
			"a", "an", "the", "our",
		},
	}
}

func (op *Determiner) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const Determiner_Type = "determiner"

func (op *Determiner) Marshal(n jsn.Marshaler) {
	Determiner_Marshal(n, op)
}

func Determiner_Optional_Marshal(n jsn.Marshaler, val *Determiner) {
	var zero Determiner
	if val.Str != zero.Str {
		Determiner_Marshal(n, val)
	}
}

func Determiner_Marshal(n jsn.Marshaler, val *Determiner) {
	n.SpecifyEnum(Determiner_Type, val)
}

func Determiner_Repeats_Marshal(n jsn.Marshaler, vals *[]Determiner) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Determiner_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// EventBlock Listeners let objects in the game world react to changes before, during, or after they happen.
type EventBlock struct {
	At       reader.Position `if:"internal"`
	Target   EventTarget     `if:"label=target"`
	Handlers []EventHandler  `if:"label=handlers"`
}

func (*EventBlock) Compose() composer.Spec {
	return composer.Spec{
		Name: EventBlock_Type,
		Uses: composer.Type_Flow,
	}
}

const EventBlock_Type = "event_block"

const EventBlock_Field_Target = "$TARGET"
const EventBlock_Field_Handlers = "$HANDLERS"

func (op *EventBlock) Marshal(n jsn.Marshaler) {
	EventBlock_Marshal(n, op)
}

func EventBlock_Repeats_Marshal(n jsn.Marshaler, vals *[]EventBlock) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				EventBlock_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func EventBlock_Optional_Marshal(n jsn.Marshaler, val **EventBlock) {
	if *val != nil {
		EventBlock_Marshal(n, *val)
	}
}

func EventBlock_Marshal(n jsn.Marshaler, val *EventBlock) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(EventBlock_Type, EventBlock_Type) {
		if n.MapKey("target", EventBlock_Field_Target) {
			EventTarget_Marshal(n, &val.Target)
		}
		if n.MapKey("handlers", EventBlock_Field_Handlers) {
			EventHandler_Repeats_Marshal(n, &val.Handlers)
		}
		n.EndValues()
	}
	return
}

// EventHandler
type EventHandler struct {
	EventPhase   EventPhase     `if:"label=_"`
	Event        EventName      `if:"label=event"`
	Locals       *PatternLocals `if:"label=locals,optional"`
	PatternRules PatternRules   `if:"label=pattern_rules"`
}

func (*EventHandler) Compose() composer.Spec {
	return composer.Spec{
		Name: EventHandler_Type,
		Uses: composer.Type_Flow,
	}
}

const EventHandler_Type = "event_handler"

const EventHandler_Field_EventPhase = "$EVENT_PHASE"
const EventHandler_Field_Event = "$EVENT"
const EventHandler_Field_Locals = "$LOCALS"
const EventHandler_Field_PatternRules = "$PATTERN_RULES"

func (op *EventHandler) Marshal(n jsn.Marshaler) {
	EventHandler_Marshal(n, op)
}

func EventHandler_Repeats_Marshal(n jsn.Marshaler, vals *[]EventHandler) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				EventHandler_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func EventHandler_Optional_Marshal(n jsn.Marshaler, val **EventHandler) {
	if *val != nil {
		EventHandler_Marshal(n, *val)
	}
}

func EventHandler_Marshal(n jsn.Marshaler, val *EventHandler) {
	if n.MapValues(EventHandler_Type, EventHandler_Type) {
		if n.MapKey("", EventHandler_Field_EventPhase) {
			EventPhase_Marshal(n, &val.EventPhase)
		}
		if n.MapKey("event", EventHandler_Field_Event) {
			EventName_Marshal(n, &val.Event)
		}
		if n.MapKey("locals", EventHandler_Field_Locals) {
			PatternLocals_Optional_Marshal(n, &val.Locals)
		}
		if n.MapKey("pattern_rules", EventHandler_Field_PatternRules) {
			PatternRules_Marshal(n, &val.PatternRules)
		}
		n.EndValues()
	}
	return
}

// EventName requires a user-specified string.
type EventName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *EventName) String() string {
	return op.Str
}

func (*EventName) Compose() composer.Spec {
	return composer.Spec{
		Name:        EventName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *EventName) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const EventName_Type = "event_name"

func (op *EventName) Marshal(n jsn.Marshaler) {
	EventName_Marshal(n, op)
}

func EventName_Optional_Marshal(n jsn.Marshaler, val *EventName) {
	var zero EventName
	if val.Str != zero.Str {
		EventName_Marshal(n, val)
	}
}

func EventName_Marshal(n jsn.Marshaler, val *EventName) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(EventName_Type, val.Str)
}

func EventName_Repeats_Marshal(n jsn.Marshaler, vals *[]EventName) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				EventName_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// EventPhase requires a user-specified string.
type EventPhase struct {
	Str string
}

func (op *EventPhase) String() string {
	return op.Str
}

const EventPhase_Before = "$BEFORE"
const EventPhase_While = "$WHILE"
const EventPhase_After = "$AFTER"

func (*EventPhase) Compose() composer.Spec {
	return composer.Spec{
		Name: EventPhase_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			EventPhase_Before, EventPhase_While, EventPhase_After,
		},
		Strings: []string{
			"before", "while", "after",
		},
	}
}

func (op *EventPhase) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const EventPhase_Type = "event_phase"

func (op *EventPhase) Marshal(n jsn.Marshaler) {
	EventPhase_Marshal(n, op)
}

func EventPhase_Optional_Marshal(n jsn.Marshaler, val *EventPhase) {
	var zero EventPhase
	if val.Str != zero.Str {
		EventPhase_Marshal(n, val)
	}
}

func EventPhase_Marshal(n jsn.Marshaler, val *EventPhase) {
	n.SpecifyEnum(EventPhase_Type, val)
}

func EventPhase_Repeats_Marshal(n jsn.Marshaler, vals *[]EventPhase) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				EventPhase_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// EventTarget swaps between various options
type EventTarget struct {
	Opt interface{}
}

const EventTarget_Kinds_Opt = "$KINDS"
const EventTarget_NamedNoun_Opt = "$NAMED_NOUN"

func (*EventTarget) Compose() composer.Spec {
	return composer.Spec{
		Name: EventTarget_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			EventTarget_Kinds_Opt, EventTarget_NamedNoun_Opt,
		},
		Swaps: []interface{}{
			(*PluralKinds)(nil),
			(*NamedNoun)(nil),
		},
	}
}

const EventTarget_Type = "event_target"

func (op *EventTarget) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PluralKinds:
		ret, okay = EventTarget_Kinds_Opt, true
	case *NamedNoun:
		ret, okay = EventTarget_NamedNoun_Opt, true
	}
	return
}
func (op *EventTarget) Marshal(n jsn.Marshaler) {
	EventTarget_Marshal(n, op)
}
func EventTarget_Marshal(n jsn.Marshaler, val *EventTarget) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			if n.PickValues(EventTarget_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func EventTarget_Repeats_Marshal(n jsn.Marshaler, vals *[]EventTarget) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				EventTarget_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// ExtType swaps between various options
type ExtType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ExtType_Numbers_Opt = "$NUMBERS"
const ExtType_TextList_Opt = "$TEXT_LIST"
const ExtType_Record_Opt = "$RECORD"
const ExtType_Records_Opt = "$RECORDS"

func (*ExtType) Compose() composer.Spec {
	return composer.Spec{
		Name: ExtType_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			ExtType_Numbers_Opt, ExtType_TextList_Opt, ExtType_Record_Opt, ExtType_Records_Opt,
		},
		Swaps: []interface{}{
			(*NumberList)(nil),
			(*TextList)(nil),
			(*RecordType)(nil),
			(*RecordList)(nil),
		},
	}
}

const ExtType_Type = "ext_type"

func (op *ExtType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *NumberList:
		ret, okay = ExtType_Numbers_Opt, true
	case *TextList:
		ret, okay = ExtType_TextList_Opt, true
	case *RecordType:
		ret, okay = ExtType_Record_Opt, true
	case *RecordList:
		ret, okay = ExtType_Records_Opt, true
	}
	return
}
func (op *ExtType) Marshal(n jsn.Marshaler) {
	ExtType_Marshal(n, op)
}
func ExtType_Marshal(n jsn.Marshaler, val *ExtType) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			n.SetCursor(val.At.Offset)
			if n.PickValues(ExtType_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func ExtType_Repeats_Marshal(n jsn.Marshaler, vals *[]ExtType) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ExtType_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// GrammarDecl
type GrammarDecl struct {
	Grammar grammar.GrammarMaker `if:"label=_"`
}

func (*GrammarDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: GrammarDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const GrammarDecl_Type = "grammar_decl"

const GrammarDecl_Field_Grammar = "$GRAMMAR"

func (op *GrammarDecl) Marshal(n jsn.Marshaler) {
	GrammarDecl_Marshal(n, op)
}

func GrammarDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]GrammarDecl) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				GrammarDecl_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func GrammarDecl_Optional_Marshal(n jsn.Marshaler, val **GrammarDecl) {
	if *val != nil {
		GrammarDecl_Marshal(n, *val)
	}
}

func GrammarDecl_Marshal(n jsn.Marshaler, val *GrammarDecl) {
	if n.MapValues(GrammarDecl_Type, GrammarDecl_Type) {
		if n.MapKey("", GrammarDecl_Field_Grammar) {
			grammar.GrammarMaker_Marshal(n, &val.Grammar)
		}
		n.EndValues()
	}
	return
}

// KindOfNoun
type KindOfNoun struct {
	AreAn        AreAn         `if:"label=_"`
	Trait        []Trait       `if:"label=trait,optional"`
	Kind         SingularKind  `if:"label=kind"`
	NounRelation *NounRelation `if:"label=noun_relation,optional"`
}

func (*KindOfNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: KindOfNoun_Type,
		Uses: composer.Type_Flow,
	}
}

const KindOfNoun_Type = "kind_of_noun"

const KindOfNoun_Field_AreAn = "$ARE_AN"
const KindOfNoun_Field_Trait = "$TRAIT"
const KindOfNoun_Field_Kind = "$KIND"
const KindOfNoun_Field_NounRelation = "$NOUN_RELATION"

func (op *KindOfNoun) Marshal(n jsn.Marshaler) {
	KindOfNoun_Marshal(n, op)
}

func KindOfNoun_Repeats_Marshal(n jsn.Marshaler, vals *[]KindOfNoun) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				KindOfNoun_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func KindOfNoun_Optional_Marshal(n jsn.Marshaler, val **KindOfNoun) {
	if *val != nil {
		KindOfNoun_Marshal(n, *val)
	}
}

func KindOfNoun_Marshal(n jsn.Marshaler, val *KindOfNoun) {
	if n.MapValues(KindOfNoun_Type, KindOfNoun_Type) {
		if n.MapKey("", KindOfNoun_Field_AreAn) {
			AreAn_Marshal(n, &val.AreAn)
		}
		if n.MapKey("trait", KindOfNoun_Field_Trait) {
			Trait_Repeats_Marshal(n, &val.Trait)
		}
		if n.MapKey("kind", KindOfNoun_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		if n.MapKey("noun_relation", KindOfNoun_Field_NounRelation) {
			NounRelation_Optional_Marshal(n, &val.NounRelation)
		}
		n.EndValues()
	}
	return
}

// KindOfRelation
type KindOfRelation struct {
	Relation    value.RelationName  `if:"label=_"`
	Cardinality RelationCardinality `if:"label=cardinality"`
}

func (*KindOfRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: KindOfRelation_Type,
		Uses: composer.Type_Flow,
	}
}

const KindOfRelation_Type = "kind_of_relation"

const KindOfRelation_Field_Relation = "$RELATION"
const KindOfRelation_Field_Cardinality = "$CARDINALITY"

func (op *KindOfRelation) Marshal(n jsn.Marshaler) {
	KindOfRelation_Marshal(n, op)
}

func KindOfRelation_Repeats_Marshal(n jsn.Marshaler, vals *[]KindOfRelation) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				KindOfRelation_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func KindOfRelation_Optional_Marshal(n jsn.Marshaler, val **KindOfRelation) {
	if *val != nil {
		KindOfRelation_Marshal(n, *val)
	}
}

func KindOfRelation_Marshal(n jsn.Marshaler, val *KindOfRelation) {
	if n.MapValues(KindOfRelation_Type, KindOfRelation_Type) {
		if n.MapKey("", KindOfRelation_Field_Relation) {
			value.RelationName_Marshal(n, &val.Relation)
		}
		if n.MapKey("cardinality", KindOfRelation_Field_Cardinality) {
			RelationCardinality_Marshal(n, &val.Cardinality)
		}
		n.EndValues()
	}
	return
}

// KindsOfAspect
type KindsOfAspect struct {
	Aspect Aspect `if:"label=_"`
}

func (*KindsOfAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: KindsOfAspect_Type,
		Uses: composer.Type_Flow,
	}
}

const KindsOfAspect_Type = "kinds_of_aspect"

const KindsOfAspect_Field_Aspect = "$ASPECT"

func (op *KindsOfAspect) Marshal(n jsn.Marshaler) {
	KindsOfAspect_Marshal(n, op)
}

func KindsOfAspect_Repeats_Marshal(n jsn.Marshaler, vals *[]KindsOfAspect) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				KindsOfAspect_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func KindsOfAspect_Optional_Marshal(n jsn.Marshaler, val **KindsOfAspect) {
	if *val != nil {
		KindsOfAspect_Marshal(n, *val)
	}
}

func KindsOfAspect_Marshal(n jsn.Marshaler, val *KindsOfAspect) {
	if n.MapValues(KindsOfAspect_Type, KindsOfAspect_Type) {
		if n.MapKey("", KindsOfAspect_Field_Aspect) {
			Aspect_Marshal(n, &val.Aspect)
		}
		n.EndValues()
	}
	return
}

// KindsOfKind
type KindsOfKind struct {
	PluralKinds  PluralKinds  `if:"label=_"`
	SingularKind SingularKind `if:"label=singular_kind"`
}

func (*KindsOfKind) Compose() composer.Spec {
	return composer.Spec{
		Name: KindsOfKind_Type,
		Uses: composer.Type_Flow,
	}
}

const KindsOfKind_Type = "kinds_of_kind"

const KindsOfKind_Field_PluralKinds = "$PLURAL_KINDS"
const KindsOfKind_Field_SingularKind = "$SINGULAR_KIND"

func (op *KindsOfKind) Marshal(n jsn.Marshaler) {
	KindsOfKind_Marshal(n, op)
}

func KindsOfKind_Repeats_Marshal(n jsn.Marshaler, vals *[]KindsOfKind) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				KindsOfKind_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func KindsOfKind_Optional_Marshal(n jsn.Marshaler, val **KindsOfKind) {
	if *val != nil {
		KindsOfKind_Marshal(n, *val)
	}
}

func KindsOfKind_Marshal(n jsn.Marshaler, val *KindsOfKind) {
	if n.MapValues(KindsOfKind_Type, KindsOfKind_Type) {
		if n.MapKey("", KindsOfKind_Field_PluralKinds) {
			PluralKinds_Marshal(n, &val.PluralKinds)
		}
		if n.MapKey("singular_kind", KindsOfKind_Field_SingularKind) {
			SingularKind_Marshal(n, &val.SingularKind)
		}
		n.EndValues()
	}
	return
}

// KindsOfRecord
type KindsOfRecord struct {
	RecordPlural RecordPlural `if:"label=_"`
}

func (*KindsOfRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: KindsOfRecord_Type,
		Uses: composer.Type_Flow,
	}
}

const KindsOfRecord_Type = "kinds_of_record"

const KindsOfRecord_Field_RecordPlural = "$RECORD_PLURAL"

func (op *KindsOfRecord) Marshal(n jsn.Marshaler) {
	KindsOfRecord_Marshal(n, op)
}

func KindsOfRecord_Repeats_Marshal(n jsn.Marshaler, vals *[]KindsOfRecord) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				KindsOfRecord_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func KindsOfRecord_Optional_Marshal(n jsn.Marshaler, val **KindsOfRecord) {
	if *val != nil {
		KindsOfRecord_Marshal(n, *val)
	}
}

func KindsOfRecord_Marshal(n jsn.Marshaler, val *KindsOfRecord) {
	if n.MapValues(KindsOfRecord_Type, KindsOfRecord_Type) {
		if n.MapKey("", KindsOfRecord_Field_RecordPlural) {
			RecordPlural_Marshal(n, &val.RecordPlural)
		}
		n.EndValues()
	}
	return
}

// KindsPossessProperties
type KindsPossessProperties struct {
	PluralKinds  PluralKinds    `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*KindsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: KindsPossessProperties_Type,
		Uses: composer.Type_Flow,
	}
}

const KindsPossessProperties_Type = "kinds_possess_properties"

const KindsPossessProperties_Field_PluralKinds = "$PLURAL_KINDS"
const KindsPossessProperties_Field_PropertyDecl = "$PROPERTY_DECL"

func (op *KindsPossessProperties) Marshal(n jsn.Marshaler) {
	KindsPossessProperties_Marshal(n, op)
}

func KindsPossessProperties_Repeats_Marshal(n jsn.Marshaler, vals *[]KindsPossessProperties) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				KindsPossessProperties_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func KindsPossessProperties_Optional_Marshal(n jsn.Marshaler, val **KindsPossessProperties) {
	if *val != nil {
		KindsPossessProperties_Marshal(n, *val)
	}
}

func KindsPossessProperties_Marshal(n jsn.Marshaler, val *KindsPossessProperties) {
	if n.MapValues(KindsPossessProperties_Type, KindsPossessProperties_Type) {
		if n.MapKey("", KindsPossessProperties_Field_PluralKinds) {
			PluralKinds_Marshal(n, &val.PluralKinds)
		}
		if n.MapKey("property_decl", KindsPossessProperties_Field_PropertyDecl) {
			PropertyDecl_Repeats_Marshal(n, &val.PropertyDecl)
		}
		n.EndValues()
	}
	return
}

// Lede Describes one or more nouns.
type Lede struct {
	Nouns      []NamedNoun `if:"label=_"`
	NounPhrase NounPhrase  `if:"label=noun_phrase"`
}

func (*Lede) Compose() composer.Spec {
	return composer.Spec{
		Name: Lede_Type,
		Uses: composer.Type_Flow,
	}
}

const Lede_Type = "lede"

const Lede_Field_Nouns = "$NOUNS"
const Lede_Field_NounPhrase = "$NOUN_PHRASE"

func (op *Lede) Marshal(n jsn.Marshaler) {
	Lede_Marshal(n, op)
}

func Lede_Repeats_Marshal(n jsn.Marshaler, vals *[]Lede) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Lede_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Lede_Optional_Marshal(n jsn.Marshaler, val **Lede) {
	if *val != nil {
		Lede_Marshal(n, *val)
	}
}

func Lede_Marshal(n jsn.Marshaler, val *Lede) {
	if n.MapValues(Lede_Type, Lede_Type) {
		if n.MapKey("", Lede_Field_Nouns) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns)
		}
		if n.MapKey("noun_phrase", Lede_Field_NounPhrase) {
			NounPhrase_Marshal(n, &val.NounPhrase)
		}
		n.EndValues()
	}
	return
}

// LocalDecl
type LocalDecl struct {
	VariableDecl VariableDecl `if:"label=_"`
	Value        *LocalInit   `if:"label=value,optional"`
}

func (*LocalDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: LocalDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const LocalDecl_Type = "local_decl"

const LocalDecl_Field_VariableDecl = "$VARIABLE_DECL"
const LocalDecl_Field_Value = "$VALUE"

func (op *LocalDecl) Marshal(n jsn.Marshaler) {
	LocalDecl_Marshal(n, op)
}

func LocalDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]LocalDecl) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				LocalDecl_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func LocalDecl_Optional_Marshal(n jsn.Marshaler, val **LocalDecl) {
	if *val != nil {
		LocalDecl_Marshal(n, *val)
	}
}

func LocalDecl_Marshal(n jsn.Marshaler, val *LocalDecl) {
	if n.MapValues(LocalDecl_Type, LocalDecl_Type) {
		if n.MapKey("", LocalDecl_Field_VariableDecl) {
			VariableDecl_Marshal(n, &val.VariableDecl)
		}
		if n.MapKey("value", LocalDecl_Field_Value) {
			LocalInit_Optional_Marshal(n, &val.Value)
		}
		n.EndValues()
	}
	return
}

// LocalInit
type LocalInit struct {
	Value rt.Assignment `if:"label=_"`
}

func (*LocalInit) Compose() composer.Spec {
	return composer.Spec{
		Name: LocalInit_Type,
		Uses: composer.Type_Flow,
	}
}

const LocalInit_Type = "local_init"

const LocalInit_Field_Value = "$VALUE"

func (op *LocalInit) Marshal(n jsn.Marshaler) {
	LocalInit_Marshal(n, op)
}

func LocalInit_Repeats_Marshal(n jsn.Marshaler, vals *[]LocalInit) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				LocalInit_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func LocalInit_Optional_Marshal(n jsn.Marshaler, val **LocalInit) {
	if *val != nil {
		LocalInit_Marshal(n, *val)
	}
}

func LocalInit_Marshal(n jsn.Marshaler, val *LocalInit) {
	if n.MapValues(LocalInit_Type, LocalInit_Type) {
		if n.MapKey("", LocalInit_Field_Value) {
			rt.Assignment_Marshal(n, &val.Value)
		}
		n.EndValues()
	}
	return
}

// Make
type Make struct {
	Name      string     `if:"label=_,type=text"`
	Arguments *Arguments `if:"label=arguments,optional"`
}

func (*Make) Compose() composer.Spec {
	return composer.Spec{
		Name: Make_Type,
		Uses: composer.Type_Flow,
	}
}

const Make_Type = "make"

const Make_Field_Name = "$NAME"
const Make_Field_Arguments = "$ARGUMENTS"

func (op *Make) Marshal(n jsn.Marshaler) {
	Make_Marshal(n, op)
}

func Make_Repeats_Marshal(n jsn.Marshaler, vals *[]Make) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Make_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Make_Optional_Marshal(n jsn.Marshaler, val **Make) {
	if *val != nil {
		Make_Marshal(n, *val)
	}
}

func Make_Marshal(n jsn.Marshaler, val *Make) {
	if n.MapValues(Make_Type, Make_Type) {
		if n.MapKey("", Make_Field_Name) {
			value.Text_Unboxed_Marshal(n, &val.Name)
		}
		if n.MapKey("arguments", Make_Field_Arguments) {
			Arguments_Optional_Marshal(n, &val.Arguments)
		}
		n.EndValues()
	}
	return
}

// ManyToMany
type ManyToMany struct {
	Kinds      PluralKinds `if:"label=_"`
	OtherKinds PluralKinds `if:"label=other_kinds"`
}

func (*ManyToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyToMany_Type,
		Uses: composer.Type_Flow,
	}
}

const ManyToMany_Type = "many_to_many"

const ManyToMany_Field_Kinds = "$KINDS"
const ManyToMany_Field_OtherKinds = "$OTHER_KINDS"

func (op *ManyToMany) Marshal(n jsn.Marshaler) {
	ManyToMany_Marshal(n, op)
}

func ManyToMany_Repeats_Marshal(n jsn.Marshaler, vals *[]ManyToMany) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ManyToMany_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func ManyToMany_Optional_Marshal(n jsn.Marshaler, val **ManyToMany) {
	if *val != nil {
		ManyToMany_Marshal(n, *val)
	}
}

func ManyToMany_Marshal(n jsn.Marshaler, val *ManyToMany) {
	if n.MapValues(ManyToMany_Type, ManyToMany_Type) {
		if n.MapKey("", ManyToMany_Field_Kinds) {
			PluralKinds_Marshal(n, &val.Kinds)
		}
		if n.MapKey("other_kinds", ManyToMany_Field_OtherKinds) {
			PluralKinds_Marshal(n, &val.OtherKinds)
		}
		n.EndValues()
	}
	return
}

// ManyToOne
type ManyToOne struct {
	Kinds PluralKinds  `if:"label=_"`
	Kind  SingularKind `if:"label=kind"`
}

func (*ManyToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: ManyToOne_Type,
		Uses: composer.Type_Flow,
	}
}

const ManyToOne_Type = "many_to_one"

const ManyToOne_Field_Kinds = "$KINDS"
const ManyToOne_Field_Kind = "$KIND"

func (op *ManyToOne) Marshal(n jsn.Marshaler) {
	ManyToOne_Marshal(n, op)
}

func ManyToOne_Repeats_Marshal(n jsn.Marshaler, vals *[]ManyToOne) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ManyToOne_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func ManyToOne_Optional_Marshal(n jsn.Marshaler, val **ManyToOne) {
	if *val != nil {
		ManyToOne_Marshal(n, *val)
	}
}

func ManyToOne_Marshal(n jsn.Marshaler, val *ManyToOne) {
	if n.MapValues(ManyToOne_Type, ManyToOne_Type) {
		if n.MapKey("", ManyToOne_Field_Kinds) {
			PluralKinds_Marshal(n, &val.Kinds)
		}
		if n.MapKey("kind", ManyToOne_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		n.EndValues()
	}
	return
}

// NamedNoun
type NamedNoun struct {
	Determiner Determiner `if:"label=_"`
	Name       NounName   `if:"label=name"`
}

func (*NamedNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: NamedNoun_Type,
		Uses: composer.Type_Flow,
	}
}

const NamedNoun_Type = "named_noun"

const NamedNoun_Field_Determiner = "$DETERMINER"
const NamedNoun_Field_Name = "$NAME"

func (op *NamedNoun) Marshal(n jsn.Marshaler) {
	NamedNoun_Marshal(n, op)
}

func NamedNoun_Repeats_Marshal(n jsn.Marshaler, vals *[]NamedNoun) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				NamedNoun_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func NamedNoun_Optional_Marshal(n jsn.Marshaler, val **NamedNoun) {
	if *val != nil {
		NamedNoun_Marshal(n, *val)
	}
}

func NamedNoun_Marshal(n jsn.Marshaler, val *NamedNoun) {
	if n.MapValues(NamedNoun_Type, NamedNoun_Type) {
		if n.MapKey("", NamedNoun_Field_Determiner) {
			Determiner_Marshal(n, &val.Determiner)
		}
		if n.MapKey("name", NamedNoun_Field_Name) {
			NounName_Marshal(n, &val.Name)
		}
		n.EndValues()
	}
	return
}

// NounAssignment Assign text.
type NounAssignment struct {
	Property Property    `if:"label=_"`
	Nouns    []NamedNoun `if:"label=nouns"`
	Lines    value.Lines `if:"label=lines"`
}

func (*NounAssignment) Compose() composer.Spec {
	return composer.Spec{
		Name: NounAssignment_Type,
		Uses: composer.Type_Flow,
	}
}

const NounAssignment_Type = "noun_assignment"

const NounAssignment_Field_Property = "$PROPERTY"
const NounAssignment_Field_Nouns = "$NOUNS"
const NounAssignment_Field_Lines = "$LINES"

func (op *NounAssignment) Marshal(n jsn.Marshaler) {
	NounAssignment_Marshal(n, op)
}

func NounAssignment_Repeats_Marshal(n jsn.Marshaler, vals *[]NounAssignment) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				NounAssignment_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func NounAssignment_Optional_Marshal(n jsn.Marshaler, val **NounAssignment) {
	if *val != nil {
		NounAssignment_Marshal(n, *val)
	}
}

func NounAssignment_Marshal(n jsn.Marshaler, val *NounAssignment) {
	if n.MapValues(NounAssignment_Type, NounAssignment_Type) {
		if n.MapKey("", NounAssignment_Field_Property) {
			Property_Marshal(n, &val.Property)
		}
		if n.MapKey("nouns", NounAssignment_Field_Nouns) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns)
		}
		if n.MapKey("lines", NounAssignment_Field_Lines) {
			value.Lines_Marshal(n, &val.Lines)
		}
		n.EndValues()
	}
	return
}

// NounName requires a user-specified string.
type NounName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *NounName) String() string {
	return op.Str
}

func (*NounName) Compose() composer.Spec {
	return composer.Spec{
		Name:        NounName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *NounName) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const NounName_Type = "noun_name"

func (op *NounName) Marshal(n jsn.Marshaler) {
	NounName_Marshal(n, op)
}

func NounName_Optional_Marshal(n jsn.Marshaler, val *NounName) {
	var zero NounName
	if val.Str != zero.Str {
		NounName_Marshal(n, val)
	}
}

func NounName_Marshal(n jsn.Marshaler, val *NounName) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(NounName_Type, val.Str)
}

func NounName_Repeats_Marshal(n jsn.Marshaler, vals *[]NounName) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				NounName_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// NounPhrase swaps between various options
type NounPhrase struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const NounPhrase_KindOfNoun_Opt = "$KIND_OF_NOUN"
const NounPhrase_NounTraits_Opt = "$NOUN_TRAITS"
const NounPhrase_NounRelation_Opt = "$NOUN_RELATION"

func (*NounPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: NounPhrase_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			NounPhrase_KindOfNoun_Opt, NounPhrase_NounTraits_Opt, NounPhrase_NounRelation_Opt,
		},
		Swaps: []interface{}{
			(*KindOfNoun)(nil),
			(*NounTraits)(nil),
			(*NounRelation)(nil),
		},
	}
}

const NounPhrase_Type = "noun_phrase"

func (op *NounPhrase) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *KindOfNoun:
		ret, okay = NounPhrase_KindOfNoun_Opt, true
	case *NounTraits:
		ret, okay = NounPhrase_NounTraits_Opt, true
	case *NounRelation:
		ret, okay = NounPhrase_NounRelation_Opt, true
	}
	return
}
func (op *NounPhrase) Marshal(n jsn.Marshaler) {
	NounPhrase_Marshal(n, op)
}
func NounPhrase_Marshal(n jsn.Marshaler, val *NounPhrase) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			n.SetCursor(val.At.Offset)
			if n.PickValues(NounPhrase_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func NounPhrase_Repeats_Marshal(n jsn.Marshaler, vals *[]NounPhrase) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				NounPhrase_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// NounRelation
type NounRelation struct {
	AreBeing AreBeing           `if:"label=_,optional"`
	Relation value.RelationName `if:"label=relation"`
	Nouns    []NamedNoun        `if:"label=nouns"`
}

func (*NounRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: NounRelation_Type,
		Uses: composer.Type_Flow,
	}
}

const NounRelation_Type = "noun_relation"

const NounRelation_Field_AreBeing = "$ARE_BEING"
const NounRelation_Field_Relation = "$RELATION"
const NounRelation_Field_Nouns = "$NOUNS"

func (op *NounRelation) Marshal(n jsn.Marshaler) {
	NounRelation_Marshal(n, op)
}

func NounRelation_Repeats_Marshal(n jsn.Marshaler, vals *[]NounRelation) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				NounRelation_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func NounRelation_Optional_Marshal(n jsn.Marshaler, val **NounRelation) {
	if *val != nil {
		NounRelation_Marshal(n, *val)
	}
}

func NounRelation_Marshal(n jsn.Marshaler, val *NounRelation) {
	if n.MapValues(NounRelation_Type, NounRelation_Type) {
		if n.MapKey("", NounRelation_Field_AreBeing) {
			AreBeing_Optional_Marshal(n, &val.AreBeing)
		}
		if n.MapKey("relation", NounRelation_Field_Relation) {
			value.RelationName_Marshal(n, &val.Relation)
		}
		if n.MapKey("nouns", NounRelation_Field_Nouns) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns)
		}
		n.EndValues()
	}
	return
}

// NounStatement Describes people, places, or things.
type NounStatement struct {
	Lede    Lede     `if:"label=_"`
	Tail    []Tail   `if:"label=tail,optional"`
	Summary *Summary `if:"label=summary,optional"`
}

func (*NounStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: NounStatement_Type,
		Uses: composer.Type_Flow,
	}
}

const NounStatement_Type = "noun_statement"

const NounStatement_Field_Lede = "$LEDE"
const NounStatement_Field_Tail = "$TAIL"
const NounStatement_Field_Summary = "$SUMMARY"

func (op *NounStatement) Marshal(n jsn.Marshaler) {
	NounStatement_Marshal(n, op)
}

func NounStatement_Repeats_Marshal(n jsn.Marshaler, vals *[]NounStatement) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				NounStatement_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func NounStatement_Optional_Marshal(n jsn.Marshaler, val **NounStatement) {
	if *val != nil {
		NounStatement_Marshal(n, *val)
	}
}

func NounStatement_Marshal(n jsn.Marshaler, val *NounStatement) {
	if n.MapValues(NounStatement_Type, NounStatement_Type) {
		if n.MapKey("", NounStatement_Field_Lede) {
			Lede_Marshal(n, &val.Lede)
		}
		if n.MapKey("tail", NounStatement_Field_Tail) {
			Tail_Repeats_Marshal(n, &val.Tail)
		}
		if n.MapKey("summary", NounStatement_Field_Summary) {
			Summary_Optional_Marshal(n, &val.Summary)
		}
		n.EndValues()
	}
	return
}

// NounTraits
type NounTraits struct {
	AreBeing AreBeing `if:"label=_"`
	Trait    []Trait  `if:"label=trait"`
}

func (*NounTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: NounTraits_Type,
		Uses: composer.Type_Flow,
	}
}

const NounTraits_Type = "noun_traits"

const NounTraits_Field_AreBeing = "$ARE_BEING"
const NounTraits_Field_Trait = "$TRAIT"

func (op *NounTraits) Marshal(n jsn.Marshaler) {
	NounTraits_Marshal(n, op)
}

func NounTraits_Repeats_Marshal(n jsn.Marshaler, vals *[]NounTraits) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				NounTraits_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func NounTraits_Optional_Marshal(n jsn.Marshaler, val **NounTraits) {
	if *val != nil {
		NounTraits_Marshal(n, *val)
	}
}

func NounTraits_Marshal(n jsn.Marshaler, val *NounTraits) {
	if n.MapValues(NounTraits_Type, NounTraits_Type) {
		if n.MapKey("", NounTraits_Field_AreBeing) {
			AreBeing_Marshal(n, &val.AreBeing)
		}
		if n.MapKey("trait", NounTraits_Field_Trait) {
			Trait_Repeats_Marshal(n, &val.Trait)
		}
		n.EndValues()
	}
	return
}

// NumberList requires a user-specified string.
type NumberList struct {
	Str string
}

func (op *NumberList) String() string {
	return op.Str
}

const NumberList_List = "$LIST"

func (*NumberList) Compose() composer.Spec {
	return composer.Spec{
		Name: NumberList_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			NumberList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

func (op *NumberList) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const NumberList_Type = "number_list"

func (op *NumberList) Marshal(n jsn.Marshaler) {
	NumberList_Marshal(n, op)
}

func NumberList_Optional_Marshal(n jsn.Marshaler, val *NumberList) {
	var zero NumberList
	if val.Str != zero.Str {
		NumberList_Marshal(n, val)
	}
}

func NumberList_Marshal(n jsn.Marshaler, val *NumberList) {
	n.SpecifyEnum(NumberList_Type, val)
}

func NumberList_Repeats_Marshal(n jsn.Marshaler, vals *[]NumberList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				NumberList_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// ObjectType
type ObjectType struct {
	An   Ana          `if:"label=_"`
	Kind SingularKind `if:"label=kind"`
}

func (*ObjectType) Compose() composer.Spec {
	return composer.Spec{
		Name: ObjectType_Type,
		Uses: composer.Type_Flow,
	}
}

const ObjectType_Type = "object_type"

const ObjectType_Field_An = "$AN"
const ObjectType_Field_Kind = "$KIND"

func (op *ObjectType) Marshal(n jsn.Marshaler) {
	ObjectType_Marshal(n, op)
}

func ObjectType_Repeats_Marshal(n jsn.Marshaler, vals *[]ObjectType) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ObjectType_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func ObjectType_Optional_Marshal(n jsn.Marshaler, val **ObjectType) {
	if *val != nil {
		ObjectType_Marshal(n, *val)
	}
}

func ObjectType_Marshal(n jsn.Marshaler, val *ObjectType) {
	if n.MapValues(ObjectType_Type, ObjectType_Type) {
		if n.MapKey("", ObjectType_Field_An) {
			Ana_Marshal(n, &val.An)
		}
		if n.MapKey("kind", ObjectType_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		n.EndValues()
	}
	return
}

// OneToMany
type OneToMany struct {
	Kind  SingularKind `if:"label=_"`
	Kinds PluralKinds  `if:"label=kinds"`
}

func (*OneToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: OneToMany_Type,
		Uses: composer.Type_Flow,
	}
}

const OneToMany_Type = "one_to_many"

const OneToMany_Field_Kind = "$KIND"
const OneToMany_Field_Kinds = "$KINDS"

func (op *OneToMany) Marshal(n jsn.Marshaler) {
	OneToMany_Marshal(n, op)
}

func OneToMany_Repeats_Marshal(n jsn.Marshaler, vals *[]OneToMany) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				OneToMany_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func OneToMany_Optional_Marshal(n jsn.Marshaler, val **OneToMany) {
	if *val != nil {
		OneToMany_Marshal(n, *val)
	}
}

func OneToMany_Marshal(n jsn.Marshaler, val *OneToMany) {
	if n.MapValues(OneToMany_Type, OneToMany_Type) {
		if n.MapKey("", OneToMany_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		if n.MapKey("kinds", OneToMany_Field_Kinds) {
			PluralKinds_Marshal(n, &val.Kinds)
		}
		n.EndValues()
	}
	return
}

// OneToOne
type OneToOne struct {
	Kind      SingularKind `if:"label=_"`
	OtherKind SingularKind `if:"label=other_kind"`
}

func (*OneToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: OneToOne_Type,
		Uses: composer.Type_Flow,
	}
}

const OneToOne_Type = "one_to_one"

const OneToOne_Field_Kind = "$KIND"
const OneToOne_Field_OtherKind = "$OTHER_KIND"

func (op *OneToOne) Marshal(n jsn.Marshaler) {
	OneToOne_Marshal(n, op)
}

func OneToOne_Repeats_Marshal(n jsn.Marshaler, vals *[]OneToOne) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				OneToOne_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func OneToOne_Optional_Marshal(n jsn.Marshaler, val **OneToOne) {
	if *val != nil {
		OneToOne_Marshal(n, *val)
	}
}

func OneToOne_Marshal(n jsn.Marshaler, val *OneToOne) {
	if n.MapValues(OneToOne_Type, OneToOne_Type) {
		if n.MapKey("", OneToOne_Field_Kind) {
			SingularKind_Marshal(n, &val.Kind)
		}
		if n.MapKey("other_kind", OneToOne_Field_OtherKind) {
			SingularKind_Marshal(n, &val.OtherKind)
		}
		n.EndValues()
	}
	return
}

// PairedAction
type PairedAction struct {
	At    reader.Position `if:"internal"`
	Kinds PluralKinds     `if:"label=kinds"`
}

func (*PairedAction) Compose() composer.Spec {
	return composer.Spec{
		Name: PairedAction_Type,
		Uses: composer.Type_Flow,
	}
}

const PairedAction_Type = "paired_action"

const PairedAction_Field_Kinds = "$KINDS"

func (op *PairedAction) Marshal(n jsn.Marshaler) {
	PairedAction_Marshal(n, op)
}

func PairedAction_Repeats_Marshal(n jsn.Marshaler, vals *[]PairedAction) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PairedAction_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PairedAction_Optional_Marshal(n jsn.Marshaler, val **PairedAction) {
	if *val != nil {
		PairedAction_Marshal(n, *val)
	}
}

func PairedAction_Marshal(n jsn.Marshaler, val *PairedAction) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(PairedAction_Type, PairedAction_Type) {
		if n.MapKey("kinds", PairedAction_Field_Kinds) {
			PluralKinds_Marshal(n, &val.Kinds)
		}
		n.EndValues()
	}
	return
}

// Paragraph
type Paragraph struct {
	StoryStatement []StoryStatement `if:"label=_,optional"`
}

func (*Paragraph) Compose() composer.Spec {
	return composer.Spec{
		Name: Paragraph_Type,
		Uses: composer.Type_Flow,
	}
}

const Paragraph_Type = "paragraph"

const Paragraph_Field_StoryStatement = "$STORY_STATEMENT"

func (op *Paragraph) Marshal(n jsn.Marshaler) {
	Paragraph_Marshal(n, op)
}

func Paragraph_Repeats_Marshal(n jsn.Marshaler, vals *[]Paragraph) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Paragraph_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Paragraph_Optional_Marshal(n jsn.Marshaler, val **Paragraph) {
	if *val != nil {
		Paragraph_Marshal(n, *val)
	}
}

func Paragraph_Marshal(n jsn.Marshaler, val *Paragraph) {
	if n.MapValues(Paragraph_Type, Paragraph_Type) {
		if n.MapKey("", Paragraph_Field_StoryStatement) {
			StoryStatement_Repeats_Marshal(n, &val.StoryStatement)
		}
		n.EndValues()
	}
	return
}

// PatternActions Actions to take when using a pattern.
type PatternActions struct {
	Name          value.PatternName `if:"label=_"`
	PatternLocals *PatternLocals    `if:"label=pattern_locals,optional"`
	PatternReturn *PatternReturn    `if:"label=pattern_return,optional"`
	PatternRules  PatternRules      `if:"label=pattern_rules"`
}

func (*PatternActions) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternActions_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternActions_Type = "pattern_actions"

const PatternActions_Field_Name = "$NAME"
const PatternActions_Field_PatternLocals = "$PATTERN_LOCALS"
const PatternActions_Field_PatternReturn = "$PATTERN_RETURN"
const PatternActions_Field_PatternRules = "$PATTERN_RULES"

func (op *PatternActions) Marshal(n jsn.Marshaler) {
	PatternActions_Marshal(n, op)
}

func PatternActions_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternActions) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternActions_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PatternActions_Optional_Marshal(n jsn.Marshaler, val **PatternActions) {
	if *val != nil {
		PatternActions_Marshal(n, *val)
	}
}

func PatternActions_Marshal(n jsn.Marshaler, val *PatternActions) {
	if n.MapValues(PatternActions_Type, PatternActions_Type) {
		if n.MapKey("", PatternActions_Field_Name) {
			value.PatternName_Marshal(n, &val.Name)
		}
		if n.MapKey("pattern_locals", PatternActions_Field_PatternLocals) {
			PatternLocals_Optional_Marshal(n, &val.PatternLocals)
		}
		if n.MapKey("pattern_return", PatternActions_Field_PatternReturn) {
			PatternReturn_Optional_Marshal(n, &val.PatternReturn)
		}
		if n.MapKey("pattern_rules", PatternActions_Field_PatternRules) {
			PatternRules_Marshal(n, &val.PatternRules)
		}
		n.EndValues()
	}
	return
}

// PatternDecl
type PatternDecl struct {
	Type          PatternType           `if:"label=_"`
	Name          value.PatternName     `if:"label=name"`
	Optvars       *PatternVariablesTail `if:"label=optvars,optional"`
	PatternReturn *PatternReturn        `if:"label=pattern_return,optional"`
	About         *Comment              `if:"label=about,optional"`
}

func (*PatternDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternDecl_Type = "pattern_decl"

const PatternDecl_Field_Type = "$TYPE"
const PatternDecl_Field_Name = "$NAME"
const PatternDecl_Field_Optvars = "$OPTVARS"
const PatternDecl_Field_PatternReturn = "$PATTERN_RETURN"
const PatternDecl_Field_About = "$ABOUT"

func (op *PatternDecl) Marshal(n jsn.Marshaler) {
	PatternDecl_Marshal(n, op)
}

func PatternDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternDecl) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternDecl_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PatternDecl_Optional_Marshal(n jsn.Marshaler, val **PatternDecl) {
	if *val != nil {
		PatternDecl_Marshal(n, *val)
	}
}

func PatternDecl_Marshal(n jsn.Marshaler, val *PatternDecl) {
	if n.MapValues(PatternDecl_Type, PatternDecl_Type) {
		if n.MapKey("", PatternDecl_Field_Type) {
			PatternType_Marshal(n, &val.Type)
		}
		if n.MapKey("name", PatternDecl_Field_Name) {
			value.PatternName_Marshal(n, &val.Name)
		}
		if n.MapKey("optvars", PatternDecl_Field_Optvars) {
			PatternVariablesTail_Optional_Marshal(n, &val.Optvars)
		}
		if n.MapKey("pattern_return", PatternDecl_Field_PatternReturn) {
			PatternReturn_Optional_Marshal(n, &val.PatternReturn)
		}
		if n.MapKey("about", PatternDecl_Field_About) {
			Comment_Optional_Marshal(n, &val.About)
		}
		n.EndValues()
	}
	return
}

// PatternFlags requires a user-specified string.
type PatternFlags struct {
	Str string
}

func (op *PatternFlags) String() string {
	return op.Str
}

const PatternFlags_Before = "$BEFORE"
const PatternFlags_After = "$AFTER"
const PatternFlags_Terminate = "$TERMINATE"

func (*PatternFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternFlags_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			PatternFlags_Before, PatternFlags_After, PatternFlags_Terminate,
		},
		Strings: []string{
			"before", "after", "terminate",
		},
	}
}

func (op *PatternFlags) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const PatternFlags_Type = "pattern_flags"

func (op *PatternFlags) Marshal(n jsn.Marshaler) {
	PatternFlags_Marshal(n, op)
}

func PatternFlags_Optional_Marshal(n jsn.Marshaler, val *PatternFlags) {
	var zero PatternFlags
	if val.Str != zero.Str {
		PatternFlags_Marshal(n, val)
	}
}

func PatternFlags_Marshal(n jsn.Marshaler, val *PatternFlags) {
	n.SpecifyEnum(PatternFlags_Type, val)
}

func PatternFlags_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternFlags) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternFlags_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// PatternLocals
type PatternLocals struct {
	LocalDecl []LocalDecl `if:"label=_"`
}

func (*PatternLocals) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternLocals_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternLocals_Type = "pattern_locals"

const PatternLocals_Field_LocalDecl = "$LOCAL_DECL"

func (op *PatternLocals) Marshal(n jsn.Marshaler) {
	PatternLocals_Marshal(n, op)
}

func PatternLocals_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternLocals) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternLocals_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PatternLocals_Optional_Marshal(n jsn.Marshaler, val **PatternLocals) {
	if *val != nil {
		PatternLocals_Marshal(n, *val)
	}
}

func PatternLocals_Marshal(n jsn.Marshaler, val *PatternLocals) {
	if n.MapValues(PatternLocals_Type, PatternLocals_Type) {
		if n.MapKey("", PatternLocals_Field_LocalDecl) {
			LocalDecl_Repeats_Marshal(n, &val.LocalDecl)
		}
		n.EndValues()
	}
	return
}

// PatternReturn
type PatternReturn struct {
	Result VariableDecl `if:"label=_"`
}

func (*PatternReturn) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternReturn_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternReturn_Type = "pattern_return"

const PatternReturn_Field_Result = "$RESULT"

func (op *PatternReturn) Marshal(n jsn.Marshaler) {
	PatternReturn_Marshal(n, op)
}

func PatternReturn_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternReturn) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternReturn_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PatternReturn_Optional_Marshal(n jsn.Marshaler, val **PatternReturn) {
	if *val != nil {
		PatternReturn_Marshal(n, *val)
	}
}

func PatternReturn_Marshal(n jsn.Marshaler, val *PatternReturn) {
	if n.MapValues(PatternReturn_Type, PatternReturn_Type) {
		if n.MapKey("", PatternReturn_Field_Result) {
			VariableDecl_Marshal(n, &val.Result)
		}
		n.EndValues()
	}
	return
}

// PatternRule
type PatternRule struct {
	Guard rt.BoolEval  `if:"label=_"`
	Flags PatternFlags `if:"label=flags,optional"`
	Hook  ProgramHook  `if:"label=hook"`
}

func (*PatternRule) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternRule_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternRule_Type = "pattern_rule"

const PatternRule_Field_Guard = "$GUARD"
const PatternRule_Field_Flags = "$FLAGS"
const PatternRule_Field_Hook = "$HOOK"

func (op *PatternRule) Marshal(n jsn.Marshaler) {
	PatternRule_Marshal(n, op)
}

func PatternRule_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternRule) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternRule_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PatternRule_Optional_Marshal(n jsn.Marshaler, val **PatternRule) {
	if *val != nil {
		PatternRule_Marshal(n, *val)
	}
}

func PatternRule_Marshal(n jsn.Marshaler, val *PatternRule) {
	if n.MapValues(PatternRule_Type, PatternRule_Type) {
		if n.MapKey("", PatternRule_Field_Guard) {
			rt.BoolEval_Marshal(n, &val.Guard)
		}
		if n.MapKey("flags", PatternRule_Field_Flags) {
			PatternFlags_Optional_Marshal(n, &val.Flags)
		}
		if n.MapKey("hook", PatternRule_Field_Hook) {
			ProgramHook_Marshal(n, &val.Hook)
		}
		n.EndValues()
	}
	return
}

// PatternRules
type PatternRules struct {
	PatternRule []PatternRule `if:"label=_,optional"`
}

func (*PatternRules) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternRules_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternRules_Type = "pattern_rules"

const PatternRules_Field_PatternRule = "$PATTERN_RULE"

func (op *PatternRules) Marshal(n jsn.Marshaler) {
	PatternRules_Marshal(n, op)
}

func PatternRules_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternRules) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternRules_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PatternRules_Optional_Marshal(n jsn.Marshaler, val **PatternRules) {
	if *val != nil {
		PatternRules_Marshal(n, *val)
	}
}

func PatternRules_Marshal(n jsn.Marshaler, val *PatternRules) {
	if n.MapValues(PatternRules_Type, PatternRules_Type) {
		if n.MapKey("", PatternRules_Field_PatternRule) {
			PatternRule_Repeats_Marshal(n, &val.PatternRule)
		}
		n.EndValues()
	}
	return
}

// PatternType requires a user-specified string.
type PatternType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PatternType) String() string {
	return op.Str
}

const PatternType_Patterns = "$PATTERNS"
const PatternType_Actions = "$ACTIONS"
const PatternType_Events = "$EVENTS"

func (*PatternType) Compose() composer.Spec {
	return composer.Spec{
		Name:        PatternType_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			PatternType_Patterns, PatternType_Actions, PatternType_Events,
		},
		Strings: []string{
			"patterns", "actions", "events",
		},
	}
}

func (op *PatternType) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const PatternType_Type = "pattern_type"

func (op *PatternType) Marshal(n jsn.Marshaler) {
	PatternType_Marshal(n, op)
}

func PatternType_Optional_Marshal(n jsn.Marshaler, val *PatternType) {
	var zero PatternType
	if val.Str != zero.Str {
		PatternType_Marshal(n, val)
	}
}

func PatternType_Marshal(n jsn.Marshaler, val *PatternType) {
	n.SetCursor(val.At.Offset)
	n.SpecifyEnum(PatternType_Type, val)
}

func PatternType_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternType) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternType_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// PatternVariablesDecl Values provided when calling a pattern.
type PatternVariablesDecl struct {
	PatternName  value.PatternName `if:"label=_"`
	VariableDecl []VariableDecl    `if:"label=variable_decl"`
}

func (*PatternVariablesDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternVariablesDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternVariablesDecl_Type = "pattern_variables_decl"

const PatternVariablesDecl_Field_PatternName = "$PATTERN_NAME"
const PatternVariablesDecl_Field_VariableDecl = "$VARIABLE_DECL"

func (op *PatternVariablesDecl) Marshal(n jsn.Marshaler) {
	PatternVariablesDecl_Marshal(n, op)
}

func PatternVariablesDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternVariablesDecl) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternVariablesDecl_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PatternVariablesDecl_Optional_Marshal(n jsn.Marshaler, val **PatternVariablesDecl) {
	if *val != nil {
		PatternVariablesDecl_Marshal(n, *val)
	}
}

func PatternVariablesDecl_Marshal(n jsn.Marshaler, val *PatternVariablesDecl) {
	if n.MapValues(PatternVariablesDecl_Type, PatternVariablesDecl_Type) {
		if n.MapKey("", PatternVariablesDecl_Field_PatternName) {
			value.PatternName_Marshal(n, &val.PatternName)
		}
		if n.MapKey("variable_decl", PatternVariablesDecl_Field_VariableDecl) {
			VariableDecl_Repeats_Marshal(n, &val.VariableDecl)
		}
		n.EndValues()
	}
	return
}

// PatternVariablesTail Storage for values used during the execution of a pattern.
type PatternVariablesTail struct {
	VariableDecl []VariableDecl `if:"label=_"`
}

func (*PatternVariablesTail) Compose() composer.Spec {
	return composer.Spec{
		Name: PatternVariablesTail_Type,
		Uses: composer.Type_Flow,
	}
}

const PatternVariablesTail_Type = "pattern_variables_tail"

const PatternVariablesTail_Field_VariableDecl = "$VARIABLE_DECL"

func (op *PatternVariablesTail) Marshal(n jsn.Marshaler) {
	PatternVariablesTail_Marshal(n, op)
}

func PatternVariablesTail_Repeats_Marshal(n jsn.Marshaler, vals *[]PatternVariablesTail) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PatternVariablesTail_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PatternVariablesTail_Optional_Marshal(n jsn.Marshaler, val **PatternVariablesTail) {
	if *val != nil {
		PatternVariablesTail_Marshal(n, *val)
	}
}

func PatternVariablesTail_Marshal(n jsn.Marshaler, val *PatternVariablesTail) {
	if n.MapValues(PatternVariablesTail_Type, PatternVariablesTail_Type) {
		if n.MapKey("", PatternVariablesTail_Field_VariableDecl) {
			VariableDecl_Repeats_Marshal(n, &val.VariableDecl)
		}
		n.EndValues()
	}
	return
}

// PluralKinds requires a user-specified string.
type PluralKinds struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PluralKinds) String() string {
	return op.Str
}

func (*PluralKinds) Compose() composer.Spec {
	return composer.Spec{
		Name:        PluralKinds_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *PluralKinds) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const PluralKinds_Type = "plural_kinds"

func (op *PluralKinds) Marshal(n jsn.Marshaler) {
	PluralKinds_Marshal(n, op)
}

func PluralKinds_Optional_Marshal(n jsn.Marshaler, val *PluralKinds) {
	var zero PluralKinds
	if val.Str != zero.Str {
		PluralKinds_Marshal(n, val)
	}
}

func PluralKinds_Marshal(n jsn.Marshaler, val *PluralKinds) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(PluralKinds_Type, val.Str)
}

func PluralKinds_Repeats_Marshal(n jsn.Marshaler, vals *[]PluralKinds) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PluralKinds_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// PrimitiveType requires a user-specified string.
type PrimitiveType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PrimitiveType) String() string {
	return op.Str
}

const PrimitiveType_Number = "$NUMBER"
const PrimitiveType_Text = "$TEXT"
const PrimitiveType_Bool = "$BOOL"

func (*PrimitiveType) Compose() composer.Spec {
	return composer.Spec{
		Name: PrimitiveType_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			PrimitiveType_Number, PrimitiveType_Text, PrimitiveType_Bool,
		},
		Strings: []string{
			"number", "text", "bool",
		},
	}
}

func (op *PrimitiveType) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const PrimitiveType_Type = "primitive_type"

func (op *PrimitiveType) Marshal(n jsn.Marshaler) {
	PrimitiveType_Marshal(n, op)
}

func PrimitiveType_Optional_Marshal(n jsn.Marshaler, val *PrimitiveType) {
	var zero PrimitiveType
	if val.Str != zero.Str {
		PrimitiveType_Marshal(n, val)
	}
}

func PrimitiveType_Marshal(n jsn.Marshaler, val *PrimitiveType) {
	n.SetCursor(val.At.Offset)
	n.SpecifyEnum(PrimitiveType_Type, val)
}

func PrimitiveType_Repeats_Marshal(n jsn.Marshaler, vals *[]PrimitiveType) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PrimitiveType_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// PrimitiveValue swaps between various options
type PrimitiveValue struct {
	Opt interface{}
}

const PrimitiveValue_BoxedText_Opt = "$BOXED_TEXT"
const PrimitiveValue_BoxedNumber_Opt = "$BOXED_NUMBER"

func (*PrimitiveValue) Compose() composer.Spec {
	return composer.Spec{
		Name: PrimitiveValue_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			PrimitiveValue_BoxedText_Opt, PrimitiveValue_BoxedNumber_Opt,
		},
		Swaps: []interface{}{
			(*BoxedText)(nil),
			(*BoxedNumber)(nil),
		},
	}
}

const PrimitiveValue_Type = "primitive_value"

func (op *PrimitiveValue) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *BoxedText:
		ret, okay = PrimitiveValue_BoxedText_Opt, true
	case *BoxedNumber:
		ret, okay = PrimitiveValue_BoxedNumber_Opt, true
	}
	return
}
func (op *PrimitiveValue) Marshal(n jsn.Marshaler) {
	PrimitiveValue_Marshal(n, op)
}
func PrimitiveValue_Marshal(n jsn.Marshaler, val *PrimitiveValue) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			if n.PickValues(PrimitiveValue_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func PrimitiveValue_Repeats_Marshal(n jsn.Marshaler, vals *[]PrimitiveValue) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PrimitiveValue_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// ProgramHook swaps between various options
type ProgramHook struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ProgramHook_Activity_Opt = "$ACTIVITY"

func (*ProgramHook) Compose() composer.Spec {
	return composer.Spec{
		Name: ProgramHook_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			ProgramHook_Activity_Opt,
		},
		Swaps: []interface{}{
			(*core.Activity)(nil),
		},
	}
}

const ProgramHook_Type = "program_hook"

func (op *ProgramHook) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *core.Activity:
		ret, okay = ProgramHook_Activity_Opt, true
	}
	return
}
func (op *ProgramHook) Marshal(n jsn.Marshaler) {
	ProgramHook_Marshal(n, op)
}
func ProgramHook_Marshal(n jsn.Marshaler, val *ProgramHook) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			n.SetCursor(val.At.Offset)
			if n.PickValues(ProgramHook_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func ProgramHook_Repeats_Marshal(n jsn.Marshaler, vals *[]ProgramHook) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ProgramHook_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// Pronoun requires a user-specified string.
type Pronoun struct {
	Str string
}

func (op *Pronoun) String() string {
	return op.Str
}

const Pronoun_It = "$IT"
const Pronoun_They = "$THEY"

func (*Pronoun) Compose() composer.Spec {
	return composer.Spec{
		Name:        Pronoun_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			Pronoun_It, Pronoun_They,
		},
		Strings: []string{
			"it", "they",
		},
	}
}

func (op *Pronoun) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const Pronoun_Type = "pronoun"

func (op *Pronoun) Marshal(n jsn.Marshaler) {
	Pronoun_Marshal(n, op)
}

func Pronoun_Optional_Marshal(n jsn.Marshaler, val *Pronoun) {
	var zero Pronoun
	if val.Str != zero.Str {
		Pronoun_Marshal(n, val)
	}
}

func Pronoun_Marshal(n jsn.Marshaler, val *Pronoun) {
	n.SpecifyEnum(Pronoun_Type, val)
}

func Pronoun_Repeats_Marshal(n jsn.Marshaler, vals *[]Pronoun) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Pronoun_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// Property requires a user-specified string.
type Property struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Property) String() string {
	return op.Str
}

func (*Property) Compose() composer.Spec {
	return composer.Spec{
		Name:        Property_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *Property) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const Property_Type = "property"

func (op *Property) Marshal(n jsn.Marshaler) {
	Property_Marshal(n, op)
}

func Property_Optional_Marshal(n jsn.Marshaler, val *Property) {
	var zero Property
	if val.Str != zero.Str {
		Property_Marshal(n, val)
	}
}

func Property_Marshal(n jsn.Marshaler, val *Property) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(Property_Type, val.Str)
}

func Property_Repeats_Marshal(n jsn.Marshaler, vals *[]Property) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Property_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// PropertyAspect requires a user-specified string.
type PropertyAspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PropertyAspect) String() string {
	return op.Str
}

const PropertyAspect_Aspect = "$ASPECT"

func (*PropertyAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: PropertyAspect_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			PropertyAspect_Aspect,
		},
		Strings: []string{
			"aspect",
		},
	}
}

func (op *PropertyAspect) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const PropertyAspect_Type = "property_aspect"

func (op *PropertyAspect) Marshal(n jsn.Marshaler) {
	PropertyAspect_Marshal(n, op)
}

func PropertyAspect_Optional_Marshal(n jsn.Marshaler, val *PropertyAspect) {
	var zero PropertyAspect
	if val.Str != zero.Str {
		PropertyAspect_Marshal(n, val)
	}
}

func PropertyAspect_Marshal(n jsn.Marshaler, val *PropertyAspect) {
	n.SetCursor(val.At.Offset)
	n.SpecifyEnum(PropertyAspect_Type, val)
}

func PropertyAspect_Repeats_Marshal(n jsn.Marshaler, vals *[]PropertyAspect) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PropertyAspect_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// PropertyDecl
type PropertyDecl struct {
	An           Determiner   `if:"label=_"`
	Property     Property     `if:"label=property"`
	PropertyType PropertyType `if:"label=property_type"`
	Comment      value.Lines  `if:"label=comment,optional"`
}

func (*PropertyDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: PropertyDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const PropertyDecl_Type = "property_decl"

const PropertyDecl_Field_An = "$AN"
const PropertyDecl_Field_Property = "$PROPERTY"
const PropertyDecl_Field_PropertyType = "$PROPERTY_TYPE"
const PropertyDecl_Field_Comment = "$COMMENT"

func (op *PropertyDecl) Marshal(n jsn.Marshaler) {
	PropertyDecl_Marshal(n, op)
}

func PropertyDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]PropertyDecl) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PropertyDecl_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func PropertyDecl_Optional_Marshal(n jsn.Marshaler, val **PropertyDecl) {
	if *val != nil {
		PropertyDecl_Marshal(n, *val)
	}
}

func PropertyDecl_Marshal(n jsn.Marshaler, val *PropertyDecl) {
	if n.MapValues(PropertyDecl_Type, PropertyDecl_Type) {
		if n.MapKey("", PropertyDecl_Field_An) {
			Determiner_Marshal(n, &val.An)
		}
		if n.MapKey("property", PropertyDecl_Field_Property) {
			Property_Marshal(n, &val.Property)
		}
		if n.MapKey("property_type", PropertyDecl_Field_PropertyType) {
			PropertyType_Marshal(n, &val.PropertyType)
		}
		if n.MapKey("comment", PropertyDecl_Field_Comment) {
			value.Lines_Optional_Marshal(n, &val.Comment)
		}
		n.EndValues()
	}
	return
}

// PropertyType swaps between various options
type PropertyType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const PropertyType_PropertyAspect_Opt = "$PROPERTY_ASPECT"
const PropertyType_Primitive_Opt = "$PRIMITIVE"
const PropertyType_Ext_Opt = "$EXT"

func (*PropertyType) Compose() composer.Spec {
	return composer.Spec{
		Name: PropertyType_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			PropertyType_PropertyAspect_Opt, PropertyType_Primitive_Opt, PropertyType_Ext_Opt,
		},
		Swaps: []interface{}{
			(*PropertyAspect)(nil),
			(*PrimitiveType)(nil),
			(*ExtType)(nil),
		},
	}
}

const PropertyType_Type = "property_type"

func (op *PropertyType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PropertyAspect:
		ret, okay = PropertyType_PropertyAspect_Opt, true
	case *PrimitiveType:
		ret, okay = PropertyType_Primitive_Opt, true
	case *ExtType:
		ret, okay = PropertyType_Ext_Opt, true
	}
	return
}
func (op *PropertyType) Marshal(n jsn.Marshaler) {
	PropertyType_Marshal(n, op)
}
func PropertyType_Marshal(n jsn.Marshaler, val *PropertyType) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			n.SetCursor(val.At.Offset)
			if n.PickValues(PropertyType_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func PropertyType_Repeats_Marshal(n jsn.Marshaler, vals *[]PropertyType) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				PropertyType_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// RecordList
type RecordList struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordList) Compose() composer.Spec {
	return composer.Spec{
		Name: RecordList_Type,
		Uses: composer.Type_Flow,
	}
}

const RecordList_Type = "record_list"

const RecordList_Field_Kind = "$KIND"

func (op *RecordList) Marshal(n jsn.Marshaler) {
	RecordList_Marshal(n, op)
}

func RecordList_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				RecordList_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func RecordList_Optional_Marshal(n jsn.Marshaler, val **RecordList) {
	if *val != nil {
		RecordList_Marshal(n, *val)
	}
}

func RecordList_Marshal(n jsn.Marshaler, val *RecordList) {
	if n.MapValues(RecordList_Type, RecordList_Type) {
		if n.MapKey("", RecordList_Field_Kind) {
			RecordSingular_Marshal(n, &val.Kind)
		}
		n.EndValues()
	}
	return
}

// RecordPlural requires a user-specified string.
type RecordPlural struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordPlural) String() string {
	return op.Str
}

func (*RecordPlural) Compose() composer.Spec {
	return composer.Spec{
		Name:        RecordPlural_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *RecordPlural) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const RecordPlural_Type = "record_plural"

func (op *RecordPlural) Marshal(n jsn.Marshaler) {
	RecordPlural_Marshal(n, op)
}

func RecordPlural_Optional_Marshal(n jsn.Marshaler, val *RecordPlural) {
	var zero RecordPlural
	if val.Str != zero.Str {
		RecordPlural_Marshal(n, val)
	}
}

func RecordPlural_Marshal(n jsn.Marshaler, val *RecordPlural) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(RecordPlural_Type, val.Str)
}

func RecordPlural_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordPlural) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				RecordPlural_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// RecordSingular requires a user-specified string.
type RecordSingular struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordSingular) String() string {
	return op.Str
}

func (*RecordSingular) Compose() composer.Spec {
	return composer.Spec{
		Name:        RecordSingular_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *RecordSingular) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const RecordSingular_Type = "record_singular"

func (op *RecordSingular) Marshal(n jsn.Marshaler) {
	RecordSingular_Marshal(n, op)
}

func RecordSingular_Optional_Marshal(n jsn.Marshaler, val *RecordSingular) {
	var zero RecordSingular
	if val.Str != zero.Str {
		RecordSingular_Marshal(n, val)
	}
}

func RecordSingular_Marshal(n jsn.Marshaler, val *RecordSingular) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(RecordSingular_Type, val.Str)
}

func RecordSingular_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordSingular) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				RecordSingular_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// RecordType
type RecordType struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordType) Compose() composer.Spec {
	return composer.Spec{
		Name: RecordType_Type,
		Uses: composer.Type_Flow,
	}
}

const RecordType_Type = "record_type"

const RecordType_Field_Kind = "$KIND"

func (op *RecordType) Marshal(n jsn.Marshaler) {
	RecordType_Marshal(n, op)
}

func RecordType_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordType) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				RecordType_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func RecordType_Optional_Marshal(n jsn.Marshaler, val **RecordType) {
	if *val != nil {
		RecordType_Marshal(n, *val)
	}
}

func RecordType_Marshal(n jsn.Marshaler, val *RecordType) {
	if n.MapValues(RecordType_Type, RecordType_Type) {
		if n.MapKey("", RecordType_Field_Kind) {
			RecordSingular_Marshal(n, &val.Kind)
		}
		n.EndValues()
	}
	return
}

// RecordsPossessProperties
type RecordsPossessProperties struct {
	RecordPlural RecordPlural   `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*RecordsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: RecordsPossessProperties_Type,
		Uses: composer.Type_Flow,
	}
}

const RecordsPossessProperties_Type = "records_possess_properties"

const RecordsPossessProperties_Field_RecordPlural = "$RECORD_PLURAL"
const RecordsPossessProperties_Field_PropertyDecl = "$PROPERTY_DECL"

func (op *RecordsPossessProperties) Marshal(n jsn.Marshaler) {
	RecordsPossessProperties_Marshal(n, op)
}

func RecordsPossessProperties_Repeats_Marshal(n jsn.Marshaler, vals *[]RecordsPossessProperties) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				RecordsPossessProperties_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func RecordsPossessProperties_Optional_Marshal(n jsn.Marshaler, val **RecordsPossessProperties) {
	if *val != nil {
		RecordsPossessProperties_Marshal(n, *val)
	}
}

func RecordsPossessProperties_Marshal(n jsn.Marshaler, val *RecordsPossessProperties) {
	if n.MapValues(RecordsPossessProperties_Type, RecordsPossessProperties_Type) {
		if n.MapKey("", RecordsPossessProperties_Field_RecordPlural) {
			RecordPlural_Marshal(n, &val.RecordPlural)
		}
		if n.MapKey("property_decl", RecordsPossessProperties_Field_PropertyDecl) {
			PropertyDecl_Repeats_Marshal(n, &val.PropertyDecl)
		}
		n.EndValues()
	}
	return
}

// RelationCardinality swaps between various options
type RelationCardinality struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const RelationCardinality_OneToOne_Opt = "$ONE_TO_ONE"
const RelationCardinality_OneToMany_Opt = "$ONE_TO_MANY"
const RelationCardinality_ManyToOne_Opt = "$MANY_TO_ONE"
const RelationCardinality_ManyToMany_Opt = "$MANY_TO_MANY"

func (*RelationCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: RelationCardinality_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			RelationCardinality_OneToOne_Opt, RelationCardinality_OneToMany_Opt, RelationCardinality_ManyToOne_Opt, RelationCardinality_ManyToMany_Opt,
		},
		Swaps: []interface{}{
			(*OneToOne)(nil),
			(*OneToMany)(nil),
			(*ManyToOne)(nil),
			(*ManyToMany)(nil),
		},
	}
}

const RelationCardinality_Type = "relation_cardinality"

func (op *RelationCardinality) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *OneToOne:
		ret, okay = RelationCardinality_OneToOne_Opt, true
	case *OneToMany:
		ret, okay = RelationCardinality_OneToMany_Opt, true
	case *ManyToOne:
		ret, okay = RelationCardinality_ManyToOne_Opt, true
	case *ManyToMany:
		ret, okay = RelationCardinality_ManyToMany_Opt, true
	}
	return
}
func (op *RelationCardinality) Marshal(n jsn.Marshaler) {
	RelationCardinality_Marshal(n, op)
}
func RelationCardinality_Marshal(n jsn.Marshaler, val *RelationCardinality) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			n.SetCursor(val.At.Offset)
			if n.PickValues(RelationCardinality_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func RelationCardinality_Repeats_Marshal(n jsn.Marshaler, vals *[]RelationCardinality) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				RelationCardinality_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// RelativeToNoun
type RelativeToNoun struct {
	Relation value.RelationName `if:"label=_"`
	Nouns    []NamedNoun        `if:"label=nouns"`
	AreBeing AreBeing           `if:"label=are_being"`
	Nouns1   []NamedNoun        `if:"label=nouns1"`
}

func (*RelativeToNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: RelativeToNoun_Type,
		Uses: composer.Type_Flow,
	}
}

const RelativeToNoun_Type = "relative_to_noun"

const RelativeToNoun_Field_Relation = "$RELATION"
const RelativeToNoun_Field_Nouns = "$NOUNS"
const RelativeToNoun_Field_AreBeing = "$ARE_BEING"
const RelativeToNoun_Field_Nouns1 = "$NOUNS1"

func (op *RelativeToNoun) Marshal(n jsn.Marshaler) {
	RelativeToNoun_Marshal(n, op)
}

func RelativeToNoun_Repeats_Marshal(n jsn.Marshaler, vals *[]RelativeToNoun) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				RelativeToNoun_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func RelativeToNoun_Optional_Marshal(n jsn.Marshaler, val **RelativeToNoun) {
	if *val != nil {
		RelativeToNoun_Marshal(n, *val)
	}
}

func RelativeToNoun_Marshal(n jsn.Marshaler, val *RelativeToNoun) {
	if n.MapValues(RelativeToNoun_Type, RelativeToNoun_Type) {
		if n.MapKey("", RelativeToNoun_Field_Relation) {
			value.RelationName_Marshal(n, &val.Relation)
		}
		if n.MapKey("nouns", RelativeToNoun_Field_Nouns) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns)
		}
		if n.MapKey("are_being", RelativeToNoun_Field_AreBeing) {
			AreBeing_Marshal(n, &val.AreBeing)
		}
		if n.MapKey("nouns1", RelativeToNoun_Field_Nouns1) {
			NamedNoun_Repeats_Marshal(n, &val.Nouns1)
		}
		n.EndValues()
	}
	return
}

// RenderTemplate Parse text using iffy templates.
type RenderTemplate struct {
	Template value.Lines `if:"label=_"`
}

func (*RenderTemplate) Compose() composer.Spec {
	return composer.Spec{
		Name: RenderTemplate_Type,
		Uses: composer.Type_Flow,
	}
}

const RenderTemplate_Type = "render_template"

const RenderTemplate_Field_Template = "$TEMPLATE"

func (op *RenderTemplate) Marshal(n jsn.Marshaler) {
	RenderTemplate_Marshal(n, op)
}

func RenderTemplate_Repeats_Marshal(n jsn.Marshaler, vals *[]RenderTemplate) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				RenderTemplate_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func RenderTemplate_Optional_Marshal(n jsn.Marshaler, val **RenderTemplate) {
	if *val != nil {
		RenderTemplate_Marshal(n, *val)
	}
}

func RenderTemplate_Marshal(n jsn.Marshaler, val *RenderTemplate) {
	if n.MapValues(RenderTemplate_Type, RenderTemplate_Type) {
		if n.MapKey("", RenderTemplate_Field_Template) {
			value.Lines_Marshal(n, &val.Template)
		}
		n.EndValues()
	}
	return
}

// Send
type Send struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=path"`
	Arguments *Arguments      `if:"label=arguments,optional"`
}

func (*Send) Compose() composer.Spec {
	return composer.Spec{
		Name: Send_Type,
		Uses: composer.Type_Flow,
	}
}

const Send_Type = "send"

const Send_Field_Event = "$EVENT"
const Send_Field_Path = "$PATH"
const Send_Field_Arguments = "$ARGUMENTS"

func (op *Send) Marshal(n jsn.Marshaler) {
	Send_Marshal(n, op)
}

func Send_Repeats_Marshal(n jsn.Marshaler, vals *[]Send) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Send_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Send_Optional_Marshal(n jsn.Marshaler, val **Send) {
	if *val != nil {
		Send_Marshal(n, *val)
	}
}

func Send_Marshal(n jsn.Marshaler, val *Send) {
	if n.MapValues(Send_Type, Send_Type) {
		if n.MapKey("", Send_Field_Event) {
			value.Text_Unboxed_Marshal(n, &val.Event)
		}
		if n.MapKey("path", Send_Field_Path) {
			rt.TextListEval_Marshal(n, &val.Path)
		}
		if n.MapKey("arguments", Send_Field_Arguments) {
			Arguments_Optional_Marshal(n, &val.Arguments)
		}
		n.EndValues()
	}
	return
}

// ShuffleText
type ShuffleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*ShuffleText) Compose() composer.Spec {
	return composer.Spec{
		Name: ShuffleText_Type,
		Uses: composer.Type_Flow,
	}
}

const ShuffleText_Type = "shuffle_text"

const ShuffleText_Field_Parts = "$PARTS"

func (op *ShuffleText) Marshal(n jsn.Marshaler) {
	ShuffleText_Marshal(n, op)
}

func ShuffleText_Repeats_Marshal(n jsn.Marshaler, vals *[]ShuffleText) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				ShuffleText_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func ShuffleText_Optional_Marshal(n jsn.Marshaler, val **ShuffleText) {
	if *val != nil {
		ShuffleText_Marshal(n, *val)
	}
}

func ShuffleText_Marshal(n jsn.Marshaler, val *ShuffleText) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(ShuffleText_Type, ShuffleText_Type) {
		if n.MapKey("parts", ShuffleText_Field_Parts) {
			rt.TextEval_Repeats_Marshal(n, &val.Parts)
		}
		n.EndValues()
	}
	return
}

// SingularKind requires a user-specified string.
type SingularKind struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *SingularKind) String() string {
	return op.Str
}

func (*SingularKind) Compose() composer.Spec {
	return composer.Spec{
		Name:        SingularKind_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *SingularKind) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const SingularKind_Type = "singular_kind"

func (op *SingularKind) Marshal(n jsn.Marshaler) {
	SingularKind_Marshal(n, op)
}

func SingularKind_Optional_Marshal(n jsn.Marshaler, val *SingularKind) {
	var zero SingularKind
	if val.Str != zero.Str {
		SingularKind_Marshal(n, val)
	}
}

func SingularKind_Marshal(n jsn.Marshaler, val *SingularKind) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(SingularKind_Type, val.Str)
}

func SingularKind_Repeats_Marshal(n jsn.Marshaler, vals *[]SingularKind) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				SingularKind_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// StoppingText
type StoppingText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*StoppingText) Compose() composer.Spec {
	return composer.Spec{
		Name: StoppingText_Type,
		Uses: composer.Type_Flow,
	}
}

const StoppingText_Type = "stopping_text"

const StoppingText_Field_Parts = "$PARTS"

func (op *StoppingText) Marshal(n jsn.Marshaler) {
	StoppingText_Marshal(n, op)
}

func StoppingText_Repeats_Marshal(n jsn.Marshaler, vals *[]StoppingText) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				StoppingText_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func StoppingText_Optional_Marshal(n jsn.Marshaler, val **StoppingText) {
	if *val != nil {
		StoppingText_Marshal(n, *val)
	}
}

func StoppingText_Marshal(n jsn.Marshaler, val *StoppingText) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(StoppingText_Type, StoppingText_Type) {
		if n.MapKey("parts", StoppingText_Field_Parts) {
			rt.TextEval_Repeats_Marshal(n, &val.Parts)
		}
		n.EndValues()
	}
	return
}

// Story
type Story struct {
	Paragraph []Paragraph `if:"label=_,optional"`
}

func (*Story) Compose() composer.Spec {
	return composer.Spec{
		Name: Story_Type,
		Uses: composer.Type_Flow,
	}
}

const Story_Type = "story"

const Story_Field_Paragraph = "$PARAGRAPH"

func (op *Story) Marshal(n jsn.Marshaler) {
	Story_Marshal(n, op)
}

func Story_Repeats_Marshal(n jsn.Marshaler, vals *[]Story) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Story_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Story_Optional_Marshal(n jsn.Marshaler, val **Story) {
	if *val != nil {
		Story_Marshal(n, *val)
	}
}

func Story_Marshal(n jsn.Marshaler, val *Story) {
	if n.MapValues(Story_Type, Story_Type) {
		if n.MapKey("", Story_Field_Paragraph) {
			Paragraph_Repeats_Marshal(n, &val.Paragraph)
		}
		n.EndValues()
	}
	return
}

const StoryStatement_Type = "story_statement"

var StoryStatement_Optional_Marshal = StoryStatement_Marshal

func StoryStatement_Marshal(n jsn.Marshaler, ptr *StoryStatement) {
	if slat := *ptr; slat != nil {
		slat.(jsn.Marshalee).Marshal(n)
	}
	return
}

func StoryStatement_Repeats_Marshal(n jsn.Marshaler, vals *[]StoryStatement) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				StoryStatement_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// Summary
type Summary struct {
	At    reader.Position `if:"internal"`
	Lines value.Lines     `if:"label=lines"`
}

func (*Summary) Compose() composer.Spec {
	return composer.Spec{
		Name: Summary_Type,
		Uses: composer.Type_Flow,
	}
}

const Summary_Type = "summary"

const Summary_Field_Lines = "$LINES"

func (op *Summary) Marshal(n jsn.Marshaler) {
	Summary_Marshal(n, op)
}

func Summary_Repeats_Marshal(n jsn.Marshaler, vals *[]Summary) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Summary_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Summary_Optional_Marshal(n jsn.Marshaler, val **Summary) {
	if *val != nil {
		Summary_Marshal(n, *val)
	}
}

func Summary_Marshal(n jsn.Marshaler, val *Summary) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(Summary_Type, Summary_Type) {
		if n.MapKey("lines", Summary_Field_Lines) {
			value.Lines_Marshal(n, &val.Lines)
		}
		n.EndValues()
	}
	return
}

// Tail Adds details about the preceding noun or nouns.
type Tail struct {
	Pronoun    Pronoun    `if:"label=_"`
	NounPhrase NounPhrase `if:"label=noun_phrase"`
}

func (*Tail) Compose() composer.Spec {
	return composer.Spec{
		Name: Tail_Type,
		Uses: composer.Type_Flow,
	}
}

const Tail_Type = "tail"

const Tail_Field_Pronoun = "$PRONOUN"
const Tail_Field_NounPhrase = "$NOUN_PHRASE"

func (op *Tail) Marshal(n jsn.Marshaler) {
	Tail_Marshal(n, op)
}

func Tail_Repeats_Marshal(n jsn.Marshaler, vals *[]Tail) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Tail_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func Tail_Optional_Marshal(n jsn.Marshaler, val **Tail) {
	if *val != nil {
		Tail_Marshal(n, *val)
	}
}

func Tail_Marshal(n jsn.Marshaler, val *Tail) {
	if n.MapValues(Tail_Type, Tail_Type) {
		if n.MapKey("", Tail_Field_Pronoun) {
			Pronoun_Marshal(n, &val.Pronoun)
		}
		if n.MapKey("noun_phrase", Tail_Field_NounPhrase) {
			NounPhrase_Marshal(n, &val.NounPhrase)
		}
		n.EndValues()
	}
	return
}

// TestName requires a user-specified string.
type TestName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *TestName) String() string {
	return op.Str
}

const TestName_CurrentTest = "$CURRENT_TEST"

func (*TestName) Compose() composer.Spec {
	return composer.Spec{
		Name:        TestName_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
		Choices: []string{
			TestName_CurrentTest,
		},
		Strings: []string{
			"current_test",
		},
	}
}

func (op *TestName) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const TestName_Type = "test_name"

func (op *TestName) Marshal(n jsn.Marshaler) {
	TestName_Marshal(n, op)
}

func TestName_Optional_Marshal(n jsn.Marshaler, val *TestName) {
	var zero TestName
	if val.Str != zero.Str {
		TestName_Marshal(n, val)
	}
}

func TestName_Marshal(n jsn.Marshaler, val *TestName) {
	n.SetCursor(val.At.Offset)
	n.SpecifyEnum(TestName_Type, val)
}

func TestName_Repeats_Marshal(n jsn.Marshaler, vals *[]TestName) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				TestName_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// TestOutput Expect that a test uses &#x27;Say&#x27; to print some specific text.
type TestOutput struct {
	Lines value.Lines `if:"label=_"`
}

func (*TestOutput) Compose() composer.Spec {
	return composer.Spec{
		Name: TestOutput_Type,
		Uses: composer.Type_Flow,
	}
}

const TestOutput_Type = "test_output"

const TestOutput_Field_Lines = "$LINES"

func (op *TestOutput) Marshal(n jsn.Marshaler) {
	TestOutput_Marshal(n, op)
}

func TestOutput_Repeats_Marshal(n jsn.Marshaler, vals *[]TestOutput) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				TestOutput_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func TestOutput_Optional_Marshal(n jsn.Marshaler, val **TestOutput) {
	if *val != nil {
		TestOutput_Marshal(n, *val)
	}
}

func TestOutput_Marshal(n jsn.Marshaler, val *TestOutput) {
	if n.MapValues(TestOutput_Type, TestOutput_Type) {
		if n.MapKey("", TestOutput_Field_Lines) {
			value.Lines_Marshal(n, &val.Lines)
		}
		n.EndValues()
	}
	return
}

// TestRule
type TestRule struct {
	TestName TestName    `if:"label=_"`
	Hook     ProgramHook `if:"label=hook"`
}

func (*TestRule) Compose() composer.Spec {
	return composer.Spec{
		Name: TestRule_Type,
		Uses: composer.Type_Flow,
	}
}

const TestRule_Type = "test_rule"

const TestRule_Field_TestName = "$TEST_NAME"
const TestRule_Field_Hook = "$HOOK"

func (op *TestRule) Marshal(n jsn.Marshaler) {
	TestRule_Marshal(n, op)
}

func TestRule_Repeats_Marshal(n jsn.Marshaler, vals *[]TestRule) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				TestRule_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func TestRule_Optional_Marshal(n jsn.Marshaler, val **TestRule) {
	if *val != nil {
		TestRule_Marshal(n, *val)
	}
}

func TestRule_Marshal(n jsn.Marshaler, val *TestRule) {
	if n.MapValues(TestRule_Type, TestRule_Type) {
		if n.MapKey("", TestRule_Field_TestName) {
			TestName_Marshal(n, &val.TestName)
		}
		if n.MapKey("hook", TestRule_Field_Hook) {
			ProgramHook_Marshal(n, &val.Hook)
		}
		n.EndValues()
	}
	return
}

// TestScene
type TestScene struct {
	TestName TestName `if:"label=_"`
	Story    Story    `if:"label=story"`
}

func (*TestScene) Compose() composer.Spec {
	return composer.Spec{
		Name: TestScene_Type,
		Uses: composer.Type_Flow,
	}
}

const TestScene_Type = "test_scene"

const TestScene_Field_TestName = "$TEST_NAME"
const TestScene_Field_Story = "$STORY"

func (op *TestScene) Marshal(n jsn.Marshaler) {
	TestScene_Marshal(n, op)
}

func TestScene_Repeats_Marshal(n jsn.Marshaler, vals *[]TestScene) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				TestScene_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func TestScene_Optional_Marshal(n jsn.Marshaler, val **TestScene) {
	if *val != nil {
		TestScene_Marshal(n, *val)
	}
}

func TestScene_Marshal(n jsn.Marshaler, val *TestScene) {
	if n.MapValues(TestScene_Type, TestScene_Type) {
		if n.MapKey("", TestScene_Field_TestName) {
			TestName_Marshal(n, &val.TestName)
		}
		if n.MapKey("story", TestScene_Field_Story) {
			Story_Marshal(n, &val.Story)
		}
		n.EndValues()
	}
	return
}

// TestStatement
type TestStatement struct {
	At       reader.Position `if:"internal"`
	TestName TestName        `if:"label=test_name"`
	Test     Testing         `if:"label=test"`
}

func (*TestStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: TestStatement_Type,
		Uses: composer.Type_Flow,
	}
}

const TestStatement_Type = "test_statement"

const TestStatement_Field_TestName = "$TEST_NAME"
const TestStatement_Field_Test = "$TEST"

func (op *TestStatement) Marshal(n jsn.Marshaler) {
	TestStatement_Marshal(n, op)
}

func TestStatement_Repeats_Marshal(n jsn.Marshaler, vals *[]TestStatement) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				TestStatement_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func TestStatement_Optional_Marshal(n jsn.Marshaler, val **TestStatement) {
	if *val != nil {
		TestStatement_Marshal(n, *val)
	}
}

func TestStatement_Marshal(n jsn.Marshaler, val *TestStatement) {
	n.SetCursor(val.At.Offset)
	if n.MapValues(TestStatement_Type, TestStatement_Type) {
		if n.MapKey("test_name", TestStatement_Field_TestName) {
			TestName_Marshal(n, &val.TestName)
		}
		if n.MapKey("test", TestStatement_Field_Test) {
			Testing_Marshal(n, &val.Test)
		}
		n.EndValues()
	}
	return
}

const Testing_Type = "testing"

var Testing_Optional_Marshal = Testing_Marshal

func Testing_Marshal(n jsn.Marshaler, ptr *Testing) {
	if slat := *ptr; slat != nil {
		slat.(jsn.Marshalee).Marshal(n)
	}
	return
}

func Testing_Repeats_Marshal(n jsn.Marshaler, vals *[]Testing) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Testing_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// TextList requires a user-specified string.
type TextList struct {
	Str string
}

func (op *TextList) String() string {
	return op.Str
}

const TextList_List = "$LIST"

func (*TextList) Compose() composer.Spec {
	return composer.Spec{
		Name: TextList_Type,
		Uses: composer.Type_Str,
		Choices: []string{
			TextList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

func (op *TextList) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const TextList_Type = "text_list"

func (op *TextList) Marshal(n jsn.Marshaler) {
	TextList_Marshal(n, op)
}

func TextList_Optional_Marshal(n jsn.Marshaler, val *TextList) {
	var zero TextList
	if val.Str != zero.Str {
		TextList_Marshal(n, val)
	}
}

func TextList_Marshal(n jsn.Marshaler, val *TextList) {
	n.SpecifyEnum(TextList_Type, val)
}

func TextList_Repeats_Marshal(n jsn.Marshaler, vals *[]TextList) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				TextList_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// Trait requires a user-specified string.
type Trait struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Trait) String() string {
	return op.Str
}

func (*Trait) Compose() composer.Spec {
	return composer.Spec{
		Name:        Trait_Type,
		Uses:        composer.Type_Str,
		OpenStrings: true,
	}
}

func (op *Trait) FindChoice() (string, bool) {
	return op.Compose().FindChoice(op.Str)
}

const Trait_Type = "trait"

func (op *Trait) Marshal(n jsn.Marshaler) {
	Trait_Marshal(n, op)
}

func Trait_Optional_Marshal(n jsn.Marshaler, val *Trait) {
	var zero Trait
	if val.Str != zero.Str {
		Trait_Marshal(n, val)
	}
}

func Trait_Marshal(n jsn.Marshaler, val *Trait) {
	n.SetCursor(val.At.Offset)
	n.SpecifyValue(Trait_Type, val.Str)
}

func Trait_Repeats_Marshal(n jsn.Marshaler, vals *[]Trait) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				Trait_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

// TraitPhrase
type TraitPhrase struct {
	AreEither AreEither `if:"label=_"`
	Trait     []Trait   `if:"label=trait"`
}

func (*TraitPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: TraitPhrase_Type,
		Uses: composer.Type_Flow,
	}
}

const TraitPhrase_Type = "trait_phrase"

const TraitPhrase_Field_AreEither = "$ARE_EITHER"
const TraitPhrase_Field_Trait = "$TRAIT"

func (op *TraitPhrase) Marshal(n jsn.Marshaler) {
	TraitPhrase_Marshal(n, op)
}

func TraitPhrase_Repeats_Marshal(n jsn.Marshaler, vals *[]TraitPhrase) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				TraitPhrase_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func TraitPhrase_Optional_Marshal(n jsn.Marshaler, val **TraitPhrase) {
	if *val != nil {
		TraitPhrase_Marshal(n, *val)
	}
}

func TraitPhrase_Marshal(n jsn.Marshaler, val *TraitPhrase) {
	if n.MapValues(TraitPhrase_Type, TraitPhrase_Type) {
		if n.MapKey("", TraitPhrase_Field_AreEither) {
			AreEither_Marshal(n, &val.AreEither)
		}
		if n.MapKey("trait", TraitPhrase_Field_Trait) {
			Trait_Repeats_Marshal(n, &val.Trait)
		}
		n.EndValues()
	}
	return
}

// VariableDecl
type VariableDecl struct {
	An      Determiner         `if:"label=_"`
	Name    value.VariableName `if:"label=name"`
	Type    VariableType       `if:"label=type"`
	Comment value.Lines        `if:"label=comment,optional"`
}

func (*VariableDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: VariableDecl_Type,
		Uses: composer.Type_Flow,
	}
}

const VariableDecl_Type = "variable_decl"

const VariableDecl_Field_An = "$AN"
const VariableDecl_Field_Name = "$NAME"
const VariableDecl_Field_Type = "$TYPE"
const VariableDecl_Field_Comment = "$COMMENT"

func (op *VariableDecl) Marshal(n jsn.Marshaler) {
	VariableDecl_Marshal(n, op)
}

func VariableDecl_Repeats_Marshal(n jsn.Marshaler, vals *[]VariableDecl) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				VariableDecl_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

func VariableDecl_Optional_Marshal(n jsn.Marshaler, val **VariableDecl) {
	if *val != nil {
		VariableDecl_Marshal(n, *val)
	}
}

func VariableDecl_Marshal(n jsn.Marshaler, val *VariableDecl) {
	if n.MapValues(VariableDecl_Type, VariableDecl_Type) {
		if n.MapKey("", VariableDecl_Field_An) {
			Determiner_Marshal(n, &val.An)
		}
		if n.MapKey("name", VariableDecl_Field_Name) {
			value.VariableName_Marshal(n, &val.Name)
		}
		if n.MapKey("type", VariableDecl_Field_Type) {
			VariableType_Marshal(n, &val.Type)
		}
		if n.MapKey("comment", VariableDecl_Field_Comment) {
			value.Lines_Optional_Marshal(n, &val.Comment)
		}
		n.EndValues()
	}
	return
}

// VariableType swaps between various options
type VariableType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const VariableType_Primitive_Opt = "$PRIMITIVE"
const VariableType_Object_Opt = "$OBJECT"
const VariableType_Ext_Opt = "$EXT"

func (*VariableType) Compose() composer.Spec {
	return composer.Spec{
		Name: VariableType_Type,
		Uses: composer.Type_Swap,
		Choices: []string{
			VariableType_Primitive_Opt, VariableType_Object_Opt, VariableType_Ext_Opt,
		},
		Swaps: []interface{}{
			(*PrimitiveType)(nil),
			(*ObjectType)(nil),
			(*ExtType)(nil),
		},
	}
}

const VariableType_Type = "variable_type"

func (op *VariableType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PrimitiveType:
		ret, okay = VariableType_Primitive_Opt, true
	case *ObjectType:
		ret, okay = VariableType_Object_Opt, true
	case *ExtType:
		ret, okay = VariableType_Ext_Opt, true
	}
	return
}
func (op *VariableType) Marshal(n jsn.Marshaler) {
	VariableType_Marshal(n, op)
}
func VariableType_Marshal(n jsn.Marshaler, val *VariableType) {
	if pick, ok := val.GetChoice(); ok {
		if slat := val.Opt; len(pick) > 0 {
			n.SetCursor(val.At.Offset)
			if n.PickValues(VariableType_Type, pick) {
				slat.(jsn.Marshalee).Marshal(n)
				n.EndValues()
			}
		}
	}
}

func VariableType_Repeats_Marshal(n jsn.Marshaler, vals *[]VariableType) {
	if cnt := len(*vals); cnt > 0 { // generated code collapses optional and empty.
		if n.RepeatValues(cnt) {
			for _, el := range *vals {
				VariableType_Marshal(n, &el)
			}
			n.EndValues()
		}
	}
	return
}

var Slots = []interface{}{
	(*StoryStatement)(nil),
	(*Testing)(nil),
}

var Slats = []composer.Composer{
	(*AbstractAction)(nil),
	(*ActionContext)(nil),
	(*ActionDecl)(nil),
	(*ActionName)(nil),
	(*ActionParams)(nil),
	(*Ana)(nil),
	(*AreAn)(nil),
	(*AreBeing)(nil),
	(*AreEither)(nil),
	(*Argument)(nil),
	(*Arguments)(nil),
	(*Aspect)(nil),
	(*AspectTraits)(nil),
	(*BoxedNumber)(nil),
	(*BoxedText)(nil),
	(*Certainties)(nil),
	(*Certainty)(nil),
	(*Comment)(nil),
	(*CommonAction)(nil),
	(*CountOf)(nil),
	(*CycleText)(nil),
	(*Determine)(nil),
	(*Determiner)(nil),
	(*EventBlock)(nil),
	(*EventHandler)(nil),
	(*EventName)(nil),
	(*EventPhase)(nil),
	(*EventTarget)(nil),
	(*ExtType)(nil),
	(*GrammarDecl)(nil),
	(*KindOfNoun)(nil),
	(*KindOfRelation)(nil),
	(*KindsOfAspect)(nil),
	(*KindsOfKind)(nil),
	(*KindsOfRecord)(nil),
	(*KindsPossessProperties)(nil),
	(*Lede)(nil),
	(*LocalDecl)(nil),
	(*LocalInit)(nil),
	(*Make)(nil),
	(*ManyToMany)(nil),
	(*ManyToOne)(nil),
	(*NamedNoun)(nil),
	(*NounAssignment)(nil),
	(*NounName)(nil),
	(*NounPhrase)(nil),
	(*NounRelation)(nil),
	(*NounStatement)(nil),
	(*NounTraits)(nil),
	(*NumberList)(nil),
	(*ObjectType)(nil),
	(*OneToMany)(nil),
	(*OneToOne)(nil),
	(*PairedAction)(nil),
	(*Paragraph)(nil),
	(*PatternActions)(nil),
	(*PatternDecl)(nil),
	(*PatternFlags)(nil),
	(*PatternLocals)(nil),
	(*PatternReturn)(nil),
	(*PatternRule)(nil),
	(*PatternRules)(nil),
	(*PatternType)(nil),
	(*PatternVariablesDecl)(nil),
	(*PatternVariablesTail)(nil),
	(*PluralKinds)(nil),
	(*PrimitiveType)(nil),
	(*PrimitiveValue)(nil),
	(*ProgramHook)(nil),
	(*Pronoun)(nil),
	(*Property)(nil),
	(*PropertyAspect)(nil),
	(*PropertyDecl)(nil),
	(*PropertyType)(nil),
	(*RecordList)(nil),
	(*RecordPlural)(nil),
	(*RecordSingular)(nil),
	(*RecordType)(nil),
	(*RecordsPossessProperties)(nil),
	(*RelationCardinality)(nil),
	(*RelativeToNoun)(nil),
	(*RenderTemplate)(nil),
	(*Send)(nil),
	(*ShuffleText)(nil),
	(*SingularKind)(nil),
	(*StoppingText)(nil),
	(*Story)(nil),
	(*Summary)(nil),
	(*Tail)(nil),
	(*TestName)(nil),
	(*TestOutput)(nil),
	(*TestRule)(nil),
	(*TestScene)(nil),
	(*TestStatement)(nil),
	(*TextList)(nil),
	(*Trait)(nil),
	(*TraitPhrase)(nil),
	(*VariableDecl)(nil),
	(*VariableType)(nil),
}
