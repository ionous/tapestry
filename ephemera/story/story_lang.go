// Code generated by "makeops"; edit at your own risk.
package story

import (
	"encoding/json"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/dl/core"
	"git.sr.ht/~ionous/iffy/dl/grammar"
	"git.sr.ht/~ionous/iffy/dl/reader"
	"git.sr.ht/~ionous/iffy/dl/value"
	"git.sr.ht/~ionous/iffy/rt"
	"github.com/ionous/errutil"
)

// AbstractAction requires a user-specified string.
type AbstractAction struct {
	Str string
}

func (op *AbstractAction) String() (ret string) {
	return op.Str
}

func (op *AbstractAction) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "abstract_action",
		"value": op.Str,
	})
}

const AbstractAction_Nothing = "$NOTHING"

func (*AbstractAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "abstract_action",
		Uses: "str",
		Choices: []string{
			AbstractAction_Nothing,
		},
		Strings: []string{
			"nothing",
		},
	}
}

// ActionContext
type ActionContext struct {
	At   reader.Position `if:"internal"`
	Kind SingularKind    `if:"label=kind"`
}

func (*ActionContext) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_context",
		Uses: "flow",
	}
}

func (op *ActionContext) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "action_context",
			"value": map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *ActionContext) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

// ActionDecl
type ActionDecl struct {
	At           reader.Position `if:"internal"`
	Event        EventName       `if:"label=event"`
	Action       ActionName      `if:"label=action"`
	ActionParams ActionParams    `if:"label=action_params"`
}

func (*ActionDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_decl",
		Uses: "flow",
	}
}

func (op *ActionDecl) MarshalJSON() (ret []byte, err error) {
	if jsonEvent, e := op.MarshalJSONEvent(); e != nil {
		err = e
	} else if jsonAction, e := op.MarshalJSONAction(); e != nil {
		err = e
	} else if jsonActionParams, e := op.MarshalJSONActionParams(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "action_decl",
			"value": map[string]json.RawMessage{
				"$EVENT":         jsonEvent,
				"$ACTION":        jsonAction,
				"$ACTION_PARAMS": jsonActionParams,
			},
		})
	}
	return
}

func (op *ActionDecl) MarshalJSONEvent() ([]byte, error) {
	return op.Event.MarshalJSON()
}

func (op *ActionDecl) MarshalJSONAction() ([]byte, error) {
	return op.Action.MarshalJSON()
}

func (op *ActionDecl) MarshalJSONActionParams() ([]byte, error) {
	return op.ActionParams.MarshalJSON()
}

// ActionName requires a user-specified string.
type ActionName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *ActionName) String() (ret string) {
	return op.Str
}

func (op *ActionName) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "action_name",
		"value": op.Str,
	})
}

func (*ActionName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "action_name",
		Uses:        "str",
		OpenStrings: true,
	}
}

// ActionParams swaps between various options
type ActionParams struct {
	Opt interface{}
}

const ActionParams_Common = "$COMMON"
const ActionParams_Dual = "$DUAL"
const ActionParams_None = "$NONE"

func (*ActionParams) Compose() composer.Spec {
	return composer.Spec{
		Name: "action_params",
		Uses: "swap",
		Choices: []string{
			ActionParams_Common, ActionParams_Dual, ActionParams_None,
		},
		Swaps: []interface{}{
			(*CommonAction)(nil),
			(*PairedAction)(nil),
			(*AbstractAction)(nil),
		},
	}
}

func (op *ActionParams) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "action_params",
			"value": val,
		})
	}
	return
}

func (op *ActionParams) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *ActionParams) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *CommonAction:
		ret, okay = ActionParams_Common, true
	case *PairedAction:
		ret, okay = ActionParams_Dual, true
	case *AbstractAction:
		ret, okay = ActionParams_None, true
	}
	return
}

// Ana requires a user-specified string.
type Ana struct {
	Str string
}

func (op *Ana) String() (ret string) {
	return op.Str
}

func (op *Ana) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "ana",
		"value": op.Str,
	})
}

const Ana_A = "$A"
const Ana_An = "$AN"

func (*Ana) Compose() composer.Spec {
	return composer.Spec{
		Name: "ana",
		Uses: "str",
		Choices: []string{
			Ana_A, Ana_An,
		},
		Strings: []string{
			"a", "an",
		},
	}
}

// AreAn requires a user-specified string.
type AreAn struct {
	Str string
}

func (op *AreAn) String() (ret string) {
	return op.Str
}

func (op *AreAn) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "are_an",
		"value": op.Str,
	})
}

const AreAn_Are = "$ARE"
const AreAn_Area = "$AREA"
const AreAn_Arean = "$AREAN"
const AreAn_Is = "$IS"
const AreAn_Isa = "$ISA"
const AreAn_Isan = "$ISAN"

func (*AreAn) Compose() composer.Spec {
	return composer.Spec{
		Name: "are_an",
		Uses: "str",
		Choices: []string{
			AreAn_Are, AreAn_Area, AreAn_Arean, AreAn_Is, AreAn_Isa, AreAn_Isan,
		},
		Strings: []string{
			"are", "area", "arean", "is", "isa", "isan",
		},
	}
}

// AreBeing requires a user-specified string.
type AreBeing struct {
	Str string
}

func (op *AreBeing) String() (ret string) {
	return op.Str
}

func (op *AreBeing) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "are_being",
		"value": op.Str,
	})
}

const AreBeing_Are = "$ARE"
const AreBeing_Is = "$IS"

func (*AreBeing) Compose() composer.Spec {
	return composer.Spec{
		Name: "are_being",
		Uses: "str",
		Choices: []string{
			AreBeing_Are, AreBeing_Is,
		},
		Strings: []string{
			"are", "is",
		},
	}
}

// AreEither requires a user-specified string.
type AreEither struct {
	Str string
}

func (op *AreEither) String() (ret string) {
	return op.Str
}

func (op *AreEither) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "are_either",
		"value": op.Str,
	})
}

const AreEither_Canbe = "$CANBE"
const AreEither_Either = "$EITHER"

func (*AreEither) Compose() composer.Spec {
	return composer.Spec{
		Name: "are_either",
		Uses: "str",
		Choices: []string{
			AreEither_Canbe, AreEither_Either,
		},
		Strings: []string{
			"canbe", "either",
		},
	}
}

// Argument
type Argument struct {
	At   reader.Position `if:"internal"`
	Name string          `if:"label=_,type=text"`
	From rt.Assignment   `if:"label=from"`
}

func (*Argument) Compose() composer.Spec {
	return composer.Spec{
		Name: "argument",
		Uses: "flow",
		Lede: "arg",
	}
}

func (op *Argument) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonFrom, e := op.MarshalJSONFrom(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "argument",
			"value": map[string]json.RawMessage{
				"$NAME": jsonName,
				"$FROM": jsonFrom,
			},
		})
	}
	return
}

func (op *Argument) MarshalJSONName() ([]byte, error) {
	// type override
	m := value.Text{op.Name}
	return m.MarshalJSON()
}

func (op *Argument) MarshalJSONFrom() ([]byte, error) {
	m := op.From.(json.Marshaler)
	return m.MarshalJSON()
}

// Arguments
type Arguments struct {
	At   reader.Position `if:"internal"`
	Args []Argument      `if:"label=_"`
}

func (*Arguments) Compose() composer.Spec {
	return composer.Spec{
		Name: "arguments",
		Uses: "flow",
		Lede: "args",
	}
}

func (op *Arguments) MarshalJSON() (ret []byte, err error) {
	if jsonArgs, e := op.MarshalJSONArgs(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "arguments",
			"value": map[string]json.RawMessage{
				"$ARGS": jsonArgs,
			},
		})
	}
	return
}

func (op *Arguments) MarshalJSONArgs() ([]byte, error) {
	return json.Marshal(op.Args)
}

// Aspect requires a user-specified string.
type Aspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Aspect) String() (ret string) {
	return op.Str
}

func (op *Aspect) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "aspect",
		"value": op.Str,
	})
}

func (*Aspect) Compose() composer.Spec {
	return composer.Spec{
		Name:        "aspect",
		Uses:        "str",
		OpenStrings: true,
	}
}

// AspectTraits
type AspectTraits struct {
	Aspect      Aspect      `if:"label=_"`
	TraitPhrase TraitPhrase `if:"label=trait_phrase"`
}

func (*AspectTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: "aspect_traits",
		Uses: "flow",
	}
}

func (op *AspectTraits) MarshalJSON() (ret []byte, err error) {
	if jsonAspect, e := op.MarshalJSONAspect(); e != nil {
		err = e
	} else if jsonTraitPhrase, e := op.MarshalJSONTraitPhrase(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "aspect_traits",
			"value": map[string]json.RawMessage{
				"$ASPECT":       jsonAspect,
				"$TRAIT_PHRASE": jsonTraitPhrase,
			},
		})
	}
	return
}

func (op *AspectTraits) MarshalJSONAspect() ([]byte, error) {
	return op.Aspect.MarshalJSON()
}

func (op *AspectTraits) MarshalJSONTraitPhrase() ([]byte, error) {
	return op.TraitPhrase.MarshalJSON()
}

// BoxedNumber
type BoxedNumber struct {
	Number float64 `if:"label=_,type=number"`
}

func (*BoxedNumber) Compose() composer.Spec {
	return composer.Spec{
		Name: "boxed_number",
		Uses: "flow",
	}
}

func (op *BoxedNumber) MarshalJSON() (ret []byte, err error) {
	if jsonNumber, e := op.MarshalJSONNumber(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "boxed_number",
			"value": map[string]json.RawMessage{
				"$NUMBER": jsonNumber,
			},
		})
	}
	return
}

func (op *BoxedNumber) MarshalJSONNumber() ([]byte, error) {
	// type override
	m := value.Number{op.Number}
	return m.MarshalJSON()
}

// BoxedText
type BoxedText struct {
	Text string `if:"label=_,type=text"`
}

func (*BoxedText) Compose() composer.Spec {
	return composer.Spec{
		Name: "boxed_text",
		Uses: "flow",
	}
}

func (op *BoxedText) MarshalJSON() (ret []byte, err error) {
	if jsonText, e := op.MarshalJSONText(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "boxed_text",
			"value": map[string]json.RawMessage{
				"$TEXT": jsonText,
			},
		})
	}
	return
}

func (op *BoxedText) MarshalJSONText() ([]byte, error) {
	// type override
	m := value.Text{op.Text}
	return m.MarshalJSON()
}

// Certainties
type Certainties struct {
	PluralKinds PluralKinds `if:"label=_"`
	AreBeing    bool        `if:"label=are_being,type=are_being"`
	Certainty   Certainty   `if:"label=certainty"`
	Trait       Trait       `if:"label=trait"`
}

func (*Certainties) Compose() composer.Spec {
	return composer.Spec{
		Name: "certainties",
		Uses: "flow",
	}
}

func (op *Certainties) MarshalJSON() (ret []byte, err error) {
	if jsonPluralKinds, e := op.MarshalJSONPluralKinds(); e != nil {
		err = e
	} else if jsonAreBeing, e := op.MarshalJSONAreBeing(); e != nil {
		err = e
	} else if jsonCertainty, e := op.MarshalJSONCertainty(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "certainties",
			"value": map[string]json.RawMessage{
				"$PLURAL_KINDS": jsonPluralKinds,
				"$ARE_BEING":    jsonAreBeing,
				"$CERTAINTY":    jsonCertainty,
				"$TRAIT":        jsonTrait,
			},
		})
	}
	return
}

func (op *Certainties) MarshalJSONPluralKinds() ([]byte, error) {
	return op.PluralKinds.MarshalJSON()
}

func (op *Certainties) MarshalJSONAreBeing() ([]byte, error) {
	// bool override
	var str string
	if op.AreBeing {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	return m.MarshalJSON()
}

func (op *Certainties) MarshalJSONCertainty() ([]byte, error) {
	return op.Certainty.MarshalJSON()
}

func (op *Certainties) MarshalJSONTrait() ([]byte, error) {
	return op.Trait.MarshalJSON()
}

// Certainty requires a user-specified string.
type Certainty struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Certainty) String() (ret string) {
	return op.Str
}

func (op *Certainty) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "certainty",
		"value": op.Str,
	})
}

const Certainty_Usually = "$USUALLY"
const Certainty_Always = "$ALWAYS"
const Certainty_Seldom = "$SELDOM"
const Certainty_Never = "$NEVER"

func (*Certainty) Compose() composer.Spec {
	return composer.Spec{
		Name: "certainty",
		Uses: "str",
		Choices: []string{
			Certainty_Usually, Certainty_Always, Certainty_Seldom, Certainty_Never,
		},
		Strings: []string{
			"usually", "always", "seldom", "never",
		},
	}
}

// Comment Information about the story for you and other authors.
type Comment struct {
	Lines value.Lines `if:"label=_"`
}

func (*Comment) Compose() composer.Spec {
	return composer.Spec{
		Name: "comment",
		Uses: "flow",
	}
}

func (op *Comment) MarshalJSON() (ret []byte, err error) {
	if jsonLines, e := op.MarshalJSONLines(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "comment",
			"value": map[string]json.RawMessage{
				"$LINES": jsonLines,
			},
		})
	}
	return
}

func (op *Comment) MarshalJSONLines() ([]byte, error) {
	return op.Lines.MarshalJSON()
}

// CommonAction
type CommonAction struct {
	At            reader.Position `if:"internal"`
	Kind          SingularKind    `if:"label=kind"`
	ActionContext *ActionContext  `if:"label=action_context,optional"`
}

func (*CommonAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "common_action",
		Uses: "flow",
	}
}

func (op *CommonAction) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonActionContext, e := op.MarshalJSONActionContext(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "common_action",
			"value": map[string]json.RawMessage{
				"$KIND":           jsonKind,
				"$ACTION_CONTEXT": jsonActionContext,
			},
		})
	}
	return
}

func (op *CommonAction) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

func (op *CommonAction) MarshalJSONActionContext() ([]byte, error) {
	return op.ActionContext.MarshalJSON()
}

// CountOf A guard which returns true based on a counter.
type CountOf struct {
	At      reader.Position `if:"internal"`
	Trigger core.Trigger    `if:"label=trigger"`
	Num     rt.NumberEval   `if:"label=num"`
}

func (*CountOf) Compose() composer.Spec {
	return composer.Spec{
		Name: "count_of",
		Uses: "flow",
	}
}

func (op *CountOf) MarshalJSON() (ret []byte, err error) {
	if jsonTrigger, e := op.MarshalJSONTrigger(); e != nil {
		err = e
	} else if jsonNum, e := op.MarshalJSONNum(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "count_of",
			"value": map[string]json.RawMessage{
				"$TRIGGER": jsonTrigger,
				"$NUM":     jsonNum,
			},
		})
	}
	return
}

func (op *CountOf) MarshalJSONTrigger() ([]byte, error) {
	m := op.Trigger.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *CountOf) MarshalJSONNum() ([]byte, error) {
	m := op.Num.(json.Marshaler)
	return m.MarshalJSON()
}

// CycleText
type CycleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*CycleText) Compose() composer.Spec {
	return composer.Spec{
		Name: "cycle_text",
		Uses: "flow",
	}
}

func (op *CycleText) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "cycle_text",
			"value": map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *CycleText) MarshalJSONParts() ([]byte, error) {
	return json.Marshal(op.Parts)
}

// Determine
type Determine struct {
	Name      value.PatternName `if:"label=_"`
	Arguments *Arguments        `if:"label=arguments,optional"`
}

func (*Determine) Compose() composer.Spec {
	return composer.Spec{
		Name: "determine",
		Uses: "flow",
	}
}

func (op *Determine) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "determine",
			"value": map[string]json.RawMessage{
				"$NAME":      jsonName,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *Determine) MarshalJSONName() ([]byte, error) {
	return op.Name.MarshalJSON()
}

func (op *Determine) MarshalJSONArguments() ([]byte, error) {
	return op.Arguments.MarshalJSON()
}

// Determiner requires a user-specified string.
type Determiner struct {
	Str string
}

func (op *Determiner) String() (ret string) {
	return op.Str
}

func (op *Determiner) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "determiner",
		"value": op.Str,
	})
}

const Determiner_A = "$A"
const Determiner_An = "$AN"
const Determiner_The = "$THE"
const Determiner_Our = "$OUR"

func (*Determiner) Compose() composer.Spec {
	return composer.Spec{
		Name:        "determiner",
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			Determiner_A, Determiner_An, Determiner_The, Determiner_Our,
		},
		Strings: []string{
			"a", "an", "the", "our",
		},
	}
}

// EventBlock Listeners let objects in the game world react to changes before, during, or after they happen.
type EventBlock struct {
	At       reader.Position `if:"internal"`
	Target   EventTarget     `if:"label=target"`
	Handlers []EventHandler  `if:"label=handlers"`
}

func (*EventBlock) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_block",
		Uses: "flow",
	}
}

func (op *EventBlock) MarshalJSON() (ret []byte, err error) {
	if jsonTarget, e := op.MarshalJSONTarget(); e != nil {
		err = e
	} else if jsonHandlers, e := op.MarshalJSONHandlers(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "event_block",
			"value": map[string]json.RawMessage{
				"$TARGET":   jsonTarget,
				"$HANDLERS": jsonHandlers,
			},
		})
	}
	return
}

func (op *EventBlock) MarshalJSONTarget() ([]byte, error) {
	return op.Target.MarshalJSON()
}

func (op *EventBlock) MarshalJSONHandlers() ([]byte, error) {
	return json.Marshal(op.Handlers)
}

// EventHandler
type EventHandler struct {
	EventPhase   EventPhase     `if:"label=_"`
	Event        EventName      `if:"label=event"`
	Locals       *PatternLocals `if:"label=locals,optional"`
	PatternRules PatternRules   `if:"label=pattern_rules"`
}

func (*EventHandler) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_handler",
		Uses: "flow",
	}
}

func (op *EventHandler) MarshalJSON() (ret []byte, err error) {
	if jsonEventPhase, e := op.MarshalJSONEventPhase(); e != nil {
		err = e
	} else if jsonEvent, e := op.MarshalJSONEvent(); e != nil {
		err = e
	} else if jsonLocals, e := op.MarshalJSONLocals(); e != nil {
		err = e
	} else if jsonPatternRules, e := op.MarshalJSONPatternRules(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "event_handler",
			"value": map[string]json.RawMessage{
				"$EVENT_PHASE":   jsonEventPhase,
				"$EVENT":         jsonEvent,
				"$LOCALS":        jsonLocals,
				"$PATTERN_RULES": jsonPatternRules,
			},
		})
	}
	return
}

func (op *EventHandler) MarshalJSONEventPhase() ([]byte, error) {
	return op.EventPhase.MarshalJSON()
}

func (op *EventHandler) MarshalJSONEvent() ([]byte, error) {
	return op.Event.MarshalJSON()
}

func (op *EventHandler) MarshalJSONLocals() ([]byte, error) {
	return op.Locals.MarshalJSON()
}

func (op *EventHandler) MarshalJSONPatternRules() ([]byte, error) {
	return op.PatternRules.MarshalJSON()
}

// EventName requires a user-specified string.
type EventName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *EventName) String() (ret string) {
	return op.Str
}

func (op *EventName) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "event_name",
		"value": op.Str,
	})
}

func (*EventName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "event_name",
		Uses:        "str",
		OpenStrings: true,
	}
}

// EventPhase requires a user-specified string.
type EventPhase struct {
	Str string
}

func (op *EventPhase) String() (ret string) {
	return op.Str
}

func (op *EventPhase) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "event_phase",
		"value": op.Str,
	})
}

const EventPhase_Before = "$BEFORE"
const EventPhase_While = "$WHILE"
const EventPhase_After = "$AFTER"

func (*EventPhase) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_phase",
		Uses: "str",
		Choices: []string{
			EventPhase_Before, EventPhase_While, EventPhase_After,
		},
		Strings: []string{
			"before", "while", "after",
		},
	}
}

// EventTarget swaps between various options
type EventTarget struct {
	Opt interface{}
}

const EventTarget_Kinds = "$KINDS"
const EventTarget_NamedNoun = "$NAMED_NOUN"

func (*EventTarget) Compose() composer.Spec {
	return composer.Spec{
		Name: "event_target",
		Uses: "swap",
		Choices: []string{
			EventTarget_Kinds, EventTarget_NamedNoun,
		},
		Swaps: []interface{}{
			(*PluralKinds)(nil),
			(*NamedNoun)(nil),
		},
	}
}

func (op *EventTarget) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "event_target",
			"value": val,
		})
	}
	return
}

func (op *EventTarget) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *EventTarget) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PluralKinds:
		ret, okay = EventTarget_Kinds, true
	case *NamedNoun:
		ret, okay = EventTarget_NamedNoun, true
	}
	return
}

// ExtType swaps between various options
type ExtType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ExtType_Numbers = "$NUMBERS"
const ExtType_TextList = "$TEXT_LIST"
const ExtType_Record = "$RECORD"
const ExtType_Records = "$RECORDS"

func (*ExtType) Compose() composer.Spec {
	return composer.Spec{
		Name: "ext_type",
		Uses: "swap",
		Choices: []string{
			ExtType_Numbers, ExtType_TextList, ExtType_Record, ExtType_Records,
		},
		Swaps: []interface{}{
			(*NumberList)(nil),
			(*TextList)(nil),
			(*RecordType)(nil),
			(*RecordList)(nil),
		},
	}
}

func (op *ExtType) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "ext_type",
			"value": val,
		})
	}
	return
}

func (op *ExtType) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *ExtType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *NumberList:
		ret, okay = ExtType_Numbers, true
	case *TextList:
		ret, okay = ExtType_TextList, true
	case *RecordType:
		ret, okay = ExtType_Record, true
	case *RecordList:
		ret, okay = ExtType_Records, true
	}
	return
}

// GrammarDecl
type GrammarDecl struct {
	Grammar grammar.GrammarMaker `if:"label=_"`
}

func (*GrammarDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "grammar_decl",
		Uses: "flow",
	}
}

func (op *GrammarDecl) MarshalJSON() (ret []byte, err error) {
	if jsonGrammar, e := op.MarshalJSONGrammar(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "grammar_decl",
			"value": map[string]json.RawMessage{
				"$GRAMMAR": jsonGrammar,
			},
		})
	}
	return
}

func (op *GrammarDecl) MarshalJSONGrammar() ([]byte, error) {
	m := op.Grammar.(json.Marshaler)
	return m.MarshalJSON()
}

// KindOfNoun
type KindOfNoun struct {
	AreAn        AreAn         `if:"label=_"`
	Trait        []Trait       `if:"label=trait,optional"`
	Kind         SingularKind  `if:"label=kind"`
	NounRelation *NounRelation `if:"label=noun_relation,optional"`
}

func (*KindOfNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of_noun",
		Uses: "flow",
	}
}

func (op *KindOfNoun) MarshalJSON() (ret []byte, err error) {
	if jsonAreAn, e := op.MarshalJSONAreAn(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonNounRelation, e := op.MarshalJSONNounRelation(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "kind_of_noun",
			"value": map[string]json.RawMessage{
				"$ARE_AN":        jsonAreAn,
				"$TRAIT":         jsonTrait,
				"$KIND":          jsonKind,
				"$NOUN_RELATION": jsonNounRelation,
			},
		})
	}
	return
}

func (op *KindOfNoun) MarshalJSONAreAn() ([]byte, error) {
	return op.AreAn.MarshalJSON()
}

func (op *KindOfNoun) MarshalJSONTrait() ([]byte, error) {
	return json.Marshal(op.Trait)
}

func (op *KindOfNoun) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

func (op *KindOfNoun) MarshalJSONNounRelation() ([]byte, error) {
	return op.NounRelation.MarshalJSON()
}

// KindOfRelation
type KindOfRelation struct {
	Relation            value.RelationName  `if:"label=_"`
	RelationCardinality RelationCardinality `if:"label=relation_cardinality"`
}

func (*KindOfRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: "kind_of_relation",
		Uses: "flow",
	}
}

func (op *KindOfRelation) MarshalJSON() (ret []byte, err error) {
	if jsonRelation, e := op.MarshalJSONRelation(); e != nil {
		err = e
	} else if jsonRelationCardinality, e := op.MarshalJSONRelationCardinality(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "kind_of_relation",
			"value": map[string]json.RawMessage{
				"$RELATION":             jsonRelation,
				"$RELATION_CARDINALITY": jsonRelationCardinality,
			},
		})
	}
	return
}

func (op *KindOfRelation) MarshalJSONRelation() ([]byte, error) {
	return op.Relation.MarshalJSON()
}

func (op *KindOfRelation) MarshalJSONRelationCardinality() ([]byte, error) {
	return op.RelationCardinality.MarshalJSON()
}

// KindsOfAspect
type KindsOfAspect struct {
	Aspect Aspect `if:"label=_"`
}

func (*KindsOfAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_aspect",
		Uses: "flow",
	}
}

func (op *KindsOfAspect) MarshalJSON() (ret []byte, err error) {
	if jsonAspect, e := op.MarshalJSONAspect(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "kinds_of_aspect",
			"value": map[string]json.RawMessage{
				"$ASPECT": jsonAspect,
			},
		})
	}
	return
}

func (op *KindsOfAspect) MarshalJSONAspect() ([]byte, error) {
	return op.Aspect.MarshalJSON()
}

// KindsOfKind
type KindsOfKind struct {
	PluralKinds  PluralKinds  `if:"label=_"`
	SingularKind SingularKind `if:"label=singular_kind"`
}

func (*KindsOfKind) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_kind",
		Uses: "flow",
	}
}

func (op *KindsOfKind) MarshalJSON() (ret []byte, err error) {
	if jsonPluralKinds, e := op.MarshalJSONPluralKinds(); e != nil {
		err = e
	} else if jsonSingularKind, e := op.MarshalJSONSingularKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "kinds_of_kind",
			"value": map[string]json.RawMessage{
				"$PLURAL_KINDS":  jsonPluralKinds,
				"$SINGULAR_KIND": jsonSingularKind,
			},
		})
	}
	return
}

func (op *KindsOfKind) MarshalJSONPluralKinds() ([]byte, error) {
	return op.PluralKinds.MarshalJSON()
}

func (op *KindsOfKind) MarshalJSONSingularKind() ([]byte, error) {
	return op.SingularKind.MarshalJSON()
}

// KindsOfRecord
type KindsOfRecord struct {
	RecordPlural RecordPlural `if:"label=_"`
}

func (*KindsOfRecord) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_of_record",
		Uses: "flow",
	}
}

func (op *KindsOfRecord) MarshalJSON() (ret []byte, err error) {
	if jsonRecordPlural, e := op.MarshalJSONRecordPlural(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "kinds_of_record",
			"value": map[string]json.RawMessage{
				"$RECORD_PLURAL": jsonRecordPlural,
			},
		})
	}
	return
}

func (op *KindsOfRecord) MarshalJSONRecordPlural() ([]byte, error) {
	return op.RecordPlural.MarshalJSON()
}

// KindsPossessProperties
type KindsPossessProperties struct {
	PluralKinds  PluralKinds    `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*KindsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: "kinds_possess_properties",
		Uses: "flow",
	}
}

func (op *KindsPossessProperties) MarshalJSON() (ret []byte, err error) {
	if jsonPluralKinds, e := op.MarshalJSONPluralKinds(); e != nil {
		err = e
	} else if jsonPropertyDecl, e := op.MarshalJSONPropertyDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "kinds_possess_properties",
			"value": map[string]json.RawMessage{
				"$PLURAL_KINDS":  jsonPluralKinds,
				"$PROPERTY_DECL": jsonPropertyDecl,
			},
		})
	}
	return
}

func (op *KindsPossessProperties) MarshalJSONPluralKinds() ([]byte, error) {
	return op.PluralKinds.MarshalJSON()
}

func (op *KindsPossessProperties) MarshalJSONPropertyDecl() ([]byte, error) {
	return json.Marshal(op.PropertyDecl)
}

// Lede Describes one or more nouns.
type Lede struct {
	Nouns      []NamedNoun `if:"label=_"`
	NounPhrase NounPhrase  `if:"label=noun_phrase"`
}

func (*Lede) Compose() composer.Spec {
	return composer.Spec{
		Name: "lede",
		Uses: "flow",
	}
}

func (op *Lede) MarshalJSON() (ret []byte, err error) {
	if jsonNouns, e := op.MarshalJSONNouns(); e != nil {
		err = e
	} else if jsonNounPhrase, e := op.MarshalJSONNounPhrase(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "lede",
			"value": map[string]json.RawMessage{
				"$NOUNS":       jsonNouns,
				"$NOUN_PHRASE": jsonNounPhrase,
			},
		})
	}
	return
}

func (op *Lede) MarshalJSONNouns() ([]byte, error) {
	return json.Marshal(op.Nouns)
}

func (op *Lede) MarshalJSONNounPhrase() ([]byte, error) {
	return op.NounPhrase.MarshalJSON()
}

// LocalDecl
type LocalDecl struct {
	VariableDecl VariableDecl `if:"label=_"`
	Value        *LocalInit   `if:"label=value,optional"`
}

func (*LocalDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "local_decl",
		Uses: "flow",
	}
}

func (op *LocalDecl) MarshalJSON() (ret []byte, err error) {
	if jsonVariableDecl, e := op.MarshalJSONVariableDecl(); e != nil {
		err = e
	} else if jsonValue, e := op.MarshalJSONValue(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "local_decl",
			"value": map[string]json.RawMessage{
				"$VARIABLE_DECL": jsonVariableDecl,
				"$VALUE":         jsonValue,
			},
		})
	}
	return
}

func (op *LocalDecl) MarshalJSONVariableDecl() ([]byte, error) {
	return op.VariableDecl.MarshalJSON()
}

func (op *LocalDecl) MarshalJSONValue() ([]byte, error) {
	return op.Value.MarshalJSON()
}

// LocalInit
type LocalInit struct {
	Value rt.Assignment `if:"label=_"`
}

func (*LocalInit) Compose() composer.Spec {
	return composer.Spec{
		Name: "local_init",
		Uses: "flow",
	}
}

func (op *LocalInit) MarshalJSON() (ret []byte, err error) {
	if jsonValue, e := op.MarshalJSONValue(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "local_init",
			"value": map[string]json.RawMessage{
				"$VALUE": jsonValue,
			},
		})
	}
	return
}

func (op *LocalInit) MarshalJSONValue() ([]byte, error) {
	m := op.Value.(json.Marshaler)
	return m.MarshalJSON()
}

// Make
type Make struct {
	Name      string     `if:"label=_,type=text"`
	Arguments *Arguments `if:"label=arguments,optional"`
}

func (*Make) Compose() composer.Spec {
	return composer.Spec{
		Name: "make",
		Uses: "flow",
	}
}

func (op *Make) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "make",
			"value": map[string]json.RawMessage{
				"$NAME":      jsonName,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *Make) MarshalJSONName() ([]byte, error) {
	// type override
	m := value.Text{op.Name}
	return m.MarshalJSON()
}

func (op *Make) MarshalJSONArguments() ([]byte, error) {
	return op.Arguments.MarshalJSON()
}

// ManyToMany
type ManyToMany struct {
	Kinds      PluralKinds `if:"label=_"`
	OtherKinds PluralKinds `if:"label=other_kinds"`
}

func (*ManyToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: "many_to_many",
		Uses: "flow",
	}
}

func (op *ManyToMany) MarshalJSON() (ret []byte, err error) {
	if jsonKinds, e := op.MarshalJSONKinds(); e != nil {
		err = e
	} else if jsonOtherKinds, e := op.MarshalJSONOtherKinds(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "many_to_many",
			"value": map[string]json.RawMessage{
				"$KINDS":       jsonKinds,
				"$OTHER_KINDS": jsonOtherKinds,
			},
		})
	}
	return
}

func (op *ManyToMany) MarshalJSONKinds() ([]byte, error) {
	return op.Kinds.MarshalJSON()
}

func (op *ManyToMany) MarshalJSONOtherKinds() ([]byte, error) {
	return op.OtherKinds.MarshalJSON()
}

// ManyToOne
type ManyToOne struct {
	Kinds PluralKinds  `if:"label=_"`
	Kind  SingularKind `if:"label=kind"`
}

func (*ManyToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: "many_to_one",
		Uses: "flow",
	}
}

func (op *ManyToOne) MarshalJSON() (ret []byte, err error) {
	if jsonKinds, e := op.MarshalJSONKinds(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "many_to_one",
			"value": map[string]json.RawMessage{
				"$KINDS": jsonKinds,
				"$KIND":  jsonKind,
			},
		})
	}
	return
}

func (op *ManyToOne) MarshalJSONKinds() ([]byte, error) {
	return op.Kinds.MarshalJSON()
}

func (op *ManyToOne) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

// NamedNoun
type NamedNoun struct {
	Determiner Determiner `if:"label=_"`
	Name       NounName   `if:"label=name"`
}

func (*NamedNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "named_noun",
		Uses: "flow",
	}
}

func (op *NamedNoun) MarshalJSON() (ret []byte, err error) {
	if jsonDeterminer, e := op.MarshalJSONDeterminer(); e != nil {
		err = e
	} else if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "named_noun",
			"value": map[string]json.RawMessage{
				"$DETERMINER": jsonDeterminer,
				"$NAME":       jsonName,
			},
		})
	}
	return
}

func (op *NamedNoun) MarshalJSONDeterminer() ([]byte, error) {
	return op.Determiner.MarshalJSON()
}

func (op *NamedNoun) MarshalJSONName() ([]byte, error) {
	return op.Name.MarshalJSON()
}

// NounAssignment Assign text.
type NounAssignment struct {
	Property Property    `if:"label=_"`
	Nouns    []NamedNoun `if:"label=nouns"`
	Lines    value.Lines `if:"label=lines"`
}

func (*NounAssignment) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_assignment",
		Uses: "flow",
	}
}

func (op *NounAssignment) MarshalJSON() (ret []byte, err error) {
	if jsonProperty, e := op.MarshalJSONProperty(); e != nil {
		err = e
	} else if jsonNouns, e := op.MarshalJSONNouns(); e != nil {
		err = e
	} else if jsonLines, e := op.MarshalJSONLines(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "noun_assignment",
			"value": map[string]json.RawMessage{
				"$PROPERTY": jsonProperty,
				"$NOUNS":    jsonNouns,
				"$LINES":    jsonLines,
			},
		})
	}
	return
}

func (op *NounAssignment) MarshalJSONProperty() ([]byte, error) {
	return op.Property.MarshalJSON()
}

func (op *NounAssignment) MarshalJSONNouns() ([]byte, error) {
	return json.Marshal(op.Nouns)
}

func (op *NounAssignment) MarshalJSONLines() ([]byte, error) {
	return op.Lines.MarshalJSON()
}

// NounName requires a user-specified string.
type NounName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *NounName) String() (ret string) {
	return op.Str
}

func (op *NounName) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "noun_name",
		"value": op.Str,
	})
}

func (*NounName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "noun_name",
		Uses:        "str",
		OpenStrings: true,
	}
}

// NounPhrase swaps between various options
type NounPhrase struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const NounPhrase_KindOfNoun = "$KIND_OF_NOUN"
const NounPhrase_NounTraits = "$NOUN_TRAITS"
const NounPhrase_NounRelation = "$NOUN_RELATION"

func (*NounPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_phrase",
		Uses: "swap",
		Choices: []string{
			NounPhrase_KindOfNoun, NounPhrase_NounTraits, NounPhrase_NounRelation,
		},
		Swaps: []interface{}{
			(*KindOfNoun)(nil),
			(*NounTraits)(nil),
			(*NounRelation)(nil),
		},
	}
}

func (op *NounPhrase) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "noun_phrase",
			"value": val,
		})
	}
	return
}

func (op *NounPhrase) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *NounPhrase) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *KindOfNoun:
		ret, okay = NounPhrase_KindOfNoun, true
	case *NounTraits:
		ret, okay = NounPhrase_NounTraits, true
	case *NounRelation:
		ret, okay = NounPhrase_NounRelation, true
	}
	return
}

// NounRelation
type NounRelation struct {
	AreBeing bool               `if:"label=_,optional,type=are_being"`
	Relation value.RelationName `if:"label=relation"`
	Nouns    []NamedNoun        `if:"label=nouns"`
}

func (*NounRelation) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_relation",
		Uses: "flow",
	}
}

func (op *NounRelation) MarshalJSON() (ret []byte, err error) {
	if jsonAreBeing, e := op.MarshalJSONAreBeing(); e != nil {
		err = e
	} else if jsonRelation, e := op.MarshalJSONRelation(); e != nil {
		err = e
	} else if jsonNouns, e := op.MarshalJSONNouns(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "noun_relation",
			"value": map[string]json.RawMessage{
				"$ARE_BEING": jsonAreBeing,
				"$RELATION":  jsonRelation,
				"$NOUNS":     jsonNouns,
			},
		})
	}
	return
}

func (op *NounRelation) MarshalJSONAreBeing() ([]byte, error) {
	// bool override
	var str string
	if op.AreBeing {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	return m.MarshalJSON()
}

func (op *NounRelation) MarshalJSONRelation() ([]byte, error) {
	return op.Relation.MarshalJSON()
}

func (op *NounRelation) MarshalJSONNouns() ([]byte, error) {
	return json.Marshal(op.Nouns)
}

// NounStatement Describes people, places, or things.
type NounStatement struct {
	Lede    Lede     `if:"label=_"`
	Tail    []Tail   `if:"label=tail,optional"`
	Summary *Summary `if:"label=summary,optional"`
}

func (*NounStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_statement",
		Uses: "flow",
	}
}

func (op *NounStatement) MarshalJSON() (ret []byte, err error) {
	if jsonLede, e := op.MarshalJSONLede(); e != nil {
		err = e
	} else if jsonTail, e := op.MarshalJSONTail(); e != nil {
		err = e
	} else if jsonSummary, e := op.MarshalJSONSummary(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "noun_statement",
			"value": map[string]json.RawMessage{
				"$LEDE":    jsonLede,
				"$TAIL":    jsonTail,
				"$SUMMARY": jsonSummary,
			},
		})
	}
	return
}

func (op *NounStatement) MarshalJSONLede() ([]byte, error) {
	return op.Lede.MarshalJSON()
}

func (op *NounStatement) MarshalJSONTail() ([]byte, error) {
	return json.Marshal(op.Tail)
}

func (op *NounStatement) MarshalJSONSummary() ([]byte, error) {
	return op.Summary.MarshalJSON()
}

// NounTraits
type NounTraits struct {
	AreBeing bool    `if:"label=_,type=are_being"`
	Trait    []Trait `if:"label=trait"`
}

func (*NounTraits) Compose() composer.Spec {
	return composer.Spec{
		Name: "noun_traits",
		Uses: "flow",
	}
}

func (op *NounTraits) MarshalJSON() (ret []byte, err error) {
	if jsonAreBeing, e := op.MarshalJSONAreBeing(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "noun_traits",
			"value": map[string]json.RawMessage{
				"$ARE_BEING": jsonAreBeing,
				"$TRAIT":     jsonTrait,
			},
		})
	}
	return
}

func (op *NounTraits) MarshalJSONAreBeing() ([]byte, error) {
	// bool override
	var str string
	if op.AreBeing {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	return m.MarshalJSON()
}

func (op *NounTraits) MarshalJSONTrait() ([]byte, error) {
	return json.Marshal(op.Trait)
}

// NumberList requires a user-specified string.
type NumberList struct {
	Str string
}

func (op *NumberList) String() (ret string) {
	return op.Str
}

func (op *NumberList) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "number_list",
		"value": op.Str,
	})
}

const NumberList_List = "$LIST"

func (*NumberList) Compose() composer.Spec {
	return composer.Spec{
		Name: "number_list",
		Uses: "str",
		Choices: []string{
			NumberList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

// ObjectType
type ObjectType struct {
	An   bool         `if:"label=_,type=ana"`
	Kind SingularKind `if:"label=kind"`
}

func (*ObjectType) Compose() composer.Spec {
	return composer.Spec{
		Name: "object_type",
		Uses: "flow",
	}
}

func (op *ObjectType) MarshalJSON() (ret []byte, err error) {
	if jsonAn, e := op.MarshalJSONAn(); e != nil {
		err = e
	} else if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "object_type",
			"value": map[string]json.RawMessage{
				"$AN":   jsonAn,
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *ObjectType) MarshalJSONAn() ([]byte, error) {
	// bool override
	var str string
	if op.An {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	return m.MarshalJSON()
}

func (op *ObjectType) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

// OneToMany
type OneToMany struct {
	Kind  SingularKind `if:"label=_"`
	Kinds PluralKinds  `if:"label=kinds"`
}

func (*OneToMany) Compose() composer.Spec {
	return composer.Spec{
		Name: "one_to_many",
		Uses: "flow",
	}
}

func (op *OneToMany) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonKinds, e := op.MarshalJSONKinds(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "one_to_many",
			"value": map[string]json.RawMessage{
				"$KIND":  jsonKind,
				"$KINDS": jsonKinds,
			},
		})
	}
	return
}

func (op *OneToMany) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

func (op *OneToMany) MarshalJSONKinds() ([]byte, error) {
	return op.Kinds.MarshalJSON()
}

// OneToOne
type OneToOne struct {
	Kind      SingularKind `if:"label=_"`
	OtherKind SingularKind `if:"label=other_kind"`
}

func (*OneToOne) Compose() composer.Spec {
	return composer.Spec{
		Name: "one_to_one",
		Uses: "flow",
	}
}

func (op *OneToOne) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else if jsonOtherKind, e := op.MarshalJSONOtherKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "one_to_one",
			"value": map[string]json.RawMessage{
				"$KIND":       jsonKind,
				"$OTHER_KIND": jsonOtherKind,
			},
		})
	}
	return
}

func (op *OneToOne) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

func (op *OneToOne) MarshalJSONOtherKind() ([]byte, error) {
	return op.OtherKind.MarshalJSON()
}

// PairedAction
type PairedAction struct {
	At    reader.Position `if:"internal"`
	Kinds PluralKinds     `if:"label=kinds"`
}

func (*PairedAction) Compose() composer.Spec {
	return composer.Spec{
		Name: "paired_action",
		Uses: "flow",
	}
}

func (op *PairedAction) MarshalJSON() (ret []byte, err error) {
	if jsonKinds, e := op.MarshalJSONKinds(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "paired_action",
			"value": map[string]json.RawMessage{
				"$KINDS": jsonKinds,
			},
		})
	}
	return
}

func (op *PairedAction) MarshalJSONKinds() ([]byte, error) {
	return op.Kinds.MarshalJSON()
}

// Paragraph
type Paragraph struct {
	StoryStatement []StoryStatement `if:"label=_,optional"`
}

func (*Paragraph) Compose() composer.Spec {
	return composer.Spec{
		Name: "paragraph",
		Uses: "flow",
	}
}

func (op *Paragraph) MarshalJSON() (ret []byte, err error) {
	if jsonStoryStatement, e := op.MarshalJSONStoryStatement(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "paragraph",
			"value": map[string]json.RawMessage{
				"$STORY_STATEMENT": jsonStoryStatement,
			},
		})
	}
	return
}

func (op *Paragraph) MarshalJSONStoryStatement() ([]byte, error) {
	return json.Marshal(op.StoryStatement)
}

// PatternActions Actions to take when using a pattern.
type PatternActions struct {
	Name          value.PatternName `if:"label=_"`
	PatternLocals *PatternLocals    `if:"label=pattern_locals,optional"`
	PatternReturn *PatternReturn    `if:"label=pattern_return,optional"`
	PatternRules  PatternRules      `if:"label=pattern_rules"`
}

func (*PatternActions) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_actions",
		Uses: "flow",
	}
}

func (op *PatternActions) MarshalJSON() (ret []byte, err error) {
	if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonPatternLocals, e := op.MarshalJSONPatternLocals(); e != nil {
		err = e
	} else if jsonPatternReturn, e := op.MarshalJSONPatternReturn(); e != nil {
		err = e
	} else if jsonPatternRules, e := op.MarshalJSONPatternRules(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pattern_actions",
			"value": map[string]json.RawMessage{
				"$NAME":           jsonName,
				"$PATTERN_LOCALS": jsonPatternLocals,
				"$PATTERN_RETURN": jsonPatternReturn,
				"$PATTERN_RULES":  jsonPatternRules,
			},
		})
	}
	return
}

func (op *PatternActions) MarshalJSONName() ([]byte, error) {
	return op.Name.MarshalJSON()
}

func (op *PatternActions) MarshalJSONPatternLocals() ([]byte, error) {
	return op.PatternLocals.MarshalJSON()
}

func (op *PatternActions) MarshalJSONPatternReturn() ([]byte, error) {
	return op.PatternReturn.MarshalJSON()
}

func (op *PatternActions) MarshalJSONPatternRules() ([]byte, error) {
	return op.PatternRules.MarshalJSON()
}

// PatternDecl
type PatternDecl struct {
	Type          PatternType           `if:"label=_"`
	Name          value.PatternName     `if:"label=name"`
	Optvars       *PatternVariablesTail `if:"label=optvars,optional"`
	PatternReturn *PatternReturn        `if:"label=pattern_return,optional"`
	About         *Comment              `if:"label=about,optional"`
}

func (*PatternDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_decl",
		Uses: "flow",
	}
}

func (op *PatternDecl) MarshalJSON() (ret []byte, err error) {
	if jsonType, e := op.MarshalJSONType(); e != nil {
		err = e
	} else if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonOptvars, e := op.MarshalJSONOptvars(); e != nil {
		err = e
	} else if jsonPatternReturn, e := op.MarshalJSONPatternReturn(); e != nil {
		err = e
	} else if jsonAbout, e := op.MarshalJSONAbout(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pattern_decl",
			"value": map[string]json.RawMessage{
				"$TYPE":           jsonType,
				"$NAME":           jsonName,
				"$OPTVARS":        jsonOptvars,
				"$PATTERN_RETURN": jsonPatternReturn,
				"$ABOUT":          jsonAbout,
			},
		})
	}
	return
}

func (op *PatternDecl) MarshalJSONType() ([]byte, error) {
	return op.Type.MarshalJSON()
}

func (op *PatternDecl) MarshalJSONName() ([]byte, error) {
	return op.Name.MarshalJSON()
}

func (op *PatternDecl) MarshalJSONOptvars() ([]byte, error) {
	return op.Optvars.MarshalJSON()
}

func (op *PatternDecl) MarshalJSONPatternReturn() ([]byte, error) {
	return op.PatternReturn.MarshalJSON()
}

func (op *PatternDecl) MarshalJSONAbout() ([]byte, error) {
	return op.About.MarshalJSON()
}

// PatternFlags requires a user-specified string.
type PatternFlags struct {
	Str string
}

func (op *PatternFlags) String() (ret string) {
	return op.Str
}

func (op *PatternFlags) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "pattern_flags",
		"value": op.Str,
	})
}

const PatternFlags_Before = "$BEFORE"
const PatternFlags_After = "$AFTER"
const PatternFlags_Terminate = "$TERMINATE"

func (*PatternFlags) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_flags",
		Uses: "str",
		Choices: []string{
			PatternFlags_Before, PatternFlags_After, PatternFlags_Terminate,
		},
		Strings: []string{
			"before", "after", "terminate",
		},
	}
}

// PatternLocals
type PatternLocals struct {
	LocalDecl []LocalDecl `if:"label=_"`
}

func (*PatternLocals) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_locals",
		Uses: "flow",
	}
}

func (op *PatternLocals) MarshalJSON() (ret []byte, err error) {
	if jsonLocalDecl, e := op.MarshalJSONLocalDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pattern_locals",
			"value": map[string]json.RawMessage{
				"$LOCAL_DECL": jsonLocalDecl,
			},
		})
	}
	return
}

func (op *PatternLocals) MarshalJSONLocalDecl() ([]byte, error) {
	return json.Marshal(op.LocalDecl)
}

// PatternReturn
type PatternReturn struct {
	Result VariableDecl `if:"label=_"`
}

func (*PatternReturn) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_return",
		Uses: "flow",
	}
}

func (op *PatternReturn) MarshalJSON() (ret []byte, err error) {
	if jsonResult, e := op.MarshalJSONResult(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pattern_return",
			"value": map[string]json.RawMessage{
				"$RESULT": jsonResult,
			},
		})
	}
	return
}

func (op *PatternReturn) MarshalJSONResult() ([]byte, error) {
	return op.Result.MarshalJSON()
}

// PatternRule
type PatternRule struct {
	Guard rt.BoolEval  `if:"label=_"`
	Flags PatternFlags `if:"label=flags,optional"`
	Hook  ProgramHook  `if:"label=hook"`
}

func (*PatternRule) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_rule",
		Uses: "flow",
	}
}

func (op *PatternRule) MarshalJSON() (ret []byte, err error) {
	if jsonGuard, e := op.MarshalJSONGuard(); e != nil {
		err = e
	} else if jsonFlags, e := op.MarshalJSONFlags(); e != nil {
		err = e
	} else if jsonHook, e := op.MarshalJSONHook(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pattern_rule",
			"value": map[string]json.RawMessage{
				"$GUARD": jsonGuard,
				"$FLAGS": jsonFlags,
				"$HOOK":  jsonHook,
			},
		})
	}
	return
}

func (op *PatternRule) MarshalJSONGuard() ([]byte, error) {
	m := op.Guard.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *PatternRule) MarshalJSONFlags() ([]byte, error) {
	return op.Flags.MarshalJSON()
}

func (op *PatternRule) MarshalJSONHook() ([]byte, error) {
	return op.Hook.MarshalJSON()
}

// PatternRules
type PatternRules struct {
	PatternRule []PatternRule `if:"label=_,optional"`
}

func (*PatternRules) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_rules",
		Uses: "flow",
	}
}

func (op *PatternRules) MarshalJSON() (ret []byte, err error) {
	if jsonPatternRule, e := op.MarshalJSONPatternRule(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pattern_rules",
			"value": map[string]json.RawMessage{
				"$PATTERN_RULE": jsonPatternRule,
			},
		})
	}
	return
}

func (op *PatternRules) MarshalJSONPatternRule() ([]byte, error) {
	return json.Marshal(op.PatternRule)
}

// PatternType requires a user-specified string.
type PatternType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PatternType) String() (ret string) {
	return op.Str
}

func (op *PatternType) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "pattern_type",
		"value": op.Str,
	})
}

const PatternType_Patterns = "$PATTERNS"
const PatternType_Actions = "$ACTIONS"
const PatternType_Events = "$EVENTS"

func (*PatternType) Compose() composer.Spec {
	return composer.Spec{
		Name:        "pattern_type",
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			PatternType_Patterns, PatternType_Actions, PatternType_Events,
		},
		Strings: []string{
			"patterns", "actions", "events",
		},
	}
}

// PatternVariablesDecl Values provided when calling a pattern.
type PatternVariablesDecl struct {
	PatternName  value.PatternName `if:"label=_"`
	VariableDecl []VariableDecl    `if:"label=variable_decl"`
}

func (*PatternVariablesDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_variables_decl",
		Uses: "flow",
	}
}

func (op *PatternVariablesDecl) MarshalJSON() (ret []byte, err error) {
	if jsonPatternName, e := op.MarshalJSONPatternName(); e != nil {
		err = e
	} else if jsonVariableDecl, e := op.MarshalJSONVariableDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pattern_variables_decl",
			"value": map[string]json.RawMessage{
				"$PATTERN_NAME":  jsonPatternName,
				"$VARIABLE_DECL": jsonVariableDecl,
			},
		})
	}
	return
}

func (op *PatternVariablesDecl) MarshalJSONPatternName() ([]byte, error) {
	return op.PatternName.MarshalJSON()
}

func (op *PatternVariablesDecl) MarshalJSONVariableDecl() ([]byte, error) {
	return json.Marshal(op.VariableDecl)
}

// PatternVariablesTail Storage for values used during the execution of a pattern.
type PatternVariablesTail struct {
	VariableDecl []VariableDecl `if:"label=_"`
}

func (*PatternVariablesTail) Compose() composer.Spec {
	return composer.Spec{
		Name: "pattern_variables_tail",
		Uses: "flow",
	}
}

func (op *PatternVariablesTail) MarshalJSON() (ret []byte, err error) {
	if jsonVariableDecl, e := op.MarshalJSONVariableDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "pattern_variables_tail",
			"value": map[string]json.RawMessage{
				"$VARIABLE_DECL": jsonVariableDecl,
			},
		})
	}
	return
}

func (op *PatternVariablesTail) MarshalJSONVariableDecl() ([]byte, error) {
	return json.Marshal(op.VariableDecl)
}

// PluralKinds requires a user-specified string.
type PluralKinds struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PluralKinds) String() (ret string) {
	return op.Str
}

func (op *PluralKinds) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "plural_kinds",
		"value": op.Str,
	})
}

func (*PluralKinds) Compose() composer.Spec {
	return composer.Spec{
		Name:        "plural_kinds",
		Uses:        "str",
		OpenStrings: true,
	}
}

// PrimitiveType requires a user-specified string.
type PrimitiveType struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PrimitiveType) String() (ret string) {
	return op.Str
}

func (op *PrimitiveType) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "primitive_type",
		"value": op.Str,
	})
}

const PrimitiveType_Number = "$NUMBER"
const PrimitiveType_Text = "$TEXT"
const PrimitiveType_Bool = "$BOOL"

func (*PrimitiveType) Compose() composer.Spec {
	return composer.Spec{
		Name: "primitive_type",
		Uses: "str",
		Choices: []string{
			PrimitiveType_Number, PrimitiveType_Text, PrimitiveType_Bool,
		},
		Strings: []string{
			"number", "text", "bool",
		},
	}
}

// PrimitiveValue swaps between various options
type PrimitiveValue struct {
	Opt interface{}
}

const PrimitiveValue_BoxedText = "$BOXED_TEXT"
const PrimitiveValue_BoxedNumber = "$BOXED_NUMBER"

func (*PrimitiveValue) Compose() composer.Spec {
	return composer.Spec{
		Name: "primitive_value",
		Uses: "swap",
		Choices: []string{
			PrimitiveValue_BoxedText, PrimitiveValue_BoxedNumber,
		},
		Swaps: []interface{}{
			(*BoxedText)(nil),
			(*BoxedNumber)(nil),
		},
	}
}

func (op *PrimitiveValue) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type":  "primitive_value",
			"value": val,
		})
	}
	return
}

func (op *PrimitiveValue) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *PrimitiveValue) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *BoxedText:
		ret, okay = PrimitiveValue_BoxedText, true
	case *BoxedNumber:
		ret, okay = PrimitiveValue_BoxedNumber, true
	}
	return
}

// ProgramHook swaps between various options
type ProgramHook struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const ProgramHook_Activity = "$ACTIVITY"

func (*ProgramHook) Compose() composer.Spec {
	return composer.Spec{
		Name: "program_hook",
		Uses: "swap",
		Choices: []string{
			ProgramHook_Activity,
		},
		Swaps: []interface{}{
			(*core.Activity)(nil),
		},
	}
}

func (op *ProgramHook) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "program_hook",
			"value": val,
		})
	}
	return
}

func (op *ProgramHook) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *ProgramHook) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *core.Activity:
		ret, okay = ProgramHook_Activity, true
	}
	return
}

// Pronoun requires a user-specified string.
type Pronoun struct {
	Str string
}

func (op *Pronoun) String() (ret string) {
	return op.Str
}

func (op *Pronoun) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "pronoun",
		"value": op.Str,
	})
}

const Pronoun_It = "$IT"
const Pronoun_They = "$THEY"

func (*Pronoun) Compose() composer.Spec {
	return composer.Spec{
		Name:        "pronoun",
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			Pronoun_It, Pronoun_They,
		},
		Strings: []string{
			"it", "they",
		},
	}
}

// Property requires a user-specified string.
type Property struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Property) String() (ret string) {
	return op.Str
}

func (op *Property) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "property",
		"value": op.Str,
	})
}

func (*Property) Compose() composer.Spec {
	return composer.Spec{
		Name:        "property",
		Uses:        "str",
		OpenStrings: true,
	}
}

// PropertyAspect requires a user-specified string.
type PropertyAspect struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *PropertyAspect) String() (ret string) {
	return op.Str
}

func (op *PropertyAspect) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "property_aspect",
		"value": op.Str,
	})
}

const PropertyAspect_Aspect = "$ASPECT"

func (*PropertyAspect) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_aspect",
		Uses: "str",
		Choices: []string{
			PropertyAspect_Aspect,
		},
		Strings: []string{
			"aspect",
		},
	}
}

// PropertyDecl
type PropertyDecl struct {
	An           Determiner   `if:"label=_"`
	Property     Property     `if:"label=property"`
	PropertyType PropertyType `if:"label=property_type"`
	Comment      value.Lines  `if:"label=comment,optional"`
}

func (*PropertyDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_decl",
		Uses: "flow",
	}
}

func (op *PropertyDecl) MarshalJSON() (ret []byte, err error) {
	if jsonAn, e := op.MarshalJSONAn(); e != nil {
		err = e
	} else if jsonProperty, e := op.MarshalJSONProperty(); e != nil {
		err = e
	} else if jsonPropertyType, e := op.MarshalJSONPropertyType(); e != nil {
		err = e
	} else if jsonComment, e := op.MarshalJSONComment(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "property_decl",
			"value": map[string]json.RawMessage{
				"$AN":            jsonAn,
				"$PROPERTY":      jsonProperty,
				"$PROPERTY_TYPE": jsonPropertyType,
				"$COMMENT":       jsonComment,
			},
		})
	}
	return
}

func (op *PropertyDecl) MarshalJSONAn() ([]byte, error) {
	return op.An.MarshalJSON()
}

func (op *PropertyDecl) MarshalJSONProperty() ([]byte, error) {
	return op.Property.MarshalJSON()
}

func (op *PropertyDecl) MarshalJSONPropertyType() ([]byte, error) {
	return op.PropertyType.MarshalJSON()
}

func (op *PropertyDecl) MarshalJSONComment() ([]byte, error) {
	return op.Comment.MarshalJSON()
}

// PropertyType swaps between various options
type PropertyType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const PropertyType_PropertyAspect = "$PROPERTY_ASPECT"
const PropertyType_Primitive = "$PRIMITIVE"
const PropertyType_Ext = "$EXT"

func (*PropertyType) Compose() composer.Spec {
	return composer.Spec{
		Name: "property_type",
		Uses: "swap",
		Choices: []string{
			PropertyType_PropertyAspect, PropertyType_Primitive, PropertyType_Ext,
		},
		Swaps: []interface{}{
			(*PropertyAspect)(nil),
			(*PrimitiveType)(nil),
			(*ExtType)(nil),
		},
	}
}

func (op *PropertyType) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "property_type",
			"value": val,
		})
	}
	return
}

func (op *PropertyType) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *PropertyType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PropertyAspect:
		ret, okay = PropertyType_PropertyAspect, true
	case *PrimitiveType:
		ret, okay = PropertyType_Primitive, true
	case *ExtType:
		ret, okay = PropertyType_Ext, true
	}
	return
}

// RecordList
type RecordList struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordList) Compose() composer.Spec {
	return composer.Spec{
		Name: "record_list",
		Uses: "flow",
	}
}

func (op *RecordList) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "record_list",
			"value": map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *RecordList) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

// RecordPlural requires a user-specified string.
type RecordPlural struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordPlural) String() (ret string) {
	return op.Str
}

func (op *RecordPlural) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "record_plural",
		"value": op.Str,
	})
}

func (*RecordPlural) Compose() composer.Spec {
	return composer.Spec{
		Name:        "record_plural",
		Uses:        "str",
		OpenStrings: true,
	}
}

// RecordSingular requires a user-specified string.
type RecordSingular struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *RecordSingular) String() (ret string) {
	return op.Str
}

func (op *RecordSingular) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "record_singular",
		"value": op.Str,
	})
}

func (*RecordSingular) Compose() composer.Spec {
	return composer.Spec{
		Name:        "record_singular",
		Uses:        "str",
		OpenStrings: true,
	}
}

// RecordType
type RecordType struct {
	Kind RecordSingular `if:"label=_"`
}

func (*RecordType) Compose() composer.Spec {
	return composer.Spec{
		Name: "record_type",
		Uses: "flow",
	}
}

func (op *RecordType) MarshalJSON() (ret []byte, err error) {
	if jsonKind, e := op.MarshalJSONKind(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "record_type",
			"value": map[string]json.RawMessage{
				"$KIND": jsonKind,
			},
		})
	}
	return
}

func (op *RecordType) MarshalJSONKind() ([]byte, error) {
	return op.Kind.MarshalJSON()
}

// RecordsPossessProperties
type RecordsPossessProperties struct {
	RecordPlural RecordPlural   `if:"label=_"`
	PropertyDecl []PropertyDecl `if:"label=property_decl"`
}

func (*RecordsPossessProperties) Compose() composer.Spec {
	return composer.Spec{
		Name: "records_possess_properties",
		Uses: "flow",
	}
}

func (op *RecordsPossessProperties) MarshalJSON() (ret []byte, err error) {
	if jsonRecordPlural, e := op.MarshalJSONRecordPlural(); e != nil {
		err = e
	} else if jsonPropertyDecl, e := op.MarshalJSONPropertyDecl(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "records_possess_properties",
			"value": map[string]json.RawMessage{
				"$RECORD_PLURAL": jsonRecordPlural,
				"$PROPERTY_DECL": jsonPropertyDecl,
			},
		})
	}
	return
}

func (op *RecordsPossessProperties) MarshalJSONRecordPlural() ([]byte, error) {
	return op.RecordPlural.MarshalJSON()
}

func (op *RecordsPossessProperties) MarshalJSONPropertyDecl() ([]byte, error) {
	return json.Marshal(op.PropertyDecl)
}

// RelationCardinality swaps between various options
type RelationCardinality struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const RelationCardinality_OneToOne = "$ONE_TO_ONE"
const RelationCardinality_OneToMany = "$ONE_TO_MANY"
const RelationCardinality_ManyToOne = "$MANY_TO_ONE"
const RelationCardinality_ManyToMany = "$MANY_TO_MANY"

func (*RelationCardinality) Compose() composer.Spec {
	return composer.Spec{
		Name: "relation_cardinality",
		Uses: "swap",
		Choices: []string{
			RelationCardinality_OneToOne, RelationCardinality_OneToMany, RelationCardinality_ManyToOne, RelationCardinality_ManyToMany,
		},
		Swaps: []interface{}{
			(*OneToOne)(nil),
			(*OneToMany)(nil),
			(*ManyToOne)(nil),
			(*ManyToMany)(nil),
		},
	}
}

func (op *RelationCardinality) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "relation_cardinality",
			"value": val,
		})
	}
	return
}

func (op *RelationCardinality) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *RelationCardinality) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *OneToOne:
		ret, okay = RelationCardinality_OneToOne, true
	case *OneToMany:
		ret, okay = RelationCardinality_OneToMany, true
	case *ManyToOne:
		ret, okay = RelationCardinality_ManyToOne, true
	case *ManyToMany:
		ret, okay = RelationCardinality_ManyToMany, true
	}
	return
}

// RelativeToNoun
type RelativeToNoun struct {
	Relation value.RelationName `if:"label=_"`
	Nouns    []NamedNoun        `if:"label=nouns"`
	AreBeing bool               `if:"label=are_being,type=are_being"`
	Nouns1   []NamedNoun        `if:"label=nouns1"`
}

func (*RelativeToNoun) Compose() composer.Spec {
	return composer.Spec{
		Name: "relative_to_noun",
		Uses: "flow",
	}
}

func (op *RelativeToNoun) MarshalJSON() (ret []byte, err error) {
	if jsonRelation, e := op.MarshalJSONRelation(); e != nil {
		err = e
	} else if jsonNouns, e := op.MarshalJSONNouns(); e != nil {
		err = e
	} else if jsonAreBeing, e := op.MarshalJSONAreBeing(); e != nil {
		err = e
	} else if jsonNouns1, e := op.MarshalJSONNouns1(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "relative_to_noun",
			"value": map[string]json.RawMessage{
				"$RELATION":  jsonRelation,
				"$NOUNS":     jsonNouns,
				"$ARE_BEING": jsonAreBeing,
				"$NOUNS1":    jsonNouns1,
			},
		})
	}
	return
}

func (op *RelativeToNoun) MarshalJSONRelation() ([]byte, error) {
	return op.Relation.MarshalJSON()
}

func (op *RelativeToNoun) MarshalJSONNouns() ([]byte, error) {
	return json.Marshal(op.Nouns)
}

func (op *RelativeToNoun) MarshalJSONAreBeing() ([]byte, error) {
	// bool override
	var str string
	if op.AreBeing {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	return m.MarshalJSON()
}

func (op *RelativeToNoun) MarshalJSONNouns1() ([]byte, error) {
	return json.Marshal(op.Nouns1)
}

// RenderTemplate Parse text using iffy templates.
type RenderTemplate struct {
	Template value.Lines `if:"label=_"`
}

func (*RenderTemplate) Compose() composer.Spec {
	return composer.Spec{
		Name: "render_template",
		Uses: "flow",
	}
}

func (op *RenderTemplate) MarshalJSON() (ret []byte, err error) {
	if jsonTemplate, e := op.MarshalJSONTemplate(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "render_template",
			"value": map[string]json.RawMessage{
				"$TEMPLATE": jsonTemplate,
			},
		})
	}
	return
}

func (op *RenderTemplate) MarshalJSONTemplate() ([]byte, error) {
	return op.Template.MarshalJSON()
}

// Send
type Send struct {
	Event     string          `if:"label=_,type=text"`
	Path      rt.TextListEval `if:"label=path"`
	Arguments *Arguments      `if:"label=arguments,optional"`
}

func (*Send) Compose() composer.Spec {
	return composer.Spec{
		Name: "send",
		Uses: "flow",
	}
}

func (op *Send) MarshalJSON() (ret []byte, err error) {
	if jsonEvent, e := op.MarshalJSONEvent(); e != nil {
		err = e
	} else if jsonPath, e := op.MarshalJSONPath(); e != nil {
		err = e
	} else if jsonArguments, e := op.MarshalJSONArguments(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "send",
			"value": map[string]json.RawMessage{
				"$EVENT":     jsonEvent,
				"$PATH":      jsonPath,
				"$ARGUMENTS": jsonArguments,
			},
		})
	}
	return
}

func (op *Send) MarshalJSONEvent() ([]byte, error) {
	// type override
	m := value.Text{op.Event}
	return m.MarshalJSON()
}

func (op *Send) MarshalJSONPath() ([]byte, error) {
	m := op.Path.(json.Marshaler)
	return m.MarshalJSON()
}

func (op *Send) MarshalJSONArguments() ([]byte, error) {
	return op.Arguments.MarshalJSON()
}

// ShuffleText
type ShuffleText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*ShuffleText) Compose() composer.Spec {
	return composer.Spec{
		Name: "shuffle_text",
		Uses: "flow",
	}
}

func (op *ShuffleText) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "shuffle_text",
			"value": map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *ShuffleText) MarshalJSONParts() ([]byte, error) {
	return json.Marshal(op.Parts)
}

// SingularKind requires a user-specified string.
type SingularKind struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *SingularKind) String() (ret string) {
	return op.Str
}

func (op *SingularKind) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "singular_kind",
		"value": op.Str,
	})
}

func (*SingularKind) Compose() composer.Spec {
	return composer.Spec{
		Name:        "singular_kind",
		Uses:        "str",
		OpenStrings: true,
	}
}

// StoppingText
type StoppingText struct {
	At    reader.Position `if:"internal"`
	Parts []rt.TextEval   `if:"label=parts"`
}

func (*StoppingText) Compose() composer.Spec {
	return composer.Spec{
		Name: "stopping_text",
		Uses: "flow",
	}
}

func (op *StoppingText) MarshalJSON() (ret []byte, err error) {
	if jsonParts, e := op.MarshalJSONParts(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "stopping_text",
			"value": map[string]json.RawMessage{
				"$PARTS": jsonParts,
			},
		})
	}
	return
}

func (op *StoppingText) MarshalJSONParts() ([]byte, error) {
	return json.Marshal(op.Parts)
}

// Story
type Story struct {
	Paragraph []Paragraph `if:"label=_,optional"`
}

func (*Story) Compose() composer.Spec {
	return composer.Spec{
		Name: "story",
		Uses: "flow",
	}
}

func (op *Story) MarshalJSON() (ret []byte, err error) {
	if jsonParagraph, e := op.MarshalJSONParagraph(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "story",
			"value": map[string]json.RawMessage{
				"$PARAGRAPH": jsonParagraph,
			},
		})
	}
	return
}

func (op *Story) MarshalJSONParagraph() ([]byte, error) {
	return json.Marshal(op.Paragraph)
}

// Summary
type Summary struct {
	At    reader.Position `if:"internal"`
	Lines value.Lines     `if:"label=lines"`
}

func (*Summary) Compose() composer.Spec {
	return composer.Spec{
		Name: "summary",
		Uses: "flow",
	}
}

func (op *Summary) MarshalJSON() (ret []byte, err error) {
	if jsonLines, e := op.MarshalJSONLines(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "summary",
			"value": map[string]json.RawMessage{
				"$LINES": jsonLines,
			},
		})
	}
	return
}

func (op *Summary) MarshalJSONLines() ([]byte, error) {
	return op.Lines.MarshalJSON()
}

// Tail Adds details about the preceding noun or nouns.
type Tail struct {
	Pronoun    Pronoun    `if:"label=_"`
	NounPhrase NounPhrase `if:"label=noun_phrase"`
}

func (*Tail) Compose() composer.Spec {
	return composer.Spec{
		Name: "tail",
		Uses: "flow",
	}
}

func (op *Tail) MarshalJSON() (ret []byte, err error) {
	if jsonPronoun, e := op.MarshalJSONPronoun(); e != nil {
		err = e
	} else if jsonNounPhrase, e := op.MarshalJSONNounPhrase(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "tail",
			"value": map[string]json.RawMessage{
				"$PRONOUN":     jsonPronoun,
				"$NOUN_PHRASE": jsonNounPhrase,
			},
		})
	}
	return
}

func (op *Tail) MarshalJSONPronoun() ([]byte, error) {
	return op.Pronoun.MarshalJSON()
}

func (op *Tail) MarshalJSONNounPhrase() ([]byte, error) {
	return op.NounPhrase.MarshalJSON()
}

// TestName requires a user-specified string.
type TestName struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *TestName) String() (ret string) {
	return op.Str
}

func (op *TestName) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "test_name",
		"value": op.Str,
	})
}

const TestName_CurrentTest = "$CURRENT_TEST"

func (*TestName) Compose() composer.Spec {
	return composer.Spec{
		Name:        "test_name",
		Uses:        "str",
		OpenStrings: true,
		Choices: []string{
			TestName_CurrentTest,
		},
		Strings: []string{
			"current_test",
		},
	}
}

// TestOutput Expect that a test uses &#x27;Say&#x27; to print some specific text.
type TestOutput struct {
	Lines value.Lines `if:"label=_"`
}

func (*TestOutput) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_output",
		Uses: "flow",
	}
}

func (op *TestOutput) MarshalJSON() (ret []byte, err error) {
	if jsonLines, e := op.MarshalJSONLines(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "test_output",
			"value": map[string]json.RawMessage{
				"$LINES": jsonLines,
			},
		})
	}
	return
}

func (op *TestOutput) MarshalJSONLines() ([]byte, error) {
	return op.Lines.MarshalJSON()
}

// TestRule
type TestRule struct {
	TestName TestName    `if:"label=_"`
	Hook     ProgramHook `if:"label=hook"`
}

func (*TestRule) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_rule",
		Uses: "flow",
	}
}

func (op *TestRule) MarshalJSON() (ret []byte, err error) {
	if jsonTestName, e := op.MarshalJSONTestName(); e != nil {
		err = e
	} else if jsonHook, e := op.MarshalJSONHook(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "test_rule",
			"value": map[string]json.RawMessage{
				"$TEST_NAME": jsonTestName,
				"$HOOK":      jsonHook,
			},
		})
	}
	return
}

func (op *TestRule) MarshalJSONTestName() ([]byte, error) {
	return op.TestName.MarshalJSON()
}

func (op *TestRule) MarshalJSONHook() ([]byte, error) {
	return op.Hook.MarshalJSON()
}

// TestScene
type TestScene struct {
	TestName TestName `if:"label=_"`
	Story    Story    `if:"label=story"`
}

func (*TestScene) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_scene",
		Uses: "flow",
	}
}

func (op *TestScene) MarshalJSON() (ret []byte, err error) {
	if jsonTestName, e := op.MarshalJSONTestName(); e != nil {
		err = e
	} else if jsonStory, e := op.MarshalJSONStory(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "test_scene",
			"value": map[string]json.RawMessage{
				"$TEST_NAME": jsonTestName,
				"$STORY":     jsonStory,
			},
		})
	}
	return
}

func (op *TestScene) MarshalJSONTestName() ([]byte, error) {
	return op.TestName.MarshalJSON()
}

func (op *TestScene) MarshalJSONStory() ([]byte, error) {
	return op.Story.MarshalJSON()
}

// TestStatement
type TestStatement struct {
	At       reader.Position `if:"internal"`
	TestName TestName        `if:"label=test_name"`
	Test     Testing         `if:"label=test"`
}

func (*TestStatement) Compose() composer.Spec {
	return composer.Spec{
		Name: "test_statement",
		Uses: "flow",
	}
}

func (op *TestStatement) MarshalJSON() (ret []byte, err error) {
	if jsonTestName, e := op.MarshalJSONTestName(); e != nil {
		err = e
	} else if jsonTest, e := op.MarshalJSONTest(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"id":   op.At.Offset,
			"type": "test_statement",
			"value": map[string]json.RawMessage{
				"$TEST_NAME": jsonTestName,
				"$TEST":      jsonTest,
			},
		})
	}
	return
}

func (op *TestStatement) MarshalJSONTestName() ([]byte, error) {
	return op.TestName.MarshalJSON()
}

func (op *TestStatement) MarshalJSONTest() ([]byte, error) {
	m := op.Test.(json.Marshaler)
	return m.MarshalJSON()
}

// TextList requires a user-specified string.
type TextList struct {
	Str string
}

func (op *TextList) String() (ret string) {
	return op.Str
}

func (op *TextList) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"type":  "text_list",
		"value": op.Str,
	})
}

const TextList_List = "$LIST"

func (*TextList) Compose() composer.Spec {
	return composer.Spec{
		Name: "text_list",
		Uses: "str",
		Choices: []string{
			TextList_List,
		},
		Strings: []string{
			"list",
		},
	}
}

// Trait requires a user-specified string.
type Trait struct {
	At  reader.Position `if:"internal"`
	Str string
}

func (op *Trait) String() (ret string) {
	return op.Str
}

func (op *Trait) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{"id": op.At.Offset,
		"type":  "trait",
		"value": op.Str,
	})
}

func (*Trait) Compose() composer.Spec {
	return composer.Spec{
		Name:        "trait",
		Uses:        "str",
		OpenStrings: true,
	}
}

// TraitPhrase
type TraitPhrase struct {
	AreEither bool    `if:"label=_,type=are_either"`
	Trait     []Trait `if:"label=trait"`
}

func (*TraitPhrase) Compose() composer.Spec {
	return composer.Spec{
		Name: "trait_phrase",
		Uses: "flow",
	}
}

func (op *TraitPhrase) MarshalJSON() (ret []byte, err error) {
	if jsonAreEither, e := op.MarshalJSONAreEither(); e != nil {
		err = e
	} else if jsonTrait, e := op.MarshalJSONTrait(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "trait_phrase",
			"value": map[string]json.RawMessage{
				"$ARE_EITHER": jsonAreEither,
				"$TRAIT":      jsonTrait,
			},
		})
	}
	return
}

func (op *TraitPhrase) MarshalJSONAreEither() ([]byte, error) {
	// bool override
	var str string
	if op.AreEither {
		str = value.Bool_True
	} else {
		str = value.Bool_False
	}
	m := value.Bool{str}
	return m.MarshalJSON()
}

func (op *TraitPhrase) MarshalJSONTrait() ([]byte, error) {
	return json.Marshal(op.Trait)
}

// VariableDecl
type VariableDecl struct {
	An      Determiner         `if:"label=_"`
	Name    value.VariableName `if:"label=name"`
	Type    VariableType       `if:"label=type"`
	Comment value.Lines        `if:"label=comment,optional"`
}

func (*VariableDecl) Compose() composer.Spec {
	return composer.Spec{
		Name: "variable_decl",
		Uses: "flow",
	}
}

func (op *VariableDecl) MarshalJSON() (ret []byte, err error) {
	if jsonAn, e := op.MarshalJSONAn(); e != nil {
		err = e
	} else if jsonName, e := op.MarshalJSONName(); e != nil {
		err = e
	} else if jsonType, e := op.MarshalJSONType(); e != nil {
		err = e
	} else if jsonComment, e := op.MarshalJSONComment(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{
			"type": "variable_decl",
			"value": map[string]json.RawMessage{
				"$AN":      jsonAn,
				"$NAME":    jsonName,
				"$TYPE":    jsonType,
				"$COMMENT": jsonComment,
			},
		})
	}
	return
}

func (op *VariableDecl) MarshalJSONAn() ([]byte, error) {
	return op.An.MarshalJSON()
}

func (op *VariableDecl) MarshalJSONName() ([]byte, error) {
	return op.Name.MarshalJSON()
}

func (op *VariableDecl) MarshalJSONType() ([]byte, error) {
	return op.Type.MarshalJSON()
}

func (op *VariableDecl) MarshalJSONComment() ([]byte, error) {
	return op.Comment.MarshalJSON()
}

// VariableType swaps between various options
type VariableType struct {
	At  reader.Position `if:"internal"`
	Opt interface{}
}

const VariableType_Primitive = "$PRIMITIVE"
const VariableType_Object = "$OBJECT"
const VariableType_Ext = "$EXT"

func (*VariableType) Compose() composer.Spec {
	return composer.Spec{
		Name: "variable_type",
		Uses: "swap",
		Choices: []string{
			VariableType_Primitive, VariableType_Object, VariableType_Ext,
		},
		Swaps: []interface{}{
			(*PrimitiveType)(nil),
			(*ObjectType)(nil),
			(*ExtType)(nil),
		},
	}
}

func (op *VariableType) MarshalJSON() (ret []byte, err error) {
	if val, e := op.MarshalChoice(); e != nil {
		err = e
	} else {
		ret, err = json.Marshal(map[string]interface{}{"id": op.At.Offset,
			"type":  "variable_type",
			"value": val,
		})
	}
	return
}

func (op *VariableType) MarshalChoice() (ret map[string]json.RawMessage, err error) {
	if kid, e := json.Marshal(op.Opt); e != nil {
		err = e
	} else if pick, ok := op.GetChoice(); !ok {
		err = errutil.Fmt("unknown choice %T in %T", op.Opt, op)
	} else if len(pick) > 0 {
		ret = map[string]json.RawMessage{
			pick: kid,
		}
	}
	return
}

func (op *VariableType) GetChoice() (ret string, okay bool) {
	switch op.Opt.(type) {
	case nil:
		okay = true
	case *PrimitiveType:
		ret, okay = VariableType_Primitive, true
	case *ObjectType:
		ret, okay = VariableType_Object, true
	case *ExtType:
		ret, okay = VariableType_Ext, true
	}
	return
}

var Slots = []interface{}{
	(*StoryStatement)(nil),
	(*Testing)(nil),
}
var Slats = []composer.Composer{
	(*AbstractAction)(nil),
	(*ActionContext)(nil),
	(*ActionDecl)(nil),
	(*ActionName)(nil),
	(*ActionParams)(nil),
	(*Ana)(nil),
	(*AreAn)(nil),
	(*AreBeing)(nil),
	(*AreEither)(nil),
	(*Argument)(nil),
	(*Arguments)(nil),
	(*Aspect)(nil),
	(*AspectTraits)(nil),
	(*BoxedNumber)(nil),
	(*BoxedText)(nil),
	(*Certainties)(nil),
	(*Certainty)(nil),
	(*Comment)(nil),
	(*CommonAction)(nil),
	(*CountOf)(nil),
	(*CycleText)(nil),
	(*Determine)(nil),
	(*Determiner)(nil),
	(*EventBlock)(nil),
	(*EventHandler)(nil),
	(*EventName)(nil),
	(*EventPhase)(nil),
	(*EventTarget)(nil),
	(*ExtType)(nil),
	(*GrammarDecl)(nil),
	(*KindOfNoun)(nil),
	(*KindOfRelation)(nil),
	(*KindsOfAspect)(nil),
	(*KindsOfKind)(nil),
	(*KindsOfRecord)(nil),
	(*KindsPossessProperties)(nil),
	(*Lede)(nil),
	(*LocalDecl)(nil),
	(*LocalInit)(nil),
	(*Make)(nil),
	(*ManyToMany)(nil),
	(*ManyToOne)(nil),
	(*NamedNoun)(nil),
	(*NounAssignment)(nil),
	(*NounName)(nil),
	(*NounPhrase)(nil),
	(*NounRelation)(nil),
	(*NounStatement)(nil),
	(*NounTraits)(nil),
	(*NumberList)(nil),
	(*ObjectType)(nil),
	(*OneToMany)(nil),
	(*OneToOne)(nil),
	(*PairedAction)(nil),
	(*Paragraph)(nil),
	(*PatternActions)(nil),
	(*PatternDecl)(nil),
	(*PatternFlags)(nil),
	(*PatternLocals)(nil),
	(*PatternReturn)(nil),
	(*PatternRule)(nil),
	(*PatternRules)(nil),
	(*PatternType)(nil),
	(*PatternVariablesDecl)(nil),
	(*PatternVariablesTail)(nil),
	(*PluralKinds)(nil),
	(*PrimitiveType)(nil),
	(*PrimitiveValue)(nil),
	(*ProgramHook)(nil),
	(*Pronoun)(nil),
	(*Property)(nil),
	(*PropertyAspect)(nil),
	(*PropertyDecl)(nil),
	(*PropertyType)(nil),
	(*RecordList)(nil),
	(*RecordPlural)(nil),
	(*RecordSingular)(nil),
	(*RecordType)(nil),
	(*RecordsPossessProperties)(nil),
	(*RelationCardinality)(nil),
	(*RelativeToNoun)(nil),
	(*RenderTemplate)(nil),
	(*Send)(nil),
	(*ShuffleText)(nil),
	(*SingularKind)(nil),
	(*StoppingText)(nil),
	(*Story)(nil),
	(*Summary)(nil),
	(*Tail)(nil),
	(*TestName)(nil),
	(*TestOutput)(nil),
	(*TestRule)(nil),
	(*TestScene)(nil),
	(*TestStatement)(nil),
	(*TextList)(nil),
	(*Trait)(nil),
	(*TraitPhrase)(nil),
	(*VariableDecl)(nil),
	(*VariableType)(nil),
}
