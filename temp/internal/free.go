package internal

import (
	r "reflect"
	"strings"

	"git.sr.ht/~ionous/iffy"
	"git.sr.ht/~ionous/iffy/dl/composer"
	"git.sr.ht/~ionous/iffy/ephemera/reader"
	"git.sr.ht/~ionous/iffy/export/tag"
	"git.sr.ht/~ionous/iffy/lang"
)

// return the manually specified label, or an autogenerated one
// the first exposed field of a struct can be label-less ( a runin, anonymous )
func makeLabel(f *r.StructField, tags tag.StructTag, index int) (retLabel, retPool string) {
	label, _ := tags.Find("pb")
	if pool := strings.Split(label, "__"); len(pool) > 0 {
		// the left half is the label, the right the pool;
		// the label may be empty
		label = pool[0] //
		if len(pool) > 1 {
			retPool = pool[1]
		}
	}
	//
	if len(label) > 0 {
		retLabel = label
	} else if index > 0 {
		retLabel = lang.Underscore(f.Name)
	}
	return
}

type Indicies struct {
	pub, pri int
}

func (i *Indicies) makeIndex(f *r.StructField, tags tag.StructTag) (ret int) {
	if internal := tags.Exists("internal"); !internal {
		i.pub++
		ret = i.pub
	} else if f.Type == posType {
		ret = 12
	} else {
		ret = 13 + i.pri
		i.pri++
	}
	return
}

var posType = r.TypeOf((*reader.Position)(nil)).Elem()

func makeLede(c composer.Composer) (ret string) {
	spec := c.Compose()
	// assign lede
	if lede := spec.Lede; len(lede) > 0 {
		ret = lede
	} else if fl := spec.Fluent; fl != nil && len(fl.Name) > 0 {
		ret = fl.Name
	} else {
		ret = composer.SpecName(c)
	}
	return
}

func makeGroup(c composer.Composer) (ret string) {
	spec := c.Compose()
	// assign group
	if gn := spec.Group; len(gn) == 0 {
		ret = "misc"
	} else {
		ret = gn
	}
	return
}

func Desc(c composer.Composer) (ret string) {
	spec := c.Compose()
	return ClipDesc(spec.Desc)
}

func ClipDesc(d string) string {
	if i := strings.IndexRune(d, ':'); i >= 0 {
		d = strings.TrimSpace(d[i+1:])
	}
	d = strings.Join(strings.Fields(d), " ")
	if len(d) > 0 {
		d = strings.ToUpper(d[:1]) + d[1:]
		d = strings.Replace(d, "\n", " ", -1)
		d = strings.Replace(d, "\"", "'", -1)
	}
	if len(d) < 3 {
		d = ""
	}
	return d
}

func ImplementorsOf(slot interface{}) (ret []composer.Composer) {
	slotType := r.TypeOf(slot).Elem()
	for _, slats := range iffy.AllSlats {
		for _, slat := range slats {
			rtype := r.TypeOf(slat)
			if rtype.Implements(slotType) {
				ret = append(ret, slat)
			}
		}
	}
	return
}
