// Code generated by capnpc-go. DO NOT EDIT.

package auto

import (
	math "math"
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type Pos struct{ capnp.Struct }

// Pos_TypeID is the unique identifier for the type Pos.
const Pos_TypeID = 0x83be7cf8769eb08b

func NewPos(s *capnp.Segment) (Pos, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pos{st}, err
}

func NewRootPos(s *capnp.Segment) (Pos, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pos{st}, err
}

func ReadRootPos(msg *capnp.Message) (Pos, error) {
	root, err := msg.RootPtr()
	return Pos{root.Struct()}, err
}

func (s Pos) String() string {
	str, _ := text.Marshal(0x83be7cf8769eb08b, s.Struct)
	return str
}

func (s Pos) Source() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Pos) HasSource() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Pos) SetSource(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSource sets the source field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Pos) NewSource() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Pos) Offset() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s Pos) HasOffset() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Pos) SetOffset(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewOffset sets the offset field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Pos) NewOffset() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Pos_List is a list of Pos.
type Pos_List struct{ capnp.List }

// NewPos creates a new list of Pos.
func NewPos_List(s *capnp.Segment, sz int32) (Pos_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Pos_List{l}, err
}

func (s Pos_List) At(i int) Pos { return Pos{s.List.Struct(i)} }

func (s Pos_List) Set(i int, v Pos) error { return s.List.SetStruct(i, v.Struct) }

func (s Pos_List) String() string {
	str, _ := text.MarshalList(0x83be7cf8769eb08b, s.List)
	return str
}

// Pos_Promise is a wrapper for a Pos promised by a client call.
type Pos_Promise struct{ *capnp.Pipeline }

func (p Pos_Promise) Struct() (Pos, error) {
	s, err := p.Pipeline.Struct()
	return Pos{s}, err
}

func (p Pos_Promise) Source() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Pos_Promise) Offset() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Assignment struct{ capnp.Struct }

// Assignment_TypeID is the unique identifier for the type Assignment.
const Assignment_TypeID = 0xd82dd8f06a75baa5

func NewAssignment(s *capnp.Segment) (Assignment, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Assignment{st}, err
}

func NewRootAssignment(s *capnp.Segment) (Assignment, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Assignment{st}, err
}

func ReadRootAssignment(msg *capnp.Message) (Assignment, error) {
	root, err := msg.RootPtr()
	return Assignment{root.Struct()}, err
}

func (s Assignment) String() string {
	str, _ := text.Marshal(0xd82dd8f06a75baa5, s.Struct)
	return str
}

func (s Assignment) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s Assignment) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Assignment) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Assignment) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s Assignment) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Assignment_List is a list of Assignment.
type Assignment_List struct{ capnp.List }

// NewAssignment creates a new list of Assignment.
func NewAssignment_List(s *capnp.Segment, sz int32) (Assignment_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Assignment_List{l}, err
}

func (s Assignment_List) At(i int) Assignment { return Assignment{s.List.Struct(i)} }

func (s Assignment_List) Set(i int, v Assignment) error { return s.List.SetStruct(i, v.Struct) }

func (s Assignment_List) String() string {
	str, _ := text.MarshalList(0xd82dd8f06a75baa5, s.List)
	return str
}

// Assignment_Promise is a wrapper for a Assignment promised by a client call.
type Assignment_Promise struct{ *capnp.Pipeline }

func (p Assignment_Promise) Struct() (Assignment, error) {
	s, err := p.Pipeline.Struct()
	return Assignment{s}, err
}

func (p Assignment_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type AssignmentImpl struct{ capnp.Struct }
type AssignmentImpl_Which uint16

const (
	AssignmentImpl_Which_bool           AssignmentImpl_Which = 0
	AssignmentImpl_Which_getFrom        AssignmentImpl_Which = 1
	AssignmentImpl_Which_num            AssignmentImpl_Which = 2
	AssignmentImpl_Which_nums           AssignmentImpl_Which = 3
	AssignmentImpl_Which_rec            AssignmentImpl_Which = 4
	AssignmentImpl_Which_recs           AssignmentImpl_Which = 5
	AssignmentImpl_Which_renderArgs     AssignmentImpl_Which = 6
	AssignmentImpl_Which_renderRefFlags AssignmentImpl_Which = 7
	AssignmentImpl_Which_txt            AssignmentImpl_Which = 8
	AssignmentImpl_Which_txts           AssignmentImpl_Which = 9
	AssignmentImpl_Which_var            AssignmentImpl_Which = 10
)

func (w AssignmentImpl_Which) String() string {
	const s = "boolgetFromnumnumsrecrecsrenderArgsrenderRefFlagstxttxtsvar"
	switch w {
	case AssignmentImpl_Which_bool:
		return s[0:4]
	case AssignmentImpl_Which_getFrom:
		return s[4:11]
	case AssignmentImpl_Which_num:
		return s[11:14]
	case AssignmentImpl_Which_nums:
		return s[14:18]
	case AssignmentImpl_Which_rec:
		return s[18:21]
	case AssignmentImpl_Which_recs:
		return s[21:25]
	case AssignmentImpl_Which_renderArgs:
		return s[25:35]
	case AssignmentImpl_Which_renderRefFlags:
		return s[35:49]
	case AssignmentImpl_Which_txt:
		return s[49:52]
	case AssignmentImpl_Which_txts:
		return s[52:56]
	case AssignmentImpl_Which_var:
		return s[56:59]

	}
	return "AssignmentImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// AssignmentImpl_TypeID is the unique identifier for the type AssignmentImpl.
const AssignmentImpl_TypeID = 0xdd2907c256b45ff2

func NewAssignmentImpl(s *capnp.Segment) (AssignmentImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return AssignmentImpl{st}, err
}

func NewRootAssignmentImpl(s *capnp.Segment) (AssignmentImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return AssignmentImpl{st}, err
}

func ReadRootAssignmentImpl(msg *capnp.Message) (AssignmentImpl, error) {
	root, err := msg.RootPtr()
	return AssignmentImpl{root.Struct()}, err
}

func (s AssignmentImpl) String() string {
	str, _ := text.Marshal(0xdd2907c256b45ff2, s.Struct)
	return str
}

func (s AssignmentImpl) Which() AssignmentImpl_Which {
	return AssignmentImpl_Which(s.Struct.Uint16(0))
}
func (s AssignmentImpl) Bool() (FromBool, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != bool")
	}
	p, err := s.Struct.Ptr(0)
	return FromBool{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasBool() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetBool(v FromBool) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBool sets the bool field to a newly
// allocated FromBool struct, preferring placement in s's segment.
func (s AssignmentImpl) NewBool() (FromBool, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewFromBool(s.Struct.Segment())
	if err != nil {
		return FromBool{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) GetFrom() (GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return GetAtField{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetGetFrom(v GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated GetAtField struct, preferring placement in s's segment.
func (s AssignmentImpl) NewGetFrom() (GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewGetAtField(s.Struct.Segment())
	if err != nil {
		return GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Num() (FromNum, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != num")
	}
	p, err := s.Struct.Ptr(0)
	return FromNum{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasNum() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetNum(v FromNum) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated FromNum struct, preferring placement in s's segment.
func (s AssignmentImpl) NewNum() (FromNum, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewFromNum(s.Struct.Segment())
	if err != nil {
		return FromNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Nums() (FromNumbers, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != nums")
	}
	p, err := s.Struct.Ptr(0)
	return FromNumbers{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasNums() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetNums(v FromNumbers) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNums sets the nums field to a newly
// allocated FromNumbers struct, preferring placement in s's segment.
func (s AssignmentImpl) NewNums() (FromNumbers, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewFromNumbers(s.Struct.Segment())
	if err != nil {
		return FromNumbers{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Rec() (FromRecord, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != rec")
	}
	p, err := s.Struct.Ptr(0)
	return FromRecord{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasRec() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetRec(v FromRecord) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRec sets the rec field to a newly
// allocated FromRecord struct, preferring placement in s's segment.
func (s AssignmentImpl) NewRec() (FromRecord, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewFromRecord(s.Struct.Segment())
	if err != nil {
		return FromRecord{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Recs() (FromRecords, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != recs")
	}
	p, err := s.Struct.Ptr(0)
	return FromRecords{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasRecs() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetRecs(v FromRecords) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRecs sets the recs field to a newly
// allocated FromRecords struct, preferring placement in s's segment.
func (s AssignmentImpl) NewRecs() (FromRecords, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewFromRecords(s.Struct.Segment())
	if err != nil {
		return FromRecords{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s AssignmentImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) RenderRefFlags() (RenderRef, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return RenderRef{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetRenderRefFlags(v RenderRef) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated RenderRef struct, preferring placement in s's segment.
func (s AssignmentImpl) NewRenderRefFlags() (RenderRef, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewRenderRef(s.Struct.Segment())
	if err != nil {
		return RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Txt() (FromText, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != txt")
	}
	p, err := s.Struct.Ptr(0)
	return FromText{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasTxt() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetTxt(v FromText) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxt sets the txt field to a newly
// allocated FromText struct, preferring placement in s's segment.
func (s AssignmentImpl) NewTxt() (FromText, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewFromText(s.Struct.Segment())
	if err != nil {
		return FromText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Txts() (FromTexts, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != txts")
	}
	p, err := s.Struct.Ptr(0)
	return FromTexts{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasTxts() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetTxts(v FromTexts) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxts sets the txts field to a newly
// allocated FromTexts struct, preferring placement in s's segment.
func (s AssignmentImpl) NewTxts() (FromTexts, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := NewFromTexts(s.Struct.Segment())
	if err != nil {
		return FromTexts{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s AssignmentImpl) Var() (Var, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return Var{Struct: p.Struct()}, err
}

func (s AssignmentImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AssignmentImpl) SetVar(v Var) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated Var struct, preferring placement in s's segment.
func (s AssignmentImpl) NewVar() (Var, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := NewVar(s.Struct.Segment())
	if err != nil {
		return Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// AssignmentImpl_List is a list of AssignmentImpl.
type AssignmentImpl_List struct{ capnp.List }

// NewAssignmentImpl creates a new list of AssignmentImpl.
func NewAssignmentImpl_List(s *capnp.Segment, sz int32) (AssignmentImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return AssignmentImpl_List{l}, err
}

func (s AssignmentImpl_List) At(i int) AssignmentImpl { return AssignmentImpl{s.List.Struct(i)} }

func (s AssignmentImpl_List) Set(i int, v AssignmentImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s AssignmentImpl_List) String() string {
	str, _ := text.MarshalList(0xdd2907c256b45ff2, s.List)
	return str
}

// AssignmentImpl_Promise is a wrapper for a AssignmentImpl promised by a client call.
type AssignmentImpl_Promise struct{ *capnp.Pipeline }

func (p AssignmentImpl_Promise) Struct() (AssignmentImpl, error) {
	s, err := p.Pipeline.Struct()
	return AssignmentImpl{s}, err
}

func (p AssignmentImpl_Promise) Bool() FromBool_Promise {
	return FromBool_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) GetFrom() GetAtField_Promise {
	return GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Num() FromNum_Promise {
	return FromNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Nums() FromNumbers_Promise {
	return FromNumbers_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Rec() FromRecord_Promise {
	return FromRecord_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Recs() FromRecords_Promise {
	return FromRecords_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) RenderRefFlags() RenderRef_Promise {
	return RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Txt() FromText_Promise {
	return FromText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Txts() FromTexts_Promise {
	return FromTexts_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p AssignmentImpl_Promise) Var() Var_Promise {
	return Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type BoolEval struct{ capnp.Struct }

// BoolEval_TypeID is the unique identifier for the type BoolEval.
const BoolEval_TypeID = 0xb39c483c21864f2b

func NewBoolEval(s *capnp.Segment) (BoolEval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return BoolEval{st}, err
}

func NewRootBoolEval(s *capnp.Segment) (BoolEval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return BoolEval{st}, err
}

func ReadRootBoolEval(msg *capnp.Message) (BoolEval, error) {
	root, err := msg.RootPtr()
	return BoolEval{root.Struct()}, err
}

func (s BoolEval) String() string {
	str, _ := text.Marshal(0xb39c483c21864f2b, s.Struct)
	return str
}

func (s BoolEval) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s BoolEval) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEval) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s BoolEval) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s BoolEval) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// BoolEval_List is a list of BoolEval.
type BoolEval_List struct{ capnp.List }

// NewBoolEval creates a new list of BoolEval.
func NewBoolEval_List(s *capnp.Segment, sz int32) (BoolEval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return BoolEval_List{l}, err
}

func (s BoolEval_List) At(i int) BoolEval { return BoolEval{s.List.Struct(i)} }

func (s BoolEval_List) Set(i int, v BoolEval) error { return s.List.SetStruct(i, v.Struct) }

func (s BoolEval_List) String() string {
	str, _ := text.MarshalList(0xb39c483c21864f2b, s.List)
	return str
}

// BoolEval_Promise is a wrapper for a BoolEval promised by a client call.
type BoolEval_Promise struct{ *capnp.Pipeline }

func (p BoolEval_Promise) Struct() (BoolEval, error) {
	s, err := p.Pipeline.Struct()
	return BoolEval{s}, err
}

func (p BoolEval_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type BoolEvalImpl struct{ capnp.Struct }
type BoolEvalImpl_Which uint16

const (
	BoolEvalImpl_Which_allOf           BoolEvalImpl_Which = 0
	BoolEvalImpl_Which_always          BoolEvalImpl_Which = 1
	BoolEvalImpl_Which_anyOf           BoolEvalImpl_Which = 2
	BoolEvalImpl_Which_bool            BoolEvalImpl_Which = 3
	BoolEvalImpl_Which_cmpIsNum        BoolEvalImpl_Which = 4
	BoolEvalImpl_Which_cmpIsTxt        BoolEvalImpl_Which = 5
	BoolEvalImpl_Which_containsPart    BoolEvalImpl_Which = 6
	BoolEvalImpl_Which_countOfTrigger  BoolEvalImpl_Which = 7
	BoolEvalImpl_Which_determineArgs   BoolEvalImpl_Which = 8
	BoolEvalImpl_Which_during          BoolEvalImpl_Which = 9
	BoolEvalImpl_Which_findList        BoolEvalImpl_Which = 10
	BoolEvalImpl_Which_getObjTrait     BoolEvalImpl_Which = 11
	BoolEvalImpl_Which_getFrom         BoolEvalImpl_Which = 12
	BoolEvalImpl_Which_hasDominion     BoolEvalImpl_Which = 13
	BoolEvalImpl_Which_isEmpty         BoolEvalImpl_Which = 14
	BoolEvalImpl_Which_isValid         BoolEvalImpl_Which = 15
	BoolEvalImpl_Which_kindOfIs        BoolEvalImpl_Which = 16
	BoolEvalImpl_Which_kindOfIsExactly BoolEvalImpl_Which = 17
	BoolEvalImpl_Which_matchesTo       BoolEvalImpl_Which = 18
	BoolEvalImpl_Which_not             BoolEvalImpl_Which = 19
	BoolEvalImpl_Which_renderArgs      BoolEvalImpl_Which = 20
	BoolEvalImpl_Which_renderRefFlags  BoolEvalImpl_Which = 21
	BoolEvalImpl_Which_sendToArgs      BoolEvalImpl_Which = 22
	BoolEvalImpl_Which_var             BoolEvalImpl_Which = 23
)

func (w BoolEvalImpl_Which) String() string {
	const s = "allOfalwaysanyOfboolcmpIsNumcmpIsTxtcontainsPartcountOfTriggerdetermineArgsduringfindListgetObjTraitgetFromhasDominionisEmptyisValidkindOfIskindOfIsExactlymatchesTonotrenderArgsrenderRefFlagssendToArgsvar"
	switch w {
	case BoolEvalImpl_Which_allOf:
		return s[0:5]
	case BoolEvalImpl_Which_always:
		return s[5:11]
	case BoolEvalImpl_Which_anyOf:
		return s[11:16]
	case BoolEvalImpl_Which_bool:
		return s[16:20]
	case BoolEvalImpl_Which_cmpIsNum:
		return s[20:28]
	case BoolEvalImpl_Which_cmpIsTxt:
		return s[28:36]
	case BoolEvalImpl_Which_containsPart:
		return s[36:48]
	case BoolEvalImpl_Which_countOfTrigger:
		return s[48:62]
	case BoolEvalImpl_Which_determineArgs:
		return s[62:75]
	case BoolEvalImpl_Which_during:
		return s[75:81]
	case BoolEvalImpl_Which_findList:
		return s[81:89]
	case BoolEvalImpl_Which_getObjTrait:
		return s[89:100]
	case BoolEvalImpl_Which_getFrom:
		return s[100:107]
	case BoolEvalImpl_Which_hasDominion:
		return s[107:118]
	case BoolEvalImpl_Which_isEmpty:
		return s[118:125]
	case BoolEvalImpl_Which_isValid:
		return s[125:132]
	case BoolEvalImpl_Which_kindOfIs:
		return s[132:140]
	case BoolEvalImpl_Which_kindOfIsExactly:
		return s[140:155]
	case BoolEvalImpl_Which_matchesTo:
		return s[155:164]
	case BoolEvalImpl_Which_not:
		return s[164:167]
	case BoolEvalImpl_Which_renderArgs:
		return s[167:177]
	case BoolEvalImpl_Which_renderRefFlags:
		return s[177:191]
	case BoolEvalImpl_Which_sendToArgs:
		return s[191:201]
	case BoolEvalImpl_Which_var:
		return s[201:204]

	}
	return "BoolEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// BoolEvalImpl_TypeID is the unique identifier for the type BoolEvalImpl.
const BoolEvalImpl_TypeID = 0xb9ac809d387e2655

func NewBoolEvalImpl(s *capnp.Segment) (BoolEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return BoolEvalImpl{st}, err
}

func NewRootBoolEvalImpl(s *capnp.Segment) (BoolEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return BoolEvalImpl{st}, err
}

func ReadRootBoolEvalImpl(msg *capnp.Message) (BoolEvalImpl, error) {
	root, err := msg.RootPtr()
	return BoolEvalImpl{root.Struct()}, err
}

func (s BoolEvalImpl) String() string {
	str, _ := text.Marshal(0xb9ac809d387e2655, s.Struct)
	return str
}

func (s BoolEvalImpl) Which() BoolEvalImpl_Which {
	return BoolEvalImpl_Which(s.Struct.Uint16(0))
}
func (s BoolEvalImpl) AllOf() (AllTrue, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != allOf")
	}
	p, err := s.Struct.Ptr(0)
	return AllTrue{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasAllOf() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetAllOf(v AllTrue) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAllOf sets the allOf field to a newly
// allocated AllTrue struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewAllOf() (AllTrue, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewAllTrue(s.Struct.Segment())
	if err != nil {
		return AllTrue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) Always() (Always, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != always")
	}
	p, err := s.Struct.Ptr(0)
	return Always{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasAlways() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetAlways(v Always) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAlways sets the always field to a newly
// allocated Always struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewAlways() (Always, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewAlways(s.Struct.Segment())
	if err != nil {
		return Always{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) AnyOf() (AnyTrue, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != anyOf")
	}
	p, err := s.Struct.Ptr(0)
	return AnyTrue{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasAnyOf() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetAnyOf(v AnyTrue) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAnyOf sets the anyOf field to a newly
// allocated AnyTrue struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewAnyOf() (AnyTrue, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewAnyTrue(s.Struct.Segment())
	if err != nil {
		return AnyTrue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) Bool() (Bool, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != bool")
	}
	p, err := s.Struct.Ptr(0)
	return Bool{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasBool() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetBool(v Bool) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBool sets the bool field to a newly
// allocated Bool struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewBool() (Bool, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewBool(s.Struct.Segment())
	if err != nil {
		return Bool{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) CmpIsNum() (CompareNum, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != cmpIsNum")
	}
	p, err := s.Struct.Ptr(0)
	return CompareNum{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasCmpIsNum() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetCmpIsNum(v CompareNum) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCmpIsNum sets the cmpIsNum field to a newly
// allocated CompareNum struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewCmpIsNum() (CompareNum, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewCompareNum(s.Struct.Segment())
	if err != nil {
		return CompareNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) CmpIsTxt() (CompareText, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != cmpIsTxt")
	}
	p, err := s.Struct.Ptr(0)
	return CompareText{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasCmpIsTxt() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetCmpIsTxt(v CompareText) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCmpIsTxt sets the cmpIsTxt field to a newly
// allocated CompareText struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewCmpIsTxt() (CompareText, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewCompareText(s.Struct.Segment())
	if err != nil {
		return CompareText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) ContainsPart() (Includes, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != containsPart")
	}
	p, err := s.Struct.Ptr(0)
	return Includes{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasContainsPart() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetContainsPart(v Includes) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewContainsPart sets the containsPart field to a newly
// allocated Includes struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewContainsPart() (Includes, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewIncludes(s.Struct.Segment())
	if err != nil {
		return Includes{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) CountOfTrigger() (CountOf, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != countOfTrigger")
	}
	p, err := s.Struct.Ptr(0)
	return CountOf{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasCountOfTrigger() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetCountOfTrigger(v CountOf) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCountOfTrigger sets the countOfTrigger field to a newly
// allocated CountOf struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewCountOfTrigger() (CountOf, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewCountOf(s.Struct.Segment())
	if err != nil {
		return CountOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) DetermineArgs() (Determine, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Determine{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetDetermineArgs(v Determine) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated Determine struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewDetermineArgs() (Determine, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewDetermine(s.Struct.Segment())
	if err != nil {
		return Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) During() (During, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != during")
	}
	p, err := s.Struct.Ptr(0)
	return During{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasDuring() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetDuring(v During) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDuring sets the during field to a newly
// allocated During struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewDuring() (During, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := NewDuring(s.Struct.Segment())
	if err != nil {
		return During{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) FindList() (Find, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != findList")
	}
	p, err := s.Struct.Ptr(0)
	return Find{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasFindList() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetFindList(v Find) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFindList sets the findList field to a newly
// allocated Find struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewFindList() (Find, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := NewFind(s.Struct.Segment())
	if err != nil {
		return Find{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) GetObjTrait() (HasTrait, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != getObjTrait")
	}
	p, err := s.Struct.Ptr(0)
	return HasTrait{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasGetObjTrait() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetGetObjTrait(v HasTrait) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetObjTrait sets the getObjTrait field to a newly
// allocated HasTrait struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewGetObjTrait() (HasTrait, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := NewHasTrait(s.Struct.Segment())
	if err != nil {
		return HasTrait{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) GetFrom() (GetAtField, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return GetAtField{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetGetFrom(v GetAtField) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated GetAtField struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewGetFrom() (GetAtField, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := NewGetAtField(s.Struct.Segment())
	if err != nil {
		return GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) HasDominion() (HasDominion, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != hasDominion")
	}
	p, err := s.Struct.Ptr(0)
	return HasDominion{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasHasDominion() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetHasDominion(v HasDominion) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewHasDominion sets the hasDominion field to a newly
// allocated HasDominion struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewHasDominion() (HasDominion, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := NewHasDominion(s.Struct.Segment())
	if err != nil {
		return HasDominion{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) IsEmpty() (IsEmpty, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != isEmpty")
	}
	p, err := s.Struct.Ptr(0)
	return IsEmpty{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasIsEmpty() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetIsEmpty(v IsEmpty) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIsEmpty sets the isEmpty field to a newly
// allocated IsEmpty struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewIsEmpty() (IsEmpty, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := NewIsEmpty(s.Struct.Segment())
	if err != nil {
		return IsEmpty{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) IsValid() (ObjectExists, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != isValid")
	}
	p, err := s.Struct.Ptr(0)
	return ObjectExists{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasIsValid() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetIsValid(v ObjectExists) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIsValid sets the isValid field to a newly
// allocated ObjectExists struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewIsValid() (ObjectExists, error) {
	s.Struct.SetUint16(0, 15)
	ss, err := NewObjectExists(s.Struct.Segment())
	if err != nil {
		return ObjectExists{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) KindOfIs() (IsKindOf, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != kindOfIs")
	}
	p, err := s.Struct.Ptr(0)
	return IsKindOf{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasKindOfIs() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetKindOfIs(v IsKindOf) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKindOfIs sets the kindOfIs field to a newly
// allocated IsKindOf struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewKindOfIs() (IsKindOf, error) {
	s.Struct.SetUint16(0, 16)
	ss, err := NewIsKindOf(s.Struct.Segment())
	if err != nil {
		return IsKindOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) KindOfIsExactly() (IsExactKindOf, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != kindOfIsExactly")
	}
	p, err := s.Struct.Ptr(0)
	return IsExactKindOf{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasKindOfIsExactly() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetKindOfIsExactly(v IsExactKindOf) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKindOfIsExactly sets the kindOfIsExactly field to a newly
// allocated IsExactKindOf struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewKindOfIsExactly() (IsExactKindOf, error) {
	s.Struct.SetUint16(0, 17)
	ss, err := NewIsExactKindOf(s.Struct.Segment())
	if err != nil {
		return IsExactKindOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) MatchesTo() (Matches, error) {
	if s.Struct.Uint16(0) != 18 {
		panic("Which() != matchesTo")
	}
	p, err := s.Struct.Ptr(0)
	return Matches{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasMatchesTo() bool {
	if s.Struct.Uint16(0) != 18 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetMatchesTo(v Matches) error {
	s.Struct.SetUint16(0, 18)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMatchesTo sets the matchesTo field to a newly
// allocated Matches struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewMatchesTo() (Matches, error) {
	s.Struct.SetUint16(0, 18)
	ss, err := NewMatches(s.Struct.Segment())
	if err != nil {
		return Matches{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) Not() (IsNotTrue, error) {
	if s.Struct.Uint16(0) != 19 {
		panic("Which() != not")
	}
	p, err := s.Struct.Ptr(0)
	return IsNotTrue{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasNot() bool {
	if s.Struct.Uint16(0) != 19 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetNot(v IsNotTrue) error {
	s.Struct.SetUint16(0, 19)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNot sets the not field to a newly
// allocated IsNotTrue struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewNot() (IsNotTrue, error) {
	s.Struct.SetUint16(0, 19)
	ss, err := NewIsNotTrue(s.Struct.Segment())
	if err != nil {
		return IsNotTrue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 20 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 20 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 20)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 20)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) RenderRefFlags() (RenderRef, error) {
	if s.Struct.Uint16(0) != 21 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return RenderRef{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 21 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetRenderRefFlags(v RenderRef) error {
	s.Struct.SetUint16(0, 21)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated RenderRef struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewRenderRefFlags() (RenderRef, error) {
	s.Struct.SetUint16(0, 21)
	ss, err := NewRenderRef(s.Struct.Segment())
	if err != nil {
		return RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) SendToArgs() (Send, error) {
	if s.Struct.Uint16(0) != 22 {
		panic("Which() != sendToArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Send{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasSendToArgs() bool {
	if s.Struct.Uint16(0) != 22 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetSendToArgs(v Send) error {
	s.Struct.SetUint16(0, 22)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSendToArgs sets the sendToArgs field to a newly
// allocated Send struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewSendToArgs() (Send, error) {
	s.Struct.SetUint16(0, 22)
	ss, err := NewSend(s.Struct.Segment())
	if err != nil {
		return Send{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BoolEvalImpl) Var() (Var, error) {
	if s.Struct.Uint16(0) != 23 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return Var{Struct: p.Struct()}, err
}

func (s BoolEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 23 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BoolEvalImpl) SetVar(v Var) error {
	s.Struct.SetUint16(0, 23)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated Var struct, preferring placement in s's segment.
func (s BoolEvalImpl) NewVar() (Var, error) {
	s.Struct.SetUint16(0, 23)
	ss, err := NewVar(s.Struct.Segment())
	if err != nil {
		return Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// BoolEvalImpl_List is a list of BoolEvalImpl.
type BoolEvalImpl_List struct{ capnp.List }

// NewBoolEvalImpl creates a new list of BoolEvalImpl.
func NewBoolEvalImpl_List(s *capnp.Segment, sz int32) (BoolEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return BoolEvalImpl_List{l}, err
}

func (s BoolEvalImpl_List) At(i int) BoolEvalImpl { return BoolEvalImpl{s.List.Struct(i)} }

func (s BoolEvalImpl_List) Set(i int, v BoolEvalImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s BoolEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xb9ac809d387e2655, s.List)
	return str
}

// BoolEvalImpl_Promise is a wrapper for a BoolEvalImpl promised by a client call.
type BoolEvalImpl_Promise struct{ *capnp.Pipeline }

func (p BoolEvalImpl_Promise) Struct() (BoolEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return BoolEvalImpl{s}, err
}

func (p BoolEvalImpl_Promise) AllOf() AllTrue_Promise {
	return AllTrue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) Always() Always_Promise {
	return Always_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) AnyOf() AnyTrue_Promise {
	return AnyTrue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) Bool() Bool_Promise {
	return Bool_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) CmpIsNum() CompareNum_Promise {
	return CompareNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) CmpIsTxt() CompareText_Promise {
	return CompareText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) ContainsPart() Includes_Promise {
	return Includes_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) CountOfTrigger() CountOf_Promise {
	return CountOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) DetermineArgs() Determine_Promise {
	return Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) During() During_Promise {
	return During_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) FindList() Find_Promise {
	return Find_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) GetObjTrait() HasTrait_Promise {
	return HasTrait_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) GetFrom() GetAtField_Promise {
	return GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) HasDominion() HasDominion_Promise {
	return HasDominion_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) IsEmpty() IsEmpty_Promise {
	return IsEmpty_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) IsValid() ObjectExists_Promise {
	return ObjectExists_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) KindOfIs() IsKindOf_Promise {
	return IsKindOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) KindOfIsExactly() IsExactKindOf_Promise {
	return IsExactKindOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) MatchesTo() Matches_Promise {
	return Matches_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) Not() IsNotTrue_Promise {
	return IsNotTrue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) RenderRefFlags() RenderRef_Promise {
	return RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) SendToArgs() Send_Promise {
	return Send_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BoolEvalImpl_Promise) Var() Var_Promise {
	return Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Brancher struct{ capnp.Struct }

// Brancher_TypeID is the unique identifier for the type Brancher.
const Brancher_TypeID = 0xc492499254cc9e46

func NewBrancher(s *capnp.Segment) (Brancher, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Brancher{st}, err
}

func NewRootBrancher(s *capnp.Segment) (Brancher, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Brancher{st}, err
}

func ReadRootBrancher(msg *capnp.Message) (Brancher, error) {
	root, err := msg.RootPtr()
	return Brancher{root.Struct()}, err
}

func (s Brancher) String() string {
	str, _ := text.Marshal(0xc492499254cc9e46, s.Struct)
	return str
}

func (s Brancher) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s Brancher) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Brancher) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Brancher) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s Brancher) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Brancher_List is a list of Brancher.
type Brancher_List struct{ capnp.List }

// NewBrancher creates a new list of Brancher.
func NewBrancher_List(s *capnp.Segment, sz int32) (Brancher_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Brancher_List{l}, err
}

func (s Brancher_List) At(i int) Brancher { return Brancher{s.List.Struct(i)} }

func (s Brancher_List) Set(i int, v Brancher) error { return s.List.SetStruct(i, v.Struct) }

func (s Brancher_List) String() string {
	str, _ := text.MarshalList(0xc492499254cc9e46, s.List)
	return str
}

// Brancher_Promise is a wrapper for a Brancher promised by a client call.
type Brancher_Promise struct{ *capnp.Pipeline }

func (p Brancher_Promise) Struct() (Brancher, error) {
	s, err := p.Pipeline.Struct()
	return Brancher{s}, err
}

func (p Brancher_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type BrancherImpl struct{ capnp.Struct }
type BrancherImpl_Which uint16

const (
	BrancherImpl_Which_elseDoDo            BrancherImpl_Which = 0
	BrancherImpl_Which_elseIfDo            BrancherImpl_Which = 1
	BrancherImpl_Which_elseIfDoElse        BrancherImpl_Which = 2
	BrancherImpl_Which_elseIfFromAndDo     BrancherImpl_Which = 3
	BrancherImpl_Which_elseIfFromAndDoElse BrancherImpl_Which = 4
	BrancherImpl_Which_ifDo                BrancherImpl_Which = 5
	BrancherImpl_Which_ifDoElse            BrancherImpl_Which = 6
	BrancherImpl_Which_ifFromAndDo         BrancherImpl_Which = 7
	BrancherImpl_Which_ifFromAndDoElse     BrancherImpl_Which = 8
)

func (w BrancherImpl_Which) String() string {
	const s = "elseDoDoelseIfDoelseIfDoElseelseIfFromAndDoelseIfFromAndDoElseifDoifDoElseifFromAndDoifFromAndDoElse"
	switch w {
	case BrancherImpl_Which_elseDoDo:
		return s[0:8]
	case BrancherImpl_Which_elseIfDo:
		return s[8:16]
	case BrancherImpl_Which_elseIfDoElse:
		return s[16:28]
	case BrancherImpl_Which_elseIfFromAndDo:
		return s[28:43]
	case BrancherImpl_Which_elseIfFromAndDoElse:
		return s[43:62]
	case BrancherImpl_Which_ifDo:
		return s[62:66]
	case BrancherImpl_Which_ifDoElse:
		return s[66:74]
	case BrancherImpl_Which_ifFromAndDo:
		return s[74:85]
	case BrancherImpl_Which_ifFromAndDoElse:
		return s[85:100]

	}
	return "BrancherImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// BrancherImpl_TypeID is the unique identifier for the type BrancherImpl.
const BrancherImpl_TypeID = 0xbc62d4b545dce96a

func NewBrancherImpl(s *capnp.Segment) (BrancherImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return BrancherImpl{st}, err
}

func NewRootBrancherImpl(s *capnp.Segment) (BrancherImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return BrancherImpl{st}, err
}

func ReadRootBrancherImpl(msg *capnp.Message) (BrancherImpl, error) {
	root, err := msg.RootPtr()
	return BrancherImpl{root.Struct()}, err
}

func (s BrancherImpl) String() string {
	str, _ := text.Marshal(0xbc62d4b545dce96a, s.Struct)
	return str
}

func (s BrancherImpl) Which() BrancherImpl_Which {
	return BrancherImpl_Which(s.Struct.Uint16(0))
}
func (s BrancherImpl) ElseDoDo() (ChooseNothingElse, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != elseDoDo")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseNothingElse{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseDoDo() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseDoDo(v ChooseNothingElse) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseDoDo sets the elseDoDo field to a newly
// allocated ChooseNothingElse struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseDoDo() (ChooseNothingElse, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewChooseNothingElse(s.Struct.Segment())
	if err != nil {
		return ChooseNothingElse{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) ElseIfDo() (ChooseMore, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != elseIfDo")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseMore{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseIfDo() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseIfDo(v ChooseMore) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseIfDo sets the elseIfDo field to a newly
// allocated ChooseMore struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseIfDo() (ChooseMore, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewChooseMore(s.Struct.Segment())
	if err != nil {
		return ChooseMore{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) ElseIfDoElse() (ChooseMore, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != elseIfDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseMore{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseIfDoElse() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseIfDoElse(v ChooseMore) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseIfDoElse sets the elseIfDoElse field to a newly
// allocated ChooseMore struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseIfDoElse() (ChooseMore, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewChooseMore(s.Struct.Segment())
	if err != nil {
		return ChooseMore{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) ElseIfFromAndDo() (ChooseMoreValue, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != elseIfFromAndDo")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseMoreValue{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseIfFromAndDo() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseIfFromAndDo(v ChooseMoreValue) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseIfFromAndDo sets the elseIfFromAndDo field to a newly
// allocated ChooseMoreValue struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseIfFromAndDo() (ChooseMoreValue, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewChooseMoreValue(s.Struct.Segment())
	if err != nil {
		return ChooseMoreValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) ElseIfFromAndDoElse() (ChooseMoreValue, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != elseIfFromAndDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseMoreValue{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasElseIfFromAndDoElse() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetElseIfFromAndDoElse(v ChooseMoreValue) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewElseIfFromAndDoElse sets the elseIfFromAndDoElse field to a newly
// allocated ChooseMoreValue struct, preferring placement in s's segment.
func (s BrancherImpl) NewElseIfFromAndDoElse() (ChooseMoreValue, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewChooseMoreValue(s.Struct.Segment())
	if err != nil {
		return ChooseMoreValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) IfDo() (ChooseAction, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != ifDo")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseAction{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasIfDo() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetIfDo(v ChooseAction) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfDo sets the ifDo field to a newly
// allocated ChooseAction struct, preferring placement in s's segment.
func (s BrancherImpl) NewIfDo() (ChooseAction, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewChooseAction(s.Struct.Segment())
	if err != nil {
		return ChooseAction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) IfDoElse() (ChooseAction, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != ifDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseAction{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasIfDoElse() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetIfDoElse(v ChooseAction) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfDoElse sets the ifDoElse field to a newly
// allocated ChooseAction struct, preferring placement in s's segment.
func (s BrancherImpl) NewIfDoElse() (ChooseAction, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewChooseAction(s.Struct.Segment())
	if err != nil {
		return ChooseAction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) IfFromAndDo() (ChooseValue, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != ifFromAndDo")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseValue{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasIfFromAndDo() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetIfFromAndDo(v ChooseValue) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfFromAndDo sets the ifFromAndDo field to a newly
// allocated ChooseValue struct, preferring placement in s's segment.
func (s BrancherImpl) NewIfFromAndDo() (ChooseValue, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewChooseValue(s.Struct.Segment())
	if err != nil {
		return ChooseValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s BrancherImpl) IfFromAndDoElse() (ChooseValue, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != ifFromAndDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseValue{Struct: p.Struct()}, err
}

func (s BrancherImpl) HasIfFromAndDoElse() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s BrancherImpl) SetIfFromAndDoElse(v ChooseValue) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfFromAndDoElse sets the ifFromAndDoElse field to a newly
// allocated ChooseValue struct, preferring placement in s's segment.
func (s BrancherImpl) NewIfFromAndDoElse() (ChooseValue, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewChooseValue(s.Struct.Segment())
	if err != nil {
		return ChooseValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// BrancherImpl_List is a list of BrancherImpl.
type BrancherImpl_List struct{ capnp.List }

// NewBrancherImpl creates a new list of BrancherImpl.
func NewBrancherImpl_List(s *capnp.Segment, sz int32) (BrancherImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return BrancherImpl_List{l}, err
}

func (s BrancherImpl_List) At(i int) BrancherImpl { return BrancherImpl{s.List.Struct(i)} }

func (s BrancherImpl_List) Set(i int, v BrancherImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s BrancherImpl_List) String() string {
	str, _ := text.MarshalList(0xbc62d4b545dce96a, s.List)
	return str
}

// BrancherImpl_Promise is a wrapper for a BrancherImpl promised by a client call.
type BrancherImpl_Promise struct{ *capnp.Pipeline }

func (p BrancherImpl_Promise) Struct() (BrancherImpl, error) {
	s, err := p.Pipeline.Struct()
	return BrancherImpl{s}, err
}

func (p BrancherImpl_Promise) ElseDoDo() ChooseNothingElse_Promise {
	return ChooseNothingElse_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) ElseIfDo() ChooseMore_Promise {
	return ChooseMore_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) ElseIfDoElse() ChooseMore_Promise {
	return ChooseMore_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) ElseIfFromAndDo() ChooseMoreValue_Promise {
	return ChooseMoreValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) ElseIfFromAndDoElse() ChooseMoreValue_Promise {
	return ChooseMoreValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) IfDo() ChooseAction_Promise {
	return ChooseAction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) IfDoElse() ChooseAction_Promise {
	return ChooseAction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) IfFromAndDo() ChooseValue_Promise {
	return ChooseValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p BrancherImpl_Promise) IfFromAndDoElse() ChooseValue_Promise {
	return ChooseValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Comparator struct{ capnp.Struct }

// Comparator_TypeID is the unique identifier for the type Comparator.
const Comparator_TypeID = 0x81e4d9ea503dc431

func NewComparator(s *capnp.Segment) (Comparator, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Comparator{st}, err
}

func NewRootComparator(s *capnp.Segment) (Comparator, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Comparator{st}, err
}

func ReadRootComparator(msg *capnp.Message) (Comparator, error) {
	root, err := msg.RootPtr()
	return Comparator{root.Struct()}, err
}

func (s Comparator) String() string {
	str, _ := text.Marshal(0x81e4d9ea503dc431, s.Struct)
	return str
}

func (s Comparator) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s Comparator) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Comparator) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Comparator) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s Comparator) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Comparator_List is a list of Comparator.
type Comparator_List struct{ capnp.List }

// NewComparator creates a new list of Comparator.
func NewComparator_List(s *capnp.Segment, sz int32) (Comparator_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Comparator_List{l}, err
}

func (s Comparator_List) At(i int) Comparator { return Comparator{s.List.Struct(i)} }

func (s Comparator_List) Set(i int, v Comparator) error { return s.List.SetStruct(i, v.Struct) }

func (s Comparator_List) String() string {
	str, _ := text.MarshalList(0x81e4d9ea503dc431, s.List)
	return str
}

// Comparator_Promise is a wrapper for a Comparator promised by a client call.
type Comparator_Promise struct{ *capnp.Pipeline }

func (p Comparator_Promise) Struct() (Comparator, error) {
	s, err := p.Pipeline.Struct()
	return Comparator{s}, err
}

func (p Comparator_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type ComparatorImpl struct{ capnp.Struct }
type ComparatorImpl_Which uint16

const (
	ComparatorImpl_Which_atLeast     ComparatorImpl_Which = 0
	ComparatorImpl_Which_atMost      ComparatorImpl_Which = 1
	ComparatorImpl_Which_equalTo     ComparatorImpl_Which = 2
	ComparatorImpl_Which_greaterThan ComparatorImpl_Which = 3
	ComparatorImpl_Which_lessThan    ComparatorImpl_Which = 4
	ComparatorImpl_Which_otherThan   ComparatorImpl_Which = 5
)

func (w ComparatorImpl_Which) String() string {
	const s = "atLeastatMostequalTogreaterThanlessThanotherThan"
	switch w {
	case ComparatorImpl_Which_atLeast:
		return s[0:7]
	case ComparatorImpl_Which_atMost:
		return s[7:13]
	case ComparatorImpl_Which_equalTo:
		return s[13:20]
	case ComparatorImpl_Which_greaterThan:
		return s[20:31]
	case ComparatorImpl_Which_lessThan:
		return s[31:39]
	case ComparatorImpl_Which_otherThan:
		return s[39:48]

	}
	return "ComparatorImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ComparatorImpl_TypeID is the unique identifier for the type ComparatorImpl.
const ComparatorImpl_TypeID = 0xc2fdfeaf7471fcf6

func NewComparatorImpl(s *capnp.Segment) (ComparatorImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ComparatorImpl{st}, err
}

func NewRootComparatorImpl(s *capnp.Segment) (ComparatorImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ComparatorImpl{st}, err
}

func ReadRootComparatorImpl(msg *capnp.Message) (ComparatorImpl, error) {
	root, err := msg.RootPtr()
	return ComparatorImpl{root.Struct()}, err
}

func (s ComparatorImpl) String() string {
	str, _ := text.Marshal(0xc2fdfeaf7471fcf6, s.Struct)
	return str
}

func (s ComparatorImpl) Which() ComparatorImpl_Which {
	return ComparatorImpl_Which(s.Struct.Uint16(0))
}
func (s ComparatorImpl) AtLeast() (GreaterOrEqual, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != atLeast")
	}
	p, err := s.Struct.Ptr(0)
	return GreaterOrEqual{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasAtLeast() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetAtLeast(v GreaterOrEqual) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAtLeast sets the atLeast field to a newly
// allocated GreaterOrEqual struct, preferring placement in s's segment.
func (s ComparatorImpl) NewAtLeast() (GreaterOrEqual, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewGreaterOrEqual(s.Struct.Segment())
	if err != nil {
		return GreaterOrEqual{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) AtMost() (LessOrEqual, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != atMost")
	}
	p, err := s.Struct.Ptr(0)
	return LessOrEqual{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasAtMost() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetAtMost(v LessOrEqual) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAtMost sets the atMost field to a newly
// allocated LessOrEqual struct, preferring placement in s's segment.
func (s ComparatorImpl) NewAtMost() (LessOrEqual, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewLessOrEqual(s.Struct.Segment())
	if err != nil {
		return LessOrEqual{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) EqualTo() (EqualTo, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != equalTo")
	}
	p, err := s.Struct.Ptr(0)
	return EqualTo{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasEqualTo() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetEqualTo(v EqualTo) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEqualTo sets the equalTo field to a newly
// allocated EqualTo struct, preferring placement in s's segment.
func (s ComparatorImpl) NewEqualTo() (EqualTo, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewEqualTo(s.Struct.Segment())
	if err != nil {
		return EqualTo{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) GreaterThan() (GreaterThan, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != greaterThan")
	}
	p, err := s.Struct.Ptr(0)
	return GreaterThan{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasGreaterThan() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetGreaterThan(v GreaterThan) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGreaterThan sets the greaterThan field to a newly
// allocated GreaterThan struct, preferring placement in s's segment.
func (s ComparatorImpl) NewGreaterThan() (GreaterThan, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewGreaterThan(s.Struct.Segment())
	if err != nil {
		return GreaterThan{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) LessThan() (LessThan, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != lessThan")
	}
	p, err := s.Struct.Ptr(0)
	return LessThan{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasLessThan() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetLessThan(v LessThan) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLessThan sets the lessThan field to a newly
// allocated LessThan struct, preferring placement in s's segment.
func (s ComparatorImpl) NewLessThan() (LessThan, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewLessThan(s.Struct.Segment())
	if err != nil {
		return LessThan{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ComparatorImpl) OtherThan() (NotEqualTo, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != otherThan")
	}
	p, err := s.Struct.Ptr(0)
	return NotEqualTo{Struct: p.Struct()}, err
}

func (s ComparatorImpl) HasOtherThan() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ComparatorImpl) SetOtherThan(v NotEqualTo) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewOtherThan sets the otherThan field to a newly
// allocated NotEqualTo struct, preferring placement in s's segment.
func (s ComparatorImpl) NewOtherThan() (NotEqualTo, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewNotEqualTo(s.Struct.Segment())
	if err != nil {
		return NotEqualTo{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ComparatorImpl_List is a list of ComparatorImpl.
type ComparatorImpl_List struct{ capnp.List }

// NewComparatorImpl creates a new list of ComparatorImpl.
func NewComparatorImpl_List(s *capnp.Segment, sz int32) (ComparatorImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ComparatorImpl_List{l}, err
}

func (s ComparatorImpl_List) At(i int) ComparatorImpl { return ComparatorImpl{s.List.Struct(i)} }

func (s ComparatorImpl_List) Set(i int, v ComparatorImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s ComparatorImpl_List) String() string {
	str, _ := text.MarshalList(0xc2fdfeaf7471fcf6, s.List)
	return str
}

// ComparatorImpl_Promise is a wrapper for a ComparatorImpl promised by a client call.
type ComparatorImpl_Promise struct{ *capnp.Pipeline }

func (p ComparatorImpl_Promise) Struct() (ComparatorImpl, error) {
	s, err := p.Pipeline.Struct()
	return ComparatorImpl{s}, err
}

func (p ComparatorImpl_Promise) AtLeast() GreaterOrEqual_Promise {
	return GreaterOrEqual_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) AtMost() LessOrEqual_Promise {
	return LessOrEqual_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) EqualTo() EqualTo_Promise {
	return EqualTo_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) GreaterThan() GreaterThan_Promise {
	return GreaterThan_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) LessThan() LessThan_Promise {
	return LessThan_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ComparatorImpl_Promise) OtherThan() NotEqualTo_Promise {
	return NotEqualTo_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Execute struct{ capnp.Struct }

// Execute_TypeID is the unique identifier for the type Execute.
const Execute_TypeID = 0xb67af87c95544ff6

func NewExecute(s *capnp.Segment) (Execute, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Execute{st}, err
}

func NewRootExecute(s *capnp.Segment) (Execute, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Execute{st}, err
}

func ReadRootExecute(msg *capnp.Message) (Execute, error) {
	root, err := msg.RootPtr()
	return Execute{root.Struct()}, err
}

func (s Execute) String() string {
	str, _ := text.Marshal(0xb67af87c95544ff6, s.Struct)
	return str
}

func (s Execute) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s Execute) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Execute) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Execute) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s Execute) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Execute_List is a list of Execute.
type Execute_List struct{ capnp.List }

// NewExecute creates a new list of Execute.
func NewExecute_List(s *capnp.Segment, sz int32) (Execute_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Execute_List{l}, err
}

func (s Execute_List) At(i int) Execute { return Execute{s.List.Struct(i)} }

func (s Execute_List) Set(i int, v Execute) error { return s.List.SetStruct(i, v.Struct) }

func (s Execute_List) String() string {
	str, _ := text.MarshalList(0xb67af87c95544ff6, s.List)
	return str
}

// Execute_Promise is a wrapper for a Execute promised by a client call.
type Execute_Promise struct{ *capnp.Pipeline }

func (p Execute_Promise) Struct() (Execute, error) {
	s, err := p.Pipeline.Struct()
	return Execute{s}, err
}

func (p Execute_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type ExecuteImpl struct{ capnp.Struct }
type ExecuteImpl_Which uint16

const (
	ExecuteImpl_Which_actDo                       ExecuteImpl_Which = 0
	ExecuteImpl_Which_br                          ExecuteImpl_Which = 1
	ExecuteImpl_Which_break                       ExecuteImpl_Which = 2
	ExecuteImpl_Which_determineArgs               ExecuteImpl_Which = 3
	ExecuteImpl_Which_doNothing                   ExecuteImpl_Which = 4
	ExecuteImpl_Which_doNothingWhy                ExecuteImpl_Which = 5
	ExecuteImpl_Which_eraseAtEdge                 ExecuteImpl_Which = 6
	ExecuteImpl_Which_eraseFromAtIndex            ExecuteImpl_Which = 7
	ExecuteImpl_Which_erasingAtEdgeAsDo           ExecuteImpl_Which = 8
	ExecuteImpl_Which_erasingAtEdgeAsDoElse       ExecuteImpl_Which = 9
	ExecuteImpl_Which_erasingFromAtIndexAsDo      ExecuteImpl_Which = 10
	ExecuteImpl_Which_ifDo                        ExecuteImpl_Which = 11
	ExecuteImpl_Which_ifDoElse                    ExecuteImpl_Which = 12
	ExecuteImpl_Which_ifFromAndDo                 ExecuteImpl_Which = 13
	ExecuteImpl_Which_ifFromAndDoElse             ExecuteImpl_Which = 14
	ExecuteImpl_Which_letBe                       ExecuteImpl_Which = 15
	ExecuteImpl_Which_listReduceIntoFromListUsing ExecuteImpl_Which = 16
	ExecuteImpl_Which_listReverse                 ExecuteImpl_Which = 17
	ExecuteImpl_Which_listSetIndexFrom            ExecuteImpl_Which = 18
	ExecuteImpl_Which_logValue                    ExecuteImpl_Which = 19
	ExecuteImpl_Which_mapFromListUsing            ExecuteImpl_Which = 20
	ExecuteImpl_Which_next                        ExecuteImpl_Which = 21
	ExecuteImpl_Which_p                           ExecuteImpl_Which = 22
	ExecuteImpl_Which_putObjTrait                 ExecuteImpl_Which = 23
	ExecuteImpl_Which_putFromAt                   ExecuteImpl_Which = 24
	ExecuteImpl_Which_putIntoAtEdge               ExecuteImpl_Which = 25
	ExecuteImpl_Which_putIntoAtIndex              ExecuteImpl_Which = 26
	ExecuteImpl_Which_relateToRel                 ExecuteImpl_Which = 27
	ExecuteImpl_Which_renderArgs                  ExecuteImpl_Which = 28
	ExecuteImpl_Which_repeatingAcrossAsDo         ExecuteImpl_Which = 29
	ExecuteImpl_Which_repeatingAcrossAsDoElse     ExecuteImpl_Which = 30
	ExecuteImpl_Which_repeatingDo                 ExecuteImpl_Which = 31
	ExecuteImpl_Which_sayText                     ExecuteImpl_Which = 32
	ExecuteImpl_Which_sendToArgs                  ExecuteImpl_Which = 33
	ExecuteImpl_Which_sortByOrder                 ExecuteImpl_Which = 34
	ExecuteImpl_Which_sortByOrderCase             ExecuteImpl_Which = 35
	ExecuteImpl_Which_sortUsing                   ExecuteImpl_Which = 36
	ExecuteImpl_Which_spliceStartRemoveInsert     ExecuteImpl_Which = 37
	ExecuteImpl_Which_wbr                         ExecuteImpl_Which = 38
)

func (w ExecuteImpl_Which) String() string {
	const s = "actDobrbreakdetermineArgsdoNothingdoNothingWhyeraseAtEdgeeraseFromAtIndexerasingAtEdgeAsDoerasingAtEdgeAsDoElseerasingFromAtIndexAsDoifDoifDoElseifFromAndDoifFromAndDoElseletBelistReduceIntoFromListUsinglistReverselistSetIndexFromlogValuemapFromListUsingnextpputObjTraitputFromAtputIntoAtEdgeputIntoAtIndexrelateToRelrenderArgsrepeatingAcrossAsDorepeatingAcrossAsDoElserepeatingDosayTextsendToArgssortByOrdersortByOrderCasesortUsingspliceStartRemoveInsertwbr"
	switch w {
	case ExecuteImpl_Which_actDo:
		return s[0:5]
	case ExecuteImpl_Which_br:
		return s[5:7]
	case ExecuteImpl_Which_break:
		return s[7:12]
	case ExecuteImpl_Which_determineArgs:
		return s[12:25]
	case ExecuteImpl_Which_doNothing:
		return s[25:34]
	case ExecuteImpl_Which_doNothingWhy:
		return s[34:46]
	case ExecuteImpl_Which_eraseAtEdge:
		return s[46:57]
	case ExecuteImpl_Which_eraseFromAtIndex:
		return s[57:73]
	case ExecuteImpl_Which_erasingAtEdgeAsDo:
		return s[73:90]
	case ExecuteImpl_Which_erasingAtEdgeAsDoElse:
		return s[90:111]
	case ExecuteImpl_Which_erasingFromAtIndexAsDo:
		return s[111:133]
	case ExecuteImpl_Which_ifDo:
		return s[133:137]
	case ExecuteImpl_Which_ifDoElse:
		return s[137:145]
	case ExecuteImpl_Which_ifFromAndDo:
		return s[145:156]
	case ExecuteImpl_Which_ifFromAndDoElse:
		return s[156:171]
	case ExecuteImpl_Which_letBe:
		return s[171:176]
	case ExecuteImpl_Which_listReduceIntoFromListUsing:
		return s[176:203]
	case ExecuteImpl_Which_listReverse:
		return s[203:214]
	case ExecuteImpl_Which_listSetIndexFrom:
		return s[214:230]
	case ExecuteImpl_Which_logValue:
		return s[230:238]
	case ExecuteImpl_Which_mapFromListUsing:
		return s[238:254]
	case ExecuteImpl_Which_next:
		return s[254:258]
	case ExecuteImpl_Which_p:
		return s[258:259]
	case ExecuteImpl_Which_putObjTrait:
		return s[259:270]
	case ExecuteImpl_Which_putFromAt:
		return s[270:279]
	case ExecuteImpl_Which_putIntoAtEdge:
		return s[279:292]
	case ExecuteImpl_Which_putIntoAtIndex:
		return s[292:306]
	case ExecuteImpl_Which_relateToRel:
		return s[306:317]
	case ExecuteImpl_Which_renderArgs:
		return s[317:327]
	case ExecuteImpl_Which_repeatingAcrossAsDo:
		return s[327:346]
	case ExecuteImpl_Which_repeatingAcrossAsDoElse:
		return s[346:369]
	case ExecuteImpl_Which_repeatingDo:
		return s[369:380]
	case ExecuteImpl_Which_sayText:
		return s[380:387]
	case ExecuteImpl_Which_sendToArgs:
		return s[387:397]
	case ExecuteImpl_Which_sortByOrder:
		return s[397:408]
	case ExecuteImpl_Which_sortByOrderCase:
		return s[408:423]
	case ExecuteImpl_Which_sortUsing:
		return s[423:432]
	case ExecuteImpl_Which_spliceStartRemoveInsert:
		return s[432:455]
	case ExecuteImpl_Which_wbr:
		return s[455:458]

	}
	return "ExecuteImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ExecuteImpl_TypeID is the unique identifier for the type ExecuteImpl.
const ExecuteImpl_TypeID = 0xc2856de8bae2a3a5

func NewExecuteImpl(s *capnp.Segment) (ExecuteImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ExecuteImpl{st}, err
}

func NewRootExecuteImpl(s *capnp.Segment) (ExecuteImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ExecuteImpl{st}, err
}

func ReadRootExecuteImpl(msg *capnp.Message) (ExecuteImpl, error) {
	root, err := msg.RootPtr()
	return ExecuteImpl{root.Struct()}, err
}

func (s ExecuteImpl) String() string {
	str, _ := text.Marshal(0xc2856de8bae2a3a5, s.Struct)
	return str
}

func (s ExecuteImpl) Which() ExecuteImpl_Which {
	return ExecuteImpl_Which(s.Struct.Uint16(0))
}
func (s ExecuteImpl) ActDo() (Activity, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != actDo")
	}
	p, err := s.Struct.Ptr(0)
	return Activity{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasActDo() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetActDo(v Activity) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewActDo sets the actDo field to a newly
// allocated Activity struct, preferring placement in s's segment.
func (s ExecuteImpl) NewActDo() (Activity, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewActivity(s.Struct.Segment())
	if err != nil {
		return Activity{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) Br() (Newline, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != br")
	}
	p, err := s.Struct.Ptr(0)
	return Newline{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasBr() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetBr(v Newline) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBr sets the br field to a newly
// allocated Newline struct, preferring placement in s's segment.
func (s ExecuteImpl) NewBr() (Newline, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewNewline(s.Struct.Segment())
	if err != nil {
		return Newline{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) Break() (Break, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != break")
	}
	p, err := s.Struct.Ptr(0)
	return Break{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasBreak() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetBreak(v Break) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBreak sets the break field to a newly
// allocated Break struct, preferring placement in s's segment.
func (s ExecuteImpl) NewBreak() (Break, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewBreak(s.Struct.Segment())
	if err != nil {
		return Break{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) DetermineArgs() (Determine, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Determine{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetDetermineArgs(v Determine) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated Determine struct, preferring placement in s's segment.
func (s ExecuteImpl) NewDetermineArgs() (Determine, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewDetermine(s.Struct.Segment())
	if err != nil {
		return Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) DoNothing() (DoNothing, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != doNothing")
	}
	p, err := s.Struct.Ptr(0)
	return DoNothing{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasDoNothing() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetDoNothing(v DoNothing) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDoNothing sets the doNothing field to a newly
// allocated DoNothing struct, preferring placement in s's segment.
func (s ExecuteImpl) NewDoNothing() (DoNothing, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewDoNothing(s.Struct.Segment())
	if err != nil {
		return DoNothing{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) DoNothingWhy() (DoNothing, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != doNothingWhy")
	}
	p, err := s.Struct.Ptr(0)
	return DoNothing{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasDoNothingWhy() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetDoNothingWhy(v DoNothing) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDoNothingWhy sets the doNothingWhy field to a newly
// allocated DoNothing struct, preferring placement in s's segment.
func (s ExecuteImpl) NewDoNothingWhy() (DoNothing, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewDoNothing(s.Struct.Segment())
	if err != nil {
		return DoNothing{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) EraseAtEdge() (EraseEdge, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != eraseAtEdge")
	}
	p, err := s.Struct.Ptr(0)
	return EraseEdge{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasEraseAtEdge() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetEraseAtEdge(v EraseEdge) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEraseAtEdge sets the eraseAtEdge field to a newly
// allocated EraseEdge struct, preferring placement in s's segment.
func (s ExecuteImpl) NewEraseAtEdge() (EraseEdge, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewEraseEdge(s.Struct.Segment())
	if err != nil {
		return EraseEdge{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) EraseFromAtIndex() (EraseIndex, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != eraseFromAtIndex")
	}
	p, err := s.Struct.Ptr(0)
	return EraseIndex{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasEraseFromAtIndex() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetEraseFromAtIndex(v EraseIndex) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEraseFromAtIndex sets the eraseFromAtIndex field to a newly
// allocated EraseIndex struct, preferring placement in s's segment.
func (s ExecuteImpl) NewEraseFromAtIndex() (EraseIndex, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewEraseIndex(s.Struct.Segment())
	if err != nil {
		return EraseIndex{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ErasingAtEdgeAsDo() (ErasingEdge, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != erasingAtEdgeAsDo")
	}
	p, err := s.Struct.Ptr(0)
	return ErasingEdge{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasErasingAtEdgeAsDo() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetErasingAtEdgeAsDo(v ErasingEdge) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewErasingAtEdgeAsDo sets the erasingAtEdgeAsDo field to a newly
// allocated ErasingEdge struct, preferring placement in s's segment.
func (s ExecuteImpl) NewErasingAtEdgeAsDo() (ErasingEdge, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewErasingEdge(s.Struct.Segment())
	if err != nil {
		return ErasingEdge{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ErasingAtEdgeAsDoElse() (ErasingEdge, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != erasingAtEdgeAsDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return ErasingEdge{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasErasingAtEdgeAsDoElse() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetErasingAtEdgeAsDoElse(v ErasingEdge) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewErasingAtEdgeAsDoElse sets the erasingAtEdgeAsDoElse field to a newly
// allocated ErasingEdge struct, preferring placement in s's segment.
func (s ExecuteImpl) NewErasingAtEdgeAsDoElse() (ErasingEdge, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := NewErasingEdge(s.Struct.Segment())
	if err != nil {
		return ErasingEdge{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ErasingFromAtIndexAsDo() (Erasing, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != erasingFromAtIndexAsDo")
	}
	p, err := s.Struct.Ptr(0)
	return Erasing{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasErasingFromAtIndexAsDo() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetErasingFromAtIndexAsDo(v Erasing) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewErasingFromAtIndexAsDo sets the erasingFromAtIndexAsDo field to a newly
// allocated Erasing struct, preferring placement in s's segment.
func (s ExecuteImpl) NewErasingFromAtIndexAsDo() (Erasing, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := NewErasing(s.Struct.Segment())
	if err != nil {
		return Erasing{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) IfDo() (ChooseAction, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != ifDo")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseAction{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasIfDo() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetIfDo(v ChooseAction) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfDo sets the ifDo field to a newly
// allocated ChooseAction struct, preferring placement in s's segment.
func (s ExecuteImpl) NewIfDo() (ChooseAction, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := NewChooseAction(s.Struct.Segment())
	if err != nil {
		return ChooseAction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) IfDoElse() (ChooseAction, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != ifDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseAction{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasIfDoElse() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetIfDoElse(v ChooseAction) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfDoElse sets the ifDoElse field to a newly
// allocated ChooseAction struct, preferring placement in s's segment.
func (s ExecuteImpl) NewIfDoElse() (ChooseAction, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := NewChooseAction(s.Struct.Segment())
	if err != nil {
		return ChooseAction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) IfFromAndDo() (ChooseValue, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != ifFromAndDo")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseValue{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasIfFromAndDo() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetIfFromAndDo(v ChooseValue) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfFromAndDo sets the ifFromAndDo field to a newly
// allocated ChooseValue struct, preferring placement in s's segment.
func (s ExecuteImpl) NewIfFromAndDo() (ChooseValue, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := NewChooseValue(s.Struct.Segment())
	if err != nil {
		return ChooseValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) IfFromAndDoElse() (ChooseValue, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != ifFromAndDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseValue{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasIfFromAndDoElse() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetIfFromAndDoElse(v ChooseValue) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIfFromAndDoElse sets the ifFromAndDoElse field to a newly
// allocated ChooseValue struct, preferring placement in s's segment.
func (s ExecuteImpl) NewIfFromAndDoElse() (ChooseValue, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := NewChooseValue(s.Struct.Segment())
	if err != nil {
		return ChooseValue{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) LetBe() (Assign, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != letBe")
	}
	p, err := s.Struct.Ptr(0)
	return Assign{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasLetBe() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetLetBe(v Assign) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLetBe sets the letBe field to a newly
// allocated Assign struct, preferring placement in s's segment.
func (s ExecuteImpl) NewLetBe() (Assign, error) {
	s.Struct.SetUint16(0, 15)
	ss, err := NewAssign(s.Struct.Segment())
	if err != nil {
		return Assign{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ListReduceIntoFromListUsing() (Reduce, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != listReduceIntoFromListUsing")
	}
	p, err := s.Struct.Ptr(0)
	return Reduce{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasListReduceIntoFromListUsing() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetListReduceIntoFromListUsing(v Reduce) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewListReduceIntoFromListUsing sets the listReduceIntoFromListUsing field to a newly
// allocated Reduce struct, preferring placement in s's segment.
func (s ExecuteImpl) NewListReduceIntoFromListUsing() (Reduce, error) {
	s.Struct.SetUint16(0, 16)
	ss, err := NewReduce(s.Struct.Segment())
	if err != nil {
		return Reduce{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ListReverse() (ReverseList, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != listReverse")
	}
	p, err := s.Struct.Ptr(0)
	return ReverseList{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasListReverse() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetListReverse(v ReverseList) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewListReverse sets the listReverse field to a newly
// allocated ReverseList struct, preferring placement in s's segment.
func (s ExecuteImpl) NewListReverse() (ReverseList, error) {
	s.Struct.SetUint16(0, 17)
	ss, err := NewReverseList(s.Struct.Segment())
	if err != nil {
		return ReverseList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) ListSetIndexFrom() (Set, error) {
	if s.Struct.Uint16(0) != 18 {
		panic("Which() != listSetIndexFrom")
	}
	p, err := s.Struct.Ptr(0)
	return Set{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasListSetIndexFrom() bool {
	if s.Struct.Uint16(0) != 18 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetListSetIndexFrom(v Set) error {
	s.Struct.SetUint16(0, 18)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewListSetIndexFrom sets the listSetIndexFrom field to a newly
// allocated Set struct, preferring placement in s's segment.
func (s ExecuteImpl) NewListSetIndexFrom() (Set, error) {
	s.Struct.SetUint16(0, 18)
	ss, err := NewSet(s.Struct.Segment())
	if err != nil {
		return Set{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) LogValue() (Log, error) {
	if s.Struct.Uint16(0) != 19 {
		panic("Which() != logValue")
	}
	p, err := s.Struct.Ptr(0)
	return Log{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasLogValue() bool {
	if s.Struct.Uint16(0) != 19 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetLogValue(v Log) error {
	s.Struct.SetUint16(0, 19)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLogValue sets the logValue field to a newly
// allocated Log struct, preferring placement in s's segment.
func (s ExecuteImpl) NewLogValue() (Log, error) {
	s.Struct.SetUint16(0, 19)
	ss, err := NewLog(s.Struct.Segment())
	if err != nil {
		return Log{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) MapFromListUsing() (Map, error) {
	if s.Struct.Uint16(0) != 20 {
		panic("Which() != mapFromListUsing")
	}
	p, err := s.Struct.Ptr(0)
	return Map{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasMapFromListUsing() bool {
	if s.Struct.Uint16(0) != 20 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetMapFromListUsing(v Map) error {
	s.Struct.SetUint16(0, 20)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMapFromListUsing sets the mapFromListUsing field to a newly
// allocated Map struct, preferring placement in s's segment.
func (s ExecuteImpl) NewMapFromListUsing() (Map, error) {
	s.Struct.SetUint16(0, 20)
	ss, err := NewMap(s.Struct.Segment())
	if err != nil {
		return Map{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) Next() (Next, error) {
	if s.Struct.Uint16(0) != 21 {
		panic("Which() != next")
	}
	p, err := s.Struct.Ptr(0)
	return Next{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasNext() bool {
	if s.Struct.Uint16(0) != 21 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetNext(v Next) error {
	s.Struct.SetUint16(0, 21)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNext sets the next field to a newly
// allocated Next struct, preferring placement in s's segment.
func (s ExecuteImpl) NewNext() (Next, error) {
	s.Struct.SetUint16(0, 21)
	ss, err := NewNext(s.Struct.Segment())
	if err != nil {
		return Next{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) P() (Paragraph, error) {
	if s.Struct.Uint16(0) != 22 {
		panic("Which() != p")
	}
	p, err := s.Struct.Ptr(0)
	return Paragraph{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasP() bool {
	if s.Struct.Uint16(0) != 22 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetP(v Paragraph) error {
	s.Struct.SetUint16(0, 22)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewP sets the p field to a newly
// allocated Paragraph struct, preferring placement in s's segment.
func (s ExecuteImpl) NewP() (Paragraph, error) {
	s.Struct.SetUint16(0, 22)
	ss, err := NewParagraph(s.Struct.Segment())
	if err != nil {
		return Paragraph{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) PutObjTrait() (SetTrait, error) {
	if s.Struct.Uint16(0) != 23 {
		panic("Which() != putObjTrait")
	}
	p, err := s.Struct.Ptr(0)
	return SetTrait{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasPutObjTrait() bool {
	if s.Struct.Uint16(0) != 23 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetPutObjTrait(v SetTrait) error {
	s.Struct.SetUint16(0, 23)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPutObjTrait sets the putObjTrait field to a newly
// allocated SetTrait struct, preferring placement in s's segment.
func (s ExecuteImpl) NewPutObjTrait() (SetTrait, error) {
	s.Struct.SetUint16(0, 23)
	ss, err := NewSetTrait(s.Struct.Segment())
	if err != nil {
		return SetTrait{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) PutFromAt() (PutAtField, error) {
	if s.Struct.Uint16(0) != 24 {
		panic("Which() != putFromAt")
	}
	p, err := s.Struct.Ptr(0)
	return PutAtField{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasPutFromAt() bool {
	if s.Struct.Uint16(0) != 24 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetPutFromAt(v PutAtField) error {
	s.Struct.SetUint16(0, 24)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPutFromAt sets the putFromAt field to a newly
// allocated PutAtField struct, preferring placement in s's segment.
func (s ExecuteImpl) NewPutFromAt() (PutAtField, error) {
	s.Struct.SetUint16(0, 24)
	ss, err := NewPutAtField(s.Struct.Segment())
	if err != nil {
		return PutAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) PutIntoAtEdge() (PutEdge, error) {
	if s.Struct.Uint16(0) != 25 {
		panic("Which() != putIntoAtEdge")
	}
	p, err := s.Struct.Ptr(0)
	return PutEdge{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasPutIntoAtEdge() bool {
	if s.Struct.Uint16(0) != 25 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetPutIntoAtEdge(v PutEdge) error {
	s.Struct.SetUint16(0, 25)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPutIntoAtEdge sets the putIntoAtEdge field to a newly
// allocated PutEdge struct, preferring placement in s's segment.
func (s ExecuteImpl) NewPutIntoAtEdge() (PutEdge, error) {
	s.Struct.SetUint16(0, 25)
	ss, err := NewPutEdge(s.Struct.Segment())
	if err != nil {
		return PutEdge{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) PutIntoAtIndex() (PutIndex, error) {
	if s.Struct.Uint16(0) != 26 {
		panic("Which() != putIntoAtIndex")
	}
	p, err := s.Struct.Ptr(0)
	return PutIndex{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasPutIntoAtIndex() bool {
	if s.Struct.Uint16(0) != 26 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetPutIntoAtIndex(v PutIndex) error {
	s.Struct.SetUint16(0, 26)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPutIntoAtIndex sets the putIntoAtIndex field to a newly
// allocated PutIndex struct, preferring placement in s's segment.
func (s ExecuteImpl) NewPutIntoAtIndex() (PutIndex, error) {
	s.Struct.SetUint16(0, 26)
	ss, err := NewPutIndex(s.Struct.Segment())
	if err != nil {
		return PutIndex{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RelateToRel() (Relate, error) {
	if s.Struct.Uint16(0) != 27 {
		panic("Which() != relateToRel")
	}
	p, err := s.Struct.Ptr(0)
	return Relate{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRelateToRel() bool {
	if s.Struct.Uint16(0) != 27 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRelateToRel(v Relate) error {
	s.Struct.SetUint16(0, 27)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRelateToRel sets the relateToRel field to a newly
// allocated Relate struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRelateToRel() (Relate, error) {
	s.Struct.SetUint16(0, 27)
	ss, err := NewRelate(s.Struct.Segment())
	if err != nil {
		return Relate{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 28 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 28 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 28)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 28)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RepeatingAcrossAsDo() (Each, error) {
	if s.Struct.Uint16(0) != 29 {
		panic("Which() != repeatingAcrossAsDo")
	}
	p, err := s.Struct.Ptr(0)
	return Each{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRepeatingAcrossAsDo() bool {
	if s.Struct.Uint16(0) != 29 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRepeatingAcrossAsDo(v Each) error {
	s.Struct.SetUint16(0, 29)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRepeatingAcrossAsDo sets the repeatingAcrossAsDo field to a newly
// allocated Each struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRepeatingAcrossAsDo() (Each, error) {
	s.Struct.SetUint16(0, 29)
	ss, err := NewEach(s.Struct.Segment())
	if err != nil {
		return Each{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RepeatingAcrossAsDoElse() (Each, error) {
	if s.Struct.Uint16(0) != 30 {
		panic("Which() != repeatingAcrossAsDoElse")
	}
	p, err := s.Struct.Ptr(0)
	return Each{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRepeatingAcrossAsDoElse() bool {
	if s.Struct.Uint16(0) != 30 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRepeatingAcrossAsDoElse(v Each) error {
	s.Struct.SetUint16(0, 30)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRepeatingAcrossAsDoElse sets the repeatingAcrossAsDoElse field to a newly
// allocated Each struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRepeatingAcrossAsDoElse() (Each, error) {
	s.Struct.SetUint16(0, 30)
	ss, err := NewEach(s.Struct.Segment())
	if err != nil {
		return Each{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) RepeatingDo() (While, error) {
	if s.Struct.Uint16(0) != 31 {
		panic("Which() != repeatingDo")
	}
	p, err := s.Struct.Ptr(0)
	return While{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasRepeatingDo() bool {
	if s.Struct.Uint16(0) != 31 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetRepeatingDo(v While) error {
	s.Struct.SetUint16(0, 31)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRepeatingDo sets the repeatingDo field to a newly
// allocated While struct, preferring placement in s's segment.
func (s ExecuteImpl) NewRepeatingDo() (While, error) {
	s.Struct.SetUint16(0, 31)
	ss, err := NewWhile(s.Struct.Segment())
	if err != nil {
		return While{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SayText() (Say, error) {
	if s.Struct.Uint16(0) != 32 {
		panic("Which() != sayText")
	}
	p, err := s.Struct.Ptr(0)
	return Say{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSayText() bool {
	if s.Struct.Uint16(0) != 32 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSayText(v Say) error {
	s.Struct.SetUint16(0, 32)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSayText sets the sayText field to a newly
// allocated Say struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSayText() (Say, error) {
	s.Struct.SetUint16(0, 32)
	ss, err := NewSay(s.Struct.Segment())
	if err != nil {
		return Say{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SendToArgs() (Send, error) {
	if s.Struct.Uint16(0) != 33 {
		panic("Which() != sendToArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Send{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSendToArgs() bool {
	if s.Struct.Uint16(0) != 33 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSendToArgs(v Send) error {
	s.Struct.SetUint16(0, 33)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSendToArgs sets the sendToArgs field to a newly
// allocated Send struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSendToArgs() (Send, error) {
	s.Struct.SetUint16(0, 33)
	ss, err := NewSend(s.Struct.Segment())
	if err != nil {
		return Send{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SortByOrder() (SortNumbers, error) {
	if s.Struct.Uint16(0) != 34 {
		panic("Which() != sortByOrder")
	}
	p, err := s.Struct.Ptr(0)
	return SortNumbers{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSortByOrder() bool {
	if s.Struct.Uint16(0) != 34 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSortByOrder(v SortNumbers) error {
	s.Struct.SetUint16(0, 34)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSortByOrder sets the sortByOrder field to a newly
// allocated SortNumbers struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSortByOrder() (SortNumbers, error) {
	s.Struct.SetUint16(0, 34)
	ss, err := NewSortNumbers(s.Struct.Segment())
	if err != nil {
		return SortNumbers{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SortByOrderCase() (SortText, error) {
	if s.Struct.Uint16(0) != 35 {
		panic("Which() != sortByOrderCase")
	}
	p, err := s.Struct.Ptr(0)
	return SortText{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSortByOrderCase() bool {
	if s.Struct.Uint16(0) != 35 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSortByOrderCase(v SortText) error {
	s.Struct.SetUint16(0, 35)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSortByOrderCase sets the sortByOrderCase field to a newly
// allocated SortText struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSortByOrderCase() (SortText, error) {
	s.Struct.SetUint16(0, 35)
	ss, err := NewSortText(s.Struct.Segment())
	if err != nil {
		return SortText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SortUsing() (SortRecords, error) {
	if s.Struct.Uint16(0) != 36 {
		panic("Which() != sortUsing")
	}
	p, err := s.Struct.Ptr(0)
	return SortRecords{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSortUsing() bool {
	if s.Struct.Uint16(0) != 36 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSortUsing(v SortRecords) error {
	s.Struct.SetUint16(0, 36)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSortUsing sets the sortUsing field to a newly
// allocated SortRecords struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSortUsing() (SortRecords, error) {
	s.Struct.SetUint16(0, 36)
	ss, err := NewSortRecords(s.Struct.Segment())
	if err != nil {
		return SortRecords{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) SpliceStartRemoveInsert() (Splice, error) {
	if s.Struct.Uint16(0) != 37 {
		panic("Which() != spliceStartRemoveInsert")
	}
	p, err := s.Struct.Ptr(0)
	return Splice{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasSpliceStartRemoveInsert() bool {
	if s.Struct.Uint16(0) != 37 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetSpliceStartRemoveInsert(v Splice) error {
	s.Struct.SetUint16(0, 37)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpliceStartRemoveInsert sets the spliceStartRemoveInsert field to a newly
// allocated Splice struct, preferring placement in s's segment.
func (s ExecuteImpl) NewSpliceStartRemoveInsert() (Splice, error) {
	s.Struct.SetUint16(0, 37)
	ss, err := NewSplice(s.Struct.Segment())
	if err != nil {
		return Splice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ExecuteImpl) Wbr() (Softline, error) {
	if s.Struct.Uint16(0) != 38 {
		panic("Which() != wbr")
	}
	p, err := s.Struct.Ptr(0)
	return Softline{Struct: p.Struct()}, err
}

func (s ExecuteImpl) HasWbr() bool {
	if s.Struct.Uint16(0) != 38 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ExecuteImpl) SetWbr(v Softline) error {
	s.Struct.SetUint16(0, 38)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewWbr sets the wbr field to a newly
// allocated Softline struct, preferring placement in s's segment.
func (s ExecuteImpl) NewWbr() (Softline, error) {
	s.Struct.SetUint16(0, 38)
	ss, err := NewSoftline(s.Struct.Segment())
	if err != nil {
		return Softline{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ExecuteImpl_List is a list of ExecuteImpl.
type ExecuteImpl_List struct{ capnp.List }

// NewExecuteImpl creates a new list of ExecuteImpl.
func NewExecuteImpl_List(s *capnp.Segment, sz int32) (ExecuteImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ExecuteImpl_List{l}, err
}

func (s ExecuteImpl_List) At(i int) ExecuteImpl { return ExecuteImpl{s.List.Struct(i)} }

func (s ExecuteImpl_List) Set(i int, v ExecuteImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s ExecuteImpl_List) String() string {
	str, _ := text.MarshalList(0xc2856de8bae2a3a5, s.List)
	return str
}

// ExecuteImpl_Promise is a wrapper for a ExecuteImpl promised by a client call.
type ExecuteImpl_Promise struct{ *capnp.Pipeline }

func (p ExecuteImpl_Promise) Struct() (ExecuteImpl, error) {
	s, err := p.Pipeline.Struct()
	return ExecuteImpl{s}, err
}

func (p ExecuteImpl_Promise) ActDo() Activity_Promise {
	return Activity_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) Br() Newline_Promise {
	return Newline_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) Break() Break_Promise {
	return Break_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) DetermineArgs() Determine_Promise {
	return Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) DoNothing() DoNothing_Promise {
	return DoNothing_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) DoNothingWhy() DoNothing_Promise {
	return DoNothing_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) EraseAtEdge() EraseEdge_Promise {
	return EraseEdge_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) EraseFromAtIndex() EraseIndex_Promise {
	return EraseIndex_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ErasingAtEdgeAsDo() ErasingEdge_Promise {
	return ErasingEdge_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ErasingAtEdgeAsDoElse() ErasingEdge_Promise {
	return ErasingEdge_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ErasingFromAtIndexAsDo() Erasing_Promise {
	return Erasing_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) IfDo() ChooseAction_Promise {
	return ChooseAction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) IfDoElse() ChooseAction_Promise {
	return ChooseAction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) IfFromAndDo() ChooseValue_Promise {
	return ChooseValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) IfFromAndDoElse() ChooseValue_Promise {
	return ChooseValue_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) LetBe() Assign_Promise {
	return Assign_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ListReduceIntoFromListUsing() Reduce_Promise {
	return Reduce_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ListReverse() ReverseList_Promise {
	return ReverseList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) ListSetIndexFrom() Set_Promise {
	return Set_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) LogValue() Log_Promise {
	return Log_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) MapFromListUsing() Map_Promise {
	return Map_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) Next() Next_Promise {
	return Next_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) P() Paragraph_Promise {
	return Paragraph_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) PutObjTrait() SetTrait_Promise {
	return SetTrait_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) PutFromAt() PutAtField_Promise {
	return PutAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) PutIntoAtEdge() PutEdge_Promise {
	return PutEdge_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) PutIntoAtIndex() PutIndex_Promise {
	return PutIndex_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RelateToRel() Relate_Promise {
	return Relate_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RepeatingAcrossAsDo() Each_Promise {
	return Each_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RepeatingAcrossAsDoElse() Each_Promise {
	return Each_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) RepeatingDo() While_Promise {
	return While_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SayText() Say_Promise {
	return Say_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SendToArgs() Send_Promise {
	return Send_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SortByOrder() SortNumbers_Promise {
	return SortNumbers_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SortByOrderCase() SortText_Promise {
	return SortText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SortUsing() SortRecords_Promise {
	return SortRecords_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) SpliceStartRemoveInsert() Splice_Promise {
	return Splice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ExecuteImpl_Promise) Wbr() Softline_Promise {
	return Softline_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromSourceFields struct{ capnp.Struct }

// FromSourceFields_TypeID is the unique identifier for the type FromSourceFields.
const FromSourceFields_TypeID = 0xfc90f4b91130aaf2

func NewFromSourceFields(s *capnp.Segment) (FromSourceFields, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromSourceFields{st}, err
}

func NewRootFromSourceFields(s *capnp.Segment) (FromSourceFields, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromSourceFields{st}, err
}

func ReadRootFromSourceFields(msg *capnp.Message) (FromSourceFields, error) {
	root, err := msg.RootPtr()
	return FromSourceFields{root.Struct()}, err
}

func (s FromSourceFields) String() string {
	str, _ := text.Marshal(0xfc90f4b91130aaf2, s.Struct)
	return str
}

func (s FromSourceFields) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s FromSourceFields) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFields) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s FromSourceFields) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s FromSourceFields) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// FromSourceFields_List is a list of FromSourceFields.
type FromSourceFields_List struct{ capnp.List }

// NewFromSourceFields creates a new list of FromSourceFields.
func NewFromSourceFields_List(s *capnp.Segment, sz int32) (FromSourceFields_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromSourceFields_List{l}, err
}

func (s FromSourceFields_List) At(i int) FromSourceFields { return FromSourceFields{s.List.Struct(i)} }

func (s FromSourceFields_List) Set(i int, v FromSourceFields) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s FromSourceFields_List) String() string {
	str, _ := text.MarshalList(0xfc90f4b91130aaf2, s.List)
	return str
}

// FromSourceFields_Promise is a wrapper for a FromSourceFields promised by a client call.
type FromSourceFields_Promise struct{ *capnp.Pipeline }

func (p FromSourceFields_Promise) Struct() (FromSourceFields, error) {
	s, err := p.Pipeline.Struct()
	return FromSourceFields{s}, err
}

func (p FromSourceFields_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type FromSourceFieldsImpl struct{ capnp.Struct }
type FromSourceFieldsImpl_Which uint16

const (
	FromSourceFieldsImpl_Which_obj         FromSourceFieldsImpl_Which = 0
	FromSourceFieldsImpl_Which_rec         FromSourceFieldsImpl_Which = 1
	FromSourceFieldsImpl_Which_renderField FromSourceFieldsImpl_Which = 2
	FromSourceFieldsImpl_Which_var         FromSourceFieldsImpl_Which = 3
)

func (w FromSourceFieldsImpl_Which) String() string {
	const s = "objrecrenderFieldvar"
	switch w {
	case FromSourceFieldsImpl_Which_obj:
		return s[0:3]
	case FromSourceFieldsImpl_Which_rec:
		return s[3:6]
	case FromSourceFieldsImpl_Which_renderField:
		return s[6:17]
	case FromSourceFieldsImpl_Which_var:
		return s[17:20]

	}
	return "FromSourceFieldsImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// FromSourceFieldsImpl_TypeID is the unique identifier for the type FromSourceFieldsImpl.
const FromSourceFieldsImpl_TypeID = 0xeb835242fc94c284

func NewFromSourceFieldsImpl(s *capnp.Segment) (FromSourceFieldsImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return FromSourceFieldsImpl{st}, err
}

func NewRootFromSourceFieldsImpl(s *capnp.Segment) (FromSourceFieldsImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return FromSourceFieldsImpl{st}, err
}

func ReadRootFromSourceFieldsImpl(msg *capnp.Message) (FromSourceFieldsImpl, error) {
	root, err := msg.RootPtr()
	return FromSourceFieldsImpl{root.Struct()}, err
}

func (s FromSourceFieldsImpl) String() string {
	str, _ := text.Marshal(0xeb835242fc94c284, s.Struct)
	return str
}

func (s FromSourceFieldsImpl) Which() FromSourceFieldsImpl_Which {
	return FromSourceFieldsImpl_Which(s.Struct.Uint16(0))
}
func (s FromSourceFieldsImpl) Obj() (FromObj, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != obj")
	}
	p, err := s.Struct.Ptr(0)
	return FromObj{Struct: p.Struct()}, err
}

func (s FromSourceFieldsImpl) HasObj() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFieldsImpl) SetObj(v FromObj) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObj sets the obj field to a newly
// allocated FromObj struct, preferring placement in s's segment.
func (s FromSourceFieldsImpl) NewObj() (FromObj, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewFromObj(s.Struct.Segment())
	if err != nil {
		return FromObj{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s FromSourceFieldsImpl) Rec() (FromRec, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != rec")
	}
	p, err := s.Struct.Ptr(0)
	return FromRec{Struct: p.Struct()}, err
}

func (s FromSourceFieldsImpl) HasRec() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFieldsImpl) SetRec(v FromRec) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRec sets the rec field to a newly
// allocated FromRec struct, preferring placement in s's segment.
func (s FromSourceFieldsImpl) NewRec() (FromRec, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewFromRec(s.Struct.Segment())
	if err != nil {
		return FromRec{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s FromSourceFieldsImpl) RenderField() (RenderField, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != renderField")
	}
	p, err := s.Struct.Ptr(0)
	return RenderField{Struct: p.Struct()}, err
}

func (s FromSourceFieldsImpl) HasRenderField() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFieldsImpl) SetRenderField(v RenderField) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderField sets the renderField field to a newly
// allocated RenderField struct, preferring placement in s's segment.
func (s FromSourceFieldsImpl) NewRenderField() (RenderField, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewRenderField(s.Struct.Segment())
	if err != nil {
		return RenderField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s FromSourceFieldsImpl) Var() (FromVar, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return FromVar{Struct: p.Struct()}, err
}

func (s FromSourceFieldsImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromSourceFieldsImpl) SetVar(v FromVar) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated FromVar struct, preferring placement in s's segment.
func (s FromSourceFieldsImpl) NewVar() (FromVar, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewFromVar(s.Struct.Segment())
	if err != nil {
		return FromVar{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromSourceFieldsImpl_List is a list of FromSourceFieldsImpl.
type FromSourceFieldsImpl_List struct{ capnp.List }

// NewFromSourceFieldsImpl creates a new list of FromSourceFieldsImpl.
func NewFromSourceFieldsImpl_List(s *capnp.Segment, sz int32) (FromSourceFieldsImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return FromSourceFieldsImpl_List{l}, err
}

func (s FromSourceFieldsImpl_List) At(i int) FromSourceFieldsImpl {
	return FromSourceFieldsImpl{s.List.Struct(i)}
}

func (s FromSourceFieldsImpl_List) Set(i int, v FromSourceFieldsImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s FromSourceFieldsImpl_List) String() string {
	str, _ := text.MarshalList(0xeb835242fc94c284, s.List)
	return str
}

// FromSourceFieldsImpl_Promise is a wrapper for a FromSourceFieldsImpl promised by a client call.
type FromSourceFieldsImpl_Promise struct{ *capnp.Pipeline }

func (p FromSourceFieldsImpl_Promise) Struct() (FromSourceFieldsImpl, error) {
	s, err := p.Pipeline.Struct()
	return FromSourceFieldsImpl{s}, err
}

func (p FromSourceFieldsImpl_Promise) Obj() FromObj_Promise {
	return FromObj_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p FromSourceFieldsImpl_Promise) Rec() FromRec_Promise {
	return FromRec_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p FromSourceFieldsImpl_Promise) RenderField() RenderField_Promise {
	return RenderField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p FromSourceFieldsImpl_Promise) Var() FromVar_Promise {
	return FromVar_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type GrammarMaker struct{ capnp.Struct }

// GrammarMaker_TypeID is the unique identifier for the type GrammarMaker.
const GrammarMaker_TypeID = 0xc218357175c250bf

func NewGrammarMaker(s *capnp.Segment) (GrammarMaker, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return GrammarMaker{st}, err
}

func NewRootGrammarMaker(s *capnp.Segment) (GrammarMaker, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return GrammarMaker{st}, err
}

func ReadRootGrammarMaker(msg *capnp.Message) (GrammarMaker, error) {
	root, err := msg.RootPtr()
	return GrammarMaker{root.Struct()}, err
}

func (s GrammarMaker) String() string {
	str, _ := text.Marshal(0xc218357175c250bf, s.Struct)
	return str
}

func (s GrammarMaker) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s GrammarMaker) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s GrammarMaker) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s GrammarMaker) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s GrammarMaker) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// GrammarMaker_List is a list of GrammarMaker.
type GrammarMaker_List struct{ capnp.List }

// NewGrammarMaker creates a new list of GrammarMaker.
func NewGrammarMaker_List(s *capnp.Segment, sz int32) (GrammarMaker_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return GrammarMaker_List{l}, err
}

func (s GrammarMaker_List) At(i int) GrammarMaker { return GrammarMaker{s.List.Struct(i)} }

func (s GrammarMaker_List) Set(i int, v GrammarMaker) error { return s.List.SetStruct(i, v.Struct) }

func (s GrammarMaker_List) String() string {
	str, _ := text.MarshalList(0xc218357175c250bf, s.List)
	return str
}

// GrammarMaker_Promise is a wrapper for a GrammarMaker promised by a client call.
type GrammarMaker_Promise struct{ *capnp.Pipeline }

func (p GrammarMaker_Promise) Struct() (GrammarMaker, error) {
	s, err := p.Pipeline.Struct()
	return GrammarMaker{s}, err
}

func (p GrammarMaker_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type GrammarMakerImpl struct{ capnp.Struct }
type GrammarMakerImpl_Which uint16

const (
	GrammarMakerImpl_Which_aliasAsNoun    GrammarMakerImpl_Which = 0
	GrammarMakerImpl_Which_directiveScans GrammarMakerImpl_Which = 1
)

func (w GrammarMakerImpl_Which) String() string {
	const s = "aliasAsNoundirectiveScans"
	switch w {
	case GrammarMakerImpl_Which_aliasAsNoun:
		return s[0:11]
	case GrammarMakerImpl_Which_directiveScans:
		return s[11:25]

	}
	return "GrammarMakerImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// GrammarMakerImpl_TypeID is the unique identifier for the type GrammarMakerImpl.
const GrammarMakerImpl_TypeID = 0xca4a7c7ae2b259a5

func NewGrammarMakerImpl(s *capnp.Segment) (GrammarMakerImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return GrammarMakerImpl{st}, err
}

func NewRootGrammarMakerImpl(s *capnp.Segment) (GrammarMakerImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return GrammarMakerImpl{st}, err
}

func ReadRootGrammarMakerImpl(msg *capnp.Message) (GrammarMakerImpl, error) {
	root, err := msg.RootPtr()
	return GrammarMakerImpl{root.Struct()}, err
}

func (s GrammarMakerImpl) String() string {
	str, _ := text.Marshal(0xca4a7c7ae2b259a5, s.Struct)
	return str
}

func (s GrammarMakerImpl) Which() GrammarMakerImpl_Which {
	return GrammarMakerImpl_Which(s.Struct.Uint16(0))
}
func (s GrammarMakerImpl) AliasAsNoun() (Alias, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != aliasAsNoun")
	}
	p, err := s.Struct.Ptr(0)
	return Alias{Struct: p.Struct()}, err
}

func (s GrammarMakerImpl) HasAliasAsNoun() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s GrammarMakerImpl) SetAliasAsNoun(v Alias) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAliasAsNoun sets the aliasAsNoun field to a newly
// allocated Alias struct, preferring placement in s's segment.
func (s GrammarMakerImpl) NewAliasAsNoun() (Alias, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewAlias(s.Struct.Segment())
	if err != nil {
		return Alias{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s GrammarMakerImpl) DirectiveScans() (Directive, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != directiveScans")
	}
	p, err := s.Struct.Ptr(0)
	return Directive{Struct: p.Struct()}, err
}

func (s GrammarMakerImpl) HasDirectiveScans() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s GrammarMakerImpl) SetDirectiveScans(v Directive) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDirectiveScans sets the directiveScans field to a newly
// allocated Directive struct, preferring placement in s's segment.
func (s GrammarMakerImpl) NewDirectiveScans() (Directive, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewDirective(s.Struct.Segment())
	if err != nil {
		return Directive{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// GrammarMakerImpl_List is a list of GrammarMakerImpl.
type GrammarMakerImpl_List struct{ capnp.List }

// NewGrammarMakerImpl creates a new list of GrammarMakerImpl.
func NewGrammarMakerImpl_List(s *capnp.Segment, sz int32) (GrammarMakerImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return GrammarMakerImpl_List{l}, err
}

func (s GrammarMakerImpl_List) At(i int) GrammarMakerImpl { return GrammarMakerImpl{s.List.Struct(i)} }

func (s GrammarMakerImpl_List) Set(i int, v GrammarMakerImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s GrammarMakerImpl_List) String() string {
	str, _ := text.MarshalList(0xca4a7c7ae2b259a5, s.List)
	return str
}

// GrammarMakerImpl_Promise is a wrapper for a GrammarMakerImpl promised by a client call.
type GrammarMakerImpl_Promise struct{ *capnp.Pipeline }

func (p GrammarMakerImpl_Promise) Struct() (GrammarMakerImpl, error) {
	s, err := p.Pipeline.Struct()
	return GrammarMakerImpl{s}, err
}

func (p GrammarMakerImpl_Promise) AliasAsNoun() Alias_Promise {
	return Alias_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p GrammarMakerImpl_Promise) DirectiveScans() Directive_Promise {
	return Directive_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type IntoTargetFields struct{ capnp.Struct }

// IntoTargetFields_TypeID is the unique identifier for the type IntoTargetFields.
const IntoTargetFields_TypeID = 0x92c7c4e159ac1d45

func NewIntoTargetFields(s *capnp.Segment) (IntoTargetFields, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoTargetFields{st}, err
}

func NewRootIntoTargetFields(s *capnp.Segment) (IntoTargetFields, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoTargetFields{st}, err
}

func ReadRootIntoTargetFields(msg *capnp.Message) (IntoTargetFields, error) {
	root, err := msg.RootPtr()
	return IntoTargetFields{root.Struct()}, err
}

func (s IntoTargetFields) String() string {
	str, _ := text.Marshal(0x92c7c4e159ac1d45, s.Struct)
	return str
}

func (s IntoTargetFields) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s IntoTargetFields) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoTargetFields) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s IntoTargetFields) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s IntoTargetFields) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// IntoTargetFields_List is a list of IntoTargetFields.
type IntoTargetFields_List struct{ capnp.List }

// NewIntoTargetFields creates a new list of IntoTargetFields.
func NewIntoTargetFields_List(s *capnp.Segment, sz int32) (IntoTargetFields_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IntoTargetFields_List{l}, err
}

func (s IntoTargetFields_List) At(i int) IntoTargetFields { return IntoTargetFields{s.List.Struct(i)} }

func (s IntoTargetFields_List) Set(i int, v IntoTargetFields) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s IntoTargetFields_List) String() string {
	str, _ := text.MarshalList(0x92c7c4e159ac1d45, s.List)
	return str
}

// IntoTargetFields_Promise is a wrapper for a IntoTargetFields promised by a client call.
type IntoTargetFields_Promise struct{ *capnp.Pipeline }

func (p IntoTargetFields_Promise) Struct() (IntoTargetFields, error) {
	s, err := p.Pipeline.Struct()
	return IntoTargetFields{s}, err
}

func (p IntoTargetFields_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type IntoTargetFieldsImpl struct{ capnp.Struct }
type IntoTargetFieldsImpl_Which uint16

const (
	IntoTargetFieldsImpl_Which_obj IntoTargetFieldsImpl_Which = 0
	IntoTargetFieldsImpl_Which_var IntoTargetFieldsImpl_Which = 1
)

func (w IntoTargetFieldsImpl_Which) String() string {
	const s = "objvar"
	switch w {
	case IntoTargetFieldsImpl_Which_obj:
		return s[0:3]
	case IntoTargetFieldsImpl_Which_var:
		return s[3:6]

	}
	return "IntoTargetFieldsImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// IntoTargetFieldsImpl_TypeID is the unique identifier for the type IntoTargetFieldsImpl.
const IntoTargetFieldsImpl_TypeID = 0xaeafaebf10861781

func NewIntoTargetFieldsImpl(s *capnp.Segment) (IntoTargetFieldsImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return IntoTargetFieldsImpl{st}, err
}

func NewRootIntoTargetFieldsImpl(s *capnp.Segment) (IntoTargetFieldsImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return IntoTargetFieldsImpl{st}, err
}

func ReadRootIntoTargetFieldsImpl(msg *capnp.Message) (IntoTargetFieldsImpl, error) {
	root, err := msg.RootPtr()
	return IntoTargetFieldsImpl{root.Struct()}, err
}

func (s IntoTargetFieldsImpl) String() string {
	str, _ := text.Marshal(0xaeafaebf10861781, s.Struct)
	return str
}

func (s IntoTargetFieldsImpl) Which() IntoTargetFieldsImpl_Which {
	return IntoTargetFieldsImpl_Which(s.Struct.Uint16(0))
}
func (s IntoTargetFieldsImpl) Obj() (IntoObj, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != obj")
	}
	p, err := s.Struct.Ptr(0)
	return IntoObj{Struct: p.Struct()}, err
}

func (s IntoTargetFieldsImpl) HasObj() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoTargetFieldsImpl) SetObj(v IntoObj) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObj sets the obj field to a newly
// allocated IntoObj struct, preferring placement in s's segment.
func (s IntoTargetFieldsImpl) NewObj() (IntoObj, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewIntoObj(s.Struct.Segment())
	if err != nil {
		return IntoObj{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s IntoTargetFieldsImpl) Var() (IntoVar, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return IntoVar{Struct: p.Struct()}, err
}

func (s IntoTargetFieldsImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoTargetFieldsImpl) SetVar(v IntoVar) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated IntoVar struct, preferring placement in s's segment.
func (s IntoTargetFieldsImpl) NewVar() (IntoVar, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewIntoVar(s.Struct.Segment())
	if err != nil {
		return IntoVar{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IntoTargetFieldsImpl_List is a list of IntoTargetFieldsImpl.
type IntoTargetFieldsImpl_List struct{ capnp.List }

// NewIntoTargetFieldsImpl creates a new list of IntoTargetFieldsImpl.
func NewIntoTargetFieldsImpl_List(s *capnp.Segment, sz int32) (IntoTargetFieldsImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return IntoTargetFieldsImpl_List{l}, err
}

func (s IntoTargetFieldsImpl_List) At(i int) IntoTargetFieldsImpl {
	return IntoTargetFieldsImpl{s.List.Struct(i)}
}

func (s IntoTargetFieldsImpl_List) Set(i int, v IntoTargetFieldsImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s IntoTargetFieldsImpl_List) String() string {
	str, _ := text.MarshalList(0xaeafaebf10861781, s.List)
	return str
}

// IntoTargetFieldsImpl_Promise is a wrapper for a IntoTargetFieldsImpl promised by a client call.
type IntoTargetFieldsImpl_Promise struct{ *capnp.Pipeline }

func (p IntoTargetFieldsImpl_Promise) Struct() (IntoTargetFieldsImpl, error) {
	s, err := p.Pipeline.Struct()
	return IntoTargetFieldsImpl{s}, err
}

func (p IntoTargetFieldsImpl_Promise) Obj() IntoObj_Promise {
	return IntoObj_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p IntoTargetFieldsImpl_Promise) Var() IntoVar_Promise {
	return IntoVar_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ListIterator struct{ capnp.Struct }

// ListIterator_TypeID is the unique identifier for the type ListIterator.
const ListIterator_TypeID = 0xacfab4eb900533b7

func NewListIterator(s *capnp.Segment) (ListIterator, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListIterator{st}, err
}

func NewRootListIterator(s *capnp.Segment) (ListIterator, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListIterator{st}, err
}

func ReadRootListIterator(msg *capnp.Message) (ListIterator, error) {
	root, err := msg.RootPtr()
	return ListIterator{root.Struct()}, err
}

func (s ListIterator) String() string {
	str, _ := text.Marshal(0xacfab4eb900533b7, s.Struct)
	return str
}

func (s ListIterator) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s ListIterator) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListIterator) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s ListIterator) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s ListIterator) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// ListIterator_List is a list of ListIterator.
type ListIterator_List struct{ capnp.List }

// NewListIterator creates a new list of ListIterator.
func NewListIterator_List(s *capnp.Segment, sz int32) (ListIterator_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return ListIterator_List{l}, err
}

func (s ListIterator_List) At(i int) ListIterator { return ListIterator{s.List.Struct(i)} }

func (s ListIterator_List) Set(i int, v ListIterator) error { return s.List.SetStruct(i, v.Struct) }

func (s ListIterator_List) String() string {
	str, _ := text.MarshalList(0xacfab4eb900533b7, s.List)
	return str
}

// ListIterator_Promise is a wrapper for a ListIterator promised by a client call.
type ListIterator_Promise struct{ *capnp.Pipeline }

func (p ListIterator_Promise) Struct() (ListIterator, error) {
	s, err := p.Pipeline.Struct()
	return ListIterator{s}, err
}

func (p ListIterator_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type ListIteratorImpl struct{ capnp.Struct }
type ListIteratorImpl_Which uint16

const (
	ListIteratorImpl_Which_num ListIteratorImpl_Which = 0
	ListIteratorImpl_Which_rec ListIteratorImpl_Which = 1
	ListIteratorImpl_Which_txt ListIteratorImpl_Which = 2
)

func (w ListIteratorImpl_Which) String() string {
	const s = "numrectxt"
	switch w {
	case ListIteratorImpl_Which_num:
		return s[0:3]
	case ListIteratorImpl_Which_rec:
		return s[3:6]
	case ListIteratorImpl_Which_txt:
		return s[6:9]

	}
	return "ListIteratorImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ListIteratorImpl_TypeID is the unique identifier for the type ListIteratorImpl.
const ListIteratorImpl_TypeID = 0x88b9bf32c2da2936

func NewListIteratorImpl(s *capnp.Segment) (ListIteratorImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListIteratorImpl{st}, err
}

func NewRootListIteratorImpl(s *capnp.Segment) (ListIteratorImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListIteratorImpl{st}, err
}

func ReadRootListIteratorImpl(msg *capnp.Message) (ListIteratorImpl, error) {
	root, err := msg.RootPtr()
	return ListIteratorImpl{root.Struct()}, err
}

func (s ListIteratorImpl) String() string {
	str, _ := text.Marshal(0x88b9bf32c2da2936, s.Struct)
	return str
}

func (s ListIteratorImpl) Which() ListIteratorImpl_Which {
	return ListIteratorImpl_Which(s.Struct.Uint16(0))
}
func (s ListIteratorImpl) Num() (AsNum, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != num")
	}
	p, err := s.Struct.Ptr(0)
	return AsNum{Struct: p.Struct()}, err
}

func (s ListIteratorImpl) HasNum() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListIteratorImpl) SetNum(v AsNum) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated AsNum struct, preferring placement in s's segment.
func (s ListIteratorImpl) NewNum() (AsNum, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewAsNum(s.Struct.Segment())
	if err != nil {
		return AsNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListIteratorImpl) Rec() (AsRec, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != rec")
	}
	p, err := s.Struct.Ptr(0)
	return AsRec{Struct: p.Struct()}, err
}

func (s ListIteratorImpl) HasRec() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListIteratorImpl) SetRec(v AsRec) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRec sets the rec field to a newly
// allocated AsRec struct, preferring placement in s's segment.
func (s ListIteratorImpl) NewRec() (AsRec, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewAsRec(s.Struct.Segment())
	if err != nil {
		return AsRec{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListIteratorImpl) Txt() (AsTxt, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != txt")
	}
	p, err := s.Struct.Ptr(0)
	return AsTxt{Struct: p.Struct()}, err
}

func (s ListIteratorImpl) HasTxt() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListIteratorImpl) SetTxt(v AsTxt) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxt sets the txt field to a newly
// allocated AsTxt struct, preferring placement in s's segment.
func (s ListIteratorImpl) NewTxt() (AsTxt, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewAsTxt(s.Struct.Segment())
	if err != nil {
		return AsTxt{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ListIteratorImpl_List is a list of ListIteratorImpl.
type ListIteratorImpl_List struct{ capnp.List }

// NewListIteratorImpl creates a new list of ListIteratorImpl.
func NewListIteratorImpl_List(s *capnp.Segment, sz int32) (ListIteratorImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ListIteratorImpl_List{l}, err
}

func (s ListIteratorImpl_List) At(i int) ListIteratorImpl { return ListIteratorImpl{s.List.Struct(i)} }

func (s ListIteratorImpl_List) Set(i int, v ListIteratorImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s ListIteratorImpl_List) String() string {
	str, _ := text.MarshalList(0x88b9bf32c2da2936, s.List)
	return str
}

// ListIteratorImpl_Promise is a wrapper for a ListIteratorImpl promised by a client call.
type ListIteratorImpl_Promise struct{ *capnp.Pipeline }

func (p ListIteratorImpl_Promise) Struct() (ListIteratorImpl, error) {
	s, err := p.Pipeline.Struct()
	return ListIteratorImpl{s}, err
}

func (p ListIteratorImpl_Promise) Num() AsNum_Promise {
	return AsNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListIteratorImpl_Promise) Rec() AsRec_Promise {
	return AsRec_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListIteratorImpl_Promise) Txt() AsTxt_Promise {
	return AsTxt_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ListSource struct{ capnp.Struct }

// ListSource_TypeID is the unique identifier for the type ListSource.
const ListSource_TypeID = 0x9d227eff4bd296d9

func NewListSource(s *capnp.Segment) (ListSource, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListSource{st}, err
}

func NewRootListSource(s *capnp.Segment) (ListSource, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListSource{st}, err
}

func ReadRootListSource(msg *capnp.Message) (ListSource, error) {
	root, err := msg.RootPtr()
	return ListSource{root.Struct()}, err
}

func (s ListSource) String() string {
	str, _ := text.Marshal(0x9d227eff4bd296d9, s.Struct)
	return str
}

func (s ListSource) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s ListSource) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListSource) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s ListSource) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s ListSource) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// ListSource_List is a list of ListSource.
type ListSource_List struct{ capnp.List }

// NewListSource creates a new list of ListSource.
func NewListSource_List(s *capnp.Segment, sz int32) (ListSource_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return ListSource_List{l}, err
}

func (s ListSource_List) At(i int) ListSource { return ListSource{s.List.Struct(i)} }

func (s ListSource_List) Set(i int, v ListSource) error { return s.List.SetStruct(i, v.Struct) }

func (s ListSource_List) String() string {
	str, _ := text.MarshalList(0x9d227eff4bd296d9, s.List)
	return str
}

// ListSource_Promise is a wrapper for a ListSource promised by a client call.
type ListSource_Promise struct{ *capnp.Pipeline }

func (p ListSource_Promise) Struct() (ListSource, error) {
	s, err := p.Pipeline.Struct()
	return ListSource{s}, err
}

func (p ListSource_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type ListSourceImpl struct{ capnp.Struct }
type ListSourceImpl_Which uint16

const (
	ListSourceImpl_Which_nums ListSourceImpl_Which = 0
	ListSourceImpl_Which_recs ListSourceImpl_Which = 1
	ListSourceImpl_Which_txts ListSourceImpl_Which = 2
)

func (w ListSourceImpl_Which) String() string {
	const s = "numsrecstxts"
	switch w {
	case ListSourceImpl_Which_nums:
		return s[0:4]
	case ListSourceImpl_Which_recs:
		return s[4:8]
	case ListSourceImpl_Which_txts:
		return s[8:12]

	}
	return "ListSourceImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ListSourceImpl_TypeID is the unique identifier for the type ListSourceImpl.
const ListSourceImpl_TypeID = 0x8b0eceb92e275c06

func NewListSourceImpl(s *capnp.Segment) (ListSourceImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListSourceImpl{st}, err
}

func NewRootListSourceImpl(s *capnp.Segment) (ListSourceImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListSourceImpl{st}, err
}

func ReadRootListSourceImpl(msg *capnp.Message) (ListSourceImpl, error) {
	root, err := msg.RootPtr()
	return ListSourceImpl{root.Struct()}, err
}

func (s ListSourceImpl) String() string {
	str, _ := text.Marshal(0x8b0eceb92e275c06, s.Struct)
	return str
}

func (s ListSourceImpl) Which() ListSourceImpl_Which {
	return ListSourceImpl_Which(s.Struct.Uint16(0))
}
func (s ListSourceImpl) Nums() (FromNumList, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != nums")
	}
	p, err := s.Struct.Ptr(0)
	return FromNumList{Struct: p.Struct()}, err
}

func (s ListSourceImpl) HasNums() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListSourceImpl) SetNums(v FromNumList) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNums sets the nums field to a newly
// allocated FromNumList struct, preferring placement in s's segment.
func (s ListSourceImpl) NewNums() (FromNumList, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewFromNumList(s.Struct.Segment())
	if err != nil {
		return FromNumList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListSourceImpl) Recs() (FromRecList, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != recs")
	}
	p, err := s.Struct.Ptr(0)
	return FromRecList{Struct: p.Struct()}, err
}

func (s ListSourceImpl) HasRecs() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListSourceImpl) SetRecs(v FromRecList) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRecs sets the recs field to a newly
// allocated FromRecList struct, preferring placement in s's segment.
func (s ListSourceImpl) NewRecs() (FromRecList, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewFromRecList(s.Struct.Segment())
	if err != nil {
		return FromRecList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListSourceImpl) Txts() (FromTxtList, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != txts")
	}
	p, err := s.Struct.Ptr(0)
	return FromTxtList{Struct: p.Struct()}, err
}

func (s ListSourceImpl) HasTxts() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListSourceImpl) SetTxts(v FromTxtList) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxts sets the txts field to a newly
// allocated FromTxtList struct, preferring placement in s's segment.
func (s ListSourceImpl) NewTxts() (FromTxtList, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewFromTxtList(s.Struct.Segment())
	if err != nil {
		return FromTxtList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ListSourceImpl_List is a list of ListSourceImpl.
type ListSourceImpl_List struct{ capnp.List }

// NewListSourceImpl creates a new list of ListSourceImpl.
func NewListSourceImpl_List(s *capnp.Segment, sz int32) (ListSourceImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ListSourceImpl_List{l}, err
}

func (s ListSourceImpl_List) At(i int) ListSourceImpl { return ListSourceImpl{s.List.Struct(i)} }

func (s ListSourceImpl_List) Set(i int, v ListSourceImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s ListSourceImpl_List) String() string {
	str, _ := text.MarshalList(0x8b0eceb92e275c06, s.List)
	return str
}

// ListSourceImpl_Promise is a wrapper for a ListSourceImpl promised by a client call.
type ListSourceImpl_Promise struct{ *capnp.Pipeline }

func (p ListSourceImpl_Promise) Struct() (ListSourceImpl, error) {
	s, err := p.Pipeline.Struct()
	return ListSourceImpl{s}, err
}

func (p ListSourceImpl_Promise) Nums() FromNumList_Promise {
	return FromNumList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListSourceImpl_Promise) Recs() FromRecList_Promise {
	return FromRecList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListSourceImpl_Promise) Txts() FromTxtList_Promise {
	return FromTxtList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ListTarget struct{ capnp.Struct }

// ListTarget_TypeID is the unique identifier for the type ListTarget.
const ListTarget_TypeID = 0xe58557d333ec51da

func NewListTarget(s *capnp.Segment) (ListTarget, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListTarget{st}, err
}

func NewRootListTarget(s *capnp.Segment) (ListTarget, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListTarget{st}, err
}

func ReadRootListTarget(msg *capnp.Message) (ListTarget, error) {
	root, err := msg.RootPtr()
	return ListTarget{root.Struct()}, err
}

func (s ListTarget) String() string {
	str, _ := text.Marshal(0xe58557d333ec51da, s.Struct)
	return str
}

func (s ListTarget) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s ListTarget) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListTarget) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s ListTarget) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s ListTarget) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// ListTarget_List is a list of ListTarget.
type ListTarget_List struct{ capnp.List }

// NewListTarget creates a new list of ListTarget.
func NewListTarget_List(s *capnp.Segment, sz int32) (ListTarget_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return ListTarget_List{l}, err
}

func (s ListTarget_List) At(i int) ListTarget { return ListTarget{s.List.Struct(i)} }

func (s ListTarget_List) Set(i int, v ListTarget) error { return s.List.SetStruct(i, v.Struct) }

func (s ListTarget_List) String() string {
	str, _ := text.MarshalList(0xe58557d333ec51da, s.List)
	return str
}

// ListTarget_Promise is a wrapper for a ListTarget promised by a client call.
type ListTarget_Promise struct{ *capnp.Pipeline }

func (p ListTarget_Promise) Struct() (ListTarget, error) {
	s, err := p.Pipeline.Struct()
	return ListTarget{s}, err
}

func (p ListTarget_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type ListTargetImpl struct{ capnp.Struct }
type ListTargetImpl_Which uint16

const (
	ListTargetImpl_Which_nums ListTargetImpl_Which = 0
	ListTargetImpl_Which_recs ListTargetImpl_Which = 1
	ListTargetImpl_Which_txts ListTargetImpl_Which = 2
)

func (w ListTargetImpl_Which) String() string {
	const s = "numsrecstxts"
	switch w {
	case ListTargetImpl_Which_nums:
		return s[0:4]
	case ListTargetImpl_Which_recs:
		return s[4:8]
	case ListTargetImpl_Which_txts:
		return s[8:12]

	}
	return "ListTargetImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ListTargetImpl_TypeID is the unique identifier for the type ListTargetImpl.
const ListTargetImpl_TypeID = 0x9ef7ea3ddadddb80

func NewListTargetImpl(s *capnp.Segment) (ListTargetImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListTargetImpl{st}, err
}

func NewRootListTargetImpl(s *capnp.Segment) (ListTargetImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ListTargetImpl{st}, err
}

func ReadRootListTargetImpl(msg *capnp.Message) (ListTargetImpl, error) {
	root, err := msg.RootPtr()
	return ListTargetImpl{root.Struct()}, err
}

func (s ListTargetImpl) String() string {
	str, _ := text.Marshal(0x9ef7ea3ddadddb80, s.Struct)
	return str
}

func (s ListTargetImpl) Which() ListTargetImpl_Which {
	return ListTargetImpl_Which(s.Struct.Uint16(0))
}
func (s ListTargetImpl) Nums() (IntoNumList, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != nums")
	}
	p, err := s.Struct.Ptr(0)
	return IntoNumList{Struct: p.Struct()}, err
}

func (s ListTargetImpl) HasNums() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListTargetImpl) SetNums(v IntoNumList) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNums sets the nums field to a newly
// allocated IntoNumList struct, preferring placement in s's segment.
func (s ListTargetImpl) NewNums() (IntoNumList, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewIntoNumList(s.Struct.Segment())
	if err != nil {
		return IntoNumList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListTargetImpl) Recs() (IntoRecList, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != recs")
	}
	p, err := s.Struct.Ptr(0)
	return IntoRecList{Struct: p.Struct()}, err
}

func (s ListTargetImpl) HasRecs() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListTargetImpl) SetRecs(v IntoRecList) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRecs sets the recs field to a newly
// allocated IntoRecList struct, preferring placement in s's segment.
func (s ListTargetImpl) NewRecs() (IntoRecList, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewIntoRecList(s.Struct.Segment())
	if err != nil {
		return IntoRecList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ListTargetImpl) Txts() (IntoTxtList, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != txts")
	}
	p, err := s.Struct.Ptr(0)
	return IntoTxtList{Struct: p.Struct()}, err
}

func (s ListTargetImpl) HasTxts() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ListTargetImpl) SetTxts(v IntoTxtList) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxts sets the txts field to a newly
// allocated IntoTxtList struct, preferring placement in s's segment.
func (s ListTargetImpl) NewTxts() (IntoTxtList, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewIntoTxtList(s.Struct.Segment())
	if err != nil {
		return IntoTxtList{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ListTargetImpl_List is a list of ListTargetImpl.
type ListTargetImpl_List struct{ capnp.List }

// NewListTargetImpl creates a new list of ListTargetImpl.
func NewListTargetImpl_List(s *capnp.Segment, sz int32) (ListTargetImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ListTargetImpl_List{l}, err
}

func (s ListTargetImpl_List) At(i int) ListTargetImpl { return ListTargetImpl{s.List.Struct(i)} }

func (s ListTargetImpl_List) Set(i int, v ListTargetImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s ListTargetImpl_List) String() string {
	str, _ := text.MarshalList(0x9ef7ea3ddadddb80, s.List)
	return str
}

// ListTargetImpl_Promise is a wrapper for a ListTargetImpl promised by a client call.
type ListTargetImpl_Promise struct{ *capnp.Pipeline }

func (p ListTargetImpl_Promise) Struct() (ListTargetImpl, error) {
	s, err := p.Pipeline.Struct()
	return ListTargetImpl{s}, err
}

func (p ListTargetImpl_Promise) Nums() IntoNumList_Promise {
	return IntoNumList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListTargetImpl_Promise) Recs() IntoRecList_Promise {
	return IntoRecList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ListTargetImpl_Promise) Txts() IntoTxtList_Promise {
	return IntoTxtList_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type NumListEval struct{ capnp.Struct }

// NumListEval_TypeID is the unique identifier for the type NumListEval.
const NumListEval_TypeID = 0xb6919d1572e7b344

func NewNumListEval(s *capnp.Segment) (NumListEval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NumListEval{st}, err
}

func NewRootNumListEval(s *capnp.Segment) (NumListEval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NumListEval{st}, err
}

func ReadRootNumListEval(msg *capnp.Message) (NumListEval, error) {
	root, err := msg.RootPtr()
	return NumListEval{root.Struct()}, err
}

func (s NumListEval) String() string {
	str, _ := text.Marshal(0xb6919d1572e7b344, s.Struct)
	return str
}

func (s NumListEval) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s NumListEval) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEval) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s NumListEval) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s NumListEval) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// NumListEval_List is a list of NumListEval.
type NumListEval_List struct{ capnp.List }

// NewNumListEval creates a new list of NumListEval.
func NewNumListEval_List(s *capnp.Segment, sz int32) (NumListEval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return NumListEval_List{l}, err
}

func (s NumListEval_List) At(i int) NumListEval { return NumListEval{s.List.Struct(i)} }

func (s NumListEval_List) Set(i int, v NumListEval) error { return s.List.SetStruct(i, v.Struct) }

func (s NumListEval_List) String() string {
	str, _ := text.MarshalList(0xb6919d1572e7b344, s.List)
	return str
}

// NumListEval_Promise is a wrapper for a NumListEval promised by a client call.
type NumListEval_Promise struct{ *capnp.Pipeline }

func (p NumListEval_Promise) Struct() (NumListEval, error) {
	s, err := p.Pipeline.Struct()
	return NumListEval{s}, err
}

func (p NumListEval_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type NumListEvalImpl struct{ capnp.Struct }
type NumListEvalImpl_Which uint16

const (
	NumListEvalImpl_Which_determineArgs           NumListEvalImpl_Which = 0
	NumListEvalImpl_Which_getFrom                 NumListEvalImpl_Which = 1
	NumListEvalImpl_Which_nums                    NumListEvalImpl_Which = 2
	NumListEvalImpl_Which_range                   NumListEvalImpl_Which = 3
	NumListEvalImpl_Which_rangeByStep             NumListEvalImpl_Which = 4
	NumListEvalImpl_Which_rangeFrom               NumListEvalImpl_Which = 5
	NumListEvalImpl_Which_rangeFromByStep         NumListEvalImpl_Which = 6
	NumListEvalImpl_Which_renderArgs              NumListEvalImpl_Which = 7
	NumListEvalImpl_Which_renderRefFlags          NumListEvalImpl_Which = 8
	NumListEvalImpl_Which_slice                   NumListEvalImpl_Which = 9
	NumListEvalImpl_Which_sliceEnd                NumListEvalImpl_Which = 10
	NumListEvalImpl_Which_sliceStart              NumListEvalImpl_Which = 11
	NumListEvalImpl_Which_sliceStartEnd           NumListEvalImpl_Which = 12
	NumListEvalImpl_Which_spliceStartRemoveInsert NumListEvalImpl_Which = 13
	NumListEvalImpl_Which_var                     NumListEvalImpl_Which = 14
)

func (w NumListEvalImpl_Which) String() string {
	const s = "determineArgsgetFromnumsrangerangeBySteprangeFromrangeFromBySteprenderArgsrenderRefFlagsslicesliceEndsliceStartsliceStartEndspliceStartRemoveInsertvar"
	switch w {
	case NumListEvalImpl_Which_determineArgs:
		return s[0:13]
	case NumListEvalImpl_Which_getFrom:
		return s[13:20]
	case NumListEvalImpl_Which_nums:
		return s[20:24]
	case NumListEvalImpl_Which_range:
		return s[24:29]
	case NumListEvalImpl_Which_rangeByStep:
		return s[29:40]
	case NumListEvalImpl_Which_rangeFrom:
		return s[40:49]
	case NumListEvalImpl_Which_rangeFromByStep:
		return s[49:64]
	case NumListEvalImpl_Which_renderArgs:
		return s[64:74]
	case NumListEvalImpl_Which_renderRefFlags:
		return s[74:88]
	case NumListEvalImpl_Which_slice:
		return s[88:93]
	case NumListEvalImpl_Which_sliceEnd:
		return s[93:101]
	case NumListEvalImpl_Which_sliceStart:
		return s[101:111]
	case NumListEvalImpl_Which_sliceStartEnd:
		return s[111:124]
	case NumListEvalImpl_Which_spliceStartRemoveInsert:
		return s[124:147]
	case NumListEvalImpl_Which_var:
		return s[147:150]

	}
	return "NumListEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// NumListEvalImpl_TypeID is the unique identifier for the type NumListEvalImpl.
const NumListEvalImpl_TypeID = 0xa99e9b876aeb6d08

func NewNumListEvalImpl(s *capnp.Segment) (NumListEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return NumListEvalImpl{st}, err
}

func NewRootNumListEvalImpl(s *capnp.Segment) (NumListEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return NumListEvalImpl{st}, err
}

func ReadRootNumListEvalImpl(msg *capnp.Message) (NumListEvalImpl, error) {
	root, err := msg.RootPtr()
	return NumListEvalImpl{root.Struct()}, err
}

func (s NumListEvalImpl) String() string {
	str, _ := text.Marshal(0xa99e9b876aeb6d08, s.Struct)
	return str
}

func (s NumListEvalImpl) Which() NumListEvalImpl_Which {
	return NumListEvalImpl_Which(s.Struct.Uint16(0))
}
func (s NumListEvalImpl) DetermineArgs() (Determine, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Determine{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetDetermineArgs(v Determine) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated Determine struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewDetermineArgs() (Determine, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewDetermine(s.Struct.Segment())
	if err != nil {
		return Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) GetFrom() (GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return GetAtField{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetGetFrom(v GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated GetAtField struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewGetFrom() (GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewGetAtField(s.Struct.Segment())
	if err != nil {
		return GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) Nums() (Numbers, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != nums")
	}
	p, err := s.Struct.Ptr(0)
	return Numbers{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasNums() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetNums(v Numbers) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNums sets the nums field to a newly
// allocated Numbers struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewNums() (Numbers, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewNumbers(s.Struct.Segment())
	if err != nil {
		return Numbers{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) Range() (Range, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != range")
	}
	p, err := s.Struct.Ptr(0)
	return Range{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRange() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRange(v Range) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRange sets the range field to a newly
// allocated Range struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRange() (Range, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewRange(s.Struct.Segment())
	if err != nil {
		return Range{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RangeByStep() (Range, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != rangeByStep")
	}
	p, err := s.Struct.Ptr(0)
	return Range{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRangeByStep() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRangeByStep(v Range) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRangeByStep sets the rangeByStep field to a newly
// allocated Range struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRangeByStep() (Range, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewRange(s.Struct.Segment())
	if err != nil {
		return Range{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RangeFrom() (Range, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != rangeFrom")
	}
	p, err := s.Struct.Ptr(0)
	return Range{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRangeFrom() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRangeFrom(v Range) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRangeFrom sets the rangeFrom field to a newly
// allocated Range struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRangeFrom() (Range, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewRange(s.Struct.Segment())
	if err != nil {
		return Range{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RangeFromByStep() (Range, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != rangeFromByStep")
	}
	p, err := s.Struct.Ptr(0)
	return Range{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRangeFromByStep() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRangeFromByStep(v Range) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRangeFromByStep sets the rangeFromByStep field to a newly
// allocated Range struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRangeFromByStep() (Range, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewRange(s.Struct.Segment())
	if err != nil {
		return Range{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) RenderRefFlags() (RenderRef, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return RenderRef{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetRenderRefFlags(v RenderRef) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated RenderRef struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewRenderRefFlags() (RenderRef, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewRenderRef(s.Struct.Segment())
	if err != nil {
		return RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) Slice() (Slice, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != slice")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSlice() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSlice(v Slice) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSlice sets the slice field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSlice() (Slice, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) SliceEnd() (Slice, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != sliceEnd")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSliceEnd() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSliceEnd(v Slice) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceEnd sets the sliceEnd field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSliceEnd() (Slice, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) SliceStart() (Slice, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != sliceStart")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSliceStart() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSliceStart(v Slice) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStart sets the sliceStart field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSliceStart() (Slice, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) SliceStartEnd() (Slice, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != sliceStartEnd")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSliceStartEnd() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSliceStartEnd(v Slice) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStartEnd sets the sliceStartEnd field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSliceStartEnd() (Slice, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) SpliceStartRemoveInsert() (Splice, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != spliceStartRemoveInsert")
	}
	p, err := s.Struct.Ptr(0)
	return Splice{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasSpliceStartRemoveInsert() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetSpliceStartRemoveInsert(v Splice) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpliceStartRemoveInsert sets the spliceStartRemoveInsert field to a newly
// allocated Splice struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewSpliceStartRemoveInsert() (Splice, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := NewSplice(s.Struct.Segment())
	if err != nil {
		return Splice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumListEvalImpl) Var() (Var, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return Var{Struct: p.Struct()}, err
}

func (s NumListEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumListEvalImpl) SetVar(v Var) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated Var struct, preferring placement in s's segment.
func (s NumListEvalImpl) NewVar() (Var, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := NewVar(s.Struct.Segment())
	if err != nil {
		return Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// NumListEvalImpl_List is a list of NumListEvalImpl.
type NumListEvalImpl_List struct{ capnp.List }

// NewNumListEvalImpl creates a new list of NumListEvalImpl.
func NewNumListEvalImpl_List(s *capnp.Segment, sz int32) (NumListEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return NumListEvalImpl_List{l}, err
}

func (s NumListEvalImpl_List) At(i int) NumListEvalImpl { return NumListEvalImpl{s.List.Struct(i)} }

func (s NumListEvalImpl_List) Set(i int, v NumListEvalImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s NumListEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xa99e9b876aeb6d08, s.List)
	return str
}

// NumListEvalImpl_Promise is a wrapper for a NumListEvalImpl promised by a client call.
type NumListEvalImpl_Promise struct{ *capnp.Pipeline }

func (p NumListEvalImpl_Promise) Struct() (NumListEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return NumListEvalImpl{s}, err
}

func (p NumListEvalImpl_Promise) DetermineArgs() Determine_Promise {
	return Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) GetFrom() GetAtField_Promise {
	return GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) Nums() Numbers_Promise {
	return Numbers_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) Range() Range_Promise {
	return Range_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RangeByStep() Range_Promise {
	return Range_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RangeFrom() Range_Promise {
	return Range_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RangeFromByStep() Range_Promise {
	return Range_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) RenderRefFlags() RenderRef_Promise {
	return RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) Slice() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) SliceEnd() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) SliceStart() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) SliceStartEnd() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) SpliceStartRemoveInsert() Splice_Promise {
	return Splice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumListEvalImpl_Promise) Var() Var_Promise {
	return Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type NumberEval struct{ capnp.Struct }

// NumberEval_TypeID is the unique identifier for the type NumberEval.
const NumberEval_TypeID = 0xef087f977e163f61

func NewNumberEval(s *capnp.Segment) (NumberEval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NumberEval{st}, err
}

func NewRootNumberEval(s *capnp.Segment) (NumberEval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NumberEval{st}, err
}

func ReadRootNumberEval(msg *capnp.Message) (NumberEval, error) {
	root, err := msg.RootPtr()
	return NumberEval{root.Struct()}, err
}

func (s NumberEval) String() string {
	str, _ := text.Marshal(0xef087f977e163f61, s.Struct)
	return str
}

func (s NumberEval) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s NumberEval) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEval) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s NumberEval) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s NumberEval) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// NumberEval_List is a list of NumberEval.
type NumberEval_List struct{ capnp.List }

// NewNumberEval creates a new list of NumberEval.
func NewNumberEval_List(s *capnp.Segment, sz int32) (NumberEval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return NumberEval_List{l}, err
}

func (s NumberEval_List) At(i int) NumberEval { return NumberEval{s.List.Struct(i)} }

func (s NumberEval_List) Set(i int, v NumberEval) error { return s.List.SetStruct(i, v.Struct) }

func (s NumberEval_List) String() string {
	str, _ := text.MarshalList(0xef087f977e163f61, s.List)
	return str
}

// NumberEval_Promise is a wrapper for a NumberEval promised by a client call.
type NumberEval_Promise struct{ *capnp.Pipeline }

func (p NumberEval_Promise) Struct() (NumberEval, error) {
	s, err := p.Pipeline.Struct()
	return NumberEval{s}, err
}

func (p NumberEval_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type NumberEvalImpl struct{ capnp.Struct }
type NumberEvalImpl_Which uint16

const (
	NumberEvalImpl_Which_dec            NumberEvalImpl_Which = 0
	NumberEvalImpl_Which_decBy          NumberEvalImpl_Which = 1
	NumberEvalImpl_Which_determineArgs  NumberEvalImpl_Which = 2
	NumberEvalImpl_Which_divBy          NumberEvalImpl_Which = 3
	NumberEvalImpl_Which_during         NumberEvalImpl_Which = 4
	NumberEvalImpl_Which_findList       NumberEvalImpl_Which = 5
	NumberEvalImpl_Which_getFrom        NumberEvalImpl_Which = 6
	NumberEvalImpl_Which_getIndex       NumberEvalImpl_Which = 7
	NumberEvalImpl_Which_inc            NumberEvalImpl_Which = 8
	NumberEvalImpl_Which_incBy          NumberEvalImpl_Which = 9
	NumberEvalImpl_Which_len            NumberEvalImpl_Which = 10
	NumberEvalImpl_Which_modBy          NumberEvalImpl_Which = 11
	NumberEvalImpl_Which_mulBy          NumberEvalImpl_Which = 12
	NumberEvalImpl_Which_num            NumberEvalImpl_Which = 13
	NumberEvalImpl_Which_numIfElse      NumberEvalImpl_Which = 14
	NumberEvalImpl_Which_renderArgs     NumberEvalImpl_Which = 15
	NumberEvalImpl_Which_renderRefFlags NumberEvalImpl_Which = 16
	NumberEvalImpl_Which_var            NumberEvalImpl_Which = 17
)

func (w NumberEvalImpl_Which) String() string {
	const s = "decdecBydetermineArgsdivByduringfindListgetFromgetIndexincincBylenmodBymulBynumnumIfElserenderArgsrenderRefFlagsvar"
	switch w {
	case NumberEvalImpl_Which_dec:
		return s[0:3]
	case NumberEvalImpl_Which_decBy:
		return s[3:8]
	case NumberEvalImpl_Which_determineArgs:
		return s[8:21]
	case NumberEvalImpl_Which_divBy:
		return s[21:26]
	case NumberEvalImpl_Which_during:
		return s[26:32]
	case NumberEvalImpl_Which_findList:
		return s[32:40]
	case NumberEvalImpl_Which_getFrom:
		return s[40:47]
	case NumberEvalImpl_Which_getIndex:
		return s[47:55]
	case NumberEvalImpl_Which_inc:
		return s[55:58]
	case NumberEvalImpl_Which_incBy:
		return s[58:63]
	case NumberEvalImpl_Which_len:
		return s[63:66]
	case NumberEvalImpl_Which_modBy:
		return s[66:71]
	case NumberEvalImpl_Which_mulBy:
		return s[71:76]
	case NumberEvalImpl_Which_num:
		return s[76:79]
	case NumberEvalImpl_Which_numIfElse:
		return s[79:88]
	case NumberEvalImpl_Which_renderArgs:
		return s[88:98]
	case NumberEvalImpl_Which_renderRefFlags:
		return s[98:112]
	case NumberEvalImpl_Which_var:
		return s[112:115]

	}
	return "NumberEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// NumberEvalImpl_TypeID is the unique identifier for the type NumberEvalImpl.
const NumberEvalImpl_TypeID = 0xdbafe9a684c47d3e

func NewNumberEvalImpl(s *capnp.Segment) (NumberEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return NumberEvalImpl{st}, err
}

func NewRootNumberEvalImpl(s *capnp.Segment) (NumberEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return NumberEvalImpl{st}, err
}

func ReadRootNumberEvalImpl(msg *capnp.Message) (NumberEvalImpl, error) {
	root, err := msg.RootPtr()
	return NumberEvalImpl{root.Struct()}, err
}

func (s NumberEvalImpl) String() string {
	str, _ := text.Marshal(0xdbafe9a684c47d3e, s.Struct)
	return str
}

func (s NumberEvalImpl) Which() NumberEvalImpl_Which {
	return NumberEvalImpl_Which(s.Struct.Uint16(0))
}
func (s NumberEvalImpl) Dec() (DiffOf, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != dec")
	}
	p, err := s.Struct.Ptr(0)
	return DiffOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDec() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDec(v DiffOf) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDec sets the dec field to a newly
// allocated DiffOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDec() (DiffOf, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewDiffOf(s.Struct.Segment())
	if err != nil {
		return DiffOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) DecBy() (DiffOf, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != decBy")
	}
	p, err := s.Struct.Ptr(0)
	return DiffOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDecBy() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDecBy(v DiffOf) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDecBy sets the decBy field to a newly
// allocated DiffOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDecBy() (DiffOf, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewDiffOf(s.Struct.Segment())
	if err != nil {
		return DiffOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) DetermineArgs() (Determine, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Determine{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDetermineArgs(v Determine) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated Determine struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDetermineArgs() (Determine, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewDetermine(s.Struct.Segment())
	if err != nil {
		return Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) DivBy() (QuotientOf, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != divBy")
	}
	p, err := s.Struct.Ptr(0)
	return QuotientOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDivBy() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDivBy(v QuotientOf) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDivBy sets the divBy field to a newly
// allocated QuotientOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDivBy() (QuotientOf, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewQuotientOf(s.Struct.Segment())
	if err != nil {
		return QuotientOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) During() (During, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != during")
	}
	p, err := s.Struct.Ptr(0)
	return During{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasDuring() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetDuring(v During) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDuring sets the during field to a newly
// allocated During struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewDuring() (During, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewDuring(s.Struct.Segment())
	if err != nil {
		return During{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) FindList() (Find, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != findList")
	}
	p, err := s.Struct.Ptr(0)
	return Find{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasFindList() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetFindList(v Find) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFindList sets the findList field to a newly
// allocated Find struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewFindList() (Find, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewFind(s.Struct.Segment())
	if err != nil {
		return Find{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) GetFrom() (GetAtField, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return GetAtField{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetGetFrom(v GetAtField) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated GetAtField struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewGetFrom() (GetAtField, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewGetAtField(s.Struct.Segment())
	if err != nil {
		return GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) GetIndex() (At, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != getIndex")
	}
	p, err := s.Struct.Ptr(0)
	return At{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasGetIndex() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetGetIndex(v At) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetIndex sets the getIndex field to a newly
// allocated At struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewGetIndex() (At, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewAt(s.Struct.Segment())
	if err != nil {
		return At{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) Inc() (SumOf, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != inc")
	}
	p, err := s.Struct.Ptr(0)
	return SumOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasInc() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetInc(v SumOf) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewInc sets the inc field to a newly
// allocated SumOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewInc() (SumOf, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewSumOf(s.Struct.Segment())
	if err != nil {
		return SumOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) IncBy() (SumOf, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != incBy")
	}
	p, err := s.Struct.Ptr(0)
	return SumOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasIncBy() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetIncBy(v SumOf) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIncBy sets the incBy field to a newly
// allocated SumOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewIncBy() (SumOf, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := NewSumOf(s.Struct.Segment())
	if err != nil {
		return SumOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) Len() (Len, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != len")
	}
	p, err := s.Struct.Ptr(0)
	return Len{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasLen() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetLen(v Len) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLen sets the len field to a newly
// allocated Len struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewLen() (Len, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := NewLen(s.Struct.Segment())
	if err != nil {
		return Len{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) ModBy() (RemainderOf, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != modBy")
	}
	p, err := s.Struct.Ptr(0)
	return RemainderOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasModBy() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetModBy(v RemainderOf) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewModBy sets the modBy field to a newly
// allocated RemainderOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewModBy() (RemainderOf, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := NewRemainderOf(s.Struct.Segment())
	if err != nil {
		return RemainderOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) MulBy() (ProductOf, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != mulBy")
	}
	p, err := s.Struct.Ptr(0)
	return ProductOf{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasMulBy() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetMulBy(v ProductOf) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMulBy sets the mulBy field to a newly
// allocated ProductOf struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewMulBy() (ProductOf, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := NewProductOf(s.Struct.Segment())
	if err != nil {
		return ProductOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) Num() (Number, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != num")
	}
	p, err := s.Struct.Ptr(0)
	return Number{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasNum() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetNum(v Number) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated Number struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewNum() (Number, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := NewNumber(s.Struct.Segment())
	if err != nil {
		return Number{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) NumIfElse() (ChooseNum, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != numIfElse")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseNum{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasNumIfElse() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetNumIfElse(v ChooseNum) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNumIfElse sets the numIfElse field to a newly
// allocated ChooseNum struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewNumIfElse() (ChooseNum, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := NewChooseNum(s.Struct.Segment())
	if err != nil {
		return ChooseNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 15)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) RenderRefFlags() (RenderRef, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return RenderRef{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetRenderRefFlags(v RenderRef) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated RenderRef struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewRenderRefFlags() (RenderRef, error) {
	s.Struct.SetUint16(0, 16)
	ss, err := NewRenderRef(s.Struct.Segment())
	if err != nil {
		return RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s NumberEvalImpl) Var() (Var, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return Var{Struct: p.Struct()}, err
}

func (s NumberEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NumberEvalImpl) SetVar(v Var) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated Var struct, preferring placement in s's segment.
func (s NumberEvalImpl) NewVar() (Var, error) {
	s.Struct.SetUint16(0, 17)
	ss, err := NewVar(s.Struct.Segment())
	if err != nil {
		return Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// NumberEvalImpl_List is a list of NumberEvalImpl.
type NumberEvalImpl_List struct{ capnp.List }

// NewNumberEvalImpl creates a new list of NumberEvalImpl.
func NewNumberEvalImpl_List(s *capnp.Segment, sz int32) (NumberEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return NumberEvalImpl_List{l}, err
}

func (s NumberEvalImpl_List) At(i int) NumberEvalImpl { return NumberEvalImpl{s.List.Struct(i)} }

func (s NumberEvalImpl_List) Set(i int, v NumberEvalImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s NumberEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xdbafe9a684c47d3e, s.List)
	return str
}

// NumberEvalImpl_Promise is a wrapper for a NumberEvalImpl promised by a client call.
type NumberEvalImpl_Promise struct{ *capnp.Pipeline }

func (p NumberEvalImpl_Promise) Struct() (NumberEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return NumberEvalImpl{s}, err
}

func (p NumberEvalImpl_Promise) Dec() DiffOf_Promise {
	return DiffOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) DecBy() DiffOf_Promise {
	return DiffOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) DetermineArgs() Determine_Promise {
	return Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) DivBy() QuotientOf_Promise {
	return QuotientOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) During() During_Promise {
	return During_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) FindList() Find_Promise {
	return Find_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) GetFrom() GetAtField_Promise {
	return GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) GetIndex() At_Promise {
	return At_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) Inc() SumOf_Promise {
	return SumOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) IncBy() SumOf_Promise {
	return SumOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) Len() Len_Promise {
	return Len_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) ModBy() RemainderOf_Promise {
	return RemainderOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) MulBy() ProductOf_Promise {
	return ProductOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) Num() Number_Promise {
	return Number_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) NumIfElse() ChooseNum_Promise {
	return ChooseNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) RenderRefFlags() RenderRef_Promise {
	return RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p NumberEvalImpl_Promise) Var() Var_Promise {
	return Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type RecordEval struct{ capnp.Struct }

// RecordEval_TypeID is the unique identifier for the type RecordEval.
const RecordEval_TypeID = 0x8b61b7396e31a557

func NewRecordEval(s *capnp.Segment) (RecordEval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RecordEval{st}, err
}

func NewRootRecordEval(s *capnp.Segment) (RecordEval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RecordEval{st}, err
}

func ReadRootRecordEval(msg *capnp.Message) (RecordEval, error) {
	root, err := msg.RootPtr()
	return RecordEval{root.Struct()}, err
}

func (s RecordEval) String() string {
	str, _ := text.Marshal(0x8b61b7396e31a557, s.Struct)
	return str
}

func (s RecordEval) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s RecordEval) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEval) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s RecordEval) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s RecordEval) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// RecordEval_List is a list of RecordEval.
type RecordEval_List struct{ capnp.List }

// NewRecordEval creates a new list of RecordEval.
func NewRecordEval_List(s *capnp.Segment, sz int32) (RecordEval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return RecordEval_List{l}, err
}

func (s RecordEval_List) At(i int) RecordEval { return RecordEval{s.List.Struct(i)} }

func (s RecordEval_List) Set(i int, v RecordEval) error { return s.List.SetStruct(i, v.Struct) }

func (s RecordEval_List) String() string {
	str, _ := text.MarshalList(0x8b61b7396e31a557, s.List)
	return str
}

// RecordEval_Promise is a wrapper for a RecordEval promised by a client call.
type RecordEval_Promise struct{ *capnp.Pipeline }

func (p RecordEval_Promise) Struct() (RecordEval, error) {
	s, err := p.Pipeline.Struct()
	return RecordEval{s}, err
}

func (p RecordEval_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type RecordEvalImpl struct{ capnp.Struct }
type RecordEvalImpl_Which uint16

const (
	RecordEvalImpl_Which_determineArgs  RecordEvalImpl_Which = 0
	RecordEvalImpl_Which_getFrom        RecordEvalImpl_Which = 1
	RecordEvalImpl_Which_getIndex       RecordEvalImpl_Which = 2
	RecordEvalImpl_Which_makeArgs       RecordEvalImpl_Which = 3
	RecordEvalImpl_Which_renderArgs     RecordEvalImpl_Which = 4
	RecordEvalImpl_Which_renderRefFlags RecordEvalImpl_Which = 5
	RecordEvalImpl_Which_var            RecordEvalImpl_Which = 6
)

func (w RecordEvalImpl_Which) String() string {
	const s = "determineArgsgetFromgetIndexmakeArgsrenderArgsrenderRefFlagsvar"
	switch w {
	case RecordEvalImpl_Which_determineArgs:
		return s[0:13]
	case RecordEvalImpl_Which_getFrom:
		return s[13:20]
	case RecordEvalImpl_Which_getIndex:
		return s[20:28]
	case RecordEvalImpl_Which_makeArgs:
		return s[28:36]
	case RecordEvalImpl_Which_renderArgs:
		return s[36:46]
	case RecordEvalImpl_Which_renderRefFlags:
		return s[46:60]
	case RecordEvalImpl_Which_var:
		return s[60:63]

	}
	return "RecordEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// RecordEvalImpl_TypeID is the unique identifier for the type RecordEvalImpl.
const RecordEvalImpl_TypeID = 0xa449468eb28ad189

func NewRecordEvalImpl(s *capnp.Segment) (RecordEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RecordEvalImpl{st}, err
}

func NewRootRecordEvalImpl(s *capnp.Segment) (RecordEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RecordEvalImpl{st}, err
}

func ReadRootRecordEvalImpl(msg *capnp.Message) (RecordEvalImpl, error) {
	root, err := msg.RootPtr()
	return RecordEvalImpl{root.Struct()}, err
}

func (s RecordEvalImpl) String() string {
	str, _ := text.Marshal(0xa449468eb28ad189, s.Struct)
	return str
}

func (s RecordEvalImpl) Which() RecordEvalImpl_Which {
	return RecordEvalImpl_Which(s.Struct.Uint16(0))
}
func (s RecordEvalImpl) DetermineArgs() (Determine, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Determine{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetDetermineArgs(v Determine) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated Determine struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewDetermineArgs() (Determine, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewDetermine(s.Struct.Segment())
	if err != nil {
		return Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) GetFrom() (GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return GetAtField{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetGetFrom(v GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated GetAtField struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewGetFrom() (GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewGetAtField(s.Struct.Segment())
	if err != nil {
		return GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) GetIndex() (At, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != getIndex")
	}
	p, err := s.Struct.Ptr(0)
	return At{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasGetIndex() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetGetIndex(v At) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetIndex sets the getIndex field to a newly
// allocated At struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewGetIndex() (At, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewAt(s.Struct.Segment())
	if err != nil {
		return At{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) MakeArgs() (Make, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != makeArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Make{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasMakeArgs() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetMakeArgs(v Make) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMakeArgs sets the makeArgs field to a newly
// allocated Make struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewMakeArgs() (Make, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewMake(s.Struct.Segment())
	if err != nil {
		return Make{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) RenderRefFlags() (RenderRef, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return RenderRef{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetRenderRefFlags(v RenderRef) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated RenderRef struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewRenderRefFlags() (RenderRef, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewRenderRef(s.Struct.Segment())
	if err != nil {
		return RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordEvalImpl) Var() (Var, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return Var{Struct: p.Struct()}, err
}

func (s RecordEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordEvalImpl) SetVar(v Var) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated Var struct, preferring placement in s's segment.
func (s RecordEvalImpl) NewVar() (Var, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewVar(s.Struct.Segment())
	if err != nil {
		return Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// RecordEvalImpl_List is a list of RecordEvalImpl.
type RecordEvalImpl_List struct{ capnp.List }

// NewRecordEvalImpl creates a new list of RecordEvalImpl.
func NewRecordEvalImpl_List(s *capnp.Segment, sz int32) (RecordEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return RecordEvalImpl_List{l}, err
}

func (s RecordEvalImpl_List) At(i int) RecordEvalImpl { return RecordEvalImpl{s.List.Struct(i)} }

func (s RecordEvalImpl_List) Set(i int, v RecordEvalImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s RecordEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xa449468eb28ad189, s.List)
	return str
}

// RecordEvalImpl_Promise is a wrapper for a RecordEvalImpl promised by a client call.
type RecordEvalImpl_Promise struct{ *capnp.Pipeline }

func (p RecordEvalImpl_Promise) Struct() (RecordEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return RecordEvalImpl{s}, err
}

func (p RecordEvalImpl_Promise) DetermineArgs() Determine_Promise {
	return Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) GetFrom() GetAtField_Promise {
	return GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) GetIndex() At_Promise {
	return At_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) MakeArgs() Make_Promise {
	return Make_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) RenderRefFlags() RenderRef_Promise {
	return RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordEvalImpl_Promise) Var() Var_Promise {
	return Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type RecordListEval struct{ capnp.Struct }

// RecordListEval_TypeID is the unique identifier for the type RecordListEval.
const RecordListEval_TypeID = 0x8d565c5237432e42

func NewRecordListEval(s *capnp.Segment) (RecordListEval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RecordListEval{st}, err
}

func NewRootRecordListEval(s *capnp.Segment) (RecordListEval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RecordListEval{st}, err
}

func ReadRootRecordListEval(msg *capnp.Message) (RecordListEval, error) {
	root, err := msg.RootPtr()
	return RecordListEval{root.Struct()}, err
}

func (s RecordListEval) String() string {
	str, _ := text.Marshal(0x8d565c5237432e42, s.Struct)
	return str
}

func (s RecordListEval) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s RecordListEval) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEval) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s RecordListEval) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s RecordListEval) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// RecordListEval_List is a list of RecordListEval.
type RecordListEval_List struct{ capnp.List }

// NewRecordListEval creates a new list of RecordListEval.
func NewRecordListEval_List(s *capnp.Segment, sz int32) (RecordListEval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return RecordListEval_List{l}, err
}

func (s RecordListEval_List) At(i int) RecordListEval { return RecordListEval{s.List.Struct(i)} }

func (s RecordListEval_List) Set(i int, v RecordListEval) error { return s.List.SetStruct(i, v.Struct) }

func (s RecordListEval_List) String() string {
	str, _ := text.MarshalList(0x8d565c5237432e42, s.List)
	return str
}

// RecordListEval_Promise is a wrapper for a RecordListEval promised by a client call.
type RecordListEval_Promise struct{ *capnp.Pipeline }

func (p RecordListEval_Promise) Struct() (RecordListEval, error) {
	s, err := p.Pipeline.Struct()
	return RecordListEval{s}, err
}

func (p RecordListEval_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type RecordListEvalImpl struct{ capnp.Struct }
type RecordListEvalImpl_Which uint16

const (
	RecordListEvalImpl_Which_determineArgs           RecordListEvalImpl_Which = 0
	RecordListEvalImpl_Which_getFrom                 RecordListEvalImpl_Which = 1
	RecordListEvalImpl_Which_renderArgs              RecordListEvalImpl_Which = 2
	RecordListEvalImpl_Which_renderRefFlags          RecordListEvalImpl_Which = 3
	RecordListEvalImpl_Which_slice                   RecordListEvalImpl_Which = 4
	RecordListEvalImpl_Which_sliceEnd                RecordListEvalImpl_Which = 5
	RecordListEvalImpl_Which_sliceStart              RecordListEvalImpl_Which = 6
	RecordListEvalImpl_Which_sliceStartEnd           RecordListEvalImpl_Which = 7
	RecordListEvalImpl_Which_spliceStartRemoveInsert RecordListEvalImpl_Which = 8
	RecordListEvalImpl_Which_var                     RecordListEvalImpl_Which = 9
)

func (w RecordListEvalImpl_Which) String() string {
	const s = "determineArgsgetFromrenderArgsrenderRefFlagsslicesliceEndsliceStartsliceStartEndspliceStartRemoveInsertvar"
	switch w {
	case RecordListEvalImpl_Which_determineArgs:
		return s[0:13]
	case RecordListEvalImpl_Which_getFrom:
		return s[13:20]
	case RecordListEvalImpl_Which_renderArgs:
		return s[20:30]
	case RecordListEvalImpl_Which_renderRefFlags:
		return s[30:44]
	case RecordListEvalImpl_Which_slice:
		return s[44:49]
	case RecordListEvalImpl_Which_sliceEnd:
		return s[49:57]
	case RecordListEvalImpl_Which_sliceStart:
		return s[57:67]
	case RecordListEvalImpl_Which_sliceStartEnd:
		return s[67:80]
	case RecordListEvalImpl_Which_spliceStartRemoveInsert:
		return s[80:103]
	case RecordListEvalImpl_Which_var:
		return s[103:106]

	}
	return "RecordListEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// RecordListEvalImpl_TypeID is the unique identifier for the type RecordListEvalImpl.
const RecordListEvalImpl_TypeID = 0xee4d212526f6ffac

func NewRecordListEvalImpl(s *capnp.Segment) (RecordListEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RecordListEvalImpl{st}, err
}

func NewRootRecordListEvalImpl(s *capnp.Segment) (RecordListEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RecordListEvalImpl{st}, err
}

func ReadRootRecordListEvalImpl(msg *capnp.Message) (RecordListEvalImpl, error) {
	root, err := msg.RootPtr()
	return RecordListEvalImpl{root.Struct()}, err
}

func (s RecordListEvalImpl) String() string {
	str, _ := text.Marshal(0xee4d212526f6ffac, s.Struct)
	return str
}

func (s RecordListEvalImpl) Which() RecordListEvalImpl_Which {
	return RecordListEvalImpl_Which(s.Struct.Uint16(0))
}
func (s RecordListEvalImpl) DetermineArgs() (Determine, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Determine{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetDetermineArgs(v Determine) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated Determine struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewDetermineArgs() (Determine, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewDetermine(s.Struct.Segment())
	if err != nil {
		return Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) GetFrom() (GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return GetAtField{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetGetFrom(v GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated GetAtField struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewGetFrom() (GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewGetAtField(s.Struct.Segment())
	if err != nil {
		return GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) RenderRefFlags() (RenderRef, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return RenderRef{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetRenderRefFlags(v RenderRef) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated RenderRef struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewRenderRefFlags() (RenderRef, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewRenderRef(s.Struct.Segment())
	if err != nil {
		return RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) Slice() (Slice, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != slice")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSlice() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSlice(v Slice) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSlice sets the slice field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSlice() (Slice, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) SliceEnd() (Slice, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != sliceEnd")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSliceEnd() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSliceEnd(v Slice) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceEnd sets the sliceEnd field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSliceEnd() (Slice, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) SliceStart() (Slice, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != sliceStart")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSliceStart() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSliceStart(v Slice) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStart sets the sliceStart field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSliceStart() (Slice, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) SliceStartEnd() (Slice, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != sliceStartEnd")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSliceStartEnd() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSliceStartEnd(v Slice) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStartEnd sets the sliceStartEnd field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSliceStartEnd() (Slice, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) SpliceStartRemoveInsert() (Splice, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != spliceStartRemoveInsert")
	}
	p, err := s.Struct.Ptr(0)
	return Splice{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasSpliceStartRemoveInsert() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetSpliceStartRemoveInsert(v Splice) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpliceStartRemoveInsert sets the spliceStartRemoveInsert field to a newly
// allocated Splice struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewSpliceStartRemoveInsert() (Splice, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewSplice(s.Struct.Segment())
	if err != nil {
		return Splice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RecordListEvalImpl) Var() (Var, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return Var{Struct: p.Struct()}, err
}

func (s RecordListEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RecordListEvalImpl) SetVar(v Var) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated Var struct, preferring placement in s's segment.
func (s RecordListEvalImpl) NewVar() (Var, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := NewVar(s.Struct.Segment())
	if err != nil {
		return Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// RecordListEvalImpl_List is a list of RecordListEvalImpl.
type RecordListEvalImpl_List struct{ capnp.List }

// NewRecordListEvalImpl creates a new list of RecordListEvalImpl.
func NewRecordListEvalImpl_List(s *capnp.Segment, sz int32) (RecordListEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return RecordListEvalImpl_List{l}, err
}

func (s RecordListEvalImpl_List) At(i int) RecordListEvalImpl {
	return RecordListEvalImpl{s.List.Struct(i)}
}

func (s RecordListEvalImpl_List) Set(i int, v RecordListEvalImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s RecordListEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xee4d212526f6ffac, s.List)
	return str
}

// RecordListEvalImpl_Promise is a wrapper for a RecordListEvalImpl promised by a client call.
type RecordListEvalImpl_Promise struct{ *capnp.Pipeline }

func (p RecordListEvalImpl_Promise) Struct() (RecordListEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return RecordListEvalImpl{s}, err
}

func (p RecordListEvalImpl_Promise) DetermineArgs() Determine_Promise {
	return Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) GetFrom() GetAtField_Promise {
	return GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) RenderRefFlags() RenderRef_Promise {
	return RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) Slice() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) SliceEnd() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) SliceStart() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) SliceStartEnd() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) SpliceStartRemoveInsert() Splice_Promise {
	return Splice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RecordListEvalImpl_Promise) Var() Var_Promise {
	return Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ScannerMaker struct{ capnp.Struct }

// ScannerMaker_TypeID is the unique identifier for the type ScannerMaker.
const ScannerMaker_TypeID = 0xe1163d1396252641

func NewScannerMaker(s *capnp.Segment) (ScannerMaker, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ScannerMaker{st}, err
}

func NewRootScannerMaker(s *capnp.Segment) (ScannerMaker, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ScannerMaker{st}, err
}

func ReadRootScannerMaker(msg *capnp.Message) (ScannerMaker, error) {
	root, err := msg.RootPtr()
	return ScannerMaker{root.Struct()}, err
}

func (s ScannerMaker) String() string {
	str, _ := text.Marshal(0xe1163d1396252641, s.Struct)
	return str
}

func (s ScannerMaker) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s ScannerMaker) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMaker) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s ScannerMaker) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s ScannerMaker) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// ScannerMaker_List is a list of ScannerMaker.
type ScannerMaker_List struct{ capnp.List }

// NewScannerMaker creates a new list of ScannerMaker.
func NewScannerMaker_List(s *capnp.Segment, sz int32) (ScannerMaker_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return ScannerMaker_List{l}, err
}

func (s ScannerMaker_List) At(i int) ScannerMaker { return ScannerMaker{s.List.Struct(i)} }

func (s ScannerMaker_List) Set(i int, v ScannerMaker) error { return s.List.SetStruct(i, v.Struct) }

func (s ScannerMaker_List) String() string {
	str, _ := text.MarshalList(0xe1163d1396252641, s.List)
	return str
}

// ScannerMaker_Promise is a wrapper for a ScannerMaker promised by a client call.
type ScannerMaker_Promise struct{ *capnp.Pipeline }

func (p ScannerMaker_Promise) Struct() (ScannerMaker, error) {
	s, err := p.Pipeline.Struct()
	return ScannerMaker{s}, err
}

func (p ScannerMaker_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type ScannerMakerImpl struct{ capnp.Struct }
type ScannerMakerImpl_Which uint16

const (
	ScannerMakerImpl_Which_allOf    ScannerMakerImpl_Which = 0
	ScannerMakerImpl_Which_anyOf    ScannerMakerImpl_Which = 1
	ScannerMakerImpl_Which_as       ScannerMakerImpl_Which = 2
	ScannerMakerImpl_Which_noun     ScannerMakerImpl_Which = 3
	ScannerMakerImpl_Which_retarget ScannerMakerImpl_Which = 4
	ScannerMakerImpl_Which_reverse  ScannerMakerImpl_Which = 5
	ScannerMakerImpl_Which_self     ScannerMakerImpl_Which = 6
	ScannerMakerImpl_Which_words    ScannerMakerImpl_Which = 7
)

func (w ScannerMakerImpl_Which) String() string {
	const s = "allOfanyOfasnounretargetreverseselfwords"
	switch w {
	case ScannerMakerImpl_Which_allOf:
		return s[0:5]
	case ScannerMakerImpl_Which_anyOf:
		return s[5:10]
	case ScannerMakerImpl_Which_as:
		return s[10:12]
	case ScannerMakerImpl_Which_noun:
		return s[12:16]
	case ScannerMakerImpl_Which_retarget:
		return s[16:24]
	case ScannerMakerImpl_Which_reverse:
		return s[24:31]
	case ScannerMakerImpl_Which_self:
		return s[31:35]
	case ScannerMakerImpl_Which_words:
		return s[35:40]

	}
	return "ScannerMakerImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// ScannerMakerImpl_TypeID is the unique identifier for the type ScannerMakerImpl.
const ScannerMakerImpl_TypeID = 0xe071a1982c51cc6f

func NewScannerMakerImpl(s *capnp.Segment) (ScannerMakerImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ScannerMakerImpl{st}, err
}

func NewRootScannerMakerImpl(s *capnp.Segment) (ScannerMakerImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return ScannerMakerImpl{st}, err
}

func ReadRootScannerMakerImpl(msg *capnp.Message) (ScannerMakerImpl, error) {
	root, err := msg.RootPtr()
	return ScannerMakerImpl{root.Struct()}, err
}

func (s ScannerMakerImpl) String() string {
	str, _ := text.Marshal(0xe071a1982c51cc6f, s.Struct)
	return str
}

func (s ScannerMakerImpl) Which() ScannerMakerImpl_Which {
	return ScannerMakerImpl_Which(s.Struct.Uint16(0))
}
func (s ScannerMakerImpl) AllOf() (AllOf, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != allOf")
	}
	p, err := s.Struct.Ptr(0)
	return AllOf{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasAllOf() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetAllOf(v AllOf) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAllOf sets the allOf field to a newly
// allocated AllOf struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewAllOf() (AllOf, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewAllOf(s.Struct.Segment())
	if err != nil {
		return AllOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) AnyOf() (AnyOf, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != anyOf")
	}
	p, err := s.Struct.Ptr(0)
	return AnyOf{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasAnyOf() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetAnyOf(v AnyOf) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAnyOf sets the anyOf field to a newly
// allocated AnyOf struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewAnyOf() (AnyOf, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewAnyOf(s.Struct.Segment())
	if err != nil {
		return AnyOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) As() (Action, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != as")
	}
	p, err := s.Struct.Ptr(0)
	return Action{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasAs() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetAs(v Action) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAs sets the as field to a newly
// allocated Action struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewAs() (Action, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewAction(s.Struct.Segment())
	if err != nil {
		return Action{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Noun() (Noun, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != noun")
	}
	p, err := s.Struct.Ptr(0)
	return Noun{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasNoun() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetNoun(v Noun) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNoun sets the noun field to a newly
// allocated Noun struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewNoun() (Noun, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewNoun(s.Struct.Segment())
	if err != nil {
		return Noun{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Retarget() (Retarget, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != retarget")
	}
	p, err := s.Struct.Ptr(0)
	return Retarget{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasRetarget() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetRetarget(v Retarget) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRetarget sets the retarget field to a newly
// allocated Retarget struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewRetarget() (Retarget, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewRetarget(s.Struct.Segment())
	if err != nil {
		return Retarget{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Reverse() (Reverse, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != reverse")
	}
	p, err := s.Struct.Ptr(0)
	return Reverse{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasReverse() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetReverse(v Reverse) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReverse sets the reverse field to a newly
// allocated Reverse struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewReverse() (Reverse, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewReverse(s.Struct.Segment())
	if err != nil {
		return Reverse{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Self() (Self, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != self")
	}
	p, err := s.Struct.Ptr(0)
	return Self{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasSelf() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetSelf(v Self) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSelf sets the self field to a newly
// allocated Self struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewSelf() (Self, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewSelf(s.Struct.Segment())
	if err != nil {
		return Self{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ScannerMakerImpl) Words() (Words, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != words")
	}
	p, err := s.Struct.Ptr(0)
	return Words{Struct: p.Struct()}, err
}

func (s ScannerMakerImpl) HasWords() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ScannerMakerImpl) SetWords(v Words) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewWords sets the words field to a newly
// allocated Words struct, preferring placement in s's segment.
func (s ScannerMakerImpl) NewWords() (Words, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewWords(s.Struct.Segment())
	if err != nil {
		return Words{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ScannerMakerImpl_List is a list of ScannerMakerImpl.
type ScannerMakerImpl_List struct{ capnp.List }

// NewScannerMakerImpl creates a new list of ScannerMakerImpl.
func NewScannerMakerImpl_List(s *capnp.Segment, sz int32) (ScannerMakerImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return ScannerMakerImpl_List{l}, err
}

func (s ScannerMakerImpl_List) At(i int) ScannerMakerImpl { return ScannerMakerImpl{s.List.Struct(i)} }

func (s ScannerMakerImpl_List) Set(i int, v ScannerMakerImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s ScannerMakerImpl_List) String() string {
	str, _ := text.MarshalList(0xe071a1982c51cc6f, s.List)
	return str
}

// ScannerMakerImpl_Promise is a wrapper for a ScannerMakerImpl promised by a client call.
type ScannerMakerImpl_Promise struct{ *capnp.Pipeline }

func (p ScannerMakerImpl_Promise) Struct() (ScannerMakerImpl, error) {
	s, err := p.Pipeline.Struct()
	return ScannerMakerImpl{s}, err
}

func (p ScannerMakerImpl_Promise) AllOf() AllOf_Promise {
	return AllOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) AnyOf() AnyOf_Promise {
	return AnyOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) As() Action_Promise {
	return Action_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Noun() Noun_Promise {
	return Noun_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Retarget() Retarget_Promise {
	return Retarget_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Reverse() Reverse_Promise {
	return Reverse_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Self() Self_Promise {
	return Self_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ScannerMakerImpl_Promise) Words() Words_Promise {
	return Words_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type TextEval struct{ capnp.Struct }

// TextEval_TypeID is the unique identifier for the type TextEval.
const TextEval_TypeID = 0x8aae1e7149605b6f

func NewTextEval(s *capnp.Segment) (TextEval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return TextEval{st}, err
}

func NewRootTextEval(s *capnp.Segment) (TextEval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return TextEval{st}, err
}

func ReadRootTextEval(msg *capnp.Message) (TextEval, error) {
	root, err := msg.RootPtr()
	return TextEval{root.Struct()}, err
}

func (s TextEval) String() string {
	str, _ := text.Marshal(0x8aae1e7149605b6f, s.Struct)
	return str
}

func (s TextEval) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s TextEval) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEval) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s TextEval) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s TextEval) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// TextEval_List is a list of TextEval.
type TextEval_List struct{ capnp.List }

// NewTextEval creates a new list of TextEval.
func NewTextEval_List(s *capnp.Segment, sz int32) (TextEval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return TextEval_List{l}, err
}

func (s TextEval_List) At(i int) TextEval { return TextEval{s.List.Struct(i)} }

func (s TextEval_List) Set(i int, v TextEval) error { return s.List.SetStruct(i, v.Struct) }

func (s TextEval_List) String() string {
	str, _ := text.MarshalList(0x8aae1e7149605b6f, s.List)
	return str
}

// TextEval_Promise is a wrapper for a TextEval promised by a client call.
type TextEval_Promise struct{ *capnp.Pipeline }

func (p TextEval_Promise) Struct() (TextEval, error) {
	s, err := p.Pipeline.Struct()
	return TextEval{s}, err
}

func (p TextEval_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type TextEvalImpl struct{ capnp.Struct }
type TextEvalImpl_Which uint16

const (
	TextEvalImpl_Which_bracketTextDo       TextEvalImpl_Which = 0
	TextEvalImpl_Which_bufferTextDo        TextEvalImpl_Which = 1
	TextEvalImpl_Which_capitalize          TextEvalImpl_Which = 2
	TextEvalImpl_Which_commaTextDo         TextEvalImpl_Which = 3
	TextEvalImpl_Which_cycle               TextEvalImpl_Which = 4
	TextEvalImpl_Which_determineArgs       TextEvalImpl_Which = 5
	TextEvalImpl_Which_getFrom             TextEvalImpl_Which = 6
	TextEvalImpl_Which_getIndex            TextEvalImpl_Which = 7
	TextEvalImpl_Which_idOf                TextEvalImpl_Which = 8
	TextEvalImpl_Which_joinParts           TextEvalImpl_Which = 9
	TextEvalImpl_Which_kindOf              TextEvalImpl_Which = 10
	TextEvalImpl_Which_lower               TextEvalImpl_Which = 11
	TextEvalImpl_Which_nameOf              TextEvalImpl_Which = 12
	TextEvalImpl_Which_numeralWords        TextEvalImpl_Which = 13
	TextEvalImpl_Which_numeral             TextEvalImpl_Which = 14
	TextEvalImpl_Which_pluralize           TextEvalImpl_Which = 15
	TextEvalImpl_Which_reciprocalRelObject TextEvalImpl_Which = 16
	TextEvalImpl_Which_relativeRelObject   TextEvalImpl_Which = 17
	TextEvalImpl_Which_renderArgs          TextEvalImpl_Which = 18
	TextEvalImpl_Which_renderName          TextEvalImpl_Which = 19
	TextEvalImpl_Which_renderRefFlags      TextEvalImpl_Which = 20
	TextEvalImpl_Which_renderTemplate      TextEvalImpl_Which = 21
	TextEvalImpl_Which_response            TextEvalImpl_Which = 22
	TextEvalImpl_Which_responseText        TextEvalImpl_Which = 23
	TextEvalImpl_Which_reverse             TextEvalImpl_Which = 24
	TextEvalImpl_Which_rowDo               TextEvalImpl_Which = 25
	TextEvalImpl_Which_rowsDo              TextEvalImpl_Which = 26
	TextEvalImpl_Which_sentence            TextEvalImpl_Which = 27
	TextEvalImpl_Which_shuffle             TextEvalImpl_Which = 28
	TextEvalImpl_Which_singularize         TextEvalImpl_Which = 29
	TextEvalImpl_Which_slashTextDo         TextEvalImpl_Which = 30
	TextEvalImpl_Which_spanTextDo          TextEvalImpl_Which = 31
	TextEvalImpl_Which_stopping            TextEvalImpl_Which = 32
	TextEvalImpl_Which_title               TextEvalImpl_Which = 33
	TextEvalImpl_Which_txt                 TextEvalImpl_Which = 34
	TextEvalImpl_Which_txtIfElse           TextEvalImpl_Which = 35
	TextEvalImpl_Which_upper               TextEvalImpl_Which = 36
	TextEvalImpl_Which_var                 TextEvalImpl_Which = 37
)

func (w TextEvalImpl_Which) String() string {
	const s = "bracketTextDobufferTextDocapitalizecommaTextDocycledetermineArgsgetFromgetIndexidOfjoinPartskindOflowernameOfnumeralWordsnumeralpluralizereciprocalRelObjectrelativeRelObjectrenderArgsrenderNamerenderRefFlagsrenderTemplateresponseresponseTextreverserowDorowsDosentenceshufflesingularizeslashTextDospanTextDostoppingtitletxttxtIfElseuppervar"
	switch w {
	case TextEvalImpl_Which_bracketTextDo:
		return s[0:13]
	case TextEvalImpl_Which_bufferTextDo:
		return s[13:25]
	case TextEvalImpl_Which_capitalize:
		return s[25:35]
	case TextEvalImpl_Which_commaTextDo:
		return s[35:46]
	case TextEvalImpl_Which_cycle:
		return s[46:51]
	case TextEvalImpl_Which_determineArgs:
		return s[51:64]
	case TextEvalImpl_Which_getFrom:
		return s[64:71]
	case TextEvalImpl_Which_getIndex:
		return s[71:79]
	case TextEvalImpl_Which_idOf:
		return s[79:83]
	case TextEvalImpl_Which_joinParts:
		return s[83:92]
	case TextEvalImpl_Which_kindOf:
		return s[92:98]
	case TextEvalImpl_Which_lower:
		return s[98:103]
	case TextEvalImpl_Which_nameOf:
		return s[103:109]
	case TextEvalImpl_Which_numeralWords:
		return s[109:121]
	case TextEvalImpl_Which_numeral:
		return s[121:128]
	case TextEvalImpl_Which_pluralize:
		return s[128:137]
	case TextEvalImpl_Which_reciprocalRelObject:
		return s[137:156]
	case TextEvalImpl_Which_relativeRelObject:
		return s[156:173]
	case TextEvalImpl_Which_renderArgs:
		return s[173:183]
	case TextEvalImpl_Which_renderName:
		return s[183:193]
	case TextEvalImpl_Which_renderRefFlags:
		return s[193:207]
	case TextEvalImpl_Which_renderTemplate:
		return s[207:221]
	case TextEvalImpl_Which_response:
		return s[221:229]
	case TextEvalImpl_Which_responseText:
		return s[229:241]
	case TextEvalImpl_Which_reverse:
		return s[241:248]
	case TextEvalImpl_Which_rowDo:
		return s[248:253]
	case TextEvalImpl_Which_rowsDo:
		return s[253:259]
	case TextEvalImpl_Which_sentence:
		return s[259:267]
	case TextEvalImpl_Which_shuffle:
		return s[267:274]
	case TextEvalImpl_Which_singularize:
		return s[274:285]
	case TextEvalImpl_Which_slashTextDo:
		return s[285:296]
	case TextEvalImpl_Which_spanTextDo:
		return s[296:306]
	case TextEvalImpl_Which_stopping:
		return s[306:314]
	case TextEvalImpl_Which_title:
		return s[314:319]
	case TextEvalImpl_Which_txt:
		return s[319:322]
	case TextEvalImpl_Which_txtIfElse:
		return s[322:331]
	case TextEvalImpl_Which_upper:
		return s[331:336]
	case TextEvalImpl_Which_var:
		return s[336:339]

	}
	return "TextEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TextEvalImpl_TypeID is the unique identifier for the type TextEvalImpl.
const TextEvalImpl_TypeID = 0xdf95941c6150b2a5

func NewTextEvalImpl(s *capnp.Segment) (TextEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TextEvalImpl{st}, err
}

func NewRootTextEvalImpl(s *capnp.Segment) (TextEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TextEvalImpl{st}, err
}

func ReadRootTextEvalImpl(msg *capnp.Message) (TextEvalImpl, error) {
	root, err := msg.RootPtr()
	return TextEvalImpl{root.Struct()}, err
}

func (s TextEvalImpl) String() string {
	str, _ := text.Marshal(0xdf95941c6150b2a5, s.Struct)
	return str
}

func (s TextEvalImpl) Which() TextEvalImpl_Which {
	return TextEvalImpl_Which(s.Struct.Uint16(0))
}
func (s TextEvalImpl) BracketTextDo() (Bracket, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != bracketTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return Bracket{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasBracketTextDo() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetBracketTextDo(v Bracket) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBracketTextDo sets the bracketTextDo field to a newly
// allocated Bracket struct, preferring placement in s's segment.
func (s TextEvalImpl) NewBracketTextDo() (Bracket, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewBracket(s.Struct.Segment())
	if err != nil {
		return Bracket{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) BufferTextDo() (Buffer, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != bufferTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return Buffer{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasBufferTextDo() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetBufferTextDo(v Buffer) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBufferTextDo sets the bufferTextDo field to a newly
// allocated Buffer struct, preferring placement in s's segment.
func (s TextEvalImpl) NewBufferTextDo() (Buffer, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewBuffer(s.Struct.Segment())
	if err != nil {
		return Buffer{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Capitalize() (Capitalize, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != capitalize")
	}
	p, err := s.Struct.Ptr(0)
	return Capitalize{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasCapitalize() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetCapitalize(v Capitalize) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCapitalize sets the capitalize field to a newly
// allocated Capitalize struct, preferring placement in s's segment.
func (s TextEvalImpl) NewCapitalize() (Capitalize, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewCapitalize(s.Struct.Segment())
	if err != nil {
		return Capitalize{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) CommaTextDo() (Commas, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != commaTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return Commas{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasCommaTextDo() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetCommaTextDo(v Commas) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCommaTextDo sets the commaTextDo field to a newly
// allocated Commas struct, preferring placement in s's segment.
func (s TextEvalImpl) NewCommaTextDo() (Commas, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewCommas(s.Struct.Segment())
	if err != nil {
		return Commas{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Cycle() (CycleText, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != cycle")
	}
	p, err := s.Struct.Ptr(0)
	return CycleText{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasCycle() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetCycle(v CycleText) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCycle sets the cycle field to a newly
// allocated CycleText struct, preferring placement in s's segment.
func (s TextEvalImpl) NewCycle() (CycleText, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewCycleText(s.Struct.Segment())
	if err != nil {
		return CycleText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) DetermineArgs() (Determine, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Determine{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetDetermineArgs(v Determine) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated Determine struct, preferring placement in s's segment.
func (s TextEvalImpl) NewDetermineArgs() (Determine, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewDetermine(s.Struct.Segment())
	if err != nil {
		return Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) GetFrom() (GetAtField, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return GetAtField{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetGetFrom(v GetAtField) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated GetAtField struct, preferring placement in s's segment.
func (s TextEvalImpl) NewGetFrom() (GetAtField, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewGetAtField(s.Struct.Segment())
	if err != nil {
		return GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) GetIndex() (At, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != getIndex")
	}
	p, err := s.Struct.Ptr(0)
	return At{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasGetIndex() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetGetIndex(v At) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetIndex sets the getIndex field to a newly
// allocated At struct, preferring placement in s's segment.
func (s TextEvalImpl) NewGetIndex() (At, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewAt(s.Struct.Segment())
	if err != nil {
		return At{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) IdOf() (IdOf, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != idOf")
	}
	p, err := s.Struct.Ptr(0)
	return IdOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasIdOf() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetIdOf(v IdOf) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIdOf sets the idOf field to a newly
// allocated IdOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewIdOf() (IdOf, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewIdOf(s.Struct.Segment())
	if err != nil {
		return IdOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) JoinParts() (Join, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != joinParts")
	}
	p, err := s.Struct.Ptr(0)
	return Join{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasJoinParts() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetJoinParts(v Join) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewJoinParts sets the joinParts field to a newly
// allocated Join struct, preferring placement in s's segment.
func (s TextEvalImpl) NewJoinParts() (Join, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := NewJoin(s.Struct.Segment())
	if err != nil {
		return Join{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) KindOf() (KindOf, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != kindOf")
	}
	p, err := s.Struct.Ptr(0)
	return KindOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasKindOf() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetKindOf(v KindOf) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKindOf sets the kindOf field to a newly
// allocated KindOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewKindOf() (KindOf, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := NewKindOf(s.Struct.Segment())
	if err != nil {
		return KindOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Lower() (MakeLowercase, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != lower")
	}
	p, err := s.Struct.Ptr(0)
	return MakeLowercase{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasLower() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetLower(v MakeLowercase) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLower sets the lower field to a newly
// allocated MakeLowercase struct, preferring placement in s's segment.
func (s TextEvalImpl) NewLower() (MakeLowercase, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := NewMakeLowercase(s.Struct.Segment())
	if err != nil {
		return MakeLowercase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) NameOf() (NameOf, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != nameOf")
	}
	p, err := s.Struct.Ptr(0)
	return NameOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasNameOf() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetNameOf(v NameOf) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNameOf sets the nameOf field to a newly
// allocated NameOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewNameOf() (NameOf, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := NewNameOf(s.Struct.Segment())
	if err != nil {
		return NameOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) NumeralWords() (PrintNumWord, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != numeralWords")
	}
	p, err := s.Struct.Ptr(0)
	return PrintNumWord{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasNumeralWords() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetNumeralWords(v PrintNumWord) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNumeralWords sets the numeralWords field to a newly
// allocated PrintNumWord struct, preferring placement in s's segment.
func (s TextEvalImpl) NewNumeralWords() (PrintNumWord, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := NewPrintNumWord(s.Struct.Segment())
	if err != nil {
		return PrintNumWord{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Numeral() (PrintNum, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != numeral")
	}
	p, err := s.Struct.Ptr(0)
	return PrintNum{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasNumeral() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetNumeral(v PrintNum) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNumeral sets the numeral field to a newly
// allocated PrintNum struct, preferring placement in s's segment.
func (s TextEvalImpl) NewNumeral() (PrintNum, error) {
	s.Struct.SetUint16(0, 14)
	ss, err := NewPrintNum(s.Struct.Segment())
	if err != nil {
		return PrintNum{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Pluralize() (MakePlural, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != pluralize")
	}
	p, err := s.Struct.Ptr(0)
	return MakePlural{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasPluralize() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetPluralize(v MakePlural) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPluralize sets the pluralize field to a newly
// allocated MakePlural struct, preferring placement in s's segment.
func (s TextEvalImpl) NewPluralize() (MakePlural, error) {
	s.Struct.SetUint16(0, 15)
	ss, err := NewMakePlural(s.Struct.Segment())
	if err != nil {
		return MakePlural{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) ReciprocalRelObject() (ReciprocalOf, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != reciprocalRelObject")
	}
	p, err := s.Struct.Ptr(0)
	return ReciprocalOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasReciprocalRelObject() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetReciprocalRelObject(v ReciprocalOf) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReciprocalRelObject sets the reciprocalRelObject field to a newly
// allocated ReciprocalOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewReciprocalRelObject() (ReciprocalOf, error) {
	s.Struct.SetUint16(0, 16)
	ss, err := NewReciprocalOf(s.Struct.Segment())
	if err != nil {
		return ReciprocalOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RelativeRelObject() (RelativeOf, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != relativeRelObject")
	}
	p, err := s.Struct.Ptr(0)
	return RelativeOf{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRelativeRelObject() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRelativeRelObject(v RelativeOf) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRelativeRelObject sets the relativeRelObject field to a newly
// allocated RelativeOf struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRelativeRelObject() (RelativeOf, error) {
	s.Struct.SetUint16(0, 17)
	ss, err := NewRelativeOf(s.Struct.Segment())
	if err != nil {
		return RelativeOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 18 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 18 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 18)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 18)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RenderName() (RenderName, error) {
	if s.Struct.Uint16(0) != 19 {
		panic("Which() != renderName")
	}
	p, err := s.Struct.Ptr(0)
	return RenderName{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRenderName() bool {
	if s.Struct.Uint16(0) != 19 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRenderName(v RenderName) error {
	s.Struct.SetUint16(0, 19)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderName sets the renderName field to a newly
// allocated RenderName struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRenderName() (RenderName, error) {
	s.Struct.SetUint16(0, 19)
	ss, err := NewRenderName(s.Struct.Segment())
	if err != nil {
		return RenderName{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RenderRefFlags() (RenderRef, error) {
	if s.Struct.Uint16(0) != 20 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return RenderRef{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 20 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRenderRefFlags(v RenderRef) error {
	s.Struct.SetUint16(0, 20)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated RenderRef struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRenderRefFlags() (RenderRef, error) {
	s.Struct.SetUint16(0, 20)
	ss, err := NewRenderRef(s.Struct.Segment())
	if err != nil {
		return RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RenderTemplate() (RenderTemplate, error) {
	if s.Struct.Uint16(0) != 21 {
		panic("Which() != renderTemplate")
	}
	p, err := s.Struct.Ptr(0)
	return RenderTemplate{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRenderTemplate() bool {
	if s.Struct.Uint16(0) != 21 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRenderTemplate(v RenderTemplate) error {
	s.Struct.SetUint16(0, 21)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderTemplate sets the renderTemplate field to a newly
// allocated RenderTemplate struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRenderTemplate() (RenderTemplate, error) {
	s.Struct.SetUint16(0, 21)
	ss, err := NewRenderTemplate(s.Struct.Segment())
	if err != nil {
		return RenderTemplate{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Response() (Response, error) {
	if s.Struct.Uint16(0) != 22 {
		panic("Which() != response")
	}
	p, err := s.Struct.Ptr(0)
	return Response{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasResponse() bool {
	if s.Struct.Uint16(0) != 22 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetResponse(v Response) error {
	s.Struct.SetUint16(0, 22)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewResponse sets the response field to a newly
// allocated Response struct, preferring placement in s's segment.
func (s TextEvalImpl) NewResponse() (Response, error) {
	s.Struct.SetUint16(0, 22)
	ss, err := NewResponse(s.Struct.Segment())
	if err != nil {
		return Response{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) ResponseText() (Response, error) {
	if s.Struct.Uint16(0) != 23 {
		panic("Which() != responseText")
	}
	p, err := s.Struct.Ptr(0)
	return Response{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasResponseText() bool {
	if s.Struct.Uint16(0) != 23 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetResponseText(v Response) error {
	s.Struct.SetUint16(0, 23)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewResponseText sets the responseText field to a newly
// allocated Response struct, preferring placement in s's segment.
func (s TextEvalImpl) NewResponseText() (Response, error) {
	s.Struct.SetUint16(0, 23)
	ss, err := NewResponse(s.Struct.Segment())
	if err != nil {
		return Response{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Reverse() (MakeReversed, error) {
	if s.Struct.Uint16(0) != 24 {
		panic("Which() != reverse")
	}
	p, err := s.Struct.Ptr(0)
	return MakeReversed{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasReverse() bool {
	if s.Struct.Uint16(0) != 24 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetReverse(v MakeReversed) error {
	s.Struct.SetUint16(0, 24)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReverse sets the reverse field to a newly
// allocated MakeReversed struct, preferring placement in s's segment.
func (s TextEvalImpl) NewReverse() (MakeReversed, error) {
	s.Struct.SetUint16(0, 24)
	ss, err := NewMakeReversed(s.Struct.Segment())
	if err != nil {
		return MakeReversed{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RowDo() (Row, error) {
	if s.Struct.Uint16(0) != 25 {
		panic("Which() != rowDo")
	}
	p, err := s.Struct.Ptr(0)
	return Row{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRowDo() bool {
	if s.Struct.Uint16(0) != 25 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRowDo(v Row) error {
	s.Struct.SetUint16(0, 25)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRowDo sets the rowDo field to a newly
// allocated Row struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRowDo() (Row, error) {
	s.Struct.SetUint16(0, 25)
	ss, err := NewRow(s.Struct.Segment())
	if err != nil {
		return Row{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) RowsDo() (Rows, error) {
	if s.Struct.Uint16(0) != 26 {
		panic("Which() != rowsDo")
	}
	p, err := s.Struct.Ptr(0)
	return Rows{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasRowsDo() bool {
	if s.Struct.Uint16(0) != 26 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetRowsDo(v Rows) error {
	s.Struct.SetUint16(0, 26)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRowsDo sets the rowsDo field to a newly
// allocated Rows struct, preferring placement in s's segment.
func (s TextEvalImpl) NewRowsDo() (Rows, error) {
	s.Struct.SetUint16(0, 26)
	ss, err := NewRows(s.Struct.Segment())
	if err != nil {
		return Rows{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Sentence() (MakeSentenceCase, error) {
	if s.Struct.Uint16(0) != 27 {
		panic("Which() != sentence")
	}
	p, err := s.Struct.Ptr(0)
	return MakeSentenceCase{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasSentence() bool {
	if s.Struct.Uint16(0) != 27 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetSentence(v MakeSentenceCase) error {
	s.Struct.SetUint16(0, 27)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSentence sets the sentence field to a newly
// allocated MakeSentenceCase struct, preferring placement in s's segment.
func (s TextEvalImpl) NewSentence() (MakeSentenceCase, error) {
	s.Struct.SetUint16(0, 27)
	ss, err := NewMakeSentenceCase(s.Struct.Segment())
	if err != nil {
		return MakeSentenceCase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Shuffle() (ShuffleText, error) {
	if s.Struct.Uint16(0) != 28 {
		panic("Which() != shuffle")
	}
	p, err := s.Struct.Ptr(0)
	return ShuffleText{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasShuffle() bool {
	if s.Struct.Uint16(0) != 28 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetShuffle(v ShuffleText) error {
	s.Struct.SetUint16(0, 28)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewShuffle sets the shuffle field to a newly
// allocated ShuffleText struct, preferring placement in s's segment.
func (s TextEvalImpl) NewShuffle() (ShuffleText, error) {
	s.Struct.SetUint16(0, 28)
	ss, err := NewShuffleText(s.Struct.Segment())
	if err != nil {
		return ShuffleText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Singularize() (MakeSingular, error) {
	if s.Struct.Uint16(0) != 29 {
		panic("Which() != singularize")
	}
	p, err := s.Struct.Ptr(0)
	return MakeSingular{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasSingularize() bool {
	if s.Struct.Uint16(0) != 29 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetSingularize(v MakeSingular) error {
	s.Struct.SetUint16(0, 29)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSingularize sets the singularize field to a newly
// allocated MakeSingular struct, preferring placement in s's segment.
func (s TextEvalImpl) NewSingularize() (MakeSingular, error) {
	s.Struct.SetUint16(0, 29)
	ss, err := NewMakeSingular(s.Struct.Segment())
	if err != nil {
		return MakeSingular{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) SlashTextDo() (Slash, error) {
	if s.Struct.Uint16(0) != 30 {
		panic("Which() != slashTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return Slash{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasSlashTextDo() bool {
	if s.Struct.Uint16(0) != 30 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetSlashTextDo(v Slash) error {
	s.Struct.SetUint16(0, 30)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSlashTextDo sets the slashTextDo field to a newly
// allocated Slash struct, preferring placement in s's segment.
func (s TextEvalImpl) NewSlashTextDo() (Slash, error) {
	s.Struct.SetUint16(0, 30)
	ss, err := NewSlash(s.Struct.Segment())
	if err != nil {
		return Slash{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) SpanTextDo() (Span, error) {
	if s.Struct.Uint16(0) != 31 {
		panic("Which() != spanTextDo")
	}
	p, err := s.Struct.Ptr(0)
	return Span{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasSpanTextDo() bool {
	if s.Struct.Uint16(0) != 31 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetSpanTextDo(v Span) error {
	s.Struct.SetUint16(0, 31)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpanTextDo sets the spanTextDo field to a newly
// allocated Span struct, preferring placement in s's segment.
func (s TextEvalImpl) NewSpanTextDo() (Span, error) {
	s.Struct.SetUint16(0, 31)
	ss, err := NewSpan(s.Struct.Segment())
	if err != nil {
		return Span{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Stopping() (StoppingText, error) {
	if s.Struct.Uint16(0) != 32 {
		panic("Which() != stopping")
	}
	p, err := s.Struct.Ptr(0)
	return StoppingText{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasStopping() bool {
	if s.Struct.Uint16(0) != 32 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetStopping(v StoppingText) error {
	s.Struct.SetUint16(0, 32)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStopping sets the stopping field to a newly
// allocated StoppingText struct, preferring placement in s's segment.
func (s TextEvalImpl) NewStopping() (StoppingText, error) {
	s.Struct.SetUint16(0, 32)
	ss, err := NewStoppingText(s.Struct.Segment())
	if err != nil {
		return StoppingText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Title() (MakeTitleCase, error) {
	if s.Struct.Uint16(0) != 33 {
		panic("Which() != title")
	}
	p, err := s.Struct.Ptr(0)
	return MakeTitleCase{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasTitle() bool {
	if s.Struct.Uint16(0) != 33 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetTitle(v MakeTitleCase) error {
	s.Struct.SetUint16(0, 33)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTitle sets the title field to a newly
// allocated MakeTitleCase struct, preferring placement in s's segment.
func (s TextEvalImpl) NewTitle() (MakeTitleCase, error) {
	s.Struct.SetUint16(0, 33)
	ss, err := NewMakeTitleCase(s.Struct.Segment())
	if err != nil {
		return MakeTitleCase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Txt() (Text, error) {
	if s.Struct.Uint16(0) != 34 {
		panic("Which() != txt")
	}
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasTxt() bool {
	if s.Struct.Uint16(0) != 34 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetTxt(v Text) error {
	s.Struct.SetUint16(0, 34)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxt sets the txt field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s TextEvalImpl) NewTxt() (Text, error) {
	s.Struct.SetUint16(0, 34)
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) TxtIfElse() (ChooseText, error) {
	if s.Struct.Uint16(0) != 35 {
		panic("Which() != txtIfElse")
	}
	p, err := s.Struct.Ptr(0)
	return ChooseText{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasTxtIfElse() bool {
	if s.Struct.Uint16(0) != 35 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetTxtIfElse(v ChooseText) error {
	s.Struct.SetUint16(0, 35)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxtIfElse sets the txtIfElse field to a newly
// allocated ChooseText struct, preferring placement in s's segment.
func (s TextEvalImpl) NewTxtIfElse() (ChooseText, error) {
	s.Struct.SetUint16(0, 35)
	ss, err := NewChooseText(s.Struct.Segment())
	if err != nil {
		return ChooseText{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Upper() (MakeUppercase, error) {
	if s.Struct.Uint16(0) != 36 {
		panic("Which() != upper")
	}
	p, err := s.Struct.Ptr(0)
	return MakeUppercase{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasUpper() bool {
	if s.Struct.Uint16(0) != 36 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetUpper(v MakeUppercase) error {
	s.Struct.SetUint16(0, 36)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewUpper sets the upper field to a newly
// allocated MakeUppercase struct, preferring placement in s's segment.
func (s TextEvalImpl) NewUpper() (MakeUppercase, error) {
	s.Struct.SetUint16(0, 36)
	ss, err := NewMakeUppercase(s.Struct.Segment())
	if err != nil {
		return MakeUppercase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextEvalImpl) Var() (Var, error) {
	if s.Struct.Uint16(0) != 37 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return Var{Struct: p.Struct()}, err
}

func (s TextEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 37 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextEvalImpl) SetVar(v Var) error {
	s.Struct.SetUint16(0, 37)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated Var struct, preferring placement in s's segment.
func (s TextEvalImpl) NewVar() (Var, error) {
	s.Struct.SetUint16(0, 37)
	ss, err := NewVar(s.Struct.Segment())
	if err != nil {
		return Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// TextEvalImpl_List is a list of TextEvalImpl.
type TextEvalImpl_List struct{ capnp.List }

// NewTextEvalImpl creates a new list of TextEvalImpl.
func NewTextEvalImpl_List(s *capnp.Segment, sz int32) (TextEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return TextEvalImpl_List{l}, err
}

func (s TextEvalImpl_List) At(i int) TextEvalImpl { return TextEvalImpl{s.List.Struct(i)} }

func (s TextEvalImpl_List) Set(i int, v TextEvalImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s TextEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xdf95941c6150b2a5, s.List)
	return str
}

// TextEvalImpl_Promise is a wrapper for a TextEvalImpl promised by a client call.
type TextEvalImpl_Promise struct{ *capnp.Pipeline }

func (p TextEvalImpl_Promise) Struct() (TextEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return TextEvalImpl{s}, err
}

func (p TextEvalImpl_Promise) BracketTextDo() Bracket_Promise {
	return Bracket_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) BufferTextDo() Buffer_Promise {
	return Buffer_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Capitalize() Capitalize_Promise {
	return Capitalize_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) CommaTextDo() Commas_Promise {
	return Commas_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Cycle() CycleText_Promise {
	return CycleText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) DetermineArgs() Determine_Promise {
	return Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) GetFrom() GetAtField_Promise {
	return GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) GetIndex() At_Promise {
	return At_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) IdOf() IdOf_Promise {
	return IdOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) JoinParts() Join_Promise {
	return Join_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) KindOf() KindOf_Promise {
	return KindOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Lower() MakeLowercase_Promise {
	return MakeLowercase_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) NameOf() NameOf_Promise {
	return NameOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) NumeralWords() PrintNumWord_Promise {
	return PrintNumWord_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Numeral() PrintNum_Promise {
	return PrintNum_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Pluralize() MakePlural_Promise {
	return MakePlural_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) ReciprocalRelObject() ReciprocalOf_Promise {
	return ReciprocalOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RelativeRelObject() RelativeOf_Promise {
	return RelativeOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RenderName() RenderName_Promise {
	return RenderName_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RenderRefFlags() RenderRef_Promise {
	return RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RenderTemplate() RenderTemplate_Promise {
	return RenderTemplate_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Response() Response_Promise {
	return Response_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) ResponseText() Response_Promise {
	return Response_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Reverse() MakeReversed_Promise {
	return MakeReversed_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RowDo() Row_Promise {
	return Row_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) RowsDo() Rows_Promise {
	return Rows_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Sentence() MakeSentenceCase_Promise {
	return MakeSentenceCase_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Shuffle() ShuffleText_Promise {
	return ShuffleText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Singularize() MakeSingular_Promise {
	return MakeSingular_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) SlashTextDo() Slash_Promise {
	return Slash_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) SpanTextDo() Span_Promise {
	return Span_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Stopping() StoppingText_Promise {
	return StoppingText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Title() MakeTitleCase_Promise {
	return MakeTitleCase_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Txt() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) TxtIfElse() ChooseText_Promise {
	return ChooseText_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Upper() MakeUppercase_Promise {
	return MakeUppercase_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextEvalImpl_Promise) Var() Var_Promise {
	return Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type TextListEval struct{ capnp.Struct }

// TextListEval_TypeID is the unique identifier for the type TextListEval.
const TextListEval_TypeID = 0x8a104f955ecccb16

func NewTextListEval(s *capnp.Segment) (TextListEval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return TextListEval{st}, err
}

func NewRootTextListEval(s *capnp.Segment) (TextListEval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return TextListEval{st}, err
}

func ReadRootTextListEval(msg *capnp.Message) (TextListEval, error) {
	root, err := msg.RootPtr()
	return TextListEval{root.Struct()}, err
}

func (s TextListEval) String() string {
	str, _ := text.Marshal(0x8a104f955ecccb16, s.Struct)
	return str
}

func (s TextListEval) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s TextListEval) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEval) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s TextListEval) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s TextListEval) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// TextListEval_List is a list of TextListEval.
type TextListEval_List struct{ capnp.List }

// NewTextListEval creates a new list of TextListEval.
func NewTextListEval_List(s *capnp.Segment, sz int32) (TextListEval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return TextListEval_List{l}, err
}

func (s TextListEval_List) At(i int) TextListEval { return TextListEval{s.List.Struct(i)} }

func (s TextListEval_List) Set(i int, v TextListEval) error { return s.List.SetStruct(i, v.Struct) }

func (s TextListEval_List) String() string {
	str, _ := text.MarshalList(0x8a104f955ecccb16, s.List)
	return str
}

// TextListEval_Promise is a wrapper for a TextListEval promised by a client call.
type TextListEval_Promise struct{ *capnp.Pipeline }

func (p TextListEval_Promise) Struct() (TextListEval, error) {
	s, err := p.Pipeline.Struct()
	return TextListEval{s}, err
}

func (p TextListEval_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type TextListEvalImpl struct{ capnp.Struct }
type TextListEvalImpl_Which uint16

const (
	TextListEvalImpl_Which_determineArgs           TextListEvalImpl_Which = 0
	TextListEvalImpl_Which_getFrom                 TextListEvalImpl_Which = 1
	TextListEvalImpl_Which_kindsOf                 TextListEvalImpl_Which = 2
	TextListEvalImpl_Which_reciprocalsRelObject    TextListEvalImpl_Which = 3
	TextListEvalImpl_Which_relativesRelObject      TextListEvalImpl_Which = 4
	TextListEvalImpl_Which_renderArgs              TextListEvalImpl_Which = 5
	TextListEvalImpl_Which_renderRefFlags          TextListEvalImpl_Which = 6
	TextListEvalImpl_Which_slice                   TextListEvalImpl_Which = 7
	TextListEvalImpl_Which_sliceEnd                TextListEvalImpl_Which = 8
	TextListEvalImpl_Which_sliceStart              TextListEvalImpl_Which = 9
	TextListEvalImpl_Which_sliceStartEnd           TextListEvalImpl_Which = 10
	TextListEvalImpl_Which_spliceStartRemoveInsert TextListEvalImpl_Which = 11
	TextListEvalImpl_Which_txts                    TextListEvalImpl_Which = 12
	TextListEvalImpl_Which_var                     TextListEvalImpl_Which = 13
)

func (w TextListEvalImpl_Which) String() string {
	const s = "determineArgsgetFromkindsOfreciprocalsRelObjectrelativesRelObjectrenderArgsrenderRefFlagsslicesliceEndsliceStartsliceStartEndspliceStartRemoveInserttxtsvar"
	switch w {
	case TextListEvalImpl_Which_determineArgs:
		return s[0:13]
	case TextListEvalImpl_Which_getFrom:
		return s[13:20]
	case TextListEvalImpl_Which_kindsOf:
		return s[20:27]
	case TextListEvalImpl_Which_reciprocalsRelObject:
		return s[27:47]
	case TextListEvalImpl_Which_relativesRelObject:
		return s[47:65]
	case TextListEvalImpl_Which_renderArgs:
		return s[65:75]
	case TextListEvalImpl_Which_renderRefFlags:
		return s[75:89]
	case TextListEvalImpl_Which_slice:
		return s[89:94]
	case TextListEvalImpl_Which_sliceEnd:
		return s[94:102]
	case TextListEvalImpl_Which_sliceStart:
		return s[102:112]
	case TextListEvalImpl_Which_sliceStartEnd:
		return s[112:125]
	case TextListEvalImpl_Which_spliceStartRemoveInsert:
		return s[125:148]
	case TextListEvalImpl_Which_txts:
		return s[148:152]
	case TextListEvalImpl_Which_var:
		return s[152:155]

	}
	return "TextListEvalImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TextListEvalImpl_TypeID is the unique identifier for the type TextListEvalImpl.
const TextListEvalImpl_TypeID = 0xe3f62895ddeecf83

func NewTextListEvalImpl(s *capnp.Segment) (TextListEvalImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TextListEvalImpl{st}, err
}

func NewRootTextListEvalImpl(s *capnp.Segment) (TextListEvalImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TextListEvalImpl{st}, err
}

func ReadRootTextListEvalImpl(msg *capnp.Message) (TextListEvalImpl, error) {
	root, err := msg.RootPtr()
	return TextListEvalImpl{root.Struct()}, err
}

func (s TextListEvalImpl) String() string {
	str, _ := text.Marshal(0xe3f62895ddeecf83, s.Struct)
	return str
}

func (s TextListEvalImpl) Which() TextListEvalImpl_Which {
	return TextListEvalImpl_Which(s.Struct.Uint16(0))
}
func (s TextListEvalImpl) DetermineArgs() (Determine, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != determineArgs")
	}
	p, err := s.Struct.Ptr(0)
	return Determine{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasDetermineArgs() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetDetermineArgs(v Determine) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDetermineArgs sets the determineArgs field to a newly
// allocated Determine struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewDetermineArgs() (Determine, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewDetermine(s.Struct.Segment())
	if err != nil {
		return Determine{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) GetFrom() (GetAtField, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != getFrom")
	}
	p, err := s.Struct.Ptr(0)
	return GetAtField{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasGetFrom() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetGetFrom(v GetAtField) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGetFrom sets the getFrom field to a newly
// allocated GetAtField struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewGetFrom() (GetAtField, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewGetAtField(s.Struct.Segment())
	if err != nil {
		return GetAtField{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) KindsOf() (KindsOf, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != kindsOf")
	}
	p, err := s.Struct.Ptr(0)
	return KindsOf{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasKindsOf() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetKindsOf(v KindsOf) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKindsOf sets the kindsOf field to a newly
// allocated KindsOf struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewKindsOf() (KindsOf, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewKindsOf(s.Struct.Segment())
	if err != nil {
		return KindsOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) ReciprocalsRelObject() (ReciprocalsOf, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != reciprocalsRelObject")
	}
	p, err := s.Struct.Ptr(0)
	return ReciprocalsOf{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasReciprocalsRelObject() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetReciprocalsRelObject(v ReciprocalsOf) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReciprocalsRelObject sets the reciprocalsRelObject field to a newly
// allocated ReciprocalsOf struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewReciprocalsRelObject() (ReciprocalsOf, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewReciprocalsOf(s.Struct.Segment())
	if err != nil {
		return ReciprocalsOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) RelativesRelObject() (RelativesOf, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != relativesRelObject")
	}
	p, err := s.Struct.Ptr(0)
	return RelativesOf{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasRelativesRelObject() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetRelativesRelObject(v RelativesOf) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRelativesRelObject sets the relativesRelObject field to a newly
// allocated RelativesOf struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewRelativesRelObject() (RelativesOf, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewRelativesOf(s.Struct.Segment())
	if err != nil {
		return RelativesOf{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) RenderArgs() (RenderPattern, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != renderArgs")
	}
	p, err := s.Struct.Ptr(0)
	return RenderPattern{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasRenderArgs() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetRenderArgs(v RenderPattern) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderArgs sets the renderArgs field to a newly
// allocated RenderPattern struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewRenderArgs() (RenderPattern, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewRenderPattern(s.Struct.Segment())
	if err != nil {
		return RenderPattern{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) RenderRefFlags() (RenderRef, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != renderRefFlags")
	}
	p, err := s.Struct.Ptr(0)
	return RenderRef{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasRenderRefFlags() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetRenderRefFlags(v RenderRef) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRenderRefFlags sets the renderRefFlags field to a newly
// allocated RenderRef struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewRenderRefFlags() (RenderRef, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewRenderRef(s.Struct.Segment())
	if err != nil {
		return RenderRef{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) Slice() (Slice, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != slice")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSlice() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSlice(v Slice) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSlice sets the slice field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSlice() (Slice, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) SliceEnd() (Slice, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != sliceEnd")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSliceEnd() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSliceEnd(v Slice) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceEnd sets the sliceEnd field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSliceEnd() (Slice, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) SliceStart() (Slice, error) {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != sliceStart")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSliceStart() bool {
	if s.Struct.Uint16(0) != 9 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSliceStart(v Slice) error {
	s.Struct.SetUint16(0, 9)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStart sets the sliceStart field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSliceStart() (Slice, error) {
	s.Struct.SetUint16(0, 9)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) SliceStartEnd() (Slice, error) {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != sliceStartEnd")
	}
	p, err := s.Struct.Ptr(0)
	return Slice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSliceStartEnd() bool {
	if s.Struct.Uint16(0) != 10 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSliceStartEnd(v Slice) error {
	s.Struct.SetUint16(0, 10)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSliceStartEnd sets the sliceStartEnd field to a newly
// allocated Slice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSliceStartEnd() (Slice, error) {
	s.Struct.SetUint16(0, 10)
	ss, err := NewSlice(s.Struct.Segment())
	if err != nil {
		return Slice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) SpliceStartRemoveInsert() (Splice, error) {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != spliceStartRemoveInsert")
	}
	p, err := s.Struct.Ptr(0)
	return Splice{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasSpliceStartRemoveInsert() bool {
	if s.Struct.Uint16(0) != 11 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetSpliceStartRemoveInsert(v Splice) error {
	s.Struct.SetUint16(0, 11)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSpliceStartRemoveInsert sets the spliceStartRemoveInsert field to a newly
// allocated Splice struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewSpliceStartRemoveInsert() (Splice, error) {
	s.Struct.SetUint16(0, 11)
	ss, err := NewSplice(s.Struct.Segment())
	if err != nil {
		return Splice{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) Txts() (Texts, error) {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != txts")
	}
	p, err := s.Struct.Ptr(0)
	return Texts{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasTxts() bool {
	if s.Struct.Uint16(0) != 12 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetTxts(v Texts) error {
	s.Struct.SetUint16(0, 12)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTxts sets the txts field to a newly
// allocated Texts struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewTxts() (Texts, error) {
	s.Struct.SetUint16(0, 12)
	ss, err := NewTexts(s.Struct.Segment())
	if err != nil {
		return Texts{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TextListEvalImpl) Var() (Var, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != var")
	}
	p, err := s.Struct.Ptr(0)
	return Var{Struct: p.Struct()}, err
}

func (s TextListEvalImpl) HasVar() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TextListEvalImpl) SetVar(v Var) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVar sets the var field to a newly
// allocated Var struct, preferring placement in s's segment.
func (s TextListEvalImpl) NewVar() (Var, error) {
	s.Struct.SetUint16(0, 13)
	ss, err := NewVar(s.Struct.Segment())
	if err != nil {
		return Var{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// TextListEvalImpl_List is a list of TextListEvalImpl.
type TextListEvalImpl_List struct{ capnp.List }

// NewTextListEvalImpl creates a new list of TextListEvalImpl.
func NewTextListEvalImpl_List(s *capnp.Segment, sz int32) (TextListEvalImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return TextListEvalImpl_List{l}, err
}

func (s TextListEvalImpl_List) At(i int) TextListEvalImpl { return TextListEvalImpl{s.List.Struct(i)} }

func (s TextListEvalImpl_List) Set(i int, v TextListEvalImpl) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s TextListEvalImpl_List) String() string {
	str, _ := text.MarshalList(0xe3f62895ddeecf83, s.List)
	return str
}

// TextListEvalImpl_Promise is a wrapper for a TextListEvalImpl promised by a client call.
type TextListEvalImpl_Promise struct{ *capnp.Pipeline }

func (p TextListEvalImpl_Promise) Struct() (TextListEvalImpl, error) {
	s, err := p.Pipeline.Struct()
	return TextListEvalImpl{s}, err
}

func (p TextListEvalImpl_Promise) DetermineArgs() Determine_Promise {
	return Determine_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) GetFrom() GetAtField_Promise {
	return GetAtField_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) KindsOf() KindsOf_Promise {
	return KindsOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) ReciprocalsRelObject() ReciprocalsOf_Promise {
	return ReciprocalsOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) RelativesRelObject() RelativesOf_Promise {
	return RelativesOf_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) RenderArgs() RenderPattern_Promise {
	return RenderPattern_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) RenderRefFlags() RenderRef_Promise {
	return RenderRef_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) Slice() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) SliceEnd() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) SliceStart() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) SliceStartEnd() Slice_Promise {
	return Slice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) SpliceStartRemoveInsert() Splice_Promise {
	return Splice_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) Txts() Texts_Promise {
	return Texts_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TextListEvalImpl_Promise) Var() Var_Promise {
	return Var_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Trigger struct{ capnp.Struct }

// Trigger_TypeID is the unique identifier for the type Trigger.
const Trigger_TypeID = 0xaabc83a03b837d1a

func NewTrigger(s *capnp.Segment) (Trigger, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Trigger{st}, err
}

func NewRootTrigger(s *capnp.Segment) (Trigger, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Trigger{st}, err
}

func ReadRootTrigger(msg *capnp.Message) (Trigger, error) {
	root, err := msg.RootPtr()
	return Trigger{root.Struct()}, err
}

func (s Trigger) String() string {
	str, _ := text.Marshal(0xaabc83a03b837d1a, s.Struct)
	return str
}

func (s Trigger) Eval() (capnp.Pointer, error) {
	return s.Struct.Pointer(0)
}

func (s Trigger) HasEval() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Trigger) EvalPtr() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Trigger) SetEval(v capnp.Pointer) error {
	return s.Struct.SetPointer(0, v)
}

func (s Trigger) SetEvalPtr(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Trigger_List is a list of Trigger.
type Trigger_List struct{ capnp.List }

// NewTrigger creates a new list of Trigger.
func NewTrigger_List(s *capnp.Segment, sz int32) (Trigger_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Trigger_List{l}, err
}

func (s Trigger_List) At(i int) Trigger { return Trigger{s.List.Struct(i)} }

func (s Trigger_List) Set(i int, v Trigger) error { return s.List.SetStruct(i, v.Struct) }

func (s Trigger_List) String() string {
	str, _ := text.MarshalList(0xaabc83a03b837d1a, s.List)
	return str
}

// Trigger_Promise is a wrapper for a Trigger promised by a client call.
type Trigger_Promise struct{ *capnp.Pipeline }

func (p Trigger_Promise) Struct() (Trigger, error) {
	s, err := p.Pipeline.Struct()
	return Trigger{s}, err
}

func (p Trigger_Promise) Eval() *capnp.Pipeline {
	return p.Pipeline.GetPipeline(0)
}

type TriggerImpl struct{ capnp.Struct }
type TriggerImpl_Which uint16

const (
	TriggerImpl_Which_after TriggerImpl_Which = 0
	TriggerImpl_Which_at    TriggerImpl_Which = 1
	TriggerImpl_Which_every TriggerImpl_Which = 2
)

func (w TriggerImpl_Which) String() string {
	const s = "afteratevery"
	switch w {
	case TriggerImpl_Which_after:
		return s[0:5]
	case TriggerImpl_Which_at:
		return s[5:7]
	case TriggerImpl_Which_every:
		return s[7:12]

	}
	return "TriggerImpl_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TriggerImpl_TypeID is the unique identifier for the type TriggerImpl.
const TriggerImpl_TypeID = 0xf6c2e4faed3a43c2

func NewTriggerImpl(s *capnp.Segment) (TriggerImpl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TriggerImpl{st}, err
}

func NewRootTriggerImpl(s *capnp.Segment) (TriggerImpl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TriggerImpl{st}, err
}

func ReadRootTriggerImpl(msg *capnp.Message) (TriggerImpl, error) {
	root, err := msg.RootPtr()
	return TriggerImpl{root.Struct()}, err
}

func (s TriggerImpl) String() string {
	str, _ := text.Marshal(0xf6c2e4faed3a43c2, s.Struct)
	return str
}

func (s TriggerImpl) Which() TriggerImpl_Which {
	return TriggerImpl_Which(s.Struct.Uint16(0))
}
func (s TriggerImpl) After() (TriggerSwitch, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != after")
	}
	p, err := s.Struct.Ptr(0)
	return TriggerSwitch{Struct: p.Struct()}, err
}

func (s TriggerImpl) HasAfter() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TriggerImpl) SetAfter(v TriggerSwitch) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAfter sets the after field to a newly
// allocated TriggerSwitch struct, preferring placement in s's segment.
func (s TriggerImpl) NewAfter() (TriggerSwitch, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewTriggerSwitch(s.Struct.Segment())
	if err != nil {
		return TriggerSwitch{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TriggerImpl) At() (TriggerOnce, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != at")
	}
	p, err := s.Struct.Ptr(0)
	return TriggerOnce{Struct: p.Struct()}, err
}

func (s TriggerImpl) HasAt() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TriggerImpl) SetAt(v TriggerOnce) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAt sets the at field to a newly
// allocated TriggerOnce struct, preferring placement in s's segment.
func (s TriggerImpl) NewAt() (TriggerOnce, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewTriggerOnce(s.Struct.Segment())
	if err != nil {
		return TriggerOnce{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s TriggerImpl) Every() (TriggerCycle, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != every")
	}
	p, err := s.Struct.Ptr(0)
	return TriggerCycle{Struct: p.Struct()}, err
}

func (s TriggerImpl) HasEvery() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TriggerImpl) SetEvery(v TriggerCycle) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEvery sets the every field to a newly
// allocated TriggerCycle struct, preferring placement in s's segment.
func (s TriggerImpl) NewEvery() (TriggerCycle, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewTriggerCycle(s.Struct.Segment())
	if err != nil {
		return TriggerCycle{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// TriggerImpl_List is a list of TriggerImpl.
type TriggerImpl_List struct{ capnp.List }

// NewTriggerImpl creates a new list of TriggerImpl.
func NewTriggerImpl_List(s *capnp.Segment, sz int32) (TriggerImpl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return TriggerImpl_List{l}, err
}

func (s TriggerImpl_List) At(i int) TriggerImpl { return TriggerImpl{s.List.Struct(i)} }

func (s TriggerImpl_List) Set(i int, v TriggerImpl) error { return s.List.SetStruct(i, v.Struct) }

func (s TriggerImpl_List) String() string {
	str, _ := text.MarshalList(0xf6c2e4faed3a43c2, s.List)
	return str
}

// TriggerImpl_Promise is a wrapper for a TriggerImpl promised by a client call.
type TriggerImpl_Promise struct{ *capnp.Pipeline }

func (p TriggerImpl_Promise) Struct() (TriggerImpl, error) {
	s, err := p.Pipeline.Struct()
	return TriggerImpl{s}, err
}

func (p TriggerImpl_Promise) After() TriggerSwitch_Promise {
	return TriggerSwitch_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TriggerImpl_Promise) At() TriggerOnce_Promise {
	return TriggerOnce_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TriggerImpl_Promise) Every() TriggerCycle_Promise {
	return TriggerCycle_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Action struct{ capnp.Struct }

// Action_TypeID is the unique identifier for the type Action.
const Action_TypeID = 0xa4cd32fedde44bdb

func NewAction(s *capnp.Segment) (Action, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Action{st}, err
}

func NewRootAction(s *capnp.Segment) (Action, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Action{st}, err
}

func ReadRootAction(msg *capnp.Message) (Action, error) {
	root, err := msg.RootPtr()
	return Action{root.Struct()}, err
}

func (s Action) String() string {
	str, _ := text.Marshal(0xa4cd32fedde44bdb, s.Struct)
	return str
}

func (s Action) Action() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Action) HasAction() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Action) SetAction(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAction sets the action field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Action) NewAction() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Action_List is a list of Action.
type Action_List struct{ capnp.List }

// NewAction creates a new list of Action.
func NewAction_List(s *capnp.Segment, sz int32) (Action_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Action_List{l}, err
}

func (s Action_List) At(i int) Action { return Action{s.List.Struct(i)} }

func (s Action_List) Set(i int, v Action) error { return s.List.SetStruct(i, v.Struct) }

func (s Action_List) String() string {
	str, _ := text.MarshalList(0xa4cd32fedde44bdb, s.List)
	return str
}

// Action_Promise is a wrapper for a Action promised by a client call.
type Action_Promise struct{ *capnp.Pipeline }

func (p Action_Promise) Struct() (Action, error) {
	s, err := p.Pipeline.Struct()
	return Action{s}, err
}

func (p Action_Promise) Action() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Activity struct{ capnp.Struct }

// Activity_TypeID is the unique identifier for the type Activity.
const Activity_TypeID = 0xbf584d588d5035bf

func NewActivity(s *capnp.Segment) (Activity, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Activity{st}, err
}

func NewRootActivity(s *capnp.Segment) (Activity, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Activity{st}, err
}

func ReadRootActivity(msg *capnp.Message) (Activity, error) {
	root, err := msg.RootPtr()
	return Activity{root.Struct()}, err
}

func (s Activity) String() string {
	str, _ := text.Marshal(0xbf584d588d5035bf, s.Struct)
	return str
}

func (s Activity) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s Activity) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Activity) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Activity) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Activity_List is a list of Activity.
type Activity_List struct{ capnp.List }

// NewActivity creates a new list of Activity.
func NewActivity_List(s *capnp.Segment, sz int32) (Activity_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Activity_List{l}, err
}

func (s Activity_List) At(i int) Activity { return Activity{s.List.Struct(i)} }

func (s Activity_List) Set(i int, v Activity) error { return s.List.SetStruct(i, v.Struct) }

func (s Activity_List) String() string {
	str, _ := text.MarshalList(0xbf584d588d5035bf, s.List)
	return str
}

// Activity_Promise is a wrapper for a Activity promised by a client call.
type Activity_Promise struct{ *capnp.Pipeline }

func (p Activity_Promise) Struct() (Activity, error) {
	s, err := p.Pipeline.Struct()
	return Activity{s}, err
}

type Alias struct{ capnp.Struct }

// Alias_TypeID is the unique identifier for the type Alias.
const Alias_TypeID = 0xa1da6b401255eb1c

func NewAlias(s *capnp.Segment) (Alias, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Alias{st}, err
}

func NewRootAlias(s *capnp.Segment) (Alias, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Alias{st}, err
}

func ReadRootAlias(msg *capnp.Message) (Alias, error) {
	root, err := msg.RootPtr()
	return Alias{root.Struct()}, err
}

func (s Alias) String() string {
	str, _ := text.Marshal(0xa1da6b401255eb1c, s.Struct)
	return str
}

func (s Alias) Names() (Text_List, error) {
	p, err := s.Struct.Ptr(0)
	return Text_List{List: p.List()}, err
}

func (s Alias) HasNames() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Alias) SetNames(v Text_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewNames sets the names field to a newly
// allocated Text_List, preferring placement in s's segment.
func (s Alias) NewNames(n int32) (Text_List, error) {
	l, err := NewText_List(s.Struct.Segment(), n)
	if err != nil {
		return Text_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Alias) AsNoun() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s Alias) HasAsNoun() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Alias) SetAsNoun(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAsNoun sets the asNoun field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Alias) NewAsNoun() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Alias_List is a list of Alias.
type Alias_List struct{ capnp.List }

// NewAlias creates a new list of Alias.
func NewAlias_List(s *capnp.Segment, sz int32) (Alias_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Alias_List{l}, err
}

func (s Alias_List) At(i int) Alias { return Alias{s.List.Struct(i)} }

func (s Alias_List) Set(i int, v Alias) error { return s.List.SetStruct(i, v.Struct) }

func (s Alias_List) String() string {
	str, _ := text.MarshalList(0xa1da6b401255eb1c, s.List)
	return str
}

// Alias_Promise is a wrapper for a Alias promised by a client call.
type Alias_Promise struct{ *capnp.Pipeline }

func (p Alias_Promise) Struct() (Alias, error) {
	s, err := p.Pipeline.Struct()
	return Alias{s}, err
}

func (p Alias_Promise) AsNoun() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type AllOf struct{ capnp.Struct }

// AllOf_TypeID is the unique identifier for the type AllOf.
const AllOf_TypeID = 0xb1605c9c47b9b539

func NewAllOf(s *capnp.Segment) (AllOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllOf{st}, err
}

func NewRootAllOf(s *capnp.Segment) (AllOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllOf{st}, err
}

func ReadRootAllOf(msg *capnp.Message) (AllOf, error) {
	root, err := msg.RootPtr()
	return AllOf{root.Struct()}, err
}

func (s AllOf) String() string {
	str, _ := text.Marshal(0xb1605c9c47b9b539, s.Struct)
	return str
}

func (s AllOf) Series() (ScannerMaker_List, error) {
	p, err := s.Struct.Ptr(0)
	return ScannerMaker_List{List: p.List()}, err
}

func (s AllOf) HasSeries() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AllOf) SetSeries(v ScannerMaker_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewSeries sets the series field to a newly
// allocated ScannerMaker_List, preferring placement in s's segment.
func (s AllOf) NewSeries(n int32) (ScannerMaker_List, error) {
	l, err := NewScannerMaker_List(s.Struct.Segment(), n)
	if err != nil {
		return ScannerMaker_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// AllOf_List is a list of AllOf.
type AllOf_List struct{ capnp.List }

// NewAllOf creates a new list of AllOf.
func NewAllOf_List(s *capnp.Segment, sz int32) (AllOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return AllOf_List{l}, err
}

func (s AllOf_List) At(i int) AllOf { return AllOf{s.List.Struct(i)} }

func (s AllOf_List) Set(i int, v AllOf) error { return s.List.SetStruct(i, v.Struct) }

func (s AllOf_List) String() string {
	str, _ := text.MarshalList(0xb1605c9c47b9b539, s.List)
	return str
}

// AllOf_Promise is a wrapper for a AllOf promised by a client call.
type AllOf_Promise struct{ *capnp.Pipeline }

func (p AllOf_Promise) Struct() (AllOf, error) {
	s, err := p.Pipeline.Struct()
	return AllOf{s}, err
}

type AllTrue struct{ capnp.Struct }

// AllTrue_TypeID is the unique identifier for the type AllTrue.
const AllTrue_TypeID = 0xd8858b33e34e486c

func NewAllTrue(s *capnp.Segment) (AllTrue, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllTrue{st}, err
}

func NewRootAllTrue(s *capnp.Segment) (AllTrue, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllTrue{st}, err
}

func ReadRootAllTrue(msg *capnp.Message) (AllTrue, error) {
	root, err := msg.RootPtr()
	return AllTrue{root.Struct()}, err
}

func (s AllTrue) String() string {
	str, _ := text.Marshal(0xd8858b33e34e486c, s.Struct)
	return str
}

func (s AllTrue) Test() (BoolEval_List, error) {
	p, err := s.Struct.Ptr(0)
	return BoolEval_List{List: p.List()}, err
}

func (s AllTrue) HasTest() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AllTrue) SetTest(v BoolEval_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewTest sets the test field to a newly
// allocated BoolEval_List, preferring placement in s's segment.
func (s AllTrue) NewTest(n int32) (BoolEval_List, error) {
	l, err := NewBoolEval_List(s.Struct.Segment(), n)
	if err != nil {
		return BoolEval_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// AllTrue_List is a list of AllTrue.
type AllTrue_List struct{ capnp.List }

// NewAllTrue creates a new list of AllTrue.
func NewAllTrue_List(s *capnp.Segment, sz int32) (AllTrue_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return AllTrue_List{l}, err
}

func (s AllTrue_List) At(i int) AllTrue { return AllTrue{s.List.Struct(i)} }

func (s AllTrue_List) Set(i int, v AllTrue) error { return s.List.SetStruct(i, v.Struct) }

func (s AllTrue_List) String() string {
	str, _ := text.MarshalList(0xd8858b33e34e486c, s.List)
	return str
}

// AllTrue_Promise is a wrapper for a AllTrue promised by a client call.
type AllTrue_Promise struct{ *capnp.Pipeline }

func (p AllTrue_Promise) Struct() (AllTrue, error) {
	s, err := p.Pipeline.Struct()
	return AllTrue{s}, err
}

type Always struct{ capnp.Struct }

// Always_TypeID is the unique identifier for the type Always.
const Always_TypeID = 0xab217d821f244430

func NewAlways(s *capnp.Segment) (Always, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Always{st}, err
}

func NewRootAlways(s *capnp.Segment) (Always, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Always{st}, err
}

func ReadRootAlways(msg *capnp.Message) (Always, error) {
	root, err := msg.RootPtr()
	return Always{root.Struct()}, err
}

func (s Always) String() string {
	str, _ := text.Marshal(0xab217d821f244430, s.Struct)
	return str
}

// Always_List is a list of Always.
type Always_List struct{ capnp.List }

// NewAlways creates a new list of Always.
func NewAlways_List(s *capnp.Segment, sz int32) (Always_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Always_List{l}, err
}

func (s Always_List) At(i int) Always { return Always{s.List.Struct(i)} }

func (s Always_List) Set(i int, v Always) error { return s.List.SetStruct(i, v.Struct) }

func (s Always_List) String() string {
	str, _ := text.MarshalList(0xab217d821f244430, s.List)
	return str
}

// Always_Promise is a wrapper for a Always promised by a client call.
type Always_Promise struct{ *capnp.Pipeline }

func (p Always_Promise) Struct() (Always, error) {
	s, err := p.Pipeline.Struct()
	return Always{s}, err
}

type AnyOf struct{ capnp.Struct }

// AnyOf_TypeID is the unique identifier for the type AnyOf.
const AnyOf_TypeID = 0x90affb8d74e73f93

func NewAnyOf(s *capnp.Segment) (AnyOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AnyOf{st}, err
}

func NewRootAnyOf(s *capnp.Segment) (AnyOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AnyOf{st}, err
}

func ReadRootAnyOf(msg *capnp.Message) (AnyOf, error) {
	root, err := msg.RootPtr()
	return AnyOf{root.Struct()}, err
}

func (s AnyOf) String() string {
	str, _ := text.Marshal(0x90affb8d74e73f93, s.Struct)
	return str
}

func (s AnyOf) Options() (ScannerMaker_List, error) {
	p, err := s.Struct.Ptr(0)
	return ScannerMaker_List{List: p.List()}, err
}

func (s AnyOf) HasOptions() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AnyOf) SetOptions(v ScannerMaker_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewOptions sets the options field to a newly
// allocated ScannerMaker_List, preferring placement in s's segment.
func (s AnyOf) NewOptions(n int32) (ScannerMaker_List, error) {
	l, err := NewScannerMaker_List(s.Struct.Segment(), n)
	if err != nil {
		return ScannerMaker_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// AnyOf_List is a list of AnyOf.
type AnyOf_List struct{ capnp.List }

// NewAnyOf creates a new list of AnyOf.
func NewAnyOf_List(s *capnp.Segment, sz int32) (AnyOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return AnyOf_List{l}, err
}

func (s AnyOf_List) At(i int) AnyOf { return AnyOf{s.List.Struct(i)} }

func (s AnyOf_List) Set(i int, v AnyOf) error { return s.List.SetStruct(i, v.Struct) }

func (s AnyOf_List) String() string {
	str, _ := text.MarshalList(0x90affb8d74e73f93, s.List)
	return str
}

// AnyOf_Promise is a wrapper for a AnyOf promised by a client call.
type AnyOf_Promise struct{ *capnp.Pipeline }

func (p AnyOf_Promise) Struct() (AnyOf, error) {
	s, err := p.Pipeline.Struct()
	return AnyOf{s}, err
}

type AnyTrue struct{ capnp.Struct }

// AnyTrue_TypeID is the unique identifier for the type AnyTrue.
const AnyTrue_TypeID = 0xebdf7695a5b7d624

func NewAnyTrue(s *capnp.Segment) (AnyTrue, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AnyTrue{st}, err
}

func NewRootAnyTrue(s *capnp.Segment) (AnyTrue, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AnyTrue{st}, err
}

func ReadRootAnyTrue(msg *capnp.Message) (AnyTrue, error) {
	root, err := msg.RootPtr()
	return AnyTrue{root.Struct()}, err
}

func (s AnyTrue) String() string {
	str, _ := text.Marshal(0xebdf7695a5b7d624, s.Struct)
	return str
}

func (s AnyTrue) Test() (BoolEval_List, error) {
	p, err := s.Struct.Ptr(0)
	return BoolEval_List{List: p.List()}, err
}

func (s AnyTrue) HasTest() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AnyTrue) SetTest(v BoolEval_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewTest sets the test field to a newly
// allocated BoolEval_List, preferring placement in s's segment.
func (s AnyTrue) NewTest(n int32) (BoolEval_List, error) {
	l, err := NewBoolEval_List(s.Struct.Segment(), n)
	if err != nil {
		return BoolEval_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// AnyTrue_List is a list of AnyTrue.
type AnyTrue_List struct{ capnp.List }

// NewAnyTrue creates a new list of AnyTrue.
func NewAnyTrue_List(s *capnp.Segment, sz int32) (AnyTrue_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return AnyTrue_List{l}, err
}

func (s AnyTrue_List) At(i int) AnyTrue { return AnyTrue{s.List.Struct(i)} }

func (s AnyTrue_List) Set(i int, v AnyTrue) error { return s.List.SetStruct(i, v.Struct) }

func (s AnyTrue_List) String() string {
	str, _ := text.MarshalList(0xebdf7695a5b7d624, s.List)
	return str
}

// AnyTrue_Promise is a wrapper for a AnyTrue promised by a client call.
type AnyTrue_Promise struct{ *capnp.Pipeline }

func (p AnyTrue_Promise) Struct() (AnyTrue, error) {
	s, err := p.Pipeline.Struct()
	return AnyTrue{s}, err
}

type Argument struct{ capnp.Struct }

// Argument_TypeID is the unique identifier for the type Argument.
const Argument_TypeID = 0xf4ef5aa2f835cdc7

func NewArgument(s *capnp.Segment) (Argument, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Argument{st}, err
}

func NewRootArgument(s *capnp.Segment) (Argument, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Argument{st}, err
}

func ReadRootArgument(msg *capnp.Message) (Argument, error) {
	root, err := msg.RootPtr()
	return Argument{root.Struct()}, err
}

func (s Argument) String() string {
	str, _ := text.Marshal(0xf4ef5aa2f835cdc7, s.Struct)
	return str
}

func (s Argument) Name() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Argument) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Argument) SetName(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Argument) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Argument) From() (Assignment, error) {
	p, err := s.Struct.Ptr(1)
	return Assignment{Struct: p.Struct()}, err
}

func (s Argument) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Argument) SetFrom(v Assignment) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Argument) NewFrom() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Argument_List is a list of Argument.
type Argument_List struct{ capnp.List }

// NewArgument creates a new list of Argument.
func NewArgument_List(s *capnp.Segment, sz int32) (Argument_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Argument_List{l}, err
}

func (s Argument_List) At(i int) Argument { return Argument{s.List.Struct(i)} }

func (s Argument_List) Set(i int, v Argument) error { return s.List.SetStruct(i, v.Struct) }

func (s Argument_List) String() string {
	str, _ := text.MarshalList(0xf4ef5aa2f835cdc7, s.List)
	return str
}

// Argument_Promise is a wrapper for a Argument promised by a client call.
type Argument_Promise struct{ *capnp.Pipeline }

func (p Argument_Promise) Struct() (Argument, error) {
	s, err := p.Pipeline.Struct()
	return Argument{s}, err
}

func (p Argument_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Argument_Promise) From() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Arguments struct{ capnp.Struct }

// Arguments_TypeID is the unique identifier for the type Arguments.
const Arguments_TypeID = 0xe79f6592e37beab1

func NewArguments(s *capnp.Segment) (Arguments, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Arguments{st}, err
}

func NewRootArguments(s *capnp.Segment) (Arguments, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Arguments{st}, err
}

func ReadRootArguments(msg *capnp.Message) (Arguments, error) {
	root, err := msg.RootPtr()
	return Arguments{root.Struct()}, err
}

func (s Arguments) String() string {
	str, _ := text.Marshal(0xe79f6592e37beab1, s.Struct)
	return str
}

func (s Arguments) Args() (Argument_List, error) {
	p, err := s.Struct.Ptr(0)
	return Argument_List{List: p.List()}, err
}

func (s Arguments) HasArgs() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Arguments) SetArgs(v Argument_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated Argument_List, preferring placement in s's segment.
func (s Arguments) NewArgs(n int32) (Argument_List, error) {
	l, err := NewArgument_List(s.Struct.Segment(), n)
	if err != nil {
		return Argument_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Arguments_List is a list of Arguments.
type Arguments_List struct{ capnp.List }

// NewArguments creates a new list of Arguments.
func NewArguments_List(s *capnp.Segment, sz int32) (Arguments_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Arguments_List{l}, err
}

func (s Arguments_List) At(i int) Arguments { return Arguments{s.List.Struct(i)} }

func (s Arguments_List) Set(i int, v Arguments) error { return s.List.SetStruct(i, v.Struct) }

func (s Arguments_List) String() string {
	str, _ := text.MarshalList(0xe79f6592e37beab1, s.List)
	return str
}

// Arguments_Promise is a wrapper for a Arguments promised by a client call.
type Arguments_Promise struct{ *capnp.Pipeline }

func (p Arguments_Promise) Struct() (Arguments, error) {
	s, err := p.Pipeline.Struct()
	return Arguments{s}, err
}

type AsNum struct{ capnp.Struct }

// AsNum_TypeID is the unique identifier for the type AsNum.
const AsNum_TypeID = 0xf8170ade78f3851b

func NewAsNum(s *capnp.Segment) (AsNum, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AsNum{st}, err
}

func NewRootAsNum(s *capnp.Segment) (AsNum, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AsNum{st}, err
}

func ReadRootAsNum(msg *capnp.Message) (AsNum, error) {
	root, err := msg.RootPtr()
	return AsNum{root.Struct()}, err
}

func (s AsNum) String() string {
	str, _ := text.Marshal(0xf8170ade78f3851b, s.Struct)
	return str
}

func (s AsNum) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s AsNum) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AsNum) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s AsNum) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// AsNum_List is a list of AsNum.
type AsNum_List struct{ capnp.List }

// NewAsNum creates a new list of AsNum.
func NewAsNum_List(s *capnp.Segment, sz int32) (AsNum_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return AsNum_List{l}, err
}

func (s AsNum_List) At(i int) AsNum { return AsNum{s.List.Struct(i)} }

func (s AsNum_List) Set(i int, v AsNum) error { return s.List.SetStruct(i, v.Struct) }

func (s AsNum_List) String() string {
	str, _ := text.MarshalList(0xf8170ade78f3851b, s.List)
	return str
}

// AsNum_Promise is a wrapper for a AsNum promised by a client call.
type AsNum_Promise struct{ *capnp.Pipeline }

func (p AsNum_Promise) Struct() (AsNum, error) {
	s, err := p.Pipeline.Struct()
	return AsNum{s}, err
}

func (p AsNum_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type AsRec struct{ capnp.Struct }

// AsRec_TypeID is the unique identifier for the type AsRec.
const AsRec_TypeID = 0xcd335f562bb0d63d

func NewAsRec(s *capnp.Segment) (AsRec, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AsRec{st}, err
}

func NewRootAsRec(s *capnp.Segment) (AsRec, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AsRec{st}, err
}

func ReadRootAsRec(msg *capnp.Message) (AsRec, error) {
	root, err := msg.RootPtr()
	return AsRec{root.Struct()}, err
}

func (s AsRec) String() string {
	str, _ := text.Marshal(0xcd335f562bb0d63d, s.Struct)
	return str
}

func (s AsRec) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s AsRec) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AsRec) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s AsRec) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// AsRec_List is a list of AsRec.
type AsRec_List struct{ capnp.List }

// NewAsRec creates a new list of AsRec.
func NewAsRec_List(s *capnp.Segment, sz int32) (AsRec_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return AsRec_List{l}, err
}

func (s AsRec_List) At(i int) AsRec { return AsRec{s.List.Struct(i)} }

func (s AsRec_List) Set(i int, v AsRec) error { return s.List.SetStruct(i, v.Struct) }

func (s AsRec_List) String() string {
	str, _ := text.MarshalList(0xcd335f562bb0d63d, s.List)
	return str
}

// AsRec_Promise is a wrapper for a AsRec promised by a client call.
type AsRec_Promise struct{ *capnp.Pipeline }

func (p AsRec_Promise) Struct() (AsRec, error) {
	s, err := p.Pipeline.Struct()
	return AsRec{s}, err
}

func (p AsRec_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type AsTxt struct{ capnp.Struct }

// AsTxt_TypeID is the unique identifier for the type AsTxt.
const AsTxt_TypeID = 0xf4ea47e08563f0a2

func NewAsTxt(s *capnp.Segment) (AsTxt, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AsTxt{st}, err
}

func NewRootAsTxt(s *capnp.Segment) (AsTxt, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AsTxt{st}, err
}

func ReadRootAsTxt(msg *capnp.Message) (AsTxt, error) {
	root, err := msg.RootPtr()
	return AsTxt{root.Struct()}, err
}

func (s AsTxt) String() string {
	str, _ := text.Marshal(0xf4ea47e08563f0a2, s.Struct)
	return str
}

func (s AsTxt) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s AsTxt) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AsTxt) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s AsTxt) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// AsTxt_List is a list of AsTxt.
type AsTxt_List struct{ capnp.List }

// NewAsTxt creates a new list of AsTxt.
func NewAsTxt_List(s *capnp.Segment, sz int32) (AsTxt_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return AsTxt_List{l}, err
}

func (s AsTxt_List) At(i int) AsTxt { return AsTxt{s.List.Struct(i)} }

func (s AsTxt_List) Set(i int, v AsTxt) error { return s.List.SetStruct(i, v.Struct) }

func (s AsTxt_List) String() string {
	str, _ := text.MarshalList(0xf4ea47e08563f0a2, s.List)
	return str
}

// AsTxt_Promise is a wrapper for a AsTxt promised by a client call.
type AsTxt_Promise struct{ *capnp.Pipeline }

func (p AsTxt_Promise) Struct() (AsTxt, error) {
	s, err := p.Pipeline.Struct()
	return AsTxt{s}, err
}

func (p AsTxt_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Assign struct{ capnp.Struct }

// Assign_TypeID is the unique identifier for the type Assign.
const Assign_TypeID = 0x9644289018e9cbc0

func NewAssign(s *capnp.Segment) (Assign, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Assign{st}, err
}

func NewRootAssign(s *capnp.Segment) (Assign, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Assign{st}, err
}

func ReadRootAssign(msg *capnp.Message) (Assign, error) {
	root, err := msg.RootPtr()
	return Assign{root.Struct()}, err
}

func (s Assign) String() string {
	str, _ := text.Marshal(0x9644289018e9cbc0, s.Struct)
	return str
}

func (s Assign) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Assign) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Assign) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Assign) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Assign) From() (Assignment, error) {
	p, err := s.Struct.Ptr(1)
	return Assignment{Struct: p.Struct()}, err
}

func (s Assign) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Assign) SetFrom(v Assignment) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Assign) NewFrom() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Assign_List is a list of Assign.
type Assign_List struct{ capnp.List }

// NewAssign creates a new list of Assign.
func NewAssign_List(s *capnp.Segment, sz int32) (Assign_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Assign_List{l}, err
}

func (s Assign_List) At(i int) Assign { return Assign{s.List.Struct(i)} }

func (s Assign_List) Set(i int, v Assign) error { return s.List.SetStruct(i, v.Struct) }

func (s Assign_List) String() string {
	str, _ := text.MarshalList(0x9644289018e9cbc0, s.List)
	return str
}

// Assign_Promise is a wrapper for a Assign promised by a client call.
type Assign_Promise struct{ *capnp.Pipeline }

func (p Assign_Promise) Struct() (Assign, error) {
	s, err := p.Pipeline.Struct()
	return Assign{s}, err
}

func (p Assign_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Assign_Promise) From() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type At struct{ capnp.Struct }

// At_TypeID is the unique identifier for the type At.
const At_TypeID = 0xd33644b52a685344

func NewAt(s *capnp.Segment) (At, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return At{st}, err
}

func NewRootAt(s *capnp.Segment) (At, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return At{st}, err
}

func ReadRootAt(msg *capnp.Message) (At, error) {
	root, err := msg.RootPtr()
	return At{root.Struct()}, err
}

func (s At) String() string {
	str, _ := text.Marshal(0xd33644b52a685344, s.Struct)
	return str
}

func (s At) List() (Assignment, error) {
	p, err := s.Struct.Ptr(0)
	return Assignment{Struct: p.Struct()}, err
}

func (s At) HasList() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s At) SetList(v Assignment) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewList sets the list field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s At) NewList() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s At) Index() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s At) HasIndex() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s At) SetIndex(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewIndex sets the index field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s At) NewIndex() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// At_List is a list of At.
type At_List struct{ capnp.List }

// NewAt creates a new list of At.
func NewAt_List(s *capnp.Segment, sz int32) (At_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return At_List{l}, err
}

func (s At_List) At(i int) At { return At{s.List.Struct(i)} }

func (s At_List) Set(i int, v At) error { return s.List.SetStruct(i, v.Struct) }

func (s At_List) String() string {
	str, _ := text.MarshalList(0xd33644b52a685344, s.List)
	return str
}

// At_Promise is a wrapper for a At promised by a client call.
type At_Promise struct{ *capnp.Pipeline }

func (p At_Promise) Struct() (At, error) {
	s, err := p.Pipeline.Struct()
	return At{s}, err
}

func (p At_Promise) List() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p At_Promise) Index() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Bool struct{ capnp.Struct }

// Bool_TypeID is the unique identifier for the type Bool.
const Bool_TypeID = 0xdd4dd8322f7db61c

func NewBool(s *capnp.Segment) (Bool, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Bool{st}, err
}

func NewRootBool(s *capnp.Segment) (Bool, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Bool{st}, err
}

func ReadRootBool(msg *capnp.Message) (Bool, error) {
	root, err := msg.RootPtr()
	return Bool{root.Struct()}, err
}

func (s Bool) String() string {
	str, _ := text.Marshal(0xdd4dd8322f7db61c, s.Struct)
	return str
}

func (s Bool) Bool() (Bool, error) {
	p, err := s.Struct.Ptr(0)
	return Bool{Struct: p.Struct()}, err
}

func (s Bool) HasBool() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Bool) SetBool(v Bool) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBool sets the bool field to a newly
// allocated Bool struct, preferring placement in s's segment.
func (s Bool) NewBool() (Bool, error) {
	ss, err := NewBool(s.Struct.Segment())
	if err != nil {
		return Bool{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Bool_List is a list of Bool.
type Bool_List struct{ capnp.List }

// NewBool creates a new list of Bool.
func NewBool_List(s *capnp.Segment, sz int32) (Bool_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Bool_List{l}, err
}

func (s Bool_List) At(i int) Bool { return Bool{s.List.Struct(i)} }

func (s Bool_List) Set(i int, v Bool) error { return s.List.SetStruct(i, v.Struct) }

func (s Bool_List) String() string {
	str, _ := text.MarshalList(0xdd4dd8322f7db61c, s.List)
	return str
}

// Bool_Promise is a wrapper for a Bool promised by a client call.
type Bool_Promise struct{ *capnp.Pipeline }

func (p Bool_Promise) Struct() (Bool, error) {
	s, err := p.Pipeline.Struct()
	return Bool{s}, err
}

func (p Bool_Promise) Bool() Bool_Promise {
	return Bool_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Bracket struct{ capnp.Struct }

// Bracket_TypeID is the unique identifier for the type Bracket.
const Bracket_TypeID = 0xba2ce21e32f1c71a

func NewBracket(s *capnp.Segment) (Bracket, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Bracket{st}, err
}

func NewRootBracket(s *capnp.Segment) (Bracket, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Bracket{st}, err
}

func ReadRootBracket(msg *capnp.Message) (Bracket, error) {
	root, err := msg.RootPtr()
	return Bracket{root.Struct()}, err
}

func (s Bracket) String() string {
	str, _ := text.Marshal(0xba2ce21e32f1c71a, s.Struct)
	return str
}

func (s Bracket) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s Bracket) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Bracket) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Bracket) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Bracket_List is a list of Bracket.
type Bracket_List struct{ capnp.List }

// NewBracket creates a new list of Bracket.
func NewBracket_List(s *capnp.Segment, sz int32) (Bracket_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Bracket_List{l}, err
}

func (s Bracket_List) At(i int) Bracket { return Bracket{s.List.Struct(i)} }

func (s Bracket_List) Set(i int, v Bracket) error { return s.List.SetStruct(i, v.Struct) }

func (s Bracket_List) String() string {
	str, _ := text.MarshalList(0xba2ce21e32f1c71a, s.List)
	return str
}

// Bracket_Promise is a wrapper for a Bracket promised by a client call.
type Bracket_Promise struct{ *capnp.Pipeline }

func (p Bracket_Promise) Struct() (Bracket, error) {
	s, err := p.Pipeline.Struct()
	return Bracket{s}, err
}

type Break struct{ capnp.Struct }

// Break_TypeID is the unique identifier for the type Break.
const Break_TypeID = 0x836331ec00b62435

func NewBreak(s *capnp.Segment) (Break, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Break{st}, err
}

func NewRootBreak(s *capnp.Segment) (Break, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Break{st}, err
}

func ReadRootBreak(msg *capnp.Message) (Break, error) {
	root, err := msg.RootPtr()
	return Break{root.Struct()}, err
}

func (s Break) String() string {
	str, _ := text.Marshal(0x836331ec00b62435, s.Struct)
	return str
}

// Break_List is a list of Break.
type Break_List struct{ capnp.List }

// NewBreak creates a new list of Break.
func NewBreak_List(s *capnp.Segment, sz int32) (Break_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Break_List{l}, err
}

func (s Break_List) At(i int) Break { return Break{s.List.Struct(i)} }

func (s Break_List) Set(i int, v Break) error { return s.List.SetStruct(i, v.Struct) }

func (s Break_List) String() string {
	str, _ := text.MarshalList(0x836331ec00b62435, s.List)
	return str
}

// Break_Promise is a wrapper for a Break promised by a client call.
type Break_Promise struct{ *capnp.Pipeline }

func (p Break_Promise) Struct() (Break, error) {
	s, err := p.Pipeline.Struct()
	return Break{s}, err
}

type Buffer struct{ capnp.Struct }

// Buffer_TypeID is the unique identifier for the type Buffer.
const Buffer_TypeID = 0xa86c622ed3cf1c7f

func NewBuffer(s *capnp.Segment) (Buffer, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer{st}, err
}

func NewRootBuffer(s *capnp.Segment) (Buffer, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer{st}, err
}

func ReadRootBuffer(msg *capnp.Message) (Buffer, error) {
	root, err := msg.RootPtr()
	return Buffer{root.Struct()}, err
}

func (s Buffer) String() string {
	str, _ := text.Marshal(0xa86c622ed3cf1c7f, s.Struct)
	return str
}

func (s Buffer) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s Buffer) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Buffer) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Buffer) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Buffer_List is a list of Buffer.
type Buffer_List struct{ capnp.List }

// NewBuffer creates a new list of Buffer.
func NewBuffer_List(s *capnp.Segment, sz int32) (Buffer_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Buffer_List{l}, err
}

func (s Buffer_List) At(i int) Buffer { return Buffer{s.List.Struct(i)} }

func (s Buffer_List) Set(i int, v Buffer) error { return s.List.SetStruct(i, v.Struct) }

func (s Buffer_List) String() string {
	str, _ := text.MarshalList(0xa86c622ed3cf1c7f, s.List)
	return str
}

// Buffer_Promise is a wrapper for a Buffer promised by a client call.
type Buffer_Promise struct{ *capnp.Pipeline }

func (p Buffer_Promise) Struct() (Buffer, error) {
	s, err := p.Pipeline.Struct()
	return Buffer{s}, err
}

type Capitalize struct{ capnp.Struct }

// Capitalize_TypeID is the unique identifier for the type Capitalize.
const Capitalize_TypeID = 0xb3906e9a0b7f5e75

func NewCapitalize(s *capnp.Segment) (Capitalize, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Capitalize{st}, err
}

func NewRootCapitalize(s *capnp.Segment) (Capitalize, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Capitalize{st}, err
}

func ReadRootCapitalize(msg *capnp.Message) (Capitalize, error) {
	root, err := msg.RootPtr()
	return Capitalize{root.Struct()}, err
}

func (s Capitalize) String() string {
	str, _ := text.Marshal(0xb3906e9a0b7f5e75, s.Struct)
	return str
}

func (s Capitalize) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s Capitalize) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Capitalize) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Capitalize) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Capitalize_List is a list of Capitalize.
type Capitalize_List struct{ capnp.List }

// NewCapitalize creates a new list of Capitalize.
func NewCapitalize_List(s *capnp.Segment, sz int32) (Capitalize_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Capitalize_List{l}, err
}

func (s Capitalize_List) At(i int) Capitalize { return Capitalize{s.List.Struct(i)} }

func (s Capitalize_List) Set(i int, v Capitalize) error { return s.List.SetStruct(i, v.Struct) }

func (s Capitalize_List) String() string {
	str, _ := text.MarshalList(0xb3906e9a0b7f5e75, s.List)
	return str
}

// Capitalize_Promise is a wrapper for a Capitalize promised by a client call.
type Capitalize_Promise struct{ *capnp.Pipeline }

func (p Capitalize_Promise) Struct() (Capitalize, error) {
	s, err := p.Pipeline.Struct()
	return Capitalize{s}, err
}

func (p Capitalize_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ChooseAction struct{ capnp.Struct }

// ChooseAction_TypeID is the unique identifier for the type ChooseAction.
const ChooseAction_TypeID = 0x808f6775394e1045

func NewChooseAction(s *capnp.Segment) (ChooseAction, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ChooseAction{st}, err
}

func NewRootChooseAction(s *capnp.Segment) (ChooseAction, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ChooseAction{st}, err
}

func ReadRootChooseAction(msg *capnp.Message) (ChooseAction, error) {
	root, err := msg.RootPtr()
	return ChooseAction{root.Struct()}, err
}

func (s ChooseAction) String() string {
	str, _ := text.Marshal(0x808f6775394e1045, s.Struct)
	return str
}

func (s ChooseAction) If() (BoolEval, error) {
	p, err := s.Struct.Ptr(0)
	return BoolEval{Struct: p.Struct()}, err
}

func (s ChooseAction) HasIf() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChooseAction) SetIf(v BoolEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIf sets the if field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s ChooseAction) NewIf() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseAction) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(1)
	return Execute_List{List: p.List()}, err
}

func (s ChooseAction) HasExe() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ChooseAction) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s ChooseAction) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s ChooseAction) Else() (Brancher, error) {
	p, err := s.Struct.Ptr(2)
	return Brancher{Struct: p.Struct()}, err
}

func (s ChooseAction) HasElse() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s ChooseAction) SetElse(v Brancher) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewElse sets the else field to a newly
// allocated Brancher struct, preferring placement in s's segment.
func (s ChooseAction) NewElse() (Brancher, error) {
	ss, err := NewBrancher(s.Struct.Segment())
	if err != nil {
		return Brancher{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// ChooseAction_List is a list of ChooseAction.
type ChooseAction_List struct{ capnp.List }

// NewChooseAction creates a new list of ChooseAction.
func NewChooseAction_List(s *capnp.Segment, sz int32) (ChooseAction_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return ChooseAction_List{l}, err
}

func (s ChooseAction_List) At(i int) ChooseAction { return ChooseAction{s.List.Struct(i)} }

func (s ChooseAction_List) Set(i int, v ChooseAction) error { return s.List.SetStruct(i, v.Struct) }

func (s ChooseAction_List) String() string {
	str, _ := text.MarshalList(0x808f6775394e1045, s.List)
	return str
}

// ChooseAction_Promise is a wrapper for a ChooseAction promised by a client call.
type ChooseAction_Promise struct{ *capnp.Pipeline }

func (p ChooseAction_Promise) Struct() (ChooseAction, error) {
	s, err := p.Pipeline.Struct()
	return ChooseAction{s}, err
}

func (p ChooseAction_Promise) If() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ChooseAction_Promise) Else() Brancher_Promise {
	return Brancher_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type ChooseMore struct{ capnp.Struct }

// ChooseMore_TypeID is the unique identifier for the type ChooseMore.
const ChooseMore_TypeID = 0xfc4a8aca1a8b1a1d

func NewChooseMore(s *capnp.Segment) (ChooseMore, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ChooseMore{st}, err
}

func NewRootChooseMore(s *capnp.Segment) (ChooseMore, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ChooseMore{st}, err
}

func ReadRootChooseMore(msg *capnp.Message) (ChooseMore, error) {
	root, err := msg.RootPtr()
	return ChooseMore{root.Struct()}, err
}

func (s ChooseMore) String() string {
	str, _ := text.Marshal(0xfc4a8aca1a8b1a1d, s.Struct)
	return str
}

func (s ChooseMore) If() (BoolEval, error) {
	p, err := s.Struct.Ptr(0)
	return BoolEval{Struct: p.Struct()}, err
}

func (s ChooseMore) HasIf() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChooseMore) SetIf(v BoolEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIf sets the if field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s ChooseMore) NewIf() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseMore) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(1)
	return Execute_List{List: p.List()}, err
}

func (s ChooseMore) HasExe() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ChooseMore) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s ChooseMore) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s ChooseMore) Else() (Brancher, error) {
	p, err := s.Struct.Ptr(2)
	return Brancher{Struct: p.Struct()}, err
}

func (s ChooseMore) HasElse() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s ChooseMore) SetElse(v Brancher) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewElse sets the else field to a newly
// allocated Brancher struct, preferring placement in s's segment.
func (s ChooseMore) NewElse() (Brancher, error) {
	ss, err := NewBrancher(s.Struct.Segment())
	if err != nil {
		return Brancher{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// ChooseMore_List is a list of ChooseMore.
type ChooseMore_List struct{ capnp.List }

// NewChooseMore creates a new list of ChooseMore.
func NewChooseMore_List(s *capnp.Segment, sz int32) (ChooseMore_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return ChooseMore_List{l}, err
}

func (s ChooseMore_List) At(i int) ChooseMore { return ChooseMore{s.List.Struct(i)} }

func (s ChooseMore_List) Set(i int, v ChooseMore) error { return s.List.SetStruct(i, v.Struct) }

func (s ChooseMore_List) String() string {
	str, _ := text.MarshalList(0xfc4a8aca1a8b1a1d, s.List)
	return str
}

// ChooseMore_Promise is a wrapper for a ChooseMore promised by a client call.
type ChooseMore_Promise struct{ *capnp.Pipeline }

func (p ChooseMore_Promise) Struct() (ChooseMore, error) {
	s, err := p.Pipeline.Struct()
	return ChooseMore{s}, err
}

func (p ChooseMore_Promise) If() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ChooseMore_Promise) Else() Brancher_Promise {
	return Brancher_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type ChooseMoreValue struct{ capnp.Struct }

// ChooseMoreValue_TypeID is the unique identifier for the type ChooseMoreValue.
const ChooseMoreValue_TypeID = 0xbe05fb96cb25d848

func NewChooseMoreValue(s *capnp.Segment) (ChooseMoreValue, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return ChooseMoreValue{st}, err
}

func NewRootChooseMoreValue(s *capnp.Segment) (ChooseMoreValue, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return ChooseMoreValue{st}, err
}

func ReadRootChooseMoreValue(msg *capnp.Message) (ChooseMoreValue, error) {
	root, err := msg.RootPtr()
	return ChooseMoreValue{root.Struct()}, err
}

func (s ChooseMoreValue) String() string {
	str, _ := text.Marshal(0xbe05fb96cb25d848, s.Struct)
	return str
}

func (s ChooseMoreValue) Assign() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s ChooseMoreValue) HasAssign() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChooseMoreValue) SetAssign(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAssign sets the assign field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s ChooseMoreValue) NewAssign() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseMoreValue) From() (Assignment, error) {
	p, err := s.Struct.Ptr(1)
	return Assignment{Struct: p.Struct()}, err
}

func (s ChooseMoreValue) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ChooseMoreValue) SetFrom(v Assignment) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s ChooseMoreValue) NewFrom() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseMoreValue) Filter() (BoolEval, error) {
	p, err := s.Struct.Ptr(2)
	return BoolEval{Struct: p.Struct()}, err
}

func (s ChooseMoreValue) HasFilter() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s ChooseMoreValue) SetFilter(v BoolEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewFilter sets the filter field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s ChooseMoreValue) NewFilter() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseMoreValue) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(3)
	return Execute_List{List: p.List()}, err
}

func (s ChooseMoreValue) HasExe() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s ChooseMoreValue) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(3, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s ChooseMoreValue) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(3, l.List.ToPtr())
	return l, err
}

func (s ChooseMoreValue) Else() (Brancher, error) {
	p, err := s.Struct.Ptr(4)
	return Brancher{Struct: p.Struct()}, err
}

func (s ChooseMoreValue) HasElse() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s ChooseMoreValue) SetElse(v Brancher) error {
	return s.Struct.SetPtr(4, v.Struct.ToPtr())
}

// NewElse sets the else field to a newly
// allocated Brancher struct, preferring placement in s's segment.
func (s ChooseMoreValue) NewElse() (Brancher, error) {
	ss, err := NewBrancher(s.Struct.Segment())
	if err != nil {
		return Brancher{}, err
	}
	err = s.Struct.SetPtr(4, ss.Struct.ToPtr())
	return ss, err
}

// ChooseMoreValue_List is a list of ChooseMoreValue.
type ChooseMoreValue_List struct{ capnp.List }

// NewChooseMoreValue creates a new list of ChooseMoreValue.
func NewChooseMoreValue_List(s *capnp.Segment, sz int32) (ChooseMoreValue_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return ChooseMoreValue_List{l}, err
}

func (s ChooseMoreValue_List) At(i int) ChooseMoreValue { return ChooseMoreValue{s.List.Struct(i)} }

func (s ChooseMoreValue_List) Set(i int, v ChooseMoreValue) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s ChooseMoreValue_List) String() string {
	str, _ := text.MarshalList(0xbe05fb96cb25d848, s.List)
	return str
}

// ChooseMoreValue_Promise is a wrapper for a ChooseMoreValue promised by a client call.
type ChooseMoreValue_Promise struct{ *capnp.Pipeline }

func (p ChooseMoreValue_Promise) Struct() (ChooseMoreValue, error) {
	s, err := p.Pipeline.Struct()
	return ChooseMoreValue{s}, err
}

func (p ChooseMoreValue_Promise) Assign() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ChooseMoreValue_Promise) From() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p ChooseMoreValue_Promise) Filter() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

func (p ChooseMoreValue_Promise) Else() Brancher_Promise {
	return Brancher_Promise{Pipeline: p.Pipeline.GetPipeline(4)}
}

type ChooseNothingElse struct{ capnp.Struct }

// ChooseNothingElse_TypeID is the unique identifier for the type ChooseNothingElse.
const ChooseNothingElse_TypeID = 0xcd747719115e1999

func NewChooseNothingElse(s *capnp.Segment) (ChooseNothingElse, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ChooseNothingElse{st}, err
}

func NewRootChooseNothingElse(s *capnp.Segment) (ChooseNothingElse, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ChooseNothingElse{st}, err
}

func ReadRootChooseNothingElse(msg *capnp.Message) (ChooseNothingElse, error) {
	root, err := msg.RootPtr()
	return ChooseNothingElse{root.Struct()}, err
}

func (s ChooseNothingElse) String() string {
	str, _ := text.Marshal(0xcd747719115e1999, s.Struct)
	return str
}

func (s ChooseNothingElse) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s ChooseNothingElse) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChooseNothingElse) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s ChooseNothingElse) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// ChooseNothingElse_List is a list of ChooseNothingElse.
type ChooseNothingElse_List struct{ capnp.List }

// NewChooseNothingElse creates a new list of ChooseNothingElse.
func NewChooseNothingElse_List(s *capnp.Segment, sz int32) (ChooseNothingElse_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return ChooseNothingElse_List{l}, err
}

func (s ChooseNothingElse_List) At(i int) ChooseNothingElse {
	return ChooseNothingElse{s.List.Struct(i)}
}

func (s ChooseNothingElse_List) Set(i int, v ChooseNothingElse) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s ChooseNothingElse_List) String() string {
	str, _ := text.MarshalList(0xcd747719115e1999, s.List)
	return str
}

// ChooseNothingElse_Promise is a wrapper for a ChooseNothingElse promised by a client call.
type ChooseNothingElse_Promise struct{ *capnp.Pipeline }

func (p ChooseNothingElse_Promise) Struct() (ChooseNothingElse, error) {
	s, err := p.Pipeline.Struct()
	return ChooseNothingElse{s}, err
}

type ChooseNum struct{ capnp.Struct }

// ChooseNum_TypeID is the unique identifier for the type ChooseNum.
const ChooseNum_TypeID = 0x9743eec37d4e392f

func NewChooseNum(s *capnp.Segment) (ChooseNum, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ChooseNum{st}, err
}

func NewRootChooseNum(s *capnp.Segment) (ChooseNum, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ChooseNum{st}, err
}

func ReadRootChooseNum(msg *capnp.Message) (ChooseNum, error) {
	root, err := msg.RootPtr()
	return ChooseNum{root.Struct()}, err
}

func (s ChooseNum) String() string {
	str, _ := text.Marshal(0x9743eec37d4e392f, s.Struct)
	return str
}

func (s ChooseNum) True() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s ChooseNum) HasTrue() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChooseNum) SetTrue(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTrue sets the true field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s ChooseNum) NewTrue() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseNum) If() (BoolEval, error) {
	p, err := s.Struct.Ptr(1)
	return BoolEval{Struct: p.Struct()}, err
}

func (s ChooseNum) HasIf() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ChooseNum) SetIf(v BoolEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewIf sets the if field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s ChooseNum) NewIf() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseNum) False() (NumberEval, error) {
	p, err := s.Struct.Ptr(2)
	return NumberEval{Struct: p.Struct()}, err
}

func (s ChooseNum) HasFalse() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s ChooseNum) SetFalse(v NumberEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewFalse sets the false field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s ChooseNum) NewFalse() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// ChooseNum_List is a list of ChooseNum.
type ChooseNum_List struct{ capnp.List }

// NewChooseNum creates a new list of ChooseNum.
func NewChooseNum_List(s *capnp.Segment, sz int32) (ChooseNum_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return ChooseNum_List{l}, err
}

func (s ChooseNum_List) At(i int) ChooseNum { return ChooseNum{s.List.Struct(i)} }

func (s ChooseNum_List) Set(i int, v ChooseNum) error { return s.List.SetStruct(i, v.Struct) }

func (s ChooseNum_List) String() string {
	str, _ := text.MarshalList(0x9743eec37d4e392f, s.List)
	return str
}

// ChooseNum_Promise is a wrapper for a ChooseNum promised by a client call.
type ChooseNum_Promise struct{ *capnp.Pipeline }

func (p ChooseNum_Promise) Struct() (ChooseNum, error) {
	s, err := p.Pipeline.Struct()
	return ChooseNum{s}, err
}

func (p ChooseNum_Promise) True() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ChooseNum_Promise) If() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p ChooseNum_Promise) False() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type ChooseText struct{ capnp.Struct }

// ChooseText_TypeID is the unique identifier for the type ChooseText.
const ChooseText_TypeID = 0xea0ce1692619d75b

func NewChooseText(s *capnp.Segment) (ChooseText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ChooseText{st}, err
}

func NewRootChooseText(s *capnp.Segment) (ChooseText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ChooseText{st}, err
}

func ReadRootChooseText(msg *capnp.Message) (ChooseText, error) {
	root, err := msg.RootPtr()
	return ChooseText{root.Struct()}, err
}

func (s ChooseText) String() string {
	str, _ := text.Marshal(0xea0ce1692619d75b, s.Struct)
	return str
}

func (s ChooseText) True() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s ChooseText) HasTrue() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChooseText) SetTrue(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTrue sets the true field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s ChooseText) NewTrue() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseText) If() (BoolEval, error) {
	p, err := s.Struct.Ptr(1)
	return BoolEval{Struct: p.Struct()}, err
}

func (s ChooseText) HasIf() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ChooseText) SetIf(v BoolEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewIf sets the if field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s ChooseText) NewIf() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseText) False() (TextEval, error) {
	p, err := s.Struct.Ptr(2)
	return TextEval{Struct: p.Struct()}, err
}

func (s ChooseText) HasFalse() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s ChooseText) SetFalse(v TextEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewFalse sets the false field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s ChooseText) NewFalse() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// ChooseText_List is a list of ChooseText.
type ChooseText_List struct{ capnp.List }

// NewChooseText creates a new list of ChooseText.
func NewChooseText_List(s *capnp.Segment, sz int32) (ChooseText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return ChooseText_List{l}, err
}

func (s ChooseText_List) At(i int) ChooseText { return ChooseText{s.List.Struct(i)} }

func (s ChooseText_List) Set(i int, v ChooseText) error { return s.List.SetStruct(i, v.Struct) }

func (s ChooseText_List) String() string {
	str, _ := text.MarshalList(0xea0ce1692619d75b, s.List)
	return str
}

// ChooseText_Promise is a wrapper for a ChooseText promised by a client call.
type ChooseText_Promise struct{ *capnp.Pipeline }

func (p ChooseText_Promise) Struct() (ChooseText, error) {
	s, err := p.Pipeline.Struct()
	return ChooseText{s}, err
}

func (p ChooseText_Promise) True() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ChooseText_Promise) If() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p ChooseText_Promise) False() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type ChooseValue struct{ capnp.Struct }

// ChooseValue_TypeID is the unique identifier for the type ChooseValue.
const ChooseValue_TypeID = 0xa7400d2e03e80da1

func NewChooseValue(s *capnp.Segment) (ChooseValue, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return ChooseValue{st}, err
}

func NewRootChooseValue(s *capnp.Segment) (ChooseValue, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return ChooseValue{st}, err
}

func ReadRootChooseValue(msg *capnp.Message) (ChooseValue, error) {
	root, err := msg.RootPtr()
	return ChooseValue{root.Struct()}, err
}

func (s ChooseValue) String() string {
	str, _ := text.Marshal(0xa7400d2e03e80da1, s.Struct)
	return str
}

func (s ChooseValue) Assign() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s ChooseValue) HasAssign() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChooseValue) SetAssign(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAssign sets the assign field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s ChooseValue) NewAssign() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseValue) From() (Assignment, error) {
	p, err := s.Struct.Ptr(1)
	return Assignment{Struct: p.Struct()}, err
}

func (s ChooseValue) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ChooseValue) SetFrom(v Assignment) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s ChooseValue) NewFrom() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseValue) Filter() (BoolEval, error) {
	p, err := s.Struct.Ptr(2)
	return BoolEval{Struct: p.Struct()}, err
}

func (s ChooseValue) HasFilter() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s ChooseValue) SetFilter(v BoolEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewFilter sets the filter field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s ChooseValue) NewFilter() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

func (s ChooseValue) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(3)
	return Execute_List{List: p.List()}, err
}

func (s ChooseValue) HasExe() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s ChooseValue) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(3, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s ChooseValue) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(3, l.List.ToPtr())
	return l, err
}

func (s ChooseValue) Else() (Brancher, error) {
	p, err := s.Struct.Ptr(4)
	return Brancher{Struct: p.Struct()}, err
}

func (s ChooseValue) HasElse() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s ChooseValue) SetElse(v Brancher) error {
	return s.Struct.SetPtr(4, v.Struct.ToPtr())
}

// NewElse sets the else field to a newly
// allocated Brancher struct, preferring placement in s's segment.
func (s ChooseValue) NewElse() (Brancher, error) {
	ss, err := NewBrancher(s.Struct.Segment())
	if err != nil {
		return Brancher{}, err
	}
	err = s.Struct.SetPtr(4, ss.Struct.ToPtr())
	return ss, err
}

// ChooseValue_List is a list of ChooseValue.
type ChooseValue_List struct{ capnp.List }

// NewChooseValue creates a new list of ChooseValue.
func NewChooseValue_List(s *capnp.Segment, sz int32) (ChooseValue_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return ChooseValue_List{l}, err
}

func (s ChooseValue_List) At(i int) ChooseValue { return ChooseValue{s.List.Struct(i)} }

func (s ChooseValue_List) Set(i int, v ChooseValue) error { return s.List.SetStruct(i, v.Struct) }

func (s ChooseValue_List) String() string {
	str, _ := text.MarshalList(0xa7400d2e03e80da1, s.List)
	return str
}

// ChooseValue_Promise is a wrapper for a ChooseValue promised by a client call.
type ChooseValue_Promise struct{ *capnp.Pipeline }

func (p ChooseValue_Promise) Struct() (ChooseValue, error) {
	s, err := p.Pipeline.Struct()
	return ChooseValue{s}, err
}

func (p ChooseValue_Promise) Assign() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ChooseValue_Promise) From() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p ChooseValue_Promise) Filter() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

func (p ChooseValue_Promise) Else() Brancher_Promise {
	return Brancher_Promise{Pipeline: p.Pipeline.GetPipeline(4)}
}

type Commas struct{ capnp.Struct }

// Commas_TypeID is the unique identifier for the type Commas.
const Commas_TypeID = 0xa4684023b73fbef8

func NewCommas(s *capnp.Segment) (Commas, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Commas{st}, err
}

func NewRootCommas(s *capnp.Segment) (Commas, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Commas{st}, err
}

func ReadRootCommas(msg *capnp.Message) (Commas, error) {
	root, err := msg.RootPtr()
	return Commas{root.Struct()}, err
}

func (s Commas) String() string {
	str, _ := text.Marshal(0xa4684023b73fbef8, s.Struct)
	return str
}

func (s Commas) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s Commas) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Commas) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Commas) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Commas_List is a list of Commas.
type Commas_List struct{ capnp.List }

// NewCommas creates a new list of Commas.
func NewCommas_List(s *capnp.Segment, sz int32) (Commas_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Commas_List{l}, err
}

func (s Commas_List) At(i int) Commas { return Commas{s.List.Struct(i)} }

func (s Commas_List) Set(i int, v Commas) error { return s.List.SetStruct(i, v.Struct) }

func (s Commas_List) String() string {
	str, _ := text.MarshalList(0xa4684023b73fbef8, s.List)
	return str
}

// Commas_Promise is a wrapper for a Commas promised by a client call.
type Commas_Promise struct{ *capnp.Pipeline }

func (p Commas_Promise) Struct() (Commas, error) {
	s, err := p.Pipeline.Struct()
	return Commas{s}, err
}

type CompareNum struct{ capnp.Struct }

// CompareNum_TypeID is the unique identifier for the type CompareNum.
const CompareNum_TypeID = 0xaa282bffe60f4044

func NewCompareNum(s *capnp.Segment) (CompareNum, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return CompareNum{st}, err
}

func NewRootCompareNum(s *capnp.Segment) (CompareNum, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return CompareNum{st}, err
}

func ReadRootCompareNum(msg *capnp.Message) (CompareNum, error) {
	root, err := msg.RootPtr()
	return CompareNum{root.Struct()}, err
}

func (s CompareNum) String() string {
	str, _ := text.Marshal(0xaa282bffe60f4044, s.Struct)
	return str
}

func (s CompareNum) A() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s CompareNum) HasA() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s CompareNum) SetA(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA sets the a field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s CompareNum) NewA() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s CompareNum) Is() (Comparator, error) {
	p, err := s.Struct.Ptr(1)
	return Comparator{Struct: p.Struct()}, err
}

func (s CompareNum) HasIs() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s CompareNum) SetIs(v Comparator) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewIs sets the is field to a newly
// allocated Comparator struct, preferring placement in s's segment.
func (s CompareNum) NewIs() (Comparator, error) {
	ss, err := NewComparator(s.Struct.Segment())
	if err != nil {
		return Comparator{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s CompareNum) B() (NumberEval, error) {
	p, err := s.Struct.Ptr(2)
	return NumberEval{Struct: p.Struct()}, err
}

func (s CompareNum) HasB() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s CompareNum) SetB(v NumberEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewB sets the b field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s CompareNum) NewB() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// CompareNum_List is a list of CompareNum.
type CompareNum_List struct{ capnp.List }

// NewCompareNum creates a new list of CompareNum.
func NewCompareNum_List(s *capnp.Segment, sz int32) (CompareNum_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return CompareNum_List{l}, err
}

func (s CompareNum_List) At(i int) CompareNum { return CompareNum{s.List.Struct(i)} }

func (s CompareNum_List) Set(i int, v CompareNum) error { return s.List.SetStruct(i, v.Struct) }

func (s CompareNum_List) String() string {
	str, _ := text.MarshalList(0xaa282bffe60f4044, s.List)
	return str
}

// CompareNum_Promise is a wrapper for a CompareNum promised by a client call.
type CompareNum_Promise struct{ *capnp.Pipeline }

func (p CompareNum_Promise) Struct() (CompareNum, error) {
	s, err := p.Pipeline.Struct()
	return CompareNum{s}, err
}

func (p CompareNum_Promise) A() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p CompareNum_Promise) Is() Comparator_Promise {
	return Comparator_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p CompareNum_Promise) B() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type CompareText struct{ capnp.Struct }

// CompareText_TypeID is the unique identifier for the type CompareText.
const CompareText_TypeID = 0xb053d8b85fa422b3

func NewCompareText(s *capnp.Segment) (CompareText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return CompareText{st}, err
}

func NewRootCompareText(s *capnp.Segment) (CompareText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return CompareText{st}, err
}

func ReadRootCompareText(msg *capnp.Message) (CompareText, error) {
	root, err := msg.RootPtr()
	return CompareText{root.Struct()}, err
}

func (s CompareText) String() string {
	str, _ := text.Marshal(0xb053d8b85fa422b3, s.Struct)
	return str
}

func (s CompareText) A() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s CompareText) HasA() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s CompareText) SetA(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA sets the a field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s CompareText) NewA() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s CompareText) Is() (Comparator, error) {
	p, err := s.Struct.Ptr(1)
	return Comparator{Struct: p.Struct()}, err
}

func (s CompareText) HasIs() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s CompareText) SetIs(v Comparator) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewIs sets the is field to a newly
// allocated Comparator struct, preferring placement in s's segment.
func (s CompareText) NewIs() (Comparator, error) {
	ss, err := NewComparator(s.Struct.Segment())
	if err != nil {
		return Comparator{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s CompareText) B() (TextEval, error) {
	p, err := s.Struct.Ptr(2)
	return TextEval{Struct: p.Struct()}, err
}

func (s CompareText) HasB() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s CompareText) SetB(v TextEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewB sets the b field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s CompareText) NewB() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// CompareText_List is a list of CompareText.
type CompareText_List struct{ capnp.List }

// NewCompareText creates a new list of CompareText.
func NewCompareText_List(s *capnp.Segment, sz int32) (CompareText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return CompareText_List{l}, err
}

func (s CompareText_List) At(i int) CompareText { return CompareText{s.List.Struct(i)} }

func (s CompareText_List) Set(i int, v CompareText) error { return s.List.SetStruct(i, v.Struct) }

func (s CompareText_List) String() string {
	str, _ := text.MarshalList(0xb053d8b85fa422b3, s.List)
	return str
}

// CompareText_Promise is a wrapper for a CompareText promised by a client call.
type CompareText_Promise struct{ *capnp.Pipeline }

func (p CompareText_Promise) Struct() (CompareText, error) {
	s, err := p.Pipeline.Struct()
	return CompareText{s}, err
}

func (p CompareText_Promise) A() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p CompareText_Promise) Is() Comparator_Promise {
	return Comparator_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p CompareText_Promise) B() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type CountOf struct{ capnp.Struct }

// CountOf_TypeID is the unique identifier for the type CountOf.
const CountOf_TypeID = 0xd9fa6a0210ede1b6

func NewCountOf(s *capnp.Segment) (CountOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return CountOf{st}, err
}

func NewRootCountOf(s *capnp.Segment) (CountOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return CountOf{st}, err
}

func ReadRootCountOf(msg *capnp.Message) (CountOf, error) {
	root, err := msg.RootPtr()
	return CountOf{root.Struct()}, err
}

func (s CountOf) String() string {
	str, _ := text.Marshal(0xd9fa6a0210ede1b6, s.Struct)
	return str
}

func (s CountOf) At() (Pos, error) {
	p, err := s.Struct.Ptr(0)
	return Pos{Struct: p.Struct()}, err
}

func (s CountOf) HasAt() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s CountOf) SetAt(v Pos) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAt sets the at field to a newly
// allocated Pos struct, preferring placement in s's segment.
func (s CountOf) NewAt() (Pos, error) {
	ss, err := NewPos(s.Struct.Segment())
	if err != nil {
		return Pos{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s CountOf) Num() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s CountOf) HasNum() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s CountOf) SetNum(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s CountOf) NewNum() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s CountOf) Trigger() (Trigger, error) {
	p, err := s.Struct.Ptr(2)
	return Trigger{Struct: p.Struct()}, err
}

func (s CountOf) HasTrigger() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s CountOf) SetTrigger(v Trigger) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewTrigger sets the trigger field to a newly
// allocated Trigger struct, preferring placement in s's segment.
func (s CountOf) NewTrigger() (Trigger, error) {
	ss, err := NewTrigger(s.Struct.Segment())
	if err != nil {
		return Trigger{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// CountOf_List is a list of CountOf.
type CountOf_List struct{ capnp.List }

// NewCountOf creates a new list of CountOf.
func NewCountOf_List(s *capnp.Segment, sz int32) (CountOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return CountOf_List{l}, err
}

func (s CountOf_List) At(i int) CountOf { return CountOf{s.List.Struct(i)} }

func (s CountOf_List) Set(i int, v CountOf) error { return s.List.SetStruct(i, v.Struct) }

func (s CountOf_List) String() string {
	str, _ := text.MarshalList(0xd9fa6a0210ede1b6, s.List)
	return str
}

// CountOf_Promise is a wrapper for a CountOf promised by a client call.
type CountOf_Promise struct{ *capnp.Pipeline }

func (p CountOf_Promise) Struct() (CountOf, error) {
	s, err := p.Pipeline.Struct()
	return CountOf{s}, err
}

func (p CountOf_Promise) At() Pos_Promise {
	return Pos_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p CountOf_Promise) Num() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p CountOf_Promise) Trigger() Trigger_Promise {
	return Trigger_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type CycleText struct{ capnp.Struct }

// CycleText_TypeID is the unique identifier for the type CycleText.
const CycleText_TypeID = 0x812dd1a8ad7759f9

func NewCycleText(s *capnp.Segment) (CycleText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return CycleText{st}, err
}

func NewRootCycleText(s *capnp.Segment) (CycleText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return CycleText{st}, err
}

func ReadRootCycleText(msg *capnp.Message) (CycleText, error) {
	root, err := msg.RootPtr()
	return CycleText{root.Struct()}, err
}

func (s CycleText) String() string {
	str, _ := text.Marshal(0x812dd1a8ad7759f9, s.Struct)
	return str
}

func (s CycleText) Seq() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s CycleText) HasSeq() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s CycleText) SetSeq(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSeq sets the seq field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s CycleText) NewSeq() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s CycleText) Parts() (TextEval_List, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval_List{List: p.List()}, err
}

func (s CycleText) HasParts() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s CycleText) SetParts(v TextEval_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewParts sets the parts field to a newly
// allocated TextEval_List, preferring placement in s's segment.
func (s CycleText) NewParts(n int32) (TextEval_List, error) {
	l, err := NewTextEval_List(s.Struct.Segment(), n)
	if err != nil {
		return TextEval_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// CycleText_List is a list of CycleText.
type CycleText_List struct{ capnp.List }

// NewCycleText creates a new list of CycleText.
func NewCycleText_List(s *capnp.Segment, sz int32) (CycleText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return CycleText_List{l}, err
}

func (s CycleText_List) At(i int) CycleText { return CycleText{s.List.Struct(i)} }

func (s CycleText_List) Set(i int, v CycleText) error { return s.List.SetStruct(i, v.Struct) }

func (s CycleText_List) String() string {
	str, _ := text.MarshalList(0x812dd1a8ad7759f9, s.List)
	return str
}

// CycleText_Promise is a wrapper for a CycleText promised by a client call.
type CycleText_Promise struct{ *capnp.Pipeline }

func (p CycleText_Promise) Struct() (CycleText, error) {
	s, err := p.Pipeline.Struct()
	return CycleText{s}, err
}

func (p CycleText_Promise) Seq() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Determine struct{ capnp.Struct }

// Determine_TypeID is the unique identifier for the type Determine.
const Determine_TypeID = 0xa3b0f7785a873f0f

func NewDetermine(s *capnp.Segment) (Determine, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Determine{st}, err
}

func NewRootDetermine(s *capnp.Segment) (Determine, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Determine{st}, err
}

func ReadRootDetermine(msg *capnp.Message) (Determine, error) {
	root, err := msg.RootPtr()
	return Determine{root.Struct()}, err
}

func (s Determine) String() string {
	str, _ := text.Marshal(0xa3b0f7785a873f0f, s.Struct)
	return str
}

func (s Determine) Pattern() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Determine) HasPattern() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Determine) SetPattern(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPattern sets the pattern field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Determine) NewPattern() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Determine) Args() (Argument_List, error) {
	p, err := s.Struct.Ptr(1)
	return Argument_List{List: p.List()}, err
}

func (s Determine) HasArgs() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Determine) SetArgs(v Argument_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated Argument_List, preferring placement in s's segment.
func (s Determine) NewArgs(n int32) (Argument_List, error) {
	l, err := NewArgument_List(s.Struct.Segment(), n)
	if err != nil {
		return Argument_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Determine_List is a list of Determine.
type Determine_List struct{ capnp.List }

// NewDetermine creates a new list of Determine.
func NewDetermine_List(s *capnp.Segment, sz int32) (Determine_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Determine_List{l}, err
}

func (s Determine_List) At(i int) Determine { return Determine{s.List.Struct(i)} }

func (s Determine_List) Set(i int, v Determine) error { return s.List.SetStruct(i, v.Struct) }

func (s Determine_List) String() string {
	str, _ := text.MarshalList(0xa3b0f7785a873f0f, s.List)
	return str
}

// Determine_Promise is a wrapper for a Determine promised by a client call.
type Determine_Promise struct{ *capnp.Pipeline }

func (p Determine_Promise) Struct() (Determine, error) {
	s, err := p.Pipeline.Struct()
	return Determine{s}, err
}

func (p Determine_Promise) Pattern() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type DiffOf struct{ capnp.Struct }

// DiffOf_TypeID is the unique identifier for the type DiffOf.
const DiffOf_TypeID = 0xa78edef01722c579

func NewDiffOf(s *capnp.Segment) (DiffOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DiffOf{st}, err
}

func NewRootDiffOf(s *capnp.Segment) (DiffOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DiffOf{st}, err
}

func ReadRootDiffOf(msg *capnp.Message) (DiffOf, error) {
	root, err := msg.RootPtr()
	return DiffOf{root.Struct()}, err
}

func (s DiffOf) String() string {
	str, _ := text.Marshal(0xa78edef01722c579, s.Struct)
	return str
}

func (s DiffOf) A() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s DiffOf) HasA() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DiffOf) SetA(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA sets the a field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s DiffOf) NewA() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s DiffOf) B() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s DiffOf) HasB() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s DiffOf) SetB(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewB sets the b field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s DiffOf) NewB() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// DiffOf_List is a list of DiffOf.
type DiffOf_List struct{ capnp.List }

// NewDiffOf creates a new list of DiffOf.
func NewDiffOf_List(s *capnp.Segment, sz int32) (DiffOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return DiffOf_List{l}, err
}

func (s DiffOf_List) At(i int) DiffOf { return DiffOf{s.List.Struct(i)} }

func (s DiffOf_List) Set(i int, v DiffOf) error { return s.List.SetStruct(i, v.Struct) }

func (s DiffOf_List) String() string {
	str, _ := text.MarshalList(0xa78edef01722c579, s.List)
	return str
}

// DiffOf_Promise is a wrapper for a DiffOf promised by a client call.
type DiffOf_Promise struct{ *capnp.Pipeline }

func (p DiffOf_Promise) Struct() (DiffOf, error) {
	s, err := p.Pipeline.Struct()
	return DiffOf{s}, err
}

func (p DiffOf_Promise) A() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p DiffOf_Promise) B() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Directive struct{ capnp.Struct }

// Directive_TypeID is the unique identifier for the type Directive.
const Directive_TypeID = 0xb30b5da348cf6bb7

func NewDirective(s *capnp.Segment) (Directive, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Directive{st}, err
}

func NewRootDirective(s *capnp.Segment) (Directive, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Directive{st}, err
}

func ReadRootDirective(msg *capnp.Message) (Directive, error) {
	root, err := msg.RootPtr()
	return Directive{root.Struct()}, err
}

func (s Directive) String() string {
	str, _ := text.Marshal(0xb30b5da348cf6bb7, s.Struct)
	return str
}

func (s Directive) Lede() (Text_List, error) {
	p, err := s.Struct.Ptr(0)
	return Text_List{List: p.List()}, err
}

func (s Directive) HasLede() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Directive) SetLede(v Text_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewLede sets the lede field to a newly
// allocated Text_List, preferring placement in s's segment.
func (s Directive) NewLede(n int32) (Text_List, error) {
	l, err := NewText_List(s.Struct.Segment(), n)
	if err != nil {
		return Text_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Directive) Scans() (ScannerMaker_List, error) {
	p, err := s.Struct.Ptr(1)
	return ScannerMaker_List{List: p.List()}, err
}

func (s Directive) HasScans() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Directive) SetScans(v ScannerMaker_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewScans sets the scans field to a newly
// allocated ScannerMaker_List, preferring placement in s's segment.
func (s Directive) NewScans(n int32) (ScannerMaker_List, error) {
	l, err := NewScannerMaker_List(s.Struct.Segment(), n)
	if err != nil {
		return ScannerMaker_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Directive_List is a list of Directive.
type Directive_List struct{ capnp.List }

// NewDirective creates a new list of Directive.
func NewDirective_List(s *capnp.Segment, sz int32) (Directive_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Directive_List{l}, err
}

func (s Directive_List) At(i int) Directive { return Directive{s.List.Struct(i)} }

func (s Directive_List) Set(i int, v Directive) error { return s.List.SetStruct(i, v.Struct) }

func (s Directive_List) String() string {
	str, _ := text.MarshalList(0xb30b5da348cf6bb7, s.List)
	return str
}

// Directive_Promise is a wrapper for a Directive promised by a client call.
type Directive_Promise struct{ *capnp.Pipeline }

func (p Directive_Promise) Struct() (Directive, error) {
	s, err := p.Pipeline.Struct()
	return Directive{s}, err
}

type DoNothing struct{ capnp.Struct }

// DoNothing_TypeID is the unique identifier for the type DoNothing.
const DoNothing_TypeID = 0xdd65c12e2085e492

func NewDoNothing(s *capnp.Segment) (DoNothing, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return DoNothing{st}, err
}

func NewRootDoNothing(s *capnp.Segment) (DoNothing, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return DoNothing{st}, err
}

func ReadRootDoNothing(msg *capnp.Message) (DoNothing, error) {
	root, err := msg.RootPtr()
	return DoNothing{root.Struct()}, err
}

func (s DoNothing) String() string {
	str, _ := text.Marshal(0xdd65c12e2085e492, s.Struct)
	return str
}

func (s DoNothing) Reason() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s DoNothing) HasReason() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DoNothing) SetReason(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewReason sets the reason field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s DoNothing) NewReason() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// DoNothing_List is a list of DoNothing.
type DoNothing_List struct{ capnp.List }

// NewDoNothing creates a new list of DoNothing.
func NewDoNothing_List(s *capnp.Segment, sz int32) (DoNothing_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return DoNothing_List{l}, err
}

func (s DoNothing_List) At(i int) DoNothing { return DoNothing{s.List.Struct(i)} }

func (s DoNothing_List) Set(i int, v DoNothing) error { return s.List.SetStruct(i, v.Struct) }

func (s DoNothing_List) String() string {
	str, _ := text.MarshalList(0xdd65c12e2085e492, s.List)
	return str
}

// DoNothing_Promise is a wrapper for a DoNothing promised by a client call.
type DoNothing_Promise struct{ *capnp.Pipeline }

func (p DoNothing_Promise) Struct() (DoNothing, error) {
	s, err := p.Pipeline.Struct()
	return DoNothing{s}, err
}

func (p DoNothing_Promise) Reason() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type During struct{ capnp.Struct }

// During_TypeID is the unique identifier for the type During.
const During_TypeID = 0x9f1b94a6ee096ce5

func NewDuring(s *capnp.Segment) (During, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return During{st}, err
}

func NewRootDuring(s *capnp.Segment) (During, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return During{st}, err
}

func ReadRootDuring(msg *capnp.Message) (During, error) {
	root, err := msg.RootPtr()
	return During{root.Struct()}, err
}

func (s During) String() string {
	str, _ := text.Marshal(0x9f1b94a6ee096ce5, s.Struct)
	return str
}

func (s During) Pattern() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s During) HasPattern() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s During) SetPattern(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPattern sets the pattern field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s During) NewPattern() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// During_List is a list of During.
type During_List struct{ capnp.List }

// NewDuring creates a new list of During.
func NewDuring_List(s *capnp.Segment, sz int32) (During_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return During_List{l}, err
}

func (s During_List) At(i int) During { return During{s.List.Struct(i)} }

func (s During_List) Set(i int, v During) error { return s.List.SetStruct(i, v.Struct) }

func (s During_List) String() string {
	str, _ := text.MarshalList(0x9f1b94a6ee096ce5, s.List)
	return str
}

// During_Promise is a wrapper for a During promised by a client call.
type During_Promise struct{ *capnp.Pipeline }

func (p During_Promise) Struct() (During, error) {
	s, err := p.Pipeline.Struct()
	return During{s}, err
}

func (p During_Promise) Pattern() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Each struct{ capnp.Struct }

// Each_TypeID is the unique identifier for the type Each.
const Each_TypeID = 0xe65505e94c48745a

func NewEach(s *capnp.Segment) (Each, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return Each{st}, err
}

func NewRootEach(s *capnp.Segment) (Each, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return Each{st}, err
}

func ReadRootEach(msg *capnp.Message) (Each, error) {
	root, err := msg.RootPtr()
	return Each{root.Struct()}, err
}

func (s Each) String() string {
	str, _ := text.Marshal(0xe65505e94c48745a, s.Struct)
	return str
}

func (s Each) List() (Assignment, error) {
	p, err := s.Struct.Ptr(0)
	return Assignment{Struct: p.Struct()}, err
}

func (s Each) HasList() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Each) SetList(v Assignment) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewList sets the list field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Each) NewList() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Each) As() (ListIterator, error) {
	p, err := s.Struct.Ptr(1)
	return ListIterator{Struct: p.Struct()}, err
}

func (s Each) HasAs() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Each) SetAs(v ListIterator) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAs sets the as field to a newly
// allocated ListIterator struct, preferring placement in s's segment.
func (s Each) NewAs() (ListIterator, error) {
	ss, err := NewListIterator(s.Struct.Segment())
	if err != nil {
		return ListIterator{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Each) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(2)
	return Execute_List{List: p.List()}, err
}

func (s Each) HasExe() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Each) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Each) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

func (s Each) Else() (Brancher, error) {
	p, err := s.Struct.Ptr(3)
	return Brancher{Struct: p.Struct()}, err
}

func (s Each) HasElse() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Each) SetElse(v Brancher) error {
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewElse sets the else field to a newly
// allocated Brancher struct, preferring placement in s's segment.
func (s Each) NewElse() (Brancher, error) {
	ss, err := NewBrancher(s.Struct.Segment())
	if err != nil {
		return Brancher{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

// Each_List is a list of Each.
type Each_List struct{ capnp.List }

// NewEach creates a new list of Each.
func NewEach_List(s *capnp.Segment, sz int32) (Each_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return Each_List{l}, err
}

func (s Each_List) At(i int) Each { return Each{s.List.Struct(i)} }

func (s Each_List) Set(i int, v Each) error { return s.List.SetStruct(i, v.Struct) }

func (s Each_List) String() string {
	str, _ := text.MarshalList(0xe65505e94c48745a, s.List)
	return str
}

// Each_Promise is a wrapper for a Each promised by a client call.
type Each_Promise struct{ *capnp.Pipeline }

func (p Each_Promise) Struct() (Each, error) {
	s, err := p.Pipeline.Struct()
	return Each{s}, err
}

func (p Each_Promise) List() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Each_Promise) As() ListIterator_Promise {
	return ListIterator_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Each_Promise) Else() Brancher_Promise {
	return Brancher_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

type EqualTo struct{ capnp.Struct }

// EqualTo_TypeID is the unique identifier for the type EqualTo.
const EqualTo_TypeID = 0x9e1117b3e9f744d7

func NewEqualTo(s *capnp.Segment) (EqualTo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EqualTo{st}, err
}

func NewRootEqualTo(s *capnp.Segment) (EqualTo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return EqualTo{st}, err
}

func ReadRootEqualTo(msg *capnp.Message) (EqualTo, error) {
	root, err := msg.RootPtr()
	return EqualTo{root.Struct()}, err
}

func (s EqualTo) String() string {
	str, _ := text.Marshal(0x9e1117b3e9f744d7, s.Struct)
	return str
}

// EqualTo_List is a list of EqualTo.
type EqualTo_List struct{ capnp.List }

// NewEqualTo creates a new list of EqualTo.
func NewEqualTo_List(s *capnp.Segment, sz int32) (EqualTo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return EqualTo_List{l}, err
}

func (s EqualTo_List) At(i int) EqualTo { return EqualTo{s.List.Struct(i)} }

func (s EqualTo_List) Set(i int, v EqualTo) error { return s.List.SetStruct(i, v.Struct) }

func (s EqualTo_List) String() string {
	str, _ := text.MarshalList(0x9e1117b3e9f744d7, s.List)
	return str
}

// EqualTo_Promise is a wrapper for a EqualTo promised by a client call.
type EqualTo_Promise struct{ *capnp.Pipeline }

func (p EqualTo_Promise) Struct() (EqualTo, error) {
	s, err := p.Pipeline.Struct()
	return EqualTo{s}, err
}

type EraseEdge struct{ capnp.Struct }

// EraseEdge_TypeID is the unique identifier for the type EraseEdge.
const EraseEdge_TypeID = 0xd6a643d6039ea176

func NewEraseEdge(s *capnp.Segment) (EraseEdge, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return EraseEdge{st}, err
}

func NewRootEraseEdge(s *capnp.Segment) (EraseEdge, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return EraseEdge{st}, err
}

func ReadRootEraseEdge(msg *capnp.Message) (EraseEdge, error) {
	root, err := msg.RootPtr()
	return EraseEdge{root.Struct()}, err
}

func (s EraseEdge) String() string {
	str, _ := text.Marshal(0xd6a643d6039ea176, s.Struct)
	return str
}

func (s EraseEdge) From() (ListSource, error) {
	p, err := s.Struct.Ptr(0)
	return ListSource{Struct: p.Struct()}, err
}

func (s EraseEdge) HasFrom() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s EraseEdge) SetFrom(v ListSource) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated ListSource struct, preferring placement in s's segment.
func (s EraseEdge) NewFrom() (ListSource, error) {
	ss, err := NewListSource(s.Struct.Segment())
	if err != nil {
		return ListSource{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s EraseEdge) AtEdge() (Bool, error) {
	p, err := s.Struct.Ptr(1)
	return Bool{Struct: p.Struct()}, err
}

func (s EraseEdge) HasAtEdge() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s EraseEdge) SetAtEdge(v Bool) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAtEdge sets the atEdge field to a newly
// allocated Bool struct, preferring placement in s's segment.
func (s EraseEdge) NewAtEdge() (Bool, error) {
	ss, err := NewBool(s.Struct.Segment())
	if err != nil {
		return Bool{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// EraseEdge_List is a list of EraseEdge.
type EraseEdge_List struct{ capnp.List }

// NewEraseEdge creates a new list of EraseEdge.
func NewEraseEdge_List(s *capnp.Segment, sz int32) (EraseEdge_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return EraseEdge_List{l}, err
}

func (s EraseEdge_List) At(i int) EraseEdge { return EraseEdge{s.List.Struct(i)} }

func (s EraseEdge_List) Set(i int, v EraseEdge) error { return s.List.SetStruct(i, v.Struct) }

func (s EraseEdge_List) String() string {
	str, _ := text.MarshalList(0xd6a643d6039ea176, s.List)
	return str
}

// EraseEdge_Promise is a wrapper for a EraseEdge promised by a client call.
type EraseEdge_Promise struct{ *capnp.Pipeline }

func (p EraseEdge_Promise) Struct() (EraseEdge, error) {
	s, err := p.Pipeline.Struct()
	return EraseEdge{s}, err
}

func (p EraseEdge_Promise) From() ListSource_Promise {
	return ListSource_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p EraseEdge_Promise) AtEdge() Bool_Promise {
	return Bool_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type EraseIndex struct{ capnp.Struct }

// EraseIndex_TypeID is the unique identifier for the type EraseIndex.
const EraseIndex_TypeID = 0x96178f58af6d467c

func NewEraseIndex(s *capnp.Segment) (EraseIndex, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return EraseIndex{st}, err
}

func NewRootEraseIndex(s *capnp.Segment) (EraseIndex, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return EraseIndex{st}, err
}

func ReadRootEraseIndex(msg *capnp.Message) (EraseIndex, error) {
	root, err := msg.RootPtr()
	return EraseIndex{root.Struct()}, err
}

func (s EraseIndex) String() string {
	str, _ := text.Marshal(0x96178f58af6d467c, s.Struct)
	return str
}

func (s EraseIndex) Count() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s EraseIndex) HasCount() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s EraseIndex) SetCount(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCount sets the count field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s EraseIndex) NewCount() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s EraseIndex) From() (ListSource, error) {
	p, err := s.Struct.Ptr(1)
	return ListSource{Struct: p.Struct()}, err
}

func (s EraseIndex) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s EraseIndex) SetFrom(v ListSource) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated ListSource struct, preferring placement in s's segment.
func (s EraseIndex) NewFrom() (ListSource, error) {
	ss, err := NewListSource(s.Struct.Segment())
	if err != nil {
		return ListSource{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s EraseIndex) AtIndex() (NumberEval, error) {
	p, err := s.Struct.Ptr(2)
	return NumberEval{Struct: p.Struct()}, err
}

func (s EraseIndex) HasAtIndex() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s EraseIndex) SetAtIndex(v NumberEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewAtIndex sets the atIndex field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s EraseIndex) NewAtIndex() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// EraseIndex_List is a list of EraseIndex.
type EraseIndex_List struct{ capnp.List }

// NewEraseIndex creates a new list of EraseIndex.
func NewEraseIndex_List(s *capnp.Segment, sz int32) (EraseIndex_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return EraseIndex_List{l}, err
}

func (s EraseIndex_List) At(i int) EraseIndex { return EraseIndex{s.List.Struct(i)} }

func (s EraseIndex_List) Set(i int, v EraseIndex) error { return s.List.SetStruct(i, v.Struct) }

func (s EraseIndex_List) String() string {
	str, _ := text.MarshalList(0x96178f58af6d467c, s.List)
	return str
}

// EraseIndex_Promise is a wrapper for a EraseIndex promised by a client call.
type EraseIndex_Promise struct{ *capnp.Pipeline }

func (p EraseIndex_Promise) Struct() (EraseIndex, error) {
	s, err := p.Pipeline.Struct()
	return EraseIndex{s}, err
}

func (p EraseIndex_Promise) Count() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p EraseIndex_Promise) From() ListSource_Promise {
	return ListSource_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p EraseIndex_Promise) AtIndex() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type Erasing struct{ capnp.Struct }

// Erasing_TypeID is the unique identifier for the type Erasing.
const Erasing_TypeID = 0xd3cab235b0032c0c

func NewErasing(s *capnp.Segment) (Erasing, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Erasing{st}, err
}

func NewRootErasing(s *capnp.Segment) (Erasing, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Erasing{st}, err
}

func ReadRootErasing(msg *capnp.Message) (Erasing, error) {
	root, err := msg.RootPtr()
	return Erasing{root.Struct()}, err
}

func (s Erasing) String() string {
	str, _ := text.Marshal(0xd3cab235b0032c0c, s.Struct)
	return str
}

func (s Erasing) Count() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Erasing) HasCount() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Erasing) SetCount(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCount sets the count field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Erasing) NewCount() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Erasing) From() (ListSource, error) {
	p, err := s.Struct.Ptr(1)
	return ListSource{Struct: p.Struct()}, err
}

func (s Erasing) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Erasing) SetFrom(v ListSource) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated ListSource struct, preferring placement in s's segment.
func (s Erasing) NewFrom() (ListSource, error) {
	ss, err := NewListSource(s.Struct.Segment())
	if err != nil {
		return ListSource{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Erasing) AtIndex() (NumberEval, error) {
	p, err := s.Struct.Ptr(2)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Erasing) HasAtIndex() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Erasing) SetAtIndex(v NumberEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewAtIndex sets the atIndex field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Erasing) NewAtIndex() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

func (s Erasing) As() (Text, error) {
	p, err := s.Struct.Ptr(3)
	return Text{Struct: p.Struct()}, err
}

func (s Erasing) HasAs() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Erasing) SetAs(v Text) error {
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewAs sets the as field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Erasing) NewAs() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

func (s Erasing) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(4)
	return Execute_List{List: p.List()}, err
}

func (s Erasing) HasExe() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Erasing) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(4, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Erasing) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(4, l.List.ToPtr())
	return l, err
}

// Erasing_List is a list of Erasing.
type Erasing_List struct{ capnp.List }

// NewErasing creates a new list of Erasing.
func NewErasing_List(s *capnp.Segment, sz int32) (Erasing_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return Erasing_List{l}, err
}

func (s Erasing_List) At(i int) Erasing { return Erasing{s.List.Struct(i)} }

func (s Erasing_List) Set(i int, v Erasing) error { return s.List.SetStruct(i, v.Struct) }

func (s Erasing_List) String() string {
	str, _ := text.MarshalList(0xd3cab235b0032c0c, s.List)
	return str
}

// Erasing_Promise is a wrapper for a Erasing promised by a client call.
type Erasing_Promise struct{ *capnp.Pipeline }

func (p Erasing_Promise) Struct() (Erasing, error) {
	s, err := p.Pipeline.Struct()
	return Erasing{s}, err
}

func (p Erasing_Promise) Count() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Erasing_Promise) From() ListSource_Promise {
	return ListSource_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Erasing_Promise) AtIndex() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

func (p Erasing_Promise) As() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

type ErasingEdge struct{ capnp.Struct }

// ErasingEdge_TypeID is the unique identifier for the type ErasingEdge.
const ErasingEdge_TypeID = 0xc86bf9018435c6ff

func NewErasingEdge(s *capnp.Segment) (ErasingEdge, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return ErasingEdge{st}, err
}

func NewRootErasingEdge(s *capnp.Segment) (ErasingEdge, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return ErasingEdge{st}, err
}

func ReadRootErasingEdge(msg *capnp.Message) (ErasingEdge, error) {
	root, err := msg.RootPtr()
	return ErasingEdge{root.Struct()}, err
}

func (s ErasingEdge) String() string {
	str, _ := text.Marshal(0xc86bf9018435c6ff, s.Struct)
	return str
}

func (s ErasingEdge) From() (ListSource, error) {
	p, err := s.Struct.Ptr(0)
	return ListSource{Struct: p.Struct()}, err
}

func (s ErasingEdge) HasFrom() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ErasingEdge) SetFrom(v ListSource) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated ListSource struct, preferring placement in s's segment.
func (s ErasingEdge) NewFrom() (ListSource, error) {
	ss, err := NewListSource(s.Struct.Segment())
	if err != nil {
		return ListSource{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ErasingEdge) AtEdge() (Bool, error) {
	p, err := s.Struct.Ptr(1)
	return Bool{Struct: p.Struct()}, err
}

func (s ErasingEdge) HasAtEdge() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ErasingEdge) SetAtEdge(v Bool) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAtEdge sets the atEdge field to a newly
// allocated Bool struct, preferring placement in s's segment.
func (s ErasingEdge) NewAtEdge() (Bool, error) {
	ss, err := NewBool(s.Struct.Segment())
	if err != nil {
		return Bool{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s ErasingEdge) As() (Text, error) {
	p, err := s.Struct.Ptr(2)
	return Text{Struct: p.Struct()}, err
}

func (s ErasingEdge) HasAs() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s ErasingEdge) SetAs(v Text) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewAs sets the as field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s ErasingEdge) NewAs() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

func (s ErasingEdge) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(3)
	return Execute_List{List: p.List()}, err
}

func (s ErasingEdge) HasExe() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s ErasingEdge) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(3, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s ErasingEdge) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(3, l.List.ToPtr())
	return l, err
}

func (s ErasingEdge) Else() (Brancher, error) {
	p, err := s.Struct.Ptr(4)
	return Brancher{Struct: p.Struct()}, err
}

func (s ErasingEdge) HasElse() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s ErasingEdge) SetElse(v Brancher) error {
	return s.Struct.SetPtr(4, v.Struct.ToPtr())
}

// NewElse sets the else field to a newly
// allocated Brancher struct, preferring placement in s's segment.
func (s ErasingEdge) NewElse() (Brancher, error) {
	ss, err := NewBrancher(s.Struct.Segment())
	if err != nil {
		return Brancher{}, err
	}
	err = s.Struct.SetPtr(4, ss.Struct.ToPtr())
	return ss, err
}

// ErasingEdge_List is a list of ErasingEdge.
type ErasingEdge_List struct{ capnp.List }

// NewErasingEdge creates a new list of ErasingEdge.
func NewErasingEdge_List(s *capnp.Segment, sz int32) (ErasingEdge_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return ErasingEdge_List{l}, err
}

func (s ErasingEdge_List) At(i int) ErasingEdge { return ErasingEdge{s.List.Struct(i)} }

func (s ErasingEdge_List) Set(i int, v ErasingEdge) error { return s.List.SetStruct(i, v.Struct) }

func (s ErasingEdge_List) String() string {
	str, _ := text.MarshalList(0xc86bf9018435c6ff, s.List)
	return str
}

// ErasingEdge_Promise is a wrapper for a ErasingEdge promised by a client call.
type ErasingEdge_Promise struct{ *capnp.Pipeline }

func (p ErasingEdge_Promise) Struct() (ErasingEdge, error) {
	s, err := p.Pipeline.Struct()
	return ErasingEdge{s}, err
}

func (p ErasingEdge_Promise) From() ListSource_Promise {
	return ListSource_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ErasingEdge_Promise) AtEdge() Bool_Promise {
	return Bool_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p ErasingEdge_Promise) As() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

func (p ErasingEdge_Promise) Else() Brancher_Promise {
	return Brancher_Promise{Pipeline: p.Pipeline.GetPipeline(4)}
}

type Find struct{ capnp.Struct }

// Find_TypeID is the unique identifier for the type Find.
const Find_TypeID = 0xc556aa603be2e808

func NewFind(s *capnp.Segment) (Find, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Find{st}, err
}

func NewRootFind(s *capnp.Segment) (Find, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Find{st}, err
}

func ReadRootFind(msg *capnp.Message) (Find, error) {
	root, err := msg.RootPtr()
	return Find{root.Struct()}, err
}

func (s Find) String() string {
	str, _ := text.Marshal(0xc556aa603be2e808, s.Struct)
	return str
}

func (s Find) Value() (Assignment, error) {
	p, err := s.Struct.Ptr(0)
	return Assignment{Struct: p.Struct()}, err
}

func (s Find) HasValue() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Find) SetValue(v Assignment) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewValue sets the value field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Find) NewValue() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Find) List() (Assignment, error) {
	p, err := s.Struct.Ptr(1)
	return Assignment{Struct: p.Struct()}, err
}

func (s Find) HasList() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Find) SetList(v Assignment) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewList sets the list field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Find) NewList() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Find_List is a list of Find.
type Find_List struct{ capnp.List }

// NewFind creates a new list of Find.
func NewFind_List(s *capnp.Segment, sz int32) (Find_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Find_List{l}, err
}

func (s Find_List) At(i int) Find { return Find{s.List.Struct(i)} }

func (s Find_List) Set(i int, v Find) error { return s.List.SetStruct(i, v.Struct) }

func (s Find_List) String() string {
	str, _ := text.MarshalList(0xc556aa603be2e808, s.List)
	return str
}

// Find_Promise is a wrapper for a Find promised by a client call.
type Find_Promise struct{ *capnp.Pipeline }

func (p Find_Promise) Struct() (Find, error) {
	s, err := p.Pipeline.Struct()
	return Find{s}, err
}

func (p Find_Promise) Value() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Find_Promise) List() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type FromBool struct{ capnp.Struct }

// FromBool_TypeID is the unique identifier for the type FromBool.
const FromBool_TypeID = 0xfa3fa772ea154c4f

func NewFromBool(s *capnp.Segment) (FromBool, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromBool{st}, err
}

func NewRootFromBool(s *capnp.Segment) (FromBool, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromBool{st}, err
}

func ReadRootFromBool(msg *capnp.Message) (FromBool, error) {
	root, err := msg.RootPtr()
	return FromBool{root.Struct()}, err
}

func (s FromBool) String() string {
	str, _ := text.Marshal(0xfa3fa772ea154c4f, s.Struct)
	return str
}

func (s FromBool) Val() (BoolEval, error) {
	p, err := s.Struct.Ptr(0)
	return BoolEval{Struct: p.Struct()}, err
}

func (s FromBool) HasVal() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromBool) SetVal(v BoolEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVal sets the val field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s FromBool) NewVal() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromBool_List is a list of FromBool.
type FromBool_List struct{ capnp.List }

// NewFromBool creates a new list of FromBool.
func NewFromBool_List(s *capnp.Segment, sz int32) (FromBool_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromBool_List{l}, err
}

func (s FromBool_List) At(i int) FromBool { return FromBool{s.List.Struct(i)} }

func (s FromBool_List) Set(i int, v FromBool) error { return s.List.SetStruct(i, v.Struct) }

func (s FromBool_List) String() string {
	str, _ := text.MarshalList(0xfa3fa772ea154c4f, s.List)
	return str
}

// FromBool_Promise is a wrapper for a FromBool promised by a client call.
type FromBool_Promise struct{ *capnp.Pipeline }

func (p FromBool_Promise) Struct() (FromBool, error) {
	s, err := p.Pipeline.Struct()
	return FromBool{s}, err
}

func (p FromBool_Promise) Val() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromNum struct{ capnp.Struct }

// FromNum_TypeID is the unique identifier for the type FromNum.
const FromNum_TypeID = 0x8051c827086156f0

func NewFromNum(s *capnp.Segment) (FromNum, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromNum{st}, err
}

func NewRootFromNum(s *capnp.Segment) (FromNum, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromNum{st}, err
}

func ReadRootFromNum(msg *capnp.Message) (FromNum, error) {
	root, err := msg.RootPtr()
	return FromNum{root.Struct()}, err
}

func (s FromNum) String() string {
	str, _ := text.Marshal(0x8051c827086156f0, s.Struct)
	return str
}

func (s FromNum) Val() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s FromNum) HasVal() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromNum) SetVal(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVal sets the val field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s FromNum) NewVal() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromNum_List is a list of FromNum.
type FromNum_List struct{ capnp.List }

// NewFromNum creates a new list of FromNum.
func NewFromNum_List(s *capnp.Segment, sz int32) (FromNum_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromNum_List{l}, err
}

func (s FromNum_List) At(i int) FromNum { return FromNum{s.List.Struct(i)} }

func (s FromNum_List) Set(i int, v FromNum) error { return s.List.SetStruct(i, v.Struct) }

func (s FromNum_List) String() string {
	str, _ := text.MarshalList(0x8051c827086156f0, s.List)
	return str
}

// FromNum_Promise is a wrapper for a FromNum promised by a client call.
type FromNum_Promise struct{ *capnp.Pipeline }

func (p FromNum_Promise) Struct() (FromNum, error) {
	s, err := p.Pipeline.Struct()
	return FromNum{s}, err
}

func (p FromNum_Promise) Val() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromNumList struct{ capnp.Struct }

// FromNumList_TypeID is the unique identifier for the type FromNumList.
const FromNumList_TypeID = 0xc74dad9d53f884e2

func NewFromNumList(s *capnp.Segment) (FromNumList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromNumList{st}, err
}

func NewRootFromNumList(s *capnp.Segment) (FromNumList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromNumList{st}, err
}

func ReadRootFromNumList(msg *capnp.Message) (FromNumList, error) {
	root, err := msg.RootPtr()
	return FromNumList{root.Struct()}, err
}

func (s FromNumList) String() string {
	str, _ := text.Marshal(0xc74dad9d53f884e2, s.Struct)
	return str
}

func (s FromNumList) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s FromNumList) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromNumList) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s FromNumList) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromNumList_List is a list of FromNumList.
type FromNumList_List struct{ capnp.List }

// NewFromNumList creates a new list of FromNumList.
func NewFromNumList_List(s *capnp.Segment, sz int32) (FromNumList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromNumList_List{l}, err
}

func (s FromNumList_List) At(i int) FromNumList { return FromNumList{s.List.Struct(i)} }

func (s FromNumList_List) Set(i int, v FromNumList) error { return s.List.SetStruct(i, v.Struct) }

func (s FromNumList_List) String() string {
	str, _ := text.MarshalList(0xc74dad9d53f884e2, s.List)
	return str
}

// FromNumList_Promise is a wrapper for a FromNumList promised by a client call.
type FromNumList_Promise struct{ *capnp.Pipeline }

func (p FromNumList_Promise) Struct() (FromNumList, error) {
	s, err := p.Pipeline.Struct()
	return FromNumList{s}, err
}

func (p FromNumList_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromNumbers struct{ capnp.Struct }

// FromNumbers_TypeID is the unique identifier for the type FromNumbers.
const FromNumbers_TypeID = 0xcd83fd0f17413705

func NewFromNumbers(s *capnp.Segment) (FromNumbers, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromNumbers{st}, err
}

func NewRootFromNumbers(s *capnp.Segment) (FromNumbers, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromNumbers{st}, err
}

func ReadRootFromNumbers(msg *capnp.Message) (FromNumbers, error) {
	root, err := msg.RootPtr()
	return FromNumbers{root.Struct()}, err
}

func (s FromNumbers) String() string {
	str, _ := text.Marshal(0xcd83fd0f17413705, s.Struct)
	return str
}

func (s FromNumbers) Vals() (NumListEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumListEval{Struct: p.Struct()}, err
}

func (s FromNumbers) HasVals() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromNumbers) SetVals(v NumListEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVals sets the vals field to a newly
// allocated NumListEval struct, preferring placement in s's segment.
func (s FromNumbers) NewVals() (NumListEval, error) {
	ss, err := NewNumListEval(s.Struct.Segment())
	if err != nil {
		return NumListEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromNumbers_List is a list of FromNumbers.
type FromNumbers_List struct{ capnp.List }

// NewFromNumbers creates a new list of FromNumbers.
func NewFromNumbers_List(s *capnp.Segment, sz int32) (FromNumbers_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromNumbers_List{l}, err
}

func (s FromNumbers_List) At(i int) FromNumbers { return FromNumbers{s.List.Struct(i)} }

func (s FromNumbers_List) Set(i int, v FromNumbers) error { return s.List.SetStruct(i, v.Struct) }

func (s FromNumbers_List) String() string {
	str, _ := text.MarshalList(0xcd83fd0f17413705, s.List)
	return str
}

// FromNumbers_Promise is a wrapper for a FromNumbers promised by a client call.
type FromNumbers_Promise struct{ *capnp.Pipeline }

func (p FromNumbers_Promise) Struct() (FromNumbers, error) {
	s, err := p.Pipeline.Struct()
	return FromNumbers{s}, err
}

func (p FromNumbers_Promise) Vals() NumListEval_Promise {
	return NumListEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromObj struct{ capnp.Struct }

// FromObj_TypeID is the unique identifier for the type FromObj.
const FromObj_TypeID = 0xaa2cae0708f464ef

func NewFromObj(s *capnp.Segment) (FromObj, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromObj{st}, err
}

func NewRootFromObj(s *capnp.Segment) (FromObj, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromObj{st}, err
}

func ReadRootFromObj(msg *capnp.Message) (FromObj, error) {
	root, err := msg.RootPtr()
	return FromObj{root.Struct()}, err
}

func (s FromObj) String() string {
	str, _ := text.Marshal(0xaa2cae0708f464ef, s.Struct)
	return str
}

func (s FromObj) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s FromObj) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromObj) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s FromObj) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromObj_List is a list of FromObj.
type FromObj_List struct{ capnp.List }

// NewFromObj creates a new list of FromObj.
func NewFromObj_List(s *capnp.Segment, sz int32) (FromObj_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromObj_List{l}, err
}

func (s FromObj_List) At(i int) FromObj { return FromObj{s.List.Struct(i)} }

func (s FromObj_List) Set(i int, v FromObj) error { return s.List.SetStruct(i, v.Struct) }

func (s FromObj_List) String() string {
	str, _ := text.MarshalList(0xaa2cae0708f464ef, s.List)
	return str
}

// FromObj_Promise is a wrapper for a FromObj promised by a client call.
type FromObj_Promise struct{ *capnp.Pipeline }

func (p FromObj_Promise) Struct() (FromObj, error) {
	s, err := p.Pipeline.Struct()
	return FromObj{s}, err
}

func (p FromObj_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromRec struct{ capnp.Struct }

// FromRec_TypeID is the unique identifier for the type FromRec.
const FromRec_TypeID = 0xbb89bbff01fc9f1c

func NewFromRec(s *capnp.Segment) (FromRec, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromRec{st}, err
}

func NewRootFromRec(s *capnp.Segment) (FromRec, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromRec{st}, err
}

func ReadRootFromRec(msg *capnp.Message) (FromRec, error) {
	root, err := msg.RootPtr()
	return FromRec{root.Struct()}, err
}

func (s FromRec) String() string {
	str, _ := text.Marshal(0xbb89bbff01fc9f1c, s.Struct)
	return str
}

func (s FromRec) Rec() (RecordEval, error) {
	p, err := s.Struct.Ptr(0)
	return RecordEval{Struct: p.Struct()}, err
}

func (s FromRec) HasRec() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromRec) SetRec(v RecordEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRec sets the rec field to a newly
// allocated RecordEval struct, preferring placement in s's segment.
func (s FromRec) NewRec() (RecordEval, error) {
	ss, err := NewRecordEval(s.Struct.Segment())
	if err != nil {
		return RecordEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromRec_List is a list of FromRec.
type FromRec_List struct{ capnp.List }

// NewFromRec creates a new list of FromRec.
func NewFromRec_List(s *capnp.Segment, sz int32) (FromRec_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromRec_List{l}, err
}

func (s FromRec_List) At(i int) FromRec { return FromRec{s.List.Struct(i)} }

func (s FromRec_List) Set(i int, v FromRec) error { return s.List.SetStruct(i, v.Struct) }

func (s FromRec_List) String() string {
	str, _ := text.MarshalList(0xbb89bbff01fc9f1c, s.List)
	return str
}

// FromRec_Promise is a wrapper for a FromRec promised by a client call.
type FromRec_Promise struct{ *capnp.Pipeline }

func (p FromRec_Promise) Struct() (FromRec, error) {
	s, err := p.Pipeline.Struct()
	return FromRec{s}, err
}

func (p FromRec_Promise) Rec() RecordEval_Promise {
	return RecordEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromRecList struct{ capnp.Struct }

// FromRecList_TypeID is the unique identifier for the type FromRecList.
const FromRecList_TypeID = 0xe9356f4c2e196332

func NewFromRecList(s *capnp.Segment) (FromRecList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromRecList{st}, err
}

func NewRootFromRecList(s *capnp.Segment) (FromRecList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromRecList{st}, err
}

func ReadRootFromRecList(msg *capnp.Message) (FromRecList, error) {
	root, err := msg.RootPtr()
	return FromRecList{root.Struct()}, err
}

func (s FromRecList) String() string {
	str, _ := text.Marshal(0xe9356f4c2e196332, s.Struct)
	return str
}

func (s FromRecList) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s FromRecList) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromRecList) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s FromRecList) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromRecList_List is a list of FromRecList.
type FromRecList_List struct{ capnp.List }

// NewFromRecList creates a new list of FromRecList.
func NewFromRecList_List(s *capnp.Segment, sz int32) (FromRecList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromRecList_List{l}, err
}

func (s FromRecList_List) At(i int) FromRecList { return FromRecList{s.List.Struct(i)} }

func (s FromRecList_List) Set(i int, v FromRecList) error { return s.List.SetStruct(i, v.Struct) }

func (s FromRecList_List) String() string {
	str, _ := text.MarshalList(0xe9356f4c2e196332, s.List)
	return str
}

// FromRecList_Promise is a wrapper for a FromRecList promised by a client call.
type FromRecList_Promise struct{ *capnp.Pipeline }

func (p FromRecList_Promise) Struct() (FromRecList, error) {
	s, err := p.Pipeline.Struct()
	return FromRecList{s}, err
}

func (p FromRecList_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromRecord struct{ capnp.Struct }

// FromRecord_TypeID is the unique identifier for the type FromRecord.
const FromRecord_TypeID = 0xb80b02b3b04983db

func NewFromRecord(s *capnp.Segment) (FromRecord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromRecord{st}, err
}

func NewRootFromRecord(s *capnp.Segment) (FromRecord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromRecord{st}, err
}

func ReadRootFromRecord(msg *capnp.Message) (FromRecord, error) {
	root, err := msg.RootPtr()
	return FromRecord{root.Struct()}, err
}

func (s FromRecord) String() string {
	str, _ := text.Marshal(0xb80b02b3b04983db, s.Struct)
	return str
}

func (s FromRecord) Val() (RecordEval, error) {
	p, err := s.Struct.Ptr(0)
	return RecordEval{Struct: p.Struct()}, err
}

func (s FromRecord) HasVal() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromRecord) SetVal(v RecordEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVal sets the val field to a newly
// allocated RecordEval struct, preferring placement in s's segment.
func (s FromRecord) NewVal() (RecordEval, error) {
	ss, err := NewRecordEval(s.Struct.Segment())
	if err != nil {
		return RecordEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromRecord_List is a list of FromRecord.
type FromRecord_List struct{ capnp.List }

// NewFromRecord creates a new list of FromRecord.
func NewFromRecord_List(s *capnp.Segment, sz int32) (FromRecord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromRecord_List{l}, err
}

func (s FromRecord_List) At(i int) FromRecord { return FromRecord{s.List.Struct(i)} }

func (s FromRecord_List) Set(i int, v FromRecord) error { return s.List.SetStruct(i, v.Struct) }

func (s FromRecord_List) String() string {
	str, _ := text.MarshalList(0xb80b02b3b04983db, s.List)
	return str
}

// FromRecord_Promise is a wrapper for a FromRecord promised by a client call.
type FromRecord_Promise struct{ *capnp.Pipeline }

func (p FromRecord_Promise) Struct() (FromRecord, error) {
	s, err := p.Pipeline.Struct()
	return FromRecord{s}, err
}

func (p FromRecord_Promise) Val() RecordEval_Promise {
	return RecordEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromRecords struct{ capnp.Struct }

// FromRecords_TypeID is the unique identifier for the type FromRecords.
const FromRecords_TypeID = 0xb3656d55761343fd

func NewFromRecords(s *capnp.Segment) (FromRecords, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromRecords{st}, err
}

func NewRootFromRecords(s *capnp.Segment) (FromRecords, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromRecords{st}, err
}

func ReadRootFromRecords(msg *capnp.Message) (FromRecords, error) {
	root, err := msg.RootPtr()
	return FromRecords{root.Struct()}, err
}

func (s FromRecords) String() string {
	str, _ := text.Marshal(0xb3656d55761343fd, s.Struct)
	return str
}

func (s FromRecords) Vals() (RecordListEval, error) {
	p, err := s.Struct.Ptr(0)
	return RecordListEval{Struct: p.Struct()}, err
}

func (s FromRecords) HasVals() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromRecords) SetVals(v RecordListEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVals sets the vals field to a newly
// allocated RecordListEval struct, preferring placement in s's segment.
func (s FromRecords) NewVals() (RecordListEval, error) {
	ss, err := NewRecordListEval(s.Struct.Segment())
	if err != nil {
		return RecordListEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromRecords_List is a list of FromRecords.
type FromRecords_List struct{ capnp.List }

// NewFromRecords creates a new list of FromRecords.
func NewFromRecords_List(s *capnp.Segment, sz int32) (FromRecords_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromRecords_List{l}, err
}

func (s FromRecords_List) At(i int) FromRecords { return FromRecords{s.List.Struct(i)} }

func (s FromRecords_List) Set(i int, v FromRecords) error { return s.List.SetStruct(i, v.Struct) }

func (s FromRecords_List) String() string {
	str, _ := text.MarshalList(0xb3656d55761343fd, s.List)
	return str
}

// FromRecords_Promise is a wrapper for a FromRecords promised by a client call.
type FromRecords_Promise struct{ *capnp.Pipeline }

func (p FromRecords_Promise) Struct() (FromRecords, error) {
	s, err := p.Pipeline.Struct()
	return FromRecords{s}, err
}

func (p FromRecords_Promise) Vals() RecordListEval_Promise {
	return RecordListEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromText struct{ capnp.Struct }

// FromText_TypeID is the unique identifier for the type FromText.
const FromText_TypeID = 0xd76e3dd0e1d74770

func NewFromText(s *capnp.Segment) (FromText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromText{st}, err
}

func NewRootFromText(s *capnp.Segment) (FromText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromText{st}, err
}

func ReadRootFromText(msg *capnp.Message) (FromText, error) {
	root, err := msg.RootPtr()
	return FromText{root.Struct()}, err
}

func (s FromText) String() string {
	str, _ := text.Marshal(0xd76e3dd0e1d74770, s.Struct)
	return str
}

func (s FromText) Val() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s FromText) HasVal() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromText) SetVal(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVal sets the val field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s FromText) NewVal() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromText_List is a list of FromText.
type FromText_List struct{ capnp.List }

// NewFromText creates a new list of FromText.
func NewFromText_List(s *capnp.Segment, sz int32) (FromText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromText_List{l}, err
}

func (s FromText_List) At(i int) FromText { return FromText{s.List.Struct(i)} }

func (s FromText_List) Set(i int, v FromText) error { return s.List.SetStruct(i, v.Struct) }

func (s FromText_List) String() string {
	str, _ := text.MarshalList(0xd76e3dd0e1d74770, s.List)
	return str
}

// FromText_Promise is a wrapper for a FromText promised by a client call.
type FromText_Promise struct{ *capnp.Pipeline }

func (p FromText_Promise) Struct() (FromText, error) {
	s, err := p.Pipeline.Struct()
	return FromText{s}, err
}

func (p FromText_Promise) Val() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromTexts struct{ capnp.Struct }

// FromTexts_TypeID is the unique identifier for the type FromTexts.
const FromTexts_TypeID = 0xa16dc25e470c65a4

func NewFromTexts(s *capnp.Segment) (FromTexts, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromTexts{st}, err
}

func NewRootFromTexts(s *capnp.Segment) (FromTexts, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromTexts{st}, err
}

func ReadRootFromTexts(msg *capnp.Message) (FromTexts, error) {
	root, err := msg.RootPtr()
	return FromTexts{root.Struct()}, err
}

func (s FromTexts) String() string {
	str, _ := text.Marshal(0xa16dc25e470c65a4, s.Struct)
	return str
}

func (s FromTexts) Vals() (TextListEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextListEval{Struct: p.Struct()}, err
}

func (s FromTexts) HasVals() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromTexts) SetVals(v TextListEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVals sets the vals field to a newly
// allocated TextListEval struct, preferring placement in s's segment.
func (s FromTexts) NewVals() (TextListEval, error) {
	ss, err := NewTextListEval(s.Struct.Segment())
	if err != nil {
		return TextListEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromTexts_List is a list of FromTexts.
type FromTexts_List struct{ capnp.List }

// NewFromTexts creates a new list of FromTexts.
func NewFromTexts_List(s *capnp.Segment, sz int32) (FromTexts_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromTexts_List{l}, err
}

func (s FromTexts_List) At(i int) FromTexts { return FromTexts{s.List.Struct(i)} }

func (s FromTexts_List) Set(i int, v FromTexts) error { return s.List.SetStruct(i, v.Struct) }

func (s FromTexts_List) String() string {
	str, _ := text.MarshalList(0xa16dc25e470c65a4, s.List)
	return str
}

// FromTexts_Promise is a wrapper for a FromTexts promised by a client call.
type FromTexts_Promise struct{ *capnp.Pipeline }

func (p FromTexts_Promise) Struct() (FromTexts, error) {
	s, err := p.Pipeline.Struct()
	return FromTexts{s}, err
}

func (p FromTexts_Promise) Vals() TextListEval_Promise {
	return TextListEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromTxtList struct{ capnp.Struct }

// FromTxtList_TypeID is the unique identifier for the type FromTxtList.
const FromTxtList_TypeID = 0xddda77c6289520dc

func NewFromTxtList(s *capnp.Segment) (FromTxtList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromTxtList{st}, err
}

func NewRootFromTxtList(s *capnp.Segment) (FromTxtList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromTxtList{st}, err
}

func ReadRootFromTxtList(msg *capnp.Message) (FromTxtList, error) {
	root, err := msg.RootPtr()
	return FromTxtList{root.Struct()}, err
}

func (s FromTxtList) String() string {
	str, _ := text.Marshal(0xddda77c6289520dc, s.Struct)
	return str
}

func (s FromTxtList) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s FromTxtList) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromTxtList) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s FromTxtList) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromTxtList_List is a list of FromTxtList.
type FromTxtList_List struct{ capnp.List }

// NewFromTxtList creates a new list of FromTxtList.
func NewFromTxtList_List(s *capnp.Segment, sz int32) (FromTxtList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromTxtList_List{l}, err
}

func (s FromTxtList_List) At(i int) FromTxtList { return FromTxtList{s.List.Struct(i)} }

func (s FromTxtList_List) Set(i int, v FromTxtList) error { return s.List.SetStruct(i, v.Struct) }

func (s FromTxtList_List) String() string {
	str, _ := text.MarshalList(0xddda77c6289520dc, s.List)
	return str
}

// FromTxtList_Promise is a wrapper for a FromTxtList promised by a client call.
type FromTxtList_Promise struct{ *capnp.Pipeline }

func (p FromTxtList_Promise) Struct() (FromTxtList, error) {
	s, err := p.Pipeline.Struct()
	return FromTxtList{s}, err
}

func (p FromTxtList_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type FromVar struct{ capnp.Struct }

// FromVar_TypeID is the unique identifier for the type FromVar.
const FromVar_TypeID = 0x9dea788f64c0b8ed

func NewFromVar(s *capnp.Segment) (FromVar, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromVar{st}, err
}

func NewRootFromVar(s *capnp.Segment) (FromVar, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FromVar{st}, err
}

func ReadRootFromVar(msg *capnp.Message) (FromVar, error) {
	root, err := msg.RootPtr()
	return FromVar{root.Struct()}, err
}

func (s FromVar) String() string {
	str, _ := text.Marshal(0x9dea788f64c0b8ed, s.Struct)
	return str
}

func (s FromVar) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s FromVar) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FromVar) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s FromVar) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// FromVar_List is a list of FromVar.
type FromVar_List struct{ capnp.List }

// NewFromVar creates a new list of FromVar.
func NewFromVar_List(s *capnp.Segment, sz int32) (FromVar_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FromVar_List{l}, err
}

func (s FromVar_List) At(i int) FromVar { return FromVar{s.List.Struct(i)} }

func (s FromVar_List) Set(i int, v FromVar) error { return s.List.SetStruct(i, v.Struct) }

func (s FromVar_List) String() string {
	str, _ := text.MarshalList(0x9dea788f64c0b8ed, s.List)
	return str
}

// FromVar_Promise is a wrapper for a FromVar promised by a client call.
type FromVar_Promise struct{ *capnp.Pipeline }

func (p FromVar_Promise) Struct() (FromVar, error) {
	s, err := p.Pipeline.Struct()
	return FromVar{s}, err
}

func (p FromVar_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Gather struct{ capnp.Struct }

// Gather_TypeID is the unique identifier for the type Gather.
const Gather_TypeID = 0xf8963ca96520c5f4

func NewGather(s *capnp.Segment) (Gather, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Gather{st}, err
}

func NewRootGather(s *capnp.Segment) (Gather, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Gather{st}, err
}

func ReadRootGather(msg *capnp.Message) (Gather, error) {
	root, err := msg.RootPtr()
	return Gather{root.Struct()}, err
}

func (s Gather) String() string {
	str, _ := text.Marshal(0xf8963ca96520c5f4, s.Struct)
	return str
}

func (s Gather) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Gather) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Gather) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Gather) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Gather) From() (ListSource, error) {
	p, err := s.Struct.Ptr(1)
	return ListSource{Struct: p.Struct()}, err
}

func (s Gather) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Gather) SetFrom(v ListSource) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated ListSource struct, preferring placement in s's segment.
func (s Gather) NewFrom() (ListSource, error) {
	ss, err := NewListSource(s.Struct.Segment())
	if err != nil {
		return ListSource{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Gather) Using() (Text, error) {
	p, err := s.Struct.Ptr(2)
	return Text{Struct: p.Struct()}, err
}

func (s Gather) HasUsing() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Gather) SetUsing(v Text) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewUsing sets the using field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Gather) NewUsing() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// Gather_List is a list of Gather.
type Gather_List struct{ capnp.List }

// NewGather creates a new list of Gather.
func NewGather_List(s *capnp.Segment, sz int32) (Gather_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return Gather_List{l}, err
}

func (s Gather_List) At(i int) Gather { return Gather{s.List.Struct(i)} }

func (s Gather_List) Set(i int, v Gather) error { return s.List.SetStruct(i, v.Struct) }

func (s Gather_List) String() string {
	str, _ := text.MarshalList(0xf8963ca96520c5f4, s.List)
	return str
}

// Gather_Promise is a wrapper for a Gather promised by a client call.
type Gather_Promise struct{ *capnp.Pipeline }

func (p Gather_Promise) Struct() (Gather, error) {
	s, err := p.Pipeline.Struct()
	return Gather{s}, err
}

func (p Gather_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Gather_Promise) From() ListSource_Promise {
	return ListSource_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Gather_Promise) Using() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type GetAtField struct{ capnp.Struct }

// GetAtField_TypeID is the unique identifier for the type GetAtField.
const GetAtField_TypeID = 0x9db5944c71636a0b

func NewGetAtField(s *capnp.Segment) (GetAtField, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return GetAtField{st}, err
}

func NewRootGetAtField(s *capnp.Segment) (GetAtField, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return GetAtField{st}, err
}

func ReadRootGetAtField(msg *capnp.Message) (GetAtField, error) {
	root, err := msg.RootPtr()
	return GetAtField{root.Struct()}, err
}

func (s GetAtField) String() string {
	str, _ := text.Marshal(0x9db5944c71636a0b, s.Struct)
	return str
}

func (s GetAtField) Field() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s GetAtField) HasField() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s GetAtField) SetField(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewField sets the field field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s GetAtField) NewField() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s GetAtField) From() (FromSourceFields, error) {
	p, err := s.Struct.Ptr(1)
	return FromSourceFields{Struct: p.Struct()}, err
}

func (s GetAtField) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s GetAtField) SetFrom(v FromSourceFields) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated FromSourceFields struct, preferring placement in s's segment.
func (s GetAtField) NewFrom() (FromSourceFields, error) {
	ss, err := NewFromSourceFields(s.Struct.Segment())
	if err != nil {
		return FromSourceFields{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// GetAtField_List is a list of GetAtField.
type GetAtField_List struct{ capnp.List }

// NewGetAtField creates a new list of GetAtField.
func NewGetAtField_List(s *capnp.Segment, sz int32) (GetAtField_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return GetAtField_List{l}, err
}

func (s GetAtField_List) At(i int) GetAtField { return GetAtField{s.List.Struct(i)} }

func (s GetAtField_List) Set(i int, v GetAtField) error { return s.List.SetStruct(i, v.Struct) }

func (s GetAtField_List) String() string {
	str, _ := text.MarshalList(0x9db5944c71636a0b, s.List)
	return str
}

// GetAtField_Promise is a wrapper for a GetAtField promised by a client call.
type GetAtField_Promise struct{ *capnp.Pipeline }

func (p GetAtField_Promise) Struct() (GetAtField, error) {
	s, err := p.Pipeline.Struct()
	return GetAtField{s}, err
}

func (p GetAtField_Promise) Field() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p GetAtField_Promise) From() FromSourceFields_Promise {
	return FromSourceFields_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type GrammarDecl struct{ capnp.Struct }

// GrammarDecl_TypeID is the unique identifier for the type GrammarDecl.
const GrammarDecl_TypeID = 0xd1846848c3d37d77

func NewGrammarDecl(s *capnp.Segment) (GrammarDecl, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return GrammarDecl{st}, err
}

func NewRootGrammarDecl(s *capnp.Segment) (GrammarDecl, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return GrammarDecl{st}, err
}

func ReadRootGrammarDecl(msg *capnp.Message) (GrammarDecl, error) {
	root, err := msg.RootPtr()
	return GrammarDecl{root.Struct()}, err
}

func (s GrammarDecl) String() string {
	str, _ := text.Marshal(0xd1846848c3d37d77, s.Struct)
	return str
}

func (s GrammarDecl) Grammar() (GrammarMaker, error) {
	p, err := s.Struct.Ptr(0)
	return GrammarMaker{Struct: p.Struct()}, err
}

func (s GrammarDecl) HasGrammar() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s GrammarDecl) SetGrammar(v GrammarMaker) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewGrammar sets the grammar field to a newly
// allocated GrammarMaker struct, preferring placement in s's segment.
func (s GrammarDecl) NewGrammar() (GrammarMaker, error) {
	ss, err := NewGrammarMaker(s.Struct.Segment())
	if err != nil {
		return GrammarMaker{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// GrammarDecl_List is a list of GrammarDecl.
type GrammarDecl_List struct{ capnp.List }

// NewGrammarDecl creates a new list of GrammarDecl.
func NewGrammarDecl_List(s *capnp.Segment, sz int32) (GrammarDecl_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return GrammarDecl_List{l}, err
}

func (s GrammarDecl_List) At(i int) GrammarDecl { return GrammarDecl{s.List.Struct(i)} }

func (s GrammarDecl_List) Set(i int, v GrammarDecl) error { return s.List.SetStruct(i, v.Struct) }

func (s GrammarDecl_List) String() string {
	str, _ := text.MarshalList(0xd1846848c3d37d77, s.List)
	return str
}

// GrammarDecl_Promise is a wrapper for a GrammarDecl promised by a client call.
type GrammarDecl_Promise struct{ *capnp.Pipeline }

func (p GrammarDecl_Promise) Struct() (GrammarDecl, error) {
	s, err := p.Pipeline.Struct()
	return GrammarDecl{s}, err
}

func (p GrammarDecl_Promise) Grammar() GrammarMaker_Promise {
	return GrammarMaker_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type GreaterOrEqual struct{ capnp.Struct }

// GreaterOrEqual_TypeID is the unique identifier for the type GreaterOrEqual.
const GreaterOrEqual_TypeID = 0xdf2e939571efc218

func NewGreaterOrEqual(s *capnp.Segment) (GreaterOrEqual, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return GreaterOrEqual{st}, err
}

func NewRootGreaterOrEqual(s *capnp.Segment) (GreaterOrEqual, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return GreaterOrEqual{st}, err
}

func ReadRootGreaterOrEqual(msg *capnp.Message) (GreaterOrEqual, error) {
	root, err := msg.RootPtr()
	return GreaterOrEqual{root.Struct()}, err
}

func (s GreaterOrEqual) String() string {
	str, _ := text.Marshal(0xdf2e939571efc218, s.Struct)
	return str
}

// GreaterOrEqual_List is a list of GreaterOrEqual.
type GreaterOrEqual_List struct{ capnp.List }

// NewGreaterOrEqual creates a new list of GreaterOrEqual.
func NewGreaterOrEqual_List(s *capnp.Segment, sz int32) (GreaterOrEqual_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return GreaterOrEqual_List{l}, err
}

func (s GreaterOrEqual_List) At(i int) GreaterOrEqual { return GreaterOrEqual{s.List.Struct(i)} }

func (s GreaterOrEqual_List) Set(i int, v GreaterOrEqual) error { return s.List.SetStruct(i, v.Struct) }

func (s GreaterOrEqual_List) String() string {
	str, _ := text.MarshalList(0xdf2e939571efc218, s.List)
	return str
}

// GreaterOrEqual_Promise is a wrapper for a GreaterOrEqual promised by a client call.
type GreaterOrEqual_Promise struct{ *capnp.Pipeline }

func (p GreaterOrEqual_Promise) Struct() (GreaterOrEqual, error) {
	s, err := p.Pipeline.Struct()
	return GreaterOrEqual{s}, err
}

type GreaterThan struct{ capnp.Struct }

// GreaterThan_TypeID is the unique identifier for the type GreaterThan.
const GreaterThan_TypeID = 0x8eca93874dc59221

func NewGreaterThan(s *capnp.Segment) (GreaterThan, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return GreaterThan{st}, err
}

func NewRootGreaterThan(s *capnp.Segment) (GreaterThan, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return GreaterThan{st}, err
}

func ReadRootGreaterThan(msg *capnp.Message) (GreaterThan, error) {
	root, err := msg.RootPtr()
	return GreaterThan{root.Struct()}, err
}

func (s GreaterThan) String() string {
	str, _ := text.Marshal(0x8eca93874dc59221, s.Struct)
	return str
}

// GreaterThan_List is a list of GreaterThan.
type GreaterThan_List struct{ capnp.List }

// NewGreaterThan creates a new list of GreaterThan.
func NewGreaterThan_List(s *capnp.Segment, sz int32) (GreaterThan_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return GreaterThan_List{l}, err
}

func (s GreaterThan_List) At(i int) GreaterThan { return GreaterThan{s.List.Struct(i)} }

func (s GreaterThan_List) Set(i int, v GreaterThan) error { return s.List.SetStruct(i, v.Struct) }

func (s GreaterThan_List) String() string {
	str, _ := text.MarshalList(0x8eca93874dc59221, s.List)
	return str
}

// GreaterThan_Promise is a wrapper for a GreaterThan promised by a client call.
type GreaterThan_Promise struct{ *capnp.Pipeline }

func (p GreaterThan_Promise) Struct() (GreaterThan, error) {
	s, err := p.Pipeline.Struct()
	return GreaterThan{s}, err
}

type HasDominion struct{ capnp.Struct }

// HasDominion_TypeID is the unique identifier for the type HasDominion.
const HasDominion_TypeID = 0xa240c704e3251c11

func NewHasDominion(s *capnp.Segment) (HasDominion, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HasDominion{st}, err
}

func NewRootHasDominion(s *capnp.Segment) (HasDominion, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HasDominion{st}, err
}

func ReadRootHasDominion(msg *capnp.Message) (HasDominion, error) {
	root, err := msg.RootPtr()
	return HasDominion{root.Struct()}, err
}

func (s HasDominion) String() string {
	str, _ := text.Marshal(0xa240c704e3251c11, s.Struct)
	return str
}

func (s HasDominion) Name() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s HasDominion) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s HasDominion) SetName(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s HasDominion) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// HasDominion_List is a list of HasDominion.
type HasDominion_List struct{ capnp.List }

// NewHasDominion creates a new list of HasDominion.
func NewHasDominion_List(s *capnp.Segment, sz int32) (HasDominion_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return HasDominion_List{l}, err
}

func (s HasDominion_List) At(i int) HasDominion { return HasDominion{s.List.Struct(i)} }

func (s HasDominion_List) Set(i int, v HasDominion) error { return s.List.SetStruct(i, v.Struct) }

func (s HasDominion_List) String() string {
	str, _ := text.MarshalList(0xa240c704e3251c11, s.List)
	return str
}

// HasDominion_Promise is a wrapper for a HasDominion promised by a client call.
type HasDominion_Promise struct{ *capnp.Pipeline }

func (p HasDominion_Promise) Struct() (HasDominion, error) {
	s, err := p.Pipeline.Struct()
	return HasDominion{s}, err
}

func (p HasDominion_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type HasTrait struct{ capnp.Struct }

// HasTrait_TypeID is the unique identifier for the type HasTrait.
const HasTrait_TypeID = 0xce8e609a9d423772

func NewHasTrait(s *capnp.Segment) (HasTrait, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return HasTrait{st}, err
}

func NewRootHasTrait(s *capnp.Segment) (HasTrait, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return HasTrait{st}, err
}

func ReadRootHasTrait(msg *capnp.Message) (HasTrait, error) {
	root, err := msg.RootPtr()
	return HasTrait{root.Struct()}, err
}

func (s HasTrait) String() string {
	str, _ := text.Marshal(0xce8e609a9d423772, s.Struct)
	return str
}

func (s HasTrait) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s HasTrait) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s HasTrait) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s HasTrait) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s HasTrait) Trait() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s HasTrait) HasTrait() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s HasTrait) SetTrait(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewTrait sets the trait field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s HasTrait) NewTrait() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// HasTrait_List is a list of HasTrait.
type HasTrait_List struct{ capnp.List }

// NewHasTrait creates a new list of HasTrait.
func NewHasTrait_List(s *capnp.Segment, sz int32) (HasTrait_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return HasTrait_List{l}, err
}

func (s HasTrait_List) At(i int) HasTrait { return HasTrait{s.List.Struct(i)} }

func (s HasTrait_List) Set(i int, v HasTrait) error { return s.List.SetStruct(i, v.Struct) }

func (s HasTrait_List) String() string {
	str, _ := text.MarshalList(0xce8e609a9d423772, s.List)
	return str
}

// HasTrait_Promise is a wrapper for a HasTrait promised by a client call.
type HasTrait_Promise struct{ *capnp.Pipeline }

func (p HasTrait_Promise) Struct() (HasTrait, error) {
	s, err := p.Pipeline.Struct()
	return HasTrait{s}, err
}

func (p HasTrait_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p HasTrait_Promise) Trait() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type IdOf struct{ capnp.Struct }

// IdOf_TypeID is the unique identifier for the type IdOf.
const IdOf_TypeID = 0xbd2f7c51fe6be2d6

func NewIdOf(s *capnp.Segment) (IdOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IdOf{st}, err
}

func NewRootIdOf(s *capnp.Segment) (IdOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IdOf{st}, err
}

func ReadRootIdOf(msg *capnp.Message) (IdOf, error) {
	root, err := msg.RootPtr()
	return IdOf{root.Struct()}, err
}

func (s IdOf) String() string {
	str, _ := text.Marshal(0xbd2f7c51fe6be2d6, s.Struct)
	return str
}

func (s IdOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s IdOf) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IdOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s IdOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IdOf_List is a list of IdOf.
type IdOf_List struct{ capnp.List }

// NewIdOf creates a new list of IdOf.
func NewIdOf_List(s *capnp.Segment, sz int32) (IdOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IdOf_List{l}, err
}

func (s IdOf_List) At(i int) IdOf { return IdOf{s.List.Struct(i)} }

func (s IdOf_List) Set(i int, v IdOf) error { return s.List.SetStruct(i, v.Struct) }

func (s IdOf_List) String() string {
	str, _ := text.MarshalList(0xbd2f7c51fe6be2d6, s.List)
	return str
}

// IdOf_Promise is a wrapper for a IdOf promised by a client call.
type IdOf_Promise struct{ *capnp.Pipeline }

func (p IdOf_Promise) Struct() (IdOf, error) {
	s, err := p.Pipeline.Struct()
	return IdOf{s}, err
}

func (p IdOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Includes struct{ capnp.Struct }

// Includes_TypeID is the unique identifier for the type Includes.
const Includes_TypeID = 0x8695311806f91e69

func NewIncludes(s *capnp.Segment) (Includes, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Includes{st}, err
}

func NewRootIncludes(s *capnp.Segment) (Includes, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Includes{st}, err
}

func ReadRootIncludes(msg *capnp.Message) (Includes, error) {
	root, err := msg.RootPtr()
	return Includes{root.Struct()}, err
}

func (s Includes) String() string {
	str, _ := text.Marshal(0x8695311806f91e69, s.Struct)
	return str
}

func (s Includes) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s Includes) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Includes) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Includes) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Includes) Part() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s Includes) HasPart() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Includes) SetPart(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewPart sets the part field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Includes) NewPart() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Includes_List is a list of Includes.
type Includes_List struct{ capnp.List }

// NewIncludes creates a new list of Includes.
func NewIncludes_List(s *capnp.Segment, sz int32) (Includes_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Includes_List{l}, err
}

func (s Includes_List) At(i int) Includes { return Includes{s.List.Struct(i)} }

func (s Includes_List) Set(i int, v Includes) error { return s.List.SetStruct(i, v.Struct) }

func (s Includes_List) String() string {
	str, _ := text.MarshalList(0x8695311806f91e69, s.List)
	return str
}

// Includes_Promise is a wrapper for a Includes promised by a client call.
type Includes_Promise struct{ *capnp.Pipeline }

func (p Includes_Promise) Struct() (Includes, error) {
	s, err := p.Pipeline.Struct()
	return Includes{s}, err
}

func (p Includes_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Includes_Promise) Part() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type IntoNumList struct{ capnp.Struct }

// IntoNumList_TypeID is the unique identifier for the type IntoNumList.
const IntoNumList_TypeID = 0xb7b9a0342f9379c3

func NewIntoNumList(s *capnp.Segment) (IntoNumList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoNumList{st}, err
}

func NewRootIntoNumList(s *capnp.Segment) (IntoNumList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoNumList{st}, err
}

func ReadRootIntoNumList(msg *capnp.Message) (IntoNumList, error) {
	root, err := msg.RootPtr()
	return IntoNumList{root.Struct()}, err
}

func (s IntoNumList) String() string {
	str, _ := text.Marshal(0xb7b9a0342f9379c3, s.Struct)
	return str
}

func (s IntoNumList) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s IntoNumList) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoNumList) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s IntoNumList) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IntoNumList_List is a list of IntoNumList.
type IntoNumList_List struct{ capnp.List }

// NewIntoNumList creates a new list of IntoNumList.
func NewIntoNumList_List(s *capnp.Segment, sz int32) (IntoNumList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IntoNumList_List{l}, err
}

func (s IntoNumList_List) At(i int) IntoNumList { return IntoNumList{s.List.Struct(i)} }

func (s IntoNumList_List) Set(i int, v IntoNumList) error { return s.List.SetStruct(i, v.Struct) }

func (s IntoNumList_List) String() string {
	str, _ := text.MarshalList(0xb7b9a0342f9379c3, s.List)
	return str
}

// IntoNumList_Promise is a wrapper for a IntoNumList promised by a client call.
type IntoNumList_Promise struct{ *capnp.Pipeline }

func (p IntoNumList_Promise) Struct() (IntoNumList, error) {
	s, err := p.Pipeline.Struct()
	return IntoNumList{s}, err
}

func (p IntoNumList_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type IntoObj struct{ capnp.Struct }

// IntoObj_TypeID is the unique identifier for the type IntoObj.
const IntoObj_TypeID = 0xa105248f353fe0f4

func NewIntoObj(s *capnp.Segment) (IntoObj, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoObj{st}, err
}

func NewRootIntoObj(s *capnp.Segment) (IntoObj, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoObj{st}, err
}

func ReadRootIntoObj(msg *capnp.Message) (IntoObj, error) {
	root, err := msg.RootPtr()
	return IntoObj{root.Struct()}, err
}

func (s IntoObj) String() string {
	str, _ := text.Marshal(0xa105248f353fe0f4, s.Struct)
	return str
}

func (s IntoObj) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s IntoObj) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoObj) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s IntoObj) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IntoObj_List is a list of IntoObj.
type IntoObj_List struct{ capnp.List }

// NewIntoObj creates a new list of IntoObj.
func NewIntoObj_List(s *capnp.Segment, sz int32) (IntoObj_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IntoObj_List{l}, err
}

func (s IntoObj_List) At(i int) IntoObj { return IntoObj{s.List.Struct(i)} }

func (s IntoObj_List) Set(i int, v IntoObj) error { return s.List.SetStruct(i, v.Struct) }

func (s IntoObj_List) String() string {
	str, _ := text.MarshalList(0xa105248f353fe0f4, s.List)
	return str
}

// IntoObj_Promise is a wrapper for a IntoObj promised by a client call.
type IntoObj_Promise struct{ *capnp.Pipeline }

func (p IntoObj_Promise) Struct() (IntoObj, error) {
	s, err := p.Pipeline.Struct()
	return IntoObj{s}, err
}

func (p IntoObj_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type IntoRecList struct{ capnp.Struct }

// IntoRecList_TypeID is the unique identifier for the type IntoRecList.
const IntoRecList_TypeID = 0xe3a2743c8dfb4ad7

func NewIntoRecList(s *capnp.Segment) (IntoRecList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoRecList{st}, err
}

func NewRootIntoRecList(s *capnp.Segment) (IntoRecList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoRecList{st}, err
}

func ReadRootIntoRecList(msg *capnp.Message) (IntoRecList, error) {
	root, err := msg.RootPtr()
	return IntoRecList{root.Struct()}, err
}

func (s IntoRecList) String() string {
	str, _ := text.Marshal(0xe3a2743c8dfb4ad7, s.Struct)
	return str
}

func (s IntoRecList) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s IntoRecList) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoRecList) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s IntoRecList) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IntoRecList_List is a list of IntoRecList.
type IntoRecList_List struct{ capnp.List }

// NewIntoRecList creates a new list of IntoRecList.
func NewIntoRecList_List(s *capnp.Segment, sz int32) (IntoRecList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IntoRecList_List{l}, err
}

func (s IntoRecList_List) At(i int) IntoRecList { return IntoRecList{s.List.Struct(i)} }

func (s IntoRecList_List) Set(i int, v IntoRecList) error { return s.List.SetStruct(i, v.Struct) }

func (s IntoRecList_List) String() string {
	str, _ := text.MarshalList(0xe3a2743c8dfb4ad7, s.List)
	return str
}

// IntoRecList_Promise is a wrapper for a IntoRecList promised by a client call.
type IntoRecList_Promise struct{ *capnp.Pipeline }

func (p IntoRecList_Promise) Struct() (IntoRecList, error) {
	s, err := p.Pipeline.Struct()
	return IntoRecList{s}, err
}

func (p IntoRecList_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type IntoTxtList struct{ capnp.Struct }

// IntoTxtList_TypeID is the unique identifier for the type IntoTxtList.
const IntoTxtList_TypeID = 0xac0239123e762137

func NewIntoTxtList(s *capnp.Segment) (IntoTxtList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoTxtList{st}, err
}

func NewRootIntoTxtList(s *capnp.Segment) (IntoTxtList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoTxtList{st}, err
}

func ReadRootIntoTxtList(msg *capnp.Message) (IntoTxtList, error) {
	root, err := msg.RootPtr()
	return IntoTxtList{root.Struct()}, err
}

func (s IntoTxtList) String() string {
	str, _ := text.Marshal(0xac0239123e762137, s.Struct)
	return str
}

func (s IntoTxtList) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s IntoTxtList) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoTxtList) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s IntoTxtList) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IntoTxtList_List is a list of IntoTxtList.
type IntoTxtList_List struct{ capnp.List }

// NewIntoTxtList creates a new list of IntoTxtList.
func NewIntoTxtList_List(s *capnp.Segment, sz int32) (IntoTxtList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IntoTxtList_List{l}, err
}

func (s IntoTxtList_List) At(i int) IntoTxtList { return IntoTxtList{s.List.Struct(i)} }

func (s IntoTxtList_List) Set(i int, v IntoTxtList) error { return s.List.SetStruct(i, v.Struct) }

func (s IntoTxtList_List) String() string {
	str, _ := text.MarshalList(0xac0239123e762137, s.List)
	return str
}

// IntoTxtList_Promise is a wrapper for a IntoTxtList promised by a client call.
type IntoTxtList_Promise struct{ *capnp.Pipeline }

func (p IntoTxtList_Promise) Struct() (IntoTxtList, error) {
	s, err := p.Pipeline.Struct()
	return IntoTxtList{s}, err
}

func (p IntoTxtList_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type IntoVar struct{ capnp.Struct }

// IntoVar_TypeID is the unique identifier for the type IntoVar.
const IntoVar_TypeID = 0x8d17a2775ccd468a

func NewIntoVar(s *capnp.Segment) (IntoVar, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoVar{st}, err
}

func NewRootIntoVar(s *capnp.Segment) (IntoVar, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IntoVar{st}, err
}

func ReadRootIntoVar(msg *capnp.Message) (IntoVar, error) {
	root, err := msg.RootPtr()
	return IntoVar{root.Struct()}, err
}

func (s IntoVar) String() string {
	str, _ := text.Marshal(0x8d17a2775ccd468a, s.Struct)
	return str
}

func (s IntoVar) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s IntoVar) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IntoVar) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s IntoVar) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IntoVar_List is a list of IntoVar.
type IntoVar_List struct{ capnp.List }

// NewIntoVar creates a new list of IntoVar.
func NewIntoVar_List(s *capnp.Segment, sz int32) (IntoVar_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IntoVar_List{l}, err
}

func (s IntoVar_List) At(i int) IntoVar { return IntoVar{s.List.Struct(i)} }

func (s IntoVar_List) Set(i int, v IntoVar) error { return s.List.SetStruct(i, v.Struct) }

func (s IntoVar_List) String() string {
	str, _ := text.MarshalList(0x8d17a2775ccd468a, s.List)
	return str
}

// IntoVar_Promise is a wrapper for a IntoVar promised by a client call.
type IntoVar_Promise struct{ *capnp.Pipeline }

func (p IntoVar_Promise) Struct() (IntoVar, error) {
	s, err := p.Pipeline.Struct()
	return IntoVar{s}, err
}

func (p IntoVar_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type IsEmpty struct{ capnp.Struct }

// IsEmpty_TypeID is the unique identifier for the type IsEmpty.
const IsEmpty_TypeID = 0xd3b370f24d61e815

func NewIsEmpty(s *capnp.Segment) (IsEmpty, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IsEmpty{st}, err
}

func NewRootIsEmpty(s *capnp.Segment) (IsEmpty, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IsEmpty{st}, err
}

func ReadRootIsEmpty(msg *capnp.Message) (IsEmpty, error) {
	root, err := msg.RootPtr()
	return IsEmpty{root.Struct()}, err
}

func (s IsEmpty) String() string {
	str, _ := text.Marshal(0xd3b370f24d61e815, s.Struct)
	return str
}

func (s IsEmpty) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s IsEmpty) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IsEmpty) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s IsEmpty) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IsEmpty_List is a list of IsEmpty.
type IsEmpty_List struct{ capnp.List }

// NewIsEmpty creates a new list of IsEmpty.
func NewIsEmpty_List(s *capnp.Segment, sz int32) (IsEmpty_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IsEmpty_List{l}, err
}

func (s IsEmpty_List) At(i int) IsEmpty { return IsEmpty{s.List.Struct(i)} }

func (s IsEmpty_List) Set(i int, v IsEmpty) error { return s.List.SetStruct(i, v.Struct) }

func (s IsEmpty_List) String() string {
	str, _ := text.MarshalList(0xd3b370f24d61e815, s.List)
	return str
}

// IsEmpty_Promise is a wrapper for a IsEmpty promised by a client call.
type IsEmpty_Promise struct{ *capnp.Pipeline }

func (p IsEmpty_Promise) Struct() (IsEmpty, error) {
	s, err := p.Pipeline.Struct()
	return IsEmpty{s}, err
}

func (p IsEmpty_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type IsExactKindOf struct{ capnp.Struct }

// IsExactKindOf_TypeID is the unique identifier for the type IsExactKindOf.
const IsExactKindOf_TypeID = 0x8eecf20de39ce6fa

func NewIsExactKindOf(s *capnp.Segment) (IsExactKindOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IsExactKindOf{st}, err
}

func NewRootIsExactKindOf(s *capnp.Segment) (IsExactKindOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IsExactKindOf{st}, err
}

func ReadRootIsExactKindOf(msg *capnp.Message) (IsExactKindOf, error) {
	root, err := msg.RootPtr()
	return IsExactKindOf{root.Struct()}, err
}

func (s IsExactKindOf) String() string {
	str, _ := text.Marshal(0x8eecf20de39ce6fa, s.Struct)
	return str
}

func (s IsExactKindOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s IsExactKindOf) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IsExactKindOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s IsExactKindOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s IsExactKindOf) Kind() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s IsExactKindOf) HasKind() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s IsExactKindOf) SetKind(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewKind sets the kind field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s IsExactKindOf) NewKind() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// IsExactKindOf_List is a list of IsExactKindOf.
type IsExactKindOf_List struct{ capnp.List }

// NewIsExactKindOf creates a new list of IsExactKindOf.
func NewIsExactKindOf_List(s *capnp.Segment, sz int32) (IsExactKindOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return IsExactKindOf_List{l}, err
}

func (s IsExactKindOf_List) At(i int) IsExactKindOf { return IsExactKindOf{s.List.Struct(i)} }

func (s IsExactKindOf_List) Set(i int, v IsExactKindOf) error { return s.List.SetStruct(i, v.Struct) }

func (s IsExactKindOf_List) String() string {
	str, _ := text.MarshalList(0x8eecf20de39ce6fa, s.List)
	return str
}

// IsExactKindOf_Promise is a wrapper for a IsExactKindOf promised by a client call.
type IsExactKindOf_Promise struct{ *capnp.Pipeline }

func (p IsExactKindOf_Promise) Struct() (IsExactKindOf, error) {
	s, err := p.Pipeline.Struct()
	return IsExactKindOf{s}, err
}

func (p IsExactKindOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p IsExactKindOf_Promise) Kind() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type IsKindOf struct{ capnp.Struct }

// IsKindOf_TypeID is the unique identifier for the type IsKindOf.
const IsKindOf_TypeID = 0xd9f26bae90dbdd40

func NewIsKindOf(s *capnp.Segment) (IsKindOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IsKindOf{st}, err
}

func NewRootIsKindOf(s *capnp.Segment) (IsKindOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IsKindOf{st}, err
}

func ReadRootIsKindOf(msg *capnp.Message) (IsKindOf, error) {
	root, err := msg.RootPtr()
	return IsKindOf{root.Struct()}, err
}

func (s IsKindOf) String() string {
	str, _ := text.Marshal(0xd9f26bae90dbdd40, s.Struct)
	return str
}

func (s IsKindOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s IsKindOf) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IsKindOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s IsKindOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s IsKindOf) Kind() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s IsKindOf) HasKind() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s IsKindOf) SetKind(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewKind sets the kind field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s IsKindOf) NewKind() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// IsKindOf_List is a list of IsKindOf.
type IsKindOf_List struct{ capnp.List }

// NewIsKindOf creates a new list of IsKindOf.
func NewIsKindOf_List(s *capnp.Segment, sz int32) (IsKindOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return IsKindOf_List{l}, err
}

func (s IsKindOf_List) At(i int) IsKindOf { return IsKindOf{s.List.Struct(i)} }

func (s IsKindOf_List) Set(i int, v IsKindOf) error { return s.List.SetStruct(i, v.Struct) }

func (s IsKindOf_List) String() string {
	str, _ := text.MarshalList(0xd9f26bae90dbdd40, s.List)
	return str
}

// IsKindOf_Promise is a wrapper for a IsKindOf promised by a client call.
type IsKindOf_Promise struct{ *capnp.Pipeline }

func (p IsKindOf_Promise) Struct() (IsKindOf, error) {
	s, err := p.Pipeline.Struct()
	return IsKindOf{s}, err
}

func (p IsKindOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p IsKindOf_Promise) Kind() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type IsNotTrue struct{ capnp.Struct }

// IsNotTrue_TypeID is the unique identifier for the type IsNotTrue.
const IsNotTrue_TypeID = 0xe137ffd715e06e2f

func NewIsNotTrue(s *capnp.Segment) (IsNotTrue, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IsNotTrue{st}, err
}

func NewRootIsNotTrue(s *capnp.Segment) (IsNotTrue, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IsNotTrue{st}, err
}

func ReadRootIsNotTrue(msg *capnp.Message) (IsNotTrue, error) {
	root, err := msg.RootPtr()
	return IsNotTrue{root.Struct()}, err
}

func (s IsNotTrue) String() string {
	str, _ := text.Marshal(0xe137ffd715e06e2f, s.Struct)
	return str
}

func (s IsNotTrue) Test() (BoolEval, error) {
	p, err := s.Struct.Ptr(0)
	return BoolEval{Struct: p.Struct()}, err
}

func (s IsNotTrue) HasTest() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s IsNotTrue) SetTest(v BoolEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTest sets the test field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s IsNotTrue) NewTest() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// IsNotTrue_List is a list of IsNotTrue.
type IsNotTrue_List struct{ capnp.List }

// NewIsNotTrue creates a new list of IsNotTrue.
func NewIsNotTrue_List(s *capnp.Segment, sz int32) (IsNotTrue_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return IsNotTrue_List{l}, err
}

func (s IsNotTrue_List) At(i int) IsNotTrue { return IsNotTrue{s.List.Struct(i)} }

func (s IsNotTrue_List) Set(i int, v IsNotTrue) error { return s.List.SetStruct(i, v.Struct) }

func (s IsNotTrue_List) String() string {
	str, _ := text.MarshalList(0xe137ffd715e06e2f, s.List)
	return str
}

// IsNotTrue_Promise is a wrapper for a IsNotTrue promised by a client call.
type IsNotTrue_Promise struct{ *capnp.Pipeline }

func (p IsNotTrue_Promise) Struct() (IsNotTrue, error) {
	s, err := p.Pipeline.Struct()
	return IsNotTrue{s}, err
}

func (p IsNotTrue_Promise) Test() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Join struct{ capnp.Struct }

// Join_TypeID is the unique identifier for the type Join.
const Join_TypeID = 0xc3bce9818d0e60a9

func NewJoin(s *capnp.Segment) (Join, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Join{st}, err
}

func NewRootJoin(s *capnp.Segment) (Join, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Join{st}, err
}

func ReadRootJoin(msg *capnp.Message) (Join, error) {
	root, err := msg.RootPtr()
	return Join{root.Struct()}, err
}

func (s Join) String() string {
	str, _ := text.Marshal(0xc3bce9818d0e60a9, s.Struct)
	return str
}

func (s Join) Sep() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s Join) HasSep() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Join) SetSep(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSep sets the sep field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Join) NewSep() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Join) Parts() (TextEval_List, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval_List{List: p.List()}, err
}

func (s Join) HasParts() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Join) SetParts(v TextEval_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewParts sets the parts field to a newly
// allocated TextEval_List, preferring placement in s's segment.
func (s Join) NewParts(n int32) (TextEval_List, error) {
	l, err := NewTextEval_List(s.Struct.Segment(), n)
	if err != nil {
		return TextEval_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Join_List is a list of Join.
type Join_List struct{ capnp.List }

// NewJoin creates a new list of Join.
func NewJoin_List(s *capnp.Segment, sz int32) (Join_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Join_List{l}, err
}

func (s Join_List) At(i int) Join { return Join{s.List.Struct(i)} }

func (s Join_List) Set(i int, v Join) error { return s.List.SetStruct(i, v.Struct) }

func (s Join_List) String() string {
	str, _ := text.MarshalList(0xc3bce9818d0e60a9, s.List)
	return str
}

// Join_Promise is a wrapper for a Join promised by a client call.
type Join_Promise struct{ *capnp.Pipeline }

func (p Join_Promise) Struct() (Join, error) {
	s, err := p.Pipeline.Struct()
	return Join{s}, err
}

func (p Join_Promise) Sep() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type KindOf struct{ capnp.Struct }

// KindOf_TypeID is the unique identifier for the type KindOf.
const KindOf_TypeID = 0xe08fc72478034f4e

func NewKindOf(s *capnp.Segment) (KindOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return KindOf{st}, err
}

func NewRootKindOf(s *capnp.Segment) (KindOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return KindOf{st}, err
}

func ReadRootKindOf(msg *capnp.Message) (KindOf, error) {
	root, err := msg.RootPtr()
	return KindOf{root.Struct()}, err
}

func (s KindOf) String() string {
	str, _ := text.Marshal(0xe08fc72478034f4e, s.Struct)
	return str
}

func (s KindOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s KindOf) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s KindOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s KindOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// KindOf_List is a list of KindOf.
type KindOf_List struct{ capnp.List }

// NewKindOf creates a new list of KindOf.
func NewKindOf_List(s *capnp.Segment, sz int32) (KindOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return KindOf_List{l}, err
}

func (s KindOf_List) At(i int) KindOf { return KindOf{s.List.Struct(i)} }

func (s KindOf_List) Set(i int, v KindOf) error { return s.List.SetStruct(i, v.Struct) }

func (s KindOf_List) String() string {
	str, _ := text.MarshalList(0xe08fc72478034f4e, s.List)
	return str
}

// KindOf_Promise is a wrapper for a KindOf promised by a client call.
type KindOf_Promise struct{ *capnp.Pipeline }

func (p KindOf_Promise) Struct() (KindOf, error) {
	s, err := p.Pipeline.Struct()
	return KindOf{s}, err
}

func (p KindOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type KindsOf struct{ capnp.Struct }

// KindsOf_TypeID is the unique identifier for the type KindsOf.
const KindsOf_TypeID = 0xd7d393648846f9e1

func NewKindsOf(s *capnp.Segment) (KindsOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return KindsOf{st}, err
}

func NewRootKindsOf(s *capnp.Segment) (KindsOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return KindsOf{st}, err
}

func ReadRootKindsOf(msg *capnp.Message) (KindsOf, error) {
	root, err := msg.RootPtr()
	return KindsOf{root.Struct()}, err
}

func (s KindsOf) String() string {
	str, _ := text.Marshal(0xd7d393648846f9e1, s.Struct)
	return str
}

func (s KindsOf) Kind() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s KindsOf) HasKind() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s KindsOf) SetKind(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKind sets the kind field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s KindsOf) NewKind() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// KindsOf_List is a list of KindsOf.
type KindsOf_List struct{ capnp.List }

// NewKindsOf creates a new list of KindsOf.
func NewKindsOf_List(s *capnp.Segment, sz int32) (KindsOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return KindsOf_List{l}, err
}

func (s KindsOf_List) At(i int) KindsOf { return KindsOf{s.List.Struct(i)} }

func (s KindsOf_List) Set(i int, v KindsOf) error { return s.List.SetStruct(i, v.Struct) }

func (s KindsOf_List) String() string {
	str, _ := text.MarshalList(0xd7d393648846f9e1, s.List)
	return str
}

// KindsOf_Promise is a wrapper for a KindsOf promised by a client call.
type KindsOf_Promise struct{ *capnp.Pipeline }

func (p KindsOf_Promise) Struct() (KindsOf, error) {
	s, err := p.Pipeline.Struct()
	return KindsOf{s}, err
}

func (p KindsOf_Promise) Kind() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Len struct{ capnp.Struct }

// Len_TypeID is the unique identifier for the type Len.
const Len_TypeID = 0x85d5302c0f03b62c

func NewLen(s *capnp.Segment) (Len, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Len{st}, err
}

func NewRootLen(s *capnp.Segment) (Len, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Len{st}, err
}

func ReadRootLen(msg *capnp.Message) (Len, error) {
	root, err := msg.RootPtr()
	return Len{root.Struct()}, err
}

func (s Len) String() string {
	str, _ := text.Marshal(0x85d5302c0f03b62c, s.Struct)
	return str
}

func (s Len) List() (Assignment, error) {
	p, err := s.Struct.Ptr(0)
	return Assignment{Struct: p.Struct()}, err
}

func (s Len) HasList() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Len) SetList(v Assignment) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewList sets the list field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Len) NewList() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Len_List is a list of Len.
type Len_List struct{ capnp.List }

// NewLen creates a new list of Len.
func NewLen_List(s *capnp.Segment, sz int32) (Len_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Len_List{l}, err
}

func (s Len_List) At(i int) Len { return Len{s.List.Struct(i)} }

func (s Len_List) Set(i int, v Len) error { return s.List.SetStruct(i, v.Struct) }

func (s Len_List) String() string {
	str, _ := text.MarshalList(0x85d5302c0f03b62c, s.List)
	return str
}

// Len_Promise is a wrapper for a Len promised by a client call.
type Len_Promise struct{ *capnp.Pipeline }

func (p Len_Promise) Struct() (Len, error) {
	s, err := p.Pipeline.Struct()
	return Len{s}, err
}

func (p Len_Promise) List() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type LessOrEqual struct{ capnp.Struct }

// LessOrEqual_TypeID is the unique identifier for the type LessOrEqual.
const LessOrEqual_TypeID = 0xb02c40488d6dcd7e

func NewLessOrEqual(s *capnp.Segment) (LessOrEqual, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return LessOrEqual{st}, err
}

func NewRootLessOrEqual(s *capnp.Segment) (LessOrEqual, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return LessOrEqual{st}, err
}

func ReadRootLessOrEqual(msg *capnp.Message) (LessOrEqual, error) {
	root, err := msg.RootPtr()
	return LessOrEqual{root.Struct()}, err
}

func (s LessOrEqual) String() string {
	str, _ := text.Marshal(0xb02c40488d6dcd7e, s.Struct)
	return str
}

// LessOrEqual_List is a list of LessOrEqual.
type LessOrEqual_List struct{ capnp.List }

// NewLessOrEqual creates a new list of LessOrEqual.
func NewLessOrEqual_List(s *capnp.Segment, sz int32) (LessOrEqual_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return LessOrEqual_List{l}, err
}

func (s LessOrEqual_List) At(i int) LessOrEqual { return LessOrEqual{s.List.Struct(i)} }

func (s LessOrEqual_List) Set(i int, v LessOrEqual) error { return s.List.SetStruct(i, v.Struct) }

func (s LessOrEqual_List) String() string {
	str, _ := text.MarshalList(0xb02c40488d6dcd7e, s.List)
	return str
}

// LessOrEqual_Promise is a wrapper for a LessOrEqual promised by a client call.
type LessOrEqual_Promise struct{ *capnp.Pipeline }

func (p LessOrEqual_Promise) Struct() (LessOrEqual, error) {
	s, err := p.Pipeline.Struct()
	return LessOrEqual{s}, err
}

type LessThan struct{ capnp.Struct }

// LessThan_TypeID is the unique identifier for the type LessThan.
const LessThan_TypeID = 0xde50d321776f40b5

func NewLessThan(s *capnp.Segment) (LessThan, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return LessThan{st}, err
}

func NewRootLessThan(s *capnp.Segment) (LessThan, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return LessThan{st}, err
}

func ReadRootLessThan(msg *capnp.Message) (LessThan, error) {
	root, err := msg.RootPtr()
	return LessThan{root.Struct()}, err
}

func (s LessThan) String() string {
	str, _ := text.Marshal(0xde50d321776f40b5, s.Struct)
	return str
}

// LessThan_List is a list of LessThan.
type LessThan_List struct{ capnp.List }

// NewLessThan creates a new list of LessThan.
func NewLessThan_List(s *capnp.Segment, sz int32) (LessThan_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return LessThan_List{l}, err
}

func (s LessThan_List) At(i int) LessThan { return LessThan{s.List.Struct(i)} }

func (s LessThan_List) Set(i int, v LessThan) error { return s.List.SetStruct(i, v.Struct) }

func (s LessThan_List) String() string {
	str, _ := text.MarshalList(0xde50d321776f40b5, s.List)
	return str
}

// LessThan_Promise is a wrapper for a LessThan promised by a client call.
type LessThan_Promise struct{ *capnp.Pipeline }

func (p LessThan_Promise) Struct() (LessThan, error) {
	s, err := p.Pipeline.Struct()
	return LessThan{s}, err
}

type Lines struct{ capnp.Struct }

// Lines_TypeID is the unique identifier for the type Lines.
const Lines_TypeID = 0xe4abe2b03dff7cc8

func NewLines(s *capnp.Segment) (Lines, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Lines{st}, err
}

func NewRootLines(s *capnp.Segment) (Lines, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Lines{st}, err
}

func ReadRootLines(msg *capnp.Message) (Lines, error) {
	root, err := msg.RootPtr()
	return Lines{root.Struct()}, err
}

func (s Lines) String() string {
	str, _ := text.Marshal(0xe4abe2b03dff7cc8, s.Struct)
	return str
}

func (s Lines) Lines() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Lines) HasLines() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Lines) SetLines(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewLines sets the lines field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Lines) NewLines() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Lines_List is a list of Lines.
type Lines_List struct{ capnp.List }

// NewLines creates a new list of Lines.
func NewLines_List(s *capnp.Segment, sz int32) (Lines_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Lines_List{l}, err
}

func (s Lines_List) At(i int) Lines { return Lines{s.List.Struct(i)} }

func (s Lines_List) Set(i int, v Lines) error { return s.List.SetStruct(i, v.Struct) }

func (s Lines_List) String() string {
	str, _ := text.MarshalList(0xe4abe2b03dff7cc8, s.List)
	return str
}

// Lines_Promise is a wrapper for a Lines promised by a client call.
type Lines_Promise struct{ *capnp.Pipeline }

func (p Lines_Promise) Struct() (Lines, error) {
	s, err := p.Pipeline.Struct()
	return Lines{s}, err
}

func (p Lines_Promise) Lines() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Log struct{ capnp.Struct }

// Log_TypeID is the unique identifier for the type Log.
const Log_TypeID = 0xe58f41cfd252caaa

func NewLog(s *capnp.Segment) (Log, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Log{st}, err
}

func NewRootLog(s *capnp.Segment) (Log, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Log{st}, err
}

func ReadRootLog(msg *capnp.Message) (Log, error) {
	root, err := msg.RootPtr()
	return Log{root.Struct()}, err
}

func (s Log) String() string {
	str, _ := text.Marshal(0xe58f41cfd252caaa, s.Struct)
	return str
}

func (s Log) Level() int32 {
	return int32(s.Struct.Uint32(0))
}

func (s Log) SetLevel(v int32) {
	s.Struct.SetUint32(0, uint32(v))
}

func (s Log) Value() (Assignment, error) {
	p, err := s.Struct.Ptr(0)
	return Assignment{Struct: p.Struct()}, err
}

func (s Log) HasValue() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Log) SetValue(v Assignment) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewValue sets the value field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Log) NewValue() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Log_List is a list of Log.
type Log_List struct{ capnp.List }

// NewLog creates a new list of Log.
func NewLog_List(s *capnp.Segment, sz int32) (Log_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return Log_List{l}, err
}

func (s Log_List) At(i int) Log { return Log{s.List.Struct(i)} }

func (s Log_List) Set(i int, v Log) error { return s.List.SetStruct(i, v.Struct) }

func (s Log_List) String() string {
	str, _ := text.MarshalList(0xe58f41cfd252caaa, s.List)
	return str
}

// Log_Promise is a wrapper for a Log promised by a client call.
type Log_Promise struct{ *capnp.Pipeline }

func (p Log_Promise) Struct() (Log, error) {
	s, err := p.Pipeline.Struct()
	return Log{s}, err
}

func (p Log_Promise) Value() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Make struct{ capnp.Struct }

// Make_TypeID is the unique identifier for the type Make.
const Make_TypeID = 0xe0dbb45e4742831d

func NewMake(s *capnp.Segment) (Make, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Make{st}, err
}

func NewRootMake(s *capnp.Segment) (Make, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Make{st}, err
}

func ReadRootMake(msg *capnp.Message) (Make, error) {
	root, err := msg.RootPtr()
	return Make{root.Struct()}, err
}

func (s Make) String() string {
	str, _ := text.Marshal(0xe0dbb45e4742831d, s.Struct)
	return str
}

func (s Make) Name() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Make) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Make) SetName(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Make) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Make) Args() (Argument_List, error) {
	p, err := s.Struct.Ptr(1)
	return Argument_List{List: p.List()}, err
}

func (s Make) HasArgs() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Make) SetArgs(v Argument_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated Argument_List, preferring placement in s's segment.
func (s Make) NewArgs(n int32) (Argument_List, error) {
	l, err := NewArgument_List(s.Struct.Segment(), n)
	if err != nil {
		return Argument_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Make_List is a list of Make.
type Make_List struct{ capnp.List }

// NewMake creates a new list of Make.
func NewMake_List(s *capnp.Segment, sz int32) (Make_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Make_List{l}, err
}

func (s Make_List) At(i int) Make { return Make{s.List.Struct(i)} }

func (s Make_List) Set(i int, v Make) error { return s.List.SetStruct(i, v.Struct) }

func (s Make_List) String() string {
	str, _ := text.MarshalList(0xe0dbb45e4742831d, s.List)
	return str
}

// Make_Promise is a wrapper for a Make promised by a client call.
type Make_Promise struct{ *capnp.Pipeline }

func (p Make_Promise) Struct() (Make, error) {
	s, err := p.Pipeline.Struct()
	return Make{s}, err
}

func (p Make_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type MakeLowercase struct{ capnp.Struct }

// MakeLowercase_TypeID is the unique identifier for the type MakeLowercase.
const MakeLowercase_TypeID = 0x8d1c50198e64b0a5

func NewMakeLowercase(s *capnp.Segment) (MakeLowercase, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeLowercase{st}, err
}

func NewRootMakeLowercase(s *capnp.Segment) (MakeLowercase, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeLowercase{st}, err
}

func ReadRootMakeLowercase(msg *capnp.Message) (MakeLowercase, error) {
	root, err := msg.RootPtr()
	return MakeLowercase{root.Struct()}, err
}

func (s MakeLowercase) String() string {
	str, _ := text.Marshal(0x8d1c50198e64b0a5, s.Struct)
	return str
}

func (s MakeLowercase) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s MakeLowercase) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MakeLowercase) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s MakeLowercase) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// MakeLowercase_List is a list of MakeLowercase.
type MakeLowercase_List struct{ capnp.List }

// NewMakeLowercase creates a new list of MakeLowercase.
func NewMakeLowercase_List(s *capnp.Segment, sz int32) (MakeLowercase_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return MakeLowercase_List{l}, err
}

func (s MakeLowercase_List) At(i int) MakeLowercase { return MakeLowercase{s.List.Struct(i)} }

func (s MakeLowercase_List) Set(i int, v MakeLowercase) error { return s.List.SetStruct(i, v.Struct) }

func (s MakeLowercase_List) String() string {
	str, _ := text.MarshalList(0x8d1c50198e64b0a5, s.List)
	return str
}

// MakeLowercase_Promise is a wrapper for a MakeLowercase promised by a client call.
type MakeLowercase_Promise struct{ *capnp.Pipeline }

func (p MakeLowercase_Promise) Struct() (MakeLowercase, error) {
	s, err := p.Pipeline.Struct()
	return MakeLowercase{s}, err
}

func (p MakeLowercase_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type MakePlural struct{ capnp.Struct }

// MakePlural_TypeID is the unique identifier for the type MakePlural.
const MakePlural_TypeID = 0x9458f6178f361ed1

func NewMakePlural(s *capnp.Segment) (MakePlural, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakePlural{st}, err
}

func NewRootMakePlural(s *capnp.Segment) (MakePlural, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakePlural{st}, err
}

func ReadRootMakePlural(msg *capnp.Message) (MakePlural, error) {
	root, err := msg.RootPtr()
	return MakePlural{root.Struct()}, err
}

func (s MakePlural) String() string {
	str, _ := text.Marshal(0x9458f6178f361ed1, s.Struct)
	return str
}

func (s MakePlural) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s MakePlural) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MakePlural) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s MakePlural) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// MakePlural_List is a list of MakePlural.
type MakePlural_List struct{ capnp.List }

// NewMakePlural creates a new list of MakePlural.
func NewMakePlural_List(s *capnp.Segment, sz int32) (MakePlural_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return MakePlural_List{l}, err
}

func (s MakePlural_List) At(i int) MakePlural { return MakePlural{s.List.Struct(i)} }

func (s MakePlural_List) Set(i int, v MakePlural) error { return s.List.SetStruct(i, v.Struct) }

func (s MakePlural_List) String() string {
	str, _ := text.MarshalList(0x9458f6178f361ed1, s.List)
	return str
}

// MakePlural_Promise is a wrapper for a MakePlural promised by a client call.
type MakePlural_Promise struct{ *capnp.Pipeline }

func (p MakePlural_Promise) Struct() (MakePlural, error) {
	s, err := p.Pipeline.Struct()
	return MakePlural{s}, err
}

func (p MakePlural_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type MakeReversed struct{ capnp.Struct }

// MakeReversed_TypeID is the unique identifier for the type MakeReversed.
const MakeReversed_TypeID = 0x84c64b0ff85b66f7

func NewMakeReversed(s *capnp.Segment) (MakeReversed, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeReversed{st}, err
}

func NewRootMakeReversed(s *capnp.Segment) (MakeReversed, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeReversed{st}, err
}

func ReadRootMakeReversed(msg *capnp.Message) (MakeReversed, error) {
	root, err := msg.RootPtr()
	return MakeReversed{root.Struct()}, err
}

func (s MakeReversed) String() string {
	str, _ := text.Marshal(0x84c64b0ff85b66f7, s.Struct)
	return str
}

func (s MakeReversed) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s MakeReversed) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MakeReversed) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s MakeReversed) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// MakeReversed_List is a list of MakeReversed.
type MakeReversed_List struct{ capnp.List }

// NewMakeReversed creates a new list of MakeReversed.
func NewMakeReversed_List(s *capnp.Segment, sz int32) (MakeReversed_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return MakeReversed_List{l}, err
}

func (s MakeReversed_List) At(i int) MakeReversed { return MakeReversed{s.List.Struct(i)} }

func (s MakeReversed_List) Set(i int, v MakeReversed) error { return s.List.SetStruct(i, v.Struct) }

func (s MakeReversed_List) String() string {
	str, _ := text.MarshalList(0x84c64b0ff85b66f7, s.List)
	return str
}

// MakeReversed_Promise is a wrapper for a MakeReversed promised by a client call.
type MakeReversed_Promise struct{ *capnp.Pipeline }

func (p MakeReversed_Promise) Struct() (MakeReversed, error) {
	s, err := p.Pipeline.Struct()
	return MakeReversed{s}, err
}

func (p MakeReversed_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type MakeSentenceCase struct{ capnp.Struct }

// MakeSentenceCase_TypeID is the unique identifier for the type MakeSentenceCase.
const MakeSentenceCase_TypeID = 0xdf288c45b0b84bc6

func NewMakeSentenceCase(s *capnp.Segment) (MakeSentenceCase, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeSentenceCase{st}, err
}

func NewRootMakeSentenceCase(s *capnp.Segment) (MakeSentenceCase, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeSentenceCase{st}, err
}

func ReadRootMakeSentenceCase(msg *capnp.Message) (MakeSentenceCase, error) {
	root, err := msg.RootPtr()
	return MakeSentenceCase{root.Struct()}, err
}

func (s MakeSentenceCase) String() string {
	str, _ := text.Marshal(0xdf288c45b0b84bc6, s.Struct)
	return str
}

func (s MakeSentenceCase) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s MakeSentenceCase) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MakeSentenceCase) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s MakeSentenceCase) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// MakeSentenceCase_List is a list of MakeSentenceCase.
type MakeSentenceCase_List struct{ capnp.List }

// NewMakeSentenceCase creates a new list of MakeSentenceCase.
func NewMakeSentenceCase_List(s *capnp.Segment, sz int32) (MakeSentenceCase_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return MakeSentenceCase_List{l}, err
}

func (s MakeSentenceCase_List) At(i int) MakeSentenceCase { return MakeSentenceCase{s.List.Struct(i)} }

func (s MakeSentenceCase_List) Set(i int, v MakeSentenceCase) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s MakeSentenceCase_List) String() string {
	str, _ := text.MarshalList(0xdf288c45b0b84bc6, s.List)
	return str
}

// MakeSentenceCase_Promise is a wrapper for a MakeSentenceCase promised by a client call.
type MakeSentenceCase_Promise struct{ *capnp.Pipeline }

func (p MakeSentenceCase_Promise) Struct() (MakeSentenceCase, error) {
	s, err := p.Pipeline.Struct()
	return MakeSentenceCase{s}, err
}

func (p MakeSentenceCase_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type MakeSingular struct{ capnp.Struct }

// MakeSingular_TypeID is the unique identifier for the type MakeSingular.
const MakeSingular_TypeID = 0x8db440cc81ed11af

func NewMakeSingular(s *capnp.Segment) (MakeSingular, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeSingular{st}, err
}

func NewRootMakeSingular(s *capnp.Segment) (MakeSingular, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeSingular{st}, err
}

func ReadRootMakeSingular(msg *capnp.Message) (MakeSingular, error) {
	root, err := msg.RootPtr()
	return MakeSingular{root.Struct()}, err
}

func (s MakeSingular) String() string {
	str, _ := text.Marshal(0x8db440cc81ed11af, s.Struct)
	return str
}

func (s MakeSingular) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s MakeSingular) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MakeSingular) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s MakeSingular) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// MakeSingular_List is a list of MakeSingular.
type MakeSingular_List struct{ capnp.List }

// NewMakeSingular creates a new list of MakeSingular.
func NewMakeSingular_List(s *capnp.Segment, sz int32) (MakeSingular_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return MakeSingular_List{l}, err
}

func (s MakeSingular_List) At(i int) MakeSingular { return MakeSingular{s.List.Struct(i)} }

func (s MakeSingular_List) Set(i int, v MakeSingular) error { return s.List.SetStruct(i, v.Struct) }

func (s MakeSingular_List) String() string {
	str, _ := text.MarshalList(0x8db440cc81ed11af, s.List)
	return str
}

// MakeSingular_Promise is a wrapper for a MakeSingular promised by a client call.
type MakeSingular_Promise struct{ *capnp.Pipeline }

func (p MakeSingular_Promise) Struct() (MakeSingular, error) {
	s, err := p.Pipeline.Struct()
	return MakeSingular{s}, err
}

func (p MakeSingular_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type MakeTitleCase struct{ capnp.Struct }

// MakeTitleCase_TypeID is the unique identifier for the type MakeTitleCase.
const MakeTitleCase_TypeID = 0xd29e45a1aeb93b4e

func NewMakeTitleCase(s *capnp.Segment) (MakeTitleCase, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeTitleCase{st}, err
}

func NewRootMakeTitleCase(s *capnp.Segment) (MakeTitleCase, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeTitleCase{st}, err
}

func ReadRootMakeTitleCase(msg *capnp.Message) (MakeTitleCase, error) {
	root, err := msg.RootPtr()
	return MakeTitleCase{root.Struct()}, err
}

func (s MakeTitleCase) String() string {
	str, _ := text.Marshal(0xd29e45a1aeb93b4e, s.Struct)
	return str
}

func (s MakeTitleCase) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s MakeTitleCase) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MakeTitleCase) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s MakeTitleCase) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// MakeTitleCase_List is a list of MakeTitleCase.
type MakeTitleCase_List struct{ capnp.List }

// NewMakeTitleCase creates a new list of MakeTitleCase.
func NewMakeTitleCase_List(s *capnp.Segment, sz int32) (MakeTitleCase_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return MakeTitleCase_List{l}, err
}

func (s MakeTitleCase_List) At(i int) MakeTitleCase { return MakeTitleCase{s.List.Struct(i)} }

func (s MakeTitleCase_List) Set(i int, v MakeTitleCase) error { return s.List.SetStruct(i, v.Struct) }

func (s MakeTitleCase_List) String() string {
	str, _ := text.MarshalList(0xd29e45a1aeb93b4e, s.List)
	return str
}

// MakeTitleCase_Promise is a wrapper for a MakeTitleCase promised by a client call.
type MakeTitleCase_Promise struct{ *capnp.Pipeline }

func (p MakeTitleCase_Promise) Struct() (MakeTitleCase, error) {
	s, err := p.Pipeline.Struct()
	return MakeTitleCase{s}, err
}

func (p MakeTitleCase_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type MakeUppercase struct{ capnp.Struct }

// MakeUppercase_TypeID is the unique identifier for the type MakeUppercase.
const MakeUppercase_TypeID = 0xd97fb70946864bfa

func NewMakeUppercase(s *capnp.Segment) (MakeUppercase, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeUppercase{st}, err
}

func NewRootMakeUppercase(s *capnp.Segment) (MakeUppercase, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return MakeUppercase{st}, err
}

func ReadRootMakeUppercase(msg *capnp.Message) (MakeUppercase, error) {
	root, err := msg.RootPtr()
	return MakeUppercase{root.Struct()}, err
}

func (s MakeUppercase) String() string {
	str, _ := text.Marshal(0xd97fb70946864bfa, s.Struct)
	return str
}

func (s MakeUppercase) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s MakeUppercase) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MakeUppercase) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s MakeUppercase) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// MakeUppercase_List is a list of MakeUppercase.
type MakeUppercase_List struct{ capnp.List }

// NewMakeUppercase creates a new list of MakeUppercase.
func NewMakeUppercase_List(s *capnp.Segment, sz int32) (MakeUppercase_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return MakeUppercase_List{l}, err
}

func (s MakeUppercase_List) At(i int) MakeUppercase { return MakeUppercase{s.List.Struct(i)} }

func (s MakeUppercase_List) Set(i int, v MakeUppercase) error { return s.List.SetStruct(i, v.Struct) }

func (s MakeUppercase_List) String() string {
	str, _ := text.MarshalList(0xd97fb70946864bfa, s.List)
	return str
}

// MakeUppercase_Promise is a wrapper for a MakeUppercase promised by a client call.
type MakeUppercase_Promise struct{ *capnp.Pipeline }

func (p MakeUppercase_Promise) Struct() (MakeUppercase, error) {
	s, err := p.Pipeline.Struct()
	return MakeUppercase{s}, err
}

func (p MakeUppercase_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Map struct{ capnp.Struct }

// Map_TypeID is the unique identifier for the type Map.
const Map_TypeID = 0xdc018eac657c47b3

func NewMap(s *capnp.Segment) (Map, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Map{st}, err
}

func NewRootMap(s *capnp.Segment) (Map, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Map{st}, err
}

func ReadRootMap(msg *capnp.Message) (Map, error) {
	root, err := msg.RootPtr()
	return Map{root.Struct()}, err
}

func (s Map) String() string {
	str, _ := text.Marshal(0xdc018eac657c47b3, s.Struct)
	return str
}

func (s Map) ToList() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Map) HasToList() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Map) SetToList(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewToList sets the toList field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Map) NewToList() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Map) FromList() (Assignment, error) {
	p, err := s.Struct.Ptr(1)
	return Assignment{Struct: p.Struct()}, err
}

func (s Map) HasFromList() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Map) SetFromList(v Assignment) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFromList sets the fromList field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Map) NewFromList() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Map) UsingPattern() (Text, error) {
	p, err := s.Struct.Ptr(2)
	return Text{Struct: p.Struct()}, err
}

func (s Map) HasUsingPattern() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Map) SetUsingPattern(v Text) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewUsingPattern sets the usingPattern field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Map) NewUsingPattern() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// Map_List is a list of Map.
type Map_List struct{ capnp.List }

// NewMap creates a new list of Map.
func NewMap_List(s *capnp.Segment, sz int32) (Map_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return Map_List{l}, err
}

func (s Map_List) At(i int) Map { return Map{s.List.Struct(i)} }

func (s Map_List) Set(i int, v Map) error { return s.List.SetStruct(i, v.Struct) }

func (s Map_List) String() string {
	str, _ := text.MarshalList(0xdc018eac657c47b3, s.List)
	return str
}

// Map_Promise is a wrapper for a Map promised by a client call.
type Map_Promise struct{ *capnp.Pipeline }

func (p Map_Promise) Struct() (Map, error) {
	s, err := p.Pipeline.Struct()
	return Map{s}, err
}

func (p Map_Promise) ToList() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Map_Promise) FromList() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Map_Promise) UsingPattern() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type Matches struct{ capnp.Struct }

// Matches_TypeID is the unique identifier for the type Matches.
const Matches_TypeID = 0xa9954603f517f5ff

func NewMatches(s *capnp.Segment) (Matches, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Matches{st}, err
}

func NewRootMatches(s *capnp.Segment) (Matches, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Matches{st}, err
}

func ReadRootMatches(msg *capnp.Message) (Matches, error) {
	root, err := msg.RootPtr()
	return Matches{root.Struct()}, err
}

func (s Matches) String() string {
	str, _ := text.Marshal(0xa9954603f517f5ff, s.Struct)
	return str
}

func (s Matches) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s Matches) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Matches) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Matches) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Matches) Pattern() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s Matches) HasPattern() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Matches) SetPattern(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewPattern sets the pattern field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Matches) NewPattern() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Matches_List is a list of Matches.
type Matches_List struct{ capnp.List }

// NewMatches creates a new list of Matches.
func NewMatches_List(s *capnp.Segment, sz int32) (Matches_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Matches_List{l}, err
}

func (s Matches_List) At(i int) Matches { return Matches{s.List.Struct(i)} }

func (s Matches_List) Set(i int, v Matches) error { return s.List.SetStruct(i, v.Struct) }

func (s Matches_List) String() string {
	str, _ := text.MarshalList(0xa9954603f517f5ff, s.List)
	return str
}

// Matches_Promise is a wrapper for a Matches promised by a client call.
type Matches_Promise struct{ *capnp.Pipeline }

func (p Matches_Promise) Struct() (Matches, error) {
	s, err := p.Pipeline.Struct()
	return Matches{s}, err
}

func (p Matches_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Matches_Promise) Pattern() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type NameOf struct{ capnp.Struct }

// NameOf_TypeID is the unique identifier for the type NameOf.
const NameOf_TypeID = 0xbf1af4a4a9c7eb17

func NewNameOf(s *capnp.Segment) (NameOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NameOf{st}, err
}

func NewRootNameOf(s *capnp.Segment) (NameOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NameOf{st}, err
}

func ReadRootNameOf(msg *capnp.Message) (NameOf, error) {
	root, err := msg.RootPtr()
	return NameOf{root.Struct()}, err
}

func (s NameOf) String() string {
	str, _ := text.Marshal(0xbf1af4a4a9c7eb17, s.Struct)
	return str
}

func (s NameOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s NameOf) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s NameOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s NameOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// NameOf_List is a list of NameOf.
type NameOf_List struct{ capnp.List }

// NewNameOf creates a new list of NameOf.
func NewNameOf_List(s *capnp.Segment, sz int32) (NameOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return NameOf_List{l}, err
}

func (s NameOf_List) At(i int) NameOf { return NameOf{s.List.Struct(i)} }

func (s NameOf_List) Set(i int, v NameOf) error { return s.List.SetStruct(i, v.Struct) }

func (s NameOf_List) String() string {
	str, _ := text.MarshalList(0xbf1af4a4a9c7eb17, s.List)
	return str
}

// NameOf_Promise is a wrapper for a NameOf promised by a client call.
type NameOf_Promise struct{ *capnp.Pipeline }

func (p NameOf_Promise) Struct() (NameOf, error) {
	s, err := p.Pipeline.Struct()
	return NameOf{s}, err
}

func (p NameOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Newline struct{ capnp.Struct }

// Newline_TypeID is the unique identifier for the type Newline.
const Newline_TypeID = 0xc613ed9e87933b32

func NewNewline(s *capnp.Segment) (Newline, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Newline{st}, err
}

func NewRootNewline(s *capnp.Segment) (Newline, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Newline{st}, err
}

func ReadRootNewline(msg *capnp.Message) (Newline, error) {
	root, err := msg.RootPtr()
	return Newline{root.Struct()}, err
}

func (s Newline) String() string {
	str, _ := text.Marshal(0xc613ed9e87933b32, s.Struct)
	return str
}

// Newline_List is a list of Newline.
type Newline_List struct{ capnp.List }

// NewNewline creates a new list of Newline.
func NewNewline_List(s *capnp.Segment, sz int32) (Newline_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Newline_List{l}, err
}

func (s Newline_List) At(i int) Newline { return Newline{s.List.Struct(i)} }

func (s Newline_List) Set(i int, v Newline) error { return s.List.SetStruct(i, v.Struct) }

func (s Newline_List) String() string {
	str, _ := text.MarshalList(0xc613ed9e87933b32, s.List)
	return str
}

// Newline_Promise is a wrapper for a Newline promised by a client call.
type Newline_Promise struct{ *capnp.Pipeline }

func (p Newline_Promise) Struct() (Newline, error) {
	s, err := p.Pipeline.Struct()
	return Newline{s}, err
}

type Next struct{ capnp.Struct }

// Next_TypeID is the unique identifier for the type Next.
const Next_TypeID = 0xaf066240ac93ca80

func NewNext(s *capnp.Segment) (Next, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Next{st}, err
}

func NewRootNext(s *capnp.Segment) (Next, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Next{st}, err
}

func ReadRootNext(msg *capnp.Message) (Next, error) {
	root, err := msg.RootPtr()
	return Next{root.Struct()}, err
}

func (s Next) String() string {
	str, _ := text.Marshal(0xaf066240ac93ca80, s.Struct)
	return str
}

// Next_List is a list of Next.
type Next_List struct{ capnp.List }

// NewNext creates a new list of Next.
func NewNext_List(s *capnp.Segment, sz int32) (Next_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Next_List{l}, err
}

func (s Next_List) At(i int) Next { return Next{s.List.Struct(i)} }

func (s Next_List) Set(i int, v Next) error { return s.List.SetStruct(i, v.Struct) }

func (s Next_List) String() string {
	str, _ := text.MarshalList(0xaf066240ac93ca80, s.List)
	return str
}

// Next_Promise is a wrapper for a Next promised by a client call.
type Next_Promise struct{ *capnp.Pipeline }

func (p Next_Promise) Struct() (Next, error) {
	s, err := p.Pipeline.Struct()
	return Next{s}, err
}

type NotEqualTo struct{ capnp.Struct }

// NotEqualTo_TypeID is the unique identifier for the type NotEqualTo.
const NotEqualTo_TypeID = 0xcdde9b01cd84fc1f

func NewNotEqualTo(s *capnp.Segment) (NotEqualTo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return NotEqualTo{st}, err
}

func NewRootNotEqualTo(s *capnp.Segment) (NotEqualTo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return NotEqualTo{st}, err
}

func ReadRootNotEqualTo(msg *capnp.Message) (NotEqualTo, error) {
	root, err := msg.RootPtr()
	return NotEqualTo{root.Struct()}, err
}

func (s NotEqualTo) String() string {
	str, _ := text.Marshal(0xcdde9b01cd84fc1f, s.Struct)
	return str
}

// NotEqualTo_List is a list of NotEqualTo.
type NotEqualTo_List struct{ capnp.List }

// NewNotEqualTo creates a new list of NotEqualTo.
func NewNotEqualTo_List(s *capnp.Segment, sz int32) (NotEqualTo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return NotEqualTo_List{l}, err
}

func (s NotEqualTo_List) At(i int) NotEqualTo { return NotEqualTo{s.List.Struct(i)} }

func (s NotEqualTo_List) Set(i int, v NotEqualTo) error { return s.List.SetStruct(i, v.Struct) }

func (s NotEqualTo_List) String() string {
	str, _ := text.MarshalList(0xcdde9b01cd84fc1f, s.List)
	return str
}

// NotEqualTo_Promise is a wrapper for a NotEqualTo promised by a client call.
type NotEqualTo_Promise struct{ *capnp.Pipeline }

func (p NotEqualTo_Promise) Struct() (NotEqualTo, error) {
	s, err := p.Pipeline.Struct()
	return NotEqualTo{s}, err
}

type Noun struct{ capnp.Struct }

// Noun_TypeID is the unique identifier for the type Noun.
const Noun_TypeID = 0xa0d5ec6e3a857d3a

func NewNoun(s *capnp.Segment) (Noun, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Noun{st}, err
}

func NewRootNoun(s *capnp.Segment) (Noun, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Noun{st}, err
}

func ReadRootNoun(msg *capnp.Message) (Noun, error) {
	root, err := msg.RootPtr()
	return Noun{root.Struct()}, err
}

func (s Noun) String() string {
	str, _ := text.Marshal(0xa0d5ec6e3a857d3a, s.Struct)
	return str
}

func (s Noun) Kind() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Noun) HasKind() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Noun) SetKind(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewKind sets the kind field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Noun) NewKind() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Noun_List is a list of Noun.
type Noun_List struct{ capnp.List }

// NewNoun creates a new list of Noun.
func NewNoun_List(s *capnp.Segment, sz int32) (Noun_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Noun_List{l}, err
}

func (s Noun_List) At(i int) Noun { return Noun{s.List.Struct(i)} }

func (s Noun_List) Set(i int, v Noun) error { return s.List.SetStruct(i, v.Struct) }

func (s Noun_List) String() string {
	str, _ := text.MarshalList(0xa0d5ec6e3a857d3a, s.List)
	return str
}

// Noun_Promise is a wrapper for a Noun promised by a client call.
type Noun_Promise struct{ *capnp.Pipeline }

func (p Noun_Promise) Struct() (Noun, error) {
	s, err := p.Pipeline.Struct()
	return Noun{s}, err
}

func (p Noun_Promise) Kind() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Number struct{ capnp.Struct }

// Number_TypeID is the unique identifier for the type Number.
const Number_TypeID = 0x8c2db996afe65923

func NewNumber(s *capnp.Segment) (Number, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Number{st}, err
}

func NewRootNumber(s *capnp.Segment) (Number, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Number{st}, err
}

func ReadRootNumber(msg *capnp.Message) (Number, error) {
	root, err := msg.RootPtr()
	return Number{root.Struct()}, err
}

func (s Number) String() string {
	str, _ := text.Marshal(0x8c2db996afe65923, s.Struct)
	return str
}

func (s Number) Num() float64 {
	return math.Float64frombits(s.Struct.Uint64(0))
}

func (s Number) SetNum(v float64) {
	s.Struct.SetUint64(0, math.Float64bits(v))
}

// Number_List is a list of Number.
type Number_List struct{ capnp.List }

// NewNumber creates a new list of Number.
func NewNumber_List(s *capnp.Segment, sz int32) (Number_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return Number_List{l}, err
}

func (s Number_List) At(i int) Number { return Number{s.List.Struct(i)} }

func (s Number_List) Set(i int, v Number) error { return s.List.SetStruct(i, v.Struct) }

func (s Number_List) String() string {
	str, _ := text.MarshalList(0x8c2db996afe65923, s.List)
	return str
}

// Number_Promise is a wrapper for a Number promised by a client call.
type Number_Promise struct{ *capnp.Pipeline }

func (p Number_Promise) Struct() (Number, error) {
	s, err := p.Pipeline.Struct()
	return Number{s}, err
}

type Numbers struct{ capnp.Struct }

// Numbers_TypeID is the unique identifier for the type Numbers.
const Numbers_TypeID = 0x90d7ac241860cf51

func NewNumbers(s *capnp.Segment) (Numbers, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Numbers{st}, err
}

func NewRootNumbers(s *capnp.Segment) (Numbers, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Numbers{st}, err
}

func ReadRootNumbers(msg *capnp.Message) (Numbers, error) {
	root, err := msg.RootPtr()
	return Numbers{root.Struct()}, err
}

func (s Numbers) String() string {
	str, _ := text.Marshal(0x90d7ac241860cf51, s.Struct)
	return str
}

func (s Numbers) Values() (capnp.Float64List, error) {
	p, err := s.Struct.Ptr(0)
	return capnp.Float64List{List: p.List()}, err
}

func (s Numbers) HasValues() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Numbers) SetValues(v capnp.Float64List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewValues sets the values field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Numbers) NewValues(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Numbers_List is a list of Numbers.
type Numbers_List struct{ capnp.List }

// NewNumbers creates a new list of Numbers.
func NewNumbers_List(s *capnp.Segment, sz int32) (Numbers_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Numbers_List{l}, err
}

func (s Numbers_List) At(i int) Numbers { return Numbers{s.List.Struct(i)} }

func (s Numbers_List) Set(i int, v Numbers) error { return s.List.SetStruct(i, v.Struct) }

func (s Numbers_List) String() string {
	str, _ := text.MarshalList(0x90d7ac241860cf51, s.List)
	return str
}

// Numbers_Promise is a wrapper for a Numbers promised by a client call.
type Numbers_Promise struct{ *capnp.Pipeline }

func (p Numbers_Promise) Struct() (Numbers, error) {
	s, err := p.Pipeline.Struct()
	return Numbers{s}, err
}

type ObjectExists struct{ capnp.Struct }

// ObjectExists_TypeID is the unique identifier for the type ObjectExists.
const ObjectExists_TypeID = 0xc9e51b196dbea45c

func NewObjectExists(s *capnp.Segment) (ObjectExists, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ObjectExists{st}, err
}

func NewRootObjectExists(s *capnp.Segment) (ObjectExists, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ObjectExists{st}, err
}

func ReadRootObjectExists(msg *capnp.Message) (ObjectExists, error) {
	root, err := msg.RootPtr()
	return ObjectExists{root.Struct()}, err
}

func (s ObjectExists) String() string {
	str, _ := text.Marshal(0xc9e51b196dbea45c, s.Struct)
	return str
}

func (s ObjectExists) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s ObjectExists) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ObjectExists) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s ObjectExists) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ObjectExists_List is a list of ObjectExists.
type ObjectExists_List struct{ capnp.List }

// NewObjectExists creates a new list of ObjectExists.
func NewObjectExists_List(s *capnp.Segment, sz int32) (ObjectExists_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return ObjectExists_List{l}, err
}

func (s ObjectExists_List) At(i int) ObjectExists { return ObjectExists{s.List.Struct(i)} }

func (s ObjectExists_List) Set(i int, v ObjectExists) error { return s.List.SetStruct(i, v.Struct) }

func (s ObjectExists_List) String() string {
	str, _ := text.MarshalList(0xc9e51b196dbea45c, s.List)
	return str
}

// ObjectExists_Promise is a wrapper for a ObjectExists promised by a client call.
type ObjectExists_Promise struct{ *capnp.Pipeline }

func (p ObjectExists_Promise) Struct() (ObjectExists, error) {
	s, err := p.Pipeline.Struct()
	return ObjectExists{s}, err
}

func (p ObjectExists_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Paragraph struct{ capnp.Struct }

// Paragraph_TypeID is the unique identifier for the type Paragraph.
const Paragraph_TypeID = 0xe6f4437448d57536

func NewParagraph(s *capnp.Segment) (Paragraph, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Paragraph{st}, err
}

func NewRootParagraph(s *capnp.Segment) (Paragraph, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Paragraph{st}, err
}

func ReadRootParagraph(msg *capnp.Message) (Paragraph, error) {
	root, err := msg.RootPtr()
	return Paragraph{root.Struct()}, err
}

func (s Paragraph) String() string {
	str, _ := text.Marshal(0xe6f4437448d57536, s.Struct)
	return str
}

// Paragraph_List is a list of Paragraph.
type Paragraph_List struct{ capnp.List }

// NewParagraph creates a new list of Paragraph.
func NewParagraph_List(s *capnp.Segment, sz int32) (Paragraph_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Paragraph_List{l}, err
}

func (s Paragraph_List) At(i int) Paragraph { return Paragraph{s.List.Struct(i)} }

func (s Paragraph_List) Set(i int, v Paragraph) error { return s.List.SetStruct(i, v.Struct) }

func (s Paragraph_List) String() string {
	str, _ := text.MarshalList(0xe6f4437448d57536, s.List)
	return str
}

// Paragraph_Promise is a wrapper for a Paragraph promised by a client call.
type Paragraph_Promise struct{ *capnp.Pipeline }

func (p Paragraph_Promise) Struct() (Paragraph, error) {
	s, err := p.Pipeline.Struct()
	return Paragraph{s}, err
}

type PrintNum struct{ capnp.Struct }

// PrintNum_TypeID is the unique identifier for the type PrintNum.
const PrintNum_TypeID = 0x94c943236a00f05a

func NewPrintNum(s *capnp.Segment) (PrintNum, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return PrintNum{st}, err
}

func NewRootPrintNum(s *capnp.Segment) (PrintNum, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return PrintNum{st}, err
}

func ReadRootPrintNum(msg *capnp.Message) (PrintNum, error) {
	root, err := msg.RootPtr()
	return PrintNum{root.Struct()}, err
}

func (s PrintNum) String() string {
	str, _ := text.Marshal(0x94c943236a00f05a, s.Struct)
	return str
}

func (s PrintNum) Num() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s PrintNum) HasNum() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s PrintNum) SetNum(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s PrintNum) NewNum() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// PrintNum_List is a list of PrintNum.
type PrintNum_List struct{ capnp.List }

// NewPrintNum creates a new list of PrintNum.
func NewPrintNum_List(s *capnp.Segment, sz int32) (PrintNum_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return PrintNum_List{l}, err
}

func (s PrintNum_List) At(i int) PrintNum { return PrintNum{s.List.Struct(i)} }

func (s PrintNum_List) Set(i int, v PrintNum) error { return s.List.SetStruct(i, v.Struct) }

func (s PrintNum_List) String() string {
	str, _ := text.MarshalList(0x94c943236a00f05a, s.List)
	return str
}

// PrintNum_Promise is a wrapper for a PrintNum promised by a client call.
type PrintNum_Promise struct{ *capnp.Pipeline }

func (p PrintNum_Promise) Struct() (PrintNum, error) {
	s, err := p.Pipeline.Struct()
	return PrintNum{s}, err
}

func (p PrintNum_Promise) Num() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type PrintNumWord struct{ capnp.Struct }

// PrintNumWord_TypeID is the unique identifier for the type PrintNumWord.
const PrintNumWord_TypeID = 0xd392ca22bc09bd3a

func NewPrintNumWord(s *capnp.Segment) (PrintNumWord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return PrintNumWord{st}, err
}

func NewRootPrintNumWord(s *capnp.Segment) (PrintNumWord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return PrintNumWord{st}, err
}

func ReadRootPrintNumWord(msg *capnp.Message) (PrintNumWord, error) {
	root, err := msg.RootPtr()
	return PrintNumWord{root.Struct()}, err
}

func (s PrintNumWord) String() string {
	str, _ := text.Marshal(0xd392ca22bc09bd3a, s.Struct)
	return str
}

func (s PrintNumWord) Num() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s PrintNumWord) HasNum() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s PrintNumWord) SetNum(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewNum sets the num field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s PrintNumWord) NewNum() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// PrintNumWord_List is a list of PrintNumWord.
type PrintNumWord_List struct{ capnp.List }

// NewPrintNumWord creates a new list of PrintNumWord.
func NewPrintNumWord_List(s *capnp.Segment, sz int32) (PrintNumWord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return PrintNumWord_List{l}, err
}

func (s PrintNumWord_List) At(i int) PrintNumWord { return PrintNumWord{s.List.Struct(i)} }

func (s PrintNumWord_List) Set(i int, v PrintNumWord) error { return s.List.SetStruct(i, v.Struct) }

func (s PrintNumWord_List) String() string {
	str, _ := text.MarshalList(0xd392ca22bc09bd3a, s.List)
	return str
}

// PrintNumWord_Promise is a wrapper for a PrintNumWord promised by a client call.
type PrintNumWord_Promise struct{ *capnp.Pipeline }

func (p PrintNumWord_Promise) Struct() (PrintNumWord, error) {
	s, err := p.Pipeline.Struct()
	return PrintNumWord{s}, err
}

func (p PrintNumWord_Promise) Num() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ProductOf struct{ capnp.Struct }

// ProductOf_TypeID is the unique identifier for the type ProductOf.
const ProductOf_TypeID = 0xccdcec72f34d3b35

func NewProductOf(s *capnp.Segment) (ProductOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ProductOf{st}, err
}

func NewRootProductOf(s *capnp.Segment) (ProductOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ProductOf{st}, err
}

func ReadRootProductOf(msg *capnp.Message) (ProductOf, error) {
	root, err := msg.RootPtr()
	return ProductOf{root.Struct()}, err
}

func (s ProductOf) String() string {
	str, _ := text.Marshal(0xccdcec72f34d3b35, s.Struct)
	return str
}

func (s ProductOf) A() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s ProductOf) HasA() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ProductOf) SetA(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA sets the a field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s ProductOf) NewA() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ProductOf) B() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s ProductOf) HasB() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ProductOf) SetB(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewB sets the b field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s ProductOf) NewB() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// ProductOf_List is a list of ProductOf.
type ProductOf_List struct{ capnp.List }

// NewProductOf creates a new list of ProductOf.
func NewProductOf_List(s *capnp.Segment, sz int32) (ProductOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return ProductOf_List{l}, err
}

func (s ProductOf_List) At(i int) ProductOf { return ProductOf{s.List.Struct(i)} }

func (s ProductOf_List) Set(i int, v ProductOf) error { return s.List.SetStruct(i, v.Struct) }

func (s ProductOf_List) String() string {
	str, _ := text.MarshalList(0xccdcec72f34d3b35, s.List)
	return str
}

// ProductOf_Promise is a wrapper for a ProductOf promised by a client call.
type ProductOf_Promise struct{ *capnp.Pipeline }

func (p ProductOf_Promise) Struct() (ProductOf, error) {
	s, err := p.Pipeline.Struct()
	return ProductOf{s}, err
}

func (p ProductOf_Promise) A() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ProductOf_Promise) B() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type PutAtField struct{ capnp.Struct }

// PutAtField_TypeID is the unique identifier for the type PutAtField.
const PutAtField_TypeID = 0xeffa3400da8ff5d5

func NewPutAtField(s *capnp.Segment) (PutAtField, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PutAtField{st}, err
}

func NewRootPutAtField(s *capnp.Segment) (PutAtField, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PutAtField{st}, err
}

func ReadRootPutAtField(msg *capnp.Message) (PutAtField, error) {
	root, err := msg.RootPtr()
	return PutAtField{root.Struct()}, err
}

func (s PutAtField) String() string {
	str, _ := text.Marshal(0xeffa3400da8ff5d5, s.Struct)
	return str
}

func (s PutAtField) Into() (IntoTargetFields, error) {
	p, err := s.Struct.Ptr(0)
	return IntoTargetFields{Struct: p.Struct()}, err
}

func (s PutAtField) HasInto() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s PutAtField) SetInto(v IntoTargetFields) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewInto sets the into field to a newly
// allocated IntoTargetFields struct, preferring placement in s's segment.
func (s PutAtField) NewInto() (IntoTargetFields, error) {
	ss, err := NewIntoTargetFields(s.Struct.Segment())
	if err != nil {
		return IntoTargetFields{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s PutAtField) From() (Assignment, error) {
	p, err := s.Struct.Ptr(1)
	return Assignment{Struct: p.Struct()}, err
}

func (s PutAtField) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s PutAtField) SetFrom(v Assignment) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s PutAtField) NewFrom() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s PutAtField) AtField() (Text, error) {
	p, err := s.Struct.Ptr(2)
	return Text{Struct: p.Struct()}, err
}

func (s PutAtField) HasAtField() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s PutAtField) SetAtField(v Text) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewAtField sets the atField field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s PutAtField) NewAtField() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// PutAtField_List is a list of PutAtField.
type PutAtField_List struct{ capnp.List }

// NewPutAtField creates a new list of PutAtField.
func NewPutAtField_List(s *capnp.Segment, sz int32) (PutAtField_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return PutAtField_List{l}, err
}

func (s PutAtField_List) At(i int) PutAtField { return PutAtField{s.List.Struct(i)} }

func (s PutAtField_List) Set(i int, v PutAtField) error { return s.List.SetStruct(i, v.Struct) }

func (s PutAtField_List) String() string {
	str, _ := text.MarshalList(0xeffa3400da8ff5d5, s.List)
	return str
}

// PutAtField_Promise is a wrapper for a PutAtField promised by a client call.
type PutAtField_Promise struct{ *capnp.Pipeline }

func (p PutAtField_Promise) Struct() (PutAtField, error) {
	s, err := p.Pipeline.Struct()
	return PutAtField{s}, err
}

func (p PutAtField_Promise) Into() IntoTargetFields_Promise {
	return IntoTargetFields_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p PutAtField_Promise) From() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p PutAtField_Promise) AtField() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type PutEdge struct{ capnp.Struct }

// PutEdge_TypeID is the unique identifier for the type PutEdge.
const PutEdge_TypeID = 0xe6f17495ad724385

func NewPutEdge(s *capnp.Segment) (PutEdge, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PutEdge{st}, err
}

func NewRootPutEdge(s *capnp.Segment) (PutEdge, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PutEdge{st}, err
}

func ReadRootPutEdge(msg *capnp.Message) (PutEdge, error) {
	root, err := msg.RootPtr()
	return PutEdge{root.Struct()}, err
}

func (s PutEdge) String() string {
	str, _ := text.Marshal(0xe6f17495ad724385, s.Struct)
	return str
}

func (s PutEdge) From() (Assignment, error) {
	p, err := s.Struct.Ptr(0)
	return Assignment{Struct: p.Struct()}, err
}

func (s PutEdge) HasFrom() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s PutEdge) SetFrom(v Assignment) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s PutEdge) NewFrom() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s PutEdge) Into() (ListTarget, error) {
	p, err := s.Struct.Ptr(1)
	return ListTarget{Struct: p.Struct()}, err
}

func (s PutEdge) HasInto() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s PutEdge) SetInto(v ListTarget) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewInto sets the into field to a newly
// allocated ListTarget struct, preferring placement in s's segment.
func (s PutEdge) NewInto() (ListTarget, error) {
	ss, err := NewListTarget(s.Struct.Segment())
	if err != nil {
		return ListTarget{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s PutEdge) AtEdge() (Bool, error) {
	p, err := s.Struct.Ptr(2)
	return Bool{Struct: p.Struct()}, err
}

func (s PutEdge) HasAtEdge() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s PutEdge) SetAtEdge(v Bool) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewAtEdge sets the atEdge field to a newly
// allocated Bool struct, preferring placement in s's segment.
func (s PutEdge) NewAtEdge() (Bool, error) {
	ss, err := NewBool(s.Struct.Segment())
	if err != nil {
		return Bool{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// PutEdge_List is a list of PutEdge.
type PutEdge_List struct{ capnp.List }

// NewPutEdge creates a new list of PutEdge.
func NewPutEdge_List(s *capnp.Segment, sz int32) (PutEdge_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return PutEdge_List{l}, err
}

func (s PutEdge_List) At(i int) PutEdge { return PutEdge{s.List.Struct(i)} }

func (s PutEdge_List) Set(i int, v PutEdge) error { return s.List.SetStruct(i, v.Struct) }

func (s PutEdge_List) String() string {
	str, _ := text.MarshalList(0xe6f17495ad724385, s.List)
	return str
}

// PutEdge_Promise is a wrapper for a PutEdge promised by a client call.
type PutEdge_Promise struct{ *capnp.Pipeline }

func (p PutEdge_Promise) Struct() (PutEdge, error) {
	s, err := p.Pipeline.Struct()
	return PutEdge{s}, err
}

func (p PutEdge_Promise) From() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p PutEdge_Promise) Into() ListTarget_Promise {
	return ListTarget_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p PutEdge_Promise) AtEdge() Bool_Promise {
	return Bool_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type PutIndex struct{ capnp.Struct }

// PutIndex_TypeID is the unique identifier for the type PutIndex.
const PutIndex_TypeID = 0xda5eae6d2cb4b33f

func NewPutIndex(s *capnp.Segment) (PutIndex, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PutIndex{st}, err
}

func NewRootPutIndex(s *capnp.Segment) (PutIndex, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PutIndex{st}, err
}

func ReadRootPutIndex(msg *capnp.Message) (PutIndex, error) {
	root, err := msg.RootPtr()
	return PutIndex{root.Struct()}, err
}

func (s PutIndex) String() string {
	str, _ := text.Marshal(0xda5eae6d2cb4b33f, s.Struct)
	return str
}

func (s PutIndex) From() (Assignment, error) {
	p, err := s.Struct.Ptr(0)
	return Assignment{Struct: p.Struct()}, err
}

func (s PutIndex) HasFrom() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s PutIndex) SetFrom(v Assignment) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s PutIndex) NewFrom() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s PutIndex) Into() (ListTarget, error) {
	p, err := s.Struct.Ptr(1)
	return ListTarget{Struct: p.Struct()}, err
}

func (s PutIndex) HasInto() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s PutIndex) SetInto(v ListTarget) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewInto sets the into field to a newly
// allocated ListTarget struct, preferring placement in s's segment.
func (s PutIndex) NewInto() (ListTarget, error) {
	ss, err := NewListTarget(s.Struct.Segment())
	if err != nil {
		return ListTarget{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s PutIndex) AtIndex() (NumberEval, error) {
	p, err := s.Struct.Ptr(2)
	return NumberEval{Struct: p.Struct()}, err
}

func (s PutIndex) HasAtIndex() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s PutIndex) SetAtIndex(v NumberEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewAtIndex sets the atIndex field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s PutIndex) NewAtIndex() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// PutIndex_List is a list of PutIndex.
type PutIndex_List struct{ capnp.List }

// NewPutIndex creates a new list of PutIndex.
func NewPutIndex_List(s *capnp.Segment, sz int32) (PutIndex_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return PutIndex_List{l}, err
}

func (s PutIndex_List) At(i int) PutIndex { return PutIndex{s.List.Struct(i)} }

func (s PutIndex_List) Set(i int, v PutIndex) error { return s.List.SetStruct(i, v.Struct) }

func (s PutIndex_List) String() string {
	str, _ := text.MarshalList(0xda5eae6d2cb4b33f, s.List)
	return str
}

// PutIndex_Promise is a wrapper for a PutIndex promised by a client call.
type PutIndex_Promise struct{ *capnp.Pipeline }

func (p PutIndex_Promise) Struct() (PutIndex, error) {
	s, err := p.Pipeline.Struct()
	return PutIndex{s}, err
}

func (p PutIndex_Promise) From() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p PutIndex_Promise) Into() ListTarget_Promise {
	return ListTarget_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p PutIndex_Promise) AtIndex() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type QuotientOf struct{ capnp.Struct }

// QuotientOf_TypeID is the unique identifier for the type QuotientOf.
const QuotientOf_TypeID = 0xe6f0752dbb696399

func NewQuotientOf(s *capnp.Segment) (QuotientOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return QuotientOf{st}, err
}

func NewRootQuotientOf(s *capnp.Segment) (QuotientOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return QuotientOf{st}, err
}

func ReadRootQuotientOf(msg *capnp.Message) (QuotientOf, error) {
	root, err := msg.RootPtr()
	return QuotientOf{root.Struct()}, err
}

func (s QuotientOf) String() string {
	str, _ := text.Marshal(0xe6f0752dbb696399, s.Struct)
	return str
}

func (s QuotientOf) A() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s QuotientOf) HasA() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s QuotientOf) SetA(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA sets the a field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s QuotientOf) NewA() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s QuotientOf) B() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s QuotientOf) HasB() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s QuotientOf) SetB(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewB sets the b field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s QuotientOf) NewB() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// QuotientOf_List is a list of QuotientOf.
type QuotientOf_List struct{ capnp.List }

// NewQuotientOf creates a new list of QuotientOf.
func NewQuotientOf_List(s *capnp.Segment, sz int32) (QuotientOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return QuotientOf_List{l}, err
}

func (s QuotientOf_List) At(i int) QuotientOf { return QuotientOf{s.List.Struct(i)} }

func (s QuotientOf_List) Set(i int, v QuotientOf) error { return s.List.SetStruct(i, v.Struct) }

func (s QuotientOf_List) String() string {
	str, _ := text.MarshalList(0xe6f0752dbb696399, s.List)
	return str
}

// QuotientOf_Promise is a wrapper for a QuotientOf promised by a client call.
type QuotientOf_Promise struct{ *capnp.Pipeline }

func (p QuotientOf_Promise) Struct() (QuotientOf, error) {
	s, err := p.Pipeline.Struct()
	return QuotientOf{s}, err
}

func (p QuotientOf_Promise) A() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p QuotientOf_Promise) B() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Range struct{ capnp.Struct }

// Range_TypeID is the unique identifier for the type Range.
const Range_TypeID = 0x913361a0f4593621

func NewRange(s *capnp.Segment) (Range, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Range{st}, err
}

func NewRootRange(s *capnp.Segment) (Range, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Range{st}, err
}

func ReadRootRange(msg *capnp.Message) (Range, error) {
	root, err := msg.RootPtr()
	return Range{root.Struct()}, err
}

func (s Range) String() string {
	str, _ := text.Marshal(0x913361a0f4593621, s.Struct)
	return str
}

func (s Range) To() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Range) HasTo() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Range) SetTo(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTo sets the to field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Range) NewTo() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Range) From() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Range) HasFrom() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Range) SetFrom(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Range) NewFrom() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Range) ByStep() (NumberEval, error) {
	p, err := s.Struct.Ptr(2)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Range) HasByStep() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Range) SetByStep(v NumberEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewByStep sets the byStep field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Range) NewByStep() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// Range_List is a list of Range.
type Range_List struct{ capnp.List }

// NewRange creates a new list of Range.
func NewRange_List(s *capnp.Segment, sz int32) (Range_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return Range_List{l}, err
}

func (s Range_List) At(i int) Range { return Range{s.List.Struct(i)} }

func (s Range_List) Set(i int, v Range) error { return s.List.SetStruct(i, v.Struct) }

func (s Range_List) String() string {
	str, _ := text.MarshalList(0x913361a0f4593621, s.List)
	return str
}

// Range_Promise is a wrapper for a Range promised by a client call.
type Range_Promise struct{ *capnp.Pipeline }

func (p Range_Promise) Struct() (Range, error) {
	s, err := p.Pipeline.Struct()
	return Range{s}, err
}

func (p Range_Promise) To() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Range_Promise) From() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Range_Promise) ByStep() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type ReciprocalOf struct{ capnp.Struct }

// ReciprocalOf_TypeID is the unique identifier for the type ReciprocalOf.
const ReciprocalOf_TypeID = 0xecd304f72f38cb0a

func NewReciprocalOf(s *capnp.Segment) (ReciprocalOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ReciprocalOf{st}, err
}

func NewRootReciprocalOf(s *capnp.Segment) (ReciprocalOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ReciprocalOf{st}, err
}

func ReadRootReciprocalOf(msg *capnp.Message) (ReciprocalOf, error) {
	root, err := msg.RootPtr()
	return ReciprocalOf{root.Struct()}, err
}

func (s ReciprocalOf) String() string {
	str, _ := text.Marshal(0xecd304f72f38cb0a, s.Struct)
	return str
}

func (s ReciprocalOf) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s ReciprocalOf) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ReciprocalOf) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s ReciprocalOf) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ReciprocalOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s ReciprocalOf) HasObject() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ReciprocalOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s ReciprocalOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// ReciprocalOf_List is a list of ReciprocalOf.
type ReciprocalOf_List struct{ capnp.List }

// NewReciprocalOf creates a new list of ReciprocalOf.
func NewReciprocalOf_List(s *capnp.Segment, sz int32) (ReciprocalOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return ReciprocalOf_List{l}, err
}

func (s ReciprocalOf_List) At(i int) ReciprocalOf { return ReciprocalOf{s.List.Struct(i)} }

func (s ReciprocalOf_List) Set(i int, v ReciprocalOf) error { return s.List.SetStruct(i, v.Struct) }

func (s ReciprocalOf_List) String() string {
	str, _ := text.MarshalList(0xecd304f72f38cb0a, s.List)
	return str
}

// ReciprocalOf_Promise is a wrapper for a ReciprocalOf promised by a client call.
type ReciprocalOf_Promise struct{ *capnp.Pipeline }

func (p ReciprocalOf_Promise) Struct() (ReciprocalOf, error) {
	s, err := p.Pipeline.Struct()
	return ReciprocalOf{s}, err
}

func (p ReciprocalOf_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ReciprocalOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type ReciprocalsOf struct{ capnp.Struct }

// ReciprocalsOf_TypeID is the unique identifier for the type ReciprocalsOf.
const ReciprocalsOf_TypeID = 0xbae2b5f4144bea5e

func NewReciprocalsOf(s *capnp.Segment) (ReciprocalsOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ReciprocalsOf{st}, err
}

func NewRootReciprocalsOf(s *capnp.Segment) (ReciprocalsOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ReciprocalsOf{st}, err
}

func ReadRootReciprocalsOf(msg *capnp.Message) (ReciprocalsOf, error) {
	root, err := msg.RootPtr()
	return ReciprocalsOf{root.Struct()}, err
}

func (s ReciprocalsOf) String() string {
	str, _ := text.Marshal(0xbae2b5f4144bea5e, s.Struct)
	return str
}

func (s ReciprocalsOf) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s ReciprocalsOf) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ReciprocalsOf) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s ReciprocalsOf) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ReciprocalsOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s ReciprocalsOf) HasObject() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ReciprocalsOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s ReciprocalsOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// ReciprocalsOf_List is a list of ReciprocalsOf.
type ReciprocalsOf_List struct{ capnp.List }

// NewReciprocalsOf creates a new list of ReciprocalsOf.
func NewReciprocalsOf_List(s *capnp.Segment, sz int32) (ReciprocalsOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return ReciprocalsOf_List{l}, err
}

func (s ReciprocalsOf_List) At(i int) ReciprocalsOf { return ReciprocalsOf{s.List.Struct(i)} }

func (s ReciprocalsOf_List) Set(i int, v ReciprocalsOf) error { return s.List.SetStruct(i, v.Struct) }

func (s ReciprocalsOf_List) String() string {
	str, _ := text.MarshalList(0xbae2b5f4144bea5e, s.List)
	return str
}

// ReciprocalsOf_Promise is a wrapper for a ReciprocalsOf promised by a client call.
type ReciprocalsOf_Promise struct{ *capnp.Pipeline }

func (p ReciprocalsOf_Promise) Struct() (ReciprocalsOf, error) {
	s, err := p.Pipeline.Struct()
	return ReciprocalsOf{s}, err
}

func (p ReciprocalsOf_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p ReciprocalsOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Reduce struct{ capnp.Struct }

// Reduce_TypeID is the unique identifier for the type Reduce.
const Reduce_TypeID = 0xd5c886733e12e583

func NewReduce(s *capnp.Segment) (Reduce, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Reduce{st}, err
}

func NewRootReduce(s *capnp.Segment) (Reduce, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Reduce{st}, err
}

func ReadRootReduce(msg *capnp.Message) (Reduce, error) {
	root, err := msg.RootPtr()
	return Reduce{root.Struct()}, err
}

func (s Reduce) String() string {
	str, _ := text.Marshal(0xd5c886733e12e583, s.Struct)
	return str
}

func (s Reduce) IntoValue() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Reduce) HasIntoValue() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Reduce) SetIntoValue(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIntoValue sets the intoValue field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Reduce) NewIntoValue() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Reduce) FromList() (Assignment, error) {
	p, err := s.Struct.Ptr(1)
	return Assignment{Struct: p.Struct()}, err
}

func (s Reduce) HasFromList() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Reduce) SetFromList(v Assignment) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFromList sets the fromList field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Reduce) NewFromList() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Reduce) UsingPattern() (Text, error) {
	p, err := s.Struct.Ptr(2)
	return Text{Struct: p.Struct()}, err
}

func (s Reduce) HasUsingPattern() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Reduce) SetUsingPattern(v Text) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewUsingPattern sets the usingPattern field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Reduce) NewUsingPattern() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// Reduce_List is a list of Reduce.
type Reduce_List struct{ capnp.List }

// NewReduce creates a new list of Reduce.
func NewReduce_List(s *capnp.Segment, sz int32) (Reduce_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return Reduce_List{l}, err
}

func (s Reduce_List) At(i int) Reduce { return Reduce{s.List.Struct(i)} }

func (s Reduce_List) Set(i int, v Reduce) error { return s.List.SetStruct(i, v.Struct) }

func (s Reduce_List) String() string {
	str, _ := text.MarshalList(0xd5c886733e12e583, s.List)
	return str
}

// Reduce_Promise is a wrapper for a Reduce promised by a client call.
type Reduce_Promise struct{ *capnp.Pipeline }

func (p Reduce_Promise) Struct() (Reduce, error) {
	s, err := p.Pipeline.Struct()
	return Reduce{s}, err
}

func (p Reduce_Promise) IntoValue() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Reduce_Promise) FromList() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Reduce_Promise) UsingPattern() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type Relate struct{ capnp.Struct }

// Relate_TypeID is the unique identifier for the type Relate.
const Relate_TypeID = 0xbea9252308c2097c

func NewRelate(s *capnp.Segment) (Relate, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Relate{st}, err
}

func NewRootRelate(s *capnp.Segment) (Relate, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Relate{st}, err
}

func ReadRootRelate(msg *capnp.Message) (Relate, error) {
	root, err := msg.RootPtr()
	return Relate{root.Struct()}, err
}

func (s Relate) String() string {
	str, _ := text.Marshal(0xbea9252308c2097c, s.Struct)
	return str
}

func (s Relate) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s Relate) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Relate) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Relate) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Relate) ToObject() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s Relate) HasToObject() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Relate) SetToObject(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewToObject sets the toObject field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Relate) NewToObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Relate) Str() (Text, error) {
	p, err := s.Struct.Ptr(2)
	return Text{Struct: p.Struct()}, err
}

func (s Relate) HasStr() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Relate) SetStr(v Text) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Relate) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// Relate_List is a list of Relate.
type Relate_List struct{ capnp.List }

// NewRelate creates a new list of Relate.
func NewRelate_List(s *capnp.Segment, sz int32) (Relate_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return Relate_List{l}, err
}

func (s Relate_List) At(i int) Relate { return Relate{s.List.Struct(i)} }

func (s Relate_List) Set(i int, v Relate) error { return s.List.SetStruct(i, v.Struct) }

func (s Relate_List) String() string {
	str, _ := text.MarshalList(0xbea9252308c2097c, s.List)
	return str
}

// Relate_Promise is a wrapper for a Relate promised by a client call.
type Relate_Promise struct{ *capnp.Pipeline }

func (p Relate_Promise) Struct() (Relate, error) {
	s, err := p.Pipeline.Struct()
	return Relate{s}, err
}

func (p Relate_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Relate_Promise) ToObject() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Relate_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type Relation struct{ capnp.Struct }

// Relation_TypeID is the unique identifier for the type Relation.
const Relation_TypeID = 0xa47541b906ccf227

func NewRelation(s *capnp.Segment) (Relation, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Relation{st}, err
}

func NewRootRelation(s *capnp.Segment) (Relation, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Relation{st}, err
}

func ReadRootRelation(msg *capnp.Message) (Relation, error) {
	root, err := msg.RootPtr()
	return Relation{root.Struct()}, err
}

func (s Relation) String() string {
	str, _ := text.Marshal(0xa47541b906ccf227, s.Struct)
	return str
}

func (s Relation) At() (Pos, error) {
	p, err := s.Struct.Ptr(0)
	return Pos{Struct: p.Struct()}, err
}

func (s Relation) HasAt() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Relation) SetAt(v Pos) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAt sets the at field to a newly
// allocated Pos struct, preferring placement in s's segment.
func (s Relation) NewAt() (Pos, error) {
	ss, err := NewPos(s.Struct.Segment())
	if err != nil {
		return Pos{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Relation) Str() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s Relation) HasStr() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Relation) SetStr(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Relation) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Relation_List is a list of Relation.
type Relation_List struct{ capnp.List }

// NewRelation creates a new list of Relation.
func NewRelation_List(s *capnp.Segment, sz int32) (Relation_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Relation_List{l}, err
}

func (s Relation_List) At(i int) Relation { return Relation{s.List.Struct(i)} }

func (s Relation_List) Set(i int, v Relation) error { return s.List.SetStruct(i, v.Struct) }

func (s Relation_List) String() string {
	str, _ := text.MarshalList(0xa47541b906ccf227, s.List)
	return str
}

// Relation_Promise is a wrapper for a Relation promised by a client call.
type Relation_Promise struct{ *capnp.Pipeline }

func (p Relation_Promise) Struct() (Relation, error) {
	s, err := p.Pipeline.Struct()
	return Relation{s}, err
}

func (p Relation_Promise) At() Pos_Promise {
	return Pos_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Relation_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type RelativeOf struct{ capnp.Struct }

// RelativeOf_TypeID is the unique identifier for the type RelativeOf.
const RelativeOf_TypeID = 0xa2c12387213209e8

func NewRelativeOf(s *capnp.Segment) (RelativeOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RelativeOf{st}, err
}

func NewRootRelativeOf(s *capnp.Segment) (RelativeOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RelativeOf{st}, err
}

func ReadRootRelativeOf(msg *capnp.Message) (RelativeOf, error) {
	root, err := msg.RootPtr()
	return RelativeOf{root.Struct()}, err
}

func (s RelativeOf) String() string {
	str, _ := text.Marshal(0xa2c12387213209e8, s.Struct)
	return str
}

func (s RelativeOf) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s RelativeOf) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RelativeOf) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s RelativeOf) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RelativeOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s RelativeOf) HasObject() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s RelativeOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s RelativeOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// RelativeOf_List is a list of RelativeOf.
type RelativeOf_List struct{ capnp.List }

// NewRelativeOf creates a new list of RelativeOf.
func NewRelativeOf_List(s *capnp.Segment, sz int32) (RelativeOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return RelativeOf_List{l}, err
}

func (s RelativeOf_List) At(i int) RelativeOf { return RelativeOf{s.List.Struct(i)} }

func (s RelativeOf_List) Set(i int, v RelativeOf) error { return s.List.SetStruct(i, v.Struct) }

func (s RelativeOf_List) String() string {
	str, _ := text.MarshalList(0xa2c12387213209e8, s.List)
	return str
}

// RelativeOf_Promise is a wrapper for a RelativeOf promised by a client call.
type RelativeOf_Promise struct{ *capnp.Pipeline }

func (p RelativeOf_Promise) Struct() (RelativeOf, error) {
	s, err := p.Pipeline.Struct()
	return RelativeOf{s}, err
}

func (p RelativeOf_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RelativeOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type RelativesOf struct{ capnp.Struct }

// RelativesOf_TypeID is the unique identifier for the type RelativesOf.
const RelativesOf_TypeID = 0xd4e14b7df75f90bf

func NewRelativesOf(s *capnp.Segment) (RelativesOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RelativesOf{st}, err
}

func NewRootRelativesOf(s *capnp.Segment) (RelativesOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RelativesOf{st}, err
}

func ReadRootRelativesOf(msg *capnp.Message) (RelativesOf, error) {
	root, err := msg.RootPtr()
	return RelativesOf{root.Struct()}, err
}

func (s RelativesOf) String() string {
	str, _ := text.Marshal(0xd4e14b7df75f90bf, s.Struct)
	return str
}

func (s RelativesOf) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s RelativesOf) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RelativesOf) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s RelativesOf) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RelativesOf) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s RelativesOf) HasObject() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s RelativesOf) SetObject(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s RelativesOf) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// RelativesOf_List is a list of RelativesOf.
type RelativesOf_List struct{ capnp.List }

// NewRelativesOf creates a new list of RelativesOf.
func NewRelativesOf_List(s *capnp.Segment, sz int32) (RelativesOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return RelativesOf_List{l}, err
}

func (s RelativesOf_List) At(i int) RelativesOf { return RelativesOf{s.List.Struct(i)} }

func (s RelativesOf_List) Set(i int, v RelativesOf) error { return s.List.SetStruct(i, v.Struct) }

func (s RelativesOf_List) String() string {
	str, _ := text.MarshalList(0xd4e14b7df75f90bf, s.List)
	return str
}

// RelativesOf_Promise is a wrapper for a RelativesOf promised by a client call.
type RelativesOf_Promise struct{ *capnp.Pipeline }

func (p RelativesOf_Promise) Struct() (RelativesOf, error) {
	s, err := p.Pipeline.Struct()
	return RelativesOf{s}, err
}

func (p RelativesOf_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RelativesOf_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type RemainderOf struct{ capnp.Struct }

// RemainderOf_TypeID is the unique identifier for the type RemainderOf.
const RemainderOf_TypeID = 0x97c95c24dd75b690

func NewRemainderOf(s *capnp.Segment) (RemainderOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RemainderOf{st}, err
}

func NewRootRemainderOf(s *capnp.Segment) (RemainderOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RemainderOf{st}, err
}

func ReadRootRemainderOf(msg *capnp.Message) (RemainderOf, error) {
	root, err := msg.RootPtr()
	return RemainderOf{root.Struct()}, err
}

func (s RemainderOf) String() string {
	str, _ := text.Marshal(0x97c95c24dd75b690, s.Struct)
	return str
}

func (s RemainderOf) A() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s RemainderOf) HasA() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RemainderOf) SetA(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA sets the a field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s RemainderOf) NewA() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RemainderOf) B() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s RemainderOf) HasB() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s RemainderOf) SetB(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewB sets the b field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s RemainderOf) NewB() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// RemainderOf_List is a list of RemainderOf.
type RemainderOf_List struct{ capnp.List }

// NewRemainderOf creates a new list of RemainderOf.
func NewRemainderOf_List(s *capnp.Segment, sz int32) (RemainderOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return RemainderOf_List{l}, err
}

func (s RemainderOf_List) At(i int) RemainderOf { return RemainderOf{s.List.Struct(i)} }

func (s RemainderOf_List) Set(i int, v RemainderOf) error { return s.List.SetStruct(i, v.Struct) }

func (s RemainderOf_List) String() string {
	str, _ := text.MarshalList(0x97c95c24dd75b690, s.List)
	return str
}

// RemainderOf_Promise is a wrapper for a RemainderOf promised by a client call.
type RemainderOf_Promise struct{ *capnp.Pipeline }

func (p RemainderOf_Promise) Struct() (RemainderOf, error) {
	s, err := p.Pipeline.Struct()
	return RemainderOf{s}, err
}

func (p RemainderOf_Promise) A() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p RemainderOf_Promise) B() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type RenderField struct{ capnp.Struct }

// RenderField_TypeID is the unique identifier for the type RenderField.
const RenderField_TypeID = 0xcd070939f32ea1ab

func NewRenderField(s *capnp.Segment) (RenderField, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RenderField{st}, err
}

func NewRootRenderField(s *capnp.Segment) (RenderField, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RenderField{st}, err
}

func ReadRootRenderField(msg *capnp.Message) (RenderField, error) {
	root, err := msg.RootPtr()
	return RenderField{root.Struct()}, err
}

func (s RenderField) String() string {
	str, _ := text.Marshal(0xcd070939f32ea1ab, s.Struct)
	return str
}

func (s RenderField) Name() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s RenderField) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RenderField) SetName(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s RenderField) NewName() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// RenderField_List is a list of RenderField.
type RenderField_List struct{ capnp.List }

// NewRenderField creates a new list of RenderField.
func NewRenderField_List(s *capnp.Segment, sz int32) (RenderField_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return RenderField_List{l}, err
}

func (s RenderField_List) At(i int) RenderField { return RenderField{s.List.Struct(i)} }

func (s RenderField_List) Set(i int, v RenderField) error { return s.List.SetStruct(i, v.Struct) }

func (s RenderField_List) String() string {
	str, _ := text.MarshalList(0xcd070939f32ea1ab, s.List)
	return str
}

// RenderField_Promise is a wrapper for a RenderField promised by a client call.
type RenderField_Promise struct{ *capnp.Pipeline }

func (p RenderField_Promise) Struct() (RenderField, error) {
	s, err := p.Pipeline.Struct()
	return RenderField{s}, err
}

func (p RenderField_Promise) Name() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type RenderName struct{ capnp.Struct }

// RenderName_TypeID is the unique identifier for the type RenderName.
const RenderName_TypeID = 0xa69d1ce67d31139a

func NewRenderName(s *capnp.Segment) (RenderName, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RenderName{st}, err
}

func NewRootRenderName(s *capnp.Segment) (RenderName, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RenderName{st}, err
}

func ReadRootRenderName(msg *capnp.Message) (RenderName, error) {
	root, err := msg.RootPtr()
	return RenderName{root.Struct()}, err
}

func (s RenderName) String() string {
	str, _ := text.Marshal(0xa69d1ce67d31139a, s.Struct)
	return str
}

func (s RenderName) Name() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s RenderName) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RenderName) SetName(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s RenderName) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// RenderName_List is a list of RenderName.
type RenderName_List struct{ capnp.List }

// NewRenderName creates a new list of RenderName.
func NewRenderName_List(s *capnp.Segment, sz int32) (RenderName_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return RenderName_List{l}, err
}

func (s RenderName_List) At(i int) RenderName { return RenderName{s.List.Struct(i)} }

func (s RenderName_List) Set(i int, v RenderName) error { return s.List.SetStruct(i, v.Struct) }

func (s RenderName_List) String() string {
	str, _ := text.MarshalList(0xa69d1ce67d31139a, s.List)
	return str
}

// RenderName_Promise is a wrapper for a RenderName promised by a client call.
type RenderName_Promise struct{ *capnp.Pipeline }

func (p RenderName_Promise) Struct() (RenderName, error) {
	s, err := p.Pipeline.Struct()
	return RenderName{s}, err
}

func (p RenderName_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type RenderPattern struct{ capnp.Struct }

// RenderPattern_TypeID is the unique identifier for the type RenderPattern.
const RenderPattern_TypeID = 0xf817fc4ee27b3949

func NewRenderPattern(s *capnp.Segment) (RenderPattern, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RenderPattern{st}, err
}

func NewRootRenderPattern(s *capnp.Segment) (RenderPattern, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return RenderPattern{st}, err
}

func ReadRootRenderPattern(msg *capnp.Message) (RenderPattern, error) {
	root, err := msg.RootPtr()
	return RenderPattern{root.Struct()}, err
}

func (s RenderPattern) String() string {
	str, _ := text.Marshal(0xf817fc4ee27b3949, s.Struct)
	return str
}

func (s RenderPattern) Pattern() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s RenderPattern) HasPattern() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RenderPattern) SetPattern(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPattern sets the pattern field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s RenderPattern) NewPattern() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RenderPattern) Args() (Argument_List, error) {
	p, err := s.Struct.Ptr(1)
	return Argument_List{List: p.List()}, err
}

func (s RenderPattern) HasArgs() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s RenderPattern) SetArgs(v Argument_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated Argument_List, preferring placement in s's segment.
func (s RenderPattern) NewArgs(n int32) (Argument_List, error) {
	l, err := NewArgument_List(s.Struct.Segment(), n)
	if err != nil {
		return Argument_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// RenderPattern_List is a list of RenderPattern.
type RenderPattern_List struct{ capnp.List }

// NewRenderPattern creates a new list of RenderPattern.
func NewRenderPattern_List(s *capnp.Segment, sz int32) (RenderPattern_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return RenderPattern_List{l}, err
}

func (s RenderPattern_List) At(i int) RenderPattern { return RenderPattern{s.List.Struct(i)} }

func (s RenderPattern_List) Set(i int, v RenderPattern) error { return s.List.SetStruct(i, v.Struct) }

func (s RenderPattern_List) String() string {
	str, _ := text.MarshalList(0xf817fc4ee27b3949, s.List)
	return str
}

// RenderPattern_Promise is a wrapper for a RenderPattern promised by a client call.
type RenderPattern_Promise struct{ *capnp.Pipeline }

func (p RenderPattern_Promise) Struct() (RenderPattern, error) {
	s, err := p.Pipeline.Struct()
	return RenderPattern{s}, err
}

func (p RenderPattern_Promise) Pattern() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type RenderRef struct{ capnp.Struct }

// RenderRef_TypeID is the unique identifier for the type RenderRef.
const RenderRef_TypeID = 0xdd36d3abe50e003c

func NewRenderRef(s *capnp.Segment) (RenderRef, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RenderRef{st}, err
}

func NewRootRenderRef(s *capnp.Segment) (RenderRef, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return RenderRef{st}, err
}

func ReadRootRenderRef(msg *capnp.Message) (RenderRef, error) {
	root, err := msg.RootPtr()
	return RenderRef{root.Struct()}, err
}

func (s RenderRef) String() string {
	str, _ := text.Marshal(0xdd36d3abe50e003c, s.Struct)
	return str
}

func (s RenderRef) Name() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s RenderRef) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RenderRef) SetName(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s RenderRef) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s RenderRef) Flags() int32 {
	return int32(s.Struct.Uint32(0))
}

func (s RenderRef) SetFlags(v int32) {
	s.Struct.SetUint32(0, uint32(v))
}

// RenderRef_List is a list of RenderRef.
type RenderRef_List struct{ capnp.List }

// NewRenderRef creates a new list of RenderRef.
func NewRenderRef_List(s *capnp.Segment, sz int32) (RenderRef_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return RenderRef_List{l}, err
}

func (s RenderRef_List) At(i int) RenderRef { return RenderRef{s.List.Struct(i)} }

func (s RenderRef_List) Set(i int, v RenderRef) error { return s.List.SetStruct(i, v.Struct) }

func (s RenderRef_List) String() string {
	str, _ := text.MarshalList(0xdd36d3abe50e003c, s.List)
	return str
}

// RenderRef_Promise is a wrapper for a RenderRef promised by a client call.
type RenderRef_Promise struct{ *capnp.Pipeline }

func (p RenderRef_Promise) Struct() (RenderRef, error) {
	s, err := p.Pipeline.Struct()
	return RenderRef{s}, err
}

func (p RenderRef_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type RenderTemplate struct{ capnp.Struct }

// RenderTemplate_TypeID is the unique identifier for the type RenderTemplate.
const RenderTemplate_TypeID = 0xf93eb8c639ed3031

func NewRenderTemplate(s *capnp.Segment) (RenderTemplate, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RenderTemplate{st}, err
}

func NewRootRenderTemplate(s *capnp.Segment) (RenderTemplate, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RenderTemplate{st}, err
}

func ReadRootRenderTemplate(msg *capnp.Message) (RenderTemplate, error) {
	root, err := msg.RootPtr()
	return RenderTemplate{root.Struct()}, err
}

func (s RenderTemplate) String() string {
	str, _ := text.Marshal(0xf93eb8c639ed3031, s.Struct)
	return str
}

func (s RenderTemplate) Expression() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s RenderTemplate) HasExpression() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s RenderTemplate) SetExpression(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewExpression sets the expression field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s RenderTemplate) NewExpression() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// RenderTemplate_List is a list of RenderTemplate.
type RenderTemplate_List struct{ capnp.List }

// NewRenderTemplate creates a new list of RenderTemplate.
func NewRenderTemplate_List(s *capnp.Segment, sz int32) (RenderTemplate_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return RenderTemplate_List{l}, err
}

func (s RenderTemplate_List) At(i int) RenderTemplate { return RenderTemplate{s.List.Struct(i)} }

func (s RenderTemplate_List) Set(i int, v RenderTemplate) error { return s.List.SetStruct(i, v.Struct) }

func (s RenderTemplate_List) String() string {
	str, _ := text.MarshalList(0xf93eb8c639ed3031, s.List)
	return str
}

// RenderTemplate_Promise is a wrapper for a RenderTemplate promised by a client call.
type RenderTemplate_Promise struct{ *capnp.Pipeline }

func (p RenderTemplate_Promise) Struct() (RenderTemplate, error) {
	s, err := p.Pipeline.Struct()
	return RenderTemplate{s}, err
}

func (p RenderTemplate_Promise) Expression() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Response struct{ capnp.Struct }

// Response_TypeID is the unique identifier for the type Response.
const Response_TypeID = 0xae341bdc736ba6c8

func NewResponse(s *capnp.Segment) (Response, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Response{st}, err
}

func NewRootResponse(s *capnp.Segment) (Response, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Response{st}, err
}

func ReadRootResponse(msg *capnp.Message) (Response, error) {
	root, err := msg.RootPtr()
	return Response{root.Struct()}, err
}

func (s Response) String() string {
	str, _ := text.Marshal(0xae341bdc736ba6c8, s.Struct)
	return str
}

func (s Response) Name() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Response) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Response) SetName(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Response) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Response) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s Response) HasText() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Response) SetText(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Response) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Response_List is a list of Response.
type Response_List struct{ capnp.List }

// NewResponse creates a new list of Response.
func NewResponse_List(s *capnp.Segment, sz int32) (Response_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Response_List{l}, err
}

func (s Response_List) At(i int) Response { return Response{s.List.Struct(i)} }

func (s Response_List) Set(i int, v Response) error { return s.List.SetStruct(i, v.Struct) }

func (s Response_List) String() string {
	str, _ := text.MarshalList(0xae341bdc736ba6c8, s.List)
	return str
}

// Response_Promise is a wrapper for a Response promised by a client call.
type Response_Promise struct{ *capnp.Pipeline }

func (p Response_Promise) Struct() (Response, error) {
	s, err := p.Pipeline.Struct()
	return Response{s}, err
}

func (p Response_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Response_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Retarget struct{ capnp.Struct }

// Retarget_TypeID is the unique identifier for the type Retarget.
const Retarget_TypeID = 0x84abbf67ae1d8745

func NewRetarget(s *capnp.Segment) (Retarget, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Retarget{st}, err
}

func NewRootRetarget(s *capnp.Segment) (Retarget, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Retarget{st}, err
}

func ReadRootRetarget(msg *capnp.Message) (Retarget, error) {
	root, err := msg.RootPtr()
	return Retarget{root.Struct()}, err
}

func (s Retarget) String() string {
	str, _ := text.Marshal(0x84abbf67ae1d8745, s.Struct)
	return str
}

func (s Retarget) Span() (ScannerMaker_List, error) {
	p, err := s.Struct.Ptr(0)
	return ScannerMaker_List{List: p.List()}, err
}

func (s Retarget) HasSpan() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Retarget) SetSpan(v ScannerMaker_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewSpan sets the span field to a newly
// allocated ScannerMaker_List, preferring placement in s's segment.
func (s Retarget) NewSpan(n int32) (ScannerMaker_List, error) {
	l, err := NewScannerMaker_List(s.Struct.Segment(), n)
	if err != nil {
		return ScannerMaker_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Retarget_List is a list of Retarget.
type Retarget_List struct{ capnp.List }

// NewRetarget creates a new list of Retarget.
func NewRetarget_List(s *capnp.Segment, sz int32) (Retarget_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Retarget_List{l}, err
}

func (s Retarget_List) At(i int) Retarget { return Retarget{s.List.Struct(i)} }

func (s Retarget_List) Set(i int, v Retarget) error { return s.List.SetStruct(i, v.Struct) }

func (s Retarget_List) String() string {
	str, _ := text.MarshalList(0x84abbf67ae1d8745, s.List)
	return str
}

// Retarget_Promise is a wrapper for a Retarget promised by a client call.
type Retarget_Promise struct{ *capnp.Pipeline }

func (p Retarget_Promise) Struct() (Retarget, error) {
	s, err := p.Pipeline.Struct()
	return Retarget{s}, err
}

type Reverse struct{ capnp.Struct }

// Reverse_TypeID is the unique identifier for the type Reverse.
const Reverse_TypeID = 0xa11b8168f91d22ba

func NewReverse(s *capnp.Segment) (Reverse, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Reverse{st}, err
}

func NewRootReverse(s *capnp.Segment) (Reverse, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Reverse{st}, err
}

func ReadRootReverse(msg *capnp.Message) (Reverse, error) {
	root, err := msg.RootPtr()
	return Reverse{root.Struct()}, err
}

func (s Reverse) String() string {
	str, _ := text.Marshal(0xa11b8168f91d22ba, s.Struct)
	return str
}

func (s Reverse) Reverses() (ScannerMaker_List, error) {
	p, err := s.Struct.Ptr(0)
	return ScannerMaker_List{List: p.List()}, err
}

func (s Reverse) HasReverses() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Reverse) SetReverses(v ScannerMaker_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewReverses sets the reverses field to a newly
// allocated ScannerMaker_List, preferring placement in s's segment.
func (s Reverse) NewReverses(n int32) (ScannerMaker_List, error) {
	l, err := NewScannerMaker_List(s.Struct.Segment(), n)
	if err != nil {
		return ScannerMaker_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Reverse_List is a list of Reverse.
type Reverse_List struct{ capnp.List }

// NewReverse creates a new list of Reverse.
func NewReverse_List(s *capnp.Segment, sz int32) (Reverse_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Reverse_List{l}, err
}

func (s Reverse_List) At(i int) Reverse { return Reverse{s.List.Struct(i)} }

func (s Reverse_List) Set(i int, v Reverse) error { return s.List.SetStruct(i, v.Struct) }

func (s Reverse_List) String() string {
	str, _ := text.MarshalList(0xa11b8168f91d22ba, s.List)
	return str
}

// Reverse_Promise is a wrapper for a Reverse promised by a client call.
type Reverse_Promise struct{ *capnp.Pipeline }

func (p Reverse_Promise) Struct() (Reverse, error) {
	s, err := p.Pipeline.Struct()
	return Reverse{s}, err
}

type ReverseList struct{ capnp.Struct }

// ReverseList_TypeID is the unique identifier for the type ReverseList.
const ReverseList_TypeID = 0xd780fa78ccd503a1

func NewReverseList(s *capnp.Segment) (ReverseList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ReverseList{st}, err
}

func NewRootReverseList(s *capnp.Segment) (ReverseList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ReverseList{st}, err
}

func ReadRootReverseList(msg *capnp.Message) (ReverseList, error) {
	root, err := msg.RootPtr()
	return ReverseList{root.Struct()}, err
}

func (s ReverseList) String() string {
	str, _ := text.Marshal(0xd780fa78ccd503a1, s.Struct)
	return str
}

func (s ReverseList) List() (ListSource, error) {
	p, err := s.Struct.Ptr(0)
	return ListSource{Struct: p.Struct()}, err
}

func (s ReverseList) HasList() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ReverseList) SetList(v ListSource) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewList sets the list field to a newly
// allocated ListSource struct, preferring placement in s's segment.
func (s ReverseList) NewList() (ListSource, error) {
	ss, err := NewListSource(s.Struct.Segment())
	if err != nil {
		return ListSource{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// ReverseList_List is a list of ReverseList.
type ReverseList_List struct{ capnp.List }

// NewReverseList creates a new list of ReverseList.
func NewReverseList_List(s *capnp.Segment, sz int32) (ReverseList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return ReverseList_List{l}, err
}

func (s ReverseList_List) At(i int) ReverseList { return ReverseList{s.List.Struct(i)} }

func (s ReverseList_List) Set(i int, v ReverseList) error { return s.List.SetStruct(i, v.Struct) }

func (s ReverseList_List) String() string {
	str, _ := text.MarshalList(0xd780fa78ccd503a1, s.List)
	return str
}

// ReverseList_Promise is a wrapper for a ReverseList promised by a client call.
type ReverseList_Promise struct{ *capnp.Pipeline }

func (p ReverseList_Promise) Struct() (ReverseList, error) {
	s, err := p.Pipeline.Struct()
	return ReverseList{s}, err
}

func (p ReverseList_Promise) List() ListSource_Promise {
	return ListSource_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Row struct{ capnp.Struct }

// Row_TypeID is the unique identifier for the type Row.
const Row_TypeID = 0xe224310cc9d07716

func NewRow(s *capnp.Segment) (Row, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Row{st}, err
}

func NewRootRow(s *capnp.Segment) (Row, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Row{st}, err
}

func ReadRootRow(msg *capnp.Message) (Row, error) {
	root, err := msg.RootPtr()
	return Row{root.Struct()}, err
}

func (s Row) String() string {
	str, _ := text.Marshal(0xe224310cc9d07716, s.Struct)
	return str
}

func (s Row) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s Row) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Row) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Row) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Row_List is a list of Row.
type Row_List struct{ capnp.List }

// NewRow creates a new list of Row.
func NewRow_List(s *capnp.Segment, sz int32) (Row_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Row_List{l}, err
}

func (s Row_List) At(i int) Row { return Row{s.List.Struct(i)} }

func (s Row_List) Set(i int, v Row) error { return s.List.SetStruct(i, v.Struct) }

func (s Row_List) String() string {
	str, _ := text.MarshalList(0xe224310cc9d07716, s.List)
	return str
}

// Row_Promise is a wrapper for a Row promised by a client call.
type Row_Promise struct{ *capnp.Pipeline }

func (p Row_Promise) Struct() (Row, error) {
	s, err := p.Pipeline.Struct()
	return Row{s}, err
}

type Rows struct{ capnp.Struct }

// Rows_TypeID is the unique identifier for the type Rows.
const Rows_TypeID = 0xe298d5560d485180

func NewRows(s *capnp.Segment) (Rows, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Rows{st}, err
}

func NewRootRows(s *capnp.Segment) (Rows, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Rows{st}, err
}

func ReadRootRows(msg *capnp.Message) (Rows, error) {
	root, err := msg.RootPtr()
	return Rows{root.Struct()}, err
}

func (s Rows) String() string {
	str, _ := text.Marshal(0xe298d5560d485180, s.Struct)
	return str
}

func (s Rows) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s Rows) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Rows) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Rows) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Rows_List is a list of Rows.
type Rows_List struct{ capnp.List }

// NewRows creates a new list of Rows.
func NewRows_List(s *capnp.Segment, sz int32) (Rows_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Rows_List{l}, err
}

func (s Rows_List) At(i int) Rows { return Rows{s.List.Struct(i)} }

func (s Rows_List) Set(i int, v Rows) error { return s.List.SetStruct(i, v.Struct) }

func (s Rows_List) String() string {
	str, _ := text.MarshalList(0xe298d5560d485180, s.List)
	return str
}

// Rows_Promise is a wrapper for a Rows promised by a client call.
type Rows_Promise struct{ *capnp.Pipeline }

func (p Rows_Promise) Struct() (Rows, error) {
	s, err := p.Pipeline.Struct()
	return Rows{s}, err
}

type Say struct{ capnp.Struct }

// Say_TypeID is the unique identifier for the type Say.
const Say_TypeID = 0xa1569a83b42c81a0

func NewSay(s *capnp.Segment) (Say, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Say{st}, err
}

func NewRootSay(s *capnp.Segment) (Say, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Say{st}, err
}

func ReadRootSay(msg *capnp.Message) (Say, error) {
	root, err := msg.RootPtr()
	return Say{root.Struct()}, err
}

func (s Say) String() string {
	str, _ := text.Marshal(0xa1569a83b42c81a0, s.Struct)
	return str
}

func (s Say) Text() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s Say) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Say) SetText(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s Say) NewText() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Say_List is a list of Say.
type Say_List struct{ capnp.List }

// NewSay creates a new list of Say.
func NewSay_List(s *capnp.Segment, sz int32) (Say_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Say_List{l}, err
}

func (s Say_List) At(i int) Say { return Say{s.List.Struct(i)} }

func (s Say_List) Set(i int, v Say) error { return s.List.SetStruct(i, v.Struct) }

func (s Say_List) String() string {
	str, _ := text.MarshalList(0xa1569a83b42c81a0, s.List)
	return str
}

// Say_Promise is a wrapper for a Say promised by a client call.
type Say_Promise struct{ *capnp.Pipeline }

func (p Say_Promise) Struct() (Say, error) {
	s, err := p.Pipeline.Struct()
	return Say{s}, err
}

func (p Say_Promise) Text() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Self struct{ capnp.Struct }

// Self_TypeID is the unique identifier for the type Self.
const Self_TypeID = 0xe30d72961ee4eaef

func NewSelf(s *capnp.Segment) (Self, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Self{st}, err
}

func NewRootSelf(s *capnp.Segment) (Self, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Self{st}, err
}

func ReadRootSelf(msg *capnp.Message) (Self, error) {
	root, err := msg.RootPtr()
	return Self{root.Struct()}, err
}

func (s Self) String() string {
	str, _ := text.Marshal(0xe30d72961ee4eaef, s.Struct)
	return str
}

func (s Self) Player() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Self) HasPlayer() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Self) SetPlayer(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPlayer sets the player field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Self) NewPlayer() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Self_List is a list of Self.
type Self_List struct{ capnp.List }

// NewSelf creates a new list of Self.
func NewSelf_List(s *capnp.Segment, sz int32) (Self_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Self_List{l}, err
}

func (s Self_List) At(i int) Self { return Self{s.List.Struct(i)} }

func (s Self_List) Set(i int, v Self) error { return s.List.SetStruct(i, v.Struct) }

func (s Self_List) String() string {
	str, _ := text.MarshalList(0xe30d72961ee4eaef, s.List)
	return str
}

// Self_Promise is a wrapper for a Self promised by a client call.
type Self_Promise struct{ *capnp.Pipeline }

func (p Self_Promise) Struct() (Self, error) {
	s, err := p.Pipeline.Struct()
	return Self{s}, err
}

func (p Self_Promise) Player() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Send struct{ capnp.Struct }

// Send_TypeID is the unique identifier for the type Send.
const Send_TypeID = 0x854220714e20cf36

func NewSend(s *capnp.Segment) (Send, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Send{st}, err
}

func NewRootSend(s *capnp.Segment) (Send, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Send{st}, err
}

func ReadRootSend(msg *capnp.Message) (Send, error) {
	root, err := msg.RootPtr()
	return Send{root.Struct()}, err
}

func (s Send) String() string {
	str, _ := text.Marshal(0x854220714e20cf36, s.Struct)
	return str
}

func (s Send) Event() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Send) HasEvent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Send) SetEvent(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewEvent sets the event field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Send) NewEvent() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Send) Path() (TextListEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextListEval{Struct: p.Struct()}, err
}

func (s Send) HasPath() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Send) SetPath(v TextListEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewPath sets the path field to a newly
// allocated TextListEval struct, preferring placement in s's segment.
func (s Send) NewPath() (TextListEval, error) {
	ss, err := NewTextListEval(s.Struct.Segment())
	if err != nil {
		return TextListEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Send) Args() (Argument_List, error) {
	p, err := s.Struct.Ptr(2)
	return Argument_List{List: p.List()}, err
}

func (s Send) HasArgs() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Send) SetArgs(v Argument_List) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated Argument_List, preferring placement in s's segment.
func (s Send) NewArgs(n int32) (Argument_List, error) {
	l, err := NewArgument_List(s.Struct.Segment(), n)
	if err != nil {
		return Argument_List{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

// Send_List is a list of Send.
type Send_List struct{ capnp.List }

// NewSend creates a new list of Send.
func NewSend_List(s *capnp.Segment, sz int32) (Send_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return Send_List{l}, err
}

func (s Send_List) At(i int) Send { return Send{s.List.Struct(i)} }

func (s Send_List) Set(i int, v Send) error { return s.List.SetStruct(i, v.Struct) }

func (s Send_List) String() string {
	str, _ := text.MarshalList(0x854220714e20cf36, s.List)
	return str
}

// Send_Promise is a wrapper for a Send promised by a client call.
type Send_Promise struct{ *capnp.Pipeline }

func (p Send_Promise) Struct() (Send, error) {
	s, err := p.Pipeline.Struct()
	return Send{s}, err
}

func (p Send_Promise) Event() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Send_Promise) Path() TextListEval_Promise {
	return TextListEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Set struct{ capnp.Struct }

// Set_TypeID is the unique identifier for the type Set.
const Set_TypeID = 0xb1e14346fdd689e0

func NewSet(s *capnp.Segment) (Set, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Set{st}, err
}

func NewRootSet(s *capnp.Segment) (Set, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Set{st}, err
}

func ReadRootSet(msg *capnp.Message) (Set, error) {
	root, err := msg.RootPtr()
	return Set{root.Struct()}, err
}

func (s Set) String() string {
	str, _ := text.Marshal(0xb1e14346fdd689e0, s.Struct)
	return str
}

func (s Set) List() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Set) HasList() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Set) SetList(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewList sets the list field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Set) NewList() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Set) Index() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Set) HasIndex() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Set) SetIndex(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewIndex sets the index field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Set) NewIndex() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Set) From() (Assignment, error) {
	p, err := s.Struct.Ptr(2)
	return Assignment{Struct: p.Struct()}, err
}

func (s Set) HasFrom() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Set) SetFrom(v Assignment) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewFrom sets the from field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Set) NewFrom() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// Set_List is a list of Set.
type Set_List struct{ capnp.List }

// NewSet creates a new list of Set.
func NewSet_List(s *capnp.Segment, sz int32) (Set_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return Set_List{l}, err
}

func (s Set_List) At(i int) Set { return Set{s.List.Struct(i)} }

func (s Set_List) Set(i int, v Set) error { return s.List.SetStruct(i, v.Struct) }

func (s Set_List) String() string {
	str, _ := text.MarshalList(0xb1e14346fdd689e0, s.List)
	return str
}

// Set_Promise is a wrapper for a Set promised by a client call.
type Set_Promise struct{ *capnp.Pipeline }

func (p Set_Promise) Struct() (Set, error) {
	s, err := p.Pipeline.Struct()
	return Set{s}, err
}

func (p Set_Promise) List() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Set_Promise) Index() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Set_Promise) From() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type SetTrait struct{ capnp.Struct }

// SetTrait_TypeID is the unique identifier for the type SetTrait.
const SetTrait_TypeID = 0x8b79c6e49242c134

func NewSetTrait(s *capnp.Segment) (SetTrait, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SetTrait{st}, err
}

func NewRootSetTrait(s *capnp.Segment) (SetTrait, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SetTrait{st}, err
}

func ReadRootSetTrait(msg *capnp.Message) (SetTrait, error) {
	root, err := msg.RootPtr()
	return SetTrait{root.Struct()}, err
}

func (s SetTrait) String() string {
	str, _ := text.Marshal(0x8b79c6e49242c134, s.Struct)
	return str
}

func (s SetTrait) Object() (TextEval, error) {
	p, err := s.Struct.Ptr(0)
	return TextEval{Struct: p.Struct()}, err
}

func (s SetTrait) HasObject() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s SetTrait) SetObject(v TextEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewObject sets the object field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s SetTrait) NewObject() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s SetTrait) Trait() (TextEval, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval{Struct: p.Struct()}, err
}

func (s SetTrait) HasTrait() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s SetTrait) SetTrait(v TextEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewTrait sets the trait field to a newly
// allocated TextEval struct, preferring placement in s's segment.
func (s SetTrait) NewTrait() (TextEval, error) {
	ss, err := NewTextEval(s.Struct.Segment())
	if err != nil {
		return TextEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// SetTrait_List is a list of SetTrait.
type SetTrait_List struct{ capnp.List }

// NewSetTrait creates a new list of SetTrait.
func NewSetTrait_List(s *capnp.Segment, sz int32) (SetTrait_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return SetTrait_List{l}, err
}

func (s SetTrait_List) At(i int) SetTrait { return SetTrait{s.List.Struct(i)} }

func (s SetTrait_List) Set(i int, v SetTrait) error { return s.List.SetStruct(i, v.Struct) }

func (s SetTrait_List) String() string {
	str, _ := text.MarshalList(0x8b79c6e49242c134, s.List)
	return str
}

// SetTrait_Promise is a wrapper for a SetTrait promised by a client call.
type SetTrait_Promise struct{ *capnp.Pipeline }

func (p SetTrait_Promise) Struct() (SetTrait, error) {
	s, err := p.Pipeline.Struct()
	return SetTrait{s}, err
}

func (p SetTrait_Promise) Object() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p SetTrait_Promise) Trait() TextEval_Promise {
	return TextEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type ShuffleText struct{ capnp.Struct }

// ShuffleText_TypeID is the unique identifier for the type ShuffleText.
const ShuffleText_TypeID = 0x9f113e6204641aee

func NewShuffleText(s *capnp.Segment) (ShuffleText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ShuffleText{st}, err
}

func NewRootShuffleText(s *capnp.Segment) (ShuffleText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ShuffleText{st}, err
}

func ReadRootShuffleText(msg *capnp.Message) (ShuffleText, error) {
	root, err := msg.RootPtr()
	return ShuffleText{root.Struct()}, err
}

func (s ShuffleText) String() string {
	str, _ := text.Marshal(0x9f113e6204641aee, s.Struct)
	return str
}

func (s ShuffleText) Seq() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s ShuffleText) HasSeq() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ShuffleText) SetSeq(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSeq sets the seq field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s ShuffleText) NewSeq() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s ShuffleText) Parts() (TextEval_List, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval_List{List: p.List()}, err
}

func (s ShuffleText) HasParts() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ShuffleText) SetParts(v TextEval_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewParts sets the parts field to a newly
// allocated TextEval_List, preferring placement in s's segment.
func (s ShuffleText) NewParts(n int32) (TextEval_List, error) {
	l, err := NewTextEval_List(s.Struct.Segment(), n)
	if err != nil {
		return TextEval_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// ShuffleText_List is a list of ShuffleText.
type ShuffleText_List struct{ capnp.List }

// NewShuffleText creates a new list of ShuffleText.
func NewShuffleText_List(s *capnp.Segment, sz int32) (ShuffleText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return ShuffleText_List{l}, err
}

func (s ShuffleText_List) At(i int) ShuffleText { return ShuffleText{s.List.Struct(i)} }

func (s ShuffleText_List) Set(i int, v ShuffleText) error { return s.List.SetStruct(i, v.Struct) }

func (s ShuffleText_List) String() string {
	str, _ := text.MarshalList(0x9f113e6204641aee, s.List)
	return str
}

// ShuffleText_Promise is a wrapper for a ShuffleText promised by a client call.
type ShuffleText_Promise struct{ *capnp.Pipeline }

func (p ShuffleText_Promise) Struct() (ShuffleText, error) {
	s, err := p.Pipeline.Struct()
	return ShuffleText{s}, err
}

func (p ShuffleText_Promise) Seq() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Slash struct{ capnp.Struct }

// Slash_TypeID is the unique identifier for the type Slash.
const Slash_TypeID = 0x9ebd6818aedc34c5

func NewSlash(s *capnp.Segment) (Slash, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Slash{st}, err
}

func NewRootSlash(s *capnp.Segment) (Slash, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Slash{st}, err
}

func ReadRootSlash(msg *capnp.Message) (Slash, error) {
	root, err := msg.RootPtr()
	return Slash{root.Struct()}, err
}

func (s Slash) String() string {
	str, _ := text.Marshal(0x9ebd6818aedc34c5, s.Struct)
	return str
}

func (s Slash) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s Slash) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Slash) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Slash) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Slash_List is a list of Slash.
type Slash_List struct{ capnp.List }

// NewSlash creates a new list of Slash.
func NewSlash_List(s *capnp.Segment, sz int32) (Slash_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Slash_List{l}, err
}

func (s Slash_List) At(i int) Slash { return Slash{s.List.Struct(i)} }

func (s Slash_List) Set(i int, v Slash) error { return s.List.SetStruct(i, v.Struct) }

func (s Slash_List) String() string {
	str, _ := text.MarshalList(0x9ebd6818aedc34c5, s.List)
	return str
}

// Slash_Promise is a wrapper for a Slash promised by a client call.
type Slash_Promise struct{ *capnp.Pipeline }

func (p Slash_Promise) Struct() (Slash, error) {
	s, err := p.Pipeline.Struct()
	return Slash{s}, err
}

type Slice struct{ capnp.Struct }

// Slice_TypeID is the unique identifier for the type Slice.
const Slice_TypeID = 0xed3b2485505bd7a7

func NewSlice(s *capnp.Segment) (Slice, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Slice{st}, err
}

func NewRootSlice(s *capnp.Segment) (Slice, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Slice{st}, err
}

func ReadRootSlice(msg *capnp.Message) (Slice, error) {
	root, err := msg.RootPtr()
	return Slice{root.Struct()}, err
}

func (s Slice) String() string {
	str, _ := text.Marshal(0xed3b2485505bd7a7, s.Struct)
	return str
}

func (s Slice) List() (Assignment, error) {
	p, err := s.Struct.Ptr(0)
	return Assignment{Struct: p.Struct()}, err
}

func (s Slice) HasList() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Slice) SetList(v Assignment) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewList sets the list field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Slice) NewList() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Slice) Start() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Slice) HasStart() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Slice) SetStart(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewStart sets the start field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Slice) NewStart() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Slice) End() (NumberEval, error) {
	p, err := s.Struct.Ptr(2)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Slice) HasEnd() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Slice) SetEnd(v NumberEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewEnd sets the end field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Slice) NewEnd() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// Slice_List is a list of Slice.
type Slice_List struct{ capnp.List }

// NewSlice creates a new list of Slice.
func NewSlice_List(s *capnp.Segment, sz int32) (Slice_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return Slice_List{l}, err
}

func (s Slice_List) At(i int) Slice { return Slice{s.List.Struct(i)} }

func (s Slice_List) Set(i int, v Slice) error { return s.List.SetStruct(i, v.Struct) }

func (s Slice_List) String() string {
	str, _ := text.MarshalList(0xed3b2485505bd7a7, s.List)
	return str
}

// Slice_Promise is a wrapper for a Slice promised by a client call.
type Slice_Promise struct{ *capnp.Pipeline }

func (p Slice_Promise) Struct() (Slice, error) {
	s, err := p.Pipeline.Struct()
	return Slice{s}, err
}

func (p Slice_Promise) List() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Slice_Promise) Start() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Slice_Promise) End() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type Softline struct{ capnp.Struct }

// Softline_TypeID is the unique identifier for the type Softline.
const Softline_TypeID = 0x9d78ce9d70c0e19b

func NewSoftline(s *capnp.Segment) (Softline, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Softline{st}, err
}

func NewRootSoftline(s *capnp.Segment) (Softline, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Softline{st}, err
}

func ReadRootSoftline(msg *capnp.Message) (Softline, error) {
	root, err := msg.RootPtr()
	return Softline{root.Struct()}, err
}

func (s Softline) String() string {
	str, _ := text.Marshal(0x9d78ce9d70c0e19b, s.Struct)
	return str
}

// Softline_List is a list of Softline.
type Softline_List struct{ capnp.List }

// NewSoftline creates a new list of Softline.
func NewSoftline_List(s *capnp.Segment, sz int32) (Softline_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Softline_List{l}, err
}

func (s Softline_List) At(i int) Softline { return Softline{s.List.Struct(i)} }

func (s Softline_List) Set(i int, v Softline) error { return s.List.SetStruct(i, v.Struct) }

func (s Softline_List) String() string {
	str, _ := text.MarshalList(0x9d78ce9d70c0e19b, s.List)
	return str
}

// Softline_Promise is a wrapper for a Softline promised by a client call.
type Softline_Promise struct{ *capnp.Pipeline }

func (p Softline_Promise) Struct() (Softline, error) {
	s, err := p.Pipeline.Struct()
	return Softline{s}, err
}

type SortByField struct{ capnp.Struct }

// SortByField_TypeID is the unique identifier for the type SortByField.
const SortByField_TypeID = 0xf8197b1f0846744b

func NewSortByField(s *capnp.Segment) (SortByField, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SortByField{st}, err
}

func NewRootSortByField(s *capnp.Segment) (SortByField, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SortByField{st}, err
}

func ReadRootSortByField(msg *capnp.Message) (SortByField, error) {
	root, err := msg.RootPtr()
	return SortByField{root.Struct()}, err
}

func (s SortByField) String() string {
	str, _ := text.Marshal(0xf8197b1f0846744b, s.Struct)
	return str
}

func (s SortByField) Name() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s SortByField) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s SortByField) SetName(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s SortByField) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// SortByField_List is a list of SortByField.
type SortByField_List struct{ capnp.List }

// NewSortByField creates a new list of SortByField.
func NewSortByField_List(s *capnp.Segment, sz int32) (SortByField_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return SortByField_List{l}, err
}

func (s SortByField_List) At(i int) SortByField { return SortByField{s.List.Struct(i)} }

func (s SortByField_List) Set(i int, v SortByField) error { return s.List.SetStruct(i, v.Struct) }

func (s SortByField_List) String() string {
	str, _ := text.MarshalList(0xf8197b1f0846744b, s.List)
	return str
}

// SortByField_Promise is a wrapper for a SortByField promised by a client call.
type SortByField_Promise struct{ *capnp.Pipeline }

func (p SortByField_Promise) Struct() (SortByField, error) {
	s, err := p.Pipeline.Struct()
	return SortByField{s}, err
}

func (p SortByField_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type SortNumbers struct{ capnp.Struct }

// SortNumbers_TypeID is the unique identifier for the type SortNumbers.
const SortNumbers_TypeID = 0x887e2baa365457ac

func NewSortNumbers(s *capnp.Segment) (SortNumbers, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return SortNumbers{st}, err
}

func NewRootSortNumbers(s *capnp.Segment) (SortNumbers, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return SortNumbers{st}, err
}

func ReadRootSortNumbers(msg *capnp.Message) (SortNumbers, error) {
	root, err := msg.RootPtr()
	return SortNumbers{root.Struct()}, err
}

func (s SortNumbers) String() string {
	str, _ := text.Marshal(0x887e2baa365457ac, s.Struct)
	return str
}

func (s SortNumbers) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s SortNumbers) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s SortNumbers) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s SortNumbers) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s SortNumbers) Name() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s SortNumbers) HasName() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s SortNumbers) SetName(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s SortNumbers) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s SortNumbers) Order() (Bool, error) {
	p, err := s.Struct.Ptr(2)
	return Bool{Struct: p.Struct()}, err
}

func (s SortNumbers) HasOrder() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s SortNumbers) SetOrder(v Bool) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewOrder sets the order field to a newly
// allocated Bool struct, preferring placement in s's segment.
func (s SortNumbers) NewOrder() (Bool, error) {
	ss, err := NewBool(s.Struct.Segment())
	if err != nil {
		return Bool{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

// SortNumbers_List is a list of SortNumbers.
type SortNumbers_List struct{ capnp.List }

// NewSortNumbers creates a new list of SortNumbers.
func NewSortNumbers_List(s *capnp.Segment, sz int32) (SortNumbers_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return SortNumbers_List{l}, err
}

func (s SortNumbers_List) At(i int) SortNumbers { return SortNumbers{s.List.Struct(i)} }

func (s SortNumbers_List) Set(i int, v SortNumbers) error { return s.List.SetStruct(i, v.Struct) }

func (s SortNumbers_List) String() string {
	str, _ := text.MarshalList(0x887e2baa365457ac, s.List)
	return str
}

// SortNumbers_Promise is a wrapper for a SortNumbers promised by a client call.
type SortNumbers_Promise struct{ *capnp.Pipeline }

func (p SortNumbers_Promise) Struct() (SortNumbers, error) {
	s, err := p.Pipeline.Struct()
	return SortNumbers{s}, err
}

func (p SortNumbers_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p SortNumbers_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p SortNumbers_Promise) Order() Bool_Promise {
	return Bool_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type SortRecords struct{ capnp.Struct }

// SortRecords_TypeID is the unique identifier for the type SortRecords.
const SortRecords_TypeID = 0xb84492e23931604b

func NewSortRecords(s *capnp.Segment) (SortRecords, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SortRecords{st}, err
}

func NewRootSortRecords(s *capnp.Segment) (SortRecords, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SortRecords{st}, err
}

func ReadRootSortRecords(msg *capnp.Message) (SortRecords, error) {
	root, err := msg.RootPtr()
	return SortRecords{root.Struct()}, err
}

func (s SortRecords) String() string {
	str, _ := text.Marshal(0xb84492e23931604b, s.Struct)
	return str
}

func (s SortRecords) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s SortRecords) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s SortRecords) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s SortRecords) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s SortRecords) Using() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s SortRecords) HasUsing() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s SortRecords) SetUsing(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewUsing sets the using field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s SortRecords) NewUsing() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// SortRecords_List is a list of SortRecords.
type SortRecords_List struct{ capnp.List }

// NewSortRecords creates a new list of SortRecords.
func NewSortRecords_List(s *capnp.Segment, sz int32) (SortRecords_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return SortRecords_List{l}, err
}

func (s SortRecords_List) At(i int) SortRecords { return SortRecords{s.List.Struct(i)} }

func (s SortRecords_List) Set(i int, v SortRecords) error { return s.List.SetStruct(i, v.Struct) }

func (s SortRecords_List) String() string {
	str, _ := text.MarshalList(0xb84492e23931604b, s.List)
	return str
}

// SortRecords_Promise is a wrapper for a SortRecords promised by a client call.
type SortRecords_Promise struct{ *capnp.Pipeline }

func (p SortRecords_Promise) Struct() (SortRecords, error) {
	s, err := p.Pipeline.Struct()
	return SortRecords{s}, err
}

func (p SortRecords_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p SortRecords_Promise) Using() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type SortText struct{ capnp.Struct }

// SortText_TypeID is the unique identifier for the type SortText.
const SortText_TypeID = 0xc3b6afda5598b1a1

func NewSortText(s *capnp.Segment) (SortText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return SortText{st}, err
}

func NewRootSortText(s *capnp.Segment) (SortText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return SortText{st}, err
}

func ReadRootSortText(msg *capnp.Message) (SortText, error) {
	root, err := msg.RootPtr()
	return SortText{root.Struct()}, err
}

func (s SortText) String() string {
	str, _ := text.Marshal(0xc3b6afda5598b1a1, s.Struct)
	return str
}

func (s SortText) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s SortText) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s SortText) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s SortText) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s SortText) Name() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s SortText) HasName() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s SortText) SetName(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s SortText) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s SortText) Order() (Bool, error) {
	p, err := s.Struct.Ptr(2)
	return Bool{Struct: p.Struct()}, err
}

func (s SortText) HasOrder() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s SortText) SetOrder(v Bool) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewOrder sets the order field to a newly
// allocated Bool struct, preferring placement in s's segment.
func (s SortText) NewOrder() (Bool, error) {
	ss, err := NewBool(s.Struct.Segment())
	if err != nil {
		return Bool{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

func (s SortText) Case() (Bool, error) {
	p, err := s.Struct.Ptr(3)
	return Bool{Struct: p.Struct()}, err
}

func (s SortText) HasCase() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s SortText) SetCase(v Bool) error {
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewCase sets the case field to a newly
// allocated Bool struct, preferring placement in s's segment.
func (s SortText) NewCase() (Bool, error) {
	ss, err := NewBool(s.Struct.Segment())
	if err != nil {
		return Bool{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

// SortText_List is a list of SortText.
type SortText_List struct{ capnp.List }

// NewSortText creates a new list of SortText.
func NewSortText_List(s *capnp.Segment, sz int32) (SortText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return SortText_List{l}, err
}

func (s SortText_List) At(i int) SortText { return SortText{s.List.Struct(i)} }

func (s SortText_List) Set(i int, v SortText) error { return s.List.SetStruct(i, v.Struct) }

func (s SortText_List) String() string {
	str, _ := text.MarshalList(0xc3b6afda5598b1a1, s.List)
	return str
}

// SortText_Promise is a wrapper for a SortText promised by a client call.
type SortText_Promise struct{ *capnp.Pipeline }

func (p SortText_Promise) Struct() (SortText, error) {
	s, err := p.Pipeline.Struct()
	return SortText{s}, err
}

func (p SortText_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p SortText_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p SortText_Promise) Order() Bool_Promise {
	return Bool_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

func (p SortText_Promise) Case() Bool_Promise {
	return Bool_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

type Span struct{ capnp.Struct }

// Span_TypeID is the unique identifier for the type Span.
const Span_TypeID = 0xf49ec658ecb66316

func NewSpan(s *capnp.Segment) (Span, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Span{st}, err
}

func NewRootSpan(s *capnp.Segment) (Span, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Span{st}, err
}

func ReadRootSpan(msg *capnp.Message) (Span, error) {
	root, err := msg.RootPtr()
	return Span{root.Struct()}, err
}

func (s Span) String() string {
	str, _ := text.Marshal(0xf49ec658ecb66316, s.Struct)
	return str
}

func (s Span) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(0)
	return Execute_List{List: p.List()}, err
}

func (s Span) HasExe() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Span) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s Span) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Span_List is a list of Span.
type Span_List struct{ capnp.List }

// NewSpan creates a new list of Span.
func NewSpan_List(s *capnp.Segment, sz int32) (Span_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Span_List{l}, err
}

func (s Span_List) At(i int) Span { return Span{s.List.Struct(i)} }

func (s Span_List) Set(i int, v Span) error { return s.List.SetStruct(i, v.Struct) }

func (s Span_List) String() string {
	str, _ := text.MarshalList(0xf49ec658ecb66316, s.List)
	return str
}

// Span_Promise is a wrapper for a Span promised by a client call.
type Span_Promise struct{ *capnp.Pipeline }

func (p Span_Promise) Struct() (Span, error) {
	s, err := p.Pipeline.Struct()
	return Span{s}, err
}

type Splice struct{ capnp.Struct }

// Splice_TypeID is the unique identifier for the type Splice.
const Splice_TypeID = 0xf3d6c196641054ba

func NewSplice(s *capnp.Segment) (Splice, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return Splice{st}, err
}

func NewRootSplice(s *capnp.Segment) (Splice, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return Splice{st}, err
}

func ReadRootSplice(msg *capnp.Message) (Splice, error) {
	root, err := msg.RootPtr()
	return Splice{root.Struct()}, err
}

func (s Splice) String() string {
	str, _ := text.Marshal(0xf3d6c196641054ba, s.Struct)
	return str
}

func (s Splice) Str() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Splice) HasStr() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Splice) SetStr(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Splice) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Splice) Start() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Splice) HasStart() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Splice) SetStart(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewStart sets the start field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Splice) NewStart() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Splice) Remove() (NumberEval, error) {
	p, err := s.Struct.Ptr(2)
	return NumberEval{Struct: p.Struct()}, err
}

func (s Splice) HasRemove() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Splice) SetRemove(v NumberEval) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewRemove sets the remove field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s Splice) NewRemove() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

func (s Splice) Insert() (Assignment, error) {
	p, err := s.Struct.Ptr(3)
	return Assignment{Struct: p.Struct()}, err
}

func (s Splice) HasInsert() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Splice) SetInsert(v Assignment) error {
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewInsert sets the insert field to a newly
// allocated Assignment struct, preferring placement in s's segment.
func (s Splice) NewInsert() (Assignment, error) {
	ss, err := NewAssignment(s.Struct.Segment())
	if err != nil {
		return Assignment{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

// Splice_List is a list of Splice.
type Splice_List struct{ capnp.List }

// NewSplice creates a new list of Splice.
func NewSplice_List(s *capnp.Segment, sz int32) (Splice_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return Splice_List{l}, err
}

func (s Splice_List) At(i int) Splice { return Splice{s.List.Struct(i)} }

func (s Splice_List) Set(i int, v Splice) error { return s.List.SetStruct(i, v.Struct) }

func (s Splice_List) String() string {
	str, _ := text.MarshalList(0xf3d6c196641054ba, s.List)
	return str
}

// Splice_Promise is a wrapper for a Splice promised by a client call.
type Splice_Promise struct{ *capnp.Pipeline }

func (p Splice_Promise) Struct() (Splice, error) {
	s, err := p.Pipeline.Struct()
	return Splice{s}, err
}

func (p Splice_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Splice_Promise) Start() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Splice_Promise) Remove() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

func (p Splice_Promise) Insert() Assignment_Promise {
	return Assignment_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

type StoppingText struct{ capnp.Struct }

// StoppingText_TypeID is the unique identifier for the type StoppingText.
const StoppingText_TypeID = 0x8ac65f056ee65bd0

func NewStoppingText(s *capnp.Segment) (StoppingText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return StoppingText{st}, err
}

func NewRootStoppingText(s *capnp.Segment) (StoppingText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return StoppingText{st}, err
}

func ReadRootStoppingText(msg *capnp.Message) (StoppingText, error) {
	root, err := msg.RootPtr()
	return StoppingText{root.Struct()}, err
}

func (s StoppingText) String() string {
	str, _ := text.Marshal(0x8ac65f056ee65bd0, s.Struct)
	return str
}

func (s StoppingText) Seq() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s StoppingText) HasSeq() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s StoppingText) SetSeq(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewSeq sets the seq field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s StoppingText) NewSeq() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s StoppingText) Parts() (TextEval_List, error) {
	p, err := s.Struct.Ptr(1)
	return TextEval_List{List: p.List()}, err
}

func (s StoppingText) HasParts() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s StoppingText) SetParts(v TextEval_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewParts sets the parts field to a newly
// allocated TextEval_List, preferring placement in s's segment.
func (s StoppingText) NewParts(n int32) (TextEval_List, error) {
	l, err := NewTextEval_List(s.Struct.Segment(), n)
	if err != nil {
		return TextEval_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// StoppingText_List is a list of StoppingText.
type StoppingText_List struct{ capnp.List }

// NewStoppingText creates a new list of StoppingText.
func NewStoppingText_List(s *capnp.Segment, sz int32) (StoppingText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return StoppingText_List{l}, err
}

func (s StoppingText_List) At(i int) StoppingText { return StoppingText{s.List.Struct(i)} }

func (s StoppingText_List) Set(i int, v StoppingText) error { return s.List.SetStruct(i, v.Struct) }

func (s StoppingText_List) String() string {
	str, _ := text.MarshalList(0x8ac65f056ee65bd0, s.List)
	return str
}

// StoppingText_Promise is a wrapper for a StoppingText promised by a client call.
type StoppingText_Promise struct{ *capnp.Pipeline }

func (p StoppingText_Promise) Struct() (StoppingText, error) {
	s, err := p.Pipeline.Struct()
	return StoppingText{s}, err
}

func (p StoppingText_Promise) Seq() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type SumOf struct{ capnp.Struct }

// SumOf_TypeID is the unique identifier for the type SumOf.
const SumOf_TypeID = 0xcec947b30cac496e

func NewSumOf(s *capnp.Segment) (SumOf, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SumOf{st}, err
}

func NewRootSumOf(s *capnp.Segment) (SumOf, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SumOf{st}, err
}

func ReadRootSumOf(msg *capnp.Message) (SumOf, error) {
	root, err := msg.RootPtr()
	return SumOf{root.Struct()}, err
}

func (s SumOf) String() string {
	str, _ := text.Marshal(0xcec947b30cac496e, s.Struct)
	return str
}

func (s SumOf) A() (NumberEval, error) {
	p, err := s.Struct.Ptr(0)
	return NumberEval{Struct: p.Struct()}, err
}

func (s SumOf) HasA() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s SumOf) SetA(v NumberEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA sets the a field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s SumOf) NewA() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s SumOf) B() (NumberEval, error) {
	p, err := s.Struct.Ptr(1)
	return NumberEval{Struct: p.Struct()}, err
}

func (s SumOf) HasB() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s SumOf) SetB(v NumberEval) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewB sets the b field to a newly
// allocated NumberEval struct, preferring placement in s's segment.
func (s SumOf) NewB() (NumberEval, error) {
	ss, err := NewNumberEval(s.Struct.Segment())
	if err != nil {
		return NumberEval{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// SumOf_List is a list of SumOf.
type SumOf_List struct{ capnp.List }

// NewSumOf creates a new list of SumOf.
func NewSumOf_List(s *capnp.Segment, sz int32) (SumOf_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return SumOf_List{l}, err
}

func (s SumOf_List) At(i int) SumOf { return SumOf{s.List.Struct(i)} }

func (s SumOf_List) Set(i int, v SumOf) error { return s.List.SetStruct(i, v.Struct) }

func (s SumOf_List) String() string {
	str, _ := text.MarshalList(0xcec947b30cac496e, s.List)
	return str
}

// SumOf_Promise is a wrapper for a SumOf promised by a client call.
type SumOf_Promise struct{ *capnp.Pipeline }

func (p SumOf_Promise) Struct() (SumOf, error) {
	s, err := p.Pipeline.Struct()
	return SumOf{s}, err
}

func (p SumOf_Promise) A() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p SumOf_Promise) B() NumberEval_Promise {
	return NumberEval_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Text struct{ capnp.Struct }

// Text_TypeID is the unique identifier for the type Text.
const Text_TypeID = 0xe3dc36ced14a87ae

func NewText(s *capnp.Segment) (Text, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Text{st}, err
}

func NewRootText(s *capnp.Segment) (Text, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Text{st}, err
}

func ReadRootText(msg *capnp.Message) (Text, error) {
	root, err := msg.RootPtr()
	return Text{root.Struct()}, err
}

func (s Text) String() string {
	str, _ := text.Marshal(0xe3dc36ced14a87ae, s.Struct)
	return str
}

func (s Text) Text() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Text) HasText() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Text) SetText(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewText sets the text field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Text) NewText() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Text_List is a list of Text.
type Text_List struct{ capnp.List }

// NewText creates a new list of Text.
func NewText_List(s *capnp.Segment, sz int32) (Text_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Text_List{l}, err
}

func (s Text_List) At(i int) Text { return Text{s.List.Struct(i)} }

func (s Text_List) Set(i int, v Text) error { return s.List.SetStruct(i, v.Struct) }

func (s Text_List) String() string {
	str, _ := text.MarshalList(0xe3dc36ced14a87ae, s.List)
	return str
}

// Text_Promise is a wrapper for a Text promised by a client call.
type Text_Promise struct{ *capnp.Pipeline }

func (p Text_Promise) Struct() (Text, error) {
	s, err := p.Pipeline.Struct()
	return Text{s}, err
}

func (p Text_Promise) Text() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Texts struct{ capnp.Struct }

// Texts_TypeID is the unique identifier for the type Texts.
const Texts_TypeID = 0xb8c452ab65134fa4

func NewTexts(s *capnp.Segment) (Texts, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Texts{st}, err
}

func NewRootTexts(s *capnp.Segment) (Texts, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Texts{st}, err
}

func ReadRootTexts(msg *capnp.Message) (Texts, error) {
	root, err := msg.RootPtr()
	return Texts{root.Struct()}, err
}

func (s Texts) String() string {
	str, _ := text.Marshal(0xb8c452ab65134fa4, s.Struct)
	return str
}

func (s Texts) Values() (Text_List, error) {
	p, err := s.Struct.Ptr(0)
	return Text_List{List: p.List()}, err
}

func (s Texts) HasValues() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Texts) SetValues(v Text_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewValues sets the values field to a newly
// allocated Text_List, preferring placement in s's segment.
func (s Texts) NewValues(n int32) (Text_List, error) {
	l, err := NewText_List(s.Struct.Segment(), n)
	if err != nil {
		return Text_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Texts_List is a list of Texts.
type Texts_List struct{ capnp.List }

// NewTexts creates a new list of Texts.
func NewTexts_List(s *capnp.Segment, sz int32) (Texts_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Texts_List{l}, err
}

func (s Texts_List) At(i int) Texts { return Texts{s.List.Struct(i)} }

func (s Texts_List) Set(i int, v Texts) error { return s.List.SetStruct(i, v.Struct) }

func (s Texts_List) String() string {
	str, _ := text.MarshalList(0xb8c452ab65134fa4, s.List)
	return str
}

// Texts_Promise is a wrapper for a Texts promised by a client call.
type Texts_Promise struct{ *capnp.Pipeline }

func (p Texts_Promise) Struct() (Texts, error) {
	s, err := p.Pipeline.Struct()
	return Texts{s}, err
}

type TriggerCycle struct{ capnp.Struct }

// TriggerCycle_TypeID is the unique identifier for the type TriggerCycle.
const TriggerCycle_TypeID = 0xf7f2f9bca6db47ac

func NewTriggerCycle(s *capnp.Segment) (TriggerCycle, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return TriggerCycle{st}, err
}

func NewRootTriggerCycle(s *capnp.Segment) (TriggerCycle, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return TriggerCycle{st}, err
}

func ReadRootTriggerCycle(msg *capnp.Message) (TriggerCycle, error) {
	root, err := msg.RootPtr()
	return TriggerCycle{root.Struct()}, err
}

func (s TriggerCycle) String() string {
	str, _ := text.Marshal(0xf7f2f9bca6db47ac, s.Struct)
	return str
}

// TriggerCycle_List is a list of TriggerCycle.
type TriggerCycle_List struct{ capnp.List }

// NewTriggerCycle creates a new list of TriggerCycle.
func NewTriggerCycle_List(s *capnp.Segment, sz int32) (TriggerCycle_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return TriggerCycle_List{l}, err
}

func (s TriggerCycle_List) At(i int) TriggerCycle { return TriggerCycle{s.List.Struct(i)} }

func (s TriggerCycle_List) Set(i int, v TriggerCycle) error { return s.List.SetStruct(i, v.Struct) }

func (s TriggerCycle_List) String() string {
	str, _ := text.MarshalList(0xf7f2f9bca6db47ac, s.List)
	return str
}

// TriggerCycle_Promise is a wrapper for a TriggerCycle promised by a client call.
type TriggerCycle_Promise struct{ *capnp.Pipeline }

func (p TriggerCycle_Promise) Struct() (TriggerCycle, error) {
	s, err := p.Pipeline.Struct()
	return TriggerCycle{s}, err
}

type TriggerOnce struct{ capnp.Struct }

// TriggerOnce_TypeID is the unique identifier for the type TriggerOnce.
const TriggerOnce_TypeID = 0xbc36d0a646cabd4a

func NewTriggerOnce(s *capnp.Segment) (TriggerOnce, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return TriggerOnce{st}, err
}

func NewRootTriggerOnce(s *capnp.Segment) (TriggerOnce, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return TriggerOnce{st}, err
}

func ReadRootTriggerOnce(msg *capnp.Message) (TriggerOnce, error) {
	root, err := msg.RootPtr()
	return TriggerOnce{root.Struct()}, err
}

func (s TriggerOnce) String() string {
	str, _ := text.Marshal(0xbc36d0a646cabd4a, s.Struct)
	return str
}

// TriggerOnce_List is a list of TriggerOnce.
type TriggerOnce_List struct{ capnp.List }

// NewTriggerOnce creates a new list of TriggerOnce.
func NewTriggerOnce_List(s *capnp.Segment, sz int32) (TriggerOnce_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return TriggerOnce_List{l}, err
}

func (s TriggerOnce_List) At(i int) TriggerOnce { return TriggerOnce{s.List.Struct(i)} }

func (s TriggerOnce_List) Set(i int, v TriggerOnce) error { return s.List.SetStruct(i, v.Struct) }

func (s TriggerOnce_List) String() string {
	str, _ := text.MarshalList(0xbc36d0a646cabd4a, s.List)
	return str
}

// TriggerOnce_Promise is a wrapper for a TriggerOnce promised by a client call.
type TriggerOnce_Promise struct{ *capnp.Pipeline }

func (p TriggerOnce_Promise) Struct() (TriggerOnce, error) {
	s, err := p.Pipeline.Struct()
	return TriggerOnce{s}, err
}

type TriggerSwitch struct{ capnp.Struct }

// TriggerSwitch_TypeID is the unique identifier for the type TriggerSwitch.
const TriggerSwitch_TypeID = 0xac2e3ed637d505a6

func NewTriggerSwitch(s *capnp.Segment) (TriggerSwitch, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return TriggerSwitch{st}, err
}

func NewRootTriggerSwitch(s *capnp.Segment) (TriggerSwitch, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return TriggerSwitch{st}, err
}

func ReadRootTriggerSwitch(msg *capnp.Message) (TriggerSwitch, error) {
	root, err := msg.RootPtr()
	return TriggerSwitch{root.Struct()}, err
}

func (s TriggerSwitch) String() string {
	str, _ := text.Marshal(0xac2e3ed637d505a6, s.Struct)
	return str
}

// TriggerSwitch_List is a list of TriggerSwitch.
type TriggerSwitch_List struct{ capnp.List }

// NewTriggerSwitch creates a new list of TriggerSwitch.
func NewTriggerSwitch_List(s *capnp.Segment, sz int32) (TriggerSwitch_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return TriggerSwitch_List{l}, err
}

func (s TriggerSwitch_List) At(i int) TriggerSwitch { return TriggerSwitch{s.List.Struct(i)} }

func (s TriggerSwitch_List) Set(i int, v TriggerSwitch) error { return s.List.SetStruct(i, v.Struct) }

func (s TriggerSwitch_List) String() string {
	str, _ := text.MarshalList(0xac2e3ed637d505a6, s.List)
	return str
}

// TriggerSwitch_Promise is a wrapper for a TriggerSwitch promised by a client call.
type TriggerSwitch_Promise struct{ *capnp.Pipeline }

func (p TriggerSwitch_Promise) Struct() (TriggerSwitch, error) {
	s, err := p.Pipeline.Struct()
	return TriggerSwitch{s}, err
}

type Var struct{ capnp.Struct }

// Var_TypeID is the unique identifier for the type Var.
const Var_TypeID = 0xf77fe4fb65c4a80e

func NewVar(s *capnp.Segment) (Var, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Var{st}, err
}

func NewRootVar(s *capnp.Segment) (Var, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Var{st}, err
}

func ReadRootVar(msg *capnp.Message) (Var, error) {
	root, err := msg.RootPtr()
	return Var{root.Struct()}, err
}

func (s Var) String() string {
	str, _ := text.Marshal(0xf77fe4fb65c4a80e, s.Struct)
	return str
}

func (s Var) Name() (Text, error) {
	p, err := s.Struct.Ptr(0)
	return Text{Struct: p.Struct()}, err
}

func (s Var) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Var) SetName(v Text) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewName sets the name field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Var) NewName() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Var_List is a list of Var.
type Var_List struct{ capnp.List }

// NewVar creates a new list of Var.
func NewVar_List(s *capnp.Segment, sz int32) (Var_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Var_List{l}, err
}

func (s Var_List) At(i int) Var { return Var{s.List.Struct(i)} }

func (s Var_List) Set(i int, v Var) error { return s.List.SetStruct(i, v.Struct) }

func (s Var_List) String() string {
	str, _ := text.MarshalList(0xf77fe4fb65c4a80e, s.List)
	return str
}

// Var_Promise is a wrapper for a Var promised by a client call.
type Var_Promise struct{ *capnp.Pipeline }

func (p Var_Promise) Struct() (Var, error) {
	s, err := p.Pipeline.Struct()
	return Var{s}, err
}

func (p Var_Promise) Name() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Variable struct{ capnp.Struct }

// Variable_TypeID is the unique identifier for the type Variable.
const Variable_TypeID = 0xdb34e3e82af96202

func NewVariable(s *capnp.Segment) (Variable, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Variable{st}, err
}

func NewRootVariable(s *capnp.Segment) (Variable, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Variable{st}, err
}

func ReadRootVariable(msg *capnp.Message) (Variable, error) {
	root, err := msg.RootPtr()
	return Variable{root.Struct()}, err
}

func (s Variable) String() string {
	str, _ := text.Marshal(0xdb34e3e82af96202, s.Struct)
	return str
}

func (s Variable) At() (Pos, error) {
	p, err := s.Struct.Ptr(0)
	return Pos{Struct: p.Struct()}, err
}

func (s Variable) HasAt() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Variable) SetAt(v Pos) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAt sets the at field to a newly
// allocated Pos struct, preferring placement in s's segment.
func (s Variable) NewAt() (Pos, error) {
	ss, err := NewPos(s.Struct.Segment())
	if err != nil {
		return Pos{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Variable) Str() (Text, error) {
	p, err := s.Struct.Ptr(1)
	return Text{Struct: p.Struct()}, err
}

func (s Variable) HasStr() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Variable) SetStr(v Text) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewStr sets the str field to a newly
// allocated Text struct, preferring placement in s's segment.
func (s Variable) NewStr() (Text, error) {
	ss, err := NewText(s.Struct.Segment())
	if err != nil {
		return Text{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Variable_List is a list of Variable.
type Variable_List struct{ capnp.List }

// NewVariable creates a new list of Variable.
func NewVariable_List(s *capnp.Segment, sz int32) (Variable_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Variable_List{l}, err
}

func (s Variable_List) At(i int) Variable { return Variable{s.List.Struct(i)} }

func (s Variable_List) Set(i int, v Variable) error { return s.List.SetStruct(i, v.Struct) }

func (s Variable_List) String() string {
	str, _ := text.MarshalList(0xdb34e3e82af96202, s.List)
	return str
}

// Variable_Promise is a wrapper for a Variable promised by a client call.
type Variable_Promise struct{ *capnp.Pipeline }

func (p Variable_Promise) Struct() (Variable, error) {
	s, err := p.Pipeline.Struct()
	return Variable{s}, err
}

func (p Variable_Promise) At() Pos_Promise {
	return Pos_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Variable_Promise) Str() Text_Promise {
	return Text_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type While struct{ capnp.Struct }

// While_TypeID is the unique identifier for the type While.
const While_TypeID = 0x86a9f42c4d4b8949

func NewWhile(s *capnp.Segment) (While, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return While{st}, err
}

func NewRootWhile(s *capnp.Segment) (While, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return While{st}, err
}

func ReadRootWhile(msg *capnp.Message) (While, error) {
	root, err := msg.RootPtr()
	return While{root.Struct()}, err
}

func (s While) String() string {
	str, _ := text.Marshal(0x86a9f42c4d4b8949, s.Struct)
	return str
}

func (s While) True() (BoolEval, error) {
	p, err := s.Struct.Ptr(0)
	return BoolEval{Struct: p.Struct()}, err
}

func (s While) HasTrue() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s While) SetTrue(v BoolEval) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTrue sets the true field to a newly
// allocated BoolEval struct, preferring placement in s's segment.
func (s While) NewTrue() (BoolEval, error) {
	ss, err := NewBoolEval(s.Struct.Segment())
	if err != nil {
		return BoolEval{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s While) Exe() (Execute_List, error) {
	p, err := s.Struct.Ptr(1)
	return Execute_List{List: p.List()}, err
}

func (s While) HasExe() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s While) SetExe(v Execute_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewExe sets the exe field to a newly
// allocated Execute_List, preferring placement in s's segment.
func (s While) NewExe(n int32) (Execute_List, error) {
	l, err := NewExecute_List(s.Struct.Segment(), n)
	if err != nil {
		return Execute_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// While_List is a list of While.
type While_List struct{ capnp.List }

// NewWhile creates a new list of While.
func NewWhile_List(s *capnp.Segment, sz int32) (While_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return While_List{l}, err
}

func (s While_List) At(i int) While { return While{s.List.Struct(i)} }

func (s While_List) Set(i int, v While) error { return s.List.SetStruct(i, v.Struct) }

func (s While_List) String() string {
	str, _ := text.MarshalList(0x86a9f42c4d4b8949, s.List)
	return str
}

// While_Promise is a wrapper for a While promised by a client call.
type While_Promise struct{ *capnp.Pipeline }

func (p While_Promise) Struct() (While, error) {
	s, err := p.Pipeline.Struct()
	return While{s}, err
}

func (p While_Promise) True() BoolEval_Promise {
	return BoolEval_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Words struct{ capnp.Struct }

// Words_TypeID is the unique identifier for the type Words.
const Words_TypeID = 0xa3fee7908559519e

func NewWords(s *capnp.Segment) (Words, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Words{st}, err
}

func NewRootWords(s *capnp.Segment) (Words, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Words{st}, err
}

func ReadRootWords(msg *capnp.Message) (Words, error) {
	root, err := msg.RootPtr()
	return Words{root.Struct()}, err
}

func (s Words) String() string {
	str, _ := text.Marshal(0xa3fee7908559519e, s.Struct)
	return str
}

func (s Words) Words() (Text_List, error) {
	p, err := s.Struct.Ptr(0)
	return Text_List{List: p.List()}, err
}

func (s Words) HasWords() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Words) SetWords(v Text_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewWords sets the words field to a newly
// allocated Text_List, preferring placement in s's segment.
func (s Words) NewWords(n int32) (Text_List, error) {
	l, err := NewText_List(s.Struct.Segment(), n)
	if err != nil {
		return Text_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Words_List is a list of Words.
type Words_List struct{ capnp.List }

// NewWords creates a new list of Words.
func NewWords_List(s *capnp.Segment, sz int32) (Words_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Words_List{l}, err
}

func (s Words_List) At(i int) Words { return Words{s.List.Struct(i)} }

func (s Words_List) Set(i int, v Words) error { return s.List.SetStruct(i, v.Struct) }

func (s Words_List) String() string {
	str, _ := text.MarshalList(0xa3fee7908559519e, s.List)
	return str
}

// Words_Promise is a wrapper for a Words promised by a client call.
type Words_Promise struct{ *capnp.Pipeline }

func (p Words_Promise) Struct() (Words, error) {
	s, err := p.Pipeline.Struct()
	return Words{s}, err
}

const schema_ad22bd0042f92910 = "x\xda\xec\xbd\x0d|\x14\xd5\xb9?>gg\x93IP" +
	"\x0c\xeb\x89E(v\x86\x08\x02)D\x09b`\x15C" +
	"B\x02\x84\xb7\xcdf\x82\x0a\x15e\xb2{\x92\x0c\xec\xce" +
	",3\xb3!\xe1'\xe5Ei\x95JU\x14\x15\xae\xa8" +
	"P\xd1\x82\xa8\x80\xa2\xc2\x95Z\xa8\xa0Pi\xb5\x16\x15" +
	"\x14\x05**\x08U,T\xb0\xe2\xfe?\xe7\xcc\xcb\xce" +
	"\xeeN6o\xd0k\xef\xff~>\xf7\xe3\xa5y\x9ey" +
	"\xf6\xcc\x99\xf3\xf2\xbc~\x9f\xab\xee\x1f3\xdc50\xe3" +
	"\xa5R\x8a\xe2\xb3\xe8\x8c\xcc\xd8W7\x08Y}\xde\xf0" +
	"\xcf\xa5<\x9d\xc0\x97]\xfa\x9d)\xdd\x92\xf7L\x06`" +
	"(\x0a\x96\xf4\\\x0c+z2\xb0\xa2\xa7\x0fn\xeaY" +
	"L\x81Xy\x97\x09C\xa3u\xf7$\xf2\xd2\x98wo" +
	"\xcf\xcd\xf0`O\x06\x1e\xec\xe9\x83\x15y\xcfQ v" +
	"f\xd2\xccg~\xfb\xf6\x80y\x09\xbc.\xcc;\xf1\xf2" +
	"\x95p\xca\xe5\x0c\x9cr\xb9\x0f\xee\xbd|&\x05b\x03" +
	"_\x1bVyt\xef'\xf3R\xc7\x80z\xad\x81\xe1^" +
	"\xf8_b\xafb\x0a|3\xb8\xd7\x8b\xc7\x06\x06n\xb7" +
	"\xf1\xb91\xf1\xae^\xf3\xe1\xa2^\x0c\\\xd4\xcbG\xb9" +
	"b\xbfZ\xf7h\xc3\xe9\xdb~w{\xeaO\xef\xef\xa5" +
	"\xc0\x83\xbd\xf4\x7f\xe1\x1f.\xff\xe5e\xcf\xd6\xbd\xfa\xf4" +
	"\x1d\xa9?<\xb4\xf72X\xd2\x9b\x81%\xbd\x8b\xe0\x82" +
	"\xde\xf8\xe5\xbf\xa9\xfd\xd9\xe9\x9c\xb1;\x1cx7\xf6\xde" +
	"\x0c\xb7\xf4f\xe0\x96\xde>8\xfe\x0a\xcc{\xcd\x9f\xb9" +
	"\x093\xb8\xd2\x05\xa9\x13\x15\xbeb\x16\x9cq\x05\x03g" +
	"\\\xe1\x83G\xae\xc0\x13\xd5\xffE:\xa7\xffU{\x16" +
	"\xa4\xca=\xdbG\x81\xa0/\x03A_\x1f\x8c\xf6\xc5r" +
	"\xc5\x9f\x9c\xc9\xbct\xe0\x92_\xa4\xbe\xd9\x92\xbe\xcb\xe0" +
	"\xf2\xbe\x0c\\\xde\xd7\x07;\xf7\xc3\xefVq\xd7\xd8\xf1" +
	"\xfdO\xaev\xe0]\xd4o>\xbc\xaf\x1f\x03\xef\xeb\xe7" +
	"\x83\x9e|\xcc\xbb\xf6\xc6\xeak\xd6\xfc\xf4\xe7w\xa6\x8e" +
	"wE\xfe\x06\xb8:\x9f\x81\xab\xf3\x8b\xe0\x91|<\xde" +
	"k\xfa\xed\xdbV\xf8\xea\xa6;)\x7f'`1\x97\x03" +
	"\x86\xa6(x\xe2\xa7\xfb\xe0\xd9\x9f2\xf0\xecOY\xd8" +
	"\xaf?\xe6\xfe\xd1\x1f\xdf\xbce\x89\xaf\xcb\xc2\xd4\xb7\x1b" +
	"0`3\x1c<\x00\xffk\xe0\x00\xfcn\xf2\xcf\xa6V" +
	"\xcc\xf8\xc9\xb3\x0e\x9c\xfe\x01\xcb\xe0$\xc29\x91p\xbe" +
	"\xf5\xb3O\xa5\x8c[w,L}\xb3\xe8\x80\xcdp\xf6" +
	"\x00\x06\xce\x1e\xe0\x83\x9d\x0b\xf0\x9be\xde\xdc\xa7`\xd3" +
	"\x9f.\xfa\x95\xd3h\x97\x16\xec\x82\xab\x0a\x18\xb8\xaa\x80" +
	"\x85o\x17\xe0\xd1\xde\xb8j\xa04\xf4%\xe1W\xa9c" +
	"\xd8s\xe5\x1a\xb8\xffJ\xb2\xd4\xaf\xc4c\xb8zk\xe9" +
	"\xe2Ov4\xfd*u\x0cg\xae\\\x06\xc1U\x0c\x04" +
	"W\xf9\xe0\x8c\xab\xf0\x18.\x9f\xf4\xe9s\x0fn\x1ap" +
	"w\xc2\x18\xc8\xba\xbdd\xe0Bx\xd9@\x06^6\xd0" +
	"\x07\x17\x0d\xc4r\x17\x8e\xdc}\xf3\xcc\x95]\x17\xa5\x8e" +
	"\xe0\x99\x81\x8b\xe1\xc6\x81\x0c\xdc8\xd0\x07\x07\x14b\xde" +
	"U\xeb\x82\xbf\xeeV\xd9\xc3\x817Z\xb8\x0d\xce.d" +
	"\xe0\xecB\x1f\xcc\x1e\x84yK\x0bF\x14U\xdd|\x83" +
	"\x03o\xbfA\xbb\xe0\xe0A\xe4;\x10\xce\xe7<\xc7\xe7" +
	"\xbd9\xfc\x05\x07N\xff\xa0\xcdp\xd2 \x06N\x1a\xe4" +
	"\x83\xfb\x09o\xcf\xc5\xdb\xc7\xff\xf2\xfe]\xbf\xa6\x927" +
	"\xe4\xd9A\x1b`\xc6\xd5\x0c\xcc\xb8\x1ao\xc8o?}" +
	"\xe4o\x9d\xbf>\xf6\xeb\xd4\xc9BWo\x83\xe1\xab\x19" +
	"\x18\xbe\xda\x07\x0f^\x8d'\xeb\xfe\xe2\xcf\xb4E\xffz" +
	"\xee^\x87\xb3`\xf0|(\x0ef\xa08\xb8\x08\xae\x1e" +
	"\x8c\x7f\xde\xff\xe7\xa9\x97\xf6Z\xfb\x9e\x03\xef\xde\xc1\x8b" +
	"\xe1\xc1\xc1\x0c<8\xd8\x07'^C\x86z\xcd\xa4\x93" +
	"\x8f\x0b\x83\xeeK]\xe2\x0b\xae\x99\x0f\xef\xba\x86\x81w" +
	"]\xe3\x83\xa7\xae\xc1\xcb\xa0\xfc\xb2\xb5\x93\x0e\xbe\xf6\xfa" +
	"\xe2T\xb9\x9d\x87\xec\x83\xdd\x86\x90O7\x04K}\xfb" +
	"'\xd7\xdc\xd3\xf5\x9f7=\x90\xca9x\xc8\x1a8l" +
	"\x08\x03\x87\x0d\xf1\xc1\xad\x98\xf7_\x93\xbf\x9av\xf9\x88" +
	"\x9d\x0f\xa4p\x1e\x1c\xb2\x0c\x1e\x19\xc2\xc0#C|P" +
	"\x18\x8a\xa5\xde62\xfc\xdcM\xf7t}0u\xac\xf3" +
	"\x86\xae\x81w\x0de\xe0]C}\xf0\xccP<\xd6\xdf" +
	"\xff\xf1\xc8\xa5\xf7\xf6-{\xd0\xe1\xb0\xf3.\x84\x87\xbd" +
	"\x0c<\xec\xf5\xc1\x89\xd7\xe2\xb9\xbdr\xe8\x84\xd9\x7f\xf8" +
	"\xfb\x88\x87R\xe5\x9e\xbdv%\xcc\xb8\x8e\x81\x19\xd7\xf9" +
	"\xe0\xec\xeb\xb0\xdc{_\x8c\xee\xefu\xf3\xce\x87R\xe5" +
	"N\x19\xb6\x01\xa2a\x0cD\xc3|p\xff0,w\xef" +
	"\x83\x7f\x19\x1b\xfby\xde\xf2\xd4Y\x98r\xfd\x1a\x88\xae" +
	"\xc7\xff\x12\xae\xc7o\xf6_\x07\x7f\x1fY\xfe\xa7\xc6\xe5" +
	")\x0bf\xde\xf5\xcb\xe0]\xd73\xf0\xae\xeb\xf1\x82\xb9" +
	"`Z`\xc6\xb8\x076.O\xfd\xf1\xc3\xd7\xaf\x81\xc7" +
	"\xafg\xe0\xf1\xeb}pJ1\xfe\xf1\xe3/\xff>x" +
	"O\xe3Q\x87\x1f\xdf_\xbc\x18\x1e.f\xe0\xe1b\x1f" +
	"\x9c8\x1c\xff\xfc{e\xdf\x1cy\xbe\xab\xe7\xd1\x94\x9f" +
	"_>|1\\5\x9c\x81\xab\x86\xe3\x9f\xdf~\xf5\x87" +
	"\xcf^Z\xbf\xe5\xd1T\x91\xa7\x86\xcf\x87g\x863\xf0" +
	"\xccp\x1f\x8c\x96`\x91s?\xd8\xbfo\xd8\xd1o\x1e" +
	"u:`v\x96\xec\x82{J\x18\xb8\xa7\x84\x85\xa0\x14" +
	"\xcf\xea\xdf\xbb\x07\xdd5\xd7{\x1eK}\xb1\x8c\x11\x1b" +
	"`\xe7\x11\x0c\xec<\xc2\x07\xef\x1a\x81_\xecp(\xfb" +
	"\xefO>\xf0\xe3\xc7RGqI\xd9BxY\x19\x03" +
	"/+\xf3\xc1\xfb\xca\xf0(\xbc\xb3\x17x\xa5c{\x1e" +
	"w8\xb8\xcaf\xc1\xbde\x0c\xdc[V\x04\xbb\x95c" +
	"\xde\x93\x07\x8a\x07\xdf\xd3+c\x85\xc3\xa5W\xbe\x18\x96" +
	"\x943\xb0\xa4\xdc\x07\xd7\x13\xde\xcdy\x97\x9d\xa9\x9f\xf7" +
	"c\x07\xde\xb7\xcb\x17\xc3\xbd\xe5\x0c\xdc[^\x04\xbb\x8d" +
	"\xc4\xbc\x8f\xcf\xeb\xff\xc2\xed\xcbnp\xe0\x1d?R\x81" +
	"\xfe\x91\x0c\xf4\x8f\xf4\xc1\xed\x84\xf7\x09t\xe1\xa8[\xb6" +
	"\x85\x1dx\x0f\x8f\\\x09\x8f\x8fd\xe0\xf1\x91>8e" +
	"\x14\xe6\xed\xf1\xc5\xc4\x8b\x87O\xdf\xb7\"u\xcef\x8f" +
	"\x9a\x0f\xe7\x8db\xe0\xbcQEp\xeb(<g\x9e\x1e" +
	"\xbd\xff\xe6~}\xf8J\x87\xc3k\xf4\x068i4\x03" +
	"'\x8d.\x82\xcbGc\xb9\x9fg\x17\xf6\xfc\xe5\xe5[" +
	"W\xa6\xca=8z\x0d<2\x9a\x81GF\xfb`\xb4" +
	"\x02\xcb\xcd)\xfe\xe5\xe4\xc6o\xd6\xfd&\x95w\xd8\x98" +
	"\x95\xb0|\x0c\x03\xcb\xc7\xf8\xe0\xf61\x98\xf7Q\xff\xa4" +
	"\x05\xf7~\xf6\xfdoR\xc7\xd04v>\x9c=\x96\x81" +
	"\xb3\xc7\x16\xc1-c\xf1\x18\xeez{\xe1\x86_\x8f\xac" +
	"x\"y\xf5`\xee\xe3cw\xc13c\x19xf," +
	";\xa8\xdf\xb8{\x00\x05b\xa7\x7fW\xfc\xd2\xe5\xc3\xeb" +
	"\x9fpX\xeb\x13\x16\xc2\xc3\x13\x18xx\x82\x0fN\xf1" +
	"a\xd1}\xbe~3sSI\xf4\x89\xd4!\xaf\xf7-" +
	"\x83\x9b|\x0c\xdc\xe4+\x82g}x\xc8\x1f\x8c\xfdd" +
	"\xff\xf7\x85\xbb\x1d\xe4n\xad\\\x08wV2pge" +
	"\x11\xcc\xf6c\xb9\xcb\xe0\xc0\xd9\x9f\xf6X\xfe\xa4\xc3M" +
	"\xe2_\x03\x07\xfa\x198\xd0_\x04\x9b\x08\xef\x8a\xce\x9f" +
	"\xd3\x05\x9d\x87?\x95\xc0\x9b\x81y\x97\xfa7\xc0\x15~" +
	"\x06\xae\xf0\xfb\x06y\xaaX\xfcrM\xdb\xf3\xba~\xf5" +
	"\xd1\xaf\x9fr8\xc9\xf8\x85\xf00\xcf\xc0\xc3\xbc\x0f\x8e" +
	"\xaf\xc6\x03\x9e\xd3\xe3\xcf\xef\x14\xd4\x84~\x9b:\x88#" +
	"\xd5\x0b\xe1\x89j\x06\x9e\xa8.\x82C'\xe2A\xc4N" +
	"u=E\x8f\\\xb2\xdaA\x11\x9a\xb8\x18.\x99\xc8\xc0" +
	"%\x13}\xb0\xe7\x0dXnV\xf8\x8bi\xbf\xfc\xafG" +
	"W'\x7f\x8f\x1c\xac\x0a\xdd\xf0\x17\xf8\xcc\x0d\x0c|\xe6" +
	"\x06v\xd0\xc1\x1b|4\x05be\xc3s>\x8d\xfd\xb4" +
	"\xef\x9a\xd4\x03\xf5\xed\x9b\xd7\xc0\xbd73p\xef\xcd>" +
	"X1\x05o\xfd/\x83'\xb3\x98g\xfb\xafq\x98\xb7" +
	"[\x16\xc3\x81\xb70p\xe0->\xb8\xe2\x16<\xe4\xee" +
	"\xb3o\xbf\xf6\xf1\xdb_q\xe0\xddz\xcbb\xb8\xf3\x16" +
	"\xfc\xaf\xed\x84\xf3\xaa\xb2^\xec\xfc\xd9=\x9fN9\xd1" +
	"\x0e\xdf\xb2\x10\x1e\xbf\x85\x81\xc7o\xc1'ZQ\xcf\x86" +
	"\xeb/\x1e\xeaZ\xebpO\xdd\xba\x01\x0e\xbb\x95\x81\xc3" +
	"n\xf5\xc1U\xb7b\x91Of\xec)z\xf7\xfa\x82\xb5" +
	")\"\x8f\xdf\xba\x0d\x9e\xba\x95\x81\xa7n-\xa2\\\xb1" +
	"\x97\x06e\xdc\xfb\xc5\x0b\xdf:\x88\xec6u3\xec9" +
	"\x15\xff\xeb\xb2\xa9X\xe0\x1bONW?\xfc\xf1\xd5\xcf" +
	":l\x9e\xa9\xcb`\xf9T\x06\x96O\xf5\xc1MS\xf1" +
	"\x07\x98\xd7\xf5\x17]^}\xf6\xb9g\x93?\x80\x0bk" +
	"\x7f\xc2\xb7P\x10\x18(\x08,\\$`\xee\xb9\xbb\xee" +
	"_;\xbc&\xf3\xb9\x94\xa1\x0e\xac\x99\x05\x07\xd70p" +
	"p\x0d~\xfb\x9f\xef\x0e/\x1a=\xbc\xff\xba\x14\xb6\xfb" +
	"j6\xc0\xa55\x0c\\J\xd8\x9e\xcf{\xe2\xd6\x97\xdf" +
	"\xe7\xd7\xa5~\xcdS5\x1b\xe0\xd9\x1a\x06\x9e\xad\xf1\xc1" +
	"h\x00\x7f\xcd\xa1\x1b7\x8dz\xe4\xe6\xa9\xebS\xdf~" +
	"bp>\x9c\x14d\xe0\xa4`\x11\\\x1a\xc4\xef\x7f\xe0" +
	"\xaew\xcf\x8e\x1cqp}\xaa\xdc\x9dA\x05\xee\x0e2" +
	"pw\xd0\x07\x87!,\xf7\xa5\xe9\x7f\x1e\xfd\x9b)\x17" +
	"<\x9f:W\x97\xd5\xae\x84\xbdk\x19\xd8\xbb\xb6\x08\x8a" +
	"\xb5\xf8\xed\xcf\x8e\x80\x0d\x13\xc3\xe8\xf9\xd41d\xd7m" +
	"\x80\x9e:\x06z\xea|p^\x1d\x1eC\xf4\x969\x17" +
	",\x93\xeeu\xe0]Q\xb7\x06\xae\xaec\xe0\xea:\x1f" +
	"\xecW\x8fy\x7f\xea\xfbE\xcf\xebF?\xe2\xc0[Q" +
	"\xbf\x0c\xfa\xeb\xc9\x91N8\xff\xe9\xab^r\xdb\xe9Y" +
	"/\xa6r\x86\xeb\x17\xc3(\xe1\x9cA8\xcb\x9e\xffL" +
	"\xb9d\xf9}\x0e\x9c\xf7\xd5o\x80K\x09\xe7\x12\xc2\xf9" +
	"\x87\xa6\xfb\xaf\xbc\xfa\xf1M/9\xd8Y\xf5\x1b\xe0\x96" +
	"z\x06n\xa9\xf7\xc1~\"\xe6\xfd\xe0\xf6\x8au\xcf\xbb" +
	".x9\x95w\x86\xb8\x066\x89\x0cl\x12}\xf0\x08" +
	"\xe1\x1d;u\xe0\xd0C\x8b\xcb^N\x9d\xd9\xeci\x1b" +
	"\xa0g\x1a\x03=\xd3|p\xc54<\xb3O\xf8 z" +
	"\xba\xea5\x07\xb9\xe2\xf4\xf90<\x9d\x81\xe1\xe9>x" +
	"p:\x96;\xf1\x8a\x9f\x0fY>w\xed\xa6\xe4\x15{" +
	")EAOh3\xec\x16b`\xb7\x10;h|h" +
	"T\x06\xde\xda\xaf\x9f(\xfc\xc9\xa1\xfe\x9bSEo\x8a" +
	".\x86[\xa3\x0c\xdc\x1a\xf5\xc1\xf1\x0dX\xf4-G\xc7" +
	"\xe6\x9e\xdcxhs\xea\x90W4l\x83\xab\x1b\x18\xb8" +
	"\xba\xc1\x07\x87\xce\xc4C\xee\xf1\xd8w \xf6\xdfw\xfd" +
	"w\xaa\\\xd0\xb8\x18f720\xbb\xd1\x07\x9b\x1a\xb1" +
	"\xdc1[v\x8d|\xf2\xadk^I\xd9\x0fK\x1b7" +
	"\xc0\x15\x8d\x0c\\\xd1\x88w\xf8\xb4#\x1f\x96o\xfck" +
	"\xcd+\xc9o\x96\x8dO\x9f\xc6\xcdpw#\x03w7" +
	"\xb2\x83\xce4\xc6\xf0\xf9\xfd\xee\xa1\xe9\xdf\xfbo\xbbr" +
	"\x8b\xc3'\xbem\x16\\r\x1b\x03\x97\xdc\xe6\x83`6" +
	"\x1e\xc1\xe8\xf7{\xff\xf1\xc1\x7fe\xfc.\xf5b\xe89" +
	"\xfb/p\xc0l\x06\x0e\x98]4(<\x9b\\\x0c\xb7" +
	"eo\xcb\xba\xbc\xf7\xea\xdf\xa5\xee\x9f\xa1s\x16\xc2\x92" +
	"9\x0c,\x99\xe3\x83\xcf\xcc\xc1\xfb\xa7\xeb\x17\xaf\xaf~" +
	"\xe2d\xf7W\x1dV\xcf\xdc\x85p\xcb\\\x06n\x99\xeb" +
	"\x83\xfd\xe6\xe1A\xbc:\xb8r\xd1M\xe3or\xe0\xad" +
	"\x98\xb7\x0c\xfa\xe71\xd0?\xaf\x08\xde\xa7\xf3Vn\x8b" +
	"\xce\x18|\xe96\x07\x85e\xdefx|\x1e\xb9z\x08" +
	"\xe7\xaa\xdf\x1c\xda\xfcyx\xc1\xb6\xe4Y\xeb\x83W\xda" +
	"\xfc\x0d\xd03\x9f\x81\x9e\xf9\xec\xa0a\xf3\xef\xc9\xc2[" +
	"\xe8\xbb\x19\xdas\xdf\x9fMa\xcf\xc4&\xf2\xe2]p" +
	"\xe8b\x06\x0e]\xcc\x0eB\x8bo\xc4s\xb1b\xfd\xc3" +
	"\x13\xf7=\xf7\xe2\x1f\x12\xc6A\xbe\xdd\x8a\x07\x96\xc1\xd5" +
	"\x0f0p\xf5\x03>8t\xc9g\x14\x88\xad\x9ez\xd1" +
	"\xa2yG^\xf9\x83\xc3\xf2yp\x16\\\xf5 \x03W" +
	"=\xe8\x83=\x1f\xc2\xcbg\xe4\xa3oV/\xaeX\xfc" +
	"Z\xea\xfb\xad\x7fh\x19\xdc\xf4\x10\x99\xc1\x87\xf0\xfbe" +
	"}~\xe8\xda\xa9kn\xd8\x9e*u\xcfC\xb3\xe0\xde" +
	"\x87\x18\xb8\xf7!\x1f\xacx\x18K-\xbc\xf6\xfe_>" +
	"z\x1c\xeeHYh;\x1f^\x0c\xdf~\x98\x81o?" +
	"\x8c\x0f\xdeCw\x9c\xe6\x97?3\xfe\xf5\xd4\x1f\xbfl" +
	"\xe9\x06\xd8{)\x03{/\xf5\xc1EK\xc9m\xbec" +
	"\xf0\x1d\xe0\xcc\xf47RW\xce\x9e\xa5\x1b\xe0\xfe\xa5\x0c" +
	"\xdc\xbf\xd47\xe8\xaeed\xe5\xdc\xfc\xc4\xef\xc2\xdd~" +
	"|x\xa7\xc3)\xfd\xc8f8\xe5\x11\x06Ny\xc4\x07" +
	"\xf7>B\xbe\xdb\xa4\x0d\x87f\xdd6f\x97\xd3\xcds" +
	"\xd9\xf2}\xb0\xdfr\x06\xf6[\xce\xc2I\xcb\xf1\x9b\x0d" +
	"\xbev\xfc?\x94c\x1f\xbe\x99:\x0b\x9eGW\xc2n" +
	"\x8f2\xb0\xdb\xa3>8\xefQ\xcc\xfb\xf4\x8a\x82\x7f\x0c" +
	"\xcdfv;l\xcd\xc76\xc0\xec\xc7\x18\x98\xfdX\x11" +
	"\xf4?\x86G1\xec\xddu?\xbd\xe1\xd6A\x0e\xbc3" +
	"\x1e\x9b\x0f\xa3\x8f10\xfa\x98\x0f\x1e&\xbcK\xbb\xdd" +
	"\xe2\xe96Ss\xe0\x1d\xf0\xf8!8\xf4q\x06\x0e}" +
	"\xbc\x086=\x8ey3\x8aJ\xba\xe6\x9c\xbd\xdd\x81w" +
	"\xf7\xe3\x1b\xe0\x9e\xc7\x19\xb8\xe7q\x1f,_\x81y\xd9" +
	"\xef\xee\xd8\x0d\xfe\xeb\xa3\xdd)_\x0d\xadX\x03\xc3+" +
	"\x18\x18^\x81\xbf\x9aRT\xba|\xd9\xd4_\xff)u" +
	"\x0a\xb6\xaeX\x06w\xae`\xe0\xce\x15>X\xbe\x12O" +
	"\x81T\xb1\xf6\xc2\xe7G\xedt\xe0=\xb2r><\xbe" +
	"\x92\x81\xc7W\xfa\xe0\xc4\xdf`\xde\x99\xb3\xdf\xf9\xc3\xe8" +
	"\xfa;\xdeN\x1d\xea\x89\xdfl\x80g~\xc3\xc03\xbf" +
	"\xf1\xc1\x19O\xe0\xa1N\xb8v\xd3\xb3+\xca\x1f\xfd\x8b" +
	"\xc3\x99\xf3\xc46\xb8\xf4\x09\x06.}\xc2\x07\x07\xac\"" +
	"W\x10_\x9f\xbf\xb1\xec\x9awR\xc70~\xd54\xe8" +
	"_\xc5@\xff*\x1f\xdc\xbd\x0a\x8f\xc1\xbb%\xfb\x95\xbc" +
	"]\x8b\xdfq\xb0e\x9e\xdc\x0c'>\xc9\xc0\x89O\xfa" +
	"\xe0\xee'\xb1\xdcK>\x17\xc6\x7f\x1dy\xde\x81\xd7\xf3" +
	"\xd4b\xd8\xed)\x06v{\xca\x07\x17<\x85y/\xec" +
	"O\xaf\x1b\xbca\xd7;\xa9\xabw\xe7S\x8b\xe1\xdbO" +
	"1\xf0\xed\xa7|\x83f\xff\x96\xac\xdeW\xef\xbd\xf5\x9b" +
	"\xd9c\x0f\xfe5u\xc0\x03\xd7l\x80C\xd70p\xe8" +
	"\x1a\x1f\xdc\xbd\x06\x0f\xf8\xf6\xc3\x17_\xaf\xfe\xe2\x8d=" +
	"\xa9g\xe4\x92\xa7\x17\xc2\xe5O3p\xf9\xd3>8e" +
	"->#\x1bV<J\xbf;\xe2\xc9wS\xe5\xde\xf7" +
	"\xccJ\xb8\xf4\x19\x06.}\xc6\x07\xb3\x9f\xc5r#\xa3" +
	"\xde;\xf8\xd60\xe9\xbd\xd4\x97\xbb\xeb\xd9e\xf0\xbeg" +
	"\x19x\xdf\xb3>\x98\xf1\x1c\xd1\xf6\xe9=o6~;" +
	"\xd7\x81\xb7\xf7s\x1b\xe0\x80\xe7\x188\xe09\x1f\\B" +
	"x\x0f\x9e\x19yg\xf0\xfew\x1cx7>\xb7\x18n" +
	"y\x8e\x81[\x9e\xf3\xc1~\xeb\xc8\xce\xdc\x1c\x9d\xf6\xd5" +
	"\xfb\x03\xdew8\xa7\xd7\xad\x81\xfeu\xe4\xb3\x10\xce\xd0" +
	"\xe8\x09\x7f\x1b\xf4\xab\x05\x0e\x9c\xe1u\x8bat\x1d\x03" +
	"\xa3\xeb|\xf08\xe1\xfdv\xec/Ff\xbf4g\xaf" +
	"\xc3\xa1\xb3~\x1b\xec\xbd\x9e\x81\xbd\xd7\xfb\xe0\xfa\xf5\x98" +
	"w\xf8\xfe\x0f\xee}v\xfa\xd7{Sg\xec\xed\xf5\xcb" +
	"\xe0\xde\xf5\x0c\xdc\xbb\xde\x07\xfd\x1b\xf0\x8c\xbdx\xf0x" +
	"\x17\xd7\xb4o\xf7:\xd8\x04\x1b\x16\xc3\xbd\x1b\x18\xb8w" +
	"\x83\x0fF\x9f\xc7_\xa2\xf8\xf9\x17\xfa\x87\x9f\xbde_" +
	"*\xaf\xff\x85ep\xd2\x0b\x0c\x9c\xf4\x82\x0f\xee~\x01" +
	"\xf3\xbaj\xce\xe4\x7f\xfe\xb7\xab?p\xb0\xe76.\x83" +
	"\x9b62p\xd3\xc6\"xf#\x1e\xc3\xf5\xb3_\xbb" +
	"\xe3\xc9#\xcf}\x90|\x96]LQp\xf9\x8b\xbb\xe0" +
	"\xea\x17\x19\xb8\xfaEv\xd0\xde\x17\xbf\xc1f\xcc\xf3\xa3" +
	"nCk\x7f\x0d>L\x1d\xc6\xc6-\x0a\xdc\xb4\x85\x81" +
	"\x9b\xb6\xf8\xa0\xf8;<\x8c\xafo}\xe1\x86mL\xbf" +
	"\xfd\xc9\xa2/\xa0(\x18}u\x17\x9c\xf7*\x03\xe7\xbd" +
	"\xca\x0ez\xe6U\xd9E\x81\xb3\xd7]t\xf8\xe9w\xae" +
	"\xd9og\xd6'y\xe7\x1fV\xc2\xb7\xff\xc0\xc0\xb7\xff" +
	"P\x04\xbb\xbdF4\x98\x17g_Y\xf8\xfe\xf8\xfd\x0e" +
	"F\xcfk\xb3\xe0\xf6\xd7\x18\xb8\xfd5\x1f\x1c\xb6\x1d\x7f" +
	"\x90\xc5\x9f,\xe0\x0a\xb6\"\x07\xde)\xdbWB\xb4\x9d" +
	"\x81h\xbb\x0f\xee!\xbc\x1frK\xfa\xee\x98\xb9\xcf\x81" +
	"w\xf0\x8e\x0dp\xd8\x0e\x06\x0e\xdb\xe1\x83\xabv`\xde" +
	"\x8d\xc3\xe5\x99=\xdf\xa9\xfc(\xd5\xf6\xd9\xb1\x0c\x9e\xda" +
	"\xc1\xc0S;\xf0\xd1\xb7c\xec\xcb\xeb\xca\xef\xee\xfb\xb1" +
	"\x83\x9b\xe1\xf5}p\xca\xeb\x0c\x9c\xf2\xba\x0f\x9ez\x1d" +
	"\x8b\xbct\xdb\x973\x96\xdc_\xf0q\x8a\xc8K\xde\xd8" +
	"\x05{\xbe\xc1\xc0\x9eo`\x91\xab6T\x0a=\x1eX" +
	"\xf2q\xf2\xbc^AQp\xf6\x1b\x9b\xe1\x827\x18\xb8" +
	"\xe0\x0dv\xd0\xfa7n\xc4j\x83\xfc\xa6\xbf\xff\xc3+" +
	"f\x1cHf\xcf\xc2\x1f\xed\xbd}p\xeb{\x0c\xdc\xfa" +
	"\x1e;\xe8\xc4{\xaf\xe3\xa3d\x82\x8fn\xec\xf5\xfa=" +
	"\x07R\x07|p\xdfBxd\x1f\x03\x8f\xec\xf3\xc1I" +
	"\x1f\xe0\x01_v{\xe9\xa8[^\xf8\xe0@\xeaBk" +
	"\xfa`\x16\x9c\xfd\x01\x03g\x7fP\x04\xb7|\x80\xbfY" +
	"\xc9\x15\xbd\x1f\x84\xc3~t\xd0\xe1\xba\xfap3l\xfa" +
	"\x908\xa3?\xc4R\xaf\x94\x0e\\\xf2^\xac\xc8\x81s" +
	"\xc9\x87+\xe1\xf2\x0f\x19\xb8\xfcC\x1f\xcc\xde\x8fy\x7f" +
	"4\xf3\xad\x9d\x17\x0e\xecu\xc8\xc1T\xde\xaf\xc0\x01\xfb" +
	"\x198`\xbf\x0f\xae\"\xbcs\xfd\xa3;\xdf\xb0\xe7a" +
	"\x07\xde3\xfbg\xc1\xb3\xfb\x19xv\xbf\x0f\xce\xf8\x08" +
	"\xf3~y\xf4\x93\x9f<\xa8t\xfe[*\xef\xf6\x8ff" +
	"\xc1\x9d\x1f1p\xe7GE0\xfbc\xe2*\x1c\xf3\xaf" +
	"E\xd7i+\x1dx\xfb}\xbc\x01\x0e\xfc\x98\x81\x03?" +
	"\xf6\xc1\xe5\x84\xf7\xd9_\x8ey\xfbO\xd7|\xe8\xc0{" +
	"\xf8\xe3Y\xf0\xc8\xc7\x0c<\xf2\xb1\x0fN:\x80yo" +
	"\xff\xf3\xdf\xf7/\xe9\xfb\xcf\xbf%\x7f\xb8\x8b\xf0\xfc\x1e" +
	"\xd8\x07\x17\x1c`\xe0\x82\x03\xec\xa0\x8d\x07\xba\xe2\xad\xf9" +
	"\xc6m\xb1a\xeb\x0e=\xfd\x89\xc3E\xf4\xe9|\xe8\xff" +
	"\x94\x81\xfeO}p\xfb\xa7X\xf4>\xff\xb1A\xef\xdc" +
	"\xb8\xe0\xb0\xc30>]\x03\x8f\x7fJ\xae[\xc2\xb9f" +
	"W\xd5_\xfe\\r\xcfa*u_f\x7f\xa6\xc0\xce" +
	"\x9f1\xb0\xf3g>8\xe33\xfc\x8d'k\xa3\xc7\x1d" +
	"\xc9\x98\xf8i\xaa\xcay\xe2\xb3Y\xf0\xd4g\x0c<\xf5" +
	"\x99\x0f\xce\xfb\x1c\xab\x9cK\x03\xe2\x7f\x0f\x88~\xf5\xa9" +
	"\x83Ztt\x0d\xecv\x94\x81\xdd\x8e\xfa\xe0\x82\xa3X" +
	"\xee\x82\x11\xca3K\xb4\x13\x9f\xa6\x9e:\x19_,\x86" +
	"\x9d\xbf``\xe7/|0\xfa\x05\x09:E\xf7\x8c\xd6" +
	"F\x9c\xfc4e\x13M<\xb6\x12N9\xc6\xc0)\xc7" +
	"\xf0&Z\x7f\xf4\xff\xfdm1z\xec3\x87[\xe5\xd8" +
	"J\xb8\xe5\x18\x03\xb7\x1c+\x82\x19\xc7\xf1\x1c\x14\x06\xba" +
	"\x15\x8c\x93\x07\x1fq8\x16\x8eo\x80\xc3\x8e3p\xd8" +
	"q\x1f\\Ex\x7f\xf6^\xb7+\xc4\x83\x17\x1eM\x1d" +
	"\xea\xf1\xe3k\xe0\xa9\xe3\x0c<u\xdc\x07\xc3\x7f\xc7C" +
	"\xbdc\xdb\x03\xdf\x95V\xdd\xfeE\xf2\x07v\xe3o\xf6" +
	"\xe5\xb7p\xd2\x97\x0c\x9c\xf4%\x0b\x17|\x89'\xac\xd7" +
	"\xbb/\xadZ\xd2\xf0\xf1\x17\x0e\xca\xceW\x8b\xe1\x99\xaf" +
	"\x18x\xe6+\x1f\x9cq\x02\x8f\xa2\xd3\x1f\x87\\\xf9\x8d" +
	"\xfb\x9dc\x0e\xfa\xfc\x89\xcdp\xf5\x09\x06\xae>\xe1\x83" +
	"C\xbf\xc6\x93\xfb\xd4{?\xab\\\xd0\xeb\xda\xe3\xa9#" +
	"\x06\xff\x98\x0f3\xfe\xc1\xc0\x8c\x7f\xf8\xe0\xec\x7f\xe0\x11" +
	"\xaf\x8d\xfd\xf3\x8a\xde=\xc7\xff=y\xc4\x9d\xf0\xe6<" +
	"y\x14\xae8\xc9\xc0\x15'\xd9A{N\x16\xb9(\x10" +
	"\x13\x8a\x7f\xf4\xf3\x87\xe6d}\x99:\xe4\x9d\xa7\xd7\xc0" +
	"\xb7O\x13\xa5\xf2t1\x05\xbe\xdcs\xea\x9e}W\x7f" +
	"\xfbe\xea\xa4\x9d^\x03O\x9df\xe0\xa9\xd3>8\xe3" +
	"\x0c\x1e\xc2\xe6\xea.\xc1\x07\xb7\xbe\xfb\x8f\xd45\xe6\xff" +
	"v!\x9c\xf4-\x03'}\xeb\x83\x1b\xff\x85\xa7\xecG" +
	"\x81\x17\x8f\xdd\xb4\xe3\xd1\x93\x0e\x17\xf7\xd9Y\xb0\xe7Y" +
	"\x06\xf6<\xeb\x83K\xcf\xe2)[\xf9U`\xc1\x81Q" +
	"G\x1dx\x8f\x9f\x9d\x0fO\x9ce\xe0\x89\xb3>(|" +
	"\x8fy_\xdf=\xf8\xf4\xca\xc9_\x9eL\x9d\xde\xd5\xdf" +
	"/\x83\xeb\xbfg\xe0\xfa\xef\x8b\xe0\xa9\xef\xf1\xf4n\x1b" +
	"\xe1=\xfe\xed'\xdb\xfe\xe9\xe4\xf5\x8f\xc66\xc0\xd91" +
	"\x06\xce\x8e\xb1pu\x0c\xbf\xddE\xbf}\x0d\xfd\xeb\x93" +
	"9\xdf\xa4\x8c\xe2\x92g\x80r\xc9z\xc0\\\xb2\x1e\xf8" +
	"\xba\xf6\x06\x00\x0fc\xed\xa8\x0f\x9e|\xe5\xcc\xd7\xdf$" +
	"/\xf5\xaea\x006w\x8d\x02\xc0\xe0\xff`\xfb\xfc\xc7" +
	"\x0b\xfe\xd1\xf8Q\xa7\xae\xa7S\xc4v]\x0a\xc0\xfc\xae" +
	"\xcb1\xebr\x00|];\xbb\x88\xe4\x8a\xa1\xff\xef\xd0" +
	"\x84\xef\x92\xf8\xf1\x0bv\x9d\xe8\x02\xdb\xbaNq\x01\x06" +
	"\xff\xa7\xa8\xeb\x0a\x17\xc0/9V\x1b\x99\xc5\xfe\xbfn" +
	"\x0e\xf2'\xd2`C\xd7)4\xe6\xa7AQ\xd7\xe54" +
	"\x91\x7fr;\x87V_\xf7\xe0\xe9\x945\xd7\xf5 \x0d" +
	"\x16v=\x82\xf9\x8f\xd0\xc0\xd7u\xbd\x1b\xe0i\x19x" +
	"\xd5\xf1\xa1;^\xbe\xfeL\xaa\xfc\xbd\x19`W\xd7\xc3" +
	"\x19\x80\xc1\xff\xf1u\x9d\x91I\xe4\xfb\xc6]rTy" +
	"\xaa\xf8\xdbT\xfe\x8d\x99`Y\xd7-\x99\x80\xc1\xff\xf1" +
	"u\x1d\xc8\x10\xfe\xcb\xba\xff\xaa\xfb\xae\x85c\xbeK\x1d" +
	"\x8f\x9f\x01k\xbaNb\x00\x83\xffS\xd4u)C\xc6" +
	"\xf3\xf5\x9a\xab<\x9bN\xde\xfb]\xaa\xfcUY`_" +
	"\xd7\xf5Y\xe4\xdf\xcfd\x11\xe1B(T\x10\x10\"\x12" +
	"\x88xG*rxB\x14\x84+\x01\xf0_\x08\\\xb1" +
	"\xd7\xc7\xff\xf5\x99\xb5r\xee\"\xca\xdf\xc3\x05J\xfa\x82" +
	"\xd8\x93\xdf\xfe\xf3S\xe6\x81\x99\x1fQ\xfe^.Pr" +
	"5\x88}\xf1V\xbf\xf0\xaf\x9e\xca\xbb\x9f\xf2_\xe5\x02" +
	"%\xa3\x01\xb8\x90\xa2< \x8f\x91\xa2a\x8a\xd2\xffG" +
	"U\xacAPD\xa1&\x84(\xa0\x9a\x7f\xfc6V\xa2" +
	"\xaab\x9d\xa4r.\xad\x1eq\x01!\x14\x88\x86\x04\x0d" +
	"\x059\xa98\x1a\xaeAJ\x01E\xf9\xdd\xb4\x9b\xa2\xdc" +
	"\x80\xa2<\x9d\xf3(\xca\x9fE\x03\x7f\xae\x0b0\x0dB" +
	"\x08t\x89o^\x0a\x80.\x89\xaf1\xa2^\x96UT" +
	"\\\x12\xd0DYj\xe5\xbb\\e\x7f\x97\xfe.P2" +
	"\xdcx\x97\xee\xb4Xk\x8e:?',\xaa\x01\xf3\x7f" +
	"-\x8c\x95H\x9cX\xcb\xa9\x1a\x104\x14F\x92V@" +
	"\x01\xff\x85\xd6\xa0\xcb\xbbS\x94\x7f8\x0d\xfc\xe3\\\xc0" +
	"\x03@.\xc0\x7f\xac\xc8\xf3T\xb0\xfez\x1a\xf8\xefp" +
	"\x01\x8f\xcb\x95\x0b\\\x14\xe5\x99\x97\xef\x99W\xe4\x7f\x85" +
	"\x06\xfe7\\\x80\x16kA\x97\xb8\xefR\x7f?\x065" +
	"\"\xbf;\xe1=\xdc.P\xd2\xc5\x1aeP\xa6(p" +
	"\x11\x05*i\x00\xba\xc4\xfd\x99\x14\xc0\x7f\xccA!\x15" +
	"\xf9\xb3\x80+\xd6\xe7\xcd\xffz\xf3\x8b\xa2\xdbn\xa7\xfc" +
	"]\\\xa0\xe4R`\x93\x97\xeb\x02%\x1c\xa0h\xf3]" +
	"\xf13\x14\x05\xba\xc4]*\x0eS\xdd\x14\x08\xa1j\x06" +
	"5j\xed\x9d\xe7j\xe3\x0d\x0a\xd9\x00\x96eN\xae\xb7" +
	"X\x8ej\x91\xa8\xa6\xff\xef\x81\xc0\xe5\x8a\xddX\x8f$" +
	"\xbcR\x98\x10\x0ar\xe1hH\x13#!\xc4ib\x18" +
	"\xa9\xfd9\x05iQER9$\x04\xea9\xb9\x96\x13" +
	"5\x95\x13\xa5H\x94\xfc?\x0e\xd3\x0a(\xb2\x86\xcc\xaf" +
	"\xd3/\xcf\xd3\x8f\xf5\x97\xd1\xc0_i\xfb<\xe3\x0b)" +
	"\xca?\x9a\x06\xfe\xa0\x0b0*\x9aA\xa6\xfc\xe3\xd7_" +
	"8\xf2\xf0%E'\xf4)\xbf\x10OQ\x97\xb8\xaa\xa4" +
	"O\x0a\x1b\x11\x14M\x8d\x7f\x00+\x09D\xff\x00\x09s" +
	"&\x87#\x82\x92#h\xb2\x82'\xcd\xb6\xca\xf3\xe3\xab" +
	"<\x07\xe1e~1\xe5\x02\x17'>]\xaa a:" +
	"\xd5\xde\xd9\x1em\xcdv\x0d\x91c-\xec\xda\x90<\xd3" +
	"\x9c\xeb<\x10\xab\x908\x81SP\x84F\x82&Ju" +
	"\\H\x96#\xfd9\xd4(j\x1c\xde\xaf!\x99\x91#" +
	"\x05\x14e\x0d\x8cb#\xdeJY\xc5\xc3\xb2M\xb1\x97" +
	"\xa2\xfc\xbdh\x80\xcf\x06k\x86\x07\xe0?\xf6\xa5\x81\xff" +
	"j\x17(V\xe5\xa8\x12@\xa9\xb3Y,\xd7\xd6\xaaH" +
	"K%\xd8g\xa2\x0ai\x82RG#\xb2\xf4\xb2\x12&" +
	"\xa3\x0bY\xca\xb6\xc9\xd0gG\x7f\xd911\x85<\x89" +
	"\xf0\xe2\xd2\xffT:\xa7N\x11\xc2aAI<u\xcc" +
	"\xef\xd1\xcb\x05r\xd4\x88 \xc5?\xafe.\xa4~\xde" +
	"\xf1\xc2tT\x85\x8a\x1b\x90\xa2\xa2`{\xbfS\xbd5" +
	"0\x05\x11I\xf1}Q++a\xc1\xda\x17\x17\xd3\xb1" +
	"*c\xe9_ \xa1\x99\x9c\x86\x1a5\xae6$F\"" +
	"(\xc8\xd5\x08\x81\xe9\x9c&s\xb5\x8a,i\x05\xdcH" +
	"Y\xe1P\xa3\x10\x8e\x84P\x7f\xae\x0f\x0aE\"%}" +
	"0-\xcc\xf5)\x89DB\xa8O\x7fNV\xb8>\x92" +
	",K\xe6\xdf\xc9\xbfA\x81\xf3\xb4\xe0e\x8a\x7f/i" +
	"\xb9\xdb?\x13U\x1c\xf1\xf2Hj\xf7<T\x02s\x81" +
	"\xaaH\x0a\xc6'\x015 IS\xcdI\xd8\x00b\xd5" +
	"\x8aXW\x87\x145\x83\x138B\x8c\x1f\x09\x02\xa7)" +
	"Qte\xad\x10R\x11\xa7F\x03\x01\xa4\xaa\\\x03+" +
	"\x84\xa2\x08\xbf\x98\xed\xc0.\xf4\x94\xb3\xfe \x0d\xfc\x11" +
	"\xdb\x82\x0d\xe7{\xc2\xac\xffn\x1a\xf8\x1f\xb6\x9d\xd8K" +
	"\xf2=KX\xff\x0b4\xf0\xbf\xe5\x02,\xf9ErV" +
	"\x08#\xf6>v\xe3ov\xfe:\xf1x.\xd49\xc8" +
	"i\x9a\xb4\xa2s\"\x82V\x9f\xf6d\xd7d\xf2\x9c\x95" +
	"\x80f<'(uj\x9a\xe7\xf2\x09\x83\xfdN\xb0\xd4" +
	"\xc2\xa45\x8b\xf7\xee8\xd4\xee\x8br\x9cu\xe9\x87\x90" +
	"\x14?PB\xa2j-\xd2\xc9 V\x864\xa4\x84E" +
	"\xc9\x8dTr\x82H\xe4\x96\xc7'u\x03\xfe\x10\xe4\x94" +
	"\x16\xb8\x90\xa8\xd2Z\x9a\xd5\x86\x85\x82.q?Z\xea" +
	"\xa1P!\x05B\xd1 \x8dT\xe7\xd7\xe9o\x7f\x9d\xbe" +
	"\xe9t\x981\xb1\x80,i\x82(\xa9\xb6SB\xd5\x14" +
	"Q\xaa\xb3\xb4\x98C\xb1j%\x8a\xb0\x0e\xe0\"\xfb\xce" +
	"|\x82\xd3\x10\xd3H\xde\xc3v\x18\xe6;\x1d\x86\xf9\x9e" +
	"\x01\xac\x7f\x1c\x0d\xfc75\xbb\x97r\xf0\xcd\x92\xf6C" +
	"c\x06\xb2D\x9a\xdb\x85 \xe2\xbd\xb1^\x0c!\xaa\xbd" +
	"\x93r\x130u9\x05E\xc8\x95@\x81:\xe7\xcb\xe3" +
	"\x10\x88\x8dE(\xc2)Q)S\xc2W\x87\xc0\xa9H" +
	"\x11\x91\x8a\xbf\xb5@T2\x95\x9b\x89G\xc3\x09x\xc2" +
	"\x82\"\xfe\x13'\xaa\x9c\xa60\xfa\x8eli\xd2\xf2\xcc" +
	"I\xab\xc7\x93\xa6D\xd1\xb9V\x97\xec\x13\xc7\xcb\x8a6" +
	"!\xca\xe2\xd5\xaa:_4=\xec\xd3w\xa9\x0b\x94\xf4" +
	"\x8a\x1fZ\xb2\xa2%o\x09\xfb\x81\x93\x87\x0f\x1c\xac\x0c" +
	"j\xb6\xf7\x9b\x91\xef\x99\xc1\xfa\xef\xa5\x81\xff\x11\xdb\x81" +
	"\xb3\xb4\xd0\xb3\x94\xf5\xbfL\x03\xffkX5\xd1\x14\x87" +
	"\xe3&\xd7Z\xbb\x96\xca\x8d\xa7#\xe5\xc8\x91\x84p\xfa" +
	"\xd9\xa9ir:\xaaXY\x09\"%\xcd\x83\x85:\x07" +
	"y\xd6r\x82&\xadEW\xc4;NT\xb5\x0a\x0d)" +
	"X\x03\xaa\x08\xd3\x91\x10Q\x83\x80\xcb\xb6\xe8\xdcd^" +
	"\xcd]6\x1a\x85\"H\xe1j]\xb2\xc2\x09\xe4\xfc&" +
	":\x89\xa82\x9aj\x1c\xe1\x17\xc6b\xb6)5\xce\xf0" +
	"\xce\xe0\xfb\x98q\x88\xe7\xd9\x0e\xf1\xce\xae\xb31\xe3\x14" +
	"\xcf3O\xf1\xdf\xbb\x006Z\xd2\xee\xb3\x09\xd1\xb0\x97" +
	"\xbc\x9be\xaf\x1a\x8bMA\x81\xb4\x0fV\xa1\x80\xfe\xa0" +
	"\x15\x143\x1e\xd4\x1a\xd3\xef\xec\xeaFM\x7f\xd02\xff" +
	"Swv5j\xd4\xc6\x89\xc5\xaaV\xde \x84\xda\xa1" +
	"P\xe2\xe7\xcb\x1b\xe8v=\xcbkr$\"\x16Ku" +
	"\xd5\xcdZ\x00-\x1f.\xf5\xd6\xaaU\x898\xa9\xce:" +
	"q\x93\xad\x80]q+\xa0S\xaa\x15\xd0\x0a#\xa0?" +
	"\xa7jb`:^>\x9a\xac\xab\xb2\x82\xaaq\xb2\x84" +
	"\xb0\xed\xf6?n\x1d\x18\x9b\x83'jqE8\x12\xa2" +
	"\xa8s\xb97\xf2\x9d\xf7F\xbe\xf3\xde\xc8\xb7\xed\x8d\x1c" +
	")\x1aV\xd3\xee\xfc\x09\xd1\xb0\xaa\xafU+\x08n\x9c" +
	"6\x0a\x0a\xa4\x7f\xb4\x0a\x05\x8cG-W\xa6\xf1\xa8\xd6" +
	"\xa8\xa5\x7f\xb4\xbaQ3\x1e\xb5\x82#N\x86B@V" +
	"\x829\xed\xdc\x1f<\xd2\xaa\x15\x81\x16\xb5\x8e\xda\\y" +
	"\x8c\xb5\x92\xb1.!\xd7LC\x81\xb8\x0e\xeb\x05\xb1\xca" +
	"\xa8\xc6\x09\x12'\xd3\x84\xc2\x89\x92&s\x02\x87\x97\x8e" +
	"\x18\x88\x86\x04\x85+V5AK\xbe\"\xbdx\xa5\xe2" +
	"EYm[\xa9\xfeB\x8f\x9f\xf5Gh\xe0\xbf\xcd\x05" +
	"\x8a\xf5\x9fJ3\x91y\x8c\\3\xcdI\x85`5E" +
	"\x10\xb5\xb4\x9f\x80p\xb4\xa4~L \xea\x1eE\x9dS" +
	"\xcf\xd2\x98XH\xc4\xd7H(\xae\xa2\x1d\x8d\xf1\x11\x14" +
	"\x10k\x9b8W\xc2\xccI\xd1pNz\xaf\x92\x14\x0d" +
	"\x83\x0b(\x17\xb8 Y\x9f\xd4\xe4\x1b\x04\xa0t\xd4\x80" +
	"\xc9c\x1a\xb0u\x99\xeaG\x1a\x08\x16\x82X51G" +
	"U.\x03\x7f~\xfd\xeb\xcb\x0a\xa7\x90u\xcb\xa9\x9a\xac" +
	"\xa0\xa0\xae \xc7]i\x09\xef\xe1\xe9\xcc\xfa\xaf\xa2\x81" +
	"\xff\xba\x8e\xaa\x06\xf6\x93\x08\x1b\xb2\xe3\xe4\x99H\x09\x08" +
	"*j\xb7\xc7!h-\x94\x10\x96\xd5\x9c\x1d\xfb\xb5\xcb" +
	"\xb2c;\x99vl\x7fn\xa6\xa8\xd5csNi\xe2" +
	"BH\xd3\x90B\x0eq2\x19\x9a\xcc\x85\xcc\xc1%\x9b" +
	"\xb6j\xbd\x1c\xd5L\x13\x96\x1f\xcd\xfa&V\xf7i\xbf" +
	"\x0d\xeb2O\x10|4\xe3C\xc48\x94\xdbv\x8c\xe0" +
	"\xd9\xe4\xf1U\x89\xd7c{\xaf\xca\x9b\x8d\xc9\xac\x89\xe1" +
	"S\x1eK\xa2\x18qV\xb3\xce\x81\xbc\xf8\xa42\xf8\xae" +
	"3\x1f\xe20\x1b\xd1\xc7\xb9H(\xaa\x08!n\xa6\xac" +
	"\x04\x0b\xb8\xbe\xa8\xb1\x80\x13\"\xf8B\xad\xc5\xd7\x09\xfe" +
	"\x17\xa3r\xfd\xda=u \xe2\x1d\xa5 AC\xacR" +
	"]/H\xad|\xed!\xf6\xd7\xbe\xdaf~\xd4\xc4\xea" +
	"\x884\xa5\x9ab\xea\x05\xcb\xd8\x9c\x1c\x0b\x10\x97\x9a\xa8" +
	"R\xb4,\xd9\xb7U=\xe2jEE\xcd\xd0t+\x13" +
	"[\x19!\xbc\xd5\x14N\xab\x17$r\xff\xab\x08\x1b!" +
	":\xbd \xf1\xabW\xa8\xe5\x8dB@\x1b+JA_" +
	"-\xd5Q\xfb\xd8[<]\x17\xd4\xdc\x0d\xa0\x00\xcb\x9c" +
	"t\xe3\x91\x19\x07\x81\xa8\xe2\x95\x1d\xd0BM\xba\xe1," +
	"\x84Q\x90c\xb1\xac\xe4\x8b\xa0Y\x03\xb3\x92\x06\xfe\x9b" +
	"\xad{\xc0\xc1\xc4\xc4\xd2\x1c\x0ey\xf3\xd0\x98\x1c\x13\xd5" +
	"[\xc9 (:\xe4h\x1a\xd8\xbfx\x89\xd4dLW" +
	"\x1bl\xa5BV \x8fQi\x1dr\xa5q\x87\xdc\x1c" +
	"9Bl\xc9V\xf9\xe4\xf4\xeb\x07\xa8\xed\xbd~\xc6Y" +
	"\x1a9\xd6\x83\x9a\xbd\x7f\x88\xeb\xd4\xbc\x80h\xe2\xce\xd0" +
	"\xf06\xb3\xd4T\xe2\xf5`\x145\xe90\xf2\xc6_\xab" +
	"Xw\x87\x98o\x85o\xa4\xa4w\xa9\x12\xa4\xba\xf6\x1f" +
	"\xc7e\xd6|+D\x8e\x83\x0d\xef\x01\xdf\xc6F!\x09" +
	"\xdbg\xc8\xa5&\xd8\xefR\xb4\x98\x18\xc2I~3\xc7" +
	"@G\xbe\xa7\xa2\xc8\x7f\x07\x0d\xfc\xf7\xda\xac\xd8E^" +
	"\xcf\xa2\"\xff\x1b4\xf0\xff\xd5\x05hMN\x0d\xe4\xe4" +
	"\xe0S\xbb\xad\xa1\x0a\xfc\x0cY\x96I\xc2\x8ak\x9ax" +
	"\x0dE\xda&\xaetNM\xd3\xad\xaa\x86\"N\x12\x13" +
	"\xce\x07I\x93\xf5\x9b{\xa4\x88BtPm\xe7\xb5P" +
	"\x19\xca\xc1\x87pG/\x85\xaa\x98~\x98\x8b\xb3(\xd0" +
	"\xec\x95\x90\x9ft%\x18\xe7\x7f\xfcB\xb0\xee\x88\xe4+" +
	"A\xb5\xee\x84\x1cT\xd0\xb1;\xa1R\x11%m\x02\x1d" +
	"mw\xa0\xb1\xd2\xf2\xc8I\xd10\xde\x81\xf1-\x19\xc1" +
	"\xb2\xe36\xe4@0\x06\xc4nTD\x0d\xa9\x9c\xe06" +
	"\xdd\x8eQb$\x19\xcf\xaa\xfd9TW\xc0\xf5\x19\xd8" +
	"\xa7 I\xadJR\x0f\xd3\x06\x1d\xcb\x15AE\x159" +
	"R\x105v<8\x83\xb00gm\xb1\x10\xc4\xaaP" +
	"Xn@\x9cLK\x08\xab\x89aYA\xa6\x17\x95\xa8" +
	"<\x02\xcb\xa5\xba\x9a\x0a\x9b\xd9\xa3q\xff\x93\xb9Gg" +
	"\x94zf\xb0\xfe\x07h\xe0\x7f\xdc\x05\xd8\x80\x1c\x95\xb4" +
	"\xe6\xb6i:\xdf\x85\xb5'\xad\xa2J\xfd\xc99\x82V" +
	"\x81g)\xcd}3&&h\xb7\x8a\x98IWR\xd3" +
	"L\xbb\x1eF>\x17\x86E\x08i\xad\x0dY\xc7\xf5p" +
	"\x8e\x98h\xc5\x0df0!\xd9\x83`\xb8v\xad\x19\x9f" +
	"\x98\xef\x99\xc8\xfa5\x1a\xf8\xe7v\xd8\x8b\xd7\xc2\x17\xe8" +
	"N\xd7\xe8\xe1\xdb4\xder=R\xceLh\xf5NL" +
	"c\xdf\xd8\x0c\xb3\xfc\x9c\xb0\xa0\xd5\xdb\x14\xb1J10" +
	"\x9d\x93%\x94\x81\xcf\x18m\xa6l\xecC\x95\xab\x11T" +
	"\x14\xe4dl\xda\xd4\xc8r\x08a\xa5\x0c\xa9\xc9\x81\xf4" +
	"|\xa7\xb5\xdb\xddq\xed\x16\xda|\xa7\xa6o8i\xf9" +
	"\xd0bm\xdai#\xf1\xfe\x14\x8f2K\xe2GiW" +
	"\xbc\x150O\xb3^\xabPX\x10%6\x88\x14_m" +
	"\xc7\xe7<,\x07\x9d\xe7|\x1b\x88\x95\x89\x0db\x10q" +
	"r\xa6dE[j\x9a8A\x92\xb5z\xa4\xf4\xe7\x04" +
	")h\xf8\xcb\x88Z\xa9\x90q\x05\x89\x89\x9c\xb0\x8c/" +
	"v\xd2*/\xb6\x85-\x80\x90\xfa\xc6\xa0\xa65\xee\xe5" +
	"4\xd3\xa4{\xc1r\xa2J\x00\xb5\xc7e#\xd7j!" +
	"\x91\x96P{O\x85jk\x86g\xd6(i\xee\x96e" +
	" \xc6k\x82\xa2q\x02\x97\x81\xad\xd6\x90(!\xae/" +
	"\xd6\xe0%Y\xe3\x84\x90\x82\x84`\x13'`\xbaI." +
	"\xa0\xf1\xdd\x99`!!\xadD\x1b\x99#\xa2P\xb0\xe3" +
	"\xa7X]\x0b\xa7\xd8\xbe\xd8(\xa4\x11G\x82\x0b\x1bD" +
	"\xfa}\xa1{\x1a\xe8d\x83\xa2\xb0\xa5\x88\x15[\x8b\x07" +
	"\xdd\xf6\xa3\xc9v9X\xa9J\xa9k`\xa4\"\x87;" +
	"\xe2z\x19\xdd\xb2\xeb\xc5\x1bw\xbd\xd0B3\xfe\x96b" +
	"2\x85\xc9\x9e\xa3s\xefq\xc1:\xc4\x8c\xa8\x10\xaa\x06" +
	"rG\x97A\xe9\x1cD$\xc9\xe9,d\x0f\xf8K\xac" +
	"z\xa6L4\x07\x17\x8a\x1b\x99aA\x0b\xd4\x83\x82\xc4" +
	"5\xca\x87\x04\xb5\x9ej\xaf\xfd^mi\xa8*\x96S" +
	"\x8d\x1a)\xa0\xa5\xd9V\xb3@\x8cG\x11\x01\x1b n" +
	"\x95(\xa2\xaa\xee\x0a\x0a\xa1Zm\x00\xbe%\xb0\xfaF" +
	"d\xa1b\x95\xebse\x1f\xa7\xcf\xd3\x9f\x06\xfe\xd1\xae" +
	"s\x15\x0a4\\\xf3\xfar\xf9Ou\xcd[%\xa9m" +
	"w\xcd[i\xe4mw\xcd[5\xdb\xa9+\x9e\xaf\x8f" +
	"\xd6\xd6\x86XT}\x0e2\xc8J\xe7\xa8DZ\xb39" +
	"d\xbb\x80\x15=\xcaL\x13=\xb2E\x8d\x04\x8dS\x04" +
	")(\x87\x7f\x10\xd1!\x10\xf1\x96E\x15\xb2Q:\xea" +
	"\xc8\xf0\x16\x07\x0dI\xd6&\x144\x0d)R\xdc\x95\x91" +
	"\x0fbe(\x80U\x88\x99t=\xc2J\x03\x09F\x10" +
	".NT9%*I9\xa2T\x97\xb4\xf5J\xcd\xad" +
	"7\xc4\x05\xe6\x18\xeci2cJM\x9e\xb4^%\xaa" +
	"8\xe2\x9d G\xa56\x07\xe0%9*\xb5\xe0S\xb2" +
	"+\x14\xd3E)\x98\xfe\x88\xc66\xbf\xaf\x06L\xeb\xf8" +
	"\xa5\xa4G\\\x1c.\xa5\xd2\xf8\xa5\xe4\x8e\xc7\x03\xc8\xf9" +
	"'p\xf8\x1c\x8f\x92<Y!\x8c\x88\xae\xe6\xe0G\xca" +
	"M\xe3\xebKTF\x1b\x90\xa2\x02\xd4\xc6iMIJ" +
	"kff\xc7\x903\x0e\xe0;!f<\xa1R\xf6\xb3" +
	"\xb69\x8f\x1d\xc5F\xbc\xbc\xd0\xd4\xd1E^:G\x15" +
	"\x9a\xf0\xc9\x92\xe6\xaa)\x041\xe2\x8d\xe0T\x99\x0e#" +
	"\xaeF$\x0e;\x92\xcdc\x04\x88#!VhJ\x09" +
	"\x1d\xb5\xcd\xe1\x81U\x99j\xc44jjG\xaf\xf6|" +
	"r\xf0\xa6U\xf1\xben6\xb7ZcQ\xa3\xa6\xa6y" +
	"\x93\x06!\xa4\xa6\xa6\x9a%\xd8\xdb!QP\xdb\xe1\xdc" +
	"%\x8f9,\x17\x07us\xb8\xedL\x1d\xe6\xf5\x0cc" +
	"\xfd7\xeb\xb9>,^\xf3\xb6s\xd2\xbeM/\xa2@" +
	"\xb1\xa0\xe23\"\xcd\xa5T:GPo5\x8e\x84\xb4" +
	"\xbb|\xb4\xa0\x96\xc9aV\x94\x8c\x04\xf26d\x97\xd6" +
	"\xc4\xea\xc9\xc3\xa2D1b\\\xd7*dCr\x9d\x18" +
	"H\x9az\xdbY\x19O\xcaq>(\xbd\xc5A\x19\x9b" +
	"h-\x0d\xbd\x0a\x85\x04M\xcci@\xcd\xd9\x97-\xab" +
	"kA[\xa2,\x16\xd6\x80\xac\xf8j\x95\xf1'Y\xb2" +
	"\x16\xdc@P\x15\xf7)f\xe9\xb6\xa4\xfe\x94\xeeP\xc4" +
	"\xf3\xad\xbb\x111MO\xbc\xd5)\xb2\x84\x06h\xf2\x00" +
	"Y2\x1f\x91\xa5\x02\xd0/\xc5\x8bR\xe4\x0f\xd1\xc0\xdf" +
	"h[\x15Q\xaf'jy\xa8\x88\xfa\xed\xb8\x18\xe3\x13" +
	"y\xa9\xed\x03\xe51\x0a\xb2\xf9\x0b\xad\xf7qR\xce[" +
	"\x8e\x9c{\x0d\x96\x96\x02\xe0z\xfe##6g\x93\xb6" +
	">\x08V\x15\x0b\x1a\xb9\x9467\xaf\xc3\xfd\xbd\x10\xc4" +
	"\xaa\xa2$\xfd5\x92\xa1\xd3t\xa3?\"kH\xd2D" +
	"!\x14j\xb2\xa5\xc8\x9a\xf1/\xfb\xdc\x97:f\x16\xe4" +
	"\x9b\x99\x05ww\xfc\x82?wI\xac \xe2\xbd\x11\xdb" +
	"\x09m?\x9a\x88y\xd1\xc2MV\x18\x0f\xd0\xe8\xfc\xcd" +
	"\x1eB\xa9Q\xe3\xf2\x06!\x94\xce^\xe0\x8c\xefu1" +
	"\xf1%\x90B\x12Z#)\x92\x81z\xd3Cc\xda\xa6" +
	"$\x13\xbbG\xdcl\xd8\xa8x6\xb1\xfe\x0fi\xe0\xff" +
	"\xdcn6\x1c.\xf5\x1cf\xf9,@\x03>\x17\xd8\x0c" +
	"\x07\xe8\x01c\xe0%\x80\xe5\x87`R\x19&\xd1\xdf\xc5" +
	"r\x01MQ\xb0\x04\x8c\x81\xe5\x80\xe5\xeb1I\xc3$" +
	"\xf7\xbfb\xb9\xc0MQp\x06\x98\x0c\xa3\x80\xe5\x1f\xc6" +
	"\xa4'0)\xe3\xdbX.\xc8\xa0(\xb8\x02\xcc\x82\xab" +
	"\x00\xcb\xbf\x89I\xefcR\xe6\x99X.\xc8\xa4(\xb8" +
	"\x07\xe4\xc1=\x80\xe5O\x02\x1aT\xb9\\ \xbelY" +
	"T\xe2\xfc\xd9M\x93y\xbe\x95.\x0c\x90\x17\xaf\x00/" +
	"EV\x8f\x05^fx\x92\xeb\x906\xd2\xd9\xd3\x90k" +
	"m\x96QH\xf3\x12o\x03\xd0\x8d\x11\x0b\x91\xcf\xd8\xa3" +
	"\xd8\x9a\xd3=\xcdT\xda\x08(\x96#JAD\xd1\x8d" +
	"\xba \x0b\x85\xc1\x10\x14\x16\xa6\x93\xf7jI\xd0xa" +
	":y)\x8a6\xcc#\xabL\xd9\x10\xa4 )\x88\x94" +
	"\x12\x85\xa2\xd3N\xd2\xb4X\x15a\xf4\x0aT\x8e>E" +
	"\xa0K\xbc2.AV\x15\xa2\x8akG\x86\x04Gy" +
	"\x97\x02\xb3\x9c\xa9\xca`\x06\xb5\xdeZ\xcc\xec\xc5B\xcc" +
	"\xc2w#c\xb1AP\xd2\xee\xd7\x1b\x04E\x1f\x89U" +
	"*\xe8\xe0u\x96\xc3a\xac\x0d\xb4\xf7$\xac\xb4>n" +
	"\x00Kj\xd1\x9dP\xda\x9c;\x81<\xae\xea\xc7b\x1f" +
	"A\x0a\xf6IV\xa8\xcf\x83\x1f\xc1\xba\xa2\xe96\xab\x16" +
	"\xd3\xe2\x97U\xce\x04!\x9c\x12 \xb2\x9f\xdd\xdd\x1d-" +
	"\xd4<\xcf\xf8\"\xd3;N\x0bZ\xf3\x16\xaa\x85<l" +
	"|\xf6\xf3x\xc7&h\x97\x01\x9d\xad\x8d\x87xwZ" +
	"h\xe9\x04\xb7\x9bFz\x16zKj\x14\xde\x0bd\x9a" +
	"[\xf9\x95\xfa[;\\\xdft\x13\x04\x8a\x0e\xdb.h" +
	"Q\xc2\xb7 \x09U6\xa7~c\x150\xfd\xb0\xf4\x80" +
	"\x0d{\x03\xbe\xad;j\x826W\xd9H\xdc\xa2fi" +
	"#m\x946\x1a\xfe79 \x848\x01\x9b\x17\xc5\x92" +
	"^\xf1H\xf9s\xad\x97\x99\x8dg\xb9\xd1\xa8m4\x17" +
	"\xdd\xbc|\xcf<\xd6\xff8\x0d\xfckm\x81\x9a\xd5^" +
	"\xcfj\xd6L\x04\xf0\xd04\xb9\x84<o\xe7y\xdef" +
	"\xfd_\xd1\x80\xbf\x10\xb8\x80\xc7\xed\xd6/\xa0l\x90\x0f" +
	"\xb3A\x11_\x86o\x99J\x80?!\xb1p:\xe4y" +
	"N\x0a\x8b\x15\xd7\x8a!-mv{\x1e#\x90\x12\xa4" +
	"\xff\x94\xda\xcc2\xb1\xb6\xd6WKQ\x1d\xad\x80\xcdc" +
	"\x82(\xe0\x14f\xf2\x80\x0d1>Z\xa3)B@\x03" +
	"fX\x8f5\xf3CZ\x11C*2\xe3w\xcd\xc4\x90" +
	"\xda4)\xad\x09+\x95Fkk\xcd4\xd46m\xe9" +
	"\x1a\xf2`5\xbe\xfd\x9do\x9a\xf3\x7fk\x8c\x17\xb4@" +
	"=j\x7f\x0eS\xd0R\xc8\x89\x87\x1f\xd9\xd2\x98\xc8\x1f" +
	"\xec7\xe6\x1a\x97\xa5\x81e#n\xa6\xe1\xfe#\xe9r" +
	"$\xbbIDA\xddG\"\xaa\x9c*\x86\xc5\x90\xa0\x98" +
	"\xee\x928\x83\x82\xf4D\x12\xd4\x18Q\x90\xaa\xe6`\xf3" +
	"\xae\x15\xd5=\xa5-\x97D%\x98\x1d-\x94\xcd\xa5I" +
	"p\x9d\x10\x0d\x9b)\x9d\x15\xe1\x08h\xa6\x0c\xa5\x17\xb0" +
	"\x8a\xd8L\xfd\xdc\x9d\xaa\x9f\x9b\xa9^z\xa4\x95&;" +
	"\xe0:KQ\x87K\x80\x02\x97\x02\x96\x7f\x05\x9f`o" +
	"\x00\x9b\xb2\x0e\xb7\x83R\xb8\x1d\xb0\xfc\xe7\x98t2A" +
	"]?\x01\xf2\xe1\x09\xc0\xf2]\\4\xe0{\xb8\xec\xea" +
	"z7W!\xec\xe6b\xf9!\x98T\xe6\xb2\xab\xeb%" +
	"\xae\x1aX\xeeb\xf9zL\xd2\\vu}\x86\xab\x0a" +
	"F],\xff0&=\xe1\xb2\xab\xeb+\\\xf3\xe1*" +
	"\x17\xcb\xbf\x89I\xefc\x12s:\x96\xab#/\xbb&" +
	"\xc3\xbd.\x96\xff\x0e\x93\xb2h\x17\xe8\x9c\xf5M,\x17" +
	"dQ\x14\xcc\xa0g\xc1l\x9a\xe5\xaf\xa2i\xc0_\x87" +
	"I\xd9\xff\x8c\xe5\x82l\x8a\x82C\xe9B8\x94f\xf9" +
	"\x9b0)\x88I\x9dN\xc5rA'\x8a\x82\x02=\x06" +
	"\"\x9a\xe5\xef\xc4\xa4\x070\xe9\x82\x93\xb1\\p\x01E" +
	"\xc1\xfb\xe8\xc9p\x09\xcd\xf2/c\xd2k\x98t\xe1?" +
	"b\xb9\xf8\x0b\xc0\xad\xb4\x02\xb7\xd3,\x7f\x0c\x93Nc" +
	"R\xe7\xafc\xb9\xa03E\xc1S\xf46x\x96f\xf9" +
	"\xben\x1a\xf0W\xbb]\xa0\xf3E'b\xb9\xe0\"\x8a" +
	"\x82\x03\xddyp\xa0\x9b\xe5+1\xe9f\xf7\x0f\xd5\x0e" +
	"iK\x14\xc7B\x8b7\xc2\x07$\x93/\xad\x8f\x82\xe4" +
	"\x0c\xea\x0f[\xf0\xf1\xa6\x85\x80I\xa5M<\xc5h(" +
	"\x92\xe6\x0d\x94\x98.\xa4\xa6\x89by\x0dE\xd2H\x1b" +
	"\xa9\xc8\x14H7\x1b5\x86\xacZ\x85b\xe4pzI" +
	" \\Jr\xf8\xa84\xa6\xcb2K\x1e\x90\xc3^\x92" +
	"\xf3G77\xc0\x1f\xb0q\xc5\xaa!1\x90\xfeC\xf2" +
	"\x98C\x1f\x8d\x05\x8cc\x8c\x86<\\\x8e5\x94\xf4\xf6" +
	"\xa7.\x02I\x14\x1dL#\x88\xd7\x04\x8av\xac;\x8d" +
	"O\x91.I\xd5\xa8\x1cA\xd1Z\x90\xc5*Z\xb9c" +
	"\x8eq|\x86Lq\x00KCR\x90\xccP\xaa\xc4\x88" +
	".\xd2%(\x9a\x9e\x08W!\xa9H\xd1\x9c^:\x1e" +
	"\x8a\xe5#\xbap\x97\x86\x85+\xe49\xaf(\xa9\x881" +
	"Gn\x01\xf7\x9c[C7\"(9\xa8\x03\xf9U\xf1" +
	"xQ \x1cIq&\xc7\xb3\x18\x8c\xc4q\x1a\xcd\xe8" +
	"/\xa1\xfeuZ\xff\x90\xd6\xbf\x0e\xf5\x0f!C/s" +
	"\xcc\xdb\xbd\xb8\xf5yU\x17\xdb\xf2\xaa\x9c\xb45ZT" +
	"\xd3'U\xa9d\xb2\xac\x069\xad\xc8\x132S\xca\xd2" +
	"jt\xf8\xdc\xfd_\x13\x8f\xd3A\x0c@{`AJ" +
	"B3\x85&\xb5\xe3\xca\xbe\xb7X0$9,5\x0f" +
	"Xcy\xfa\x81\x86\x97\x9c\x10\x9a\x99#4\xa9I\xd9" +
	"\"$1\xba\x91\xd5\xb0v\xd5\xd1\x01%\x06\xbc\x12\x11" +
	"x6[\x1f\x06\x98\x1aX\xb1\x1e\xbc;\xef\xd9:." +
	"\xf3k)\xfcLQ\x0b\xd4\xb7\xd6e\xd17\x1e\x12\xab" +
	"\xd5\xe2\xe5P\xc9\x09:\xc9\xb9p\x15Z\xb1^/\xdd" +
	"\x8e\xa5Q\x85\xd4\x88,\xd1*jo\x82\xf98[<" +
	"\x08\x8bRQ\xb3\x05\xba^`\x95\x0e\xd0\x86\x85` " +
	"\xc9\x84\x84\x00\"\x19\xb3\xe1bA\x92\xf4xj+\xd0" +
	"\x11,\x13\xb1\x19\xe7\x08\xb1\x10\xdaj=\xeb+$}" +
	"\xc9Wbr\x7fqP\xad\x08\xb7T\xa8\xbe/!\xe3" +
	"GE\x1a\x81\xce!9r\xb4i\x12\x9b\x9e{=\x85" +
	"\xc4\x08\xae\xc4=\xf7\xfe<[\xdd&>\x92\xd2\xdeA" +
	"\xbe\x9ai\xfa\x1dduBi\xeb\xe5euirJ" +
	"\xb88\x0799\xf99\x92-\xfe\x9e\x88\x14\xb1+\x0e" +
	"3\x94\x99\x003\xa4)F\xa9\x13Y?\x04(@\x94" +
	"%\x12\x97'\xd8Cr\xa4 )[\x14\xa9\xaaOa" +
	"I\xfa\\GS>\xbd\xc5\x826^V\xb5\xf3Z\\" +
	"f\xe9\x06\x1d\xcb|\xaal\x85r\xb0,\xae\x1cd8" +
	"+\x07\x06\xa8\x09\xd7\x97\x0b\xa1F1 \x84\xf4\x14\xd5" +
	"s\xa5($\xed\xb1\xf3\xa2(h\x8d-\x06`KB" +
	"\xa1vU\xa5\x91\xc7Z\xe7[\xee\xe5\x02\xc5z\xadT" +
	"+S\\P\x87k\xcaK\xe7\xe0k\x8fG\x9a3\xf0" +
	"\x8e\x17\xc4|\x0dH\x99\xa9\x88\x1a\x8d8A\xe2P\xa3" +
	"\xa8\x92\x9df,Y\x89\x13\x8a\xc9\xcd\x99\xa4\x19:f" +
	"\xdc\x17:~p;Z\x89\x09\xd0\x93\x9c\xe0&6S" +
	"\xf0\x11\xb7n\xcdj\x8f\x8e\x14\x9a\xa4)t(\x13\x15" +
	"\x14\xd0\x18\xb1\x01\xb51\xe6R\x15\x0b\x92G\xc5\x06[" +
	"\xb4\xbd\x99\x04\x96|\xa7\x04\x96B3\x81\xa5\x11O\x0f" +
	"\x0a\xa2fC\xc7\xac\x1a\x10\xa4\xf4>\x00\xc2\xd1\x9a\x0c" +
	"*C3\xaeBl@V\x82\xe7 \xebHA\x81t" +
	"YG\x03\x81\x0bXiGtR\xda\x91\x1e\xbbV\x93" +
	"\xb5c\x87\xc4#\xab\xb9\x9f\x83-%DDM\xc8\x09" +
	"\x89\xb3PGQ\x8c&\xc7\x02DXH\xa4\xe8\xe6\x8b" +
	"\xa7\xbf\x05\x96\xae\x9b\x99T\x91\xae\x19G\xbf\xe6T\x95" +
	"\x1e\x8dDP\xb1^\x96\xde\x91\x94\xb1RY\x0e\xb5\x17" +
	"\x96\xa5\xbc\x11\x05\xa2\x1ahO\xe9\x84\xee\x13e\xdb\x0b" +
	"&\x83\xb5\xa6\x09Q6\xdc\x11\xcd\xbf\xcc\xb1\xd86Q" +
	"\xf3\xff\x8b\xa5\xf9\xbb\x92}\xafxI\x9e\xffT}}" +
	"w\xe5\xe0\x85\xdd\xf1\xa2\x0d%\x1e_i#Z\xaaR" +
	"L\xf6V\x8bh\xa9V?P\x87\x14lY\xd1\xdax" +
	"N4\x0bW\xe8\x8cxe\x94F\xd3\xb1*$(\x8a" +
	" \xd5]\x80\xc8\x16B!\x12Z\xd4\xc1y\xac\xd2v" +
	"\xf25k\x9a\x8c\x1aM\xfc\xf7 \xc2/O\xde\xd7\xcc" +
	"?\xd6dR'\xc6E\x04Q!\x95\xc9\xba,#\xb1" +
	"\xbe\xc5*\xbcB\xcf\xc4\xa2\x84\xfc\xb1v\xaf\x09\x96\x0c" +
	"\xb35\xb1\xf1\xb8NA\x1e\x89\xdf%\xadI\x806p" +
	"\x9aT\xaa\xe3\x15\xecvs\xda\xa1\x82\xfdb\xb3\x82]" +
	"D\xb4\x1aO\x91\xd7\x95D\xa3\xcc\x14\xb4\xba~\xbd\xf9" +
	"\xfc(\xeb\x88+\xd6\xd3\xa3\xda\x1f|\xb1\xa1;\x92\x1f" +
	"\xd7m\xad\xa9\xf1\xe0\xcb}\xaeBx\x9f\x8b\xe5\xd7\xb9" +
	"h\xc0\xbf\xe2\xb2\x07_6\xb9\xbcp\x93\x8b\xe5\xdf\xc7" +
	"\xa4O\\\xf6\xe0\xcbAW!<\xe8b\xabh\x1a\xf0" +
	"\x17\xd2\xf6\xd8K6\x9dO\x82\x1e}1\xe9j\xda\x1e" +
	"{\x19H\x8f\x81\x83\x13\x82\x1eV\xec%5\xe8a\xc5" +
	"^\xee\xa3\xa7%\x05=\xac\xd8\xcbVzVR\xd0\xc3" +
	"\x8a\xbd\x9c\xa2\x15x\x86f\xf9\x1en\x1a\xf0}\xdd\xf6" +
	"\xd8Ko\xb7\x17\xf6v\xb3|\x19&U\xba\xed\xb1\x97" +
	"\xf1\xee1\xd0\xeffy\x0d\x93\xe6\xba\xed\xb1\x97\xd9\xee" +
	"\x1a8\xcf\xcd\xf2O`\xd2:\xb7=\xf6\xf2\x8c\xbb\x14" +
	">\xe3f\xf9\xb70\xe9C\xb7=\xf6\xb2\xd7]\x03\xf7" +
	"\xbb\xd9\xaa\x0c<O\x19\xf6\xd0KvF)\xcc\xce`" +
	"\xf9\xfe\x984\x04\x93r\xbe\x8a\xe5\x82\x1c\x8a\x82\x833" +
	"J\xe1\xe0\x0c\x96\xbf\x09\x93\x82\x98\xd4\xe5\xcbX.\xe8" +
	"\x82\xe7)c\x0cD\x19,\x7f'&=\x80I\x9e\xbf" +
	"\xc7r\x81\x07\xcfS\xc6|\xb8$\x83\xe5_\xc1\xa47" +
	"0\xe9\xe2\xe3\xb1\\p1E\xc1\xed\x19Upg\x06" +
	"\xcb\x1f\xc3\xa4\xd3\x98\x04\x8f\xc5r\x01\xc4\xf3\x94\x91\x07" +
	"Oe\xb0|n&\x0dx.\xd3\x05:\xe7~\x11\xcb" +
	"\x05\xb9\x14\x05/\xcb\x9c\x0c{f\xb2|\x19&Ub" +
	"\xd2%Gc\xb9\xe0\x12<O\x99\xb3\xa0?\x93\xe5\x1b" +
	"1\xe9\x0eL\xfa\xd1\x91X.\xf8\x11E\xc1y\x99\x93" +
	"\xe1\x82L\x96\xff-&\xbd\x80I]?\x8f\xe5\x82\xae" +
	"\x14\x05\xd7g\xe6\xc1\xf5\x99,\xff\x16&}\x98\xe9\x02" +
	"\xba\x01\x91\xd6\xa7O,\x13\xdd\x1c\xb7\xda\xbe\x189\x09" +
	"\xba/\xae\x85\xa7\x0dw]\x97x\x0bE\xe3h\"\x88" +
	"\x1a\xe9\x1f\xc6\x1c\xfaO[\xf8\xfd\x86\xda]#\xcb\xa1" +
	"\xb4\xba(\xde\xbd^G\xa8\xbf@8R\xa1N\x88\x86" +
	"\xd3G\"jb#\xc2\x11\xaf\xa8z%\x8a1\x81\xf5" +
	"\xac6\x94vI\xd5\xd8\xb8k\x95$\x8dbL\xc0<" +
	"\xab\x05\xa2)\xc9\x04\xf3\xcc\xa9\x14\xd2\x865f\xc5F" +
	"\x98\xac\xc5\xde\x88\x15\xd8\xb0\x1a\x96[\xf2\xa2\x92\xe6\xab" +
	"\xad\xa6\x8au/`\xda\xc8\xc6\x08\x9d\xd9\x0b4\x9dY" +
	"\x8flX\xfdu\x0c\x91\xe7<.i\xd4\xf8\xa4M\x88" +
	"\xd7\x0b\x8a\xf4w\xb4\xfa\xf4\x1a\x03\xaa\x15%\x82y\xd4" +
	"RDi\xa4(\x05\xbd!Q\xa5hc\xb2\xac\xcej" +
	"\xf1\x1cK_\xcd\xb4j\x85b\x9c\xc1\xc4\xe2s?\x0a" +
	"i\x9c\\3\xcdK\x15\x13X1]\x9c\xd5\x9f\xeb\x1c" +
	"\xa6}&$\xe9\xa7\x8dr\x8d69sDY\xd2\x85" +
	"Y\xcdy\x8d\x01\x89jy8\xa25\xa5\x1dP\x85\xca" +
	"!\xccd\x0e\xc8j\xb6e\xc9\xb8A\x08\x89\xc1\x96d" +
	"4`&S\x86\xd5\x15\xcex)\x1d`\xa8\xa2\xc5\x14" +
	"T\x1d\xd1\xc8+Z)\xa8V[\xa8$A\xa0\\/" +
	"\x0aM\x17|]l\x89\x03\xaa\xc1n\x0c\xcf\xea\x96n" +
	"e\xc8\x92\xbc\x93j\x0a\xc8iw\xb3\x9e\xe9\xa2z)" +
	"F\x93uIV\xe7[\xc3\xbf)\xc9\xe9q3'\xc8" +
	"\xc6\xd2\xb1\x9a\xf5\xfc\x07\x84\x7fc*\x92\x82\xd5r\x8b" +
	"\x83Sb<\x92\x82^<7\xac`\x8d\xee\x9a?s" +
	"\x13fp\xa5\x0b\xcee\xfc\xb2T\x11\x02\xd3\x11\xd0:" +
	"ZHR\x13\xab!\x92\xb4j\x8aI_\x8e\xa5\xb8b" +
	"\xbc \x05g\x8a\x81\xfa,\xa4\xea\x11\x04\xc2\x84\x82\x9c" +
	"~\x9aq\x02W\x13\x92\x03\xd3\xf5Z\x86\xa8F\xe0\xa4" +
	"\xc3\x9c(\xa9b\x10q\x11AA\x92V\x8fTQ\xe5" +
	"\xd8>}\xfb\xfd{\x0a\x83\xabP@\x8c(r@\x08" +
	"\xa9\xcd\x02\x85\xb5<[\xf5\xd6l)\x86<\x8a\xd15" +
	"\xf3\xe6Ko\xd6\xc4Ko\xb2\xb1\xa9$\x86#!=" +
	"\xf7\xaa\xf9\x12\x1c\x1dt_\xc7c\xe6\xc2\x82\xd44@" +
	"\x93\x07\xe0\xffo<\x95#K\x05\xffK\xabpt\xab" +
	"\x1d\x04:\x1e-V\x12R\"m\xd1\xe2\xfc\x96 \x05" +
	"\x14\x14\xc8Io\xb2+(\x90\xded\xd7#\x8f\xac\xe2" +
	"\x93\x02\xa8\x8dq\xc7\xee\xb4\xa0\xb5&\xe8X\xaa\x08R" +
	"\xa0\xbe\x18)-\x87\xbd\xfe\x92\x10\xf6\x0a\x90\x0ce\x03" +
	"\xe9\x9b\x18\x8a\xbd\xe2Q\xaf\xe3c<'X>\x17`" +
	"E<!\x09\xee20\x06\xf6\x04l<\xc37n\x87" +
	"\x8d\x07\xd3\xa0\x1f\xb0\xbc\x86Is\x13jVf\x83\xf9" +
	"p\x1e`\xf9\xdfb\xd2\x0b\x095+\xeb\xc1J\xb8\x09" +
	"\xb0\xfc'\x98\xf4UB\xcd\xcaq\x90\x0f\x8f\x03\x96\xbf" +
	"\x10\xdb|\x97&$\xc1]\xe2\x1aC\xb2\xea\xae\xc3\xa4" +
	"\xd1\x09Ip\xe5\xae\x1aX\xe1b\xf9\x10&5\xba\xec" +
	"\x86X\xd45\x1f6\xb9X\xfeqLZ\xebr\x81\x18" +
	"\x0a\xa9\xa8L.\x93[\xba\x88\xcb\x09\x1f\x17\xa4h\xe3" +
	"\xa2\xb3:\xa1\x1a\x1f\x1d\x0b\xaa\xa8m\x9d\xa0\x8aZo" +
	"\\\x90\xd52(YPN\xb93\x8cM\\\xb74e" +
	"\x01\xd9\x8b\x9f2tKg\x81#\x15 \x87K\xa4`" +
	"\x99\x9cNEXi\xca\xac\x05\x8a\x1c\xf6\x0aR\xd0\xcb" +
	"\x04\x8d\x81Z\x0d\x94\x9b\x91[\xce8\x8f\xd7\\}\xbb" +
	",\xd9.Sv\xd0\x1c8H\x95\x9f#\xd6\x96\xc9i" +
	"O\x12\xfc\xea\xc6\xd8\xca\xbbL\x18\x1a\xad\xbbg\xae9" +
	"6\xfcl9\xc9\xbcNo\x8e\xe8\"P\x88bT\xd4" +
	"\x9c$|\x14\x95H\x14\x13,\x93\xd3~\x0d\xfcf\xf8" +
	"\xc5\x80\xf1f\xfa\xd7X\xd1\xf9s\xba\xa0\xf3\xf0\xa7\x92" +
	"\xe5\x81\xa01\xc24_cM\x8aL\x94\x132\x07\x9a" +
	",\xd8\x1e\x10\xae\x08\xb6\x1f\xb3(\xee\xd4\x15\x9b\xc7\xc0" +
	"\xf4\x80C\xb1\x12.*\x893\xa2\xc8e\xe1_\x06\x91" +
	"\xa4\x89\xb5\"\x93R\x83\xdd\xa6\xf4\x1a\x97Y<1^" +
	"V\xd0\x0dB(\xda\xe6\xb2wo\xb1\xbe6S\xcan" +
	"\xfe\xaf\x00\xe2\x87Y\x00A\xea\xacP\xfb\xc12\xca\xac" +
	"\x0f\xaf\x18\x92\x9a\xd5\xc4\xb0\x19\xa4\xff\x1c\xa7\x81\x992" +
	"\xd1\xb8t7\xa9-\xa8\xeau\x0a\xaa\x8e\xf1\x8cg-" +
	"\xd5\xca\\\x1c\xd1<O\xb4\xc8l\xf6\xd0\xfc\xda\xd6d" +
	"\x9f\xa1\xf6P\xadI\x85Oz\xfc\xdfU\xd45A\x08" +
	"\xa3\x8e\xd4\xa1\xc4?\x83dHj\xe6\xf0\xd8\x15\x1b\x19" +
	"\x0d\x858I\x08\xbb\x90\x99-\xa2\xb3$\x01;\xb65" +
	"/\xaf$\xa0\x89\x0d\"\xad5\xb5\xf1\xc4\xc8c\x84\x80" +
	"\x16\x8f/\xd6\x8b\xc1 \x92\xfe\x1d\x15\x86\xa3Hx\xba" +
	"X\x19/LGJ\xbb\x03\x88,jY\xf9;\x14\xab" +
	"\x8aJ\x04#\xd6e\x82\xc4\xaa\x86\xa3\xde\x08\xc6<\x12" +
	"w\xc4\x0fv\x17\xc2\xc1n\x96\xafv\xd3\x80\x9f\xea\xb6" +
	"+\x80S\xdc\xdd\xe1\x147\xcb\xdf\x86Iw\xba\xed\x0a" +
	"\xe0\x02w!\\\x90\xe0\x96\xb6\x14\xc0g\xdc\x0a\\\xef" +
	"f\xf9\xbfb\xd2\x01\xb7]\x01\xdc\xef\xae\x82\x07\xdd," +
	"\xef\xce\xa0\x01\xdf%\xc3\xae\x00v\xce\x98\x06=\x19," +
	"\x7f5&\x0d\xcf\xb0+\x80\xc32j`I\x06\xcb\x07" +
	"1)\x92aW\x00\xc3\x19\x0ba4\x83\xe5\x1f\xc1\xa4" +
	"\xdff\xd8\x15\xc0U\x19\x8b\xe13\x19,\xffWL:" +
	"\x90a\xf7\xc4\xef\xcf\xd8\x00\x0fg\xb0|\x97L\x1a\xf0" +
	"=2\xed\x9e\xf8n\x99\x9b\x89\xf3y\x1c&\xdd\x94i" +
	"\xf7\xc4O\xcc\xcc\x87\x133Y^\xc3\xa4\xb9\x99vO" +
	"\xfc\xec\xcc1p^&\xcb?\x81I\xeb2\xed\x9e\xf8" +
	"g2k\x88\xf3\xf9\xaf\x98t \xd3\xee\x8a\xdf\x9f9" +
	"\x1f\x1e\xccd\xf9,\x86\x06|.cw\xc5{\x98B" +
	"\xe8aX\xfe*L\xba\x8e\xb1\xbb\xe2\x872\x87`9" +
	"\xc3\xf2\x11L\xba\x8d\xb1\xbb\xe2\x9b\x98\x1a8\x9ba\xf9" +
	"\xc71i-cw\xc5\xaff\x16\xc2\xf5\x0c\xcb\xbf\x8f" +
	"I\x9f0vW\xfcAf\x0c<\xcc\xb0|V\x16\x1e" +
	"F\x96\xdd\x15\xef\xc9Z\x08\xbbe\xb1\xfcpL\x1a\x97" +
	"ew\xc5Wd\xe5\xc3\x8a,\x96\xaf\xc7$-\xcb\xee" +
	"\x8a\x9f\x91u1\x9c\x91\xc5\xf2\xf7b\xd2#YvW" +
	"\xfc\xd2\xac\x1a\xb8<\x8b\xe5\x7f\x8fIob\xd2\xa5\x9f" +
	"\xc5r\xc1\xa5\x14\x05wfU\xc1\xddY,\xff\x15&" +
	"}\x87I\xdd>\x8d\xe5\x82n\x14\x05\xcfd)\xf0l" +
	"\x16\xcb\xf7\xca\xa6\x01\x7fU\xb6\x0bt\xee~8\x96\x0b" +
	"\xbaS\x14\x1c\x90=\x0b\x0e\xccf\xf9\x9b0)\x88I" +
	"?\xfe$\x96\x0b~LQP\xc8\xae\x81(\x9b\xe5\xef" +
	"\xc4\xa4\x070\xa9\xc7\xdfb\xb9\xa0\x07E\xc1\xfb\xb2'" +
	"\xc3%\xd9,\xff2&\xbd\x86I\x97\x1d\x8a\xe5\x82\xcb" +
	"(\x0an\xcd^\x09wf\xb3\xfcW\x98\xf4\x1d&\xfd" +
	"\xe4`,\x17\xfc\x04\x0f#{\x1b\x04\x9dX\xbe\x7f'" +
	"\x1a\xf0C:\xb9@g\xf6@,\x17\xb0x\x13u\xaa" +
	"\x81C;\xb1\xfc\xcd\x98T\x8fI\xdc\xc7\xb1\\\xc0Q" +
	"\x14D\x9dJ!\xea\xc4\xf2wb\xd2\x03\x98\xd4\xf3\xa3" +
	"X.\xe8\x89\x87\xd1i2\\\xd2\x89\xe5_\xc6\xa4\xd7" +
	"0)o\x7f,\x17\xe4\xe1at\xaa\x81\xdb;\xb1\xfc" +
	"\xe7\x98t\x12\x93.\xff0\x96\x0b.\xa7(x\xa2\xd3" +
	"|x\xaa\x13\xcb\xf7\xb8\x80\x06|\xdf\x0b\\\xa0s\xaf" +
	"\x0fb\xb9\xa0\x17E\xc1\xde\x17T\xc1~\x17\xb0\xfc8" +
	"L\xba\x09\x93z\xef\x8b\xe5\x82\xdex\xf5^\xb0\x0dN" +
	"\xb9\x80\xe5\xef\xc4\xa4\x070\xe9\x8a\xbd\xb1\\p\x05\x1e" +
	"\xc6\x05y\xf0\xbe\x0bX~\x1d&\xbdr\x81\x0b\xb0B" +
	"@K\xab\x90\x97\xce)\x09h\x9c\xa9\x91\xbf:\xb8r" +
	"\xd1M\xe3oz\xd5L&\xabQ\xd2\x1e\x98\xa5z/" +
	"\xa2\xc2k\xef\xff\xe5\xa3\xc7\xe1\x0e30Bz\x1f\xa6" +
	"\x0fn\x18\xdd\x11\xbb|3\xb8\xd7\x8b\xc7\x06\x06n?" +
	"_>\xfaXP\x9e k\xf5\xa4\xa1VZ\xdfoY" +
	"\x9c\x8f\xc8\xb1\x1a\xc7'\xcb\xc9\xa9\xbb\xb1\xbe)\xad\x93" +
	"\xdd\x12U\\\xc7\xcd\xaco\xf2:\xca#\x10\xc4%Z" +
	"9\xc5\x04\xebPZo$A>\xf6\x0a\x1a\xc5\x96\x07" +
	"\xcd*\xa3\x86\x15\x8f\xd2\xef\x8ex\xf2\xdd\x04i\xa4\x9a" +
	"\xa7\xc4\x84[Ho/\x12\x99z=\x0f\xc1\x0bf\x90" +
	"\x01\xbbp\xdb\xc8\xf0s7\xdd\xd3\xf5A\xbbdQ\xaa" +
	"+\x01\x1a\xfe\xf5\x12\xb5\xcc\xd1\xb9lJ\xde@$\x8b" +
	"R\x9d\x17\x08\xe4\x01\xaf\xc0\xaa\x96\xbd\x17\xdb1\xf8\x0e" +
	"pf\xfa\x1b\xcd\xcaf\xe5\xf2\xf4\xd6\xe8>K\xbe\xcb" +
	"\x94\xaf\x1a\xf6(\x8d\xd2\xfe\xc8Hl\x1a\x93\xc9)F" +
	"\x8d%\xaa\xe3\x9e\x88_\xba\xd6\xaf\x10;\xce@T\xc6" +
	"\xbfe\xd9\xd5\x17\xf6\xa7\xd7\x0d\xde\xb0\xeb\x9d\xff\xb3{" +
	"\xdbc\xf7\xb2!\xa4\x95\xa2\xb4\xc7\xd28\xa4yk\x8c" +
	"\xa7\x7f\xff\xc7#\x97\xde\xdb\xb7\xccZ\x94!Q\xd5\xaa" +
	"P0\xea\x0a\xa0\x0aI\x93\xf1\x18\xc7\x89\xaa6Qe" +
	"\x9c\xe3q=\x80\x95D7\xcex\x94\x0e \x92OF" +
	"F\x8c\xff\xe8%i#\xc6<\xdc~\xf8\xe2\xeb\xd5_" +
	"\xbc\xb1'\xf1\x07\x1b\x10\xc5(i\xbd;\xd3\x0c\xf9\x0d" +
	"\x88\xcaQ\xacw\xa7\xf7\xbc\xd9\xf8\xed\xdc\xf7\xec\xc2x" +
	"\xa4U\x00\xbc\xa8F\x12s1\xedf\x1d\xa7\xf3{\x01" +
	"I\xe2\xf4\xd6*VQ\xdf\x81\xbb\xde=;r\xc4\xc1" +
	"\xf5\x96d\xb9\x8e@\x17\xb4\xe4\xce\x1a'\xd7y\x1b\x84" +
	"P\x9427\x8d\xd5\xe7\xdf\x0a%E\xc8\xa4\x022\xab" +
	"$\x82\x90v\x88\xe3\x85\x08\x99H`\xce$c\x06=" +
	"\x9f\x1fu\x1bZ\xfbk\xf0\xa1U\x87\x89Z\xe8\xc96" +
	"\xc1,\x1e\x98\xbb\xeb\xfe\xb5\xc3k2\x9f3S\x94#" +
	"i\x1e\xbb\x18T\xeaQ\x1a\xb3\xfd\xbf\xf1\x1e\x91hk" +
	"#\xa3\x95Q\x87\xc8\xe8\xd5[K\x17\x7f\xb2\xa3\xe9W" +
	"6qd?P }\xe5^e\xd4\x88\x8e\xe6x\x05" +
	"]\x94\xd9\xe2>.\x08/\xdc\x12\x8a%\xa7X\xda\xd0" +
	"\x16\x16\x86W*\xf0\x1aG\x1e1\x08\x17\x8cP\x9eY" +
	"\xa2\x9d\xb0\xbf\xa9.\xb1\xb8Y\xf8\xf7xD\xd1.\x92" +
	"p\x1b\x11\xc5\xe2\xe7_\xe8\x1f~\xf6\x96}\xf1\x10\x1c" +
	"6\xb9\xabe\x8a\xa9B\xa1\xb4\xd3\xa7\x1b\xe7^\x8d*" +
	"\x96\xbd\x0a2\x12\x17n\xcb\xde\x96uy\xef\xd5\xbf;" +
	"?\xd1A\xbdQ&\xa8+\x09(\xb2\xaa\x960\xceg" +
	"\xba\xf9\xd2\xdbbU\xc6\x13\xae:N \x8f\x18w\x87" +
	"\xbe\xe3'k\xa3\xc7\x1d\xc9\x98\xf8i\xb2|\x97)_" +
	"m\xfe\x04\xecau\xc7j\xee7l'as?D" +
	"1ui\x8fl\xc5\x12N\xb1u\xd6URq\xd7\xd8" +
	"\xf1\xfdO\xae6\xf3&LD\xc6\xb4\xe0\xff\xbc\xce\xe3" +
	"\xd5=\x0b\x8f\xcf\xeb\xff\xc2\xed\xcbnXA\x9d\x87(" +
	"iL\x95\x15\xad\xb4\xc9\xa7P\x8csg\xcb\xf8\x02\xe2" +
	"eE\xf3\xd64y\xa9b\xd2\xe3R\x17\xb7\xf6\xc6\xea" +
	"k\xd6\xfc\xf4\xe7w&\x8b\x03A\xa4\x8c\x10\xd2_G" +
	"+-\x91@\x97\x18\x10\xacks\xc5\xfa\x87'\xee{" +
	"\xee\xc5?\xd8\xe5\xe2c.\xbd\x92X\xa3K\x8c\xaa\"" +
	"e\x1doc\xa7\x0e\x1czhq\xd9\xcb\xff\xee\xf2\xd9" +
	"\x995\xe9=\x897\xd6\xe8\xaa\xf9\x7f\x1d\xfc}d\xf9" +
	"\x9f\x1a\x97;\xb9kIpJo\x12\xda2\xdc\xf2\xd1" +
	"\xc4(\x94\x1e\xd8\xd23\x16s\xa2\x88x\".\x8d\x07" +
	"\xa2\x96\x96\xda\xba\xa9\xc6\xcb\xaf\xb6z=[Y\xff\x01" +
	"\x1a\xf8\x8f\xd9\xf1\x96\x8f\x94z\x8e\xd8\xf1\xd4,\xff\x83" +
	"\x07\xd4$\xe1\xa9\xc5Q\x18R\xf0\xd4\xe2(\x0c\xa0*" +
	"\x11Om\x8e\xa0\x8dC\x82\xaa\xa57\x83t\x1e2k" +
	"\x97n\xfbr\xc6\x92\xfb\x0b>\xb6\xf2\xc4H\xc9R\xfa" +
	"T/\xb3\xaa\xa9K\xec\xe7\xbb\xc3\x8bF\x0f\xefo\xe6" +
	"F\x99`\xe1i\x7f\xbd\xdc\x02\x14\xef\x12{\xaf\xec\x9b" +
	"#\xcfw\xf5<j\xa5\xf7\xd8\x9br\xa5]\x9f\xa3\x92" +
	"\xdawu\x89\xf5\\\xbc}\xfc/\xef\xdfe\xe5\x88\x84" +
	"\x90\xaaV\x13\"\x95\xf6\x8c\x18g\xf1\xe13b\xe3p" +
	"yf\xcfw*?2\xa5\x90\x1e\x07\xd5\xf5\x02\x05\xa4" +
	"\xb4F\x95/\xceGF\xc3~w\xc7n\xf0_\x1f\xed" +
	"n&M\xba\x1a\xd1\xed/\xd6\xfa\x81\xe5Hw\xb1<" +
	"\x82B\x9eG`\xadNM\xa6czQ\xbeg\x11\xeb" +
	"_K\x03\xff\xcb6\xc7\xf4\xc6B\xcfF\xd6\xffW\x1a" +
	"\xf8\x0f\xd8\xa2\x16\xfb\xf3=\xfbY\xffw4\xe0\xb3\xc0" +
	"\x7fbs\xe2\x9c\x80\xd0Bk\x8f\x80`\x84\x1b\x9ak" +
	"kL\x15G\xbccdQ\xeax\xc1\xe44Y\xb4A" +
	"V't\x1cO,J\xb1r\xb3#\"2\xf29H" +
	"\xbe\x8c\xa0\x1am\x9cB\x88t\x9d dN\xae-&" +
	"\xe4\xe4\xfcx\xa7\xba\xdbB[\x83mFE\x11\x87\xbe" +
	"\xa0\x04\xb2<\xedl\x13\x0e\xbb\xbf:\x0d\xac\xb9\x9em" +
	"@\xb7\xddW\x8d\xa7}\xa4(\x05;\x9a\xd0\x91\x9fS" +
	"+J\xc1f6%\x88\xf1HP\x02\xf5\x9c@\xeb;" +
	"\x8f4\xc22\x91\x8e\x02\xf8\x8aI\xed\\\xder\xf3\x0c" +
	"\x92\xac\x9e\x1a\x87#\xbf\x9dv1\x1a\x83K[\xf06" +
	"\x01\xcd\x0c\x89\x12@\x1d\x8d}u\xa7\xd34@\xc1\xaa" +
	"\xba\xd9\xff\x04\x98\x0dN\x92[G`\x83\xa4\xa3%A" +
	"\xc3[Q\x12\xb496QEx\xe9\x87\x80Y\x0fT" +
	"\xacw\x19\xfa\xb7\xb4\xee \x0e\x19\xb6\x0e\x1b@\xed}" +
	"\xcb;\xe2\xed;t\xf7\x8e\xf3z<\xe4\xd6\xddc\x9c" +
	",]l]\x10z'\x17R\x98\xa6\xc8\x12i\x1f[" +
	"#\x04\xa6\xebI^\xa4\xc0\x93\xd3\xd1\x80%\x92\x9a\xd3" +
	" jM&\x84\x05Y\xd2F~\xb4y\x9d\x10\x7f\x9d" +
	"Q\xb8\xac^\xab\xd7]\x136A\xe2j\x90\x9e\xc9j" +
	"\xb4\xb9\xa9\xc7\xcf\xcc\x14T\xf2\x0c\x83\x82I\x90\x80\xf9" +
	"N\x11q\xafcD\xbc{G\"\xe2$\xae\x9d\xdam" +
	"\xacXh\xce\x80\xb5\x81\x82k\xb7\xa2`\x9d\xe3\xf9N" +
	"\x0b\xe9\xab\x95\x05\xd5\xe9.\xfa\x81\xc6\xc3\xf5`qq" +
	"y\xa3\xa8jjG/*\xa3R\xdb\xb9\x95\xe9.\xdb" +
	"5eC\x8fSH\x91\xbc`\xb58\xaeMB\x8c\xd3" +
	"1T\x12C\xb56\x88\xf4\x96\xf3\x00\x0bY=?\xba" +
	"\x05l\x07=<\xaaGG+\xc2ts1N.\xde" +
	"\x09\xc3\xb4-hY\xe1\x82\xa8V\xdf(\x11AQ\x91" +
	"\xc2\x91Z\xe0\x1cAI\x81x\xa8\xb1\xf5^\x8d\xdb\x18" +
	"\x93fy\xa6X\xeaV\x8c\x00\xe3\x97\xa8\x13(\xc6\x19" +
	"\xba>n\xce\x12\xe4}\xaf\xa0R\xec\x049j$\xa2" +
	"\xf7\xf8b\xe2\xc5\xc3\xa7\xef\xb3lc\xabV\xb9\x18\xf1" +
	"\xcd\x14\x13\xc7\xfd6e\x063@^RW\xac\xfbm" +
	"^\x9a\xfe\xe7\xd1\xbf\x99r\xc1\xf3\x8em\x1b\xe5`4" +
	"\xc0h\xed\xcf\x02\x8aCJ\x86\xa3\xa1\xe6 %\xc7\xeb" +
	"zMS\xbb %\xcfo[2\xdd\xef\xc3\x8e4{" +
	"u\xb5\x01C\xb2\xc6\xf0.\x8d\x14)\x06\x85\x82\xed\xc1" +
	"\x85M\x97\xa1\xa0V\xa1\x00u\x1e\xd3Z\x0bA\xac\x0c" +
	"\xaf{\xc4i\xb4a\x86\xe8w\x8b\x91\xe1\x8a/J\xf6" +
	"\xdf\xd3(\xcb\xca\xe4\xd2\xa3Xu$C\xb0]\xb9\\" +
	"erJ.\xd7yO\xcd0\xd5!\xbc\xa6;^\x96" +
	"oW\x87\xdaZ\x96o\xf4`lEY~\xd9\xf3\x9f" +
	")\x97,\xbf\xefE'=S\xd6\xcagDs\x84P" +
	"\xb5\xdc\xde\xbc\xf7q\x969.'\x98\xe3i\xe0W\\" +
	"\xc0j]F#\x95\x0b\xcaR\x1fMo\\f\xb61" +
	"\xc3o\x95\xd4\xd1\xa3Z\x11h\xb1\xc3\x886\x09-\xf6" +
	"R.>\xcb>\xe3\xb4L\x03u%\xb1\x95w \xaa" +
	"(H\xd2BM\xa6A\xaf\xa0\x19Q\xa4\xe2\xefQL" +
	"\x12g\x92\x9bz;\xf6`(\xb4\xa1\x04\xb5|+\x9a" +
	"\xd8f\xa9V\x1c\x09%\xa4\xbdO\x09GKi\xf5|" +
	"4\xdc\x81\x06\xe9\xf1KA\x94\x9a\xc1\x19^\x18+\x09" +
	"\x06\xc9u\x00\xacU\x0b~\x90\x08\xc3\xbaj\xc1*e" +
	"(\x10\xea(\xac\x8f\x0df\xc4\xf1\x0f\x03\xc1\x1a\xbc\xdc" +
	"\x84 7\xb3^\xc8\xd0\x8cnEB\x13V\xb6\x9a\"" +
	"\xd8\x16\x92\x82\x04\x9a\x82\x135\x1d\x9b\x02\xab\xfe9\xb2" +
	"\x94\xdc\x02\xa84\xbe\xe5\xcd_\x00]b\xafVn\x8b" +
	"\xce\x18|\xe96\x87\xf3\x17kN\xd5\xa2\x16B\xc4\xc9" +
	"\xdd\xde\xf7\x0c\xc5W\x19\x96\xd5\x1c\x10\xc74\xdaR&" +
	"/\x8c\x03q\xa8\xd8\xee\xc4Z\x18\x12\x02\xf5\x04\xd4\xdf" +
	"\x82\xe4\xd3\xc1=\x0cl\x8e\x02n\xa4\xac\xe0S!\x1c" +
	"\x09\xa1\xfe\\\x9f\xf2pDT\x10W\x12\x89\x84P\x1f" +
	"\xddj\xea\x83\xf4\xbf\x09\x91HN\x08\xf5i?l\x07" +
	"\x95\x13\xf1\x96\x9c\xdb\x13&\xd1\xf4\xfb\x0b\xb0\xdawf" +
	"\xda\xdaw\xea\xf6]\xb5\x85Jb\xda\x84\xa2J\xfeO" +
	"\x0a\xa2Fn h\x0d\xe2Z\xa1\x1d|\xd9\x00\xf3I" +
	"\xf22t\x04\xcc'\xb5\x09xq4|c\x0704" +
	"\xda\xd2\x08\xbc\xc6\xa1\x11\xb8(\xe1\x1d#J\x1c\x92\xea" +
	"B\xa2Z\xef\xd5[\x81\xcb\x8c\x84\xfa4\xa3\x0d\x0c\xd1" +
	"\xbb\x81\xa7\x9d\x00\xb3\xa7L\xda\x09\xa8 U\xa3\xa0\xa9" +
	"\xa3y\xb1\x89\x96X\x82\xc3\xd0\x03\xf6Y\xe8_\x04:" +
	"\xc4\x04\xed\xc6\x06<\xddT\x90\xa6\x1d\x95\x96>\x0e^" +
	"\xc8\xea\xd5\xac-\xdc\x0c\xba[\x04\xd4\x9dg\x97\xc8." +
	"\xd3%\x82B\x17\x1b\xfe\xf2\x1f\x86?\x04\x05\xf1Ee" +
	"s\x87\x14\xb6\xbe@\xa0\xd4\xb3\x9a\xf5\xbfI\x03\xff\xfb" +
	"6w\xc8\x9e\xee\x9e=\xac\xff$\x0d\xaal\xde\x10\xcf" +
	"\xd9<\xcfY\x96\xef\x01h\xc0\x0f\x01?\xcc\xa6\xed\xff" +
	"\x13\x9e\x94\xd4\xa6+l\x03R\xdb\xdf\x18-\x94\xd4\x05" +
	"\xad\xc1\x0e\xd2\xe3X\x9f\xf9u\xbc>\xb3\x93\xbd5\x9a" +
	"j+\xcc$\xfez\x0b\xc3H\x08#5\xb9]\x1a\xe1" +
	"6\xba\xa5\xc5\x0b5YQ\x96\xfa\x15\xfc\xef,\xd4\xac" +
	"B\xc1h\x00\xb5\xbaEP\xca\xbd\xf0\xb0\x95Jd\xa6" +
	"bQt\x005sxd\xc4\xaa\x15ARke\xe5" +
	"G\xfa\x91\xa1os\xfd\x08\x91%d\x85\xdb\x02r\xb8" +
	"\xc6:\x13\xc2\x86Je\x86Zt\x90Gr\x0b\xebA" +
	":[\xaf\xd4\x80\x10\x0a!CA\xc1ZlDP\x84" +
	"0\xd2\x90\xa2z\xb9>\xa2\xd4\x87\xeb\xab\xab1\xe6\xc5" +
	"mB]\xe2\xdf\xed\xa7\xb7'\x92\xa3\x1aak,\x88" +
	"\x1b\xdd\xfd\x92\xfa\xe4W\xd9\x01\xfa\xcc\xaf?c\x0c\xfe" +
	"\xfa\x0f\xd3\xc0\xff\x84\xedtY1\xcd\xb3\xaa\xc8\xff\x09" +
	"\x0d\xfc_\xb9@\x0c\xbf\xc9\x0dB(J\x81\xf4a0" +
	"\xcc\xe7\x88Sd&\xa9\xa5\x0f\xdbV\x11\xbe[C\xa2" +
	"\xaa7lJ\x8d`\x90\x80f\xa5\xa0Q9\xa4\xbf\xc3" +
	"\xbf\x01V\x89\xdc\x1b\xe5L\x07\xdc\xf6\xa3\xe3W\xa2\"" +
	"\xa8\xa8Y\xff\x89\x9en\xc1\xc9\xb4\x84\xf0u\x14\x96\x95" +
	"\xc4\x95&\xb0\x9c\xbe,[\xd4\xd2\xbcv-\xed\xbc\xf8" +
	"\xbdS\x9b\x97\xb6>\xf2\xdd,\xf6\x94\x89\xd3\xd9\xbc\xb7" +
	"\xa2\xb0yo\x85\x19\xc5\xe4X3\x8a\x99\x16\xf0\xac\xc5" +
	"\xae\xb7,j> \xd5\xf2\xf92\xdc\xf2\xea%d^" +
	":\x1d0\x1e0?\xa6\xff$2a\xaa\xd3\xb9\\\x0c" +
	"\xa5;\xe9s\xda\xc7?V\x94\x82\xaa\x0ft\xb8\x14\xb3" +
	"t\xcet\")}5\xa6~1\xb9j\xf5\x94\x1aM" +
	"\xac\x09!n\xba(1\xc1t}d[\xee\xa3\xac\x7f" +
	"\xe6\x1c|\xda\xb5\x0b\xed<T\xadD\x01\xea\xa8\x85\x9d" +
	"\x84\xef\x9a\x04\x9d\xbb0\x1e\xc5\xc8\xd0\x0c-Z\x08\x85" +
	"\xcc\xd3\x19\x0f.J.C\x95\x13\x14Dp\xc8\x0a\x9c" +
	"\x9d\xb8\xbd\x88B\xadjqM\xc5^AyQ\xaaq" +
	"=1\x12A\x04C\xb2\xdd\xc6u0~.bY\xcd" +
	"\x19\xd7v\x05%\x09\xe5\x12\xaf\xd9\xa6\xe6\x10.u\x80" +
	"\xcb$\xdb\xba\xa4\xb2r\\\xb9iT\x0b\x116\xd2!" +
	"k\x9a\x98Hx\xb1\xd3\xed\x0f8TZz\x87\x0ei" +
	"\xd3\xac\xe3n\x83\x0d&9\xc9c\x17_\xf7\x16\xf8\xa7" +
	"~\xc1\xb3Xf\xb2\xbf\xae\xa5\xb0\x7f\xb3\x05\x87d\xd3" +
	"\xb4\x06\x1a9]{8\x024\xd5\xfe\xa3A\xb3\x8e\x06" +
	"\x03\xdf\xaa\x99\x9dq\x94\x8e\x95puQA\x09r\x17" +
	"\xd9\xb1\xf8T\xb2\x09\xb8\x1ab,\xc9\x12\xe9\x8f\x10\x95" +
	"\x88\x17f\x84\xfe\x0fUw\xdcp\x82\xc6\xcdB\x8aL" +
	"t\x1b\xbcyD)\xa0\x10\xdd\x07\x05\x8d\x85\xa7\x89a" +
	"=\x05J\xff\x1d\xa2\x06\x07\xeaQ g\xba\x1ec\xb6" +
	"\xe9=\xdd=\xe5\xac\x7f*\x0d\xfc!\xdb\xac\x8b\xf8R" +
	"\x08\xd2\xc0\x1f\xb1\xa9=\xe1RO\x98\xf5\xdfM\x03\xff" +
	"\xc3m\xec\x80(E\xc3\xa9F\xcd\x1c\xadY\xf4\xaf\xf8" +
	"5k\xf0\x90o\xd7}\xf6\xed\xd7>~\xfb+k\x9c" +
	"\xfc!Qlb\xd1\xa8\xb1\xbd\x1f/~\xcdZ\x80\xfc" +
	"\xc9Z\xc8\x18|\xa2\x11(~\xce\x8d\x15\xdb8\x0a\xb4" +
	"~\xce\xeb\x16\xb0D\xfc\xf0\x89\xaa\xa5# t\xbe#" +
	" t\xa9g\x86em\x98\xdaIr\x8e\x0b>GZ" +
	"\xa7i\xee\xf3\x1f\x1b\xf4\xce\x8d\x0b\x0e\x9f3C\xd4>" +
	"\xe77\x10\x15\x84\x0e\xa16\x17\xf66\xc4\xbd\xb2mj" +
	"\xbfi\xb9\xed\xdb\xdc~\xf3\x9c\x04\xce&\x10\xb7\xd7\xb9" +
	"iIl\xc0\xed\xe2\xbd8:^\xe3{\x04\xe4\xc1#" +
	"\x80\xe5\xb3\\4\xe0s\x13\xc06=\xaeB\xe8q\xb1" +
	"\xfcU\x98t]\x02\xd8\xe6P\x97\x02\x87\xb9X~*" +
	"&\x85\x12:\x9d\x89\xaeB(\xbaX\xfeNLz " +
	"\xa1\xd3\xd9}.o\x12\xb0\xa7\x95c\xbb\xc95\x06n" +
	"q\xb1\xfc\x01L:\x96\x00\xf2r\xc4U\x0a\x8f\xb8X" +
	"\xfeB\x9a\x06\xfc\xa5\x09h\x9b\x97\xd0c`7\x9a\xe5" +
	"\xaf\xc3\xa4\xd1\x09h\x9b\xe5t\x1e,\xa7Y>\x88I" +
	"\x91\x84Nga\xba\x10\x86i\x96\xbf\x1b\x93\x1eN\xe8" +
	"t\xb6\x84\xce#\xc8\x9e/`\xd2\xef\x13:\x9dm\xa1" +
	"\x0b\xe1\x16\x9a\xe5?\xc4\xa4\xcf\x13:\x9d\x1d\xa6\x0b\xe1" +
	"a\x9a\xe5\xddn\x1a\xf0]\x12\xd06;\xbb\xf3`g" +
	"7\xcb\xf7\xc7\xa4!\x09\x9d\xce\x06\xbb\xab\xe0P7\xcb" +
	"\xdf\x8cI\xf5n{\x8d/rO\x86\xa2\x9b\xe5\xef\xc6" +
	"\xa4\x87\xdd\xf6\x1a\xdf%\xeeYp\xa9\x9b\xe5\x7f\x8fI" +
	"o\xba\xed5\xbe;\xddyp\xa7\x9b\xe5?\xc7\xa4\x93" +
	"n\x17`\x82(\x90v\xd7\x96\xa1\x80\x9e\x98\xd0\xb4=" +
	"\xaf\xebW\x1f\xfd\xda*\xa7\x0a\xa2@iSz B" +
	"\x14 \xe9\xf5\x0eO\x9f\xfb\xaaK6(6\xb44\x1e" +
	"\xb1\xc1\x1a\xcf\xd2\x80\xf8\xdf\x03\xa2_}\xfa\x03\xc3U" +
	"\xfcA\xf5\xbffD)\xfd\xda\xa8\x90\x8c\xb5!U\xac" +
	"\xbd\xf0\xf9Q;\xff\x14\x8f'\xb4\xb46\xf0\xa3\xe6\xb7" +
	"Hz\x9a\x09!)\xed\xcf\x8eCF\xaeL\xff\x17\xe9" +
	"\x9c\xfeW\xed1K?\xd8\xb0\x1cl\xe1g\xc7\xcbA" +
	"\xebg\xef}1\xba\xbf\xd7\xcd;\x1f\xb2\x9e\x8e\x86Z" +
	"z:\x1a\xb2\x9e\x1e|\xed\xf8\x7f(\xc7>|\xd3\xa6" +
	"L\xa4\xaf13\x01Q/\x9f\xf4\xe9s\x0fn\x1ap" +
	"\xb7\xf9\xb5\xa4h\xb8\xa2\xb6<\xa4:;j\xe2\x05J" +
	"X\x80X\xebET\xbc\xae\xe7\xca\xa1\x13f\xff\xe1\xef" +
	"#\x1e\xfa\xffG\x9bq\x8a\xc5\x86T\xa4\xbd\xba\xd4\x9d" +
	"\xf1D%!\xe2\xec6,\x8c\xbb\x0da\x1a\xb7!\x81" +
	")$\x1a\x97\xee\xffU\xa3!=\x9b\xdfP\xb3l\xc1" +
	";\x87\x1c\xfe$\xdf!q\x12\xeaJ\x9b\x15\xdf\xe8C" +
	"\xfe\x85\xa5\xf4\xe9\xcf\xc5\x95:A\xe3\x04\x8e\xc5Jt" +
	"\xabQh\x0c\xcd\xc4\xd2\xe4\x9a\xa6yf\x17\xf9_\xa1" +
	"\x81\xff\x0d\x17(\xd6\xe4q\x8e\xcd=\xfeS}\x7f." +
	"\xd3\x09\x81\xad\x8e\xd6T\x18}\xed\xd8\xde\x89\xa8^l" +
	"MH/1\xea\x1fW\x84z\x83|\xd8;\x01\xd2\xce" +
	"R\x84\xc6\x83R8\x1e\xb0|\x04\x93nK@\xbbk" +
	"\x02y\xb0\xc9^\x1b\x14W\x84V\x80|\xb8\x02\xb0\xfc" +
	"\xef1\xe9\xcd\x84b\xa3\x9d \x0f\xeeL\xe8!k)" +
	"B\xa9=d-E\xa8\x9bk2\xbc\xcc\xc5\xf2\xc31" +
	"i\\\x02\xda]\x85k\x16\x1c\xefby\x0d\x93\xe6&" +
	"\xa0\xdd\xcdv\xe5\xc1\xd9.\x96\x7f\x04\x93~\xeb\xb2+" +
	"B\xab\\\xf9\xa4\x87\xeck\x98\xf4\x96\xcb\xae\x08\xedv" +
	"\xe5\xc1\xdd.\x96?\x86I\xa7]\xae6\x01L\xfb\xc6" +
	"]rTy\xaa\xf8\xdbsx\xef\xb5\xfe\x08\xfe\xea\x06" +
	"!\xab\xcf\x1b\xfe\xb9\xedh\xd4\x9aQT\xd25\xe7\xec" +
	"\xedf9\x11\xa3\xb4\xa0>U\x99\xea\xd3\x07\xb7W\xac" +
	"{\xdeu\x81Y\xb5G\xba\xaf\xa4\xfd\xcd*\x140~" +
	"\xf3\xec\x08\xd801\x8c\x9e\xff\x8f8\xe6\xb5\x16j\xad" +
	"\xabM8\xef\xc8\xa8\xf7\x0e\xbe5Lz\xcf\xea\xfa\xd6" +
	"\xd8B\xf5Iu\xa3f\xbc\xc4\x13\xe8\xc2Q\xb7l\x0b" +
	"\xaf8\x97\xc0\xb8\xfa\xbb1U\xa8\xb6\x8dY\xa0U\xf1" +
	"9\x04\xb5\xce9\xa0v\xe7\xbf\xady\x85\xbdw\x05\xeb" +
	"\xd7h\xe0\x9f\xeb\xb2\x15K\xb5\xafyEm3_1" +
	">\x8f\x84\x83\xa2\x80\x9br\x01wR\xe1\x0d\xde\xa0\x1d" +
	"M\xdc\xc8'\xe7@\x9a~\x14c\xcc~\x14M\xa4\xfb" +
	"&j\x8c\x84\xc4\x80\xa8\xe9\x8e&Y\xe1l\x8d\x1f\x0a" +
	"\x9a\xcf\xa0\xc5?\x92>\xca\xa1\x83\xa20\xf8\x0ajg" +
	"L`t\xbceT\x02VKJ\xeb;|\x95\x98v" +
	"\xb5K3\xcc\xea\xa0\x8cTN\x925\xb6^\x94\xea\x92" +
	"\x81\x0e=\x9d\x8b\xcc$\xc0b\x05\x09\xaa,\xb5-s" +
	"-\x8f\x99Y\xdf\xd4\x92\xf3\x90\xc4y\xfe\x0d];W" +
	"\xa6\x14\xeah\xcc\xbf\xa3e\xa7\xd1(\xb0\xba\x9e\x16\xa4" +
	"\xf6f\x00T[\xbf\x19\xb2\x15\xa0\xa6\xc9T\x9d\x15o" +
	"\x14\xe8\xb67\x0aD\xaa\x9a\xd2&\xb0\xd8X\xc5Tr" +
	"4\x80G\x92\x86\xa4\x00\x1a!t\xa0\x8bg\xc4\x1a\xba" +
	"j\x88\xb3u\xf1L\x0c\x0a\xcc\x8fg\xdcuN\xca\xb8" +
	"\xd3UPSB\xdbS\xee\x0a\xcc\xf0@\xb9\x95s\x87" +
	"\xff\x98.\"\xd6B\x98\x80\xd4s\x90\xb2b\x9fB\xaa" +
	"\x94\xdb\x0f\xf8Xm\x0b\x8d\x9a\xc5\xd6\xe7\xb5\x09d5" +
	"j\xd4Z\xe8\x80\x13\xd7>\xe3GF\x92+\xce\x8a\x88" +
	">\x1c\xd7>\xbb\xb9\x15x\x99\x9b\xe5\x87\xbb\xb1n\x97" +
	"\x00\xb5W\xe1\x9e\x06\xc7\xbbY>\x82I\xb7%@\xed" +
	"5\xb9'\xc3\xd9n\x96\x7f\x1c\x93\xd6&@\xed\xadv" +
	"\xd7$u\x80\xb1\xb4\xcf\xbd\xeeB\xb8\xd7\xcd\xf2\xa71" +
	"\xc9\x9d\x00\xb5\x072\x14\x98\x91\xc1\xf2}3h\xc0_" +
	"\x9d\x00\xb570\xa3\x14\x0e\xcc`\xf9jL\x9a\x9a\x00" +
	"\xb57%c\x0c\x142X\xfe\x0eL\xba7\x01jo" +
	"QF>\\\x94\xc1\xf2k1\xe9\xe5\x04\xa8\xbd\x8d\x19" +
	"UpS\x06\xcb\x7f\x88I\x9fg\xd8\xb5\xcf\xc3\x19^" +
	"\x82\xc2\xe7\xce\xa4\x01\xdf%\x01j\xafsf!\xec\x9c" +
	"\xc9\xf2\xfd1iH\x02\xd4\xde\xe0L/\x1c\x9c\xc9\xf2" +
	"\xd5\x9845\x01joJ\xe64(d\xb2\xfc\x1d\x98" +
	"to\x02\xd4\xde\xa2\xccR\xb8(\x93\xe5\xd7a\xd2+" +
	"\x99v7\xdc\xa6\xcc*\xb8%\x93\xe5\x0f`\xd2\xb1L" +
	"\xbb\x1b\xeeH\xe6Jx\"\x93\xe5/eh\xc0\xf7J" +
	"\x80\xda\xeb\xc9,\x86\xfd\x18\x96\xaf\xc4\xa4\x9b\x13\xa0\xf6" +
	"&1\x93\xe1\x14\x86\xe5\xe7b\xd2\xdd\x09P{w1" +
	"\x93\xe1\"\x86\xe5\xd7a\xd2+\x8c\x1djo\x133\x0b" +
	"naX\xfe\x13L\xfa\x8a\xb1C\xed\x1dgf\xc1\x13" +
	"\x0c\xcb\xe7f\xd1\x80\xe7\x12\xa0\xf6.\xcb\x1a\x03{f" +
	"\xb1|\x19&U&@\xed\x8d\xcf\x9a\x06\xfdY,\xaf" +
	"a\xd2\xdc\x04\xa8\xbd\xd9Y\xa5pv\x16\xcb?\x8eI" +
	"k\x13\xa0\xf6Vg\x15\xc2\xd5Y,\xff\x06&\xfd5" +
	"\xcb\x0e\xb5\xf7v\x96\x17\xbe\x9d\xc5\xf2'\xb3hP\x95" +
	"\x80\xb4w6k\x0c\x04\xd9v|>\x0bio@v" +
	")\x1c\x90\xcd\xf2\x95\x98ts\x02\xd2\xde\xa4\xec\x1a8" +
	"%\x9b\xe5\xe7b\xd2\xdd\x09H{we\xd7\xc0E\xd9" +
	",\xbf\x0e\x93^\xc9\xb6#\xedm\xca\x9e\x0c\xb7d\xb3" +
	"\xfc\x01L:\x96mG\xda;\x92=\x06\x1e\xcff\xf9" +
	".\x9d\xb0U\x95\x80\xb4\xd7\xadS!\xec\xd6\x89\xe5\x87" +
	"`RY\x02\xd2^I\xa7<X\xd2\x89\xe5\xa7bR" +
	"(\x01iO\xecT\x05\xc3\x9dX\xfe^Lz\xa4\x93" +
	"\x1dioi\xa7B\xb84\x01\xba\xcfB\xda\xdb\xda)" +
	"\x0fn\xed\xc4\xf2\x070\xe9X'\x17\x887Z`Q" +
	"\xa3\xd6\x02\xc4V\xa9\xc1\x0bP\xa3\x81\xb0GBT\xaf" +
	"\x9f(\xfc\xc9\xa1\xfe\x9b\xcds\xb6&Z[\x8b\x94j" +
	"D\xe5\xb4 pV\xac\xd4d-n\x8cC\xf6\xcd\xe9" +
	"\xf1\xe7w\x0ajB\xbf\xb5:\xe7\xd8z/\xa6o\xea" +
	"c22\xb3\x0c\x17V\xf4\x969\x17,\x93\xee}>" +
	"\xde\x84'\x1c\x16\xaaQ#\xc5h-@\xd3\x8c09" +
	"\xd9\xf8\xc0N\xff\xae\xf8\xa5\xcb\x87\xd7?a*\xc3\x81" +
	"\xa6@\x08\xa5\xcd]\x1b\x819\xf4\x87\xcfL\x9a\xf9\xcc" +
	"o\xdf\x1e0\xef\xbc\xb9\xa8\x7fP\xce]\x02\xda\x9d\xd6" +
	"N\xa8\x08\x9a\x8d\xa4\xde=4\xfd{\xffmWn1" +
	"\xc70M\x16\xa5JA\xd1(\xa0\xa6\xfd\xdccdQ" +
	"\xf2F\x04\x85bL\xcbm\xf5\xd4\x8b\x16\xcd;\xf2\x8a" +
	"\x89\x82c\x84\xf0\xd3:]\x8dV4\xe4\xf1\x09>\xba" +
	"\xb1\xd7\xeb\xf7\x1c\xb0 \xdd\xe4\x99i#\xb5\xde\xe2q" +
	"\x98C\x7fx\xd5\xba\xe0\xaf\xbbU\xf60;\x91\x1a\xd0" +
	"\xc3i\x7f[\xc79\xd6\x1f\xef\xfa\xc5\xeb\xab\x9f8\xd9" +
	"\xfdU\x9b\xdf\x16\x9b57R9\xb2\x12T\xd3n\xa2" +
	"\x09:+G\x15\x93,r]\x9ewK\xf6+y\xbb" +
	"\x16[\xdd\x82\x0cyi\xa3\xa0\x86 \x1dF\xe9_\x93" +
	"\xbf\x9av\xf9\x88\x9d\x0f\x98h\\\xa1\xa8\"\x84\xc4Y" +
	"\xe9\xfd\xc8\x93c\x95&\x9f\x09\xc4\xf6\xf6O\xae\xb9\xa7" +
	"\xeb?oz \xee\x12\xd0[\x95\x00!T\x85B\xbe" +
	"\x9ai\x8cs\x02\xa8\xe9\x17\xd8\x1c\xab\x8a?\xc1)(" +
	"\xe4\x95\x8bIB\x84.\xbe\xd3\x1f\x87\\\xf9\x8d\xfb\x9d" +
	"c\x09\x00_b\x03\x02\xbap\x14\x00ZZ\x84\xbf*" +
	"\x93_\x17]3-\xc7\x12\xfdyva\xcf_^\xbe" +
	"u\xe5\xf9s\x8cL\x10(:\x9c\xfeL\xab2\x19\x99" +
	"\xb01\xa1\xcb\xe0\xc0\xd9\x9f\xf6X\xfe\xe4y\xeb*\xa4" +
	"\x0b\xc4\x87r8\x12\x124\xd4\x02LZ\"\xb3\xde\x8b" +
	"\xfb\xaa\xe3Cw\xbc|\xfd\x99\xf8\x10\xd5\x88,\xb5\x04" +
	"\x07Y\x15\xab2\xf9\x8c\xd3\xe9\x8d'\xa7\xab\x1f\xfe\xf8" +
	"\xeagS\xe4\xe4\xb4\x00\x096+.\xaa\xd8\xab!\xd3" +
	")\x94$o\x8e\xa2g\xd9\xa5\xdd\x14F&\x9e\x81-" +
	"\xf6M\xed\xcfN\xe7\x8c\xddq\x87yD(\xf2\xcc\x16" +
	"\xc0h\xab\xe4\x99\xd6\x05\xf2\xa3\x99o\xed\xbcp`\xaf" +
	"C\xe6\x19\xa1\xc83\xd5\xb4\xf7\xd0\x98X\x95<S5" +
	"\x9e\x07]bs\xfd\xa3;\xdf\xb0\xe7\xe1C6h3" +
	"\xc30K?\xb1\xa6=hN\xec\x8e\xb1/\xaf+\xbf" +
	"\xbb\xef\xc7\x16\xc8Z}\xb4\xb66\x94~\"x\x9d\xc7" +
	"\x18\xc9\xdf\xbb\x07\xdd5\xd7{\xac\x10\xa5*Ju\xd1" +
	"\x10>\x8c\xc5Y\xe9#M\xbc\xc9\x99#\x9a\xd7\xf4s" +
	"\x9e\xe3\xf3\xde\x1c\xfe\x82\xd5\xc5Y\x0d\x09j}\xab\xae" +
	"i\xde\xe4\xb4]\xd3\xdb\xaf\xfe\xf0\xd9K\xeb\xb7<\x1a" +
	"G0\x13$\xbc^(:\xad\xb0i1\xded\xcc\x89" +
	"\x7f\xb1\xc0\x8b\xc7n\xda\xf1\xe8IK\x96&G\"$" +
	"r\xd0\xc2\x84\x9b|\xc6\x84\xbf\xf5\xb3O\xa5\x8c[w" +
	"\xc4\xeb(E\xad\x05\xd5\x81T\xcb\x19\xf7\xd2\xb5\x9b\x9e" +
	"]Q\xfe\xe8_\xa8\xb6:A\x93\x1d\x1bZ\xa3\xd6\xaa" +
	"` \x16\x90\x14\x0c\xfc\xd9{\xdd\xae\x10\x0f^x\xd4" +
	"\xeab\x1b\x89\xb4p7\x92\x8cD\xa3\xaf\xdb\xd8_\x8c" +
	"\xcc~i\xce\xdes\xe6QuE\xbc|@\x90$\xd4" +
	"jH\x86\xbcf \x19D)\x12\xd58\x95\x08ct" +
	"\xd0\x00.\x8e\xc8\xf0v\xa1\x81%\xe2\xff\xce\x8e\xc8p" +
	"\xa6\xd0s\x86\xe5/\x05\xd8\xf2J\x08\xc6\xf4\x04\xddI" +
	"W\xa2\xe1\x984.!\x18S\x01\xf2aE\x02\xbc\x9b" +
	"e\x0e\xcf\x00c\x12\xe1\xdd\xe2\xe6\xf0\x0aPJB8" +
	"\xafa\xd2[\xc0n\x0e\xef\x06\xf9p7`\xf9c\x98" +
	"t\x1a\xd8\xcd\xe1S\xa0\x10\x9e\x02,\x9f\xeb\xc2F\x99" +
	"\xab\xadME\x87n\xdc4\xea\x91\x9b\xa7\xaeoW[" +
	"\xd0\xfb\x8b?\xd3\x16\xfd\xeb\xb9{[U\xc5\x93\xc7\x94" +
	"\x18\x17\xe4\x07c?\xd9\xff}\xe1\xee'\xac\xa0\x893" +
	"\xba\x85-hbaZxg/\xf0J\xc7\xf6<\x1e" +
	"\xbf%\xf4\"\x98\x96o\x1b\x83\xcf\xd8\xa3\xe5\xbf\xbc\xec" +
	"\xd9\xbaW\x9f\xbe\xa3\xfd\xb7\xc3\xe6\xbc\xcb\xce\xd4\xcf\xfb" +
	"\xb1\x199\xc8QQ(\xbd\x12\xcc\xa3\x901m_\x1e" +
	"\xfd\xe4'\x0f*\x9d-G\xfb\xccf\xd4\xbe\xf8\x9c\xdf" +
	"\x18W\xf6\x1e\xf5OZp\xefg\xdf\xff\xa6\x99\xdc\xef" +
	"\x8e\xf4\xd2\x18\xdd\xda|\xd8<\x10\x1b\xa9\x88H\x0a\x86" +
	"\x9ah\x0b\xed!\x9e\x18\xdbG\xe5\xa6\x8b\x8c\x14\xecH" +
	"G\x1e\xaaX\xf7n\xb61\xf7.?',LG\xe9" +
	"\x92\xef\xf2\x1dk\xe6\xf3\xcd\x9a\xf9\xbb\x9b\x8f\x9b\xc4\xcf" +
	"\xac\xe9\xa2\xd1\xea&\x19\x9eNP\xd2FL\xf2\x09\x83" +
	"\xbd&\xed\xf5\xdd\x83O\xaf\x9c\xfc\xe5I\x87\x9a4\xfd" +
	"\xd0k\x7f\x9b\x8e\x0au\x82\xacU3J\x14u\xb4\x16" +
	" \x8f\x91d\xcd1\xd9\x97\xb4\xf80\x9c\xc1\xa4\x84T" +
	"\x8eDdU\xd4\x90\x0d\xf6\xacY\xc7-\xc9\x17Hj" +
	"\x16\x94\x90\xa2Q%\xcf\xech\x04)\x8fQ\xe2\x81\x15" +
	"\x87\xb2\xdf\xc9 Vb\xd4h\xb9\x09@\x19'\xa8\\" +
	"DP4\xbd\x04\xafN\x91\xa3\x11\xfcOL\xa2\xd5\xf3" +
	"\xdf/\x12/{\xac\x06v\xbc\x93;\xd67\xd3\xbc\xf8" +
	"\xc5 6\x8a\xbc\x9c\x86\xe8F\x03\x00@\x8d\x06\x02H" +
	"U\xc5\x06D\xde7\xa5\x93\xfbyz_|0\xb6y" +
	"\x9b\xe3\xe3\xd6\x01\xf9\xa0\xb9\xf3FG>H\x1f\xff\xa9" +
	"\x904\xb9\x0a\xb1\x81\x8e\x84\xb8\xe2\x9d\xcc\x14\x14h&" +
	"\xc4\xf5\x17\xab\x07\xa4+^\xda\xa9\x17\xed\x81\xf3\x0fG" +
	"\x87g\x1c+\xbe\x1d\x85\x97I\xa8\xd7J\x09\xcdz\xc0" +
	"Q+2\xeb\x1285,\x84B\\\x8d\xa8\x07\xf4r" +
	"Rk\xb4\x1cB:iRs\xf0\xf8\xf1W\xd2S\x95" +
	"[\xd4\x07K\xe3\x99\xca\xee\xd4Le\xf3\x0b\x18q\x12" +
	"\xca?$\x1e(i\x02\x0a\x9c\x0dX\xfeq\xacw\xad" +
	"MH\xd3Y\x0dJ\xe1j\xc0\xf2ob\xd2\xfb\x09\x9a" +
	"\xe1\x1eP\x0a\xf7\x00\x96?\x8dI\xee\x84|e\xe0Z" +
	"\x03\xb3\x13\xb2\x9c-\xcdp\xa8k\x19,q\xb1|=" +
	"&i\x09\xf9\xca3\\\x93a\xd4\xc5\xf2\x0fc\xd2\x13" +
	"\x09i:+\\\xb3HV\xcd\x9b\x98\xf4~B\x9a\xce" +
	"\x1eW!\xdc\xe3b\xf9\x93.\x1aT%\xa4+\x9fu" +
	"\x8d\x81\x80f\xf9^4\x0d\xf8\xab\x12\xd2\x95\x07\xd0\x93" +
	"\xe1@\x9a\xe5\xab1ijB\xba\xf2\x14Z\x81\x02\xcd" +
	"\xf2wb\xd2\x03\x09\xe9\xca\xf7\xd1\xdb\xe0R\x9a\xe5_" +
	"\xc3\xa4\xb7\x12\xd2\x95w\xd3\xf9p7\xcd\xf2\xc70\xe9" +
	"4m\x8f\x93\x9c\xa2\xf3\xe0)\x9a\xe5s\xddXuu" +
	"\xbb~\xa0\x8eR\xb3\x12.\xadr\xa8\xd7\xdd\xd5\x1a\xca" +
	"\xe1\xc13#\xef\x0c\xde\xff\xce{\x0e\x8e0\x958\xab" +
	"r\xa6\xa5\xf7\x84m\xb3<a.!\xa4\x9a\xfe*\xdd" +
	"]\x85\x87x\xcb\xd1\xb1\xb9'7\x1e\xda\x9c\xe2\x0aS" +
	"\x0d_\x18\x9dV\xfc\x86\xb8/\xcc\x14\xce\xc6\xfdl\xaf" +
	"\xde{\xeb7\xb3\xc7\x1e\xfc\xeb\x7fB\x96\x10\xab\x86\xc4" +
	"@z\xeb\x9a'\xf0\xe4d4O\xbd\xf7\xb3\xca\x05\xbd" +
	"\xae=\x1ew>\x88\x01T\x8e\x95\xb9\xf4.p]\x04" +
	"\x92(:\x98F\x10\xaf\x09\x14\xad\xa4o\xae\xa0KR" +
	"5*G0\xd1\xd1\x9b\x95\xc5*Z\xb9c\xd5W|" +
	"\x86Lq\x00KCRP\x87\xe9K\x91\xf8\xef\xc1u" +
	"oS\xe2\x95\x0f\xa2\xa7\xab^{\xf9\\&^\x8d\xc3" +
	"J\x0b\xd5q\xd5\xa9\x1e)(M\xd2Q\xf7x\xd2\x11" +
	"-\xdb\xca\xb5\x89\xced\xdc$t\xf2\x05W\x18\xbf\xe0" +
	"X]\xb9J\x9f\x8b\"\xaaZ\xb5\x90\x83\xd5\x846\xa3" +
	"\x1e\xb3\x11\xef8\xb9\xdd\xa0*\xd7Y\xf7{H\xae\x8b" +
	"+\xfdAT\x13\xad\x8b\x97g\x97\xe1\xff\xc9\x85d\x92" +
	"\xc4\xd4\x0c\xb2\xb1#n\x10\x1bB\x0d(df\x8c\xe9" +
	"0\xc7-avFQZ@c\xac\xd1\x94\x0b\x81\xfa" +
	"\xf6\xe6\xbe\x04m\xe9wF\x8f\x0a\xd0\x0c\x94\xccbW" +
	"l\x9c,GTNn\xc8\xd6QKS0\xd8#\x82" +
	"\xaa\x1a \xec\xfd\xf1\xd2P\xa2\x92\xaa\xa7b\xa3\x90\x8a" +
	"\xfa\xc4\x01e\xc4Z\x1d\x19\x06$\x01\xae\xe7{\x04\xd6" +
	"?W7E-\x03\xf5\xae\xee\x9e\xbbX\xffoi\xe0" +
	"\x7f\xc1\x96\x83\xbd>\xcf\xb3\x9e\xf5\xbf\xa5w$\xb0P" +
	"`\x8e\xe4{\x8e\x14\xf1\xbd\xb0\xf2q\x15p\xb5\x08\x19" +
	"\xed-\xd6\x9b}8\xcdq+qY^\x1a\x94q\xef" +
	"\x17/|\xbb\xf6\x87\x8dp\xeb\x8f\xca\x9a\x88r$\xad" +
	"\xe3\x8d\x8a\xf3\x98\xa0\xd8\xe0\x8cF\xf7u\xacLl\x10" +
	"\x83\x88\x93]\x122\x91\xa4j\x9a8A\x92Y\xad^" +
	"oS\xfc?\x0eUZ\x19\xd5\xca\x83u\xed/\x91\x1f" +
	"\xdeR5)V1J\x82A\x02F\x06BQ\xc4i" +
	"\xb2\x0d\xc2\xa2}\xa5\xa3^\xcf\x0c\xd6\x7f/\x0d\xfc\x8f" +
	"\x9c\x87\xd2\xd1s\x08\x89Q)(B\x9d\xc2\x08\x91\xfa" +
	"\x8ez/.\x06\x914&\xfc4`L\xb1*\xba\x09" +
	"\xc8LMH\x90\xa6\xeb^\x8cZ9\x14\x92g\x8aR" +
	"\x1d\xa7\xcaad\x99\\\x090\x09J]4\x8c\x18I" +
	"G{nS\x9a\xb2@\x1e\x954\x1b\xc0\xd1\x98\x98Q" +
	"V\xa1R\xcd\xa3\x1c`=\xbdU\xbe/\xac\xb2w\xd4" +
	"\x14\x1f\xde\x0aS<\x15\x16^)&\x86\xf8\xbf\x05\x16" +
	"^\x07\xaa\xcdi\x835\xde,\x84A\x825\x9e\x9c\xb1" +
	"\xb9\x10\xc4*\xc5\xc0tN\x96P\x06\xd1Of\xca\x9c" +
	"\x81\x04g\xaf\xc6\xaf\x91\xe5\x10\x12$\xd2\x17\xa4\xa0\x15" +
	"\x05\xde\xdd\x1dwi\xa1}\x97jJ\xd4\x01\x9b\x98\x16" +
	"k\xd3C\x19\xd4:\xf5\x11gI2w\xda\xcdm\xdd" +
	"\x02i\xd2A\xf1\xd2\xe2\xe5\xa8\x12@#E\x14*\x0e" +
	"\xaa-gW\xeeK\xa8\xed\xa93j{jE\x14\x0a" +
	"\xd2f\xbb\x143\x8a\xa4\xf7K1\xae\xefx\x14\xe9\xae" +
	"<\xdb\xfd\x1d\xef\x1d\xb4\xbe\xc6\xb3\x91\xf5\xbfO\x03\xff" +
	"'6/\x81\xe7`\x9e\xe7 [\x05\x0cX{F\xae" +
	"\x99\x96\xf6\xb5}5\xd3\x8c\xc0B\xf0d\x16\xf3l\xff" +
	"5m.)\xe9\xf1\xd8w \xf6\xdfw\xfdw\xa2\x95" +
	"f\xa0Q\xb7\xc2\xe4\x1b)R9(d\xd8FO\xaf" +
	"(\xf8\xc7\xd0lfw\x9bU\xfb\xe3/\xff>xO" +
	"\xe3Q'X\x9b\x12\xa9\xe9\\a\xbaHMm\xc3t" +
	"\x91\x9a\xce+\xa6\x0b)\x18\xc1\xa6~\xb1\x1c\x10B\xed" +
	"\x87\x9f\xab\xb7\x8cU\xd3\xd9@\xd1q\xc4KG\xfc\xb9" +
	"eqx\x97l\xfc~b8\x12\x12Q\xd0\xc2\xa1\xb3" +
	"\xc1\xd0Y\x98s*\xd9::*D\x0a\xe8\x9c(K" +
	"tA\xbf\xff\x9d\xa0s\xc4\xd2\xa6:\xbe\xfe\x88u\xdf" +
	"\x8cu\x01b#H\xb2:'dpz\xc7\x14U3" +
	"a\\U\x14\xc0oI\xbe\x89\xad8\x14\x14\xb4B\x9f" +
	"*\xf4T\x14Y=\x9c\xcc\x93zQ\x9egQ\x91\xd9" +
	"Q\xa398W\x92\xd6\xdf6e\xbcP\x7f\xc8I\x05" +
	"e\x90\x14lkm\x0a2Bm\xcdi\xb3.\xb2\x7f" +
	"d%h:\x84s\x9a?\xd0{\xc5\xa3>\xadp\x08" +
	"\xeb.y\xfd\x84\xef\x1b\xf7\x09g\x03\x05v\x06,\x7f" +
	"\x15>\x9f\xafK\xf0\x09\x0f\x05\xa5p(`\xf9\x9b1" +
	"\xa9>\xc1'\x8c\xc0d(\x02\x96\xbf\x1b\x93\x1eN\xc8" +
	"\x16X\x02f\xc1\xa5\xcd\x95n\x166_\xba9\x86\xc4" +
	"\xfd/u\xd1\x80\xef\x95\xe0\x13\xee\xe9\x9a\x0c{\xbbX" +
	"~4&U'\xf8\x84\xfd.\x05Nt\xb1\xfcm\x98" +
	"tgB\xe9\xe6\x02\xd76\xb8\xc8\xc5\xf2/c\xd2k" +
	"\x09\xa5\x9b[]yp\xab\x1d/\xe3\x07\x9a\xd1\xfa\x7f" +
	"\x8e\xca\xffsT\xb6\xaa\x01\xe5\xb9\xf06\xeah99" +
	"\xf8\xc8iGt\xbe2\xaa\x95h#s\xcc^!\x1d" +
	")HJ0\xc2\x1d\x91\x13\x17\x03\xd2!\x18\x1b\xe3\x19" +
	":\xa6\x93&\xeb\xf0\xc7\xf8\xf7\xf5+\xc5\x84\x0d\x95\x15" +
	"=\x8b\x03\xb4\xdfP/\xb5\x9b\x00\xa4So\x97X\xf9" +
	"ek'\x1d|\xed\xf5\xc5m\x07\x1bN\xba\x92\xe6\x08" +
	"\x1a\xe9\xb0\x92\xde/\xa5\xb5T\xcf\xa8\xaf\x99v\xe7\xca" +
	"\x8c\xb8\x1aX\xdbV\x8d4\x7f\xa5\xef\xca\x89\x8d\x97\x83" +
	"bm\x13'\\o!\xc5\x0a\xc1 6 \x04\x09\xab" +
	"Za\xb9\x81\x00\xd5\x1bn\xc4\x02n\x82\xac!\xaf\x8e" +
	"\xef\xdb\x14\xb12k,7c\x0d\"\xcf\x06\x83(\xc8" +
	"\x85\xa3\xaa\xd9\xd9\"\x99\xdf\x00\x8e@\x8d\x04\x86Z\xe3" +
	"j\x90\xf1\x0cA\xa5\xb5\x00\x85\xf5~\x09\xfd\xcd\x7f\xa4" +
	"\xe3%\xf1Q\xae\xc2h\xcbd\x02\xec\xeb\xf8\xf1\xa2\xca" +
	"I\xa8\x8e(\x8d\xfd9Q\xe3f\x8a\xa1\x10W\x83\xea" +
	"\x88OT\xc0c\x94\x9a\xe2\xaf`\xa1S )h\x8e" +
	"WP\x14\xa1\x89\x88'`\x15\xff\x1fsg\xcf\xdb4" +
	"\x10\xc6qR\x03\x11\x12\x8bGXbe,R\x1ce" +
	"\xa0R\x90\xa8\x12)EE\x80R\x151\xb0\xb9\xc9%" +
	"\xb1\xa8\xed\xe8\xeeL\x13\x16T\x89\x89\xbdC7\xc4\x90" +
	"\x89\x91\xb1H\xccL,\xb0\xb0\xf1\x11\xd8\x98\x8a\xee\x9e" +
	";\x9f\xdf\xdd8Q\xc4\xdc;\xfb.\xf5s/\xcf\xcb" +
	"\xefO\x8cc\xe4\x8e\xe9\xc4\xb8\xa7^\x17-\x8dl\xc6" +
	"_\xc4\x9f\x0a\xc3i\x06\xe3\x84\xc5\x00@s\xac\xbfc" +
	"\x13b\xbbc\xde\x17\xfeF8\xb5196x\xa5\xb0" +
	"\x13\xe4\x0e\x1f\xb0\xcb\x80\xcd\x1f\xd2dF\xa2\xe6\xebz" +
	"\xaa;\xbb\x16\xc0s9\xdb\xbbPG\xb3\x95\xaa\xa3\xd9" +
	"N\xd5\xd1l\xafOGS\x9c\xeb\xf2\xfc\xee\x99\x87\xb8" +
	"]\x98_\xeeN\x06MR{\xdb|A\xcf\xed\x0dM" +
	"\x0a}\xfe\x87\xd3\xf2\xa5\xba}U\xef*\x13\x81\xafU" +
	"2=m\xed@\x1c\x80j\xcc\xa2xa+\x99Z\x03" +
	"\xc4\xec\x91\x9e \xe4\x1aP\x90\xd1\xd8\x84JP\x87<" +
	"\x9f\xd15\xe89\x85\\FQ\x12`=K\xcf\x89+" +
	"\x04\xc0\x97U\xdd\x84\x9aS\xe0\xa6\xd4\x80\x04{\x85\x14" +
	"!uK\xb4\xf08\xdd;YDP\x0e\x139\xa5\xbc" +
	"V<\xd3\xaf\xf4\xfe\x15\xa9\xf0\xe5\xf0\xc7\x1a.vA" +
	"\xfd\x8e\x09X\xfb\xae\xe0\xcb\x1c\xfbU\x80\xcb\xdcV>" +
	"\xa8^K\xef\xd5$\xddR\xf9\xa0\x9c\xbb!\xbc\xa5\xf2" +
	"A\x9d\xb5\xf4\xb3\xda\xc1g\xadr\xf0u\xabR\xb3F" +
	"\xb4@(\xb7\xc3Z\xf0\x99-n\xfc\xd8\xf9\xf9\xb0\xf1" +
	")\x08\x16\xd1\xdc\xef\xbb\x03&\xfd\xf8\xcb\xb7\xbd\xc5\xf7" +
	"\xfb\x17r)\xe2@\xcf\xdc7\xf6X\x0b\x90T\x7f\xf4" +
	"kq\xf1\xf7O*\xd0\xe9\x85\x85WgP\x87\xc8\x8d" +
	"\xa9'\xa9\xae\x92p\xba.\xa1Nr\x0b\x03\xee\xab\xec" +
	"\x94(Z\x0fY\xc7\x8ad\x8e\xe4'\xb4\x8by\xf5\xe1" +
	"\x92&\xd2\x82\xdf>\xab\x8e=\xba\xe4<\xf3\x9d5," +
	"9\xae\xef,)!'\"h\x9b\x95\x90\x83\xfb\\_" +
	"\x80\xa2\x96\xfcY\xd9\xf6\xe7\x0e\x11.$\xb8t\x0bS" +
	"\x91%\xab*'\x1b9\x97g\xb5\xde\x84d\x0f\xd3\xee" +
	"<O\xdf03_\xb3\xfb\xf6h\xce\xfb\xc5O\xc9\x99" +
	"\x0a3%\x85\xbe#j[\x16'\xd5\x96\xfej?\x04" +
	"\xff\xcf\xb1xR\xda\x09\xff\xfd\xcd\x80\xf4v'Iz" +
	"\x0b\xcb/E\x85\x1f\x00Y\x0c\xf86\xcf\x1d \xae\x1b" +
	"\x1dB\xb8\x89t\x02\xe8\xbeOY\xfbb\xa5\x08\x8b\xa4" +
	"R\xe0 \x19A)EXD\x0c\x14\xcbt\x05q\xce" +
	"\x85\x89\xc6\x82?u\xb6\x9b$\x84#\xb6C\x97\xbc\xe0" +
	"\xe4z\xde\xd2\xcfwd<cE\xa9\xf7\xd2r4\xc0" +
	"{\xdb\x04\"N\x16D\xcar\xc8U3P\xde$\xea" +
	"1\xb3Bz\x1f\xb7.\xfb\x16&\xc8\xa0\xe8\xd6\x8c\x0a" +
	"\xa9\x7f{4\x9a\x1bT\x8c\x864\x8cC\x84\xda\xc6\x84" +
	"\xd2)i\x9b\xe6\xd8\xa6\x13\xff\xa81\xf0\x1c\xd3\xf6\\" +
	"\xcf'&kn\x9e\xd8\xafl\x13fP\xa5(\x16\xf6" +
	"|\xa9\xeb\x81E^\xa2\xd9\x14#Bl\xb69d\xc3" +
	"\x89s<\xe8{\xd8s\xba\x9eV\x1e\x0b\xf5$\x15\x0b" +
	"\xb5\xacV\x84\x0cs\xbe\xae\x09\xa0N\xbeVDV\x81" +
	"\x82\x8a\xdf>\xf5p9\x85\xd1\xfdQ\xa2P%\xcc-" +
	"Os\xb8\xd4\xa5\xc3\xe5]\xc8\xeaN\xb7\xf5\xd3\x00\xc5" +
	"\xa8\xd9\xa3\xe4\xa8\xff\xc7\x8c\x9cD,V\x1b\x92+:" +
	"\xd2\xfe\x05\x00\x00\xff\xff\x07\xcd\xff\xda"

func init() {
	schemas.Register(schema_ad22bd0042f92910,
		0x8051c827086156f0,
		0x808f6775394e1045,
		0x812dd1a8ad7759f9,
		0x81e4d9ea503dc431,
		0x836331ec00b62435,
		0x83be7cf8769eb08b,
		0x84abbf67ae1d8745,
		0x84c64b0ff85b66f7,
		0x854220714e20cf36,
		0x85d5302c0f03b62c,
		0x8695311806f91e69,
		0x86a9f42c4d4b8949,
		0x887e2baa365457ac,
		0x88b9bf32c2da2936,
		0x8a104f955ecccb16,
		0x8aae1e7149605b6f,
		0x8ac65f056ee65bd0,
		0x8b0eceb92e275c06,
		0x8b61b7396e31a557,
		0x8b79c6e49242c134,
		0x8c2db996afe65923,
		0x8d17a2775ccd468a,
		0x8d1c50198e64b0a5,
		0x8d565c5237432e42,
		0x8db440cc81ed11af,
		0x8eca93874dc59221,
		0x8eecf20de39ce6fa,
		0x90affb8d74e73f93,
		0x90d7ac241860cf51,
		0x913361a0f4593621,
		0x92c7c4e159ac1d45,
		0x9458f6178f361ed1,
		0x94c943236a00f05a,
		0x96178f58af6d467c,
		0x9644289018e9cbc0,
		0x9743eec37d4e392f,
		0x97c95c24dd75b690,
		0x9d227eff4bd296d9,
		0x9d78ce9d70c0e19b,
		0x9db5944c71636a0b,
		0x9dea788f64c0b8ed,
		0x9e1117b3e9f744d7,
		0x9ebd6818aedc34c5,
		0x9ef7ea3ddadddb80,
		0x9f113e6204641aee,
		0x9f1b94a6ee096ce5,
		0xa0d5ec6e3a857d3a,
		0xa105248f353fe0f4,
		0xa11b8168f91d22ba,
		0xa1569a83b42c81a0,
		0xa16dc25e470c65a4,
		0xa1da6b401255eb1c,
		0xa240c704e3251c11,
		0xa2c12387213209e8,
		0xa3b0f7785a873f0f,
		0xa3fee7908559519e,
		0xa449468eb28ad189,
		0xa4684023b73fbef8,
		0xa47541b906ccf227,
		0xa4cd32fedde44bdb,
		0xa69d1ce67d31139a,
		0xa7400d2e03e80da1,
		0xa78edef01722c579,
		0xa86c622ed3cf1c7f,
		0xa9954603f517f5ff,
		0xa99e9b876aeb6d08,
		0xaa282bffe60f4044,
		0xaa2cae0708f464ef,
		0xaabc83a03b837d1a,
		0xab217d821f244430,
		0xac0239123e762137,
		0xac2e3ed637d505a6,
		0xacfab4eb900533b7,
		0xae341bdc736ba6c8,
		0xaeafaebf10861781,
		0xaf066240ac93ca80,
		0xb02c40488d6dcd7e,
		0xb053d8b85fa422b3,
		0xb1605c9c47b9b539,
		0xb1e14346fdd689e0,
		0xb30b5da348cf6bb7,
		0xb3656d55761343fd,
		0xb3906e9a0b7f5e75,
		0xb39c483c21864f2b,
		0xb67af87c95544ff6,
		0xb6919d1572e7b344,
		0xb7b9a0342f9379c3,
		0xb80b02b3b04983db,
		0xb84492e23931604b,
		0xb8c452ab65134fa4,
		0xb9ac809d387e2655,
		0xba2ce21e32f1c71a,
		0xbae2b5f4144bea5e,
		0xbb89bbff01fc9f1c,
		0xbc36d0a646cabd4a,
		0xbc62d4b545dce96a,
		0xbd2f7c51fe6be2d6,
		0xbe05fb96cb25d848,
		0xbea9252308c2097c,
		0xbf1af4a4a9c7eb17,
		0xbf584d588d5035bf,
		0xc218357175c250bf,
		0xc2856de8bae2a3a5,
		0xc2fdfeaf7471fcf6,
		0xc3b6afda5598b1a1,
		0xc3bce9818d0e60a9,
		0xc492499254cc9e46,
		0xc556aa603be2e808,
		0xc613ed9e87933b32,
		0xc74dad9d53f884e2,
		0xc86bf9018435c6ff,
		0xc9e51b196dbea45c,
		0xca4a7c7ae2b259a5,
		0xccdcec72f34d3b35,
		0xcd070939f32ea1ab,
		0xcd335f562bb0d63d,
		0xcd747719115e1999,
		0xcd83fd0f17413705,
		0xcdde9b01cd84fc1f,
		0xce8e609a9d423772,
		0xcec947b30cac496e,
		0xd1846848c3d37d77,
		0xd29e45a1aeb93b4e,
		0xd33644b52a685344,
		0xd392ca22bc09bd3a,
		0xd3b370f24d61e815,
		0xd3cab235b0032c0c,
		0xd4e14b7df75f90bf,
		0xd5c886733e12e583,
		0xd6a643d6039ea176,
		0xd76e3dd0e1d74770,
		0xd780fa78ccd503a1,
		0xd7d393648846f9e1,
		0xd82dd8f06a75baa5,
		0xd8858b33e34e486c,
		0xd97fb70946864bfa,
		0xd9f26bae90dbdd40,
		0xd9fa6a0210ede1b6,
		0xda5eae6d2cb4b33f,
		0xdb34e3e82af96202,
		0xdbafe9a684c47d3e,
		0xdc018eac657c47b3,
		0xdd2907c256b45ff2,
		0xdd36d3abe50e003c,
		0xdd4dd8322f7db61c,
		0xdd65c12e2085e492,
		0xddda77c6289520dc,
		0xde50d321776f40b5,
		0xdf288c45b0b84bc6,
		0xdf2e939571efc218,
		0xdf95941c6150b2a5,
		0xe071a1982c51cc6f,
		0xe08fc72478034f4e,
		0xe0dbb45e4742831d,
		0xe1163d1396252641,
		0xe137ffd715e06e2f,
		0xe224310cc9d07716,
		0xe298d5560d485180,
		0xe30d72961ee4eaef,
		0xe3a2743c8dfb4ad7,
		0xe3dc36ced14a87ae,
		0xe3f62895ddeecf83,
		0xe4abe2b03dff7cc8,
		0xe58557d333ec51da,
		0xe58f41cfd252caaa,
		0xe65505e94c48745a,
		0xe6f0752dbb696399,
		0xe6f17495ad724385,
		0xe6f4437448d57536,
		0xe79f6592e37beab1,
		0xe9356f4c2e196332,
		0xea0ce1692619d75b,
		0xeb835242fc94c284,
		0xebdf7695a5b7d624,
		0xecd304f72f38cb0a,
		0xed3b2485505bd7a7,
		0xee4d212526f6ffac,
		0xef087f977e163f61,
		0xeffa3400da8ff5d5,
		0xf3d6c196641054ba,
		0xf49ec658ecb66316,
		0xf4ea47e08563f0a2,
		0xf4ef5aa2f835cdc7,
		0xf6c2e4faed3a43c2,
		0xf77fe4fb65c4a80e,
		0xf7f2f9bca6db47ac,
		0xf8170ade78f3851b,
		0xf817fc4ee27b3949,
		0xf8197b1f0846744b,
		0xf8963ca96520c5f4,
		0xf93eb8c639ed3031,
		0xfa3fa772ea154c4f,
		0xfc4a8aca1a8b1a1d,
		0xfc90f4b91130aaf2)
}
